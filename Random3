import os

base_dir = "runcline"
if not os.path.exists(base_dir):
    print("‚ùå Ïò§Î•ò: 'runcline' Ìè¥ÎçîÍ∞Ä ÏóÜÏäµÎãàÎã§.")
    exit()

print("üöÄ AI Bridge v26: Path Normalization & Debugging Update...")

# ==========================================
# 1. Main Routes (Í≤ΩÎ°ú Ïä¨ÎûòÏãú Î≥ÄÌôò Í∞ïÏ†ú Ï†ÅÏö©)
# ==========================================
print("1Ô∏è‚É£ Main Routes ÏóÖÎç∞Ïù¥Ìä∏ (Ïó≠Ïä¨ÎûòÏãú -> Ïä¨ÎûòÏãú Î≥ÄÌôò)...")
main_routes_code = r"""from flask import Blueprint, render_template
from app.database import get_db_connection
import os

main_bp = Blueprint('main', __name__)

def normalize_path(path):
    if not path: return ""
    # ÏúàÎèÑÏö∞ Ïó≠Ïä¨ÎûòÏãúÎ•º Î¶¨ÎàÖÏä§/Ïõπ ÌëúÏ§Ä Ïä¨ÎûòÏãúÎ°ú Î≥ÄÌôò
    return path.replace('\\', '/')

@main_bp.route('/')
def index():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    
    query = "SELECT f.IPAddress, f.Account, f.DisplayName, f.FullPath, ISNULL(f.GroupName, f.IPAddress) as GroupName, ISNULL(f.TaskCount, 0) as TaskCount, ISNULL(f.TotalDuration, 0) as TotalDuration, CONVERT(VARCHAR, f.LastTaskDate, 120) as LastTaskDate, f.LastRuleContent, f.LastRuleName, f.CommonInstruction, CASE WHEN q.TaskID IS NOT NULL THEN 1 ELSE 0 END as IsQueued, CASE WHEN m.MemoContent IS NOT NULL AND LEN(CAST(m.MemoContent AS NVARCHAR(MAX))) > 0 THEN 1 ELSE 0 END as HasMemo FROM cline_FolderIndex f LEFT JOIN cline_TaskQueue q ON f.FullPath = q.ProjectPath AND q.Status IN ('Pending', 'Processing') LEFT JOIN cline_ProjectMemos m ON f.FullPath = m.ProjectPath ORDER BY f.LastTaskDate DESC, f.DisplayName ASC"
    cursor.execute(query)
    rows = cursor.fetchall()
    
    # [ÌïµÏã¨] Ïó¨Í∏∞ÏÑú Í≤ΩÎ°úÎ•º Í∞ïÏ†úÎ°ú ÏÑ∏ÌÉÅÌï¥ÏÑú HTMLÎ°ú Î≥¥ÎÉÑ
    for row in rows:
        row['FullPath'] = normalize_path(row['FullPath'])
        
    cursor.execute("SELECT SUM(TaskCount) as TotalCalls FROM cline_FolderIndex")
    stats = cursor.fetchone()
    total_calls = stats['TotalCalls'] if stats['TotalCalls'] else 0

    conn.close()
    return render_template('index.html', projects=rows, total_calls=total_calls)

@main_bp.route('/settings')
def settings():
    return render_template('settings.html')
"""
with open(os.path.join(base_dir, "app", "routes", "main_routes.py"), "w", encoding="utf-8") as f:
    f.write(main_routes_code)


# ==========================================
# 2. API Routes (ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä)
# ==========================================
print("2Ô∏è‚É£ API Routes ÏóÖÎç∞Ïù¥Ìä∏ (Í≤ΩÎ°ú ÎîîÎ≤ÑÍπÖ Î°úÍ∑∏ Ï∂îÍ∞Ä)...")
api_routes_code = r"""from flask import Blueprint, request, jsonify
from app.database import get_db_connection
from app.services.ssh_service import send_rule_via_ssh
import subprocess
import os
import json

api_bp = Blueprint('api', __name__)
BRIDGE_API_URL = "http://192.168.0.10:9111"

# --- [DEBUG] Git Logic ---
@api_bp.route('/git/commit', methods=['POST'])
def git_commit():
    data = request.json
    raw_path = data.get('path')
    message = data.get('message') or "Auto-commit via AI Bridge"
    
    # [DEBUG] Í≤ΩÎ°ú ÌôïÏù∏Ïö© Î°úÍ∑∏
    print(f"\nüîç [Git Request] Path received: '{raw_path}'")
    
    if not raw_path:
        return jsonify({'status': 'error', 'message': 'Path is empty'}), 400

    # Í≤ΩÎ°ú Ï†ïÍ∑úÌôî (ÌòπÏãú Î™®Î•¥Îãà)
    project_path = os.path.normpath(raw_path)
    print(f"   -> Normalized Path: '{project_path}'")
    
    if not os.path.exists(project_path):
        print(f"‚ùå Error: Path does not exist on server filesystem.")
        return jsonify({'status': 'error', 'message': f"Path not found on server: {project_path}"}), 404

    logs = []
    try:
        is_repo = os.path.exists(os.path.join(project_path, '.git'))
        
        if not is_repo:
            logs.append("‚ú® New project. Initializing Git...")
            subprocess.run(['git', 'init'], cwd=project_path, check=True)
            subprocess.run(['git', 'config', 'http.sslVerify', 'false'], cwd=project_path)
            subprocess.run(['git', 'add', '.'], cwd=project_path, check=True)
            subprocess.run(['git', 'commit', '-m', 'Initial commit'], cwd=project_path, check=True)
            logs.append("‚úÖ Init & Commit Done. (Please set remote manually)")
            return jsonify({'status': 'success', 'output': '\n'.join(logs)})
        else:
            # Existing Repo
            subprocess.run(['git', 'config', 'http.sslVerify', 'false'], cwd=project_path)
            subprocess.run(['git', 'add', '.'], cwd=project_path, check=True)
            
            commit_res = subprocess.run(['git', 'commit', '-m', message], cwd=project_path, capture_output=True, text=True, encoding='utf-8')
            if commit_res.returncode == 0: logs.append(f"‚úÖ Committed: {message}")
            elif "nothing to commit" in commit_res.stdout: logs.append("‚ÑπÔ∏è Nothing to commit.")
            else: logs.append(f"‚ö†Ô∏è Commit Info: {commit_res.stdout}")

            # Check Remote
            remote_check = subprocess.run(['git', 'remote'], cwd=project_path, capture_output=True, text=True)
            if remote_check.stdout.strip():
                logs.append("üöÄ Pushing to remote...")
                push_res = subprocess.run(['git', 'push'], cwd=project_path, capture_output=True, text=True, encoding='utf-8')
                if push_res.returncode == 0: logs.append("‚úÖ Push Successful!")
                else: logs.append(f"‚ùå Push Failed:\n{push_res.stderr}")
            else:
                logs.append("‚ö†Ô∏è Committed, but no Remote URL found.")
            
            return jsonify({'status': 'success', 'output': '\n'.join(logs)})
        
    except Exception as e:
        print(f"‚ùå Git Operation Error: {e}")
        return jsonify({'status': 'error', 'message': str(e)}), 500

# --- Existing Routes ---

@api_bp.route('/open_vscode', methods=['POST'])
def open_vscode():
    data = request.json
    target_ip = data.get('ip')
    user = data.get('account')
    path = data.get('path')
    try:
        if '\\' in path: path = path.replace('\\', '/')
        settings_dir = f"{path}/.vscode"
        settings_file = f"{settings_dir}/settings.json"
        clean_config = { "workbench.startupEditor": "none", "workbench.tips.enabled": False, "update.showReleaseNotes": False, "security.workspace.trust.enabled": False }
        json_str = json.dumps(clean_config).replace('"', '\\"')
        if target_ip in ['127.0.0.1', 'localhost']:
            os.makedirs(settings_dir, exist_ok=True)
            with open(os.path.join(path, '.vscode', 'settings.json'), 'w') as f: json.dump(clean_config, f, indent=4)
        else:
            subprocess.run(['ssh', f'{user}@{target_ip}', f'mkdir -p "{settings_dir}"'], check=False)
            subprocess.run(['ssh', f'{user}@{target_ip}', f'echo "{json_str}" > "{settings_file}"'], check=False)
    except: pass
    cmd = ['code', '--no-sandbox', '--new-window', '--disable-workspace-trust', '--skip-release-notes']
    remote_arg = f"ssh-remote+{user}@{target_ip}"
    cmd.extend(['--remote', remote_arg, path])
    try:
        env = os.environ.copy()
        if 'DISPLAY' not in env: env['DISPLAY'] = ':0'
        subprocess.Popen(cmd, env=env)
        return jsonify({'status': 'success'})
    except Exception as e: return jsonify({'status': 'error', 'message': str(e)}), 500

@api_bp.route('/stats/dashboard', methods=['GET'])
def get_dashboard_stats():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT ISNULL(GroupName, IPAddress) as GroupName, COUNT(*) as Cnt FROM cline_FolderIndex GROUP BY ISNULL(GroupName, IPAddress)")
    group_counts = cursor.fetchall()
    cursor.execute("SELECT ISNULL(f.GroupName, f.IPAddress) as GroupName, COUNT(*) as Cnt FROM cline_TaskQueue q JOIN cline_FolderIndex f ON q.ProjectPath = f.FullPath WHERE q.Status IN ('Pending', 'Processing') GROUP BY ISNULL(f.GroupName, f.IPAddress)")
    active_counts = cursor.fetchall()
    cursor.execute("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(day, -1, GETDATE()) AND Status='Done'")
    d = cursor.fetchone()
    cursor.execute("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(day, -7, GETDATE()) AND Status='Done'")
    w = cursor.fetchone()
    cursor.execute("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(month, -1, GETDATE()) AND Status='Done'")
    m = cursor.fetchone()
    conn.close()
    return jsonify({'groups': group_counts, 'active': active_counts, 'counts': {'day': {'cnt': d['Cnt'], 'dur': d['Dur']}, 'week': {'cnt': w['Cnt'], 'dur': w['Dur']}, 'month': {'cnt': m['Cnt'], 'dur': m['Dur']}}})

@api_bp.route('/stats/hourly_speed', methods=['GET'])
def get_hourly_speed():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    sql = "SELECT DATEPART(HOUR, StartedAt) as HourOfDay, AVG(DATEDIFF(SECOND, StartedAt, CompletedAt)) as AvgSeconds, COUNT(*) as SampleSize FROM cline_TaskQueue WHERE Status='Done' AND CreatedAt >= DATEADD(month, -3, GETDATE()) GROUP BY DATEPART(HOUR, StartedAt) ORDER BY HourOfDay"
    cursor.execute(sql)
    rows = cursor.fetchall()
    conn.close()
    return jsonify(rows)

@api_bp.route('/rules', methods=['GET', 'POST'])
def handle_rules():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    if request.method == 'GET':
        cursor.execute("SELECT * FROM cline_ProjectRules ORDER BY RuleID DESC")
        rules = cursor.fetchall()
        conn.close()
        return jsonify(rules)
    if request.method == 'POST':
        data = request.json
        cursor.execute("INSERT INTO cline_ProjectRules (RuleName, RuleContent) VALUES (%s, %s)", (data['name'], data['content']))
        conn.commit()
        conn.close()
        return jsonify({'status': 'success'})

@api_bp.route('/rules/<int:rule_id>', methods=['PUT', 'DELETE'])
def modify_rule(rule_id):
    conn = get_db_connection()
    cursor = conn.cursor()
    if request.method == 'PUT':
        data = request.json
        cursor.execute("UPDATE cline_ProjectRules SET RuleName=%s, RuleContent=%s WHERE RuleID=%s", (data['name'], data['content'], rule_id))
    elif request.method == 'DELETE':
        cursor.execute("DELETE FROM cline_ProjectRules WHERE RuleID=%s", (rule_id,))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success'})

@api_bp.route('/rules/deploy', methods=['POST'])
def deploy_rule():
    data = request.json
    project_name = data.get('project_name')
    project_path = data.get('project_path')
    rule_id = data.get('rule_id')
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT RuleName, RuleContent FROM cline_ProjectRules WHERE RuleID=%s", (rule_id,))
    rule_row = cursor.fetchone()
    cursor.execute("SELECT IPAddress, Account, FullPath FROM cline_FolderIndex WHERE FullPath=%s", (project_path,))
    target = cursor.fetchone()
    if not rule_row or not target:
        conn.close()
        return jsonify({'status': 'error', 'message': 'Not found'}), 404
    final_content = rule_row['RuleContent']
    final_content = final_content.replace('{{PROJECT_NAME}}', project_name)
    final_content = final_content.replace('{{API_URL}}', BRIDGE_API_URL)
    final_content = final_content.replace('{{TARGET_IP}}', target['IPAddress'])
    final_content = final_content.replace('{{TARGET_PATH}}', target['FullPath'])
    final_content = final_content.replace('{SUBJECT}', project_name)
    final_content = final_content.replace('{SERVER_URL}', BRIDGE_API_URL)
    final_content = final_content.replace('{VENV}', 'python')
    final_content = final_content.replace('{TARGET_PATH}', target['FullPath'].replace('\\', '/'))
    success, msg = send_rule_via_ssh(target['IPAddress'], target['Account'], final_content, target['FullPath'])
    if success:
        cursor.execute("UPDATE cline_FolderIndex SET LastRuleContent=%s, LastRuleName=%s WHERE FullPath=%s", (final_content, rule_row['RuleName'], target['FullPath']))
        conn.commit()
    conn.close()
    return jsonify({'status': 'success' if success else 'error', 'message': msg})

@api_bp.route('/memos', methods=['POST'])
def handle_memo_post():
    data = request.json
    p_name = data.get('project')
    p_path = data.get('path')
    content = data.get('content')
    conn = get_db_connection()
    cursor = conn.cursor()
    sql = "MERGE cline_ProjectMemos AS target USING (SELECT %s as PPath, %s as PName) AS source ON (target.ProjectPath = source.PPath) WHEN MATCHED THEN UPDATE SET MemoContent = %s, UpdatedAt = GETDATE() WHEN NOT MATCHED THEN INSERT (ProjectName, ProjectPath, MemoContent) VALUES (%s, %s, %s);"
    cursor.execute(sql, (p_path, p_name, content, p_name, p_path, content))
    conn.commit()
    conn.close()
    return jsonify({'status': 'success'})

@api_bp.route('/memos/get', methods=['POST'])
def handle_memo_get():
    data = request.json
    p_path = data.get('path')
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT MemoContent FROM cline_ProjectMemos WHERE ProjectPath=%s", (p_path,))
    row = cursor.fetchone()
    conn.close()
    return jsonify({'content': row['MemoContent'] if row else ''})

@api_bp.route('/queue', methods=['GET', 'POST', 'DELETE'])
def handle_queue():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    if request.method == 'GET':
        p_path = request.args.get('path')
        if p_path:
            cursor.execute("SELECT TaskID, ProjectName, TaskContent, Status, CONVERT(VARCHAR, StartedAt, 120) as StartedAt FROM cline_TaskQueue WHERE ProjectPath=%s AND Status IN ('Pending', 'Processing') ORDER BY TaskID", (p_path,))
        else:
            cursor.execute("SELECT TaskID, ProjectName, TaskContent, Status, CONVERT(VARCHAR, StartedAt, 120) as StartedAt FROM cline_TaskQueue WHERE Status IN ('Pending', 'Processing') ORDER BY ProjectName, TaskID")
        rows = cursor.fetchall()
        conn.close()
        return jsonify(rows)
    if request.method == 'POST':
        data = request.json
        p_name = data.get('project')
        p_path = data.get('path')
        content = data.get('content')
        common_inst = data.get('common_instruction', '')
        final_task_content = content
        if common_inst.strip():
            final_task_content += f"\n\n[SYSTEM NOTICE: ALWAYS EXECUTE THIS]\n{common_inst}"
        cursor.execute("INSERT INTO cline_TaskQueue (ProjectName, ProjectPath, TaskContent) VALUES (%s, %s, %s)", (p_name, p_path, final_task_content))
        cursor.execute("UPDATE cline_FolderIndex SET TaskCount = ISNULL(TaskCount, 0) + 1, LastTaskDate = GETDATE(), CommonInstruction = %s WHERE FullPath=%s", (common_inst, p_path))
        conn.commit()
        conn.close()
        return jsonify({'status': 'success'})
    if request.method == 'DELETE':
        task_id = request.args.get('id')
        cursor.execute("DELETE FROM cline_TaskQueue WHERE TaskID=%s", (task_id,))
        conn.commit()
        conn.close()
        return jsonify({'status': 'success'})

# [NEW] Git History & Restore
@api_bp.route('/git/history', methods=['POST'])
def git_history():
    data = request.json
    project_path = data.get('path')
    if not os.path.exists(project_path) or not os.path.exists(os.path.join(project_path, '.git')):
        return jsonify({'status': 'error', 'message': 'Not a git repository'}), 400
    try:
        cmd = ['git', 'log', '-n', '10', '--pretty=format:%h|%an|%ar|%s']
        result = subprocess.run(cmd, cwd=project_path, capture_output=True, text=True, encoding='utf-8')
        logs = []
        if result.stdout:
            for line in result.stdout.strip().split('\n'):
                parts = line.split('|')
                if len(parts) >= 4:
                    logs.append({'hash': parts[0], 'author': parts[1], 'date': parts[2], 'message': parts[3]})
        return jsonify({'status': 'success', 'logs': logs})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@api_bp.route('/git/reset', methods=['POST'])
def git_reset():
    data = request.json
    project_path = data.get('path')
    commit_hash = data.get('hash')
    if not project_path or not commit_hash:
        return jsonify({'status': 'error', 'message': 'Missing data'}), 400
    try:
        subprocess.run(['git', 'reset', '--hard', commit_hash], cwd=project_path, check=True)
        return jsonify({'status': 'success', 'message': f'Restored to {commit_hash} successfully.'})
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

@api_bp.route('/history', methods=['POST'])
def get_history():
    data = request.json
    p_path = data.get('path')
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT TaskID, TaskContent, Status, ResultContent, CONVERT(VARCHAR, CreatedAt, 120) as CreatedAt, CONVERT(VARCHAR, CompletedAt, 120) as CompletedAt, DATEDIFF(SECOND, StartedAt, CompletedAt) as DurationSeconds FROM cline_TaskQueue WHERE ProjectPath=%s ORDER BY TaskID DESC", (p_path,))
    rows = cursor.fetchall()
    conn.close()
    return jsonify(rows)

@api_bp.route('/bookmarks', methods=['GET', 'POST', 'DELETE'])
def handle_bookmarks():
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    if request.method == 'GET':
        cursor.execute("SELECT * FROM cline_WebBookmarks ORDER BY CreatedAt ASC")
        rows = cursor.fetchall()
        conn.close()
        return jsonify(rows)
    if request.method == 'POST':
        data = request.json
        title = data.get('title')
        url = data.get('url')
        cursor.execute("INSERT INTO cline_WebBookmarks (Title, URL) VALUES (%s, %s)", (title, url))
        conn.commit()
        conn.close()
        return jsonify({'status': 'success'})
    if request.method == 'DELETE':
        bid = request.args.get('id')
        cursor.execute("DELETE FROM cline_WebBookmarks WHERE BookmarkID=%s", (bid,))
        conn.commit()
        conn.close()
        return jsonify({'status': 'success'})

@api_bp.route('/agent/next', methods=['POST'])
def agent_next_task():
    data = request.json
    project_name = data.get('subject')
    conn = get_db_connection()
    cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT TOP 1 TaskID, TaskContent, ProjectPath FROM cline_TaskQueue WHERE ProjectName=%s AND Status='Pending' ORDER BY TaskID ASC", (project_name,))
    task = cursor.fetchone()
    if task:
        cursor.execute("UPDATE cline_TaskQueue SET Status='Processing', StartedAt=GETDATE() WHERE TaskID=%s", (task['TaskID'],))
        conn.commit()
        conn.close()
        return jsonify({"status": "ok", "log_id": task['TaskID'], "command": task['TaskContent'], "path": task['ProjectPath']})
    else:
        conn.close()
        return jsonify({"status": "wait"})

@api_bp.route('/agent/result', methods=['POST'])
def agent_submit_result():
    data = request.json
    task_id = data.get('log_id')
    result_content = data.get('result')
    project_name = data.get('subject')
    conn = get_db_connection()
    cursor = conn.cursor()
    cursor.execute("UPDATE cline_TaskQueue SET Status='Done', CompletedAt=GETDATE(), ResultContent=%s WHERE TaskID=%s", (result_content, task_id))
    if project_name:
        update_sql = "UPDATE cline_FolderIndex SET LastTaskDate=GETDATE(), TotalDuration = ISNULL(TotalDuration, 0) + ISNULL((SELECT DATEDIFF(SECOND, StartedAt, CompletedAt) FROM cline_TaskQueue WHERE TaskID=%s), 0) WHERE DisplayName=%s"
        cursor.execute(update_sql, (task_id, project_name))
    conn.commit()
    conn.close()
    return jsonify({"status": "received"})
"""
with open(os.path.join(base_dir, "app", "routes", "api_routes.py"), "w", encoding="utf-8") as f:
    f.write(api_routes_code)

print("\n‚úÖ v26 ÏóÖÎç∞Ïù¥Ìä∏ ÏôÑÎ£å!")
print("1. Path Normalization: Î™®Îì† Í≤ΩÎ°úÏùò Ïó≠Ïä¨ÎûòÏãú(\\)Î•º Ïä¨ÎûòÏãú(/)Î°ú ÏûêÎèô Î≥ÄÌôò.")
print("2. Debug Log: Git ÏöîÏ≤≠ Ïãú ÏÑúÎ≤Ñ ÌÑ∞ÎØ∏ÎÑêÏóê ÏàòÏã†Îêú Í≤ΩÎ°úÎ•º Ï∂úÎ†•.")
print("üëâ 'python3 runcline/run_bridge.py' Ïã§Ìñâ ÌõÑ ÏóêÎü¨Í∞Ä ÎÇòÎ©¥ ÌÑ∞ÎØ∏ÎÑê Î°úÍ∑∏Î•º ÌôïÏù∏Ìï¥Ï£ºÏÑ∏Ïöî!")