단계: DB 컬럼 무제한으로 확장 (SQL 실행)
이 쿼리를 SSMS에서 실행해서, 결과 담을 그릇을 **2GB(최대)**까지 늘려주십시오. 없으면 만들고, 작으면 늘립니다.

SQL

-- 테이블이 TB_CLINE_FINAL_COMMANDS 라고 가정
USE SMD_DB; -- 형님 DB명 확인

-- 1. 혹시 컬럼이 없으면 추가
IF NOT EXISTS (
  SELECT * FROM sys.columns 
  WHERE object_id = OBJECT_ID('TB_CLINE_FINAL_COMMANDS') AND name = 'Cmd_Result'
)
BEGIN
    ALTER TABLE TB_CLINE_FINAL_COMMANDS ADD Cmd_Result NVARCHAR(MAX);
    PRINT 'Cmd_Result 컬럼 추가 완료';
END

-- 2. 컬럼이 있다면 용량을 MAX로 변경 (이게 중요합니다)
ALTER TABLE TB_CLINE_FINAL_COMMANDS ALTER COLUMN Cmd_Result NVARCHAR(MAX);
PRINT 'Cmd_Result 컬럼 용량 무제한(MAX)으로 변경 완료';
2단계: 룰(Rule) 수정 (파일 저장 후 전송)
웹 대시보드 [RULES] 탭에 가서 기존 룰을 이 내용으로 덮어쓰십시오. 형님 말씀대로 **"실행 결과를 last_result.log에 저장하고, 그걸 읽어서 보내라"**고 명시했습니다.

Markdown

# [Role]
You are the dedicated executor for "{SUBJECT}".
Server: {SERVER_URL}

# [Command Loop]
When triggered by **"go"**, **"do"**, **"고"**:

1.  **FETCH**: POST `{SERVER_URL}/api/agent/next` with `{"subject": "{SUBJECT}"}`.
2.  **CHECK**:
    - If `{"status": "wait"}`, print "Waiting..." and STOP.
    - If `{"status": "ok", "log_id": 123, "command": "..."}`, proceed.
3.  **EXECUTE & LOG**:
    - Execute the command.
    - **IMPORTANT**: Save the output (stdout/stderr) to a file named `last_result.log`.
    - Example: `python script.py > last_result.log 2>&1`
4.  **READ LOG**:
    - Read the content of `last_result.log`.
5.  **REPORT**:
    - POST `{SERVER_URL}/api/agent/result`
    - Body: `{"subject": "{SUBJECT}", "log_id": [ID], "result": "[CONTENT_OF_LOG_FILE]"}`
    - If the log is too long, send the last 2000 characters.

# [Environment]
- Venv: {VENV} (Use this for python commands)
- Helper Script: {SCRIPT_NAME}
요약
SQL 실행: 결과 컬럼을 NVARCHAR(MAX)로 빵빵하게 늘립니다.

룰 수정: "결과를 파일에 담았다가 보내라"고 지침을 바꿉니다.

이제 에러 없이 긴 로그도 DB에 척척 쌓이고, 웹 화면 아래쪽 로그 창에 실시간으로 뜰 겁니다.