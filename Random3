SSQL은 테이블 생성 스크립트(CREATE TABLE...)를 텍스트 형태로 저장하지 않기 때문에, 테이블의 경우 파이썬 내부 로직으로 스키마를 읽어 **CREATE 문을 역생성(Reverse Engineering)**하도록 구현했습니다.

사전 준비
터미널에서 라이브러리를 설치해야 합니다.

Bash

pip install pymssql
Python 스크립트
아래 코드를 복사하여 export_db.py로 저장하고, 상단의 설정(Configuration) 부분만 본인 환경에 맞게 수정한 뒤 실행하세요.

Python

import pymssql
import os
import sys

# =========================================================
# [설정] MSSQL 접속 정보 및 저장 경로 (여기를 수정하세요)
# =========================================================
DB_CONFIG = {
    'server': 'localhost',      # 서버 주소 (예: 127.0.0.1)
    'port': 1633,               # 요청하신 포트 1633
    'user': 'sa',               # 접속 계정
    'password': 'your_password',# 접속 암호
    'database': 'TargetDB'      # 타겟 데이터베이스 이름
}

# 결과물이 저장될 메인 폴더명
OUTPUT_DIR = "DB_Export_Result"

# =========================================================
# [로직] 스크립트 생성 및 파일 저장 함수
# =========================================================

def create_directory(path):
    """폴더가 없으면 생성"""
    if not os.path.exists(path):
        os.makedirs(path)

def save_to_file(folder_name, file_name, content):
    """내용을 지정된 폴더와 파일명으로 저장 (UTF-8 인코딩)"""
    # 윈도우 파일명으로 사용할 수 없는 문자 제거
    safe_name = "".join([c for c in file_name if c.isalpha() or c.isdigit() or c in (' ', '.', '_', '-')]).strip()
    full_path = os.path.join(OUTPUT_DIR, folder_name)
    create_directory(full_path)
    
    file_path = os.path.join(full_path, f"{safe_name}.sql")
    
    try:
        with open(file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        print(f"[OK] {folder_name}/{safe_name}.sql 저장 완료")
    except Exception as e:
        print(f"[Err] 파일 저장 실패 ({file_name}): {e}")

def get_connection():
    return pymssql.connect(
        server=DB_CONFIG['server'],
        user=DB_CONFIG['user'],
        password=DB_CONFIG['password'],
        database=DB_CONFIG['database'],
        port=DB_CONFIG['port'],
        charset='utf8'
    )

def export_programmable_objects(cursor):
    """
    뷰, 프로시저, 함수, 트리거는 sys.sql_modules에 정의가 그대로 들어있음
    """
    print("\n--- [1/4] 프로시저, 뷰, 함수, 트리거 추출 중 ---")
    
    # P: 프로시저, V: 뷰, FN/IF/TF: 함수, TR: 트리거
    sql = """
    SELECT 
        o.name AS ObjectName,
        s.name AS SchemaName,
        o.type_desc AS ObjectType,
        m.definition AS Definition
    FROM sys.sql_modules m
    INNER JOIN sys.objects o ON m.object_id = o.object_id
    INNER JOIN sys.schemas s ON o.schema_id = s.schema_id
    WHERE o.is_ms_shipped = 0
    """
    
    cursor.execute(sql)
    rows = cursor.fetchall()

    for row in rows:
        obj_name = row[0]
        schema = row[1]
        obj_type = row[2]     # 예: SQL_STORED_PROCEDURE
        definition = row[3]

        # 폴더명을 타입별로 깔끔하게 정리
        folder_map = {
            'SQL_STORED_PROCEDURE': 'Procedures',
            'VIEW': 'Views',
            'SQL_SCALAR_FUNCTION': 'Functions',
            'SQL_TABLE_VALUED_FUNCTION': 'Functions',
            'SQL_INLINE_TABLE_VALUED_FUNCTION': 'Functions',
            'SQL_TRIGGER': 'Triggers'
        }
        folder_name = folder_map.get(obj_type, 'Others')
        
        full_name = f"{schema}.{obj_name}"
        save_to_file(folder_name, full_name, definition)

def export_tables(cursor):
    """
    테이블은 정의가 텍스트로 저장되지 않으므로, 컬럼 정보를 읽어 CREATE 문을 생성
    """
    print("\n--- [2/4] 테이블 스크립트 생성 중 ---")
    
    # 테이블 목록 조회
    cursor.execute("""
        SELECT t.name, s.name 
        FROM sys.tables t
        JOIN sys.schemas s ON t.schema_id = s.schema_id
        WHERE t.is_ms_shipped = 0
    """)
    tables = cursor.fetchall()

    for tbl in tables:
        table_name = tbl[0]
        schema_name = tbl[1]
        full_table_name = f"{schema_name}.{table_name}"
        
        # 컬럼 정보 조회
        col_sql = """
        SELECT 
            COLUMN_NAME, DATA_TYPE, CHARACTER_MAXIMUM_LENGTH, IS_NULLABLE
        FROM INFORMATION_SCHEMA.COLUMNS
        WHERE TABLE_SCHEMA = %s AND TABLE_NAME = %s
        ORDER BY ORDINAL_POSITION
        """
        cursor.execute(col_sql, (schema_name, table_name))
        columns = cursor.fetchall()

        # CREATE TABLE 구문 작성
        script_lines = []
        script_lines.append(f"CREATE TABLE [{schema_name}].[{table_name}] (")
        
        col_defs = []
        for col in columns:
            c_name = col[0]
            c_type = col[1]
            c_len = col[2]
            c_null = "NULL" if col[3] == 'YES' else "NOT NULL"
            
            # 길이 표시가 필요한 타입 처리 (varchar, nvarchar 등)
            if c_type in ['varchar', 'nvarchar', 'char', 'nchar', 'varbinary']:
                length_str = f"({c_len})" if c_len != -1 else "(MAX)"
                type_str = f"{c_type}{length_str}"
            else:
                type_str = c_type
            
            col_defs.append(f"    [{c_name}] {type_str} {c_null}")
        
        script_lines.append(",\n".join(col_defs))
        script_lines.append(");")
        script_lines.append("GO")

        save_to_file("Tables", full_table_name, "\n".join(script_lines))

def export_indexes(cursor):
    """
    인덱스 생성 스크립트 추출
    """
    print("\n--- [3/4] 인덱스 스크립트 추출 중 ---")
    
    # 인덱스 정보 쿼리 (PK 제외, 일반 인덱스만)
    sql = """
    SELECT 
        i.name AS IndexName,
        t.name AS TableName,
        s.name AS SchemaName,
        i.type_desc,
        i.is_unique,
        STUFF((SELECT ', [' + c.name + ']'
               FROM sys.index_columns ic
               JOIN sys.columns c ON ic.object_id = c.object_id AND ic.column_id = c.column_id
               WHERE ic.object_id = i.object_id AND ic.index_id = i.index_id
               ORDER BY ic.key_ordinal
               FOR XML PATH('')), 1, 2, '') AS ColumnNames
    FROM sys.indexes i
    JOIN sys.tables t ON i.object_id = t.object_id
    JOIN sys.schemas s ON t.schema_id = s.schema_id
    WHERE i.type > 0 AND i.is_primary_key = 0 AND t.is_ms_shipped = 0
    """
    
    cursor.execute(sql)
    indexes = cursor.fetchall()

    for idx in indexes:
        idx_name = idx[0]
        table_name = idx[1]
        schema_name = idx[2]
        type_desc = idx[3]
        is_unique = "UNIQUE " if idx[4] else ""
        cols = idx[5]

        # CREATE INDEX 구문 조립
        script = f"CREATE {is_unique}{type_desc} INDEX [{idx_name}] ON [{schema_name}].[{table_name}] ({cols});"
        
        save_to_file("Indexes", f"{schema_name}.{table_name}_{idx_name}", script)

def main():
    print(f"[*] MSSQL 서버({DB_CONFIG['server']}:{DB_CONFIG['port']})에 접속 시도 중...")
    
    try:
        conn = get_connection()
        cursor = conn.cursor()
        print("[+] 접속 성공! 데이터 추출을 시작합니다.\n")
        
        # 1. Programmable Objects (뷰, 프로시저 등)
        export_programmable_objects(cursor)
        
        # 2. Tables
        export_tables(cursor)
        
        # 3. Indexes
        export_indexes(cursor)
        
        print(f"\n[완료] 모든 작업이 끝났습니다. '{OUTPUT_DIR}' 폴더를 확인하세요.")
        
    except pymssql.Error as e:
        print(f"\n[치명적 오류] DB 접속 또는 쿼리 실행 중 에러: \n{e}")
    except Exception as ex:
        print(f"\n[오류] 알 수 없는 예외 발생: {ex}")
    finally:
        try:
            conn.close()
        except:
            pass

if __name__ == "__main__":
    main()
작동 방식 설명
폴더 구조 자동 생성: 스크립트를 실행하면 실행 위치에 DB_Export_Result 폴더가 생기고, 그 안에 Tables, Views, Procedures, Functions, Triggers, Indexes 폴더가 자동으로 나뉩니다.

테이블 (Tables): MSSQL은 CREATE TABLE 문을 저장하지 않으므로, 이 스크립트가 컬럼 정보를 읽어서 기본 구조(컬럼명, 타입, NULL 여부)를 가진 CREATE 문을 새로 작성해 줍니다.

프로시저/뷰/트리거: DB 내부에 저장된 원본 SQL 코드를 그대로 가져와 저장합니다.

한글 처리: 모든 파일은 UTF-8로 저장되므로 한글 깨짐 없이 열어볼 수 있습니다.

경원님을 위한 팁
port 변수에 1633을 적용해 두었습니다. 비밀번호만 바꾸시면 바로 돌아갑니다.

테이블 스크립트는 기본 구조만 생성합니다. 복잡한 FK(외래키)나 Default 제약조건까지 완벽하게 스크립팅하려면 코드가 매우 복잡해지므로, 이 코드는 데이터 구조 백업 및 확인용으로 쓰기에 가장 적합하고 가볍게 만들었습