아주 좋은 선택입니다. 윈도우 비주얼 스튜디오의 483개 에러, SDK 버전 맞추기... 이거 쳐다보다가 시간 다 갑니다.

우분투(Ubuntu) 터미널에서 **러스트(Rust)**로 컴파일하면, 윈도우 XP용 .exe 파일을 딱 3분 만에 깔끔하게 뽑아낼 수 있습니다. 복잡한 설정창도 없고, 그냥 명령어 몇 줄 복사해 넣으면 끝입니다.

우분투 터미널을 열고 아래 순서대로만 진행하세요.

1단계: 러스트 & 윈도우 크로스 컴파일러 설치
우분투 터미널에 아래 명령어들을 한 줄씩 복사해서 붙여넣으세요. (비밀번호 물어보면 입력)

Bash
# 1. 윈도우용 링커(MinGW) 설치 (이게 있어야 윈도우 실행파일을 만듭니다)
sudo apt update && sudo apt install -y mingw-w64

# 2. 러스트(Rust) 설치 (이미 있으면 생략 가능)
curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y
source "$HOME/.cargo/env"

# 3. 윈도우 XP(32비트)용 타겟 추가
# (i686 = 32비트, pc-windows-gnu = 비주얼 스튜디오 없이 만드는 방식)
rustup target add i686-pc-windows-gnu
2단계: 프로젝트 생성 및 설정
Bash
# 1. 프로젝트 폴더 생성
cargo new smd_launcher
cd smd_launcher

# 2. 시간/날짜 기능을 위한 라이브러리 추가 (한 줄로 끝)
cargo add chrono
3단계: 코드 붙여넣기 (src/main.rs)
src/main.rs 파일을 열어서 내용을 아래 코드로 싹 덮어쓰세요.
(nano src/main.rs 입력 후 붙여넣고 Ctrl+O, Enter, Ctrl+X 로 저장)

이 코드는 "무설치, 무소음(검은창 없음), 로그 자동삭제" 기능이 완벽히 들어있습니다.

Rust
// 윈도우에서 실행 시 검은색 콘솔창(CMD)을 아예 안 띄우는 핵심 설정
#![windows_subsystem = "windows"]

use std::fs::{self, OpenOptions};
use std::io::{BufRead, BufReader, Write};
use std::path::Path;
use std::process::Command;
use std::thread;
use std::time::{Duration, SystemTime};
use chrono::{DateTime, Local}; // 날짜/시간 포맷팅용

const CONFIG_FILENAME: &str = "startup_config.txt";
const LOG_RETENTION_DAYS: i64 = 7;

fn main() {
    // 1. 7일 지난 로그 자동 삭제
    delete_old_logs();
    write_log("=== Launcher Started ===");

    // 2. 설정 파일이 없으면 생성
    if !Path::new(CONFIG_FILENAME).exists() {
        create_default_config();
        write_log("Config file created. Waiting for user configuration.");
        // 설정 파일만 만들고 이번 실행은 조용히 종료 (안전을 위해)
        return;
    }

    // 3. 설정 파일 읽고 순차 실행
    if let Ok(file) = fs::File::open(CONFIG_FILENAME) {
        let reader = BufReader::new(file);

        for (idx, line) in reader.lines().enumerate() {
            if let Ok(content) = line {
                let content = content.trim();
                // 주석(#)이나 빈 줄은 패스
                if content.is_empty() || content.starts_with('#') {
                    continue;
                }

                // 파이프(|)로 시간과 경로 분리
                let parts: Vec<&str> = content.split('|').collect();
                if parts.len() < 2 {
                    write_log(&format!("Syntax Error at line {}: Missing '|'", idx + 1));
                    continue;
                }

                let time_str = parts[0].trim();
                let path_str = parts[1].trim();

                // 딜레이 시간 파싱
                match time_str.parse::<u64>() {
                    Ok(seconds) => {
                        if seconds > 0 {
                            write_log(&format!("Waiting {} seconds...", seconds));
                            thread::sleep(Duration::from_secs(seconds));
                        }
                    }
                    Err(_) => {
                        write_log(&format!("Invalid time format at line {}: {}", idx + 1, time_str));
                        continue;
                    }
                }

                // 'Dummy'가 들어있으면 시간만 끌고 실행은 안 함
                if path_str.contains("Dummy") {
                    continue;
                }

                // 프로그램 실행 로직
                if Path::new(path_str).exists() {
                    write_log(&format!("Launching: {}", path_str));
                    
                    // 실행 파일이 있는 폴더를 작업 폴더로 지정 (중요)
                    let work_dir = Path::new(path_str).parent().unwrap_or(Path::new("."));
                    
                    // spawn()은 실행만 시키고 내 프로그램은 즉시 다음 줄로 넘어감 (Non-blocking)
                    match Command::new(path_str).current_dir(work_dir).spawn() {
                        Ok(_) => {},
                        Err(e) => write_log(&format!("Failed to launch: {} (Error: {})", path_str, e)),
                    }
                } else {
                    write_log(&format!("File not found (Skipped): {}", path_str));
                }
            }
        }
    }
    write_log("All tasks finished. Exiting.");
}

// === 유틸리티 함수 ===

fn get_log_filename() -> String {
    let now: DateTime<Local> = Local::now();
    format!("log_{}.txt", now.format("%Y-%m-%d"))
}

fn write_log(msg: &str) {
    let filename = get_log_filename();
    let now: DateTime<Local> = Local::now();
    let log_msg = format!("[{}] {}\n", now.format("%H:%M:%S"), msg);

    // 파일에 이어쓰기(Append) 모드로 기록
    if let Ok(mut file) = OpenOptions::new().create(true).write(true).append(true).open(filename) {
        let _ = file.write_all(log_msg.as_bytes());
    }
}

fn create_default_config() {
    if let Ok(mut file) = fs::File::create(CONFIG_FILENAME) {
        let _ = writeln!(file, "# [SMD Startup Config]");
        let _ = writeln!(file, "# Format: DelaySeconds | FilePath");
        let _ = writeln!(file, "30 | Dummy_Wait_For_Driver_Loading");
        let _ = writeln!(file, "5  | C:\\Windows\\notepad.exe");
    }
}

fn delete_old_logs() {
    // 현재 폴더의 모든 파일을 검사
    if let Ok(entries) = fs::read_dir(".") {
        let now = SystemTime::now();
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                // 파일 이름이 log_로 시작하고 .txt로 끝나는지 확인
                if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                    if name.starts_with("log_") && name.ends_with(".txt") {
                        // 수정 날짜 확인
                        if let Ok(metadata) = fs::metadata(&path) {
                            if let Ok(modified) = metadata.modified() {
                                if let Ok(duration) = now.duration_since(modified) {
                                    // 7일(초 단위) 이상 지났으면 삭제
                                    if duration.as_secs() > (LOG_RETENTION_DAYS as u64 * 86400) {
                                        let _ = fs::remove_file(path);
                                        write_log(&format!("Deleted old log: {}", name));
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
4단계: 빌드 (EXE 파일 생성)
터미널에서 아래 명령어를 입력하면 끝입니다.

Bash
cargo build --release --target i686-pc-windows-gnu
5단계: 파일 가져오기
빌드가 끝나면 다음 경로에 smd_launcher.exe 파일이 생깁니다.

경로: smd_launcher/target/i686-pc-windows-gnu/release/smd_launcher.exe

이 파일 하나만 USB에 담아서 설비 PC(Windows XP)에 넣으세요.

아무것도 설치할 필요 없습니다.

실행하면 startup_config.txt가 생깁니다.

그거 수정해서 쓰시면 됩니다.

이게 비주얼 스튜디오보다 100배 빠르고 정신 건강에 좋습니다. 성공하실 겁니다.