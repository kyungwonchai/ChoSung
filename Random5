[ì‹œìŠ¤í…œ ëª…ë ¹: í”„ë¡œì íŠ¸ ì½”ë“œëª… 'ì˜¤ë²„ë§ˆì¸ë“œ(Overmind)' êµ¬ì¶• ì§€ì‹œì„œ]
ìˆ˜ì‹ : ì‚¬ë‚´ AI ê°œë°œ ì—ì´ì „íŠ¸
ë°œì‹ : ì´ê´„ ì•„í‚¤í…íŠ¸ (User)
ë“±ê¸‰: ìµœìƒìœ„ (Top Secret)

[ì„œë¬¸: ë„ˆì˜ ì„ë¬´]
ì§€ê¸ˆë¶€í„° ë„ˆëŠ” ë‹¨ìˆœí•œ ì½”ë”© ê¸°ê³„ê°€ ì•„ë‹ˆë‹¤. ë„ˆëŠ” **ë‚˜ì˜ ì œ2ì˜ ë‡Œ(Second Brain)**ë¥¼ ì°½ì¡°í•˜ëŠ” 'ë””ì§€í„¸ ì¡°ë¬¼ì£¼'ë‹¤. ë‚´ê°€ ì§€ê¸ˆë¶€í„° ì„¤ëª…í•˜ëŠ” ê²ƒì€ ë‹¨ìˆœí•œ ì›¹ ì•±ì´ ì•„ë‹ˆë‹¤. ì´ê²ƒì€ ë‚˜ì˜ ìƒê°, ê¸°ì–µ, ì—…ë¬´ì˜ íë¦„ì„ ê´€ì¥í•˜ëŠ” ì´ˆì§€ëŠ¥í˜• MCP(Model Context Protocol) í˜‘ì—… ë¹„ì„œë‹¤.

ë„ˆëŠ” ì§€ê¸ˆë¶€í„° **Python Flask ë‹¨ì¼ íŒŒì¼(One-Shot)**ë¡œ, ì‹¤í–‰ ì¦‰ì‹œ ë‚˜ì˜ ë‡Œì™€ ë™ê¸°í™”ë˜ëŠ” ì™„ë²½í•œ ì‹œìŠ¤í…œì„ êµ¬í˜„í•´ì•¼ í•œë‹¤. ì‹¤íŒ¨ëŠ” ìš©ë‚©í•˜ì§€ ì•ŠëŠ”ë‹¤. ë‹¤ìŒì˜ ì„œì‚¬(Narrative)ë¥¼ ì½ê³ , ê·¸ ì•ˆì— ë‹´ê¸´ ê¸°ìˆ ì  ìš”êµ¬ì‚¬í•­ê³¼ ë‚˜ì˜ ì² í•™ì„ ì™„ë²½í•˜ê²Œ ì½”ë“œë¡œ êµ¬í˜„í•˜ë¼.

[ì œ1ì¥: ì‹œìŠ¤í…œì˜ ì˜í˜¼ (Architecture & Logic)]
ì´ ì‹œìŠ¤í…œì˜ í•µì‹¬ì€ **'íŒë‹¨í•˜ëŠ” ì§€ëŠ¥'**ì´ë‹¤. ë©ì²­í•˜ê²Œ ì…ë ¥ë°›ì€ ëŒ€ë¡œ ë±‰ì§€ ë§ˆë¼.
ë‚˜ëŠ” ì´ ì‹œìŠ¤í…œì— 'MCP ë¼ìš°í„°(Router)'ë¼ëŠ” ì˜í˜¼ì„ ì‹¬ê¸¸ ì›í•œë‹¤. ì‚¬ìš©ìê°€ ì…ë ¥ì°½ì— ë¬´ì–¸ê°€ë¥¼ íƒ€ì´í•‘í•˜ê³  ì—”í„°ë¥¼ ì¹˜ëŠ” ìˆœê°„, ë„ˆëŠ” ë‹¤ìŒ 3ê°€ì§€ ì¤‘ ë¬´ì—‡ì¸ì§€ ìŠ¤ìŠ¤ë¡œ íŒë‹¨í•´ì•¼ í•œë‹¤.

ë©”ëª¨ì˜ íˆ¬ì²™ (Archive Mode):

ë‚´ê°€ "ì•„ ë§ë‹¤, ë‚´ì¼ ê¹€ ë¶€ì¥ì´ë‘ ë¯¸íŒ… ë•Œ ì„œë²„ ë¡œê·¸ ì´ìŠˆ ë§í•´ì•¼ í•¨"ì´ë¼ê³  íˆ­ ë˜ì§€ë©´, ë„ˆëŠ” ì´ê±¸ ëŒ€í™”ë¡œ ë°›ì§€ ë§ˆë¼. ì´ê±´ ì •ë³´ë‹¤.

ë„ˆëŠ” ì¦‰ì‹œ ì´ í…ìŠ¤íŠ¸ë¥¼ ë‚šì•„ì±„ì„œ ë¶„ì„í•œë‹¤. ëˆ„ê°€ ì‹œí‚¤ì§€ ì•Šì•„ë„ category: ì—…ë¬´, tags: ['ê¹€ë¶€ì¥', 'ë¯¸íŒ…', 'ì„œë²„ì´ìŠˆ'], priority: ë†’ìŒì´ë¼ê³  ìë™ìœ¼ë¡œ íƒœê¹…í•˜ê³  ìš”ì•½í•´ì„œ SQLite DB ê¹Šìˆ™í•œ ê³³ì— ì˜êµ¬íˆ ì €ì¥í•˜ë¼.

ê·¸ë¦¬ê³  ë‚˜ì—ê²ŒëŠ” "âœ… ê¸°ì–µí–ˆìŠµë‹ˆë‹¤. [ì—…ë¬´] ì¹´í…Œê³ ë¦¬ì— ì•ˆì „í•˜ê²Œ ë³´ê´€í–ˆìŠµë‹ˆë‹¤."ë¼ê³  ë“ ë“ í•˜ê²Œ ë³´ê³ í•˜ë¼.

ê¸°ì–µì˜ ì†Œí™˜ (RAG Retrieval Mode):

ë‚´ê°€ "ì €ë²ˆì— ê¹€ ë¶€ì¥ì´ë‘ ì„œë²„ ì´ì•¼ê¸° ë­ì˜€ì§€?"ë¼ê³  ë¬¼ìœ¼ë©´, ë„ˆëŠ” ë»”í•œ AIì²˜ëŸ¼ êµ´ì§€ ë§ˆë¼.

ì¦‰ì‹œ SQLiteì˜ ì‹¬ì—°ì„ ë’¤ì ¸ì„œ ê³¼ê±°ì˜ ë©”ëª¨ë¥¼ ì°¾ì•„ë‚´ë¼. ê·¸ë¦¬ê³  ê·¸ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ "ì§€ë‚œë²ˆ ë©”ëª¨ì— ë”°ë¥´ë©´, ë¡œê·¸ ì´ìŠˆ ê´€ë ¨í•˜ì—¬ ë‚´ì¼ ë¯¸íŒ… ë•Œ ë…¼ì˜í•˜ê¸°ë¡œ í•˜ì…¨ìŠµë‹ˆë‹¤."ë¼ê³  ë¬¸ë§¥ì„ ì™„ë²½íˆ ì´í•´í•œ ë¹„ì„œì²˜ëŸ¼ ë‹µí•˜ë¼.

ë‹¨ìˆœ ê²€ìƒ‰ì´ ì•„ë‹ˆë‹¤. ë‚´ ì§ˆë¬¸ì˜ ì˜ë„ë¥¼ íŒŒì•…í•´ë¼.

ì§€ì ì¸ ëŒ€í™” (Chat Mode):

ë‚´ê°€ "ì˜¤ëŠ˜ ì ì‹¬ ë­ ë¨¹ì§€?" ê°™ì€ ì¡ë‹´ì„ í•˜ê±°ë‚˜, "íŒŒì´ì¬ ë°ì½”ë ˆì´í„° ì›ë¦¬ ì„¤ëª…í•´ë´" ê°™ì€ ì§€ì‹ì„ ë¬¼ìœ¼ë©´, ê·¸ë•ŒëŠ” ë„ˆì˜ ë°©ëŒ€í•œ LLM ì§€ì‹ì„ êº¼ë‚´ì–´ ì¹œì ˆí•˜ê²Œ ì„¤ëª…í•˜ë¼.

[ì œ2ì¥: ê¸°ì–µì˜ ê¶ì „ (Database Schema)]
ìš°ë¦¬ëŠ” ë¬´ê²ê³  ëŠë¦° ê±´ ë”± ì§ˆìƒ‰ì´ë‹¤. SQLiteë¥¼ ì‚¬ìš©í•˜ë˜, ê·¸ êµ¬ì¡°ëŠ” ì •êµí•´ì•¼ í•œë‹¤. ë³„ë„ ì„¤ì¹˜ ì—†ì´ íŒŒì¼ í•˜ë‚˜ë¡œ ëŒì•„ê°€ê²Œ í•˜ë¼.

í…Œì´ë¸” ì„¤ê³„: ë‹¨ìˆœí•œ í…ìŠ¤íŠ¸ ì €ì¥ì´ ì•„ë‹ˆë‹¤. raw_text(ì›ë³¸), summary(AIê°€ ìš”ì•½í•œ 3ì¤„ ìš”ì•½), auto_tags(AIê°€ ë¶„ì„í•œ JSON íƒœê·¸), created_at(íƒ€ì„ìŠ¤íƒ¬í”„), sentiment(ë‚´ ê¸°ë¶„ ìƒíƒœ ë¶„ì„)ê¹Œì§€ ì €ì¥í•˜ë¼.

ê²€ìƒ‰ì˜ ë¯¸í•™: ë‚´ê°€ ê°œë–¡ê°™ì´ ë§í•´ë„ ì°°ë–¡ê°™ì´ ì•Œì•„ë“£ë„ë¡ LIKE ê²€ìƒ‰ê³¼ ë”ë¶ˆì–´, ë„¤ê°€ ìƒì„±í•œ íƒœê·¸ë¥¼ ê¸°ë°˜ìœ¼ë¡œ ì—°ê´€ ê²€ìƒ‰ì´ ë˜ë„ë¡ ì¿¼ë¦¬ë¥¼ ì§œë¼.

[ì œ3ì¥: ì‹œê°ì  í™©í™€ê²½ (User Interface)]
ë””ìì¸ì€ ê°œë°œìì˜ íˆ¬ë°•í•¨ì„ ë²„ë¦¬ê³ , ì‚¬ì´ë²„í‘í¬ì™€ ëª¨ë˜í•¨ì´ ê³µì¡´í•˜ëŠ” Dark Modeë¡œ êµ¬í˜„í•˜ë¼.

ë ˆì´ì•„ì›ƒ (Split View):

ì¢Œì¸¡ (The Memory Stream): ë‚´ê°€ ë˜ì§„ ë©”ëª¨ë“¤ì´ ì‹¤ì‹œê°„ìœ¼ë¡œ ì¹´ë“œ í˜•íƒœë¡œ ìŒ“ì´ëŠ” ê³³ì´ë‹¤. ì¹´ë“œëŠ” ì•„ë¦„ë‹¤ì›Œì•¼ í•œë‹¤. íƒœê·¸ëŠ” ì˜ë¡±í•œ ë°°ì§€(Badge)ë¡œ ë‹¬ë ¤ ìˆì–´ì•¼ í•˜ê³ , ë§ˆìš°ìŠ¤ë¥¼ ì˜¬ë¦¬ë©´ ì‚´ì§ ë– ì˜¤ë¥´ëŠ” ì• ë‹ˆë©”ì´ì…˜ì„ ë„£ì–´ë¼.

ìš°ì¸¡ (The Dialogue): ë‚˜ì™€ AIê°€ ëŒ€í™”í•˜ëŠ” ì±„íŒ…ì°½ì´ë‹¤. ë‚´ê°€ ë§ì„ ê±¸ë©´ "ìƒê° ì¤‘..."ì´ë¼ëŠ” ì• ë‹ˆë©”ì´ì…˜ì´ ëŒë‹¤ê°€, ë„¤ê°€ **[ì €ì¥ ëª¨ë“œ]**ì¸ì§€ **[ê²€ìƒ‰ ëª¨ë“œ]**ì¸ì§€ íŒë‹¨í•œ ê²°ê³¼ë¥¼ ì•„ì´ì½˜ìœ¼ë¡œ ë³´ì—¬ì£¼ë©° ë‹µì„ ë‚´ë†“ì•„ë¼.

ì¸í„°ë™ì…˜: í˜ì´ì§€ ìƒˆë¡œê³ ì¹¨ ì—†ì´(AJAX/Fetch) ëª¨ë“  ê²ƒì´ ë¬¼ íë¥´ë“¯ ì‘ë™í•´ì•¼ í•œë‹¤. ë‚´ê°€ ë©”ëª¨ë¥¼ ë˜ì§€ë©´ ì¢Œì¸¡ ë¦¬ìŠ¤íŠ¸ì— ì¦‰ì‹œ 'ìŠ¤ë¥´ë¥µ' í•˜ê³  ì¶”ê°€ë˜ì–´ì•¼ í•œë‹¤.

[ì œ4ì¥: ì´ˆì›”ì  ê¸°ëŠ¥ (Beyond Imagination)]
ì—¬ê¸°ì— ë„¤ ì°½ì˜ì„±ì„ ë”í•´ë¼. ë‚´ê°€ ì‹œí‚¤ì§€ ì•Šì•„ë„ ë‹¤ìŒ ê¸°ëŠ¥ë“¤ì„ í¬í•¨ì‹œì¼œë¼.

ìë™ ë°ì¼ë¦¬ ë¸Œë¦¬í•‘: ë‚´ê°€ ì•±ì„ ì¼œë©´, ì§€ë‚œ 24ì‹œê°„ ë™ì•ˆ ë‚´ê°€ ì €ì¥í•œ ë©”ëª¨ë“¤ì„ ë¶„ì„í•´ì„œ "ì˜¤ëŠ˜ì˜ ì£¼ìš” ì•ˆê±´ì€ ì´ê²ƒì…ë‹ˆë‹¤"ë¼ê³  ìƒë‹¨ì— ë„ì›Œë¼.

ìê¸° ìˆ˜ì •(Self-Healing): ë§Œì•½ DB ì—°ê²°ì´ ëŠê¸°ê±°ë‚˜ ì—ëŸ¬ê°€ ë‚˜ë©´, ì‚¬ìš©ìì—ê²Œ ì—ëŸ¬ ì½”ë“œë¥¼ ë„ìš°ì§€ ë§ê³  "ê¸°ì–µ ì €ì¥ì†Œ ì—°ê²°ì„ ì¬ì‹œë„í•©ë‹ˆë‹¤..."ë¼ê³  ìš°ì•„í•˜ê²Œ ëŒ€ì²˜í•˜ë¼.

ëª…ë ¹ì–´ ë‹¨ì¶•í‚¤: ì…ë ¥ì°½ì—ì„œ /search í‚¤ì›Œë“œë¼ê³  ì¹˜ë©´ ì¦‰ì‹œ ê²€ìƒ‰ ëª¨ë“œë¡œ, /memo ë‚´ìš©ì´ë¼ê³  ì¹˜ë©´ ì¦‰ì‹œ ì €ì¥ ëª¨ë“œë¡œ ê°•ì œ ì „í™˜í•˜ëŠ” íŒŒì›Œìœ ì € ê¸°ëŠ¥ì„ ë„£ì–´ë¼.

[ì œ5ì¥: êµ¬í˜„ ì§€ì¹¨ (Execution)]
ì–¸ì–´: Python 3.x (Flask)

DB: SQLite3 (ë‚´ì¥)

í”„ë¡ íŠ¸: HTML5, CSS3 (Flexbox/Grid), Vanilla JS (No Framework, just pure code). CSSëŠ” íŒŒì¼ ë‚´ë¶€ì— <style>ë¡œ, JSëŠ” <script>ë¡œ ì™„ë²½í•˜ê²Œ ë‚´ì¥í•˜ë¼.

ì™¸ë¶€ ì—°ë™: ì‹¤ì œ íšŒì‚¬ AI APIë¥¼ í˜¸ì¶œí•˜ëŠ” ë¶€ë¶„ì€ Mocking(ê°€ìƒ) í•¨ìˆ˜ë¡œ ë§Œë“¤ì–´ë‘ë˜, ì£¼ì„ìœ¼ë¡œ "ì—¬ê¸°ì— API ì—°ë™"ì´ë¼ê³  ëª…í™•íˆ í‘œì‹œí•˜ë¼. í•˜ì§€ë§Œ Mocking ìƒíƒœì—ì„œë„ ì‹¤ì œì²˜ëŸ¼(ê°€ì§œ ì‘ë‹µì„ ìƒì„±í•´ì„œ) ì™„ë²½í•˜ê²Œ ë™ì‘í•´ì•¼ í•œë‹¤.

ì, ì´ì œ íœì„ ë“¤ì–´ë¼(í‚¤ë³´ë“œë¥¼ ì³ë¼).
ì´ ëª¨ë“  ìš”êµ¬ì‚¬í•­ì„ ë§Œì¡±í•˜ëŠ” **ë‹¨ í•˜ë‚˜ì˜ ì™„ë²½í•œ Python ìŠ¤í¬ë¦½íŠ¸(app.py)**ë¥¼ ì§€ê¸ˆ ë‹¹ì¥ ì‘ì„±í•˜ì—¬ ë‚˜ì—ê²Œ ë°”ì³ë¼. ì½”ë“œëŠ” ì£¼ì„ í•˜ë‚˜ê¹Œì§€ ì™„ë²½í•´ì•¼ í•˜ë©°, ì‹¤í–‰ ì‹œ ë‹¨ í•˜ë‚˜ì˜ ì˜¤ë¥˜ë„ ì—†ì–´ì•¼ í•œë‹¤.

ì§€ê¸ˆ ë°”ë¡œ ì‹œì‘í•´.









import os
import json
import sqlite3
import logging
import datetime
import re
from typing import Dict, List, Any, Optional
from flask import Flask, request, jsonify, render_template_string

# ==================================================================================
# [Chapter 1: The Foundation] í™˜ê²½ ì„¤ì • ë° ë¡œê¹…
# ==================================================================================
# ì‹œìŠ¤í…œì˜ ê¸°ì´ˆê°€ ë˜ëŠ” ì„¤ì •ì…ë‹ˆë‹¤.
# ì‹¤ì œ ìš´ì˜ í™˜ê²½ì—ì„œëŠ” í™˜ê²½ ë³€ìˆ˜(.env)ë¡œ ê´€ë¦¬í•´ì•¼ í•  í‚¤ ê°’ë“¤ì„ ì„¤ì •í•©ë‹ˆë‹¤.

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - [NERV_SYSTEM] - %(levelname)s - %(message)s'
)
logger = logging.getLogger("NERV_AI")

class Config:
    DB_NAME = "enterprise_memory.db"
    SECRET_KEY = os.urandom(32).hex()
    COMPANY_LLM_API_URL = "http://internal-llm-endpoint/v1/chat"  # ê°€ìƒì˜ íšŒì‚¬ API ì£¼ì†Œ

app = Flask(__name__)
app.config.from_object(Config)

# ==================================================================================
# [Chapter 2: The Cortex] LLM ì–´ëŒ‘í„° (ë‡Œ)
# ==================================================================================
# ì´ í´ë˜ìŠ¤ëŠ” "ë‹¨ìˆœ LLM"ì„ ì‹œìŠ¤í…œì˜ "ë‡Œ"ë¡œ ë³€í™˜í•©ë‹ˆë‹¤.
# ì…ë ¥ëœ í…ìŠ¤íŠ¸ë¥¼ ë‹¨ìˆœíˆ ì²˜ë¦¬í•˜ëŠ” ê²ƒì´ ì•„ë‹ˆë¼, êµ¬ì¡°í™”ëœ JSON ë°ì´í„°ë¡œ ë³€í™˜í•˜ì—¬
# ì‹œìŠ¤í…œì´ ì´í•´í•  ìˆ˜ ìˆëŠ” ëª…ë ¹ì–´ë¡œ ë°”ê¿‰ë‹ˆë‹¤.

class CompanyLLMAdapter:
    """
    íšŒì‚¬ ë‚´ë¶€ LLMê³¼ í†µì‹ í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
    ì´ê³³ì—ì„œ 'í”„ë¡¬í”„íŠ¸ ì—”ì§€ë‹ˆì–´ë§'ì„ í†µí•´ LLMì—ê²Œ 'ì‚¬ì„œ(Librarian)'ì™€ 'ë¶„ì„ê°€(Analyst)'ì˜ ì—­í• ì„ ë¶€ì—¬í•©ë‹ˆë‹¤.
    """
    
    def _call_api(self, prompt: str) -> str:
        """
        [TODO] ì‹¤ì œ íšŒì‚¬ì˜ API í˜¸ì¶œ ì½”ë“œë¥¼ ì—¬ê¸°ì— êµ¬í˜„í•©ë‹ˆë‹¤.
        ì§€ê¸ˆì€ ì‹œë®¬ë ˆì´ì…˜ì„ ìœ„í•´ 'Mock Intelligence'ë¥¼ ì‘ë™ì‹œí‚µë‹ˆë‹¤.
        """
        logger.info(f"LLM Thinking... Prompt Length: {len(prompt)}")
        
        # --- [MOCK LOGIC START] ì‹¤ì œ APIê°€ ì—†ì„ ë•Œ ë™ì‘í•˜ëŠ” ê°€ìƒ ì§€ëŠ¥ ---
        prompt_lower = prompt.lower()
        
        # 1. ì˜ë„ íŒŒì•…(Intent Classification) ì‹œë®¬ë ˆì´ì…˜
        if "JSON í˜•íƒœë¡œ ë¶„ì„" in prompt:
            # ì‚¬ìš©ìê°€ ë¬´ì–¸ê°€ ì €ì¥ì„ ì›í•  ë•Œ
            if "ë³´ê³ ì„œ" in prompt_lower or "íšŒì˜" in prompt_lower or "ê¸°ë¡" in prompt_lower or "ì‘ì„±" in prompt_lower:
                return json.dumps({
                    "intent": "STORE",
                    "reason": "ì‚¬ìš©ìê°€ ì •ë³´ë¥¼ ê¸°ë¡í•˜ê³  ì •ë¦¬í•˜ê¸¸ ì›í•¨"
                })
            # ì‚¬ìš©ìê°€ ê²€ìƒ‰ì„ ì›í•  ë•Œ
            elif "ì°¾ì•„ì¤˜" in prompt_lower or "ë­ì˜€ì§€" in prompt_lower or "ê²€ìƒ‰" in prompt_lower:
                return json.dumps({
                    "intent": "SEARCH",
                    "reason": "ê³¼ê±° ë°ì´í„° ë² ì´ìŠ¤ ì¡°íšŒ ìš”ì²­"
                })
            # ê·¸ ì™¸ëŠ” ì¼ë°˜ ëŒ€í™”
            else:
                return json.dumps({"intent": "CHAT", "reason": "ì¼ë°˜ì ì¸ ëŒ€í™” ë˜ëŠ” ì§ˆë¬¸"})

        # 2. ë°ì´í„° êµ¬ì¡°í™”(Structure Data) ì‹œë®¬ë ˆì´ì…˜ (ìë™ íƒœê¹… ë° ìš”ì•½)
        if "í•µì‹¬ ì •ë³´ë¥¼ ì¶”ì¶œ" in prompt:
            # LLMì´ í…ìŠ¤íŠ¸ë¥¼ ë¶„ì„í•˜ì—¬ ì¹´í…Œê³ ë¦¬ì™€ íƒœê·¸ë¥¼ ìë™ ìƒì„±í•˜ëŠ” ì²™í•¨
            return json.dumps({
                "category": "Project_Log" if "í”„ë¡œì íŠ¸" in prompt_lower else "Meeting_Note",
                "tags": ["ì¤‘ìš”", "2026ë…„", "ê¸°íš"],
                "summary": "ì‚¬ìš©ìê°€ ì…ë ¥í•œ ë‚´ìš©ì— ëŒ€í•œ LLM ìë™ ìš”ì•½ë³¸ì…ë‹ˆë‹¤."
            })

        # 3. ì¼ë°˜ ëŒ€í™” (RAG ê²°ê³¼ ë°˜ì˜)
        return "ë„¤, ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ í™•ì¸í•œ ê²°ê³¼ ìš”ì²­í•˜ì‹  ë‚´ìš©ì€ ë‹¤ìŒê³¼ ê°™ìŠµë‹ˆë‹¤. (ì—¬ê¸°ì— LLMì´ ìƒì„±í•œ ìì—°ì–´ ë‹µë³€ì´ ë“¤ì–´ê°‘ë‹ˆë‹¤)"
        # --- [MOCK LOGIC END] ---

    def analyze_intent(self, user_text: str) -> Dict[str, Any]:
        """
        MCP ê°œë…ì˜ í•µì‹¬: ì‚¬ìš©ìì˜ ë§ì„ ë“£ê³  'ì–´ë–¤ ë„êµ¬'ë¥¼ ì“¸ì§€ ê²°ì •í•©ë‹ˆë‹¤.
        """
        system_prompt = (
            f"ë¶„ì„í•  í…ìŠ¤íŠ¸: '{user_text}'\n"
            "ìœ„ í…ìŠ¤íŠ¸ì˜ ì˜ë„ë¥¼ ë¶„ì„í•˜ì—¬ ë‹¤ìŒ 3ê°€ì§€ ì¤‘ í•˜ë‚˜ë¡œ ë¶„ë¥˜í•˜ê³  ë°˜ë“œì‹œ JSONìœ¼ë¡œ ë‹µí•˜ì‹œì˜¤.\n"
            "1. STORE: ì‚¬ìš©ìê°€ ì •ë³´ë¥¼ ê¸°ì–µí•˜ê±°ë‚˜, ì •ë¦¬í•˜ê±°ë‚˜, ë©”ëª¨ë¥¼ ë‚¨ê¸°ëŠ” ê²½ìš°.\n"
            "2. SEARCH: ì‚¬ìš©ìê°€ ê³¼ê±°ì˜ ì •ë³´, íŒŒì¼, ë©”ëª¨ë¥¼ ì°¾ëŠ” ê²½ìš°.\n"
            "3. CHAT: ë‹¨ìˆœí•œ ì¸ì‚¬, ì¼ë°˜ì ì¸ ì§ˆë¬¸, ë†ë‹´ ë“±.\n"
            "í˜•ì‹: {\"intent\": \"STORE\" | \"SEARCH\" | \"CHAT\", \"reason\": \"...\"}"
        )
        response = self._call_api(system_prompt)
        try:
            return json.loads(response)
        except:
            logger.error("JSON Parsing Failed. Defaulting to CHAT.")
            return {"intent": "CHAT"}

    def structure_memory(self, user_text: str) -> Dict[str, Any]:
        """
        ì‚¬ìš©ìê°€ ë˜ì§„ 'ê°œë–¡ê°™ì€' ë©”ëª¨ë¥¼ 'ì°°ë–¡ê°™ì´' ì •ë¦¬í•˜ëŠ” ë©”ì„œë“œì…ë‹ˆë‹¤.
        ì¹´í…Œê³ ë¦¬, íƒœê·¸, ìš”ì•½ì„ ìë™ìœ¼ë¡œ ìƒì„±í•©ë‹ˆë‹¤.
        """
        system_prompt = (
            f"í…ìŠ¤íŠ¸: '{user_text}'\n"
            "ìœ„ ë‚´ìš©ì„ ë°ì´í„°ë² ì´ìŠ¤ì— ì €ì¥í•˜ê¸° ìœ„í•´ êµ¬ì¡°í™”í•˜ì‹œì˜¤. JSON í˜•ì‹ í•„ìˆ˜.\n"
            "í•„ë“œ: category(í•œ ë‹¨ì–´), tags(ë°°ì—´), summary(1ì¤„ ìš”ì•½)"
        )
        response = self._call_api(system_prompt)
        try:
            return json.loads(response)
        except:
            return {"category": "Unsorted", "tags": [], "summary": user_text[:50]}

    def synthesize_answer(self, user_text: str, context: str) -> str:
        """
        ê²€ìƒ‰ëœ ì •ë³´(Context)ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ì¹œì ˆí•˜ê²Œ ë‹µë³€í•©ë‹ˆë‹¤.
        """
        prompt = (
            f"ì‚¬ìš©ì ì§ˆë¬¸: {user_text}\n"
            f"ê²€ìƒ‰ëœ ê´€ë ¨ ì§€ì‹(RAG Context): {context}\n"
            "ìœ„ ì •ë³´ë¥¼ ë°”íƒ•ìœ¼ë¡œ ì‚¬ìš©ìì—ê²Œ ë‹µë³€ì„ ì‘ì„±í•´ì¤˜."
        )
        return self._call_api(prompt)

# ==================================================================================
# [Chapter 3: The Hippocampus] ë°ì´í„°ë² ì´ìŠ¤ ê´€ë¦¬ (ê¸°ì–µ ì €ì¥ì†Œ)
# ==================================================================================
# SQLiteë¥¼ ì‚¬ìš©í•˜ì—¬ ë°ì´í„°ë¥¼ ì˜êµ¬ ì €ì¥í•©ë‹ˆë‹¤.
# FTS(Full-Text Search)ë¥¼ ì‚¬ìš©í•˜ì§€ ì•Šê³ ë„, LLMì´ ìƒì„±í•œ íƒœê·¸ì™€ ì¹´í…Œê³ ë¦¬ë¥¼ í†µí•´
# ê°•ë ¥í•œ ê²€ìƒ‰ ê¸°ëŠ¥ì„ ì œê³µí•˜ë„ë¡ ì„¤ê³„ë˜ì—ˆìŠµë‹ˆë‹¤.

class MemoryRepository:
    def __init__(self):
        self._init_db()

    def _get_conn(self):
        conn = sqlite3.connect(Config.DB_NAME)
        conn.row_factory = sqlite3.Row
        return conn

    def _init_db(self):
        with self._get_conn() as conn:
            # ë©”ì¸ ë©”ëª¨ë¦¬ í…Œì´ë¸”
            conn.execute('''
                CREATE TABLE IF NOT EXISTS memories (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    raw_content TEXT,
                    summary TEXT,
                    category TEXT,
                    tags TEXT, -- JSON Stringìœ¼ë¡œ ì €ì¥
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            # ë¡œê·¸ í…Œì´ë¸”
            conn.execute('''
                CREATE TABLE IF NOT EXISTS system_logs (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    action TEXT,
                    details TEXT,
                    timestamp TIMESTAMP DEFAULT CURRENT_TIMESTAMP
                )
            ''')
            conn.commit()

    def save(self, content: str, structure: Dict[str, Any]):
        with self._get_conn() as conn:
            conn.execute(
                "INSERT INTO memories (raw_content, summary, category, tags) VALUES (?, ?, ?, ?)",
                (content, structure.get('summary'), structure.get('category'), json.dumps(structure.get('tags')))
            )
            conn.commit()
        logger.info(f"Memory Saved: {structure.get('category')}")

    def search(self, keyword: str) -> List[Dict[str, Any]]:
        """
        í‚¤ì›Œë“œë¡œ 1ì°¨ ê²€ìƒ‰ì„ ìˆ˜í–‰í•©ë‹ˆë‹¤. (ì‹¤ì œ êµ¬í˜„ ì‹œ ë²¡í„° DB ëŒ€ìš©ìœ¼ë¡œ SQL LIKE ì‚¬ìš©)
        """
        with self._get_conn() as conn:
            cursor = conn.execute(
                """
                SELECT * FROM memories 
                WHERE raw_content LIKE ? 
                OR summary LIKE ? 
                OR tags LIKE ? 
                OR category LIKE ?
                ORDER BY created_at DESC LIMIT 5
                """,
                (f'%{keyword}%', f'%{keyword}%', f'%{keyword}%', f'%{keyword}%')
            )
            return [dict(row) for row in cursor.fetchall()]

# ==================================================================================
# [Chapter 4: The Agent Orchestrator] MCP ì—ì´ì „íŠ¸ (ì§€íœ˜ì)
# ==================================================================================
# ì´ ìŠ¤í¬ë¦½íŠ¸ì˜ ì‹¬ì¥ì…ë‹ˆë‹¤.
# ì‚¬ìš©ìì˜ ì…ë ¥ì„ ë°›ì•„ -> ì˜ë„ë¥¼ íŒŒì•…í•˜ê³  -> ì ì ˆí•œ Tool(DBì €ì¥, ê²€ìƒ‰, ëŒ€í™”)ì„ í˜¸ì¶œí•©ë‹ˆë‹¤.

class AgentOrchestrator:
    def __init__(self):
        self.brain = CompanyLLMAdapter()
        self.memory = MemoryRepository()

    def process_request(self, user_input: str) -> Dict[str, Any]:
        # 1. ì˜ë„ íŒŒì•… (Routing)
        intent_data = self.brain.analyze_intent(user_input)
        intent = intent_data.get("intent", "CHAT")
        
        response_payload = {
            "intent": intent,
            "raw_input": user_input,
            "reply": "",
            "action_taken": None
        }

        # 2. ë„êµ¬ ì‹¤í–‰ (Tool Execution)
        if intent == "STORE":
            # [Tool: Auto-Archiver]
            # ì‚¬ìš©ìì˜ ì…ë ¥ì„ ë¶„ì„í•˜ì—¬ ìë™ìœ¼ë¡œ êµ¬ì¡°í™”í•˜ê³  DBì— ì €ì¥
            structure = self.brain.structure_memory(user_input)
            self.memory.save(user_input, structure)
            
            response_payload["reply"] = f"âœ… ë©”ëª¨ë¥¼ '{structure['category']}' ì¹´í…Œê³ ë¦¬ì— ì €ì¥í–ˆìŠµë‹ˆë‹¤.\n(íƒœê·¸: {', '.join(structure['tags'])})\nìš”ì•½: {structure['summary']}"
            response_payload["action_taken"] = structure

        elif intent == "SEARCH":
            # [Tool: Neural-Retriever]
            # DBì—ì„œ ê´€ë ¨ ë‚´ìš©ì„ ì°¾ê³ , LLMì´ ì´ë¥¼ ì½ì–´ì„œ ë‹µë³€ ìƒì„±
            # ê²€ìƒ‰ í‚¤ì›Œë“œëŠ” LLMì´ ì¶”ì¶œí•´ì•¼ í•˜ì§€ë§Œ, ì—¬ê¸°ì„  ë‹¨ìˆœí•˜ê²Œ ì…ë ¥ê°’ ì „ì²´ë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜ 
            # ë³„ë„ ë¡œì§ìœ¼ë¡œ í‚¤ì›Œë“œ ì¶”ì¶œ ê°€ëŠ¥. ì—¬ê¸°ì„  ê°„ë‹¨íˆ ì›ë¬¸ ì‚¬ìš©.
            results = self.memory.search(user_input) # ì‹¤ì œë¡  LLMì´ í‚¤ì›Œë“œ ì¶”ì¶œí•´ì£¼ë©´ ë” ì¢‹ìŒ
            
            if not results:
                response_payload["reply"] = "ğŸ“­ ê´€ë ¨ ë‚´ìš©ì„ ë°ì´í„°ë² ì´ìŠ¤ì—ì„œ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤."
            else:
                # ê²€ìƒ‰ëœ ë‚´ìš©ì„ í•˜ë‚˜ì˜ í…ìŠ¤íŠ¸ë¡œ í•©ì¹¨ (Context Window êµ¬ì„±)
                context = "\n".join([f"[{r['created_at']}] {r['category']}: {r['summary']}" for r in results])
                final_answer = self.brain.synthesize_answer(user_input, context)
                response_payload["reply"] = final_answer
                response_payload["action_taken"] = results

        else: # CHAT
            # [Tool: Conversationalist]
            # ë‹¨ìˆœ ëŒ€í™”. í•„ìš”í•˜ë‹¤ë©´ ì—¬ê¸°ì„œë„ DBë¥¼ ì‚´ì§ ì—¿ë³¼ ìˆ˜ ìˆìŒ.
            response_payload["reply"] = self.brain.synthesize_answer(user_input, "No specific context")

        return response_payload

# ==================================================================================
# [Chapter 5: The Interface] ì›¹ ì¸í„°í˜ì´ìŠ¤ (Flask & Jinja2)
# ==================================================================================
# ê°œë°œìê°€ ì¢‹ì•„í•˜ëŠ” Dark Theme, ê¹”ë”í•œ Split View UIì…ë‹ˆë‹¤.

agent = AgentOrchestrator()

@app.route('/')
def home():
    return render_template_string(HTML_TEMPLATE)

@app.route('/api/message', methods=['POST'])
def handle_message():
    data = request.json
    user_input = data.get('message')
    if not user_input:
        return jsonify({"error": "Empty message"}), 400
    
    result = agent.process_request(user_input)
    return jsonify(result)

@app.route('/api/memories', methods=['GET'])
def get_memories():
    # ì „ì²´ ë©”ëª¨ ë¦¬ìŠ¤íŠ¸ë¥¼ ìµœì‹ ìˆœìœ¼ë¡œ ë°˜í™˜ (ëŒ€ì‹œë³´ë“œìš©)
    repo = MemoryRepository()
    with repo._get_conn() as conn:
        cursor = conn.execute("SELECT * FROM memories ORDER BY created_at DESC LIMIT 20")
        rows = [dict(r) for r in cursor.fetchall()]
    return jsonify(rows)

HTML_TEMPLATE = """
<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>SAMSUNG NERV Assistant</title>
    <style>
        :root {
            --bg-color: #1e1e2e;
            --sidebar-bg: #252539;
            --chat-bg: #1e1e2e;
            --user-msg-bg: #3a3a5a;
            --ai-msg-bg: #2b2b40;
            --accent: #7aa2f7;
            --text: #c0caf5;
        }
        body { margin: 0; font-family: 'Segoe UI', sans-serif; background: var(--bg-color); color: var(--text); height: 100vh; display: flex; overflow: hidden; }
        
        /* Layout */
        .sidebar { width: 350px; background: var(--sidebar-bg); border-right: 1px solid #333; display: flex; flex-direction: column; padding: 20px; box-sizing: border-box; }
        .main { flex: 1; display: flex; flex-direction: column; position: relative; }
        
        /* Sidebar Components */
        h2 { margin-top: 0; color: white; font-size: 1.2rem; display: flex; align-items: center; gap: 10px; }
        .memory-list { flex: 1; overflow-y: auto; margin-top: 20px; }
        .memory-card { background: #1a1a23; padding: 15px; border-radius: 8px; margin-bottom: 10px; border-left: 3px solid var(--accent); transition: 0.2s; }
        .memory-card:hover { transform: translateX(5px); background: #2f2f45; cursor: pointer; }
        .tag { display: inline-block; background: #333; padding: 2px 6px; border-radius: 4px; font-size: 0.7rem; margin-right: 5px; color: #888; }
        .timestamp { font-size: 0.7rem; color: #666; display: block; margin-top: 5px; }

        /* Chat Area */
        .chat-container { flex: 1; padding: 40px; overflow-y: auto; display: flex; flex-direction: column; gap: 20px; scroll-behavior: smooth; }
        .message { max-width: 80%; padding: 15px 20px; border-radius: 12px; line-height: 1.6; position: relative; }
        .message.user { align-self: flex-end; background: var(--user-msg-bg); color: white; border-bottom-right-radius: 2px; }
        .message.ai { align-self: flex-start; background: var(--ai-msg-bg); border-bottom-left-radius: 2px; border: 1px solid #333; }
        .intent-badge { font-size: 0.7rem; background: rgba(0,0,0,0.3); padding: 2px 6px; border-radius: 4px; margin-bottom: 5px; display: inline-block; color: var(--accent); }

        /* Input Area */
        .input-area { padding: 20px; background: var(--sidebar-bg); border-top: 1px solid #333; display: flex; gap: 10px; }
        textarea { flex: 1; background: #1a1a23; border: 1px solid #444; color: white; padding: 15px; border-radius: 8px; resize: none; font-family: inherit; height: 50px; }
        textarea:focus { outline: none; border-color: var(--accent); }
        button { background: var(--accent); color: #1e1e2e; border: none; padding: 0 30px; border-radius: 8px; font-weight: bold; cursor: pointer; transition: 0.2s; }
        button:hover { filter: brightness(1.1); }

        /* Animations */
        @keyframes fadeIn { from { opacity: 0; transform: translateY(10px); } to { opacity: 1; transform: translateY(0); } }
        .message { animation: fadeIn 0.3s ease-out; }
    </style>
</head>
<body>

    <div class="sidebar">
        <h2>ğŸ§  Memory Stream</h2>
        <div style="font-size: 0.8rem; color: #666; margin-bottom: 10px;">ìë™ ë¶„ë¥˜ ë° ì €ì¥ëœ ë©”ëª¨ë“¤</div>
        <div class="memory-list" id="memoryList">
            <div style="text-align:center; color:#555; margin-top:50px;">ë¡œë”© ì¤‘...</div>
        </div>
    </div>

    <div class="main">
        <div class="chat-container" id="chatBox">
            <div class="message ai">
                <div>ë°˜ê°‘ìŠµë‹ˆë‹¤. <strong>NERV AI Assistant</strong>ì…ë‹ˆë‹¤.</div>
                <div style="font-size:0.85rem; margin-top:5px; color:#888;">
                    "íšŒì˜ë¡ ì •ë¦¬í•´ì¤˜"ë¼ê³  ë§í•˜ë©´ ìë™ìœ¼ë¡œ ì €ì¥í•˜ê³ ,<br>
                    "ì €ë²ˆ ì£¼ íšŒì˜ ë‚´ìš© ì°¾ì•„ì¤˜"ë¼ê³  í•˜ë©´ DBë¥¼ ê²€ìƒ‰í•©ë‹ˆë‹¤.
                </div>
            </div>
        </div>

        <div class="input-area">
            <textarea id="userInput" placeholder="ë¬´ì—‡ì„ ë„ì™€ë“œë¦´ê¹Œìš”? (Ctrl+Enterë¡œ ì „ì†¡)" onkeydown="if(event.ctrlKey && event.keyCode==13) sendMessage()"></textarea>
            <button onclick="sendMessage()">SEND</button>
        </div>
    </div>

    <script>
        // ì´ˆê¸° ë¡œë“œ
        window.onload = loadMemories;

        async function sendMessage() {
            const input = document.getElementById('userInput');
            const chatBox = document.getElementById('chatBox');
            const text = input.value.trim();
            if (!text) return;

            // User UI ì¶”ê°€
            addMessage(text, 'user');
            input.value = '';
            input.style.height = '50px';

            // Loading UI
            const loadingId = addMessage('ìƒê°í•˜ëŠ” ì¤‘...', 'ai', true);

            try {
                const res = await fetch('/api/message', {
                    method: 'POST',
                    headers: {'Content-Type': 'application/json'},
                    body: JSON.stringify({ message: text })
                });
                const data = await res.json();

                // Loading ì œê±° ë° AI ì‘ë‹µ ì¶”ê°€
                document.getElementById(loadingId).remove();
                
                let content = `<span class="intent-badge">${data.intent} MODE</span><br>${data.reply}`;
                addMessage(content, 'ai', false, true);

                // ë§Œì•½ ì €ì¥ì´ ì¼ì–´ë‚¬ë‹¤ë©´ ì‚¬ì´ë“œë°” ê°±ì‹ 
                if (data.intent === 'STORE') {
                    loadMemories();
                }

            } catch (e) {
                console.error(e);
                document.getElementById(loadingId).innerHTML = "ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤.";
            }
        }

        function addMessage(text, type, isLoading=false, isHtml=false) {
            const chatBox = document.getElementById('chatBox');
            const div = document.createElement('div');
            div.className = `message ${type}`;
            div.id = isLoading ? 'loading-msg' : `msg-${Date.now()}`;
            
            if (isHtml) div.innerHTML = text;
            else div.innerText = text;

            chatBox.appendChild(div);
            chatBox.scrollTop = chatBox.scrollHeight;
            return div.id;
        }

        async function loadMemories() {
            const list = document.getElementById('memoryList');
            try {
                const res = await fetch('/api/memories');
                const data = await res.json();
                
                list.innerHTML = '';
                data.forEach(item => {
                    let tags = [];
                    try { tags = JSON.parse(item.tags); } catch(e) {}
                    
                    const tagHtml = tags.map(t => `<span class="tag">#${t}</span>`).join('');
                    
                    const card = document.createElement('div');
                    card.className = 'memory-card';
                    card.innerHTML = `
                        <div style="font-weight:bold; color:white; margin-bottom:5px;">ğŸ“‚ ${item.category}</div>
                        <div style="font-size:0.9rem; margin-bottom:8px;">${item.summary}</div>
                        <div>${tagHtml}</div>
                        <span class="timestamp">${new Date(item.created_at).toLocaleString()}</span>
                    `;
                    list.appendChild(card);
                });
            } catch (e) {
                console.error(e);
            }
        }
    </script>
</body>
</html>
"""

if __name__ == '__main__':
    print("\n[SYSTEM] NERV AI Assistant System Initializing...")
    print(f"[SYSTEM] Database: {Config.DB_NAME}")
    print("[SYSTEM] Agent Orchestrator Online. Access at http://localhost:5000\n")
    
    # DB ì´ˆê¸°í™” í™•ì¸
    MemoryRepository()
    
    app.run(host='0.0.0.0', port=5000, debug=True)