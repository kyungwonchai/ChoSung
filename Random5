1. 개념 정리 (이것만 이해하시면 됩니다)
외부 접속 (다른 PC → 우분투 Dify):

Dify를 도커로 깔면 기본적으로 모든 IP(0.0.0.0)로 열립니다.

따라서, 다른 자리에서 크롬 켜고 http://192.168.0.xxx (우분투 IP)만 치면 Dify 접속 됩니다. 별도 설정 필요 없습니다.

내부 통신 (Dify → 브릿지 서버):

Dify(도커 내부)가 브릿지 서버(우분투 바탕화면)를 찾을 땐 host.docker.internal이라는 주소를 씁니다.

항시 실행:

아래 코드는 브릿지 서버를 **"우분투 서비스"**로 등록합니다. 마치 윈도우의 '서비스'처럼 백그라운드에서 조용히, 항상 돕니다.

2. (개선된) One-Shot 설치 스크립트
이 코드는 다음 3가지를 수행합니다.

server.py 생성 (API 키/주소 입력란을 맨 위로 뺐습니다)

requirements.txt 생성

install_service.sh 생성 (이게 핵심! 서비스 자동 등록 스크립트)

/home/kw 에서 nano setup_bridge_v2.py 등으로 파일을 만들고 붙여넣은 뒤 실행하세요.

Python
import os
import sys

# ==============================================================================
# [설정] 사용자 환경
# ==============================================================================
USER_HOME = "/home/kw"
PROJECT_NAME = "dify_bridge"
TARGET_DIR = os.path.join(USER_HOME, PROJECT_NAME)
VENV_PYTHON = os.path.join(USER_HOME, "myvenv1/bin/python") # 가상환경 파이썬

# ==============================================================================
# [파일 1] server.py : 브릿지 서버 소스코드
# ==============================================================================
SERVER_CODE = """
from flask import Flask, request, jsonify
import requests
import time
import json

app = Flask(__name__)

# ##############################################################################
# [사용자 수정 영역] 아래 따옴표 안에 회사 정보를 입력하세요.
# ##############################################################################

# 1. 회사 AI API 전체 주소 (http://... )
COMPANY_API_URL = "여기에_회사_API_주소를_넣으세요"

# 2. API 인증 키 (x-api-key 등)
COMPANY_API_KEY = "여기에_API_키를_넣으세요"

# 3. 기타 헤더 (아까 말씀하신 fsfds 같은 것, 필요 없으면 비워두세요)
OTHER_HEADER_KEY = "fsfds" 
OTHER_HEADER_VALUE = "헤더값_없으면_비워도_됨"

# ##############################################################################

@app.route('/v1/chat/completions', methods=['POST'])
def proxy_chat():
    print(f"\\n[LOG] Dify 요청 수신함")
    
    try:
        # 1. Dify 데이터 받기
        dify_data = request.json
        messages = dify_data.get('messages', [])
        
        # 마지막 질문 추출
        user_input = ""
        if messages:
            for msg in reversed(messages):
                if msg['role'] == 'user':
                    user_input = msg['content']
                    break
        
        print(f"[LOG] 사용자 질문: {user_input}")

        # 2. 회사 API 전송용 데이터 포장
        # (구조가 바뀌면 여기를 수정하세요)
        payload = {
            "input_type": "chat",
            "output_type": "chat",
            "input_value": user_input
        }

        # 헤더 조립
        headers = {
            "Content-Type": "application/json",
            "x-api-key": COMPANY_API_KEY
        }
        if OTHER_HEADER_VALUE:
            headers[OTHER_HEADER_KEY] = OTHER_HEADER_VALUE

        # 3. 회사 API 호출
        print(f"[LOG] 회사 API 호출 중... {COMPANY_API_URL}")
        response = requests.post(
            COMPANY_API_URL, 
            headers=headers, 
            json=payload,
            timeout=120
        )
        
        # 4. 결과 처리
        if response.status_code == 200:
            try:
                # JSON 응답인 경우
                resp_json = response.json()
                # ★중요★ 회사 API가 주는 JSON에서 답변이 들어있는 '키'를 찾아야 합니다.
                # 통째로 문자열로 변환해서 보냅니다. (나중에 로그 보고 깔끔하게 다듬으세요)
                ai_answer = str(resp_json) 
            except:
                # 텍스트 응답인 경우
                ai_answer = response.text
        else:
            ai_answer = f"Error: {response.status_code} - {response.text}"

        print(f"[LOG] 답변 반환 완료")

        # 5. Dify용 포맷으로 변환 (OpenAI 표준)
        openai_resp = {
            "id": "chatcmpl-" + str(int(time.time())),
            "object": "chat.completion",
            "created": int(time.time()),
            "model": "company-ai",
            "choices": [{
                "index": 0,
                "message": {"role": "assistant", "content": ai_answer},
                "finish_reason": "stop"
            }],
            "usage": {
                "prompt_tokens": len(user_input),
                "completion_tokens": len(ai_answer),
                "total_tokens": 0
            }
        }
        return jsonify(openai_resp)

    except Exception as e:
        print(f"[ERROR] {e}")
        return jsonify({"error": str(e)}), 500

@app.route('/v1/models', methods=['GET'])
def list_models():
    return jsonify({"object": "list", "data": [{"id": "company-ai", "object": "model"}]})

if __name__ == '__main__':
    # 0.0.0.0으로 열어야 도커가 접근 가능
    app.run(host='0.0.0.0', port=5001)
"""

# ==============================================================================
# [파일 2] install_service.sh : 서비스 자동 등록 스크립트
# ==============================================================================
SERVICE_SCRIPT = f"""#!/bin/bash

SERVICE_NAME="dify-bridge"
SERVICE_FILE="/etc/systemd/system/$SERVICE_NAME.service"

echo "[INFO] 1. 필수 라이브러리 설치 중..."
"{os.path.dirname(VENV_PYTHON)}/pip" install flask requests

echo "[INFO] 2. Systemd 서비스 파일 생성 중..."
# 서비스 파일 내용 작성 (root 권한 필요)
sudo bash -c "cat > $SERVICE_FILE" <<EOL
[Unit]
Description=Dify Bridge Server (Python Flask)
After=network.target

[Service]
User={os.getlogin()}
WorkingDirectory={TARGET_DIR}
ExecStart={VENV_PYTHON} {os.path.join(TARGET_DIR, 'server.py')}
Restart=always
RestartSec=5

[Install]
WantedBy=multi-user.target
EOL

echo "[INFO] 3. 서비스 등록 및 시작..."
sudo systemctl daemon-reload
sudo systemctl enable $SERVICE_NAME
sudo systemctl restart $SERVICE_NAME

echo "----------------------------------------------------"
echo "[완료] 브릿지 서버가 백그라운드 서비스로 실행되었습니다."
echo "상태 확인: sudo systemctl status $SERVICE_NAME"
echo "로그 확인: sudo journalctl -u $SERVICE_NAME -f"
echo "----------------------------------------------------"
"""

def create_files():
    # 폴더 생성
    if not os.path.exists(TARGET_DIR):
        os.makedirs(TARGET_DIR)
        print(f"폴더 생성됨: {TARGET_DIR}")

    # server.py 저장
    server_path = os.path.join(TARGET_DIR, "server.py")
    with open(server_path, "w", encoding="utf-8") as f:
        f.write(SERVER_CODE.strip())
    
    # install_service.sh 저장
    sh_path = os.path.join(TARGET_DIR, "install_service.sh")
    with open(sh_path, "w", encoding="utf-8") as f:
        f.write(SERVICE_SCRIPT.strip())
    os.chmod(sh_path, 0o755)

    print("-" * 50)
    print("파일 생성이 완료되었습니다!")
    print(f"1. 편집: nano {server_path}")
    print("   (열어서 COMPANY_API_URL 과 COMPANY_API_KEY 를 꼭 수정하세요!)")
    print("-" * 50)
    print(f"2. 실행: {sh_path}")
    print("   (이 명령어를 치면 서비스 등록/실행이 한 번에 됩니다)")
    print("-" * 50)

if __name__ == "__main__":
    create_files()
3. 따라 하실 순서 (딱 3단계)
단계 1. 파일 생성 및 키 입력
위의 긴 파이썬 코드를 복사해서 setup_v2.py로 저장하고 실행합니다.

python3 setup_v2.py

생성된 server.py를 열어 URL과 API 키를 수정합니다.

nano /home/kw/dify_bridge/server.py

맨 위쪽에 여기에_... 라고 된 한글 부분을 지우고 실제 값으로 채우세요.

저장(Ctrl+O, 엔터) 후 종료(Ctrl+X).

단계 2. 서비스 등록 (PM2 대신 이거 한 방이면 끝)
방금 생성된 설치 스크립트를 실행합니다.

Bash
/home/kw/dify_bridge/install_service.sh
비밀번호 물어보면 입력하세요.

이제 서버가 백그라운드에서 실행되기 시작했고, 재부팅 해도 알아서 켜집니다.

단계 3. Dify 연결 설정
브라우저에서 Dify 접속 (http://localhost 또는 http://우분투IP)

Settings -> Model Provider -> OpenAI-API-compatible -> Add Model

정보 입력:

Model Name: smd-ai (원하는 이름)

Base URL: http://host.docker.internal:5001/v1

(주의: 127.0.0.1 쓰지 마세요. 도커 안에선 host.docker.internal을 써야 바깥쪽 5001번에 닿습니다.)

Model Type: Chat

API Key: any (아무거나)

저장.

만약 안 되면? (로그 확인법)
서비스로 돌고 있어서 화면에 안 보입니다. 로그를 보고 싶으면 터미널에 이렇게 치세요.

Bash
# 실시간 로그 보기 (질문 던지고 이거 보면 됨)
sudo journalctl -u dify-bridge -f
이제 우분투 아이피만 알면 외부(타 부서, 옆 자리)에서도 이 Dify에 접속해서 업무 봇을 쓸 수 있습니다. 성공 기원합니다!