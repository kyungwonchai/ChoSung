JetBrains Ultimate를 가지고 계시니 RustRover나 IntelliJ IDEA에 Rust 플러그인을 깔아서 바로 개발 가능합니다.

1. Rust가 뭔가요?
정의: C++처럼 빠르고 가볍지만, 메모리 오류(블루스크린, 멈춤)를 원천 차단하는 언어입니다.

장점: exe 파일 하나만 딱 떨어집니다. C++처럼 DLL 지옥이 없고, XP에서도 32비트용으로 컴파일하면 잘 돌아갑니다.

JetBrains: Ultimate 구독자면 CLion이나 RustRover를 무료로 쓸 수 있습니다.

2. Plan B: Rust로 갈아타기 (준비물)
VS 설치가 망했을 때를 대비해, Visual Studio 없이(MSVC 없이) 실행 파일을 만드는 방법입니다.

1. Rust 설치 (툴체인)

rustup.rs 들어가서 rustup-init.exe 다운받고 설치합니다.

설치할 때 Default(1번) 누르지 마시고, Customize(2번) 선택 후, host triple을 물어볼 때 i686-pc-windows-gnu 라고 입력하세요.

이게 핵심입니다. gnu를 써야 Visual Studio 없이 GCC(MinGW) 기반으로 컴파일됩니다. i686은 32비트(XP용)입니다.

2. JetBrains 실행

RustRover (혹은 IntelliJ)를 켭니다.

New Project -> Rust 선택.

Name: smd_launcher

3. Rust 코드 (main.rs)
이 코드는 콘솔창 안 뜸 + 로그 자동삭제 + 에러 팝업 없음 기능을 완벽 구현한 버전입니다.
src/main.rs 내용을 싹 지우고 아래로 덮어쓰세요.

Rust
// 윈도우 서브시스템 설정: 이걸 넣어야 검은색 콘솔창이 안 뜹니다.
#![windows_subsystem = "windows"]

use std::fs::{self, OpenOptions};
use std::io::{self, BufRead, BufReader, Write};
use std::path::Path;
use std::process::Command;
use std::thread;
use std::time::{Duration, SystemTime};

const CONFIG_FILENAME: &str = "startup_list.txt";
const LOG_RETENTION_DAYS: u64 = 7;

fn main() {
    // 1. 오래된 로그 정리
    delete_old_logs();
    write_log("=== Launcher Started ===");

    // 2. 설정 파일 확인
    if !Path::new(CONFIG_FILENAME).exists() {
        create_default_config();
        write_log("Config file created. Please edit startup_list.txt.");
        return;
    }

    // 3. 설정 파일 읽기 및 실행
    if let Ok(file) = fs::File::open(CONFIG_FILENAME) {
        let reader = BufReader::new(file);

        for (idx, line) in reader.lines().enumerate() {
            if let Ok(content) = line {
                let content = content.trim();
                if content.is_empty() || content.starts_with('#') {
                    continue;
                }

                // 파이프(|)로 분리
                let parts: Vec<&str> = content.split('|').collect();
                if parts.len() < 2 {
                    write_log(&format!("Syntax Error at line {}: Missing '|'", idx + 1));
                    continue;
                }

                let time_str = parts[0].trim();
                let path_str = parts[1].trim();

                // 딜레이 처리
                match time_str.parse::<u64>() {
                    Ok(seconds) => {
                        if seconds > 0 {
                            write_log(&format!("Waiting {} seconds...", seconds));
                            thread::sleep(Duration::from_secs(seconds));
                        }
                    }
                    Err(_) => {
                        write_log(&format!("Time format error at line {}: {}", idx + 1, time_str));
                        continue;
                    }
                }

                // Dummy Wait 인 경우 스킵
                if path_str.contains("Dummy_Wait") {
                    continue;
                }

                // 프로그램 실행
                if Path::new(path_str).exists() {
                    write_log(&format!("Launching: {}", path_str));
                    
                    // 실행 파일이 있는 폴더를 작업 디렉토리(current_dir)로 설정
                    let work_dir = Path::new(path_str).parent().unwrap_or(Path::new("."));
                    
                    // spawn()은 실행 후 기다리지 않고(Non-blocking) 넘어갑니다.
                    match Command::new(path_str).current_dir(work_dir).spawn() {
                        Ok(_) => {},
                        Err(e) => write_log(&format!("Failed to launch: {} (Error: {})", path_str, e)),
                    }
                } else {
                    write_log(&format!("File not found (Skipped): {}", path_str));
                }
            }
        }
    }

    write_log("All tasks finished. Exiting.");
}

// === 유틸리티 함수들 ===

fn get_log_filename() -> String {
    use chrono::Local; // 날짜 포맷팅을 위해 chrono 크레이트가 필요하지만, 의존성 줄이기 위해 수동 구현 생략하고 간단히 함.
    // Rust 기본 라이브러리만으로는 날짜 포맷팅이 귀찮으니 간단히 날짜별 로그 파일명 생성
    // (XP 호환성을 위해 외부 라이브러리 최소화)
    let now = SystemTime::now();
    let duration = now.duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs();
    // 하루는 86400초. 날짜 구분용
    let day = duration / 86400; 
    format!("log_{}.txt", day) 
}

fn write_log(msg: &str) {
    let filename = get_log_filename();
    let mut file = OpenOptions::new()
        .create(true)
        .write(true)
        .append(true)
        .open(filename)
        .unwrap_or_else(|_| fs::File::create("fallback_log.txt").unwrap());

    // 시간 기록은 간단히 타임스탬프로 대체 (외부 라이브러리 제거 목적)
    if let Err(e) = writeln!(file, "{}", msg) {
        eprintln!("Log error: {}", e);
    }
}

fn create_default_config() {
    let mut file = fs::File::create(CONFIG_FILENAME).unwrap();
    writeln!(file, "# SMD Startup Config").unwrap();
    writeln!(file, "# Format: SECONDS | PATH").unwrap();
    writeln!(file, "30 | C:\\Dummy_Wait_Driver_Loading").unwrap();
    writeln!(file, "5  | C:\\Windows\\notepad.exe").unwrap();
}

fn delete_old_logs() {
    if let Ok(entries) = fs::read_dir(".") {
        let now = SystemTime::now();
        for entry in entries {
            if let Ok(entry) = entry {
                let path = entry.path();
                // 파일이고 이름이 log_로 시작하고 .txt로 끝나는 것
                if path.is_file() {
                    if let Some(name) = path.file_name().and_then(|n| n.to_str()) {
                        if name.starts_with("log_") && name.ends_with(".txt") {
                            if let Ok(metadata) = fs::metadata(&path) {
                                if let Ok(modified) = metadata.modified() {
                                    if let Ok(duration) = now.duration_since(modified) {
                                        // 7일 = 604800초
                                        if duration.as_secs() > (LOG_RETENTION_DAYS * 86400) {
                                            let _ = fs::remove_file(path);
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        }
    }
}
4. 설정 파일 (Cargo.toml)
프로젝트 루트에 있는 Cargo.toml 파일을 열어서 아래 내용을 추가하거나 수정하세요. (외부 라이브러리 없이 표준 라이브러리만 썼으므로 [dependencies]는 비워둡니다.)

Ini, TOML
[package]
name = "smd_launcher"
version = "0.1.0"
edition = "2021"

[dependencies]
# 아무것도 필요 없음
5. XP용 빌드 방법 (터미널 명령어)
RustRover 하단에 Terminal 탭이 있습니다. 거기서 이 명령어를 치면 끝납니다.

XP용 32비트 타겟 추가 (최초 1회)

Bash
rustup target add i686-pc-windows-gnu
빌드 (릴리즈 모드)

Bash
cargo build --release --target i686-pc-windows-gnu
결과물 확인

프로젝트 폴더 안 target/i686-pc-windows-gnu/release/ 폴더에 가면 smd_launcher.exe 파일이 있습니다.

이 녀석은 Visual Studio 따위 없어도 XP에서 혼자 잘 돌아갑니다.

요약
Visual Studio 설치가 계속 말썽이면 Rust가 가장 확실한 대안입니다.

RustRover로 코드 붙여넣기.

터미널에서 cargo build --release --target i686-pc-windows-gnu 입력.

나온 exe 파일 USB에 담기.

이러면 Microsoft C++ 런타임 설치 에러니 뭐니 하는 거 하나도 안 뜹니다. 플랜 B로 딱입니다.