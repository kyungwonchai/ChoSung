import os

base_dir = "runcline"
if not os.path.exists(base_dir):
    print("âŒ ì˜¤ë¥˜: 'runcline' í´ë”ê°€ ì—†ìŠµë‹ˆë‹¤.")
    exit()

print("ğŸš€ AI Bridge v46: Absolute Restoration (Typo Extermination)...")

# 1. api_routes.py (ë³€ìˆ˜ëª… 'visitor_ip'ë¡œ í†µì¼, ëª¨ë“  ê¸°ëŠ¥ í¬í•¨)
full_api_code = r"""from flask import Blueprint, request, jsonify, abort
from app.database import get_db_connection
import subprocess, os, json, shlex, urllib.request, ssl, re, base64

api_bp = Blueprint('api', __name__)

# ==========================================
# ğŸ›¡ï¸ [IP í™”ì´íŠ¸ë¦¬ìŠ¤íŠ¸ ì„¤ì •]
# í„°ë¯¸ë„ì— ì°íˆëŠ” 'ACCESS ATTEMPT FROM' ë’¤ì˜ ì•„ì´í”¼ë¥¼ ì—¬ê¸° ë„£ìœ¼ì„¸ìš”.
# ==========================================
IP_WHITELIST = ["127.0.0.1", "localhost", "192.168.0.10"] 

def get_actual_ip():
    # ì‚¬ë‚´ë§/í”„ë¡ì‹œ í™˜ê²½ ëŒ€ì‘: ì§„ì§œ í´ë¼ì´ì–¸íŠ¸ ì•„ì´í”¼ ì¶”ì¶œ
    x_forwarded = request.headers.get('X-Forwarded-For')
    if x_forwarded:
        return x_forwarded.split(',')[0].strip()
    real_ip = request.headers.get('X-Real-IP')
    if real_ip:
        return real_ip.strip()
    return request.remote_addr

@api_bp.before_app_request
def ip_security_check():
    # ì •ì  íŒŒì¼ ê²½ë¡œëŠ” ë³´ì•ˆ ì²´í¬ ì œì™¸ (CSS/JS ë¡œë”©ìš©)
    if request.path.startswith('/static'):
        return

    # ë³€ìˆ˜ëª… í†µì¼: visitor_ip (ì˜¤íƒ€ ì ˆëŒ€ ì—†ìŒ)
    visitor_ip = get_actual_ip()
    
    # í„°ë¯¸ë„ ë¡œê·¸ ì¶œë ¥ - ì´ê±¸ ë³´ê³  ë¦¬ìŠ¤íŠ¸ë¥¼ ì—…ë°ì´íŠ¸ í•˜ì„¸ìš”
    print(f"ğŸ“¡ [DEBUG] ACCESS ATTEMPT FROM: {visitor_ip} | TARGET: {request.path}")

    if visitor_ip not in IP_WHITELIST:
        print(f"ğŸš« [BLOCKED] Unauthorized Access Attempt: {visitor_ip}")
        abort(403, description=f"Unauthorized. Your IP is {visitor_ip}")

# --- [STATS] Dashboard ---
@api_bp.route('/stats/dashboard', methods=['GET'])
def get_dashboard_stats():
    conn = get_db_connection(); cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT ISNULL(GroupName, IPAddress) as GroupName, COUNT(*) as Cnt FROM cline_FolderIndex GROUP BY ISNULL(GroupName, IPAddress)")
    groups = cursor.fetchall()
    cursor.execute("SELECT ISNULL(f.GroupName, f.IPAddress) as GroupName, COUNT(*) as Cnt FROM cline_TaskQueue q JOIN cline_FolderIndex f ON q.ProjectPath = f.FullPath WHERE q.Status IN ('Pending', 'Processing') GROUP BY ISNULL(f.GroupName, f.IPAddress)")
    active = cursor.fetchall()
    def gs(sql):
        cursor.execute(sql); r = cursor.fetchone()
        return {'cnt': r['Cnt'], 'dur': r['Dur']} if r else {'cnt': 0, 'dur': 0}
    d = gs("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(day, -1, GETDATE()) AND Status='Done'")
    w = gs("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(day, -7, GETDATE()) AND Status='Done'")
    m = gs("SELECT COUNT(*) as Cnt, ISNULL(SUM(DATEDIFF(SECOND, StartedAt, CompletedAt)), 0) as Dur FROM cline_TaskQueue WHERE CreatedAt >= DATEADD(month, -1, GETDATE()) AND Status='Done'")
    conn.close(); return jsonify({'groups': groups, 'active': active, 'counts': {'day': d, 'week': w, 'month': m}})

# --- [RULE] Deploy ---
@api_bp.route('/rules/deploy', methods=['POST'])
def deploy_rule():
    data = request.json
    p_name, p_path, r_id = data.get('project_name'), data.get('project_path'), data.get('rule_id')
    conn = get_db_connection(); cursor = conn.cursor(as_dict=True)
    cursor.execute("SELECT RuleName, RuleContent FROM cline_ProjectRules WHERE RuleID=%s", (r_id,))
    rule = cursor.fetchone()
    cursor.execute("SELECT IPAddress, Account FROM cline_FolderIndex WHERE FullPath=%s", (p_path,))
    tgt = cursor.fetchone()
    if not rule or not tgt: conn.close(); return jsonify({'status': 'error', 'message': 'Not found'})
    
    f_content = rule['RuleContent'].replace('{SUBJECT}', p_name).replace('{TARGET_PATH}', p_path.replace('\\', '/'))
    r_dir = os.path.join(p_path, ".clinerules").replace('\\', '/')
    r_file = os.path.join(r_dir, "absoluterule.md").replace('\\', '/')
    b64 = base64.b64encode(f_content.encode('utf-8')).decode('utf-8')
    
    if tgt['IPAddress'] in ['127.0.0.1', 'localhost']:
        if not os.path.exists(r_dir): os.makedirs(r_dir, exist_ok=True)
        with open(r_file, 'w', encoding='utf-8') as f: f.write(f_content)
        ok = True
    else:
        cmd = f"mkdir -p {shlex.quote(r_dir)} && echo '{b64}' | base64 -d > {shlex.quote(r_file)}"
        res = subprocess.run(['ssh', f"{tgt['Account']}@{tgt['IPAddress']}", cmd], capture_output=True, text=True)
        ok = (res.returncode == 0)
    
    if ok: cursor.execute("UPDATE cline_FolderIndex SET LastRuleName=%s WHERE FullPath=%s", (rule['RuleName'], p_path)); conn.commit()
    conn.close(); return jsonify({'status': 'success' if ok else 'error'})

# --- [GIT] Auto Connect ---
@api_bp.route('/git/auto_connect', methods=['POST'])
def git_auto_connect():
    data = request.json; ip, user, path, token, nuke = data.get('ip'), data.get('account'), data.get('path'), data.get('token'), data.get('nuke')
    def run_cmd(c_ip, c_user, c_path, cmd_list):
        if c_ip in ['127.0.0.1', 'localhost']:
            r = subprocess.run(cmd_list, cwd=c_path, capture_output=True, text=True)
        else:
            r = subprocess.run(['ssh', f'{c_user}@{c_ip}', f"cd {c_path} && {' '.join(cmd_list)}"], capture_output=True, text=True)
        return r
    
    if nuke: run_cmd(ip, user, path, ['rm', '-rf', '.git'])
    run_cmd(ip, user, path, ['git', 'init'])
    repo = "cline_" + re.sub(r'[^a-zA-Z0-9_-]', '_', os.path.basename(path.rstrip('/\\')))
    real_url = f"https://github.sec.samsung.net/{user}/{repo}.git"
    auth_url = real_url.replace("https://", f"https://{user}:{token}@", 1)
    run_cmd(ip, user, path, ['git', 'remote', 'remove', 'origin'])
    run_cmd(ip, user, path, ['git', 'remote', 'add', 'origin', auth_url])
    run_cmd(ip, user, path, ['git', 'add', '.'])
    run_cmd(ip, user, path, ['git', 'commit', '-m', 'Init'])
    run_cmd(ip, user, path, ['git', 'push', '-u', 'origin', 'main'])
    return jsonify({'status': 'success'})

# --- [SYSTEM] VSCode, Queue ---
@api_bp.route('/open_vscode', methods=['POST'])
def open_vscode():
    d = request.json
    cmd = ['code', '--new-window']
    if d['ip'] not in ['127.0.0.1', 'localhost']: cmd.extend(['--remote', f"ssh-remote+{d['account']}@{d['ip']}", d['path']])
    else: cmd.append(d['path'])
    subprocess.Popen(cmd, env=os.environ.copy()); return jsonify({'status': 'success'})

@api_bp.route('/queue', methods=['GET', 'POST', 'DELETE'])
def handle_queue():
    conn = get_db_connection(); cursor = conn.cursor(as_dict=True)
    if request.method == 'GET':
        cursor.execute("SELECT TaskID, ProjectName, TaskContent, Status FROM cline_TaskQueue WHERE Status IN ('Pending', 'Processing') ORDER BY TaskID")
        rows = cursor.fetchall(); conn.close(); return jsonify(rows)
    if request.method == 'POST':
        d = request.json; cursor.execute("INSERT INTO cline_TaskQueue (ProjectName, ProjectPath, TaskContent) VALUES (%s, %s, %s)", (d['project'], d['path'], d['content']))
        conn.commit(); conn.close(); return jsonify({'status': 'success'})
    if request.method == 'DELETE':
        cursor.execute("DELETE FROM cline_TaskQueue WHERE TaskID=%s", (request.args.get('id'),)); conn.commit(); conn.close(); return jsonify({'status': 'success'})

@api_bp.route('/bookmarks', methods=['GET'])
def get_bookmarks():
    conn = get_db_connection(); cursor = conn.cursor(as_dict=True); cursor.execute("SELECT * FROM cline_WebBookmarks"); r = cursor.fetchall(); conn.close(); return jsonify(r)
"""

with open(os.path.join(base_dir, "app", "routes", "api_routes.py"), "w", encoding="utf-8") as f:
    f.write(full_api_code)

print("\nâœ… v46 ì—…ë°ì´íŠ¸ ì™„ë£Œ! 'cline_ip' ì˜¤íƒ€ë¥¼ ì™„ì „íˆ ì œê±°í–ˆìŠµë‹ˆë‹¤.")
print("ğŸ‘‰ 'python3 run_bridge.py' ì‹¤í–‰ í›„ í„°ë¯¸ë„ì— ì°íˆëŠ” IPë¥¼ í™•ì¸í•˜ì„¸ìš”.")