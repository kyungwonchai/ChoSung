작성하겠습니다.

최종 코드: SocketClientMergeOI 클래스
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientMergeOI
{
    private TcpClient _client; // TCP 클라이언트 객체
    private NetworkStream _stream; // 데이터를 송수신할 네트워크 스트림
    private readonly string _ipAddress; // 접속할 서버의 IP 주소
    private readonly int _port; // 접속할 서버의 포트 번호
    private bool _isConnected; // 서버와 연결 여부를 나타내는 플래그
    private readonly int _retryInterval = 10000; // 10초 간격으로 재연결 시도

    // 연결 상태가 변경될 때 발생하는 이벤트
    public event Action<string> ConnectionStatusChanged;

    // 서버로부터 메시지를 수신했을 때 발생하는 이벤트
    public event Action<string> MessageReceived;

    // 서버로 메시지를 성공적으로 전송했을 때 발생하는 이벤트
    public event Action<string> CommandSent;

    // 생성자: IP 주소와 포트를 받아서 소켓 클라이언트를 초기화
    public SocketClientMergeOI(string ipAddress, int port)
    {
        _ipAddress = ipAddress; // 입력받은 IP 주소 저장
        _port = port; // 입력받은 포트 번호 저장
        _client = new TcpClient(); // TCP 클라이언트 생성
        _isConnected = false; // 초기 연결 상태는 false
        StartConnectionAttemptAsync(); // 서버 연결 시도 시작
    }

    // 비동기적으로 서버에 연결을 시도하는 함수
    private async void StartConnectionAttemptAsync()
    {
        while (!_isConnected) // 연결되지 않을 동안 반복해서 연결 시도
        {
            try
            {
                await _client.ConnectAsync(_ipAddress, _port); // 서버에 연결 시도
                _isConnected = true; // 연결 성공 시 플래그를 true로 설정
                _stream = _client.GetStream(); // 서버와의 통신을 위한 스트림 생성
                ConnectionStatusChanged?.Invoke("Connected"); // 연결 상태 변경 이벤트 발생
                StartReceiving(); // 서버로부터 메시지 수신 대기 시작
            }
            catch (Exception)
            {
                ConnectionStatusChanged?.Invoke("Retrying in 10 seconds..."); // 연결 실패 시 재시도 메시지 발생
                await Task.Delay(_retryInterval); // 10초 후 다시 연결 시도
            }
        }
    }

    // 서버에 메시지를 보내고 응답을 받는 비동기 함수
    public async Task<string> SendAndReceiveMessageAsync(string message)
    {
        if (!_isConnected) // 연결이 되어 있지 않으면
            return "Not connected"; // 연결되지 않았음을 반환

        string fullMessage = $"\x02{message}\x03"; // STX와 ETX를 추가하여 메시지 포맷을 구성
        byte[] messageBytes = Encoding.ASCII.GetBytes(fullMessage); // 메시지를 바이트 배열로 변환

        try
        {
            await _stream.WriteAsync(messageBytes, 0, messageBytes.Length); // 서버로 메시지 전송
            CommandSent?.Invoke(message); // 전송된 명령어 이벤트 발생
        }
        catch (Exception)
        {
            return "Send Failed"; // 전송 실패 시 에러 메시지 반환
        }

        // 응답을 대기하고 응답을 검증
        string response = await ReceiveMessageAsync(); // 서버로부터 응답을 비동기적으로 수신
        return ValidateResponse(message, response); // 응답을 검증 후 결과 반환
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async Task<string> ReceiveMessageAsync()
    {
        byte[] buffer = new byte[1024]; // 수신한 데이터를 저장할 버퍼 생성

        try
        {
            int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 읽음
            if (bytesRead > 0) // 읽은 데이터가 있을 경우
            {
                string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 바이트 데이터를 문자열로 변환
                MessageReceived?.Invoke(receivedMessage); // 메시지 수신 이벤트 발생
                return receivedMessage; // 수신한 메시지를 반환
            }
        }
        catch (Exception)
        {
            _isConnected = false; // 연결이 끊겼을 경우 플래그를 false로 설정
            ConnectionStatusChanged?.Invoke("Connection lost, retrying..."); // 연결이 끊겼다는 메시지 발생
            StartConnectionAttemptAsync(); // 다시 연결 시도
        }

        return string.Empty; // 수신 실패 시 빈 문자열 반환
    }

    // 서버로부터 받은 응답을 검증하는 함수
    private string ValidateResponse(string sentMessage, string receivedMessage)
    {
        // STX와 ETX로 감싸진 메시지인지 확인
        if (receivedMessage.StartsWith("\x02") && receivedMessage.EndsWith("\x03"))
        {
            string cleanMessage = receivedMessage.Trim('\x02', '\x03'); // STX와 ETX를 제거한 메시지 추출
            if (cleanMessage == "OK") // 응답이 "OK"인 경우
            {
                return "OK"; // 정상적인 응답 반환
            }
            else if (cleanMessage == sentMessage) // 응답이 전송한 메시지와 동일한 경우 (NG 응답)
            {
                return "NG"; // NG 응답 반환
            }
        }
        return "Invalid Response"; // 유효하지 않은 응답일 경우
    }

    // 연결을 중지하는 함수
    public void StopConnection()
    {
        _isConnected = false; // 연결 상태를 false로 설정
        _stream?.Close(); // 스트림을 닫음
        _client?.Close(); // TCP 클라이언트를 닫음
    }
}
Main 클래스 (사용 예시 및 이벤트 처리)
이제 Main에서 이 SocketClientMergeOI 클래스를 어떻게 사용하는지와 이벤트 핸들링을 어떻게 설정할 수 있는지 보여드리겠습니다.

csharp
코드 복사
using System;
using System.Threading.Tasks;

public class MainProgram
{
    public static async Task Main(string[] args)
    {
        // 1. SocketClientMergeOI 인스턴스를 생성하여 서버 IP와 포트 설정
        SocketClientMergeOI socketClient = new SocketClientMergeOI("127.0.0.1", 2400);

        // 2. 이벤트 핸들러를 추가하여 연결 상태 변경, 메시지 수신, 명령 전송을 처리

        // 연결 상태가 변경될 때 호출되는 이벤트 핸들러
        socketClient.ConnectionStatusChanged += OnConnectionStatusChanged;

        // 서버로부터 메시지를 수신했을 때 호출되는 이벤트 핸들러
        socketClient.MessageReceived += OnMessageReceived;

        // 명령어가 성공적으로 전송되었을 때 호출되는 이벤트 핸들러
        socketClient.CommandSent += OnCommandSent;

        // 3. 신호 전송 및 응답 처리
        string commandToSend = "TestCommand"; // 테스트용 명령어
        string response = await socketClient.SendAndReceiveMessageAsync(commandToSend); // 명령 전송 및 응답 처리

        // 응답이 OK인지 NG인지 확인
        if (response == "OK")
        {
            Console.WriteLine("전송 성공: 응답이 OK입니다.");
        }
        else if (response == "NG")
        {
            Console.WriteLine("전송 실패: 응답이 NG입니다.");
        }
        else
        {
            Console.WriteLine("잘못된 응답을 받았습니다.");
        }

        // 프로그램 종료 전 연결 종료
        socketClient.StopConnection();
    }

    // 연결 상태가 변경될 때 호출되는 함수
    private static void OnConnectionStatusChanged(string statusMessage)
    {
        Console.WriteLine($"연결 상태: {statusMessage}");
    }

    // 서버로부터 메시지를 수신했을 때 호출되는 함수
    private static void OnMessageReceived(string receivedMessage)
    {
        Console.WriteLine($"서버로부터 수신된 메시지: {receivedMessage}");
    }

    // 명령어가 성공적으로 전송되었을 때 호출되는 함수
    private static void OnCommandSent(string command)
    {
        Console.WriteLine($"서버로 전송된 명령: {command}");
    }
}
설명:
Main 프로그램에서 SocketClientMergeOI 사용

SocketClientMergeOI 인스턴스를 생성하고, 서버의 IP 주소와 포트 번호를 지정합니다.
이벤트 핸들러를 설정하여 연결 상태 변경, 메시지 수신, 명령 전송에 대한 이벤트 처리를 등록합니다.
SendAndReceiveMessageAsync 함수를 호출하여 서버로 명령을 전송하고, 응답을 처리합니다.
이벤트 처리

ConnectionStatusChanged: 서버 연결 상태가 변경될 때 호출됩니다. 연결 성공 또는 재시도 상태를 출력합니다.
MessageReceived: 서버로부터 메시지를 수신하면 호출됩니다. 수신된 메시지를 출력합니다.
CommandSent: 서버로 명령어가 성공적으로 전송되면 호출됩니다. 전송된 명령어를 출력합니다.
응답 처리

