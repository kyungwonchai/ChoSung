
응답 2
AddAsyncTaskCommand 함수가 async가 아닌 경우에는, 비동기 코드에서 사용하는 await을 사용할 수 없으므로 SemaphoreSlim.WaitAsync()를 대신하여 동기 방식의 Wait() 메서드를 사용해야 합니다.

아래 코드는 AddAsyncTaskCommand가 동기 방식으로 실행되면서, COM 포트가 재연결 상태일 때는 세마포어를 사용하여 동기적으로 대기하는 방식으로 구성한 예제입니다.

예제 코드 (비동기 메서드 없이 세마포어 사용)
SemaphoreSlim.Wait()를 사용하여 동기적으로 대기합니다.
재연결 완료 시, 세마포어를 Release()하여 대기 중인 작업이 실행될 수 있도록 합니다.
ComPortManager 클래스 (COM 포트 관리)
먼저, COM 포트를 관리하는 클래스인 ComPortManager는 이전과 동일하게 COM 포트의 재연결 상태를 관리합니다. IsRetrying 플래그와 ReconnectCompleted 이벤트를 통해 다른 클래스에서 COM 포트가 재시도 중인지 상태를 확인할 수 있도록 합니다.

csharp
코드 복사
public class ComPortManager
{
    public bool IsRetrying { get; private set; } = false; // COM 포트 재시도 상태
    public event Action ReconnectCompleted; // 재연결 완료 시 이벤트 발생

    public bool CloseAndReopenComPortWithRetry()
    {
        IsRetrying = true; // 재시도 상태 설정

        try
        {
            LogT5("COM 포트 닫는 중...");
            comPort.Close();
            LogT5("COM 포트 닫힘 성공.");
        }
        catch (Exception ex)
        {
            LogT5($"COM 포트 닫기 실패: {ex.Message}");
            IsRetrying = false;
            ReconnectCompleted?.Invoke(); // 대기 중인 작업 해제
            return false;
        }

        for (int i = 0; i < 500000; i++)
        {
            try
            {
                LogT5($"COM 포트 열기 시도 중... (시도 횟수: {i + 1})");
                comPort.Open();
                LogT5("COM 포트 열림 성공.");

                IsRetrying = false; // 재시도 상태 해제
                ReconnectCompleted?.Invoke(); // 대기 중인 작업 해제
                return true;
            }
            catch (Exception ex)
            {
                LogT5($"COM 포트 열기 실패: {ex.Message} (시도 횟수: {i + 1})");
                System.Threading.Thread.Sleep(5); // 짧은 대기 후 다시 시도
            }
        }

        IsRetrying = false;
        ReconnectCompleted?.Invoke(); // 대기 중인 작업 해제
        LogT5("COM 포트 열기 시도 500,000번 초과, 포트 열기 실패.");
        return false;
    }

    private void LogT5(string message)
    {
        msgvs.Instance.LogT5($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }
}
CommandQueueManager 클래스 (동기 방식의 명령 추가)
이제 CommandQueueManager 클래스에서 AddAsyncTaskCommand를 동기적으로 실행하면서 COM 포트가 재연결 중일 때 대기하도록 합니다.

csharp
코드 복사
public class CommandQueueManager
{
    private readonly ComPortManager comPortManager; // COM 포트 관리자 클래스 인스턴스
    private readonly SemaphoreSlim comPortSemaphore = new SemaphoreSlim(1, 1); // 대기 제어용 세마포어

    public CommandQueueManager(ComPortManager comPortManager)
    {
        this.comPortManager = comPortManager;

        // 재연결 완료 시 대기 해제 이벤트 연결
        this.comPortManager.ReconnectCompleted += () => comPortSemaphore.Release();
    }

    // 비동기 메서드가 아닌, 동기적으로 실행되는 명령 추가 메서드
    public void AddAsyncTaskCommand(Action command)
    {
        // COM 포트가 재시도 중이라면 동기적으로 대기
        if (comPortManager.IsRetrying)
        {
            LogT5("COM 포트 재시도 중, AddAsyncTaskCommand 대기 중...");
            comPortSemaphore.Wait(); // 재시도 끝날 때까지 대기 (동기 방식)
        }

        // 대기 후 큐에 작업 추가
        LogT5("AddAsyncTaskCommand: 명령 추가 중...");
        TaskQueue.Enqueue(command); // 큐에 명령 추가
    }

    private void LogT5(string message)
    {
        msgvs.Instance.LogT5($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }
}
코드 설명
세마포어 대기 (Wait):

AddAsyncTaskCommand가 async가 아닌 동기 메서드이므로, 비동기 메서드에서 사용하는 await 대신 동기적인 comPortSemaphore.Wait()를 사용하여 COM 포트가 정상 상태가 될 때까지 대기합니다.
COM 포트 재연결 완료 시 이벤트 발생:

ReconnectCompleted 이벤트가 발생하면 comPortSemaphore.Release()가 호출되어, 대기 중인 작업이 해제됩니다. 이로 인해 AddAsyncTaskCommand는 comPortSemaphore.Wait()에서 빠져나와 큐에 명령을 추가할 수 있게 됩니다.
대기 해제 및 명령 추가:

COM 포트가 정상 연결된 상태가 되면 AddAsyncTaskCommand는 세마포어의 대기가 해제되며 큐에 명령을 추가할 수 있게 됩니다. 이는 COM 포트 재연결이 완료된 상태에서만 새로운 명령이 추가되도록 보장합니다.
이 코드로 동기 방식의 세마포어 대기를 활용하여 COM 포트의 재연결 상태에 따른 명령 추가 제어를 구현할 수 있습니다.
