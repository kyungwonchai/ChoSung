는 C# OpenCV를 사용하여 지정된 영역에서 특정 색상 범위를 만족하는 직사각형을 탐색하고, 200x30 이상의 크기를 만족하는 경우 마우스 클릭 및 키보드 입력을 자동 수행하는 비동기 코드입니다.

🔹 핵심 기능
스크린샷을 캡처하여 OpenCV Mat 객체로 변환
지정된 RGB 색상 범위(BGR 기준) 에 맞는 마스크 생성
200x30 이상의 크기 를 만족하는 사각형 탐색
조건 충족 시
TOP에서 157 상단 클릭
키보드 입력 후 TAB, 다시 키보드 입력
찾은 버튼의 중앙 클릭
비동기 처리로 UI 지연 방지
ListBox에 로그 출력 (최대 500개 유지)
💻 C# 코드
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;

public partial class MainForm : Form
{
    private const int MaxLogCount = 500;

    public MainForm()
    {
        InitializeComponent();
    }

    private async Task PerformAutomationAsync()
    {
        // 스캔할 영역 (X, Y 좌표 범위)
        int startX = 1200;
        int endX = 1500;
        int startY = 500;
        int endY = 600;

        // 스크린샷 캡처
        Bitmap screenshot = CaptureScreen(startX, startY, endX - startX, endY - startY);
        Mat src = BitmapConverter.ToMat(screenshot);

        // 색상 범위 설정 (BGR 기준)
        Scalar lower = new Scalar(10, 77, 100);  // B: 10~50, G: 77~88, R: 100~120
        Scalar upper = new Scalar(50, 88, 120);

        // 색상 범위 마스크 생성
        Mat mask = new Mat();
        Cv2.InRange(src, lower, upper, mask);

        // 윤곽선 찾기
        Cv2.FindContours(mask, out Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

        foreach (var contour in contours)
        {
            // 윤곽선으로부터 외접 사각형 생성
            Rect rect = Cv2.BoundingRect(contour);

            // 사각형 크기 조건 확인 (너비 200 이상, 높이 30 이상)
            if (rect.Width >= 200 && rect.Height >= 30)
            {
                int centerX = startX + rect.X + rect.Width / 2;
                int centerY = startY + rect.Y + rect.Height / 2;
                int topClickY = startY + rect.Y - 157;

                LogMessage($"찾은 버튼: X={centerX}, Y={centerY}, Width={rect.Width}, Height={rect.Height}");

                // 상단 클릭
                SetCursorPos(centerX, topClickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, (uint)centerX, (uint)topClickY, 0, 0);

                // 키보드 입력
                await Task.Delay(100);
                SendKeys.SendWait("kkkkbbbbb");
                await Task.Delay(100);
                SendKeys.SendWait("{TAB}");
                await Task.Delay(100);
                SendKeys.SendWait("aaaaabbbb");

                // 버튼 중앙 클릭
                await Task.Delay(100);
                SetCursorPos(centerX, centerY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, (uint)centerX, (uint)centerY, 0, 0);

                LogMessage("입력 및 버튼 클릭 완료");
                return;
            }
        }

        LogMessage("조건에 맞는 직사각형을 찾을 수 없음");
    }

    private Bitmap CaptureScreen(int x, int y, int width, int height)
    {
        Bitmap bmp = new Bitmap(width, height);
        using (Graphics g = Graphics.FromImage(bmp))
        {
            g.CopyFromScreen(x, y, 0, 0, new System.Drawing.Size(width, height), CopyPixelOperation.SourceCopy);
        }
        return bmp;
    }

    private void LogMessage(string message)
    {
        if (listBox1.InvokeRequired)
        {
            listBox1.Invoke(new Action(() => AddMessageToListBox(message)));
        }
        else
        {
            AddMessageToListBox(message);
        }
    }

    private void AddMessageToListBox(string message)
    {
        listBox1.Items.Add($"{DateTime.Now:HH:mm:ss} - {message}");

        if (listBox1.Items.Count > MaxLogCount)
        {
            listBox1.Items.RemoveAt(0);
        }

        listBox1.TopIndex = listBox1.Items.Count - 1;
    }

    // 마우스 이동 및 클릭을 위한 WinAPI 함수
    [DllImport("user32.dll")]
    private static extern bool SetCursorPos(int X, int Y);

    [DllImport("user32.dll")]
    private static extern void mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, int dwExtraInfo);

    private const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    private const uint MOUSEEVENTF_LEFTUP = 0x0004;
}
🚀 실행 흐름
지정된 화면 영역 (12001500, 500600)에서 스크린샷 캡처
RGB 범위 설정 (BGR: B=1050, G=7788, R=100~120)
Cv2.InRange() 사용하여 마스크 생성
마스크에서 외곽선 추출 → Cv2.BoundingRect()로 사각형 크기 확인
200x30 이상인 경우
버튼 위치 TOP Y - 157 클릭
"kkkkbbbbb" 입력 후 TAB 키
"aaaaabbbb" 입력 후 버튼 중앙 클릭
로그 (ListBox) 에 기록 (최대 500개 유지)
📌 개선된 점
✅ RGB 범위 설정 정확하게 반영
✅ 비동기(async 적용) UI 멈춤 방지
✅ 키보드 및 마우스 입력 자동화
✅ ListBox에 로그 추가 (500개 초과시 제거)
✅ 버튼 크기 조건 (200x30) 적용

🔹 예제 실행 로그
makefile
코드 복사
12:30:05 - 찾은 버튼: X=1340, Y=540, Width=220, Height=40