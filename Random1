, 여러 개의 상태 표시 컨트롤을 추가할 때는 코드의 재사용성과 유지보수를 고려하여 **유저 컨트롤(User Control)**을 사용하는 것이 좋습니다. 유저 컨트롤을 사용하면 공통된 UI와 로직을 재사용할 수 있어 관리가 용이하고 코드가 깔끔해집니다.

유저 컨트롤을 사용한 최적화 방법
유저 컨트롤 정의: 상태를 표시하는 공통된 UI 요소와 로직을 포함하는 유저 컨트롤을 만듭니다.
MainWindow에서 유저 컨트롤 사용: MainWindow에서 여러 개의 유저 컨트롤을 사용하여 각 상태를 표시합니다.
데이터 바인딩을 사용하여 상태 관리: MVVM 패턴을 사용하여 유저 컨트롤의 상태를 데이터 바인딩으로 관리합니다.
1. 유저 컨트롤 정의
먼저, 서비스 상태를 표시하는 유저 컨트롤을 정의합니다. 이 컨트롤은 상태를 시각적으로 표시하는 원형 도형과 텍스트를 포함합니다.

1.1. StatusIndicatorControl.xaml
xml
코드 복사
<UserControl x:Class="RouterMiddleACR.Controls.StatusIndicatorControl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             mc:Ignorable="d"
             d:DesignHeight="100" d:DesignWidth="100">
    <StackPanel Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Center">
        <!-- 상태를 표시할 원형 도형 -->
        <Ellipse x:Name="IndicatorEllipse" Width="30" Height="30" Fill="Gray" />
        <!-- 상태명을 표시할 텍스트 블록 -->
        <TextBlock x:Name="StatusText" Text="Status" FontSize="16" FontWeight="Bold" HorizontalAlignment="Center" Margin="10"/>
    </StackPanel>
</UserControl>
1.2. StatusIndicatorControl.xaml.cs
유저 컨트롤의 코드 비하인드 파일입니다. 이 파일에서는 상태를 나타내는 속성(Status)과 해당 상태에 따른 색상 변경 로직을 정의합니다.

csharp
코드 복사
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;

namespace RouterMiddleACR.Controls
{
    public partial class StatusIndicatorControl : UserControl
    {
        public StatusIndicatorControl()
        {
            InitializeComponent();
        }

        // DependencyProperty로 상태명을 정의
        public static readonly DependencyProperty StatusProperty =
            DependencyProperty.Register("Status", typeof(bool), typeof(StatusIndicatorControl), new PropertyMetadata(false, OnStatusChanged));

        // 상태가 변경될 때 호출되는 메서드
        private static void OnStatusChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var control = d as StatusIndicatorControl;
            if (control != null)
            {
                // 상태에 따라 색상을 변경
                if ((bool)e.NewValue)
                {
                    control.IndicatorEllipse.Fill = Brushes.Green; // 상태가 true면 초록색
                    control.StatusText.Text = "Running"; // 상태 텍스트 설정
                }
                else
                {
                    control.IndicatorEllipse.Fill = Brushes.Red; // 상태가 false면 빨간색
                    control.StatusText.Text = "Stopped"; // 상태 텍스트 설정
                }
            }
        }

        // 상태를 나타내는 프로퍼티
        public bool Status
        {
            get { return (bool)GetValue(StatusProperty); }
            set { SetValue(StatusProperty, value); }
        }
    }
}
2. MainWindow에서 유저 컨트롤 사용
이제 MainWindow.xaml에서 여러 개의 StatusIndicatorControl을 추가하여 다양한 상태를 표시할 수 있습니다. 각각의 유저 컨트롤은 다른 서비스나 기능의 상태를 나타낼 수 있습니다.

수정된 MainWindow.xaml
xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:RouterMiddleACR.Controls"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <!-- 여러 개의 상태 표시 컨트롤을 사용 -->
        <StackPanel Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Center">
            <local:StatusIndicatorControl x:Name="ServiceStatusIndicator1" Status="{Binding ServiceStatus1}" />
            <local:StatusIndicatorControl x:Name="ServiceStatusIndicator2" Status="{Binding ServiceStatus2}" />
            <local:StatusIndicatorControl x:Name="ServiceStatusIndicator3" Status="{Binding ServiceStatus3}" />
            <!-- 추가적인 상태 표시 컨트롤들을 필요에 따라 추가 -->
        </StackPanel>
        
        <!-- 여기에 다른 UI 요소들 추가 -->
        
    </Grid>
</Window>
3. 데이터 바인딩을 사용하여 상태 관리
MainViewModel에서 각 상태의 속성을 정의하고, 이 속성을 StatusIndicatorControl과 바인딩하여 상태를 관리합니다.

수정된 MainViewModel.cs
csharp
코드 복사
using System.ComponentModel;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private bool _serviceStatus1;
        private bool _serviceStatus2;
        private bool _serviceStatus3;

        public bool ServiceStatus1
        {
            get => _serviceStatus1;
            set
            {
                _serviceStatus1 = value;
                OnPropertyChanged(nameof(ServiceStatus1));
            }
        }

        public bool ServiceStatus2
        {
            get => _serviceStatus2;
            set
            {
                _serviceStatus2 = value;
                OnPropertyChanged(nameof(ServiceStatus2));
            }
        }

        public bool ServiceStatus3
        {
            get => _serviceStatus3;
            set
            {
                _serviceStatus3 = value;
                OnPropertyChanged(nameof(ServiceStatus3));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // 서비스 상태를 주기적으로 갱신하는 메서드
        public void UpdateServiceStatuses()
        {
            // 실제 서비스 상태를 확인하여 값을 업데이트
            // 예를 들어, ServiceController를 사용하여 서비스 상태를 확인하는 로직을 구현할 수 있음
        }
    }
}
요약
유저 컨트롤(StatusIndicatorControl): 상태를 시각적으로 표시하는 컨트롤을 만들고, 상태에 따라 색상이 변경되도록 설정합니다.
MainWindow.xaml에서 유저 컨트롤 사용: 여러 개의 유저 컨트롤을 사용하여 각 서비스나 기능의 상태를 표시합니다.
데이터 바인딩: MainViewModel에서 각 상태를 관리하고, 유저 컨트롤과 바인딩하여 상태 변경 시 UI에 자동으로 반영되도록 합니다.
이 구조는 여러 상태를 효율적으로 관리하고 표시할 수 있도록 최적화되어 있으며, 유지보수가 용이하고 확장성이 뛰어납니다. 각 상태를 개별적으로 관리할 필요