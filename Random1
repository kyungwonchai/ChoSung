지우개 기능을 추가하면서 기존의 그리기 기능이 영향을 받지 않도록, 펜의 버튼을 눌렀을 때만 지우개 모드가 활성화되도록 해야 합니다. 또한, 기존의 그리기 기능이 정상적으로 동작하도록 유지해야 합니다. 이를 위해, 펜의 버튼을 감지하고, 그릴 때와 지울 때의 동작을 명확히 분리해야 합니다.

다음은 해당 기능을 구현하기 위한 수정된 코드입니다:

수정된 ImageDisplayScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.Canvas
import android.os.Build
import android.view.MotionEvent
import android.view.View
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }
    var eraseMode by remember { mutableStateOf(false) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val view = LocalView.current
    val window = (context as? ComponentActivity)?.window
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier
        .fillMaxSize()
        .pointerInteropFilter { event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                    eraseMode = event.buttonState == MotionEvent.BUTTON_SECONDARY
                }
                MotionEvent.ACTION_UP -> {
                    eraseMode = false
                }
            }
            false
        }
    ) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode && !eraseMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        Canvas(modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragStart = { offset -> currentPathPoints = listOf(offset) },
                    onDragEnd = {
                        if (drawMode && !eraseMode) {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                        }
                        currentPathPoints = listOf()
                    },
                    onDrag = { change, _ ->
                        currentPathPoints = currentPathPoints + change.position
                        change.consume()
                    }
                )
            }
        ) {
            for (path in drawingPaths) {
                for (i in 1 until path.points.size) {
                    drawLine(
                        color = path.color,
                        start = path.points[i - 1],
                        end = path.points[i],
                        strokeWidth = if (path.color == Color.Transparent) 10f else 3f // 지우개 모드에서는 더 두껍게
                    )
                }
            }

            if (eraseMode) {
                val eraserColor = Color.White.toArgb() // 지우개 모드에서 실제 색을 흰색으로 설정
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = Color(eraserColor),
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 10f // 지우개 모드에서는 더 두껍게
                    )
                }
            } else {
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(horizontal = 20.dp, vertical = 0.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    window?.let { captureAndUploadBitmap(it, view, scope) }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

fun captureAndUploadBitmap(window: android.view.Window, view: View, scope: CoroutineScope) {
    val bitmap = Bitmap.createBitmap(view.width, view.height, Bitmap.Config.ARGB_8888)
    val location = IntArray(2)
    view.getLocationInWindow(location)
    try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            PixelCopy.request(
                window, android.graphics.Rect(
                    location[0], location[1],
                    location[0] + view.width, location[1] + view.height
                ), bitmap, { copyResult ->
                    if (copyResult == PixelCopy.SUCCESS) {
                        scope.launch {
                            uploadBitmap(bitmap)
                        }
                    }
                }, view.handler
            )
        } else {
            view.draw(Canvas(bitmap))
            scope.launch {
                uploadBitmap(bitmap)
            }
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
이제 eraseMode는 펜의 버튼이 눌린 상태에서만 활성화됩니다. 지우개 모드가 활성화되었을 때만 경로가 흰색으로 그려지고, 드로잉 모드에서는 색상 선택에 따라 정상적으로 그려집니