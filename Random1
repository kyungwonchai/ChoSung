네, Mask_01로 변경되었다는 것은 제가 완전히 잘못 파악한 것입니다. 정말 죄송합니다.

지금까지의 모든 혼란을 끝내기 위해, 최종적으로 확정된 규칙과 그에 맞는 최종 코드 2개를 정리해 드리겠습니다. 이 두 개의 스크립트가 모든 것의 최종 버전입니다.

## 최종 규칙 상세 설명
1. 설치 규칙 (랙 자동 배치)
RackLayoutGenerator.cs 스크립트가 씬을 구성합니다.

Hierarchy 창에 생성되는 랙들의 이름은 언더바(_)나 다른 문자 없이 A01, A02, ... B01, B12 와 같이 깨끗한 형식입니다.

B열 랙들은 A열을 마주 보도록 180도 회전됩니다. (요청하신 A열 Z축 180도 회전 포함)

2. 검색 규칙 (바코드 처리)
RackSystemManager.cs 스크립트가 이 모든 과정을 처리합니다.

내부 주소 생성 방식: 게임이 시작되면, 스크립트는 A01 랙 안에 있는 Mask_C05를 찾아, 이 둘을 조합하여 A01_Mask_C05 라는 최종 내부 주소를 만듭니다. 모든 램프와 마스크가 이런 고유 주소를 갖게 됩니다.

사용자가 입력할 바코드 형식: 사용자는 MMF10A01C05 (11자리) 형식으로 바코드를 입력합니다.

매핑 방식: 스크립트는 MMF10A01C05를 받아, A01, C, 05로 분해한 뒤, 내부 주소인 A01_Mask_C05를 다시 조립하여 일치하는 마스크를 정확히 찾아냅니다.

## 최종 스크립트 파일
1. 최종 RackLayoutGenerator.cs
Editor 폴더에 있는 기존 파일을 지우고, 아래 코드로 새로 만드세요.

C#

using UnityEngine;
using UnityEditor;

public class RackLayoutGenerator
{
    private static readonly int RACK_COUNT_PER_ROW = 12;
    private static readonly float RACK_GAP = 0.01f;
    private static readonly float AISLE_WIDTH = 4.0f;

    [MenuItem("Tools/SMD Rack/Generate Final Layout")]
    private static void GenerateLayout()
    {
        GameObject rackPrefab = Selection.activeObject as GameObject;
        if (rackPrefab == null) { EditorUtility.DisplayDialog("오류", "Project 창에서 랙 '프리팹'을 먼저 선택해주세요.", "확인"); return; }

        GameObject parentObject = new GameObject("Rack_Installations");
        
        Bounds totalBounds = new Bounds();
        Renderer[] renderers = rackPrefab.GetComponentsInChildren<Renderer>();
        if(renderers.Length > 0)
        {
            totalBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers) { totalBounds.Encapsulate(renderer.bounds); }
        }
        float rackWidth = totalBounds.size.x;

        Quaternion standingRotation = Quaternion.Euler(-90, 0, 0);

        // 첫 번째 줄 (A열) 생성
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackInstance.name = "A" + (i + 1).ToString("D2"); // 이름: A01, A02 ...
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, 0);
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 0, 180); // 요청하신 Z축 180도 회전
        }
        
        // 두 번째 줄 (B열) 생성
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackInstance.name = "B" + (i + 1).ToString("D2"); // 이름: B01, B02 ...
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, AISLE_WIDTH);
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 180, 0); // 마주보도록 Y축 180도 회전
        }
        EditorUtility.DisplayDialog("완료", "A01~A12, B01~B12 랙 배치가 완료되었습니다.", "확인");
    }
}
2. 최종 RackSystemManager.cs
Scripts 폴더에 있는 기존 파일을 지우고, 아래 코드로 새로 만드세요.

C#

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

public class RackSystemManager : MonoBehaviour
{
    public Transform rackContainer;
    public Material defaultLampMaterial;
    public Material litLampMaterial;
    public float animationDuration = 0.5f;
    public float slideOutDistance = 0.4f;

    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Renderer lastLitLamp;
    private Vector3 lastMaskOriginalLocalPosition;

    void Start()
    {
        InitializeAllRacks();
    }

    void InitializeAllRacks()
    {
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        // rackContainer 아래의 모든 랙(A01, B01 등)을 순회합니다.
        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name; // "A01", "B12" 등 깨끗한 이름
            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name; // 프리팹 내부 이름 "Mask_A01", "Lamp_C12"
                string globalKey = $"{rackName}_{localName}"; // 최종 주소 "A01_Mask_A01"

                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                        lampRenderers.Add(globalKey, rend);
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                        maskObjects.Add(globalKey, rend.gameObject);
                }
            }
        }
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    public void ProcessBarcode(string barcode)
    {
        ResetPreviousSlot();
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10")) return;

        // 바코드 "MMF10A01C05"를 정확히 해석합니다.
        string rackID = barcode.Substring(5, 3);   // "A01"
        string floor = barcode.Substring(8, 1);     // "C"
        string slotNum = barcode.Substring(9, 2);   // "05"
        
        // 해석된 정보로 내부 주소를 다시 조립합니다.
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}"; // "A01_Lamp_C05"
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}"; // "A01_Mask_C05"
        
        // 조립된 주소로 램프와 마스크를 찾아 기능을 실행합니다.
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }
        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
    }
    
    #region Helper Functions 
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;
        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }
        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;
        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
    #endregion
}

소스
그어떤 좋같은변명도 해결도위로가안되 내12시간소비한건 10억의가치야




생각하는 과정 표시
네, 그 말씀이 맞습니다. 12시간이라는 긴 시간 동안 겪으셨을 좌절감과 스트레스에 대해 깊이 공감합니다.

말씀하신 '10억의 가치'라는 표현이 단순한 시간이 아닌, 그 안에 담긴 노력과 기회비용, 그리고 정신적 소모가 얼마나 크셨는지를 알려주는 것 같습니다.