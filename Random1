네, 아주 중요한 부분을 지적해주셨습니다. "메모리가 부족합니다" 오류는 대상 창이 최소화되었을 때 발생하는 전형적인 문제입니다.

먼저 가장 중요한 점부터 말씀드리겠습니다.

이 오류는 사용자님의 컴퓨터 시스템에 어떠한 손상도 주지 않습니다.

이것은 하드웨어나 운영체제에 영구적인 손상을 입히는 심각한 오류가 아니라, 만든 프로그램 내부에서 발생하는 소프트웨어 예외(Exception)일 뿐입니다. 안심하셔도 됩니다.

"메모리 부족" 오류가 발생하는 이유
창이 최소화되면, Windows는 그 창의 크기 정보를 비정상적인 값(예: 너비 160, 높이 31 같은 작은 값이거나, 때로는 아주 큰 음수 값)으로 반환합니다. 이 잘못된 크기 값으로 new Bitmap(...) 코드가 이미지(비트맵)를 만들려고 시도하면, 비정상적으로 큰 메모리를 할당하려다 실패하면서 "메모리가 부족합니다(OutOfMemoryException)" 오류를 발생시키는 것입니다.

사용자님께서 제안해주신 대로, **"창이 최소화되어 있다"**고 알려주고 캡처 시도를 중단하는 것이 올바른 해결책입니다.

해결 방법: 창 최소화 상태 확인 로직 추가
Windows API에는 창이 최소화되었는지 직접 확인할 수 있는 IsIconic이라는 함수가 있습니다. 이 함수를 사용하여 캡처를 시도하기 전에 창의 상태를 먼저 확인하도록 코드를 수정하겠습니다.

1. MainWindow.xaml.cs에 IsIconic 함수 선언 추가
MainWindow.xaml.cs 파일의 P/Invoke 함수 선언 부분에 아래 한 줄을 추가합니다.

C#

// ... (다른 DllImport들 아래에 추가)
[DllImport("user32.dll")]
[return: MarshalAs(UnmanagedType.Bool)]
private static extern bool IsIconic(IntPtr hWnd);
2. PerformLogging 및 UpdatePreviewImage 메소드 수정
10초마다 실행되는 로깅 함수와 미리보기를 만드는 함수, 두 곳 모두에서 창이 최소화되었는지 확인해야 합니다.

아래는 최종 수정된 MainWindow.xaml.cs의 전체 코드입니다. 기존 코드를 모두 지우고 아래 코드로 교체하시면 모든 문제가 해결됩니다.

C#

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using Tesseract;
using funcenvget.Properties;

using System.Drawing;
using System.Drawing.Imaging;

namespace funcenvget
{
    public partial class MainWindow : Window
    {
        // WinAPI 함수 선언
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);

        // [수정] 최소화 상태 확인을 위한 IsIconic 함수 추가
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);


        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private DispatcherTimer timer;
        private TesseractEngine ocrEngine;

        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
        }

        private void InitializeApp()
        {
            ocrEngine = new TesseractEngine("./tessdata", "eng", EngineMode.Default);
            ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");

            timer = new DispatcherTimer();
            timer.Interval = TimeSpan.FromSeconds(10);
            timer.Tick += Timer_Tick;
        }

        private void btnSelectArea_Click(object sender, RoutedEventArgs e)
        {
            // 이 함수는 이전 답변의 수정된 버전을 그대로 사용합니다.
            // (Visibility.Hidden 사용 버전)
            IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
            if (hWnd == IntPtr.Zero)
            {
                MessageBox.Show("먼저 유효한 '대상 창 제목'을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            this.Visibility = Visibility.Hidden;
            System.Threading.Thread.Sleep(200);
            var selectionWindow = new SelectionWindow();
            selectionWindow.Activate();
            if (selectionWindow.ShowDialog() == true)
            {
                System.Windows.Rect screenRect = selectionWindow.SelectedArea;
                GetWindowRect(hWnd, out RECT windowRect);
                int relativeX = (int)screenRect.X - windowRect.Left;
                int relativeY = (int)screenRect.Y - windowRect.Top;
                relativeX = Math.Max(0, relativeX);
                relativeY = Math.Max(0, relativeY);
                txtX.Text = relativeX.ToString();
                txtY.Text = relativeY.ToString();
                txtWidth.Text = ((int)screenRect.Width).ToString();
                txtHeight.Text = ((int)screenRect.Height).ToString();
                UpdatePreviewImage();
            }
            this.Visibility = Visibility.Visible;
            this.Activate();
        }

        private void UpdatePreviewImage()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero) return;

                // [수정] 미리보기 생성 전 최소화 상태 확인
                if (IsIconic(hWnd))
                {
                    MessageBox.Show("대상 창이 최소화되어 있어 미리보기를 생성할 수 없습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                    imgPreview.Source = null;
                    return;
                }

                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                    }
                    var cropArea = new System.Drawing.Rectangle(
                        int.Parse(txtX.Text), int.Parse(txtY.Text),
                        int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    if (cropArea.Width <= 0 || cropArea.Height <= 0 || cropArea.Right > bmp.Width || cropArea.Bottom > bmp.Height)
                    {
                        imgPreview.Source = null;
                        return;
                    }
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        imgPreview.Source = BitmapToImageSource(croppedBmp);
                        string previewPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "preview_capture.png");
                        croppedBmp.Save(previewPath, System.Drawing.Imaging.ImageFormat.Png);
                        Settings.Default.PreviewImagePath = previewPath;
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"미리보기 생성 오류: {ex.Message}";
                imgPreview.Source = null;
            }
        }

        BitmapImage BitmapToImageSource(Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, System.Drawing.Imaging.ImageFormat.Png);
                memory.Position = 0;
                BitmapImage bitmapimage = new BitmapImage();
                bitmapimage.BeginInit();
                bitmapimage.StreamSource = memory;
                bitmapimage.CacheOption = BitmapCacheOption.OnLoad;
                bitmapimage.EndInit();
                return bitmapimage;
            }
        }
        
        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled)
            {
                timer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 로깅이 중지되었습니다.";
            }
            else
            {
                if (string.IsNullOrWhiteSpace(txtWindowTitle.Text) || int.Parse(txtWidth.Text) <= 0 || int.Parse(txtHeight.Text) <= 0)
                {
                    MessageBox.Show("대상 창 제목과 유효한 캡처 영역을 먼저 설정해주세요.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            PerformLogging();
        }

        private void PerformLogging()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상 창을 찾을 수 없습니다.";
                    return;
                }

                // [수정] 로깅 전 최소화 상태 확인
                if (IsIconic(hWnd))
                {
                    lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다.";
                    LogData("[ERROR] 대상 창이 최소화되어 캡처에 실패했습니다.");
                    return;
                }

                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                    }
                    var cropArea = new System.Drawing.Rectangle(
                        int.Parse(txtX.Text), int.Parse(txtY.Text),
                        int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        using (var page = ocrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            if (!string.IsNullOrWhiteSpace(rawText))
                            {
                                LogData(rawText);
                                lblStatus.Text = $"상태: {DateTime.Now:T} - 로그 기록 완료.";
                            }
                            else
                            {
                                lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다.";
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"상태: 심각한 오류 발생! {ex.Message}";
                LogData($"[ERROR] {ex.Message}");
            }
        }

        private void LogData(string data)
        {
            try
            {
                string sanitizedData = Regex.Replace(data, @"\s+", " ").Trim();
                string logFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "datalog.txt");
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}\t{sanitizedData}\n";
                File.AppendAllText(logFilePath, logMessage, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"로그 파일 쓰기 오류: {ex.Message}", "파일 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            txtWindowTitle.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            if (!string.IsNullOrEmpty(Settings.Default.PreviewImagePath) && File.Exists(Settings.Default.PreviewImagePath))
            {
                try
                {
                    BitmapImage preview = new BitmapImage();
                    preview.BeginInit();
                    preview.UriSource = new Uri(Settings.Default.PreviewImagePath);
                    preview.CacheOption = BitmapCacheOption.OnLoad;
                    preview.EndInit();
                    imgPreview.Source = preview;
                }
                catch { /* 무시 */ }
            }
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (ocrEngine != null) ocrEngine.Dispose();
            if (timer != null) timer.Stop();
            Settings.Default.WindowTitle = txtWindowTitle.Text;
            Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
            Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
            Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
            Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
            Settings.Default.Save();
        }
    }