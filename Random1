, "ì‘ì—… ë“±ë¡ ë˜ëŠ” ì‹œì‘ ì‹¤íŒ¨: list of positional arguments is longer than the target callable can handle..." ì˜¤ë¥˜ì™€ í•¨ê»˜, Flask ì•± ìì²´ëŠ” ì‹œì‘ë˜ì§€ë§Œ ì˜ˆì•½ëœ ì‘ì—…ì´ ë™ì‘í•˜ì§€ ì•ŠëŠ” ë¬¸ì œ ìƒí™©ì´êµ°ìš”. ğŸ˜¥

ì´ ì˜¤ë¥˜ëŠ” APSchedulerê°€ íŠ¹ì • í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë ¤ê³  í•  ë•Œ, ìŠ¤ì¼€ì¤„ëŸ¬ê°€ ì „ë‹¬í•˜ëŠ” ì¸ì(arguments)ì˜ ê°œìˆ˜ì™€ í•´ë‹¹ í•¨ìˆ˜ê°€ ì‹¤ì œë¡œ ë°›ë„ë¡ ì •ì˜ëœ ì¸ìì˜ ê°œìˆ˜ê°€ ì¼ì¹˜í•˜ì§€ ì•Šê¸° ë•Œë¬¸ì— ë°œìƒí•©ë‹ˆë‹¤.

ê°€ì¥ ê°€ëŠ¥ì„±ì´ ë†’ì€ ì›ì¸ ë° í•´ê²° íŒŒì¼: app/scheduler_tasks.py

ì´ì „ì— app/__init__.pyì—ì„œ ìŠ¤ì¼€ì¤„ëœ ì‘ì—… í•¨ìˆ˜ë“¤(scheduled_task_monitor_on, scheduled_task_monitor_off)ì— Flask app ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ë„ë¡ args=[current_flask_app_for_scheduler] ì„¤ì •ì„ ì¶”ê°€í–ˆìŠµë‹ˆë‹¤.

ì´ê²ƒì€ app/scheduler_tasks.py íŒŒì¼ì— ìˆëŠ” í•´ë‹¹ í•¨ìˆ˜ë“¤ì´ ë°˜ë“œì‹œ ì²« ë²ˆì§¸ ì¸ìë¡œ Flask app ì¸ìŠ¤í„´ìŠ¤ë¥¼ ë°›ì•„ì•¼ í•œë‹¤ëŠ” ì˜ë¯¸ì…ë‹ˆë‹¤.

ë‹¤ìŒ ë‘ ê°€ì§€ë¥¼ í™•ì¸í•˜ê³  ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤:

app/scheduler_tasks.py íŒŒì¼ì˜ í•¨ìˆ˜ ì •ì˜:

scheduled_task_monitor_on í•¨ìˆ˜ì™€ scheduled_task_monitor_off í•¨ìˆ˜ì˜ ì •ì˜ê°€ app_instance (ë˜ëŠ” ë‹¤ë¥¸ ì´ë¦„ì˜) ì²« ë²ˆì§¸ ì¸ìë¥¼ í¬í•¨í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
ì´ í•¨ìˆ˜ë“¤ì´ ë‚´ë¶€ì ìœ¼ë¡œ í˜¸ì¶œí•˜ëŠ” ë‹¤ë¥¸ í—¬í¼ í•¨ìˆ˜ë“¤(ì˜ˆ: is_operational_day, _send_display_timeout_to_all_pcs)ë„ app_instanceë¥¼ í•„ìš”ë¡œ í•œë‹¤ë©´, ì´ ì¸ìë¥¼ ê³„ì† ì „ë‹¬í•´ì•¼ í•©ë‹ˆë‹¤.
Flask ì•± ì»¨í…ìŠ¤íŠ¸ ì‚¬ìš©:

ìŠ¤ì¼€ì¤„ëœ ì‘ì—… í•¨ìˆ˜ë“¤ ë‚´ë¶€ì—ì„œ Flaskì˜ ê¸°ëŠ¥(ë¡œê±°, ì„¤ì •, DB ì—°ê²° ë“±)ì„ ì‚¬ìš©í•˜ë ¤ë©´, ì „ë‹¬ë°›ì€ app_instanceë¥¼ ì‚¬ìš©í•˜ì—¬ with app_instance.app_context(): ë¸”ë¡ ì•ˆì—ì„œ í•´ë‹¹ ë¡œì§ì´ ì‹¤í–‰ë˜ë„ë¡ í•´ì•¼ í•©ë‹ˆë‹¤.
ìˆ˜ì •: app/scheduler_tasks.py (ì „ì²´ ìµœì¢… ì½”ë“œ)
ì´ì „ ë‹µë³€(#54)ì—ì„œ ì´ë¯¸ app_instance ì¸ìë¥¼ ë°›ë„ë¡ ìˆ˜ì •ëœ ë²„ì „ì„ ë“œë ¸ìŠµë‹ˆë‹¤. ê·¸ ë²„ì „ì´ ì •í™•íˆ ì ìš©ë˜ì—ˆëŠ”ì§€ ë‹¤ì‹œ í•œë²ˆ í™•ì¸í•˜ì‹œê±°ë‚˜, ì•„ë˜ ì½”ë“œë¡œ ì™„ì „íˆ êµì²´í•´ ì£¼ì‹­ì‹œì˜¤. ì´ ì½”ë“œëŠ” ê° ìŠ¤ì¼€ì¤„ëœ í•¨ìˆ˜ê°€ app_instanceë¥¼ ë°›ê³ , ì´ë¥¼ ì‚¬ìš©í•˜ì—¬ ì•± ì»¨í…ìŠ¤íŠ¸ë¥¼ ì„¤ì •í•˜ë©°, ë‚´ë¶€ í—¬í¼ í•¨ìˆ˜ì—ë„ í•„ìš”ì— ë”°ë¼ app_instanceë¥¼ ì „ë‹¬í•©ë‹ˆë‹¤.

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date
import holidays
# from flask import current_app # app_instanceë¥¼ í†µí•´ ì ‘ê·¼í•˜ë¯€ë¡œ ì§ì ‘ ì„í¬íŠ¸ ë¶ˆí•„ìš”
from .db_utils import get_db_connection
from .socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone # dtë¡œ ë³„ì¹­, timezone ì‚¬ìš©

def is_operational_day(target_date, app_instance): # app_instance ì¸ì ì‚¬ìš©
    conn = None
    try:
        # get_db_connection()ì€ current_appì„ ì‚¬ìš©í•˜ë¯€ë¡œ, ì´ í•¨ìˆ˜ê°€ app_context ë‚´ì—ì„œ í˜¸ì¶œë¨ì„ ë³´ì¥
        conn = get_db_connection() 
        if not conn:
            app_instance.logger.error(f"[Scheduler][{target_date}] is_operational_day: DB ì—°ê²° ì‹¤íŒ¨. ê¸°ë³¸ ê°€ë™ì¼ë¡œ ì²˜ë¦¬.")
            return True 

        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"
            cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),))
            exception_day = cursor.fetchone()
            if exception_day:
                is_op = bool(exception_day['is_operational'])
                app_instance.logger.info(f"[Scheduler][{target_date}] ì‚¬ìš©ì ì§€ì • ì˜ˆì™¸ì¼: {'ê°€ë™ì¼' if is_op else 'ë¹„ê°€ë™ì¼'}")
                return is_op

        if target_date.weekday() >= 5: # í† (5), ì¼(6)
            app_instance.logger.info(f"[Scheduler][{target_date}] ì£¼ë§(ë¹„ê°€ë™ì¼).")
            return False

        # í•´ë‹¹ ì—°ë„ì˜ í•œêµ­ ê³µíœ´ì¼ ì •ë³´ (ë§¤ë²ˆ ìƒì„±í•´ë„ ë˜ë‚˜, ìµœì í™” ê°€ëŠ¥)
        kr_holidays = holidays.KR(years=target_date.year, observed=True) # observed=Trueë¡œ ëŒ€ì²´ê³µíœ´ì¼ í¬í•¨
        if target_date in kr_holidays:
            app_instance.logger.info(f"[Scheduler][{target_date}] ê³µíœ´ì¼('{kr_holidays.get(target_date)}'). (ë¹„ê°€ë™ì¼)")
            return False
            
        app_instance.logger.info(f"[Scheduler][{target_date}] í‰ì¼(ê°€ë™ì¼).")
        return True
    except Exception as e:
        app_instance.logger.error(f"[Scheduler][{target_date}] is_operational_day í•¨ìˆ˜ ì˜¤ë¥˜: {e}", exc_info=True)
        return True # ì˜¤ë¥˜ ì‹œ ê¸°ë³¸ì ìœ¼ë¡œ ê°€ë™ì¼ë¡œ ì²˜ë¦¬

def _send_display_timeout_to_all_pcs(timeout_minutes, action_description, app_instance): # app_instance ì¸ì ì‚¬ìš©
    conn = None
    pcs_to_control = []
    try:
        conn = get_db_connection() 
        if not conn:
            app_instance.logger.error(f"[Scheduler] _send_display_timeout_to_all_pcs: DB ì—°ê²° ì‹¤íŒ¨.")
            return
        with conn.cursor() as cursor:
            cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs")
            pcs_to_control = cursor.fetchall()
    except Exception as e:
        app_instance.logger.error(f"[Scheduler] PC ëª©ë¡ ì¡°íšŒ ì˜¤ë¥˜: {e}", exc_info=True)
        return 

    if not pcs_to_control:
        app_instance.logger.info("[Scheduler] ì œì–´í•  PC ì—†ìŒ.")
        return

    app_instance.logger.info(f"[Scheduler] '{action_description}'ì„(ë¥¼) {len(pcs_to_control)}ëŒ€ PCì— ì „ì†¡ ì‹œì‘.")
    payload_obj = {'TimeoutMinutes': timeout_minutes}
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        command_packet = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            command_packet['Instruction'] = "RelayToTarget"; command_packet['FinalTargetIpForRelayedCommand'] = pc_data['address2']
            command_packet['FinalTargetPortForRelayedCommand'] = 4026; target_ip_for_command = pc_data['address1']
        else:
            command_packet['Instruction'] = "DirectExecute"; target_ip_for_command = pc_data['address1']

        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip_for_command})]"
        app_instance.logger.info(f"{log_prefix} - '{action_description}' ëª…ë ¹ ì „ì†¡ ì‹œë„. PktID: {command_packet['PacketId']}")
        try:
            # send_command_to_agentëŠ” ë‚´ë¶€ì ìœ¼ë¡œ current_app.logger ì‚¬ìš©. app_context ë‚´ì—ì„œ í˜¸ì¶œë˜ë¯€ë¡œ OK.
            agent_response = send_command_to_agent(target_ip_for_command, command_packet) 
            if agent_response.get('success'):
                raw_resp_packet = agent_response.get('raw_response')
                if raw_resp_packet and isinstance(raw_resp_packet, dict) and raw_resp_packet.get('PayloadJson'):
                    resp_payload = json.loads(raw_resp_packet['PayloadJson'])
                    if resp_payload.get('Success'): app_instance.logger.info(f"{log_prefix} - ëª…ë ¹ ì„±ê³µ: {resp_payload.get('Message', 'OK')}")
                    else: app_instance.logger.error(f"{log_prefix} - ëª…ë ¹ ì‹¤íŒ¨ (ì—ì´ì „íŠ¸): {resp_payload.get('Message', 'Agent error')}")
                else: app_instance.logger.warning(f"{log_prefix} - ì „ì†¡ ì„±ê³µ, ìƒì„¸ ì‘ë‹µ í™•ì¸ ë¶ˆê°€. Raw: {raw_resp_packet}")
            else: app_instance.logger.error(f"{log_prefix} - ì „ì†¡ ì‹¤íŒ¨: {agent_response.get('message', 'Socket error')}")
        except Exception as e_send:
            app_instance.logger.error(f"{log_prefix} - ëª…ë ¹ ì „ì†¡ ì¤‘ ì˜ˆì™¸: {e_send}", exc_info=True)

# --- APSchedulerê°€ í˜¸ì¶œí•  ì‹¤ì œ ì‘ì—… í•¨ìˆ˜ë“¤ ---
def scheduled_task_monitor_on(app_instance): # Flask app ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ìŒ
    with app_instance.app_context(): # ì „ë‹¬ë°›ì€ app ì¸ìŠ¤í„´ìŠ¤ë¡œ app_context ìƒì„±
        today = date.today()
        app_instance.logger.info(f"[Scheduler] ëª¨ë‹ˆí„° ì¼œê¸° ì‘ì—… (06:00 ì˜ˆì •) ì‹œì‘, ì˜¤ëŠ˜: {today}")
        if is_operational_day(today, app_instance): # app_instance ì „ë‹¬
            app_instance.logger.info(f"[Scheduler] ê°€ë™ì¼: 'ëª¨ë‹ˆí„° ì¼œê¸°(íƒ€ì„ì•„ì›ƒ í•´ì œ)' ëª…ë ¹ ì „ì†¡.")
            _send_display_timeout_to_all_pcs(0, "ë””ìŠ¤í”Œë ˆì´ í•­ìƒ ì¼œê¸° ì„¤ì • (íƒ€ì„ì•„ì›ƒ 0ë¶„)", app_instance) # app_instance ì „ë‹¬
        else:
            app_instance.logger.info(f"[Scheduler] ë¹„ê°€ë™ì¼: 'ëª¨ë‹ˆí„° ì¼œê¸°' ëª…ë ¹ ë¯¸ì‹¤í–‰.")
        app_instance.logger.info(f"[Scheduler] ëª¨ë‹ˆí„° ì¼œê¸° ì‘ì—… ì™„ë£Œ.")


def scheduled_task_monitor_off(app_instance): # Flask app ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì¸ìë¡œ ë°›ìŒ
    with app_instance.app_context(): # ì „ë‹¬ë°›ì€ app ì¸ìŠ¤í„´ìŠ¤ë¡œ app_context ìƒì„±
        today = date.today()
        app_instance.logger.info(f"[Scheduler] ëª¨ë‹ˆí„° ë„ê¸° ì‘ì—… (07:00 ì˜ˆì •) ì‹œì‘, ì˜¤ëŠ˜: {today}")
        if not is_operational_day(today, app_instance): # app_instance ì „ë‹¬
            app_instance.logger.info(f"[Scheduler] ë¹„ê°€ë™ì¼: 'ëª¨ë‹ˆí„° ë„ê¸°(1ë¶„ í›„ íƒ€ì„ì•„ì›ƒ)' ëª…ë ¹ ì „ì†¡.")
            _send_display_timeout_to_all_pcs(1, "ë””ìŠ¤í”Œë ˆì´ 1ë¶„ í›„ ìë™ êº¼ì§ ì„¤ì •", app_instance) # app_instance ì „ë‹¬
        else:
            app_instance.logger.info(f"[Scheduler] ê°€ë™ì¼: 'ëª¨ë‹ˆí„° ë„ê¸°' ëª…ë ¹ ë¯¸ì‹¤í–‰.")
        app_instance.logger.info(f"[Scheduler] ëª¨ë‹ˆí„° ë„ê¸° ì‘ì—… ì™„ë£Œ.")
app/scheduler_tasks.py ì£¼ìš” í™•ì¸/ìˆ˜ì • ì‚¬í•­:

í•¨ìˆ˜ ì‹œê·¸ë‹ˆì²˜: scheduled_task_monitor_onê³¼ scheduled_task_monitor_off í•¨ìˆ˜ê°€ ì²« ë²ˆì§¸ ì¸ìë¡œ app_instanceë¥¼ ë°›ë„ë¡ ì •ì˜ë˜ì–´ ìˆëŠ”ì§€ í™•ì¸í•©ë‹ˆë‹¤.
app_instance ì‚¬ìš©: í•¨ìˆ˜ ë‚´ì—ì„œ Flask ì•± ê°ì²´ì˜ ë¡œê±°(app_instance.logger)ë‚˜ ì„¤ì •(app_instance.config)ì— ì ‘ê·¼í•  ë•Œ ì´ app_instanceë¥¼ ì‚¬ìš©í•©ë‹ˆë‹¤.
with app_instance.app_context():: ê° ìŠ¤ì¼€ì¤„ëœ ì‘ì—… í•¨ìˆ˜ì˜ ì‹œì‘ ë¶€ë¶„ì— ì´ ì½”ë“œë¥¼ ì‚¬ìš©í•˜ì—¬, í•¨ìˆ˜ ë³¸ë¬¸ì´ ì‹¤í–‰ë˜ëŠ” ë™ì•ˆ Flask ì• í”Œë¦¬ì¼€ì´ì…˜ ì»¨í…ìŠ¤íŠ¸ê°€ í™œì„±í™”ë˜ë„ë¡ í•©ë‹ˆë‹¤. ì´ë ‡ê²Œ í•˜ë©´ get_db_connection()ì´ë‚˜ send_command_to_agent() ë‚´ë¶€ì—ì„œ current_appì„ ì‚¬ìš©í•˜ëŠ” ë¶€ë¶„ì´ ì •ìƒì ìœ¼ë¡œ ë™ì‘í•©ë‹ˆë‹¤.
í—¬í¼ í•¨ìˆ˜ì— app_instance ì „ë‹¬: is_operational_dayì™€ _send_display_timeout_to_all_pcs í•¨ìˆ˜ë„ app_instanceë¥¼ ì¸ìë¡œ ë°›ë„ë¡ ìˆ˜ì •í•˜ì—¬, ì´ë“¤ ë‚´ë¶€ì—ì„œë„ app_instance.loggerë¥¼ ì‚¬ìš©í•˜ê±°ë‚˜, ë˜ëŠ” ì´ë“¤ì´ í˜¸ì¶œí•˜ëŠ” ë‹¤ë¥¸ í•¨ìˆ˜(ì˜ˆ: get_db_connection)ê°€ current_appì„ ì˜¬ë°”ë¥´ê²Œ ì°¸ì¡°í•  ìˆ˜ ìˆë„ë¡ í•©ë‹ˆë‹¤.
app/__init__.py íŒŒì¼ì€ ì´ì „ ë‹µë³€(#54)ì—ì„œ ì œê³µí•œ ì½”ë“œê°€ ì´ë¯¸ args=[current_flask_app_for_scheduler]ë¥¼ ì‚¬ìš©í•˜ì—¬ app ì¸ìŠ¤í„´ìŠ¤ë¥¼ ì „ë‹¬í•˜ë„ë¡ ë˜ì–´ ìˆìœ¼ë¯€ë¡œ, í•´ë‹¹ íŒŒì¼ì€ ìˆ˜ì •í•  í•„ìš”ê°€ ì—†ì„ ê²ƒì…ë‹ˆë‹¤. (ë‹¤ì‹œ í•œë²ˆ í™•ì¸ì°¨ app/__init__.pyì˜ scheduler.add_job ë¶€ë¶„ì„ í™•ì¸í•´ì£¼ì„¸ìš”.)

ì¡°ì¹˜:

ìœ„ app/scheduler_tasks.py ì½”ë“œë¡œ ì‚¬ìš©ìë‹˜ì˜ íŒŒì¼ì„ ì™„ì „íˆ êµì²´í•˜ê±°ë‚˜ ì£¼ì˜ ê¹Šê²Œ ë¹„êµ ìˆ˜ì •í•©ë‹ˆë‹¤.
í”„ë¡œì íŠ¸ ë‚´ ëª¨ë“  __pycache__ í´ë”ë¥¼ ì‚­ì œí•©ë‹ˆë‹¤.
Flask ê°œë°œ ì„œë²„ë¥¼ ì™„ì „íˆ ì¢…ë£Œí–ˆë‹¤ê°€ ë‹¤ì‹œ ì‹œì‘í•©ë‹ˆë‹¤. (python run.py)