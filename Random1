래는 진행 상황을 출력하여 실행 상태를 실시간으로 알 수 있도록 수정한 코드입니다. 각 주요 단계에서 진행 상황과 예상 완료 시간을 출력하도록 구성하였습니다. tqdm 라이브러리를 사용해 진행률 바를 추가로 표시했습니다.

수정된 전체 코드
python
코드 복사
import numpy as np
import pandas as pd
import pymssql
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from tqdm import tqdm  # 진행률 표시를 위한 라이브러리
import time  # 진행 시간 측정을 위한 라이브러리


# 1. 데이터베이스에서 데이터 읽기 함수
def fetch_data_from_procedure(proc_name, connection_details):
    """
    MSSQL 저장 프로시저에서 데이터를 가져오는 함수.
    :param proc_name: 저장 프로시저 이름 (str).
    :param connection_details: 데이터베이스 연결 정보 (dict).
    :return: Pandas DataFrame.
    """
    print(f"Fetching data from procedure: {proc_name}")
    try:
        conn = pymssql.connect(
            server=connection_details['server'],
            user=connection_details['user'],
            password=connection_details['password'],
            database=connection_details['database']
        )
        query = f"EXEC {proc_name}"  # 저장 프로시저 호출
        df = pd.read_sql(query, conn)  # 데이터를 Pandas DataFrame으로 변환
        conn.close()
        print(f"Data fetched successfully from {proc_name}!")
        return df
    except Exception as e:
        print(f"Database connection failed: {e}")
        return pd.DataFrame()


# 2. DB 연결 정보
connection_details = {
    "server": "localhost",
    "user": "your_username",
    "password": "your_password",
    "database": "your_database"
}

# 3. 데이터 읽기
print("Starting data fetching...")
start_time = time.time()

df_test_a = fetch_data_from_procedure("PTestA", connection_details)
df_test_b = fetch_data_from_procedure("PTestB", connection_details)
df_real_a = fetch_data_from_procedure("PRealA", connection_details)
df_real_b = fetch_data_from_procedure("PRealB", connection_details)

# 진행 시간 출력
print(f"Data fetching completed in {time.time() - start_time:.2f} seconds.\n")

# 4. 데이터 준비
if df_test_a.empty or df_test_b.empty or df_real_a.empty or df_real_b.empty:
    print("No data available. Check your procedures or database connection.")
    exit()

data_a = df_test_a.iloc[:, 1:].values[:4]
data_b = df_test_b.iloc[:, 1:].values[:4]
data = np.concatenate([data_a, data_b])

real_a = df_real_a.iloc[:, 1:].values[:4]
real_b = df_real_b.iloc[:, 1:].values[:4]
real_data = np.concatenate([real_a, real_b])

# 모델 리스트
models = {
    "RandomForest": RandomForestRegressor(),
    "LinearRegression": LinearRegression(),
    "SVR": SVR(kernel="linear")
}

# 5. 최적 모델 찾기
print("Starting model training and evaluation...")
start_time = time.time()

best_models = []
errors = []

for i in tqdm(range(8), desc="Training models"):
    # i번째 값을 제외한 나머지 7개 값으로 학습 데이터 구성
    X = np.delete(data, i).reshape(-1, 1)
    y = np.delete(data, np.arange(len(data)) != i)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # 각 모델로 학습 및 평가
    best_model = None
    best_error = float("inf")
    for model_name, model in models.items():
        model.fit(X_train, y_train)
        predictions = model.predict(X_test)
        error = mean_squared_error(y_test, predictions)

        if error < best_error:
            best_error = error
            best_model = model_name

    best_models.append(best_model)
    errors.append(best_error)

# 진행 시간 출력
print(f"Model training completed in {time.time() - start_time:.2f} seconds.\n")
print("Best model for each data point:", best_models)
print("Errors for each model:", errors)

# 6. 실시간 모니터링
print("Starting real-time monitoring...")
start_time = time.time()

avg_errors = []
for sample in tqdm(real_data.reshape(-1, 8), desc="Monitoring data"):
    sample_errors = []
    for i, model_name in enumerate(best_models):
        model = models[model_name]
        X_sample = np.delete(sample, i).reshape(-1, 1)
        y_sample = sample[i]

        prediction = model.predict(X_sample)
        error = abs(prediction - y_sample)
        sample_errors.append(error)

    avg_error = np.mean(sample_errors)
    avg_errors.append(avg_error)

# 진행 시간 출력
print(f"Real-time monitoring completed in {time.time() - start_time:.2f} seconds.\n")

# 평균 오차의 변화 시각화
plt.plot(avg_errors, label="Average Prediction Error")
plt.xlabel("New Sample Index")
plt.ylabel("Average Error")
plt.legend()
plt.title("Real-time Monitoring of Prediction Errors")
plt.show()
추가된 기능
진행 상황 출력

각 주요 단계 시작 및 완료 시 메시지를 출력합니다.
진행 시간을 측정하여 표시합니다.
진행률 표시

tqdm 라이브러리를 사용하여 모델 학습 및 실시간 모니터링 단계에서 진행률 바를 표시합니다.
진행 상황을 직관적으로 확인할 수 있습니다.
실시간 작업 시간 측정

각 단계의 시작과 종료 시 소요 시간을 계산하여 사용자에게 출력합니다.
실행 결과 예시
실행 중에 다음과 같은 메시지와 진행률이 출력됩니다:

sql
코드 복사
Starting data fetching...
Fetching data from procedure: PTestA
Data fetched successfully from PTestA!
Fetching data from procedure: PTestB
Data fetched successfully from PTestB!
Fetching data from procedure: PRealA
Data fetched successfully from PRealA!
Fetching data from procedure: PRealB
Data fetched successfully from PRealB!
Data fetching completed in 1.23 seconds.

Starting model training and evaluation...
Training models: 100%|███████████████████████████| 8/8 [00:05<00:00,  1.50it/s]
Model training completed in 5.34 seconds.

Best model for each data point: ['RandomForest', 'SVR', 'LinearRegression', ...]
Errors for each model: [0.0012, 0.0023, 0.0031, ...]

Starting real-time monitoring...
Monitoring data: 100%|████████████████████████████| 50/50 [00:10<00:00,  4.85it/s]
Real-time monitoring completed in 10.42 seconds.
추가 요구사항 설치
tqdm 라이브러리를 설치해야 합니다:

bash
코드 복사
pip install tqdm