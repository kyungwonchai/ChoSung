죄송합니다. 이제는 partial 클래스를 이용하여 TaskModel 클래스를 분리해서 관리하는 방식으로 진행해드리겠습니다. partial 클래스는 하나의 클래스를 여러 파일로 나누어 정의할 수 있게 해주는 기능입니다. 이를 이용해 TaskModel 클래스에서 함수를 별도의 파일로 분리해 관리하겠습니다.

1. TaskModel (Partial 클래스 기본 구조)
먼저 TaskModel의 기본 구조를 partial로 나눕니다. 이 구조는 함수의 로직을 분리하고 공통된 변수 및 로직은 한 파일에 두는 것입니다.

TaskModel.cs
csharp
코드 복사
public partial class TaskModel : ViewModelBase
{
    private PLCClass _plcInstance;  // PLC 인스턴스
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }  // 함수 상태 리스트
    public string Status { get; set; }   // 전체 작업 상태 (Pending, Running, Completed)
    private Stopwatch _stopwatch;  // 총 실행 시간 측정용
    public int TotalSeconds { get; set; }  // 총 소요 시간을 표시할 컬럼

    public TaskModel(PLCClass plcInstance)
    {
        _plcInstance = plcInstance;
        FunctionStatusList = new ObservableCollection<FunctionStatus>();  // 함수 상태 리스트 초기화
        Status = "Pending";
        _stopwatch = new Stopwatch();
        InitializeFunctions(1);  // SequenceFlag = 1
    }

    private void InitializeFunctions(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
                AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
                break;
            case 2:
                AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
                AddFunction("Task D", ExecuteTaskD, Brushes.Gray);
                break;
        }
    }

    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);
    }

    // 작업 시작
    public async Task StartTask()
    {
        _stopwatch.Restart();
        Status = "Running";
        await ExecuteTaskSequence();
        Status = "Completed";
        TotalSeconds = (int)_stopwatch.Elapsed.TotalSeconds;
        _stopwatch.Stop();
    }

    // 작업 순차 실행
    private async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            Stopwatch functionStopwatch = new Stopwatch();
            functionStopwatch.Start();
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);
            functionStopwatch.Stop();
            functionStatus.ExecutionTime = $"{functionStopwatch.Elapsed.TotalSeconds:F2} seconds";
        }
    }

    // 작업 실행 중/완료 시 색상 업데이트
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 진행 중 색상
        });

        await task();

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 색상
        });
    }
}
2. 함수를 분리하여 partial로 정의
이제 함수를 다른 파일로 분리하여 관리합니다. 함수들만 별도로 분리해 partial 클래스로 정의하여, 메인 TaskModel 파일이 깔끔해지도록 합니다.

TaskModel.Functions.cs
csharp
코드 복사
public partial class TaskModel
{
    // 예시 함수들 (Task A, Task B, Task C)
    private async Task ExecuteTaskA()
    {
        await _plcInstance.SendSignalAsync("Executing Task A...");
        await Task.Delay(1000);  // Task A 작업 (시뮬레이션)
    }

    private async Task ExecuteTaskB()
    {
        await _plcInstance.SendSignalAsync("Executing Task B...");
        await Task.Delay(1500);  // Task B 작업 (시뮬레이션)
    }

    private async Task ExecuteTaskC()
    {
        await _plcInstance.SendSignalAsync("Executing Task C...");
        await Task.Delay(2000);  // Task C 작업 (시뮬레이션)
    }

    private async Task ExecuteTaskD()
    {
        await _plcInstance.SendSignalAsync("Executing Task D...");
        await Task.Delay(2500);  // Task D 작업 (시뮬레이션)
    }
}
3. FunctionStatus 클래스
각 함수의 상태(도형 색상, 실행 시간)를 관리하는 FunctionStatus 클래스는 이전과 동일하게 사용합니다.

csharp
코드 복사
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }
    public string ExecutionTime { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush initialColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = initialColor;
    }

    public void UpdateStatus(Brush color)
    {
        StatusColor = color;
        OnPropertyChanged(nameof(StatusColor));
    }
}
요약:
partial 클래스를 사용해 TaskModel의 코드를 두 파일로 분리했습니다.
TaskModel.Functions.cs 파일에 함수들을 분리하여 추가했습니다. 이로 인해 코드의 가독성과 유지보수성이 높아집니다.
Main TaskModel 파일은 작업의 흐름을 관리하고, 각 함수들은 별도 파일로 관리됩니다.
이 구조는 작업의 복잡도를 줄이고, 중요한 로직과 개별 작업을 나누어 