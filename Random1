, 알겠습니다. 데이터베이스 기반의 마스터 키/일반 키 관리 및 변경 기능을 구현하기 위해 필요한 파일들을 순서대로 드리겠습니다. 이전 단계에서 SQL 스크립트와 Models/AppSetting.cs를 제공했으므로, 다음 두 파일을 제공합니다.

수정/추가해야 할 파일 목록 (이번 단계):

Data/LockerDbContext.cs: AppSettings 테이블에 접근하기 위한 DbSet 추가.
ViewModels/PasswordChangeViewModel.cs (신규): 비밀번호 변경 창의 로직을 처리할 새 ViewModel.
1. Data/LockerDbContext.cs (수정)

DbSet<AppSetting> 속성을 추가합니다.

C#

// FILE_ID: Data/LockerDbContext_20250410104800
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Threading;
using System.ComponentModel.DataAnnotations.Schema;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }
        // *** 신규: AppSettings 테이블 DbSet 추가 ***
        public DbSet<AppSetting> AppSettings { get; set; }

        private const string ConnectionStringName = "LockerDbConnection";

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();

            // AppSetting 모델의 키 설정 (Fluent API)
            modelBuilder.Entity<AppSetting>().HasKey(s => s.SettingKey);

            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        // SaveChanges 재정의 제거됨 (인터셉터 사용 안 함)
    }
}
2. ViewModels/PasswordChangeViewModel.cs (신규 파일)

ViewModels 폴더에 이 파일을 새로 추가하세요. 비밀번호 변경 로직을 담당합니다.

C#

// FILE_ID: ViewModels/PasswordChangeViewModel_20250410104800
using LockerManagementApp.Data;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Models;
using System;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    public class PasswordChangeViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private bool _disposed = false;

        private SecureString _currentPassword;
        private SecureString _newPassword;
        private SecureString _confirmPassword;
        private string _statusMessage;

        public SecureString CurrentPassword { get => _currentPassword; set => SetProperty(ref _currentPassword, value); }
        public SecureString NewPassword { get => _newPassword; set => SetProperty(ref _newPassword, value); }
        public SecureString ConfirmPassword { get => _confirmPassword; set => SetProperty(ref _confirmPassword, value); }
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }

        public ICommand ChangeMasterKeyCommand { get; }
        public ICommand ChangeNormalKeyCommand { get; }

        public PasswordChangeViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { if (!App.IsShuttingDown) MessageBox.Show($"[PasswordChange] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 [PasswordChange] DB 컨텍스트 생성 오류 무시됨: {ex.Message}"); StatusMessage = "DB 연결 오류!"; ChangeMasterKeyCommand = new RelayCommand(_ => { }, _ => false); ChangeNormalKeyCommand = new RelayCommand(_ => { }, _ => false); return; }

            ChangeMasterKeyCommand = new RelayCommand(async _ => await ChangePasswordAsync("MasterKey"), CanChangePasswordExecute);
            ChangeNormalKeyCommand = new RelayCommand(async _ => await ChangePasswordAsync("NormalKey"), CanChangePasswordExecute);
        }

        private bool CanChangePasswordExecute(object parameter)
        {
            return !_disposed &&
                   CurrentPassword != null && CurrentPassword.Length > 0 &&
                   NewPassword != null && NewPassword.Length > 0 &&
                   ConfirmPassword != null && ConfirmPassword.Length > 0;
        }

        private async Task ChangePasswordAsync(string keyToChange)
        {
            if (!CanChangePasswordExecute(null)) return;

            string currentPlainText = ConvertToUnsecureString(CurrentPassword);
            string newPlainText = ConvertToUnsecureString(NewPassword);
            string confirmPlainText = ConvertToUnsecureString(ConfirmPassword);

            if (string.IsNullOrEmpty(currentPlainText) || string.IsNullOrEmpty(newPlainText) || string.IsNullOrEmpty(confirmPlainText))
            {
                StatusMessage = "현재 비밀번호, 새 비밀번호, 확인 비밀번호를 모두 입력하세요.";
                MessageBox.Show(StatusMessage, "입력 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            if (newPlainText != confirmPlainText)
            {
                StatusMessage = "새 비밀번호와 확인 비밀번호가 일치하지 않습니다.";
                MessageBox.Show(StatusMessage, "입력 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            StatusMessage = $"{keyToChange} 변경 중...";
            try
            {
                var setting = await _context.AppSettings.FindAsync(keyToChange);
                if (setting == null)
                {
                    StatusMessage = $"설정 오류: 데이터베이스에서 '{keyToChange}' 설정을 찾을 수 없습니다.";
                    MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                if (setting.SettingValue != currentPlainText)
                {
                    StatusMessage = "현재 비밀번호가 일치하지 않습니다.";
                    MessageBox.Show(StatusMessage, "인증 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                setting.SettingValue = newPlainText; // 새 비밀번호로 업데이트
                _context.Entry(setting).State = EntityState.Modified;
                int result = await _context.SaveChangesAsync();

                if (result > 0)
                {
                    StatusMessage = $"{keyToChange} 비밀번호가 성공적으로 변경되었습니다.";
                    MessageBox.Show(StatusMessage, "변경 완료", MessageBoxButton.OK, MessageBoxImage.Information);
                    // 변경 성공 후 필드 초기화 (선택 사항)
                    CurrentPassword = new SecureString();
                    NewPassword = new SecureString();
                    ConfirmPassword = new SecureString();
                    OnPropertyChanged(nameof(CurrentPassword));
                    OnPropertyChanged(nameof(NewPassword));
                    OnPropertyChanged(nameof(ConfirmPassword));
                }
                else
                {
                    StatusMessage = $"{keyToChange} 비밀번호 변경 중 오류가 발생했습니다 (DB 반영 실패).";
                    MessageBox.Show(StatusMessage, "변경 실패", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            catch (Exception ex)
            {
                StatusMessage = $"{keyToChange} 비밀번호 변경 중 오류 발생: {ex.Message}";
                if (!App.IsShuttingDown && !_disposed) MessageBox.Show($"{StatusMessage}\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                else Debug.WriteLine($"종료 중 비밀번호 변경 오류 무시됨: {ex.ToString()}");
            }
            finally
            {
                (ChangeMasterKeyCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (ChangeNormalKeyCommand as RelayCommand)?.RaiseCanExecuteChanged();
            }
        }

        private string ConvertToUnsecureString(SecureString securePassword)
        {
            if (securePassword == null) return string.Empty;
            IntPtr ptr = IntPtr.Zero;
            try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); }
            finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); }
        }

        #region IDisposable 구현
        protected virtual void Dispose(bool disposing) { if (!_disposed) { _disposed = true; if (disposing) { Debug.WriteLine("PasswordChangeViewModel Dispose 시작..."); try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! PasswordChangeViewModel DbContext Dispose 오류: {ex.Message}"); } Debug.WriteLine("PasswordChangeViewModel 리소스 해제 완료."); } } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
핵심 변경 사항:

Data/LockerDbContext.cs: DbSet<AppSetting> AppSettings { get; set; } 속성을 추가하고, OnModelCreating에서 AppSetting 모델의 기본 키를 설정했습니다.
ViewModels/PasswordChangeViewModel.cs (신규):
비밀번호 변경 UI와 바인딩될 CurrentPassword, NewPassword, ConfirmPassword, StatusMessage 속성을 정의했습니다.
마스터 키 변경과 일반 키 변경을 위한 ChangeMasterKeyCommand, ChangeNormalKeyCommand를 정의했습니다.
ChangePasswordAsync 메서드에서 현재 비밀번호 확인, 새 비밀번호 일치 확인 후, AppSettings 테이블에서 해당 키를 찾아 값을 업데이트하고 SaveChangesAsync를 호출하여 DB에 저장하는 로직을 구현했습니다.