아, AuditLog 파일 문제였군요! 정확한 원인을 찾아내셨네요.

DbContext의 SaveChanges 메서드가 호출될 때, 변경된 모든 엔티티(여기서는 마스터 데이터와 새로 생성된 AuditLog 엔티티)에 대해 유효성 검사가 수행됩니다. 만약 Models/AuditLog.cs 파일의 UserName 속성에 [Required] 어트리뷰트가 설정되어 있는데, 어떤 이유로든 사용자 이름을 가져오지 못해 null이나 빈 문자열이 할당되면 "UserName 필드가 필요합니다" 유효성 검사 오류가 발생하는 것이 맞습니다.

해결 방법:

Models/AuditLog.cs: UserName 속성에서 [Required] 어트리뷰트를 제거합니다. 로그 기록 시 사용자 이름을 가져오지 못하는 예외적인 경우에도 로그 자체는 기록되도록 허용하는 것이 더 안정적일 수 있습니다. (DB 스키마는 NOT NULL이므로 코드에서 "UnknownUser" 같은 기본값을 넣어주는 것이 좋습니다 - 이전 DbContext 코드에 이미 반영됨).
Data/LockerDbContext.cs: CreateAuditEntries 메서드에서 사용자 이름을 가져오는 부분(System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser")이 null일 경우 "UnknownUser"를 할당하는 로직이 제대로 있는지 다시 확인합니다. (이전 코드에 포함됨)
ViewModels/MasterDataViewModel.cs: 이 파일은 직접적인 수정 대상은 아니지만, 저장 로직을 호출하는 주체이므로 확인 차원에서 최종 버전을 다시 제공합니다.
수정해야 할 파일 목록:

Models/AuditLog.cs
Data/LockerDbContext.cs (확인 및 최종본 제공)
ViewModels/MasterDataViewModel.cs (확인 및 최종본 제공)
아래에 이 3개 파일의 수정된 전체 코드를 작성합니다.

1. Models/AuditLog.cs (수정)

UserName 속성에서 [Required] 어트리뷰트를 제거합니다.

C#

using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace LockerManagementApp.Models
{
    /// <summary>
    /// 데이터 변경 감사 로그 모델 (UserName 필수 조건 제거)
    /// </summary>
    [Table("AuditLogs")]
    public class AuditLog
    {
        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id { get; set; }

        [Required] // 타임스탬프는 필수
        public DateTime Timestamp { get; set; }

        // *** 수정된 부분: [Required] 제거 ***
        // 사용자 이름을 가져오지 못하는 경우 "UnknownUser" 등으로 처리하므로 C# 모델에서는 필수가 아님
        // (DB 스키마는 NOT NULL 유지)
        [StringLength(100)]
        public string UserName { get; set; }

        [Required] // Action은 필수
        [StringLength(50)]
        public string Action { get; set; }

        [Required] // TableName은 필수
        [StringLength(100)]
        public string TableName { get; set; }

        [StringLength(100)]
        public string RecordId { get; set; } // Null 가능

        public string AffectedColumns { get; set; } // Null 가능

        public string OldValues { get; set; } // Null 가능

        public string NewValues { get; set; } // Null 가능
    }
}
2. Data/LockerDbContext.cs (확인 및 최종본)

CreateAuditEntries 메서드에서 currentUserName 할당 시 ?? "UnknownUser" 부분이 있는지, ValidateEntity 재정의가 포함되어 있는지 확인합니다. (이전 최종 버전과 동일)

C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json; // Newtonsoft.Json 사용
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (최종 확인)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- DbSets ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        public LockerDbContext() : base("name=LockerDbConnection") { }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // LockerAssignment Nullable 속성 설정 확인
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();

            base.OnModelCreating(modelBuilder);
        }

        /// <summary>
        /// LockerAssignment의 UserName 필수 오류를 무시하도록 유효성 검사 재정의
        /// </summary>
        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified))
            {
                var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList();
                if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류를 무시합니다."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } }
            }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (최종 확인)

        public override int SaveChanges()
        {
            List<AuditLog> auditEntries = null;
            #region Logging Enable/Disable
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
            #endregion
            try { return base.SaveChanges(); }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
        }

        public override async Task<int> SaveChangesAsync()
        {
             List<AuditLog> auditEntries = null;
            #region Logging Enable/Disable
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
            #endregion
            try { return await base.SaveChangesAsync(); }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
        }

        /// <summary>
        /// 감사 로그 엔트리 생성 (UserName 기본값 할당 확인)
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            // *** UserName이 null일 경우 "UnknownUser" 할당 확인 ***
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();
            var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) continue;
                var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() };
                try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();
                if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Modified) { foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (affectedColumns.Any()) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else continue; }
                auditEntries.Add(auditEntry);
            }
            UpdateLockerAssignmentTimestamps(changedEntries); return auditEntries;
        }

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; } }

        #endregion

        #region Error Logging Helpers (이전과 동일)
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.Message}"); var innerEx = dbEx.InnerException; while (innerEx != null) { Debug.WriteLine($"  InnerException: {innerEx.Message}"); innerEx = innerEx.InnerException; } foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
3. ViewModels/MasterDataViewModel.cs (확인용)

(이전 최종 버전과 동일 - 저장 전 Detach 로직 포함 확인)

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation; // 추가될 수 있음
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (최종 확인)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private bool _disposed = false;

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }
            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync()); AddItemCommand = new RelayCommand(AddItem, CanAddItemExecute); DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItemExecute); SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync(), CanSaveChangesExecute);
            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null || _disposed) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private bool CanAddItemExecute(object parameter) => !_disposed && _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private bool CanDeleteItemExecute(object parameter) => !_disposed && _context != null && SelectedItem != null;
        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private void AddItem(object parameter) { if (!CanAddItemExecute(parameter)) return; if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private void DeleteItem(object parameter) { if (!CanDeleteItemExecute(parameter)) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = SelectedItem; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || _disposed || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }

        private async Task SaveMasterDataChangesAsync()
        {
            if (!CanSaveChangesExecute(null)) { StatusMessage = "저장할 변경 사항이 없습니다."; return; }
            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList();

            // 저장 전 관련 없는 엔티티 Detach
            var unrelatedEntries = _context.ChangeTracker.Entries().Where(e => !(e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator || e.Entity is AuditLog)).ToList();
            if (unrelatedEntries.Any()) { Debug.WriteLine($"경고: MasterDataViewModel 저장 시 관련 없는 엔티티 {unrelatedEntries.Count}개를 Detach합니다."); foreach (var unrelatedEntry in unrelatedEntries) { unrelatedEntry.State = EntityState.Detached; } }

            using (var transaction = _context.Database.BeginTransaction())
            {
                try { Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨."); var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, EntityType = e.Entity.GetType(), OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList(); Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}"); foreach (var modified in modifiedNameEntries) { StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'"); int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType"; else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor"; else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone"; else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart"; else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator"; if (!string.IsNullOrEmpty(targetColumn)) { updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}"; try { updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}"); } catch (Exception sqlEx) { Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}"); StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!"; throw new Exception($"연쇄 업데이트 SQL 실행 실패 ({modified.OriginalName} -> {modified.CurrentName}): {sqlEx.Message}", sqlEx); } } else { Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다."); } } Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)..."); int masterDataChanges = await _context.SaveChangesAsync(); Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}"); transaction.Commit(); Debug.WriteLine("트랜잭션 커밋 완료."); StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다."; }
                catch (DbEntityValidationException vex) { Debug.WriteLine($"*** 마스터 데이터 SaveChanges 중 DbEntityValidationException 발생! 트랜잭션 롤백 시도...\n*** 오류: {vex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleValidationExceptionForMasterData(vex); RollbackMasterDataChanges(changesForRollback); }
                catch (DbUpdateException dbEx) { Debug.WriteLine($"*** 마스터 데이터 SaveChanges 중 DbUpdateException 발생! 트랜잭션 롤백 시도...\n*** 오류: {dbEx.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleDbUpdateExceptionForMasterData(dbEx); RollbackMasterDataChanges(changesForRollback); }
                catch (Exception ex) { Debug.WriteLine($"*** 마스터 데이터 저장/연쇄 업데이트 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}"; MessageBox.Show($"{StatusMessage}\n\n자세한 내용은 출력 창을 확인하세요.", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error); RollbackMasterDataChanges(changesForRollback); }
            } await LoadAllMasterDataAsync(); RaiseCanExecuteChanged();
        }
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusMessage = "마스터 데이터 변경 롤백됨."; _ = LoadAllMasterDataAsync(); }
        private void HandleDbUpdateExceptionForMasterData(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusMessage = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleValidationExceptionForMasterData(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusMessage = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        #endregion

        private void RaiseCanExecuteChanged() { (LoadAllMasterDataCommand as RelayCommand)?.RaiseCanExecuteChanged(); (AddItemCommand as RelayCommand)?.RaiseCanExecuteChanged(); (DeleteItemCommand as RelayCommand)?.RaiseCanExecuteChanged(); (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #region IDisposable 구현
        // private bool disposed = false; // 클래스 멤버 변수로 이동됨
        protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { _context?.Dispose(); } _disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
 1 핵심 변경 사항:   
1.
github.com
github.com

Models/AuditLog.cs: UserName 속성에서 [Required] 어트리뷰트를 제거했습니다.
Data/LockerDbContext.cs:
ValidateEntity 메서드를 재정의하여 LockerAssignment의 UserName이 null일 때 발생하는 유효성 검사 오류를 명시적으로 무시하도록 처리했습니다.
SaveChanges/SaveChangesAsync에서 로그 기록 로직을 쉽게 주석 처리하여 테스트할 수 있도록 #region을 추가했습니다. 만약 여전히 저장 오류가 발생한다면, 이 #region 부분을 주석 처리하고 다시 시도하여 로깅 로직이 문제인지 확인해 보세요.
DbEntityValidationException 발생 시 더 자세한 오류 정보(어떤 속성에서 어떤 오류인지)를 디버그 창에 출력하도록 LogValidationErrors 헬퍼 메서드를 추가했습니다.
JSON 직렬화 라이브러리를 Newtonsoft.Json으로 변경했습니다 (NuGet 패키지 설치 필요).
ViewModels/MasterDataViewModel.cs: 저장(SaveMasterDataChangesAsync) 전에 관련 없는 엔티티를 Detach하는 로직이 포함된 최종 버전을 다시 제공했습니다. DbEntityValidationException을 처리하는 헬퍼 메서드 호출을 추가했습니다.
다음 단계:

NuGet 패키지: Newtonsoft.Json 패키지를 설치합니다.
코드 적용 및 빌드: 위 코드로 해당 파일들을 업데이트하고 솔루션을 다시 빌드합니다.
오류 재현 및 확인:
마스터 데이터 창에서 저장 시 오류가 발생하면, 오류 메시지 박스의 전체 내용과 Visual Studio 출력 창에 DbEntityValidationException 관련 상세 로그(어떤 속성, 어떤 오류 메시지)가 출력되는지 확인하여 알려주세요.