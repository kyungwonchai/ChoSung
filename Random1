이해했습니다. 프로그램의 DB 기록과 실제 동작은 잘되는데, **UI의 상태(Status 컬럼)**가 갱신되지 않는 문제가 있다는 것이군요. 작업이 실패하면 Status 컬럼에 "Processing"이 아닌 **실패 상태("Failed", "Timeout")**가 표시되어야 하며, 행의 색상도 핑크색으로 바뀌어야 합니다.

이를 해결하기 위해:

상태(Status)를 제대로 갱신하고 반영해야 합니다.
DataGrid의 행 색상을 상태에 맞게 변경해야 합니다.
해결 방안:
UI에서 Status 컬럼이 즉시 반영되지 않는 문제:

작업의 상태가 변경될 때마다 명확하게 UI에 반영되도록 OnPropertyChanged를 호출하고, 명령이 끝나면 항상 마지막 상태가 반영되도록 수정합니다.
DataGrid 행 색상 변경:

Status 값에 따라 행의 배경색을 동적으로 변경해야 합니다.
실패 시에는 핑크색으로, 성공 시 다른 색상으로 설정합니다.
수정된 코드 (상태 갱신과 행 색상 반영 포함, 주석 추가)
csharp
코드 복사
// 비동기 작업을 큐에 추가하고 처리하는 메서드
private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
{
    // 새로운 명령 아이템 생성
    var newCommand = new CommandItem 
    { 
        CommandText = commandText, 
        Status = "Pending", // 상태를 "Pending"으로 초기화 (대기 중 상태)
        MaxRetryLimit = RetryLimit, 
        RetryCount = 0, 
        CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") 
    };

    // UI 갱신: 남아있는 명령 리스트에 추가
    App.Current.Dispatcher.Invoke(() =>
    {
        RemainingCommands.Add(newCommand);
    });

    // 큐에 비동기 작업 추가
    commandQueue.Enqueue(async () =>
    {
        newCommand.Status = "Processing"; // 명령 처리 중일 때 상태를 "Processing"으로 변경
        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

        int retryCount = 0;
        Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정을 위한 스톱워치
        _isProcessing = true;

        // 최대 재시도 횟수까지 반복
        while (retryCount < RetryLimit) 
        {
            try
            {
                stopwatch.Restart(); // 스톱워치 시작
                string result = await taskFunc(); // 비동기 작업 실행
                stopwatch.Stop(); // 작업 종료 시 스톱워치 종료

                int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 측정
                newCommand.ResponseTime = responseTime;
                newCommand.RetryCount = retryCount;

                // 응답 시간이 초과된 경우
                if (responseTime > ResponseTimeout)
                {
                    newCommand.Status = "Timeout"; // 상태를 "Timeout"으로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영
                    newCommand.Result = 0; // 실패로 처리

                    // 데이터베이스에 Timeout 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Timeout occurred");
                    StopQueueProcessing(newCommand); // 큐 중단

                    return new CommandResult { Success = false, Message = "Response Timeout" };
                }

                // 응답이 정상일 경우
                if (responseValidator(result))
                {
                    newCommand.Status = "Completed"; // 상태를 "Completed"로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                    newCommand.Result = 1; // 성공 처리
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, result);
                    UpdateProgress();
                    _isProcessing = false;
                    return new CommandResult { Success = true, Message = result };
                }
                else
                {
                    retryCount++;
                    newCommand.Status = $"Retrying {retryCount}/{RetryLimit}"; // 재시도 상태 반영
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                    if (retryCount >= RetryLimit) // 재시도 실패 시
                    {
                        newCommand.Status = "Failed"; // 상태를 "Failed"로 변경
                        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영
                        newCommand.Result = 0; // 실패 처리

                        // DB에 실패 상태 기록
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, "Failed after retries");
                        StopQueueProcessing(newCommand); // 큐 중단

                        return new CommandResult { Success = false, Message = result };
                    }

                    await Task.Delay(RetryInterval); // 재시도 간격 대기
                }
            }
            catch (Exception ex)
            {
                newCommand.Status = "Failed"; // 예외 발생 시 상태를 "Failed"로 변경
                App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영
                newCommand.Result = 0;
                stopwatch.Stop();

                int responseTime = (int)stopwatch.ElapsedMilliseconds;
                newCommand.ResponseTime = responseTime;

                // DB에 에러 로그 기록
                await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                ShowAlarm("Error occurred. All tasks stopped.");
                StopQueueProcessing(newCommand); // 큐 중단

                return new CommandResult { Success = false, Message = ex.Message };
            }
        }

        UpdateProgress(); // 프로그레스바 업데이트
        _isProcessing = false;
        return new CommandResult { Success = false };
    });

    if (!_isProcessing)
    {
        _isProcessing = true;
        await ProcessCommandQueue(); // 큐 작업 처리 시작
    }

    UpdateProgress(); // 프로그레스바 업데이트
}

// DataGrid에 표시된 작업의 상태에 따라 행 색상을 변경하는 XAML

<DataGrid Grid.Row="0" Grid.Column="0" ItemsSource="{Binding CommandQueue.RemainingCommands}" AutoGenerateColumns="False" Margin="10">
    <DataGrid.Columns>
        <DataGridTextColumn Header="Command" Binding="{Binding CommandText}" Width="200"/>
        <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="100"/>
        <DataGridTextColumn Header="Retry Count" Binding="{Binding RetryCount}" Width="100"/>
        <DataGridTextColumn Header="Response Time" Binding="{Binding ResponseTime}" Width="100"/>
        <DataGridTextColumn Header="Result" Binding="{Binding ResultText}" Width="100"/> <!-- Error/OK 상태 표시 -->
        <DataGridTextColumn Header="Time" Binding="{Binding CommandTime}" Width="150"/>
    </DataGrid.Columns>

    <DataGrid.RowStyle>
        <Style TargetType="DataGridRow">
            <Style.Triggers>
                <!-- Processing 상태일 때 행의 배경을 연한 회색으로 설정 -->
                <DataTrigger Binding="{Binding Status}" Value="Processing">
                    <Setter Property="Background" Value="LightGray"/>
                </DataTrigger>

                <!-- Failed 또는 Timeout 상태일 때 행의 배경을 핑크색으로 설정 -->
                <DataTrigger Binding="{Binding Status}" Value="Failed">
                    <Setter Property="Background" Value="Pink"/>
                </DataTrigger>
                <DataTrigger Binding="{Binding Status}" Value="Timeout">
                    <Setter Property="Background" Value="Pink"/>
                </DataTrigger>

                <!-- Completed 상태일 때 행의 배경을 연한 초록색으로 설정 -->
                <DataTrigger Binding="{Binding Status}" Value="Completed">
                    <Setter Property="Background" Value="LightGreen"/>
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </DataGrid.RowStyle>
</DataGrid>
주요 변경 사항:
상태 갱신:

명령의 상태가 실패(Failed) 또는 시간 초과(Timeout) 시, 즉시 UI에 반영됩니다.
OnPropertyChanged(nameof(RemainingCommands))를 사용하여 명령 상태가 변경될 때마다 UI를 업데이트하도록 처리했습니다.
DataGrid 행 색상 변경:

DataTrigger를 사용하여 각 상태에 따른 행의 배경색을 동적으로 설정했습니다.
Processing: 연한 회색 (LightGray)
Failed, Timeout: 핑크색 (Pink)
Completed: 연한 초록색 (LightGreen)
결론:
이제 프로그램이 명령을 처리하는 동안 실패하거나 에러가 발생하면 UI의 상태가 즉시 갱신되며, 행의 색상도 상태에 맞게 변경됩니다. Failed나 Timeout 