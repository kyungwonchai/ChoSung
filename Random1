네, 알겠습니다. 디버그 로그가 무한대로 출력되는 현상은 로그를 기록하는 로직 자체가 또 다른 변경으로 감지되어 다시 로그를 생성하려고 시도하면서 발생하는 무한 루프일 가능성이 매우 높습니다.

LockerDbContext.cs의 SaveChanges/SaveChangesAsync 메서드가 호출될 때 CreateAuditEntries가 실행되고, 여기서 생성된 AuditLog 객체가 AuditLogs.AddRange()를 통해 컨텍스트에 추가됩니다. 이때 추가된 AuditLog 객체 자체가 'Added' 상태가 되는데, CreateAuditEntries 메서드 내부에서 이 AuditLog 객체의 변경을 제대로 건너뛰지 못하면, 다음번 변경 감지 시 이 AuditLog 객체에 대한 로그를 또 생성하려고 시도하게 되어 무한 루프가 발생할 수 있습니다.

해결 방법:

CreateAuditEntries 메서드 내부의 foreach 루프 시작 부분에서, 현재 처리 중인 엔티티가 AuditLog 타입인지 가장 먼저 확인하고, 맞다면 즉시 다음 엔티티로 넘어가도록 (continue) 하여 AuditLog 자체에 대한 로그 생성을 확실하게 방지합니다. 또한, 진단을 위해 추가했던 AddRange 이후의 ChangeTracker 확인 로그는 제거하여 혼란을 줄입니다.

수정해야 할 파일 목록:

Data/LockerDbContext.cs
아래는 이 수정 사항을 반영한 LockerDbContext.cs 파일 전체 코드(주석 제외)입니다.

C#

using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        private const string ConnectionStringName = "LockerDbConnection";

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();
            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (무한 루프 방지)

        public override int SaveChanges()
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 시작...");
            List<AuditLog> auditEntries = null;
            try
            {
                auditEntries = CreateAuditEntries(false); // isMaster는 기본값 false 전달
                Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}");
            }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 시도...");
                    this.AuditLogs.AddRange(auditEntries);
                    Debug.WriteLine($"  -> 로그 AddRange 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); }
            }
            else { Debug.WriteLine("  -> 추가할 로그 없음 (변경 없거나 로그 생성 실패)."); }

            try
            {
                Debug.WriteLine($"  -> base.SaveChanges() 호출 시도...");
                var result = base.SaveChanges();
                Debug.WriteLine($"  -> base.SaveChanges() 완료. 결과 = {result}");
                return result;
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 종료."); }
        }

        // isMaster 파라미터를 받는 SaveChangesAsync 오버로드
        public async Task<int> SaveChangesAsync(bool isMaster)
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기, isMaster={isMaster}) Override 시작...");
             List<AuditLog> auditEntries = null;
            try
            {
                auditEntries = CreateAuditEntries(isMaster); // isMaster 전달
                Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}");
            }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 시도...");
                    this.AuditLogs.AddRange(auditEntries);
                    Debug.WriteLine($"  -> 로그 AddRange 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); }
            }
             else { Debug.WriteLine("  -> 추가할 로그 없음 (변경 없거나 로그 생성 실패)."); }

            try
            {
                Debug.WriteLine($"  -> base.SaveChangesAsync() 호출 시도...");
                var result = await base.SaveChangesAsync(); // CancellationToken 없는 기본 오버로드 호출
                Debug.WriteLine($"  -> base.SaveChangesAsync() 완료. 결과 = {result}");
                return result;
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기) Override 종료."); }
        }

        // CancellationToken을 받는 SaveChangesAsync 오버라이드는 isMaster=false로 위임
        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken)
        {
            Debug.WriteLine($"경고: SaveChangesAsync(CancellationToken) 오버라이드가 호출되었습니다. isMaster=false로 처리합니다.");
            // CancellationToken은 현재 로직에서 명시적으로 사용하지 않으므로 isMaster 받는 버전 호출
            return SaveChangesAsync(false);
        }


        /// <summary>
        /// 감사 로그 엔트리 생성 (AuditLog 자체 로깅 방지 강화)
        /// </summary>
        private List<AuditLog> CreateAuditEntries(bool isMaster)
        {
            Debug.WriteLine("  CreateAuditEntries 시작...");
            string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
            string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries()
                                     .Where(e => e.State != EntityState.Unchanged &&
                                                 e.State != EntityState.Detached)
                                     .ToList(); // AuditLog 필터링은 루프 내에서 수행

            if (!changedEntries.Any()) { Debug.WriteLine("  CreateAuditEntries: 감지된 변경 엔티티 없음."); return auditEntries; }

            Debug.WriteLine($"  CreateAuditEntries: 감지된 변경 엔티티 수 = {changedEntries.Count}");
            var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };

            foreach (var entry in changedEntries)
            {
                // *** 수정: 루프 시작 시 AuditLog 타입인지 가장 먼저 확인 ***
                if (entry.Entity is AuditLog)
                {
                    Debug.WriteLine("    - AuditLog 엔티티 변경 감지됨 (로깅 건너뜀).");
                    continue; // AuditLog 자체의 변경은 로깅하지 않음
                }

                var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() };
                try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                // 값 변경 로깅 로직 (이전과 동일)
                if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Modified) { bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                auditEntries.Add(auditEntry);
                Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}");
            }
            UpdateLockerAssignmentTimestamps(changedEntries);
            Debug.WriteLine("  CreateAuditEntries 종료.");
            return auditEntries;
        }

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps: {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        #endregion

        #region Error Logging Helpers
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
핵심 변경 사항:

CreateAuditEntries 메서드: foreach (var entry in changedEntries) 루프 시작 부분에 if (entry.Entity is AuditLog) continue; 조건을 가장 먼저 배치하여, 처리 대상 엔티티가 AuditLog 자체인 경우 즉시 다음 엔티티로 넘어가도록 명확히 수정했습니다. 이를 통해 AuditLog 추가로 인해 다시 AuditLog가 생성되는 무한 루프를 방지합니다.
SaveChanges/SaveChangesAsync 오버로드: ViewModel에서 isMaster 플래그를 전달받는 오버로드를 명확히 하고, CancellationToken만 받는 기본 오버라이드는 isMaster=false로 위임하도록 수정했습니다. (ViewModel 코드에서 SaveChangesAsync(isMaster, cancellationToken) 대신 SaveChangesAsync(isMaster)를 호출하도록 수정했으므로 이 부분은 이제 안전합니다.)
다음 단계:

코드 적용 및 빌드: 위 코드로 LockerDbContext.cs 파일을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
메인 화면 또는 마스터 데이터 관리 화면에서 데이터를 수정/추가/삭제하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 확인합니다.
이제 로그가 무한대로 찍히지 않아야 합니다.
SaveChanges... Override 시작... 부터 SaveChanges... Override 종료. 까지의 로그가 한 번의 저장 작업에 대해 한 번만 나타나야 합니다.
CreateAuditEntries: 감지된 변경 엔티티 수 = ... 가 예상한 변경 수 + 생성될 로그 수만큼 나오는지 확인합니다. (예: 사물함 1개 수정 시 -> 변경 엔티티 2개 (LockerAssignment, AuditLog))
- 로그 생성됨: ... 메시지가 예상한 만큼(보통 1개 또는 수정된 엔티티당 1개) 나타나는지 확인합니다.
-> ChangeTracker 확인: ...개의 AuditLog 엔티티가 Added 상태임. 메시지에 예상한 로그 수가 표시되는지 확인합니다.
-> base.SaveChanges() 완료. 결과 = ... 메시지의 결과 숫자가 (원본 변경 수 + 로그 수)와 일치하는지 확인합니다.