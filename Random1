아래는 설명에 맞춰 새로 설계된 파일 처리 클래스를 포함한 WPF 프로젝트의 구조입니다. FileWatcher 대신 5초마다 폴더에서 새 파일을 확인하고, 두 개의 PO_NO에 해당하는 모든 MAG_NO 파일을 묶어 처리하도록 구현하였습니다. 파일 처리 로직은 별도의 클래스에서 처리하며, 메인 ViewModel에서는 필요한 부분만 생성자에서 넘겨 사용합니다.

FileProcessor 클래스 (파일을 처리하는 별도의 클래스)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;

public class FileProcessor
{
    private readonly string _logFolder;  // 로그 파일이 저장된 폴더 경로
    private Dictionary<string, List<LogEntry>> _poLogEntries = new Dictionary<string, List<LogEntry>>();  // PO_NO에 따른 로그 저장
    private List<string> _processedFiles = new List<string>();  // 이미 처리한 파일명 저장

    public FileProcessor(string logFolder)
    {
        _logFolder = logFolder;
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 새로운 파일이 있으면 처리합니다.
    /// </summary>
    public List<LogEntry> CheckForNewFiles()
    {
        List<LogEntry> newEntries = new List<LogEntry>();

        // 폴더 내의 모든 파일을 시간순으로 정렬
        var files = Directory.GetFiles(_logFolder, "*.txt").OrderBy(f => f).ToList();

        foreach (var file in files)
        {
            // 이미 처리한 파일은 건너뜀
            if (_processedFiles.Contains(Path.GetFileName(file)))
                continue;

            // 파일을 읽어서 파싱 후 데이터 추가
            var logEntry = ParseFile(file);

            // 새로운 파일에 대해서만 처리
            if (!_poLogEntries.ContainsKey(logEntry.PO_NO))
            {
                _poLogEntries[logEntry.PO_NO] = new List<LogEntry>();
            }
            _poLogEntries[logEntry.PO_NO].Add(logEntry);
            _processedFiles.Add(Path.GetFileName(file));  // 처리한 파일을 목록에 추가
            newEntries.Add(logEntry);  // 새로 추가된 엔트리를 반환 목록에 추가
        }

        // PO_NO 당 두 개의 가장 최근 배치만 유지하도록 제한
        return ProcessRecentPOEntries();
    }

    /// <summary>
    /// 파일을 읽어서 LogEntry 객체로 변환합니다.
    /// </summary>
    /// <param name="filePath">읽을 파일의 경로</param>
    /// <returns>파싱된 LogEntry 객체</returns>
    private LogEntry ParseFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);

        var logEntry = new LogEntry
        {
            FileName = Path.GetFileName(filePath),
            MAG_NO = GetValueFromLine(lines, "MAG_NO"),
            MAG_QTY = int.Parse(GetValueFromLine(lines, "MAG_QTY")),
            PO_NO = GetValueFromLine(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(GetValueFromLine(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(GetValueFromLine(lines, "PO_PROD_QTY"))
        };

        return logEntry;
    }

    /// <summary>
    /// 파일에서 특정 키에 해당하는 값을 추출합니다.
    /// </summary>
    /// <param name="lines">파일 내용</param>
    /// <param name="key">찾고자 하는 키 (예: "MAG_NO")</param>
    /// <returns>해당 키에 해당하는 값</returns>
    private string GetValueFromLine(string[] lines, string key)
    {
        var line = lines.FirstOrDefault(l => l.Contains(key));
        return line?.Split('=')[1].Trim('\'');
    }

    /// <summary>
    /// 가장 최근의 두 개의 PO_NO만 처리하고 나머지는 정리합니다.
    /// </summary>
    private List<LogEntry> ProcessRecentPOEntries()
    {
        var result = new List<LogEntry>();

        // PO_NO에 따라 처리한 로그 중에서 가장 최근 두 개의 PO_NO만 남김
        var recentPOs = _poLogEntries.OrderByDescending(p => p.Value.Last().FileName).Take(2).ToList();

        foreach (var poLog in recentPOs)
        {
            result.AddRange(poLog.Value);
        }

        return result;
    }
}
MainViewModel (파일 처리 클래스 호출)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows.Input;

public class MainViewModel
{
    private readonly FileProcessor _fileProcessor;  // 파일 처리 클래스
    private Timer _timer;  // 5초마다 체크할 타이머

    public ObservableCollection<LogEntry> LogEntries { get; set; }  // DataGrid에 바인딩할 로그 목록
    public ICommand LoadLogsCommand { get; }  // 수동으로 로그를 로드하는 명령

    public MainViewModel()
    {
        LogEntries = new ObservableCollection<LogEntry>();
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG");

        // 5초마다 폴더를 감시하는 타이머 설정
        _timer = new Timer(CheckForNewLogs, null, 0, 5000);

        // 수동으로 로그 로드를 위한 커맨드 설정
        LoadLogsCommand = new RelayCommand(LoadRecentLogs);
    }

    /// <summary>
    /// 타이머가 5초마다 호출하여 새로운 로그 파일을 확인합니다.
    /// </summary>
    private void CheckForNewLogs(object state)
    {
        var newEntries = _fileProcessor.CheckForNewFiles();

        // 새로운 엔트리들을 DataGrid에 추가
        foreach (var entry in newEntries)
        {
            App.Current.Dispatcher.Invoke(() => LogEntries.Add(entry));
        }
    }

    /// <summary>
    /// 수동으로 로그를 로드하는 명령 실행 시 호출됩니다.
    /// </summary>
    private void LoadRecentLogs()
    {
        var newEntries = _fileProcessor.CheckForNewFiles();

        foreach (var entry in newEntries)
        {
            LogEntries.Add(entry);
        }
    }
}
LogEntry 클래스
csharp
코드 복사
public class LogEntry
{
    public string FileName { get; set; }  // 파일 이름
    public string MAG_NO { get; set; }  // MAG_NO
    public int MAG_QTY { get; set; }  // MAG_QTY
    public string PO_NO { get; set; }  // PO_NO
    public int PO_PLAN_QTY { get; set; }  // PO_PLAN_QTY
    public int PO_PROD_QTY { get; set; }  // PO_PROD_QTY
}
RelayCommand 클래스
csharp
코드 복사
using System;
using System.Windows.Input;

public class RelayCommand : ICommand
{
    private readonly Action _execute;

    public RelayCommand(Action execute)
    {
        _execute = execute;
    }

    public bool CanExecute(object parameter) => true;

    public void Execute(object parameter)
    {
        _execute();
    }

    public event EventHandler CanExecuteChanged;
}
설명
파일 처리 클래스 (FileProcessor): FileProcessor는 주기적으로 파일을 읽고, PO_NO에 따라 파일들을 그룹화하여 5초마다 새로운 파일을 찾습니다. 또한 가장 최근 두 개의 PO_NO에 해당하는 파일들만 유지하며 나머지는 처리하지 않습니다.
파일 명 처리: 파일 이름은 고유하다고 가정하고 중복 처리를 방지하기 위해 Dictionary를 사용해 PO_NO별로 파일을 관리합니다. 새로운 파일이 추가되면 해당 PO_NO에 속하는 데이터를 계속 누적해서 추가합니다.
파일 읽기 로직: ParseFile()에서 각 파일의 내용을 읽어 LogEntry로 변환하고, 이 데이터는 메인 ViewModel에서 UI에 반영됩니다.
MainViewModel: 메인 ViewModel에서는 생성자로 FileProcessor를 생성하고, 타이머를 통해 5초마다 새로운 파일을 체크합니다. LogEntries는 DataGrid에 바인딩되며, 새로운 항목이 있으면 UI에 반영됩니다.
이 구조를 사용하면 PO_NO 단위로 로그 파일을 묶어서 처리할 수 있으며, 5초마다 폴더를 확인하여 새로운 파일이 있으면 그 파일을 읽어 DataGrid에 표시할 수 있습니