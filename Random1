겠습니다. 말씀하신 요구 사항을 반영한 코드를 제공해드리겠습니다.

처음 실행 시 최근 10개의 파일을 가져와 완료 처리: 파일 목록에서 최근 10개의 파일을 읽어 미리 완료 처리합니다.
이후 새로 들어오는 파일은 기존 로직대로 정상 처리됩니다.
아래 코드는 처음 실행 시 최근 10개 파일을 완료 처리하고, 그다음에 새로 들어오는 파일은 기존 로직대로 처리하는 흐름을 구현합니다.

수정된 FileProcessor.cs 전체 코드:
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Timers;

public class FileProcessor
{
    private string _inputDirectory;  // 파일을 감지할 디렉토리
    private string _backupDirectory;  // 백업 디렉토리
    private Timer _cleanupTimer;  // 파일 삭제 타이머

    // 파일이 감지되었을 때 발생하는 이벤트
    public event Action<LogEntry> OnLogEntryDetected;

    private bool _isInitialRun = true;  // 첫 실행 여부 체크

    public FileProcessor(string inputDirectory)
    {
        _inputDirectory = inputDirectory;
        _backupDirectory = @"C:\MESPRODFILE_Backup";

        // 24시간마다 한 번씩 파일 정리 작업 실행
        _cleanupTimer = new Timer(TimeSpan.FromDays(1).TotalMilliseconds);
        _cleanupTimer.Elapsed += (sender, args) => CleanupOldFiles();
        _cleanupTimer.Start();
    }

    /// <summary>
    /// 파일 감지 작업 시작
    /// </summary>
    public void StartProcessing()
    {
        Task.Run(() => MonitorDirectory());
    }

    /// <summary>
    /// 디렉토리를 감시하여 새로운 파일을 감지
    /// </summary>
    private void MonitorDirectory()
    {
        if (_isInitialRun)
        {
            // 첫 실행 시 최근 10개 파일을 미리 완료 처리
            ProcessRecentFiles();
            _isInitialRun = false;  // 초기 실행 체크 해제
        }

        while (true)
        {
            var files = Directory.GetFiles(_inputDirectory, "*.txt");
            foreach (var file in files)
            {
                // 새 파일은 백업 폴더로 이동 후 처리
                var backupFile = MoveFileToBackup(file);
                if (backupFile != null)
                {
                    ProcessFile(backupFile);
                }
            }
            Task.Delay(5000).Wait();  // 5초마다 디렉토리 확인
        }
    }

    /// <summary>
    /// 첫 실행 시 최근 10개의 파일을 미리 완료 처리
    /// </summary>
    private void ProcessRecentFiles()
    {
        try
        {
            // 파일 목록을 날짜 순으로 정렬하여 최근 10개 파일 가져오기
            var recentFiles = Directory.GetFiles(_inputDirectory, "*.txt")
                                       .OrderByDescending(f => File.GetLastWriteTime(f))
                                       .Take(10);

            foreach (var file in recentFiles)
            {
                // 파일을 백업 폴더로 이동한 후 완료 처리
                var backupFile = MoveFileToBackup(file);
                if (backupFile != null)
                {
                    Console.WriteLine($"Processing recent file (completed): {backupFile}");
                    // 완료 처리를 위한 함수 호출
                    CompleteFile(backupFile);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing recent files: {ex.Message}");
        }
    }

    /// <summary>
    /// 파일을 백업 폴더로 이동
    /// </summary>
    private string MoveFileToBackup(string filePath)
    {
        try
        {
            // 백업 폴더 경로 생성 (yyyyMMdd 형식)
            string backupSubDirectory = Path.Combine(_backupDirectory, DateTime.Now.ToString("yyyyMMdd"));
            if (!Directory.Exists(backupSubDirectory))
            {
                Directory.CreateDirectory(backupSubDirectory);
            }

            // 백업 파일 경로 설정
            string destinationPath = Path.Combine(backupSubDirectory, Path.GetFileName(filePath));

            // 파일 이동
            File.Move(filePath, destinationPath);

            return destinationPath;  // 이동된 파일 경로 반환
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error moving file to backup: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// 이동한 파일을 처리
    /// </summary>
    private void ProcessFile(string filePath)
    {
        try
        {
            // 파일 내용 읽기
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 처리 완료 후 이벤트 발생
            OnLogEntryDetected?.Invoke(logEntry);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 파일을 완료 처리
    /// </summary>
    private void CompleteFile(string filePath)
    {
        try
        {
            // 파일 내용 읽기
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 완료 처리된 파일을 OnLogEntryDetected로 보내지 않고, 자체적으로 완료 처리
            Console.WriteLine($"File {filePath} completed without further processing.");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error completing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 로그 파일의 내용을 파싱하여 LogEntry 객체로 변환
    /// </summary>
    private LogEntry ParseLogEntry(string[] lines)
    {
        // 로그 엔트리 파싱 로직 구현 (필요에 따라 수정)
        var logEntry = new LogEntry
        {
            MAG_NO = ExtractField(lines, "MAG_NO"),
            MAG_QTY = int.Parse(ExtractField(lines, "MAG_QTY")),
            BASIC_MODEL = ExtractField(lines, "BASIC_MODEL"),
            MODEL_CODE = ExtractField(lines, "MODEL_CODE"),
            PO_NO = ExtractField(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(ExtractField(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(ExtractField(lines, "PO_PROD_QTY")),
            SequenceFlag = DetermineSequenceFlag(ExtractField(lines, "PO_PLAN_QTY"), ExtractField(lines, "PO_PROD_QTY"))
        };
        return logEntry;
    }

    /// <summary>
    /// 로그 파일에서 각 필드를 추출하는 도우미 함수
    /// </summary>
    private string ExtractField(string[] lines, string fieldName)
    {
        var line = lines.FirstOrDefault(l => l.StartsWith(fieldName + "="));
        if (line != null)
        {
            return line.Split('=')[1].Trim();
        }
        return string.Empty;
    }

    /// <summary>
    /// 시퀀스 플래그 결정 (첫 파일: 1, 중간 파일: 2, 마지막 파일: 3)
    /// </summary>
    private int DetermineSequenceFlag(string planQty, string prodQty)
    {
        int plan = int.Parse(planQty);
        int prod = int.Parse(prodQty);
        if (prod == 0) return 1;  // 첫 번째 파일
        if (prod < plan) return 2;  // 중간 파일
        if (prod >= plan) return 3;  // 마지막 파일
        return 0;  // 기본값
    }

    /// <summary>
    /// 3개월 이상 지난 백업 파일을 삭제
    /// </summary>
    private void CleanupOldFiles()
    {
        try
        {
            // 3개월 전 날짜 계산
            DateTime thresholdDate = DateTime.Now.AddMonths(-3);

            var directories = Directory.GetDirectories(_backupDirectory);
            foreach (var directory in directories)
            {
                DateTime directoryDate;
                if (DateTime.TryParseExact(Path.GetFileName(directory), "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out directoryDate))
                {
                    // 3개월 이상 된 디렉토리 삭제
                    if (directoryDate < thresholdDate)
                    {
                        Directory.Delete(directory, true);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error cleaning up old files: {ex.Message}");
        }
    }
}
주요 기능 요약:
처음 실행 시 최근 10개 파일 완료 처리:

첫 번째 실행 시에만 최근 10개의 파일을 가져와 ProcessRecentFiles 메서드를 통해 완료 처리하고, 완료된 파일은 CompleteFile 메서드를 통해 따로 처리합니다.
완료 처리된 파일은 처리된 것으로 간주하고, 이후의 파일 처리와는 독립적으로 작동합니다.
새로 들어오는 파일 처리:

이후 새로 들어오는 파일은 기존 로직대로 백업 폴더로 이동한 후, 정상적으로 처리됩니다.
백업 폴더 관리 및 3개월 이상 파일 삭제:

파일을 **백업 폴더(C:\MESPRODFILE_Backup)**로 이동한 후, 3개월 이상 된 파일은 자동으로 삭제됩니다.
추가 설명:
CompleteFile 메서드는 처음 실행 시 가져온 최근 10개의 파일을 완료 처리하기 위해 추가되었습니다.
_isInitialRun 플래그를 통해 첫 실행 시 최근 10개 파일만 처리하고, 그 이후부터는 새로운 파일을 처리하는 방식으로 동작합니다.
이 코드가 파일 처리 및 백업을 효율적으로 수행하며, 사용자 요구에 맞는 초기 파일 완료 처리를 구현합니다.