네, 알겠습니다. 주소1(릴레이 서버)을 통해 주소2(최종 목적지)로 명령을 전달할 때, 이 주소2에 세미콜론(;)으로 구분된 여러 개의 IP 주소를 입력하고, 릴레이 서버가 이 IP 목록에 대해 중복을 제거한 후 순차적으로 명령을 실행하도록 하는 기능이군요. 그리고 저장 시에는 각 IP 주소의 유효성을 검사하고 공백을 제거하는 로직이 필요합니다.

이 기능은 주로 Flask 웹 애플리케이션(SControlM)의 데이터 저장 방식과 SAgentM.App 에이전트의 릴레이 명령 처리 방식을 수정해야 합니다.

단계별 수정 계획:

Flask 웹 앱 (SControlM) 수정:
app/forms.py: TargetPCForm에서 address2 필드의 IP 주소 유효성 검사 방식을 수정합니다 (단일 IP 검사 대신, 라우트에서 다중 IP 파싱 및 검증).
app/routes_admin.py: add_target_pc 및 edit_target_pc 라우트에서 address2에 입력된 세미콜론 구분 IP 문자열을 파싱하고, 각 IP의 유효성을 검사하며, 공백 제거 및 정제 후 다시 세미콜론으로 묶어 DB에 저장하도록 수정합니다.
SAgentM.App 에이전트 수정:
Services/AgentCoreService.cs: RelayCommandAsync 메서드에서 CommandPacket의 FinalTargetIpForRelayedCommand 필드에 전달된 세미콜론 구분 IP 문자열을 파싱하고, 공백 제거 및 중복 IP를 제거한 후, 각 최종 목적지 IP로 실제 명령(DirectExecute)을 순차적으로 전송하도록 수정합니다.
이번 답변에서는 먼저 Flask 웹 애플리케이션(SControlM) 측의 파일 수정부터 진행하겠습니다.

1. 수정: scontrol_flask_web/app/forms.py (전체 파일)
TargetPCForm의 address2 필드에서 IPAddress 유효성 검사기를 제거합니다. (라우트 함수에서 직접 파싱 및 검증 예정)

Python

# scontrol_flask_web/app/forms.py
from flask_wtf import FlaskForm
from wtforms import StringField, TextAreaField, SubmitField, BooleanField, PasswordField, SelectField
from wtforms.fields import DateField 
from wtforms.validators import DataRequired, IPAddress, Optional, Length, ValidationError
import re # IP 유효성 검사를 위해 정규표현식 사용 가능 (또는 ipaddress 모듈)

class TargetPCForm(FlaskForm):
    pc_name = StringField('PC 이름', validators=[DataRequired(), Length(min=1, max=100)])
    address1 = StringField('주소1 (직접 IP 또는 릴레이 서버 IP)', 
                           validators=[DataRequired(), IPAddress(ipv4=True, ipv6=False, message="주소1에 유효한 IPv4 주소를 입력하세요.")])
    # address2는 여러 IP를 세미콜론으로 받을 수 있으므로, 폼 레벨에서의 IPAddress 유효성 검사기는 제거하고 라우트에서 처리
    address2 = StringField('주소2 (최종 목적지 IP 목록 - 세미콜론(;)으로 구분, 비워두면 직접 제어)', 
                           validators=[Optional(), Length(max=1000)]) # 길이 제한 정도만 설정
    description = TextAreaField('설명', validators=[Optional(), Length(max=255)])
    submit = SubmitField('저장')

    # validate_address2는 라우트에서 더 복잡한 로직으로 처리하므로 여기서는 단순화 또는 제거
    # def validate_address2(form, field):
    #     if field.data and not field.data.strip():
    #         field.data = None # 공백만 있으면 None으로
    #     # 개별 IP 유효성 검사는 라우트에서 수행


class AllowedUserIPForm(FlaskForm):
    ip_address = StringField('IP 주소', validators=[DataRequired(), IPAddress(ipv4=True, ipv6=False, message="유효한 IPv4 주소를 입력하세요.")])
    description = TextAreaField('설명', validators=[Optional(), Length(max=255)])
    submit = SubmitField('저장')

class AdminIPForm(FlaskForm):
    ip_address = StringField('관리자 IP 주소', validators=[DataRequired(), IPAddress(ipv4=True, ipv6=False, message="유효한 IPv4 주소를 입력하세요.")])
    description = TextAreaField('설명', validators=[Optional(), Length(max=255)])
    submit = SubmitField('저장')

class WorkCalendarExceptionForm(FlaskForm):
    exception_date = DateField('날짜', validators=[DataRequired(message="날짜를 선택해주세요.")], format='%Y-%m-%d')
    is_operational = SelectField('운영 상태', 
                                 choices=[('1', '가동일 (Operational)'), ('0', '비가동일 (Non-Operational)')], 
                                 validators=[DataRequired(message="운영 상태를 선택해주세요.")], 
                                 coerce=str)
    description = TextAreaField('설명 (예: 임시 공휴일, 특별 근무일)', validators=[Optional(), Length(max=255)])
    submit = SubmitField('예외 날짜 추가')

    def validate_is_operational(form, field):
        if field.data not in ['0', '1']:
            raise ValidationError("유효하지 않은 운영 상태 값입니다.")

forms.py 주요 변경 사항:

TargetPCForm의 address2 필드에서 IPAddress 유효성 검사기를 제거하고 Length 유효성 검사기만 남겼습니다. 여러 IP가 세미콜론으로 구분되어 들어올 것이므로, 개별 IP 유효성 검사는 라우트 함수에서 처리합니다.
2. 수정: scontrol_flask_web/app/routes_admin.py (전체 파일)
add_target_pc와 edit_target_pc 함수에서 address2 필드 처리 로직을 수정합니다. 세미콜론으로 구분된 IP들을 파싱하고, 각 IP의 유효성을 검사하며, 공백 제거 후 다시 세미콜론으로 조합하여 저장합니다.

Python

# scontrol_flask_web/app/routes_admin.py
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app, g
from app.db_utils import get_db_connection
from app.forms import TargetPCForm, AllowedUserIPForm, AdminIPForm, WorkCalendarExceptionForm
from app.auth import ip_auth_required, get_current_user_role
import math
import pymssql
from datetime import datetime as dt_datetime, date, timedelta 
import calendar 
import holidays 
import ipaddress # IP 주소 유효성 검사를 위한 표준 라이브러리

admin_bp = Blueprint('admin', __name__)

# === 유틸리티 함수: IP 주소 유효성 검사 및 정제 ===
def validate_and_clean_ip_list_string(ip_string):
    """
    세미콜론으로 구분된 IP 주소 문자열을 검증하고 정제합니다.
    유효한 IP만 필터링하고, 공백 제거 후 다시 세미콜론으로 조합된 문자열을 반환합니다.
    유효하지 않은 IP가 하나라도 있으면 ValidationError를 발생시킵니다.
    """
    if not ip_string or not ip_string.strip():
        return None # 비어있으면 None 반환

    ips = [ip.strip() for ip in ip_string.split(';') if ip.strip()] # 공백 제거 및 빈 항목 필터링
    if not ips: # 공백과 세미콜론만 있었던 경우
        return None

    valid_ips = []
    for ip_candidate in ips:
        try:
            ipaddress.ip_address(ip_candidate) # IPv4 또는 IPv6 주소 유효성 검사
            # 여기서는 IPv4만 허용한다고 가정하고 추가 검사 가능
            # if not isinstance(ipaddress.ip_address(ip_candidate), ipaddress.IPv4Address):
            #    raise ValidationError(f"주소2 목록의 '{ip_candidate}'는 유효한 IPv4 주소가 아닙니다.")
            valid_ips.append(ip_candidate)
        except ValueError:
            # form.address2.errors.append(...) 방식으로 오류 추가는 라우트에서 직접 처리
            raise ValidationError(f"주소2 목록의 '{ip_candidate}'는 유효한 IP 주소 형식이 아닙니다.")
    
    return ";".join(valid_ips) if valid_ips else None


# === _get_pagination_data 함수는 이전과 동일 ===
def _get_pagination_data(query_count, query_data, page, per_page, params_count=None, params_data=None):
    # ... (이전 답변 #49의 전체 코드와 동일) ...
    total_items = 0; items_on_page = []
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute(query_count, params_count or ())
            count_result = cursor.fetchone()
            if count_result: total_items = count_result.get('total', 0)
            if total_items > 0:
                offset = (page - 1) * per_page
                final_params_data = (params_data or ()) + (offset, per_page)
                cursor.execute(query_data, final_params_data)
                items_on_page = cursor.fetchall()
            else: items_on_page = []
    except Exception as e:
        current_app.logger.error(f"페이지네이션 데이터 조회 오류: {e}", exc_info=True)
        flash("데이터 로드 중 오류.", "error")
        return {'page': 1, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 'items': [], 'has_prev': False, 'has_next': False, 'prev_num': 1, 'next_num': 1}
    total_pages = math.ceil(total_items / per_page) if total_items > 0 else 1
    return {'page': page, 'per_page': per_page, 'total_items': total_items, 'total_pages': total_pages, 'items': items_on_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1, 'next_num': page + 1}


# === 1. 대상 PC 관리 ===
@admin_bp.route('/pcs')
@ip_auth_required('admin')
def manage_target_pcs():
    # ... (이전과 동일) ...
    page = request.args.get('page', 1, type=int); per_page = 10
    q_count = "SELECT COUNT(*) AS total FROM dbo.target_pcs"; q_data = "SELECT id, pc_name, address1, address2, description, created_at, last_modified FROM dbo.target_pcs ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY"
    pagination = _get_pagination_data(q_count, q_data, page, per_page)
    return render_template('admin/manage_target_pcs.html', pcs=pagination['items'], pagination=pagination, title="대상 PC 관리")

@admin_bp.route('/pcs/add', methods=['GET', 'POST'])
@ip_auth_required('admin')
def add_target_pc():
    form = TargetPCForm()
    if form.validate_on_submit():
        cleaned_address2 = None
        try:
            # address2 유효성 검사 및 정제
            cleaned_address2 = validate_and_clean_ip_list_string(form.address2.data)
        except ValidationError as ve:
            flash(str(ve), 'error')
            # 폼에 오류를 추가하려면 form.address2.errors.append(str(ve)) 사용 가능하나,
            # flash로 처리하고 현재 폼을 다시 렌더링하는 것이 간단할 수 있음.
            # 또는 form.address2.errors = [str(ve)] 등으로 설정
            form.address2.errors.append(str(ve)) # 폼 필드에 직접 오류 메시지 추가
            return render_template('admin/edit_target_pc.html', form=form, title="새 PC 추가")

        conn = None
        try:
            conn = get_db_connection()
            with conn.cursor() as cursor:
                sql = "INSERT INTO dbo.target_pcs (pc_name, address1, address2, description) VALUES (%s, %s, %s, %s)"
                cursor.execute(sql, (form.pc_name.data, form.address1.data, cleaned_address2, form.description.data))
            conn.commit()
            flash(f"PC '{form.pc_name.data}' 추가 성공.", 'success')
            return redirect(url_for('admin.manage_target_pcs'))
        except pymssql.IntegrityError as ie: # 중복 등 DB 제약조건 위반
            if conn: conn.rollback()
            msg = f"PC 이름 '{form.pc_name.data}' 중복." if "UNIQUE KEY" in str(ie).upper() or "duplicate key" in str(ie) else f"DB 제약 위반: {str(ie)[:100]}"
            flash(msg, 'error'); current_app.logger.error(f"Add TargetPC IntErr: {ie}", exc_info=False)
        except Exception as e:
            if conn: conn.rollback()
            flash(f"PC 추가 오류: {str(e)[:100]}", 'error'); current_app.logger.error(f"Add TargetPC Err: {e}", exc_info=True)
            
    return render_template('admin/edit_target_pc.html', form=form, title="새 PC 추가")

@admin_bp.route('/pcs/edit/<int:pc_id>', methods=['GET', 'POST'])
@ip_auth_required('admin')
def edit_target_pc(pc_id):
    conn = None; pc_data = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute("SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs WHERE id = %d", (pc_id,))
            pc_data = cursor.fetchone()
    except Exception as e:
        flash("PC 정보 로드 오류.", "error"); current_app.logger.error(f"Edit PC (GET) ID {pc_id} Err: {e}", exc_info=True)
        return redirect(url_for('admin.manage_target_pcs'))
    if not pc_data:
        flash(f"PC ID {pc_id} 없음.", "error"); return redirect(url_for('admin.manage_target_pcs'))

    form = TargetPCForm(data=pc_data) if request.method == 'GET' else TargetPCForm() # GET시 데이터 채움
    
    if form.validate_on_submit():
        cleaned_address2 = None
        try:
            cleaned_address2 = validate_and_clean_ip_list_string(form.address2.data)
        except ValidationError as ve:
            flash(str(ve), 'error')
            form.address2.errors.append(str(ve))
            return render_template('admin/edit_target_pc.html', form=form, title=f"PC 정보 수정: {pc_data['pc_name']}", pc=pc_data)

        try:
            if conn is None or getattr(conn, '_closed', True): conn = get_db_connection()
            with conn.cursor() as cursor:
                sql = "UPDATE dbo.target_pcs SET pc_name = %s, address1 = %s, address2 = %s, description = %s WHERE id = %d"
                cursor.execute(sql, (form.pc_name.data, form.address1.data, cleaned_address2, form.description.data, pc_id))
            conn.commit()
            flash(f"PC '{form.pc_name.data}' 수정 성공.", 'success')
            return redirect(url_for('admin.manage_target_pcs'))
        except pymssql.IntegrityError as ie:
            if conn: conn.rollback()
            msg = f"PC 이름 '{form.pc_name.data}' 중복." if "UNIQUE KEY" in str(ie).upper() or "duplicate key" in str(ie) else f"DB 제약 위반: {str(ie)[:100]}"
            flash(msg, 'error'); current_app.logger.error(f"Edit PC ID {pc_id} IntErr: {ie}", exc_info=False)
        except Exception as e:
            if conn: conn.rollback()
            flash(f"PC 수정 오류: {str(e)[:100]}", 'error'); current_app.logger.error(f"Edit PC ID {pc_id} Err: {e}", exc_info=True)
            
    return render_template('admin/edit_target_pc.html', form=form, title=f"PC 정보 수정: {pc_data['pc_name']}", pc=pc_data)

# ... (delete_target_pc 및 나머지 AllowedUserIP, AdminIP, CalendarException 관리 라우트들은 이전 답변 #49, #50과 동일하게 유지) ...
# (이 부분은 매우 길기 때문에 생략합니다. 이전 답변 #49의 전체 코드를 참조하여 이 파일의 나머지 부분을 구성해주세요.)
# 아래는 달력 예외 관리의 마지막 부분만 예시로 남깁니다.
@admin_bp.route('/calendar_exceptions/delete/<string:date_str>', methods=['POST'])
@ip_auth_required('admin')
def delete_calendar_exception(date_str):
    conn = None; year_to_redirect = dt_datetime.now().year; month_to_redirect = dt_datetime.now().month
    try:
        date_obj = dt_datetime.strptime(date_str, '%Y-%m-%d').date()
        year_to_redirect = date_obj.year; month_to_redirect = date_obj.month
        conn = get_db_connection()
        with conn.cursor() as cursor:
            sql = "DELETE FROM dbo.work_calendar_exceptions WHERE exception_date = %s"; cursor.execute(sql, (date_obj.strftime('%Y-%m-%d'),)); rows_deleted = cursor.rowcount
        conn.commit()
        if rows_deleted > 0: flash(f"날짜 {date_str} 예외 삭제 성공.", 'success')
        else: flash(f"날짜 {date_str} 예외 없음.", 'warning')
    except ValueError: flash(f"잘못된 날짜 형식: {date_str}", 'error'); current_app.logger.warning(f"Invalid date for delete: {date_str}")
    except Exception as e:
        if conn: conn.rollback(); flash(f"예외 날짜 삭제 오류: {e}", 'error'); current_app.logger.error(f"Delete CalendarEx for {date_str} Error: {e}", exc_info=True)
    return redirect(url_for('admin.manage_calendar_exceptions', year=year_to_redirect, month=month_to_redirect))
app/routes_admin.py 주요 변경 사항:

import ipaddress 추가: Python 표준 라이브러리인 ipaddress를 사용하여 IP 주소 유효성을 검사합니다.
validate_and_clean_ip_list_string(ip_string) 헬퍼 함수 신규 추가:
입력된 문자열(예상: address2 필드 값)을 세미콜론(;)으로 분리합니다.
각 분리된 문자열의 앞뒤 공백을 제거합니다.
비어있지 않은 각 문자열에 대해 ipaddress.ip_address()를 사용하여 유효한 IP 주소 형식인지 검사합니다. (IPv4, IPv6 모두 검사. 필요시 ipaddress.IPv4Address 등으로 특정 버전만 검사 가능)
유효하지 않은 IP가 하나라도 있으면 ValidationError를 발생시킵니다.
유효한 IP들만 다시 세미콜론으로 조합하여 반환합니다. 입력이 아예 없거나 공백/세미콜론만 있으면 None을 반환합니다.
add_target_pc 및 edit_target_pc 함수 수정:
form.validate_on_submit() 이후, form.address2.data 값을 validate_and_clean_ip_list_string 함수로 전달하여 유효성 검사 및 정제를 수행합니다.
ValidationError 발생 시, 오류 메시지를 flash로 사용자에게 알리고, 폼의 해당 필드(form.address2.errors)에도 오류를 추가하여 템플릿에 표시되도록 합니다. 그 후 현재 폼을 다시 렌더링합니다.
정제된 cleaned_address2 값을 데이터베이스에 저장합니다.
생략된 코드: delete_target_pc 및 나머지 관리 기능 라우트(AllowedUserIP, AdminIP, CalendarException)는 이전 답변(#49)에서 제공된 pymssql 버전 코드를 그대로 사용하시면 됩니다. 지면 관계상 이 답변에서는 생략했습니다. 만약 routes_admin.py의 완전한 전체 코드가 필요하시면 다시 요청해주세요. 지금은 address2 다중 IP 처리와 관련된 부분만 중점적으로 수정하여 제공했습니다.
위와 같이 app/forms.py와 app/routes_admin.py를 수정하시면, address2 필드에 세미콜론으로 구분된 여러 IP 주소를 입력받고, 저장 시 각 IP의 유효성을 검사하며 공백을 제거하는 기능이 구현됩니다.

다음 단계는 SAgentM.App (C# 에이전트)의 AgentCoreService.cs를 수정하여, CommandPacket의 FinalTargetIpForRelayedCommand 필드에 전달된 이 세미콜론 구분 IP 문자열을 파싱하고, 중복을 제거한 후 각 IP로 순차적으로 명령을 릴레이하도록 하는 것입니다.

SAgentM.App/Services/AgentCoreService.cs 파일 수정을 