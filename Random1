etermineSequenceFlag 메서드를 추가하여 PO_NO가 이전 파일의 PO_NO와 다를 경우, 시퀀스 플래그를 1로 리턴하도록 설정할 수 있습니다. 이를 위해 FileProcessor 클래스에서 마지막 처리된 PO_NO를 저장하고, 이를 기준으로 현재 파일의 PO_NO와 비교하여 플래그를 결정하게 할 수 있습니다.

다음은 이에 대한 구현입니다.

수정된 FileProcessor 코드
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Timers;

public class FileProcessor
{
    private string _networkPath = @"\\10.44.44.44\file_log";  // 네트워크 경로
    private string _localPath = @"C:\prod_file_log";          // 로컬 경로
    private string _backupPath = @"C:\MESPRODFILE_Backup";    // 백업 경로
    private DateTime _lastProcessedTime = DateTime.MinValue;  // 마지막 처리된 파일 시간 기록
    private string _lastPONumber = "";                        // 마지막 처리된 PO_NO
    private Timer _fileCheckTimer;                            // 타이머 객체

    public FileProcessor()
    {
        // 로컬 및 백업 디렉터리 존재 여부 확인 후 없으면 생성
        EnsureDirectoryExists(_localPath);
        EnsureDirectoryExists(_backupPath);

        // 5초마다 새로 생성된 파일이 있는지 체크하는 타이머 설정
        _fileCheckTimer = new Timer(5000); // 5초
        _fileCheckTimer.Elapsed += OnTimedEvent;
        _fileCheckTimer.AutoReset = true;
        _fileCheckTimer.Enabled = true;  // 타이머 시작
    }

    /// <summary>
    /// 디렉토리의 존재 여부를 확인하고 없으면 생성하는 함수
    /// </summary>
    /// <param name="path">생성할 디렉토리 경로</param>
    private void EnsureDirectoryExists(string path)
    {
        if (!Directory.Exists(path))
        {
            Directory.CreateDirectory(path);
        }
    }

    /// <summary>
    /// 타이머가 5초마다 호출하는 이벤트 핸들러. 새로 생성된 파일을 체크합니다.
    /// </summary>
    private void OnTimedEvent(Object source, ElapsedEventArgs e)
    {
        // 새로 생성된 파일이 있는지 확인하고 처리
        ProcessFilesFromNetwork().Wait(); 
    }

    /// <summary>
    /// 네트워크 경로에서 파일을 로컬 경로로 안전하게 복사한 후 처리 및 삭제
    /// </summary>
    public async Task ProcessFilesFromNetwork()
    {
        // 네트워크 경로에서 모든 파일을 가져옴
        var files = Directory.GetFiles(_networkPath);

        // 각 파일을 로컬로 복사한 후 처리
        foreach (var file in files)
        {
            string fileName = Path.GetFileName(file);
            string localFile = Path.Combine(_localPath, fileName);

            // 파일이 다 쓰여졌는지 확인
            if (IsFileReady(file))
            {
                // 네트워크에서 로컬로 파일 복사
                File.Copy(file, localFile, true);  // 파일 덮어쓰기 허용

                // 파일을 로컬에서 처리
                await ProcessFile(localFile);

                // 처리 후 파일을 백업 경로로 이동
                MoveFileToBackup(localFile);

                // 네트워크 경로의 파일 삭제
                DeleteNetworkFile(file);
            }
        }
    }

    /// <summary>
    /// 파일이 다 쓰여졌는지 확인하는 함수
    /// </summary>
    /// <param name="filePath">확인할 파일 경로</param>
    /// <returns>파일이 준비되었는지 여부</returns>
    private bool IsFileReady(string filePath)
    {
        try
        {
            using (FileStream inputStream = File.Open(filePath, FileMode.Open, FileAccess.Read, FileShare.None))
            {
                return inputStream.Length > 0;  // 파일 크기가 0보다 크면 읽기 가능
            }
        }
        catch (IOException)
        {
            // 파일이 잠겨 있거나 접근할 수 없으면 아직 준비되지 않음
            return false;
        }
    }

    /// <summary>
    /// 파일을 로컬에서 처리하는 함수
    /// PO_NO에 따라 시퀀스 플래그를 결정합니다.
    /// </summary>
    private async Task ProcessFile(string filePath)
    {
        // 파일 처리 로직 (파일 내용 읽기, 분석 등)
        Console.WriteLine($"Processing file: {filePath}");

        // 파일 내용 읽기 (예시로 파일에서 PO_NO를 추출하는 로직)
        string[] lines = await File.ReadAllLinesAsync(filePath);
        string poNo = ExtractPONumber(lines);

        // 시퀀스 플래그 결정
        int sequenceFlag = DetermineSequenceFlag(poNo);
        Console.WriteLine($"PO_NO: {poNo}, SequenceFlag: {sequenceFlag}");

        // 마지막 처리된 PO_NO 업데이트
        _lastPONumber = poNo;
    }

    /// <summary>
    /// 파일에서 PO_NO를 추출하는 함수
    /// (실제 파일 포맷에 맞게 수정 필요)
    /// </summary>
    private string ExtractPONumber(string[] lines)
    {
        // 파일의 첫 줄이 PO_NO라고 가정
        return lines.FirstOrDefault()?.Split('=')[1].Trim();
    }

    /// <summary>
    /// PO_NO에 따라 시퀀스 플래그를 결정하는 함수
    /// 1: 새로 시작된 PO_NO
    /// 2: 기존 PO_NO의 중간 파일
    /// </summary>
    private int DetermineSequenceFlag(string poNo)
    {
        if (poNo != _lastPONumber)
        {
            return 1;  // 새로 시작된 PO_NO일 경우 시퀀스 플래그 1
        }
        else
        {
            return 2;  // 동일한 PO_NO일 경우 시퀀스 플래그 2
        }
    }

    /// <summary>
    /// 파일을 백업 폴더로 이동하는 함수 (날짜별로 폴더 생성)
    /// </summary>
    /// <param name="filePath">백업할 파일 경로</param>
    private void MoveFileToBackup(string filePath)
    {
        // 백업 폴더에 날짜별 폴더 생성
        string dateFolder = DateTime.Now.ToString("yyyyMMdd");
        string backupFolder = Path.Combine(_backupPath, dateFolder);

        // 백업 디렉터리 생성 (날짜별로)
        EnsureDirectoryExists(backupFolder);

        // 원본 파일명 가져오기
        string fileName = Path.GetFileName(filePath);

        // 백업 경로 설정
        string backupFilePath = Path.Combine(backupFolder, fileName);

        // 파일 이동 (백업 경로로)
        File.Move(filePath, backupFilePath);
    }

    /// <summary>
    /// 네트워크 경로에서 파일을 삭제하는 함수
    /// </summary>
    /// <param name="filePath">삭제할 네트워크 파일 경로</param>
    private void DeleteNetworkFile(string filePath)
    {
        try
        {
            File.Delete(filePath);  // 네트워크 경로에서 파일 삭제
            Console.WriteLine($"File deleted from network path: {filePath}");
        }
        catch (IOException ex)
        {
            Console.WriteLine($"Error deleting file from network path: {ex.Message}");
        }
    }

    /// <summary>
    /// 백업된 파일 중 3개월 이상 된 파일을 삭제하는 함수
    /// </summary>
    public void DeleteOldBackupFiles()
    {
        // 백업 디렉터리에서 날짜별 폴더 확인
        var directories = Directory.GetDirectories(_backupPath);

        foreach (var dir in directories)
        {
            // 폴더명을 날짜로 변환하여 3개월 이전의 폴더는 삭제
            string folderName = Path.GetFileName(dir);
            if (DateTime.TryParseExact(folderName, "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out DateTime folderDate))
            {
                if (folderDate < DateTime.Now.AddMonths(-3))
                {
                    Directory.Delete(dir, true);  // 폴더 및 하위 파일 삭제
                }
            }
        }
    }
}
주요 변경 사항 설명
PO_NO 비교:

DetermineSequenceFlag 함수에서 이전에 처리된 PO_NO를 저장한 _lastPONumber와 현재 파일의 PO_NO를 비교하여 새롭게 시작된 PO_NO일 경우 시퀀스 플래그를 1로 반환하도록 수정하였습니다.
동일한 PO_NO일 경우에는 시퀀스 플래그를 2로 반환합니다.
_lastPONumber:

이전에 처리한 파일의 PO_NO를 저장하기 위해 _lastPONumber 변수를 사용합니다. 각 파일을 처리할 때마다 _lastPONumber를 갱신하여 다음 파일과 비교할 수 있도록 했습니다.
파일 처리: