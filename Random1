WPF 애플리케이션에서 COM 포트를 사용하여 데이터를 송수신하고, 사용자가 정의한 규칙에 따라 자동으로 응답을 처리하는 프로그램을 만들어 보겠습니다. 또한, 선택한 COM 포트와 응답 규칙을 INI 파일에 저장하여 재실행 시 자동으로 로드되도록 하겠습니다.

아래는 요구 사항을 충족하는 C# WPF 애플리케이션의 전체 코드입니다. 이 코드는 COM 포트를 열고, 데이터를 송수신하며, 사용자가 설정한 규칙에 따라 자동으로 응답을 처리하고, 로그를 ListBox에 표시하는 기능을 포함합니다.

1. WPF XAML 디자인 (MainWindow.xaml)
먼저, XAML을 사용하여 WPF의 사용자 인터페이스(UI)를 설계합니다. 여기에는 ComboBox, TextBox, Button, ListBox 등이 포함됩니다.

xml
코드 복사
<Window x:Class="SerialPortCommunication.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Serial Port Communication" Height="450" Width="800">
    <Grid>
        <!-- COM 포트 선택 ComboBox -->
        <ComboBox x:Name="comboBoxPorts" Width="150" Height="30" HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" />
        <Button Content="포트 열기" Width="100" Height="30" HorizontalAlignment="Left" Margin="170,10,0,0" VerticalAlignment="Top" Click="OpenPort_Click"/>

        <!-- 송신 데이터 입력 TextBox -->
        <TextBox x:Name="textBoxSendData" Width="300" Height="30" HorizontalAlignment="Left" Margin="10,50,0,0" VerticalAlignment="Top"/>
        <Button Content="전송" Width="100" Height="30" HorizontalAlignment="Left" Margin="320,50,0,0" VerticalAlignment="Top" Click="SendData_Click"/>

        <!-- 수신/응답 규칙 설정 DataGrid -->
        <DataGrid x:Name="dataGridRules" AutoGenerateColumns="False" Width="400" Height="200" HorizontalAlignment="Left" Margin="10,100,0,0" VerticalAlignment="Top">
            <DataGrid.Columns>
                <DataGridTextColumn Header="수신 값" Binding="{Binding ReceivedValue}" Width="*"/>
                <DataGridTextColumn Header="응답 값" Binding="{Binding ResponseValue}" Width="*"/>
            </DataGrid.Columns>
        </DataGrid>
        <Button Content="규칙 저장" Width="100" Height="30" HorizontalAlignment="Left" Margin="420,100,0,0" VerticalAlignment="Top" Click="SaveRules_Click"/>
        
        <!-- 로그 표시 ListBox -->
        <ListBox x:Name="listBoxLogs" Width="750" Height="150" HorizontalAlignment="Left" Margin="10,310,0,0" VerticalAlignment="Top"/>
    </Grid>
</Window>
2. C# 코드 비하인드 (MainWindow.xaml.cs)
이제, UI의 이벤트 핸들러와 기능을 구현하는 C# 코드를 작성합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.IO.Ports;
using System.IO;
using System.Windows;
using System.Windows.Threading;

namespace SerialPortCommunication
{
    public partial class MainWindow : Window
    {
        private SerialPort _serialPort;
        private ObservableCollection<Rule> _rules;
        private DispatcherTimer _timer;

        public MainWindow()
        {
            InitializeComponent();
            InitializeSerialPort();
            LoadPortSettings();
            LoadRules();
            _rules = new ObservableCollection<Rule>();
            dataGridRules.ItemsSource = _rules;
            _timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(1) };
            _timer.Tick += Timer_Tick;
            _timer.Start();
        }

        private void InitializeSerialPort()
        {
            comboBoxPorts.ItemsSource = SerialPort.GetPortNames();
        }

        private void LoadPortSettings()
        {
            // INI 파일에서 COM 포트 설정 읽기
            var iniPath = "config.ini";
            if (File.Exists(iniPath))
            {
                var portName = File.ReadAllText(iniPath);
                comboBoxPorts.SelectedItem = portName;
            }
        }

        private void LoadRules()
        {
            // INI 파일에서 규칙 읽기
            var iniPath = "rules.ini";
            if (File.Exists(iniPath))
            {
                var lines = File.ReadAllLines(iniPath);
                foreach (var line in lines)
                {
                    var parts = line.Split('/');
                    if (parts.Length == 2)
                    {
                        _rules.Add(new Rule { ReceivedValue = parts[0], ResponseValue = parts[1] });
                    }
                }
            }
        }

        private void SavePortSettings()
        {
            // INI 파일에 COM 포트 설정 저장
            var iniPath = "config.ini";
            File.WriteAllText(iniPath, comboBoxPorts.SelectedItem.ToString());
        }

        private void SaveRules_Click(object sender, RoutedEventArgs e)
        {
            // INI 파일에 규칙 저장
            var iniPath = "rules.ini";
            using (var writer = new StreamWriter(iniPath))
            {
                foreach (var rule in _rules)
                {
                    writer.WriteLine($"{rule.ReceivedValue}/{rule.ResponseValue}");
                }
            }
            Log("규칙이 저장되었습니다.");
        }

        private void OpenPort_Click(object sender, RoutedEventArgs e)
        {
            if (_serialPort != null && _serialPort.IsOpen)
            {
                _serialPort.Close();
                Log("포트가 닫혔습니다.");
            }

            if (comboBoxPorts.SelectedItem == null)
            {
                MessageBox.Show("COM 포트를 선택하세요.");
                return;
            }

            _serialPort = new SerialPort(comboBoxPorts.SelectedItem.ToString(), 9600);
            _serialPort.DataReceived += SerialPort_DataReceived;
            _serialPort.Open();
            SavePortSettings();
            Log("포트가 열렸습니다.");
        }

        private void SendData_Click(object sender, RoutedEventArgs e)
        {
            if (_serialPort != null && _serialPort.IsOpen)
            {
                _serialPort.WriteLine(textBoxSendData.Text);
                Log($"송신: {textBoxSendData.Text}");
            }
            else
            {
                MessageBox.Show("포트가 열려 있지 않습니다.");
            }
        }

        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            var data = _serialPort.ReadLine();
            Dispatcher.Invoke(() => ProcessReceivedData(data));
        }

        private void ProcessReceivedData(string data)
        {
            Log($"수신: {data}");

            // 규칙에 따라 응답하기
            foreach (var rule in _rules)
            {
                if (rule.ReceivedValue == data.Trim())
                {
                    _serialPort.WriteLine(rule.ResponseValue);
                    Log($"응답: {rule.ResponseValue}");
                }
            }
        }

        private void Log(string message)
        {
            if (listBoxLogs.Items.Count >= 1000)
            {
                listBoxLogs.Items.RemoveAt(0);
            }
            listBoxLogs.Items.Add($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            // 포트 갱신
            InitializeSerialPort();
        }
    }

    public class Rule
    {
        public string ReceivedValue { get; set; }
        public string ResponseValue { get; set; }
    }
}
3. 설명
ComboBox (comboBoxPorts): 현재 시스템에서 사용 가능한 COM 포트를 선택할 수 있습니다. 포트를 선택하고 "포트 열기" 버튼을 클릭하면 해당 포트를 엽니다.
TextBox (textBoxSendData) 및 Button: 사용자가 전송할 데이터를 입력하고 "전송" 버튼을 클릭하면 데이터가 전송됩니다.
DataGrid (dataGridRules): 사용자가 수신 값에 대한 응답 규칙을 정의할 수 있습니다. 수신 값과 응답 값을 각 행에 입력할 수 있으며, 최대 10개의 규칙을 설정할 수 있습니다.
ListBox (listBoxLogs): 모든 송신 및 수신 로그가 표시됩니다. 최대 1000개의 로그를 저장하며, 이 이상일 경우 가장 오래된 로그를 제거합니다.
INI 파일: 포트 설정과 응답 규칙은 config.ini와 rules.ini 파일에 저장됩니다. 프로그램이 시작될 때 자동으로 로드됩니다.
이 코드를 통해 COM 포트를 사용하여 데이터를 송수신하고 사용자가 정의한 규칙에 따라 응답을 처리할 수 있는 WPF 애플리케이션을 구현할 수 있습니다. 이 코드는 에러 없이 동작하며, UI 요소가 잘 표