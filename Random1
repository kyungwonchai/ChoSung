주소법(Open Addressing)에서 값을 찾는 원리는 충돌 발생 시 저장된 탐색 순서를 그대로 따라가며 데이터를 검색하는 방식입니다. 기본적으로 해시 충돌이 발생했을 때, 데이터를 삽입할 때와 동일한 규칙으로 탐색하면 값을 찾을 수 있습니다.

🔹 개방 주소법의 검색 원리
1️⃣ 기본적인 탐색 과정
해시 함수를 사용해 기본적인 **해시 인덱스(hash index)**를 찾음.
해당 인덱스에 값이 존재하는지 확인.
만약 찾는 값이 없고, 해당 인덱스에 다른 값이 있다면(충돌 발생), 충돌 해결 방식(선형 탐색, 이차 탐색, 이중 해싱 등)에 따라 다음 위치를 순차적으로 검사.
빈 슬롯(empty slot)을 만나면 탐색 종료(해당 값이 존재하지 않음).
🔹 개방 주소법의 탐색 구현
✅ 1. 선형 탐색(Linear Probing)
🔹 탐색 방법:

𝑖
𝑛
𝑑
𝑒
𝑥
=
hash
(
𝑘
𝑒
𝑦
)
index=hash(key)
충돌 발생 시 
𝑖
𝑛
𝑑
𝑒
𝑥
=
(
𝑖
𝑛
𝑑
𝑒
𝑥
+
1
)
m
o
d
 
 
TABLE_SIZE
index=(index+1)modTABLE_SIZE 방식으로 탐색.
빈 슬롯을 만나면 값이 없는 것으로 판단.
cpp
코드 복사
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0}; // 0을 빈 슬롯으로 가정

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    void insert(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) { // 충돌 발생 시 다음 슬롯 탐색
            index = (index + 1) % TABLE_SIZE;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) { // 빈 슬롯 만나면 탐색 종료
            if (table[index] == key) return true;
            index = (index + 1) % TABLE_SIZE;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
✅ 선형 탐색의 특징

캐시 효율이 좋지만, 충돌이 많아질 경우 클러스터링 문제가 발생.
연속된 슬롯이 차면 탐색 시간이 길어질 수 있음.
✅ 2. 이차 탐색(Quadratic Probing)
🔹 탐색 방법:

𝑖
𝑛
𝑑
𝑒
𝑥
=
hash
(
𝑘
𝑒
𝑦
)
index=hash(key)
충돌 발생 시 
𝑖
𝑛
𝑑
𝑒
𝑥
=
(
𝑖
𝑛
𝑑
𝑒
𝑥
+
𝑖
2
)
m
o
d
 
 
TABLE_SIZE
index=(index+i 
2
 )modTABLE_SIZE 방식으로 점프하며 탐색.
cpp
코드 복사
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0};

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    void insert(int key) {
        int index = hashFunction(key);
        int i = 1;
        while (table[index] != 0) { // 충돌 시 이차 탐색
            index = (index + i * i) % TABLE_SIZE;
            i++;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction(key);
        int i = 1;
        while (table[index] != 0) {
            if (table[index] == key) return true;
            index = (index + i * i) % TABLE_SIZE;
            i++;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
✅ 이차 탐색의 특징

선형 탐색보다 충돌 회피가 뛰어나 클러스터링 문제 감소.
하지만, 해시 테이블이 꽉 차면 무한 루프에 빠질 수도 있음.
✅ 3. 이중 해싱(Double Hashing)
🔹 탐색 방법:

기본 해시 함수 
ℎ
1
(
𝑘
𝑒
𝑦
)
=
𝑘
𝑒
𝑦
m
o
d
 
 
𝑇
𝐴
𝐵
𝐿
𝐸
_
𝑆
𝐼
𝑍
𝐸
h1(key)=keymodTABLE_SIZE.
충돌 발생 시 **
ℎ
2
(
𝑘
𝑒
𝑦
)
=
7
−
(
𝑘
𝑒
𝑦
m
o
d
 
 
7
)
h2(key)=7−(keymod7)**을 사용하여 새로운 인덱스를 계산.
새로운 인덱스: 
𝑖
𝑛
𝑑
𝑒
𝑥
=
(
ℎ
1
(
𝑘
𝑒
𝑦
)
+
𝑖
×
ℎ
2
(
𝑘
𝑒
𝑦
)
)
m
o
d
 
 
𝑇
𝐴
𝐵
𝐿
𝐸
_
𝑆
𝐼
𝑍
𝐸
index=(h1(key)+i×h2(key))modTABLE_SIZE.
cpp
코드 복사
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0};

    int hashFunction1(int key) {
        return key % TABLE_SIZE;
    }

    int hashFunction2(int key) {
        return 7 - (key % 7); // 두 번째 해시 함수
    }

public:
    void insert(int key) {
        int index = hashFunction1(key);
        int step = hashFunction2(key);
        int i = 0;
        while (table[index] != 0) { // 충돌 시 이중 해싱 적용
            index = (index + step) % TABLE_SIZE;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction1(key);
        int step = hashFunction2(key);
        while (table[index] != 0) {
            if (table[index] == key) return true;
            index = (index + step) % TABLE_SIZE;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
✅ 이중 해싱의 특징

충돌 발생 시 해시 값을 크게 이동하므로 클러스터링 최소화.
가장 충돌 방지 효과가 크지만, 연산량이 많음.
🔹 결론
방법	장점	단점	적절한 상황
선형 탐색(Linear Probing)	간단하고 캐시 효율 높음	1차 클러스터링 문제 발생	충돌이 적을 때
이차 탐색(Quadratic Probing)	클러스터링 감소	탐색 범위 제한	적당한 충돌 허용 가능할 때
이중 해싱(Double Hashing)	충돌 방지 효과 큼	연산량 증가	충돌이 많을 때
💡 추천:

충돌이 적다면? → 선형 탐색
적당한 성능 + 충돌 방지 → 이차 탐색
충돌이 많다면? → 이중 해싱