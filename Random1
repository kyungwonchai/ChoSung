네, 알겠습니다. 사용자의 의도를 명확히 파악했습니다. 제가 AI CLI 도구 역할을 하는 것이 아니라, **사용자께서 AI CLI 도구에 직접 내릴 수 있는, 기계가 이해하기 쉬운 프롬프트(명령어 스크립트)**를 작성해 드리겠습니다.

설명조의 말투를 완전히 제거하고, 작업 지시서(Instruction Script) 형식으로 구성했습니다.

[AI-CLI 자동 리팩토링 작업 스크립트 V1.0]
[BEGIN SCRIPT]

# 목표 (Primary Objective)
지정된 C# 솔루션(.sln)을 대상으로 코드 리팩토링 및 빌드 자동화를 수행한다. 최종 목표는 모든 요구사항이 반영된, 빌드 에러가 없는 안정적인 실행 파일을 생성하는 것이다.

# 1. 초기 설정 (Initialization)

입력 소스: {SOLUTION_PATH}

작업을 수행할 Visual Studio 솔루션 파일의 전체 경로를 이 변수 위치에서 받는다.
프로젝트 분석 (Analyze Project):

제공된 솔루션 파일(.sln)과 포함된 모든 프로젝트 파일(.csproj)을 분석한다.
원본 .NET Framework 버전을 감지하고, 모든 리팩토링 및 빌드 과정에서 해당 버전을 엄격히 준수한다.
솔루션에 설정된 기존 빌드 구성(Debug/Release)을 파악한다.
안전 백업 (Safety Backup):

작업 시작 전, {SOLUTION_PATH}의 최상위 폴더 전체를 압축하여 원본 상태의 백업 파일을 생성한다.
백업 파일명: {SolutionName}_backup_{yyyyMMddHHmmss}.zip
# 2. 핵심 리팩토링 지시사항 (Core Refactoring Directives)

다음 지침에 따라 코드를 수정한다. 모든 수정은 상호 의존성을 고려하여 진행한다.

안정성 및 최적화 (Stability & Optimization):

메모리 누수 방지: IDisposable 인터페이스를 구현한 객체가 using 문이나 try-finally 블록 내에서 Dispose()가 호출되도록 보장한다. 이벤트 핸들러의 구독 해제가 누락된 부분을 찾아 수정한다.
CPU 부하 감소: 불필요한 루프, 비효율적인 알고리즘, 과도한 동기 처리 로직을 찾아 최적화한다. UI 스레드를 차단하는 긴 작업을 async/await를 사용하여 비동기 처리로 전환한다.
GDI/핸들 누수 방지: WinForms/WPF에서 System.Drawing 객체(Brush, Pen, Font 등)나 기타 핸들 객체 사용 후 명시적으로 해제하도록 코드를 수정한다.
네트워크 부하 예방: 불필요한 네트워크 호출을 최소화하고, 적절한 캐싱 전략을 적용할 수 있는 부분을 찾아 수정한다.
코드 구조 개선 (Code Structure Improvement):

파일 분리: 단일 파일에 과도하게 많은 클래스나 코드가 집중된 경우(Monolithic file), 논리적 단위(클래스, 기능)에 따라 파일을 분리한다.
SOLID 원칙 적용: 코드 전체에 단일 책임 원칙(SRP), 개방-폐쇄 원칙(OCP) 등을 적용하여 재사용성과 유지보수성을 향상시킨다.
디자인 패턴 도입: 코드의 맥락을 분석하여 싱글톤, 팩토리, 옵저버 등 적절하다고 판단되는 디자인 패턴을 적용한다.
절차적 코드 리팩토링: 하나의 메서드에 모든 기능이 나열된 절차적 코드를 더 작은 비공개 메서드(private method)와 명확한 역할을 가진 클래스로 분리한다.
# 3. 중요 제약 조건 (Critical Constraint)

하드코딩된 자격 증명(Credential) 절대 불변:
어떠한 경우에도 데이터베이스 연결 문자열(Connection String)이나 소스코드 내에 하드코딩된 비밀번호, API 키 등 민감한 정보는 수정하거나 변경을 시도해서는 안 된다.
"Password=", "Pwd=", "connectionString" 등과 같은 패턴의 문자열 리터럴을 식별하고 해당 라인은 리팩토링 대상에서 영구적으로 제외한다.
# 4. 반복 빌드 및 검증 루프 (Iterative Build & Verification Loop)

루프 조건: 최대 50회 시도하거나, 빌드가 성공할 때까지 아래 과정을 반복한다.
프로세스: a. 리팩토링 지시사항(#2)에 따라 코드 수정을 1회 적용한다. b. 빌드 실행: 분석된(#1.2) 빌드 구성을 사용하여 솔루션 전체 빌드를 명령줄(command line)에서 실행한다. c. 로그 리디렉션: 빌드 과정에서 발생하는 모든 출력(표준 출력, 표준 에러)을 임시 텍스트 파일(예: build_output.txt)로 리디렉션한다. d. 로그 분석: build_output.txt 파일의 내용을 분석하여 'Error' 또는 '오류' 키워드를 찾는다. e. 분기 처리: * 빌드 실패 시: 로그에 기록된 에러의 원인을 파악하고, 해당 에러를 해결하기 위한 코드 수정을 적용한 후 루프의 처음(a)으로 돌아간다. * 빌드 성공 시: 루프를 즉시 종료하고 #5 단계로 넘어간다.
# 5. 최종 변경 이력 로깅 (Final Change Logging)

로그 디렉토리: D:\refactoringhistory\ 경로를 확인하고, 없으면 생성한다. 그 안에 솔루션 이름과 동일한 폴더({SolutionFolderName})를 확인하고, 없으면 생성한다.
로그 파일 생성: 위 경로에 다음 형식으로 로그 파일을 생성한다.
{SolutionName}_{yyyyMMddHHmmss}.txt
로그 내용 기록:
해당 파일에 지금까지의 모든 코드 수정 내역을 기록한다.
각 수정 사항은 어떤 파일의 어느 부분이 어떻게 변경되었는지 명확하게 알 수 있도록 'Before'와 'After' 형식으로 기재해야 한다.
예시:
File: Services/DataService.cs
Reason: Memory Leak Prevention
--- BEFORE ---
public Bitmap ProcessImage(string path)
{
    var image = new Bitmap(path);
    // ... processing
    return image; // Dispose() not called
}
--- AFTER ---
public Bitmap ProcessImage(string path)
{
    using(var image = new Bitmap(path))
    {
        // ... processing
        return (Bitmap)image.Clone(); // Return a copy, original will be disposed
    }
}
[END SCRIPT]