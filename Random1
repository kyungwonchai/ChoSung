습니다! ConcurrentQueue를 사용하여 기존의 TaskQueue를 개선하겠습니다. 아래는 기존의 TaskQueue에서 ConcurrentQueue를 사용하도록 수정한 코드입니다.

1. TaskQueue.cs 수정된 코드
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

public class TaskQueue
{
    // Queue 대신 ConcurrentQueue 사용
    private ConcurrentQueue<Func<Task>> _tasks = new ConcurrentQueue<Func<Task>>();
    private bool _isRunning = false;  // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;   // 작업이 일시정지 상태인지 여부

    public bool IsRunning => _isRunning;
    public bool IsPaused => _isPaused;

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        if (!_isRunning && !_isPaused)
        {
            RunNextTask();  // 현재 실행 중이 아니면 즉시 실행
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.IsEmpty || _isPaused)  // 큐에 작업이 없거나 일시정지 상태면 리턴
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;

        if (_tasks.TryDequeue(out var task))  // 작업 가져오기
        {
            await task();  // 작업 실행
        }

        _isRunning = false;

        // 다음 작업 실행 (일시정지 상태가 아니라면)
        if (!_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// 현재 작업이 완료된 후 다음 작업을 멈추도록 합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;  // 작업 일시정지 상태로 변경
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;  // 일시정지 해제
            if (!_isRunning)
            {
                RunNextTask();  // 작업이 실행 중이 아니면 다음 작업 실행
            }
        }
    }

    /// <summary>
    /// 남은 작업을 모두 비웁니다.
    /// </summary>
    public void ClearQueue()
    {
        // 큐에서 남은 작업을 비움
        while (_tasks.TryDequeue(out _)) { }
    }
}
주요 변경 사항:
ConcurrentQueue<Func<Task>> _tasks:

기존의 **Queue**를 **ConcurrentQueue**로 변경하여 멀티 스레드 환경에서의 안전성을 보장합니다.
_tasks.TryDequeue(out var task):

ConcurrentQueue는 잠금 없이 안전하게 작업을 제거할 수 있습니다. **TryDequeue**를 사용하여 큐에서 작업을 안전하게 꺼냅니다.
ClearQueue():

큐에 남아있는 작업을 모두 비우는 메서드 추가. 남은 작업을 순차적으로 제거하여 작업 큐를 비울 수 있습니다.
2. TaskModel.cs는 수정 필요 없음:
TaskQueue가 내부적으로 처리되기 때문에, TaskModel.cs는 변경할 필요가 없습니다. 기존의 방식대로 작업 큐에 작업을 추가하고 순차적으로 실행되는 구조는 그대로 유지됩니다.

3. 전체적인 동작 설명:
작업 추가:

새로운 작업이 추가되면 **EnqueueTask**를 통해 ConcurrentQueue에 작업을 추가합니다. 현재 작업이 실행 중이 아니면 바로 실행됩니다.
작업 실행:

RunNextTask 메서드는 비동기 작업을 순차적으로 처리하며, 작업이 완료되면 큐에서 다음 작업을 실행합니다.
일시정지 상태가 아니면, 모든 작업은 순차적으로 실행됩니다.
일시정지 및 재개:

Pause 메서드를 통해 작업이 진행 중이던 작업까지만 완료하고 다음 작업은 대기 상태로 들어갑니다.
Resume 메서드를 통해 작업이 재개되면, 다음 작업부터 다시 실행됩니다.
큐 비우기:

ClearQueue 메서드를 통해 큐에 남아있는 작업을 모두 비울 수 있습니다.
4. ConcurrentQueue를 적용했을 때의 장점:
스레드 안전성: ConcurrentQueue는 멀티 스레드에서 안전하게 사용할 수 있기 때문에, PLC 통신에서 여러 작업을 동시에 추가하거나 실행할 때에도 문제가 발생하지 않습니다.
성능: ConcurrentQueue는 잠금을 사용하지 않기 때문에 경쟁 상태 없이 빠르게 처리할 수 있습니다.
비동기 작업 관리: PLC와 같은 순차적인 작업을 처리하는 환경에서 작업이 차례로 큐에서 빠져나가며 실행되는 방식이 유지됩니다.
이제 이 구조를 통해 멀티 스레드 환경에서도 안전하게 작업을 처리할 수 있으며, PLC 통신에서 신호 처리를 더욱 원활하게 진행할 수 있습