네, 두 가지 질문 모두 아주 좋은 포인트입니다! 하나씩 상세하게 설명해 드릴게요.

1. JsonReader.setLenient(true) 에러의 의미
이 에러는 "서버가 보낸 응답 메시지가 표준 JSON 형식이 아니지만, 일단 너그럽게(Lenient) 처리해서 앱이 죽지는 않았어" 라는 일종의 경고입니다.

상황을 쉽게 비유하자면:

앱 → 서버 (성공): 앱이 조도 값({"lux": 123.4})이라는 **'소포'**를 서버에 완벽하게 보냈습니다.

서버 (성공): 서버는 소포를 잘 받아서 내용물을 DB에 성공적으로 저장했습니다. (그래서 DB에는 데이터가 잘 올라갑니다.)

서버 → 앱 (문제 발생): 서버가 앱에게 "잘 받았어!"라는 의미로 '데이터 저장 성공' 이라는 **'엽서(일반 텍스트)'**를 보냈습니다.

앱 (경고): 그런데 앱은 원래 **'소포(JSON 형식)'**로 답장을 받기로 약속되어 있었습니다. 갑자기 엽서가 오니 당황해서 "어? 이거 약속된 형식이 아닌데? 일단 내용은 알겠으니 넘어가지만, 이거 문제 있는 거야!" 라고 Logcat에 경고 메시지를 남기는 것입니다.

결론: 데이터 전송과 DB 저장은 완벽하게 성공했지만, 서버의 성공 응답 메시지 형식이 앱의 기대와 달라서 발생하는 문제입니다. 앱 동작 자체에는 문제가 없지만, 찝찝한 경고 메시지이므로 수정하는 것이 좋습니다.

가장 쉬운 해결책 (안드로이드 코드 수정):
서버가 보내는 '엽서(일반 텍스트)'를 처리할 수 있는 전용 라이브러리로 교체하면 됩니다.

파일 위치: build.gradle.kts (Module :app)

수정 방법: dependencies { ... } 블록에 아래 한 줄을 추가하고, 기존 converter-gson은 그대로 두거나 삭제해도 됩니다.

Kotlin

// ... 기존 dependencies ...

// 일반 텍스트(String) 응답을 처리하기 위한 라이브러리
implementation("com.squareup.retrofit2:converter-scalars:2.9.0")

// 기존 Gson 컨버터 (JSON을 보낼 때 필요하므로 그대로 두는 것이 좋습니다)
implementation("com.squareup.retrofit2:converter-gson:2.9.0")
파일 위치: MainActivity.kt

수정 방법: setupNetwork() 함수에서 Retrofit.Builder() 부분을 아래와 같이 수정합니다. ScalarsConverterFactory를 먼저 추가하는 것이 중요합니다.

Kotlin

private fun setupNetwork() {
    val retrofit = Retrofit.Builder()
        .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/")
        // 1. 일반 텍스트 변환기를 먼저 추가
        .addConverterFactory(ScalarsConverterFactory.create())
        // 2. JSON 변환기는 그 다음에 추가
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    apiService = retrofit.create(ApiService::class.java)
}
수정 후에는 반드시 **Sync Now**를 눌러주세요. 이제 경고 메시지가 깨끗하게 사라질 겁니다.

2. 화면이 꺼져도 계속 전송되게 하는 방법 (화면 계속 켜기)
말씀하신 대로, 안드로이드폰은 배터리를 아끼기 위해 화면이 꺼지면 CPU와 센서, 네트워크 사용을 제한합니다. 그래서 앱의 데이터 전송도 멈추게 됩니다.

화면이 꺼진 상태에서도 계속 동작하게 만들려면 'Foreground Service'라는 아주 복잡한 기능을 구현해야 합니다. 하지만 이 앱의 목적에는 **"화면을 계속 켜두는 것"**이 훨씬 간단하고 효과적인 해결책입니다.

방법은 코드 한 줄만 추가하면 끝입니다.

MainActivity.kt 최종 수정본
기존 MainActivity.kt 파일의 내용을 모두 지우고 아래의 최종 코드로 완전히 덮어쓰세요. 화면을 계속 켜는 코드가 추가되어 있습니다.

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.WindowManager
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST

data class LightData(val lux: Float)

interface ApiService {
    @POST("log")
    fun postLightValue(@Body data: LightData): Call<String>
}

class MainActivity : AppCompatActivity(), SensorEventListener {

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null
    private var latestLuxValue: Float = 0.0f
    private val handler = Handler(Looper.getMainLooper())
    private lateinit var apiService: ApiService

    private val runnable = object : Runnable {
        override fun run() {
            sendDataToServer(latestLuxValue)
            handler.postDelayed(this, 1000)
        }
    }

    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // ★★★★★ 이 한 줄이 화면을 계속 켜주는 코드입니다! ★★★★★
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        // ★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★★

        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)

        setupSensor()
        setupNetwork()
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        if (lightSensor == null) {
            binding.tvLuxValue.text = "조도 센서 없음"
            binding.tvUnit.text = ""
        }
    }

    private fun setupNetwork() {
        val retrofit = Retrofit.Builder()
            .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/")
            .addConverterFactory(ScalarsConverterFactory.create()) // 일반 텍스트 응답 처리
            .addConverterFactory(GsonConverterFactory.create())   // JSON 요청 처리
            .build()

        apiService = retrofit.create(ApiService::class.java)
    }

    private fun sendDataToServer(lux: Float) {
        val lightData = LightData(lux = lux)
        apiService.postLightValue(lightData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) {
                    Log.d("NetworkSuccess", "데이터 전송 성공: ${response.body()}")
                } else {
                    Log.e("NetworkError", "데이터 전송 실패 (HTTP 코드): ${response.code()}")
                }
            }

            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "네트워크 오류: ${t.message}")
            }
        })
    }

    override fun onResume() {
        super.onResume()
        lightSensor?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        handler.post(runnable)
    }

    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
        handler.removeCallbacks(runnable)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {
            val luxValue = event.values[0]
            binding.tvLuxValue.text = "%.1f".format(luxValue)
            latestLuxValue = luxValue

            val colorResId = when {
                luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                else -> R.color.spec_in_black
            }
            binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // Do nothing
    }
}
이제 앱을 실행하면, 이 앱이 켜져 있는 동안에는 휴대폰 화면이 자동으로 꺼지지 않고 계속 켜진 상태를 유지하게 됩니다. 당연히 배터리는 더 빨리 닳겠지만, 원하시는 기능은 완벽하게 동작할 겁니다!






동영상
