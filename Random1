알겠습니다. 최상위 폴더를 제외한 하위 폴더의 패턴을 처음 4글자로만 일치 여부를 확인하여 패턴을 맞추도록 수정하겠습니다.

MLModelBuilder.cs 수정
FindCommonPattern 함수와 관련 로직 수정
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileRecord> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileRecord>();
        }

        public void TrainModel(List<FileRecord> fileData)
        {
            try
            {
                if (fileData == null || fileData.Count < 20) // 최소 샘플 수 확인
                {
                    throw new InvalidOperationException("Not enough samples to train the model. Minimum required samples: 20");
                }

                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);

                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileRecord.Size))
                    .Append(_mlContext.Transforms.Text.FeaturizeText("FolderPathFeaturized", nameof(FileRecord.FolderPath)))
                    .Append(_mlContext.Transforms.Concatenate("Features", "Features", "FolderPathFeaturized"))
                    .Append(_mlContext.Transforms.Conversion.ConvertType("Features", outputKind: DataKind.Single))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model: " + ex.Message, ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileRecord
                {
                    Size = (float)fileInfo.Length, // float 형식으로 변환
                    FolderPath = fileInfo.DirectoryName
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileRecord, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification: " + ex.Message, ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var regexPatterns = GetRegexPatterns();
                if (regexPatterns.Count == 0)
                {
                    return "No patterns found.";
                }

                return string.Join(", ", regexPatterns.Select(p => p.ToString()));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns: " + ex.Message, ex);
            }
        }

        public string GetCurrentPatternsInKorean()
        {
            try
            {
                var regexPatterns = GetRegexPatterns();
                if (regexPatterns.Count == 0)
                {
                    return "발견된 패턴이 없습니다.";
                }

                var patternDescriptions = regexPatterns.Select(p => TranslatePatternToKorean(p)).ToList();
                return string.Join("\n", patternDescriptions);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("패턴 설명을 가져오지 못했습니다: " + ex.Message, ex);
            }
        }

        private string TranslatePatternToKorean(Regex pattern)
        {
            if (pattern.ToString().Contains(@"\d{4}-\d{2}-\d{2}"))
            {
                return "이 패턴은 날짜 형식을 포함합니다 (예: 2022-01-01).";
            }
            if (pattern.ToString().Contains(@"IMG_\d{8}"))
            {
                return "이 패턴은 이미지 파일 형식을 포함합니다 (예: IMG_20220101).";
            }
            if (pattern.ToString().Contains(@"\d+"))
            {
                return "이 패턴은 숫자를 포함합니다.";
            }
            if (pattern.ToString().Contains(@"[A-Za-z]+"))
            {
                return "이 패턴은 영문자를 포함합니다.";
            }
            // 추가적인 패턴 설명이 필요하면 여기에 추가
            return "알 수 없는 패턴: " + pattern.ToString();
        }

        public List<Regex> GetRegexPatterns()
        {
            var patterns = new List<Regex>();

            // 모든 폴더 경로에서 공통된 부분을 찾아서 정규식 패턴으로 변환
            var folderPaths = _fileDataList.Select(f => f.FolderPath).Distinct().ToList();
            foreach (var fp in folderPaths)
            {
                var pattern = FindCommonPattern(fp, _fileDataList);
                if (!string.IsNullOrEmpty(pattern))
                {
                    patterns.Add(new Regex(pattern));
                }
            }

            return patterns;
        }

        private string FindCommonPattern(string folderPath, List<FileRecord> fileDataList)
        {
            var filesInFolder = fileDataList.Where(f => f.FolderPath.StartsWith(folderPath) && f.Size > 500 * 1024).ToList(); // 500KB 이상의 파일만 포함
            if (filesInFolder.Count < 20)
            {
                return null;
            }

            // 최상위 폴더를 제외한 하위 폴더의 글자 일치 여부를 처음 4글자로만 확인
            var subFolders = filesInFolder.Select(f => GetSubFolder(f.FolderPath, folderPath)).Where(f => f != null).ToList();
            var commonSubFolderPattern = FindLCS(subFolders);

            var regexPattern = Regex.Escape(commonSubFolderPattern).Replace("\\*", ".*").Replace("\\?", ".");
            return regexPattern;
        }

        private string GetSubFolder(string fullPath, string rootPath)
        {
            var relativePath = fullPath.Substring(rootPath.Length).Trim('\\');
            var subFolder = relativePath.Split('\\').FirstOrDefault();
            return subFolder?.Substring(0, Math.Min(subFolder.Length, 4)); // 하위 폴더의 처음 4글자만 반환
        }

        private string FindLCS(List<string> strs)
        {
            if (strs == null || strs.Count == 0)
            {
                return string.Empty;
            }

            var lcs = strs[0];
            foreach (var str in strs)
            {
                lcs = FindLCS(lcs, str);
            }

            return lcs;
        }

        private string FindLCS(string str1, string str2)
        {
            var lengths = new int[str1.Length, str2.Length];
            var greatestLength = 0;
            var output = string.Empty;

            for (int i = 0; i < str1.Length; i++)
            {
                for (int j = 0; j < str2.Length; j++)
                {
                    if (str1[i] == str2[j])
                    {
                        lengths[i, j] = (i == 0 || j == 0) ? 1 : lengths[i - 1, j - 1] + 1;
                        if (lengths[i, j] > greatestLength)
                        {
                            greatestLength = lengths[i, j];
                            output = str1.Substring(i - greatestLength + 1, greatestLength);
                        }
                    }
                }
            }

            return output;
        }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
위 코드는 최상위 폴더를 제외한 하위 폴더의 글자 일치 여부를 처음 4글자로만 확인하여 패턴을 찾도록 수정되었습니다. GetSubFolder 함수는 하위 폴더의 처음 4글자를 반환합니다. 이를 통해 패턴을 찾고 정규식으로 변환합니다.