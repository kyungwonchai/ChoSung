네, 요청하신 시스템은 상당히 광범위하고 복잡한 기능을 포함하고 있어 한 번에 모든 완성 코드를 제공하기는 어렵습니다. 단계별로 나누어 핵심적인 부분에 대한 코드와 설명을 제공해 드리겠습니다.

전제 조건 및 참고 사항:

.NET Framework 4.5: 해당 버전을 기준으로 코드를 작성합니다.
WPF Devexpress 22.2: Devexpress 컨트롤 자체의 상세한 사용법보다는 MVVM 패턴과 일반적인 WPF 기능을 중심으로 설명합니다. 실제 Devexpress 컨트롤 연동은 해당 문서를 참고하셔야 합니다.
MS SQL Server 2014: 제공되는 SQL 스크립트는 이 버전에 호환됩니다.
안정적인 고급 패턴: Agent와 제어 UI(서버 경유) 간의 통신은 실시간 양방향 통신 및 안정성을 고려하여 SignalR을 사용하는 것을 제안합니다. (요청하신 "소켓 통신이든 뭐든"에 대한 좋은 대안입니다.)
보안: 비밀번호는 반드시 해시하여 저장하고, 통신은 HTTPS를 사용하는 것이 이상적입니다. 예제 코드에서는 단순화된 형태로 제공될 수 있으나, 실제 운영 환경에서는 보안 강화가 필수입니다.
오류 처리 및 로깅: 각 기능에 대한 기본적인 오류 처리 및 로깅 개념을 포함하되, 실제 운영 수준의 상세 로깅은 NLog, Serilog 같은 전문 로깅 라이브러리 사용을 권장합니다.
1단계: 데이터베이스 스키마 (MS SQL Server)

먼저 데이터를 저장할 테이블 구조입니다.

SQL

-- 데이터베이스를 사용합니다. (이미 생성되어 있다고 가정)
-- USE YourMonitorControlDB;
-- GO

-- 1. 설정 테이블 (관리자 비밀번호 등 저장)
IF OBJECT_ID('dbo.Settings', 'U') IS NOT NULL
    DROP TABLE dbo.Settings;
GO

CREATE TABLE dbo.Settings (
    SettingKey NVARCHAR(100) PRIMARY KEY,
    SettingValue NVARCHAR(MAX) NOT NULL
);
GO

-- 초기 비밀번호 설정 (예: 'admin123')
-- !!! 실제 운영 환경에서는 반드시 BCrypt 등의 강력한 해시 함수로 해시하여 저장하세요. !!!
-- 이 예제에서는 설명을 위해 평문으로 저장하지만, 절대 이렇게 사용하면 안 됩니다.
INSERT INTO dbo.Settings (SettingKey, SettingValue) VALUES ('AdminPassword', 'admin123');
GO


-- 2. 모니터(PC) 정보 테이블
IF OBJECT_ID('dbo.Monitors', 'U') IS NOT NULL
    DROP TABLE dbo.Monitors;
GO

CREATE TABLE dbo.Monitors (
    MonitorId INT PRIMARY KEY IDENTITY(1,1),
    MonitorName NVARCHAR(255) NOT NULL,
    Description NVARCHAR(500) NULL,       -- 장비 설명
    PatternType INT NOT NULL,             -- 1: 1대 직렬 (IP 1개), 2: 2대 연결 (IP 2개)
    IpAddress1 VARCHAR(45) NOT NULL,      -- PC 1의 IP 주소 또는 Agent 식별자
    IpAddress2 VARCHAR(45) NULL,          -- PC 2의 IP 주소 (PatternType이 2일 경우)
                                          -- IP 주소 외에 Agent 고유 ID를 저장할 수도 있습니다.
    IsActive BIT DEFAULT 1 NOT NULL,      -- 사용 여부 (삭제 대신 비활성화)
    RegisteredDate DATETIME DEFAULT GETDATE(),
    LastModifiedDate DATETIME DEFAULT GETDATE(),
    LastAgentConnectionId NVARCHAR(100) NULL, -- Agent의 마지막 SignalR Connection ID (서버에서 관리)
    LastStatus NVARCHAR(50) DEFAULT 'Unknown', -- Agent의 마지막 상태 (예: Online, Offline, Off, On)
    LastHeartbeat DATETIME NULL             -- Agent로부터 마지막 하트비트를 받은 시간
);
GO

-- 3. 제어 이력 테이블
IF OBJECT_ID('dbo.ControlLogs', 'U') IS NOT NULL
    DROP TABLE dbo.ControlLogs;
GO

CREATE TABLE dbo.ControlLogs (
    LogId BIGINT PRIMARY KEY IDENTITY(1,1),
    MonitorId INT NULL, -- 특정 모니터에 대한 제어일 경우. 전체 제어면 NULL 가능
    FOREIGN KEY (MonitorId) REFERENCES dbo.Monitors(MonitorId),
    CommandType NVARCHAR(50) NOT NULL,    -- 'TurnOn', 'TurnOff', 'SystemEvent'
    CommandTarget NVARCHAR(MAX) NOT NULL, -- 'MonitorId: 1', 'IpAddress: 192.168.0.10', 'All', 'Group: X'
    RequesterInfo NVARCHAR(255),          -- 제어를 요청한 사용자 ID 또는 시스템 정보
    RequesterIpAddress VARCHAR(45),       -- 제어를 요청한 클라이언트의 IP 주소
    CommandTimestamp DATETIME DEFAULT GETDATE(), -- 제어 명령이 시스템에 기록된 시간
    ExecutionTimestamp DATETIME NULL,     -- Agent에서 실제 명령이 실행된 시간
    ResultStatus NVARCHAR(10) NOT NULL,   -- 'OK', 'NG', 'Pending', 'Sent'
    ResultMessage NVARCHAR(MAX) NULL,     -- 상세 결과 메시지 또는 오류 정보
    AgentIpAddress VARCHAR(45) NULL       -- 명령을 실행한 Agent의 IP (해당되는 경우)
);
GO

-- 인덱스 추가 (성능 향상을 위해)
CREATE INDEX IX_Monitors_IpAddress1 ON dbo.Monitors(IpAddress1);
CREATE INDEX IX_ControlLogs_CommandTimestamp ON dbo.ControlLogs(CommandTimestamp);
CREATE INDEX IX_ControlLogs_MonitorId ON dbo.ControlLogs(MonitorId);
GO

-- 최근 이벤트 조회용 (UI에서 최근 500개)
CREATE VIEW dbo.RecentControlLogs
AS
SELECT TOP 500 *
FROM dbo.ControlLogs
ORDER BY CommandTimestamp DESC;
GO
2단계: Agent (WPF, .NET 4.5)

Agent는 대상 PC에 설치되어 다음 기능을 수행합니다.

실행 시 트레이 아이콘으로 최소화 및 자동 시작 프로그램 등록
모니터 켜기/끄기 (Windows API 사용)
제어 이력 로컬 표시 (최대 100개)
중앙 서버와 SignalR을 통해 통신하여 명령 수신 및 상태 보고
2.1. 모니터 제어 유틸리티 (MonitorControl.cs)

C#

using System;
using System.Runtime.InteropServices;
using System.Windows; // For Application.Current.MainWindow if needed

public static class MonitorControl
{
    private const int WM_SYSCOMMAND = 0x0112;
    private const int SC_MONITORPOWER = 0xF170;

    // lParam for SC_MONITORPOWER:
    // -1: 전원 켜기 (The display is powering on)
    //  1: 저전력 상태 (The display is going to low power)
    //  2: 전원 끄기 (The display is being shut off)
    private const int MONITOR_ON = -1;
    private const int MONITOR_OFF = 2;
    // private const int MONITOR_LOW_POWER = 1; // 필요시 사용

    // 최상위 모든 창에 메시지를 보내기 위한 핸들
    private static readonly IntPtr HWND_BROADCAST = new IntPtr(0xFFFF);

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    // WPF 애플리케이션의 경우 메인 윈도우 핸들이나 데스크톱 윈도우 핸들을 사용할 수 있습니다.
    // Agent는 백그라운드에서 실행되므로, 특정 윈도우 핸들보다는 브로드캐스트나
    // 포그라운드 윈도우 핸들을 사용하는 것이 일반적입니다.
    [DllImport("user32.dll")]
    static extern IntPtr GetForegroundWindow();

    public static bool TurnOn()
    {
        try
        {
            // 일부 시스템에서는 MONITOR_ON이 즉각적으로 반응하지 않거나,
            // 화면이 꺼진 후 마우스/키보드 입력이 있어야 켜지는 경우가 있습니다.
            // SendMessage(GetForegroundWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
            // 브로드캐스트로 보내는 것이 더 일반적일 수 있습니다.
            SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
            return true;
        }
        catch
        {
            return false;
        }
    }

    public static bool TurnOff()
    {
        try
        {
            // SendMessage(GetForegroundWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
            SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
            return true;
        }
        catch
        {
            return false;
        }
    }

    // "제어를 받았을 때만 켜지게" 하는 것은 OS의 기본 동작(입력 시 모니터 켜짐)을
    // 소프트웨어적으로 완벽히 막는 것은 매우 어렵습니다.
    // Agent가 "켜기" 명령을 수신했을 때만 TurnOn()을 호출하는 방식으로 구현합니다.
    // 모니터가 꺼진 상태에서 사용자의 물리적 입력(마우스, 키보드)으로 켜지는 것은
    // 이 API 호출만으로는 제어하기 어렵습니다.
}
2.2. Agent의 메인 로직 (AgentViewModel.cs - MVVM 패턴 적용, App.xaml.cs 또는 MainWindow.xaml.cs에 통합)

Agent는 UI가 거의 없거나 트레이 아이콘만 있을 것이므로, ViewModel 중심으로 로직을 구성합니다.

C#

// 필요한 NuGet 패키지:
// Microsoft.AspNet.SignalR.Client (SignalR 클라이언트 라이브러리)

using Microsoft.AspNet.SignalR.Client; // SignalR
using Microsoft.Win32; // Registry
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Reflection;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms; // NotifyIcon (System.Windows.Forms.dll 참조 필요)
using System.Windows.Threading; // Dispatcher

public class AgentViewModel : INotifyPropertyChanged
{
    private const string AppName = "MyProcessMonitorAgent"; // 시작프로그램 등록 시 사용할 이름
    private const string ServerUri = "http://your_server_address/signalr"; // 실제 서버 주소로 변경!
    private HubConnection _hubConnection;
    private IHubProxy _monitorHubProxy;

    private NotifyIcon _notifyIcon;
    private Window _mainWindow; // Agent UI Window (주로 숨겨짐)

    public ObservableCollection<string> ControlHistory { get; } = new ObservableCollection<string>();
    private const int MaxHistoryEntries = 100;

    private string _statusText = "Agent Initializing...";
    public string StatusText
    {
        get => _statusText;
        set { _statusText = value; OnPropertyChanged(nameof(StatusText)); }
    }

    public AgentViewModel(Window mainWindow)
    {
        _mainWindow = mainWindow;
        InitializeTrayIcon();
        RegisterStartup();

        // 서버 연결 시도 (백그라운드에서 비동기적으로)
        Task.Run(async () => await ConnectToSignalRServer());
    }

    private void InitializeTrayIcon()
    {
        _notifyIcon = new NotifyIcon
        {
            Icon = System.Drawing.Icon.ExtractAssociatedIcon(Assembly.GetExecutingAssembly().Location),
            Visible = true,
            Text = AppName
        };

        var contextMenu = new ContextMenuStrip();
        contextMenu.Items.Add("Show Status", null, OnShowStatus);
        contextMenu.Items.Add(new ToolStripSeparator());
        contextMenu.Items.Add("Exit", null, OnExit);
        _notifyIcon.ContextMenuStrip = contextMenu;

        _notifyIcon.DoubleClick += OnShowStatus;

        // 초기에는 메인 윈도우를 숨깁니다.
        _mainWindow.Hide();
        // _mainWindow.WindowState = WindowState.Minimized; // 작업 표시줄에도 안 보이게 하려면
        // _mainWindow.ShowInTaskbar = false;               // XAML에서 설정하는 것이 좋음
    }

    private void OnShowStatus(object sender, EventArgs e)
    {
        _mainWindow.Dispatcher.Invoke(() =>
        {
            _mainWindow.Show();
            _mainWindow.WindowState = WindowState.Normal;
            _mainWindow.Activate();
        });
        AddHistory("Status window shown.");
    }

    private async void OnExit(object sender, EventArgs e)
    {
        AddHistory("Exit requested by user.");
        if (_hubConnection != null && _hubConnection.State == ConnectionState.Connected)
        {
            await _hubConnection.Stop();
        }
        _notifyIcon.Visible = false;
        _notifyIcon.Dispose();
        System.Windows.Application.Current.Shutdown();
    }

    private void RegisterStartup()
    {
        try
        {
            RegistryKey rk = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
            string exePath = Process.GetCurrentProcess().MainModule.FileName;

            if (rk.GetValue(AppName) == null || !rk.GetValue(AppName).ToString().Equals(exePath, StringComparison.OrdinalIgnoreCase))
            {
                rk.SetValue(AppName, exePath);
                AddHistory("Agent registered for startup.");
            }
            else
            {
                AddHistory("Agent already registered for startup.");
            }
        }
        catch (Exception ex)
        {
            AddHistory($"Error registering startup: {ex.Message}");
        }
    }

    private async Task ConnectToSignalRServer()
    {
        _hubConnection = new HubConnection(ServerUri);
        // 로깅 추가 (디버깅용)
        _hubConnection.TraceLevel = TraceLevels.All;
        _hubConnection.TraceWriter = Console.Out; // 또는 파일

        // Hub 프록시 생성 (서버의 Hub 이름과 동일해야 함)
        _monitorHubProxy = _hubConnection.CreateHubProxy("MonitorControlHub"); // 서버 측 Hub 이름

        // 서버에서 호출할 클라이언트 메소드 등록
        _monitorHubProxy.On<string>("TurnMonitorOn", async () => await HandleTurnMonitorOn());
        _monitorHubProxy.On<string>("TurnMonitorOff", async () => await HandleTurnMonitorOff());
        _monitorHubProxy.On<string>("PingAgent", async () => await HandlePing()); // Ping 테스트용

        _hubConnection.Closed += async () =>
        {
            StatusText = "Disconnected from server. Reconnecting...";
            AddHistory("Disconnected from server. Attempting to reconnect...");
            // 재연결 시도 (지연 시간 추가 권장)
            await Task.Delay(5000);
            await ConnectToSignalRServer();
        };

        _hubConnection.Error += ex =>
        {
            AddHistory($"SignalR Connection Error: {ex.Message}");
            StatusText = $"Connection Error: {ex.GetBaseException().Message}";
        };


        try
        {
            StatusText = $"Connecting to server at {ServerUri}...";
            AddHistory($"Attempting to connect to server: {ServerUri}");
            await _hubConnection.Start();
            StatusText = $"Connected to server. Connection ID: {_hubConnection.ConnectionId}";
            AddHistory($"Successfully connected. Connection ID: {_hubConnection.ConnectionId}");

            // 연결 성공 후 서버에 Agent 정보 등록 (예: 고유 ID, IP 주소 등)
            string agentIdentifier = GetAgentIdentifier(); // IP 주소나 MAC 주소 등
            await _monitorHubProxy.Invoke("RegisterAgent", agentIdentifier);
            AddHistory($"Agent registered with server as: {agentIdentifier}");

        }
        catch (Exception ex)
        {
            StatusText = $"Failed to connect: {ex.Message}";
            AddHistory($"Connection failed: {ex.GetBaseException().Message}. Retrying in 5s...");
            // 연결 실패 시 재시도 로직
            await Task.Delay(5000);
            await ConnectToSignalRServer(); // 재귀 호출, 주의 필요
        }
    }

    private string GetAgentIdentifier()
    {
        // Agent를 식별할 수 있는 고유한 값을 반환합니다.
        // 예: IP 주소, 호스트명, MAC 주소 등. 여기서는 간단히 호스트명을 사용합니다.
        // 여러 네트워크 인터페이스가 있는 경우 IP 주소 선택에 주의해야 합니다.
        return Environment.MachineName;
        // 또는 첫번째 유효한 IPv4 주소
        /*
        try {
            foreach (var ip in System.Net.Dns.GetHostEntry(System.Net.Dns.GetHostName()).AddressList) {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork) {
                    return ip.ToString();
                }
            }
        } catch {}
        return "UnknownIP";
        */
    }


    private async Task HandleTurnMonitorOn()
    {
        AddHistory($"Received command: TurnMonitorOn at {DateTime.Now}");
        bool success = MonitorControl.TurnOn();
        string resultMessage = success ? "Monitor On command sent successfully." : "Failed to send Monitor On command.";
        AddHistory(resultMessage);
        StatusText = $"Monitor On command executed at {DateTime.Now}";
        // 서버에 결과 보고
        if (_monitorHubProxy != null && _hubConnection.State == ConnectionState.Connected)
        {
            await _monitorHubProxy.Invoke("ReportStatus", GetAgentIdentifier(), "On", resultMessage);
        }
    }

    private async Task HandleTurnMonitorOff()
    {
        AddHistory($"Received command: TurnMonitorOff at {DateTime.Now}");
        bool success = MonitorControl.TurnOff();
        string resultMessage = success ? "Monitor Off command sent successfully." : "Failed to send Monitor Off command.";
        AddHistory(resultMessage);
        StatusText = $"Monitor Off command executed at {DateTime.Now}";
        // 서버에 결과 보고
        if (_monitorHubProxy != null && _hubConnection.State == ConnectionState.Connected)
        {
            await _monitorHubProxy.Invoke("ReportStatus", GetAgentIdentifier(), "Off", resultMessage);
        }
    }

    private async Task HandlePing()
    {
        AddHistory($"Received Ping from server at {DateTime.Now}. Sending Pong.");
        StatusText = $"Ping received at {DateTime.Now}";
        if (_monitorHubProxy != null && _hubConnection.State == ConnectionState.Connected)
        {
            await _monitorHubProxy.Invoke("Pong", GetAgentIdentifier(), DateTime.UtcNow);
        }
    }


    public void AddHistory(string message)
    {
        // UI 스레드에서 실행되도록 보장
        Action action = () =>
        {
            string entry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
            if (ControlHistory.Count >= MaxHistoryEntries)
            {
                ControlHistory.RemoveAt(0);
            }
            ControlHistory.Add(entry);
            // 파일 로그 (간단 예시)
            try
            {
                File.AppendAllText(Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "agent_log.txt"), entry + Environment.NewLine);
            }
            catch { /* 파일 쓰기 오류는 무시 (또는 다른 처리) */ }
        };

        if (_mainWindow.Dispatcher.CheckAccess())
        {
            action();
        }
        else
        {
            _mainWindow.Dispatcher.Invoke(action);
        }
        Debug.WriteLine(entry); // 디버그 콘솔에도 출력
    }


    public event PropertyChangedEventHandler PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // 애플리케이션 종료 시 자원 정리
    public async Task Cleanup()
    {
        if (_hubConnection != null)
        {
            if (_hubConnection.State == ConnectionState.Connected)
            {
                await _hubConnection.Stop();
            }
            _hubConnection.Dispose();
            _hubConnection = null;
        }
        if (_notifyIcon != null)
        {
            _notifyIcon.Visible = false;
            _notifyIcon.Dispose();
            _notifyIcon = null;
        }
    }
}
2.3. Agent UI (AgentWindow.xaml)

간단한 상태 및 로그 표시용 창입니다.

XML

<Window x:Class="YourAgentNamespace.AgentWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:YourAgentNamespace"
        mc:Ignorable="d"
        Title="Monitor Agent Status" Height="400" Width="600"
        WindowStyle="ToolWindow" ShowInTaskbar="False" WindowState="Minimized"
        Closing="Window_Closing">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="Monitor Agent Status" FontSize="16" FontWeight="Bold" Margin="0,0,0,5"/>
        <TextBlock Grid.Row="1" Text="{Binding StatusText}" Margin="0,0,0,10" TextWrapping="Wrap"/>

        <TextBlock Grid.Row="2" Text="Control History (Last 100):" VerticalAlignment="Top" Margin="0,0,0,5"/>
        <ListBox Grid.Row="2" ItemsSource="{Binding ControlHistory}" Margin="0,20,0,0" BorderBrush="LightGray" BorderThickness="1"/>
        
        </Grid>
</Window>
2.4. Agent UI Code-behind (AgentWindow.xaml.cs)

C#

using System.ComponentModel;
using System.Windows;

namespace YourAgentNamespace // AgentViewModel과 동일한 네임스페이스 또는 using 추가
{
    public partial class AgentWindow : Window
    {
        private AgentViewModel _viewModel;

        public AgentWindow()
        {
            InitializeComponent();
            _viewModel = new AgentViewModel(this); // ViewModel 인스턴스 생성 및 Window 참조 전달
            this.DataContext = _viewModel;
        }

        // 창의 X 버튼을 눌렀을 때 실제 종료가 아닌 숨김 처리
        private void Window_Closing(object sender, CancelEventArgs e)
        {
            e.Cancel = true; // 실제 종료 방지
            this.Hide();     // 창 숨기기
            _viewModel?.AddHistory("Status window hidden by user.");
        }

        // 애플리케이션 종료 시 ViewModel의 Cleanup 호출 (App.xaml.cs의 OnExit에서)
        public async Task PerformCleanup()
        {
            if (_viewModel != null)
            {
                await _viewModel.Cleanup();
            }
        }
    }
}
2.5. App.xaml.cs (Agent 애플리케이션 진입점)

C#

using System.Threading.Tasks;
using System.Windows;
using YourAgentNamespace; // AgentWindow가 있는 네임스페이스

namespace YourAgentApplicationNamespace
{
    public partial class App : Application
    {
        private AgentWindow _agentWindow;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // 중복 실행 방지 (선택 사항)
            // Mutex mutex = new System.Threading.Mutex(true, "YourUniqueAgentAppNameMutex", out bool createdNew);
            // if (!createdNew)
            // {
            //    MessageBox.Show("Agent is already running.", "Monitor Agent", MessageBoxButton.OK, MessageBoxImage.Information);
            //    Application.Current.Shutdown();
            //    return;
            // }


            // 메인 윈도우 (상태 표시용) 생성. ViewModel이 트레이 아이콘 등을 관리.
            _agentWindow = new AgentWindow();
            // MainWindow = _agentWindow; // 명시적으로 MainWindow 설정 (선택적)

            // _agentWindow는 생성자에서 스스로 Hide() 또는 WindowState.Minimized 처리
            // _agentWindow.Show(); // 초기에 잠깐 보였다 사라지게 하려면. 보통은 바로 숨김.
        }

        protected override async void OnExit(ExitEventArgs e)
        {
            if (_agentWindow != null)
            {
                await _agentWindow.PerformCleanup(); // ViewModel의 자원 정리 호출
            }
            base.OnExit(e);
        }
    }
}
프로젝트 설정:

새 WPF 애플리케이션 프로젝트 (.NET Framework 4.5)를 생성합니다.
NuGet 패키지 관리자에서 다음 패키지를 설치합니다:
Microsoft.AspNet.SignalR.Client (올바른 .NET Framework 버전에 맞는 것으로)
참조 추가: System.Windows.Forms.dll (NotifyIcon 사용을 위해)
위의 C# 및 XAML 코드 파일들을 프로젝트에 추가/수정합니다. (네임스페이스는 실제 프로젝트에 맞게 조정)
실행 파일 아이콘을 프로젝트 속성에서 설정합니다 (System.Drawing.Icon.ExtractAssociatedIcon이 제대로 동작하도록).
이것으로 1단계 DB 스키마와 2단계 Agent의 기본 구조가 마련되었습니다.
Agent는 아직 서버가 없으므로 완전한 기능을 하지는 못하지만, 트레이 아이콘, 시작프로그램 등록 시도, 모니터 제어 API, 로컬 이력 관리, SignalR 서버 연결 시도 로직을 포함하고 있습니다.

다음 단계는 다음과 같습니다:

3단계: 중앙 제어 서버 (ASP.NET Web API + SignalR Hub)
Agent로부터 연결을 받고 관리
제어 UI로부터 명령을 받아 Agent에게 전달
DB와 연동하여 모니터 정보 및 로그 관리
4.단계: 제어 UI (WPF Devexpress 22.2)
서버와 통신하여 모니터 목록 표시, 제어 명령 전송, 로그 조회