네, 서버가 정상적으로 실행되는데 앱에서 데이터 전송이 안 되는 상황이군요. 원인은 거의 99% 앱과 서버가 서로 다른 주소로 통신하고 있기 때문입니다.

먼저 질문 주신 @POST("Light/Log")의 의미를 알면 문제가 바로 보일 겁니다.

## @POST("Light/Log")의 의미는 무엇인가요?
이것은 안드로이드의 네트워크 라이브러리인 Retrofit에서 사용하는 '주석(Annotation)' 입니다. 쉽게 말해 "이 함수가 호출되면, HTTP POST 방식으로 데이터를 보내라"는 약속이자 명령어입니다.

@POST: 데이터를 서버로 **'제출'**하거나 **'생성'**할 때 사용하는 통신 방식(HTTP POST)을 의미합니다.

("Light/Log"): 이것은 '상대 경로(Relative Path)' 입니다. Retrofit 설정에 있는 '기본 주소(Base URL)' 뒤에 이 경로가 합쳐져서 최종 목적지 주소가 완성됩니다.

예시:

기본 주소(Base URL): http://192.168.0.10:3000/

상대 경로(@POST): ("Light/Log")

최종 완성 주소: http://192.168.0.10:3000/Light/Log

## DB에 전송이 안 되는 이유와 해결 방법
가장 유력한 원인:
사용자님께서 만드신 우분투 Node.js 서버는 http://서버IP:3000/log 라는 주소로 데이터를 받도록 설정되어 있습니다.

하지만 안드로이드 앱의 @POST 주석이 예전 C# 코드 기준인 ("Light/Log")로 되어 있다면, 앱은 엉뚱한 주소인 http://서버IP:3000/Light/Log로 계속 데이터를 보내고 있는 것입니다. 서버는 /log 주소만 기다리고 있으니 당연히 데이터를 받지 못합니다.

해결 방법은 아주 간단합니다. MainActivity.kt 파일의 @POST 경로를 서버와 똑같이 "log"로 수정하면 됩니다.

1. MainActivity.kt 파일 최종 수정
아래 코드는 @POST 경로와 Base URL 형식까지 모두 우분투 Node.js 서버에 맞게 수정한 최종 버전입니다. 기존 MainActivity.kt 파일의 내용을 모두 지우고 아래 코드로 완전히 덮어쓰세요.

파일 위치: app > src > main > java > com.sec.lightmeter > MainActivity.kt

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST

// 서버로 보낼 데이터의 형식을 정의 (JSON)
data class LightData(val lux: Float)

// Retrofit이 사용할 API 명세
interface ApiService {
    // ★★★★★ 경로를 서버와 동일하게 "log"로 수정! ★★★★★
    @POST("log")
    fun postLightValue(@Body data: LightData): Call<String>
}


class MainActivity : AppCompatActivity(), SensorEventListener {

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null
    private var latestLuxValue: Float = 0.0f
    private val handler = Handler(Looper.getMainLooper())
    private lateinit var apiService: ApiService

    private val runnable = object : Runnable {
        override fun run() {
            sendDataToServer(latestLuxValue)
            handler.postDelayed(this, 1000)
        }
    }

    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)

        setupSensor()
        setupNetwork()
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        if (lightSensor == null) {
            binding.tvLuxValue.text = "조도 센서 없음"
            binding.tvUnit.text = ""
        }
    }

    private fun setupNetwork() {
        val retrofit = Retrofit.Builder()
            // ★★반드시 사용자님의 '우분투 서버 IP' 주소와 포트번호 '3000'으로 변경하세요!★★
            .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/")
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        apiService = retrofit.create(ApiService::class.java)
    }

    private fun sendDataToServer(lux: Float) {
        val lightData = LightData(lux = lux)
        apiService.postLightValue(lightData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) {
                    // Logcat에서 성공 메시지 확인
                    Log.d("NetworkSuccess", "데이터 전송 성공: ${response.body()}")
                } else {
                    // Logcat에서 실패 코드(예: 404 Not Found) 확인
                    Log.e("NetworkError", "데이터 전송 실패 (HTTP 코드): ${response.code()}")
                }
            }

            override fun onFailure(call: Call<String>, t: Throwable) {
                // Logcat에서 네트워크 연결 자체의 실패 원인 확인
                Log.e("NetworkFailure", "네트워크 오류: ${t.message}")
            }
        })
    }

    override fun onResume() {
        super.onResume()
        lightSensor?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        handler.post(runnable)
    }

    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
        handler.removeCallbacks(runnable)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {
            val luxValue = event.values[0]
            binding.tvLuxValue.text = "%.1f".format(luxValue)
            latestLuxValue = luxValue

            val colorResId = when {
                luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                else -> R.color.spec_in_black
            }
            binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // Do nothing
    }
}
2. 에러 확인하는 방법 (Logcat)
만약 위 코드로 수정한 후에도 데이터가 전송되지 않는다면, 안드로이드 스튜디오의 Logcat을 통해 정확한 원인을 바로 확인할 수 있습니다.

안드로이드 스튜디오 하단의 Logcat 탭을 클릭합니다.

오른쪽 위의 검색창에 Network 라고 입력하여 필터링합니다.

앱을 실행합니다.

성공 시: NetworkSuccess: 데이터 전송 성공 이라는 초록색 로그가 1초마다 보입니다.

실패 시:

NetworkError: 데이터 전송 실패 (HTTP 코드): 404: 주소가 틀렸다는 의미입니다. @POST 경로와 Base URL을 다시 확인하세요.