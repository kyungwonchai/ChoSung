CommandQueueViewModel.cs (ViewModel)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows.Input;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Collections.Generic;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    // 명령을 처리할 큐를 선언 (FIFO 구조로 명령 순서를 보장)
    private Queue<Func<Task>> commandQueue = new Queue<Func<Task>>();

    // 최대 재시도 횟수 정의
    private int retryCount = 3;

    // 데이터베이스 연결 문자열 (운영 환경에 맞게 수정 필요)
    private string connectionString = "your_connection_string_here"; 

    // 명령 이력 기록용 ObservableCollection (UI와 실시간으로 바인딩됨)
    public ObservableCollection<CommandItem> CommandItems { get; set; } = new ObservableCollection<CommandItem>();

    // INotifyPropertyChanged 이벤트를 구현하여 UI와 데이터 바인딩 (UI 업데이트)
    public event PropertyChangedEventHandler PropertyChanged;

    // 프로그레스바의 상태를 나타낼 속성
    private int _progress;
    public int Progress
    {
        get => _progress;
        set { _progress = value; OnPropertyChanged(nameof(Progress)); }
    }

    // 생성자 (필요시 초기화 작업 추가 가능)
    public CommandQueueViewModel()
    {
        // 초기화 작업 추가 가능
    }

    // 명령을 큐에 추가하는 메서드 (비동기로 처리되며 명령을 큐에 쌓음)
    public async Task EnqueueCommand(string commandText)
    {
        // 비동기로 실행할 명령을 큐에 등록 (Queue는 FIFO로 순차 처리)
        commandQueue.Enqueue(() => SendCommandAsync(commandText));

        // 큐가 비어 있을 경우 즉시 처리 시작 (첫 번째 명령)
        if (commandQueue.Count == 1)
        {
            await ProcessCommandQueue();
        }

        // 큐에 쌓인 명령의 수를 프로그레스바에 반영
        UpdateProgress();
    }

    // 큐에 쌓인 명령을 순차적으로 처리하는 메서드
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            // 큐에서 다음 명령을 꺼내어 실행
            var command = commandQueue.Dequeue();
            await command();

            // 프로그레스바 상태 업데이트 (남아있는 명령의 수 반영)
            UpdateProgress();
        }
    }

    // 프로그레스바의 상태를 실시간으로 업데이트하는 메서드
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 큐에 남아있는 명령 수를 프로그레스바에 반영
    }

    // PLC에 명령을 보내고 응답을 처리하는 핵심 비동기 메서드
    private async Task SendCommandAsync(string commandText)
    {
        int retries = 0; // 재시도 횟수 카운터
        bool success = false; // 성공 여부 플래그
        string response = string.Empty; // PLC로부터 받은 응답 저장 변수
        Stopwatch stopwatch = new Stopwatch(); // 응답 시간을 측정하기 위한 스톱워치

        // 재시도 횟수가 남아있고 성공하지 못한 경우 재시도 반복
        while (retries < retryCount && !success)
        {
            stopwatch.Restart(); // 응답 시간 측정 시작
            response = await SendToPLCAsync(commandText); // PLC로 명령을 전송하고 응답 대기
            stopwatch.Stop(); // 응답 시간 측정 종료

            success = CheckResponse(response); // 응답이 올바른지 검증

            // 응답이 올바르지 않으면 재시도 (1초 대기 후 재전송)
            if (!success)
            {
                retries++;
                await Task.Delay(1000); // 재시도 간 1초 대기
            }
        }

        // DB에 명령, 응답, 성공 여부, 재시도 횟수, 응답 시간을 기록
        await LogToDatabase(commandText, response, success ? 1 : 0, retries, stopwatch.ElapsedMilliseconds);

        // UI에 보여줄 명령 기록을 CommandItems에 추가 (실시간으로 ListBox에 반영됨)
        CommandItems.Add(new CommandItem
        {
            CommandText = commandText, // 보낸 명령
            ResponseText = response, // 받은 응답
            Result = success ? 1 : 0, // 성공: 1, 실패: 0
            RetryCount = retries, // 재시도 횟수
            ResponseTime = stopwatch.ElapsedMilliseconds // 응답 시간 (밀리초)
        });
    }

    // 명령 및 응답을 DB에 기록하는 메서드 (비동기 방식으로 SQL 실행)
    private async Task LogToDatabase(string commandText, string response, int result, int retryCount, long responseTime)
    {
        using (SqlConnection conn = new SqlConnection(connectionString))
        {
            await conn.OpenAsync(); // 비동기로 DB 연결
            using (SqlCommand cmd = new SqlCommand(
                "INSERT INTO CommandLog (CommandText, ResponseText, Result, RetryCount, ResponseTime) " +
                "VALUES (@CommandText, @ResponseText, @Result, @RetryCount, @ResponseTime)", conn))
            {
                // SQL 명령에 파라미터 바인딩 (SQL 인젝션 방지)
                cmd.Parameters.AddWithValue("@CommandText", commandText);
                cmd.Parameters.AddWithValue("@ResponseText", response);
                cmd.Parameters.AddWithValue("@Result", result); // 1: 성공, 0: 실패
                cmd.Parameters.AddWithValue("@RetryCount", retryCount); // 재시도 횟수
                cmd.Parameters.AddWithValue("@ResponseTime", responseTime); // 응답 시간 (밀리초)

                await cmd.ExecuteNonQueryAsync(); // 비동기로 SQL 실행
            }
        }
    }

    // PLC에 명령을 보내고 응답을 받는 가상 메서드 (실제 구현에서는 PLC와의 통신 필요)
    private async Task<string> SendToPLCAsync(string commandText)
    {
        // 실제 통신 시간 시뮬레이션 (500ms 지연)
        await Task.Delay(500); 
        return "OK"; // 가상 응답 반환 (실제 응답값으로 대체 필요)
    }

    // 응답이 올바른지 확인하는 메서드 (응답 검증 로직은 필요시 수정 가능)
    private bool CheckResponse(string response)
    {
        // 응답 값이 "OK"이면 성공으로 간주 (응답 포맷에 맞게 검증 가능)
        return response == "OK";
    }

    // INotifyPropertyChanged 인터페이스 구현 (UI와 바인딩된 속성 변경 시 호출)
    protected void OnPropertyChanged(string name)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name)); // UI 업데이트를 트리거
    }
}

// UI에 표시할 명령 로그 데이터 모델
public class CommandItem
{
    public string CommandText { get; set; } // 보낸 명령어
    public string ResponseText { get; set; } // 받은 응답
    public int Result { get; set; } // 1: 성공, 0: 실패
    public int RetryCount { get; set; } // 재시도 횟수
    public long ResponseTime { get; set; } // 응답 시간 (밀리초)
}
MainWindow.xaml (View)
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 명령 기록을 표시하는 ListBox (UI와 CommandItems 바인딩) -->
        <ListBox ItemsSource="{Binding CommandItems}" HorizontalAlignment="Left" Height="200" VerticalAlignment="Top" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 보낸 명령어 -->
                        <TextBlock Text="{Binding CommandText}" Width="200"/>
                        <!-- 받은 응답 -->
                        <TextBlock Text="{Binding ResponseText}" Width="200"/>
                        <!-- 성공/실패 결과 (1: 성공, 0: 실패) -->
                        <TextBlock Text="{Binding Result}" Width="50"/>
                        <!-- 재시도 횟수 -->
                        <TextBlock Text="{Binding RetryCount}" Width="50"/>
                        <!-- 응답 시간 (밀리초) -->
                        <TextBlock Text="{Binding ResponseTime}" Width="100"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 남아있는 명령 수 표시) -->
        <ProgressBar VerticalAlignment="Top" Height="200" Width="30" Orientation="Vertical" Value="{Binding Progress}" Maximum="10" HorizontalAlignment="Right" Margin="0,0,50,0"/>

        <!-- 명령 추가 버튼 -->
        <Button Content="Add Command" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="150" Click="AddCommand_Click"/>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
public partial class MainWindow : Window
{
    private CommandQueueViewModel viewModel; // ViewModel 선언

    public MainWindow()
    {
        InitializeComponent();
        // ViewModel 인스턴스 생성 및 DataContext 설정
        viewModel = new CommandQueueViewModel();
        DataContext = viewModel; // MVVM 패턴으로 ViewModel과 View 바인딩
    }

    // 명령 추가 버튼 클릭 시 호출되는 이벤트 핸들러
    private async void AddCommand_Click(object sender, RoutedEventArgs e)
    {
        // 큐에 명령을 추가 (예: PLC의 특정 데이터를 읽는 명령)
        await viewModel.EnqueueCommand("READ 520-540");
    }
}
SQL 테이블 생성 스크립트
sql
코드 복사
CREATE TABLE CommandLog (
    Id INT PRIMARY KEY IDENTITY(1,1), -- 명령 고유 ID (자동 증가)
    CommandText NVARCHAR(255),        -- 보낸 명령 텍스트
    ResponseText NVARCHAR(255),       -- 받은 응답 텍스트
    Result INT,                       -- 결과 (1: 성공, 0: 실패)
    RetryCount INT,                   -- 재시도 횟수
    ResponseTime INT,                 -- 응답 시간 (밀리초)
    Timestamp DATETIME DEFAULT GETDATE() -- 명령 발생 시간 (기본값: 현재 시간)
);
