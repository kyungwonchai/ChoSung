데이터 구조가 달라 두 세트(data_a, data_b)를 각각 훈련하되, 서로의 모델 특징을 참조하는 방식으로 해결하려면, 다음과 같은 접근 방식을 사용할 수 있습니다:

데이터 구조 문제 해결

data_a와 data_b의 행 길이가 다르므로, 각 데이터를 별도로 모델링합니다.
상호 참조 특징 추가

data_a에서 학습된 모델의 예측값을 data_b의 입력으로 참조하거나, 그 반대로 적용합니다.
이 방식은 두 데이터 세트 간 상호 관계를 활용하기 위한 기본적인 전략입니다.
모델 학습 및 참조

각 데이터 세트(data_a, data_b)에 대해 독립적으로 모델을 학습합니다.
각 모델의 예측값을 다른 세트의 추가 입력 특징으로 활용합니다.
수정된 전체 코드
python
코드 복사
import numpy as np
import pandas as pd
import pymssql
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from tqdm import tqdm


# 1. 데이터베이스에서 데이터 가져오기 함수
def fetch_data_from_procedure_with_cursor(proc_name, connection_details):
    """
    MSSQL 저장 프로시저를 호출하여 데이터를 가져오는 함수.
    커서를 사용하여 결과를 Pandas DataFrame으로 반환.
    
    :param proc_name: 저장 프로시저 이름 (str).
    :param connection_details: 데이터베이스 연결 정보 (dict).
    :return: Pandas DataFrame.
    """
    print(f"Calling stored procedure: {proc_name}")
    try:
        # 데이터베이스 연결
        conn = pymssql.connect(
            server=connection_details['server'],
            user=connection_details['user'],
            password=connection_details['password'],
            database=connection_details['database']
        )
        cursor = conn.cursor()

        # 저장 프로시저 실행
        cursor.execute(f"EXEC {proc_name}")

        # 결과를 DataFrame으로 변환
        columns = [desc[0] for desc in cursor.description]
        data = cursor.fetchall()
        df = pd.DataFrame(data, columns=columns)

        print(f"Data successfully fetched from procedure: {proc_name}")
        return df

    except Exception as e:
        print(f"Error while calling procedure {proc_name}: {e}")
        return pd.DataFrame()

    finally:
        conn.close()


# 2. DB 연결 정보
connection_details = {
    "server": "localhost",
    "user": "your_username",
    "password": "your_password",
    "database": "your_database"
}

# 3. 데이터 가져오기
print("Fetching data from stored procedures...")
df_test_a = fetch_data_from_procedure_with_cursor("PTestA", connection_details)
df_test_b = fetch_data_from_procedure_with_cursor("PTestB", connection_details)

# 4. 데이터 준비
if df_test_a.empty or df_test_b.empty:
    print("Error: One or more datasets are empty. Check the stored procedures.")
    exit()

# 데이터에서 첫 열(날짜/시간)을 제외한 나머지 값만 추출
data_a = df_test_a.iloc[:, 1:].values
data_b = df_test_b.iloc[:, 1:].values

# 5. 모델 리스트 정의
models = {
    "RandomForest": RandomForestRegressor(),
    "LinearRegression": LinearRegression(),
    "SVR": SVR(kernel="linear")
}

# 6. 데이터 A 학습
print("Starting model training for data_a...")
best_models_a = []
errors_a = []

for i in tqdm(range(data_a.shape[1]), desc="Training models for data_a"):
    try:
        # i번째 값을 제외한 나머지 데이터로 학습 데이터 구성
        X_a = np.delete(data_a, i, axis=1)  # i번째 열을 제외
        y_a = data_a[:, i]  # 예측 대상

        # 데이터 분리 및 학습
        X_train, X_test, y_train, y_test = train_test_split(X_a, y_a, test_size=0.2, random_state=42)

        # 각 모델로 학습 및 평가
        best_model = None
        best_error = float("inf")
        for model_name, model in models.items():
            model.fit(X_train, y_train)
            predictions = model.predict(X_test)
            error = mean_squared_error(y_test, predictions)

            if error < best_error:
                best_error = error
                best_model = model_name

        best_models_a.append((best_model, models[best_model]))
        errors_a.append(best_error)

    except Exception as e:
        print(f"Error during training for data_a column {i}: {e}")
        raise

# 7. 데이터 B 학습 (데이터 A의 특징 참조)
print("Starting model training for data_b...")
best_models_b = []
errors_b = []

for i in tqdm(range(data_b.shape[1]), desc="Training models for data_b"):
    try:
        # i번째 값을 제외한 나머지 데이터로 학습 데이터 구성
        X_b = np.delete(data_b, i, axis=1)  # i번째 열을 제외
        y_b = data_b[:, i]  # 예측 대상

        # 데이터 A 모델의 예측값을 추가 특징으로 사용
        X_a_features = np.array([model.predict(X_b) for _, model in best_models_a]).T
        X_b_with_a = np.hstack([X_b, X_a_features])

        # 데이터 분리 및 학습
        X_train, X_test, y_train, y_test = train_test_split(X_b_with_a, y_b, test_size=0.2, random_state=42)

        # 각 모델로 학습 및 평가
        best_model = None
        best_error = float("inf")
        for model_name, model in models.items():
            model.fit(X_train, y_train)
            predictions = model.predict(X_test)
            error = mean_squared_error(y_test, predictions)

            if error < best_error:
                best_error = error
                best_model = model_name

        best_models_b.append((best_model, models[best_model]))
        errors_b.append(best_error)

    except Exception as e:
        print(f"Error during training for data_b column {i}: {e}")
        raise

# 8. 결과 출력
print("Training completed.")
print("Data A models:", best_models_a)
print("Data B models:", best_models_b)
수정 내용 요약
데이터 분리:

data_a와 data_b를 각각 독립적으로 처리.
상호 참조 추가:

data_a에서 학습된 모델의 예측값을 data_b의 입력에 추가.
두 단계 학습:

첫 번째 단계: data_a를 기반으로 모델 학습.
두 번째 단계: data_a의 모델 예측값을 사용해 data_b 학습.
주석 설명
데이터베이스 호출:

저장 프로시저에서 데이터를 가져오고 첫 열(날짜/시간)을 제외.
데이터 A 학습:

data_a에서 각 열을 독립적으로 예측하고, 최적 모델을 저장.
데이터 B 학습:

data_b의 입력에 data_a 모델의 예측값을 추가하여 학습.
최종 출력:

각 데이터 세트에 대한 최적 모델과 오류를 출력.
결과 예시
data_a 학습:
plaintext
코드 복사
Training models for data_a: 100%|██████████| 4/4 [00:10<00:00,  2.5s/it]
data_b 학습:
plaintext
코드 복사
Training models for data_b: 100%|██████████| 5/5 [00:12<00:00,  2.4s/it]
출력:
plaintext
코드 복사
Training completed.
Data A models: [('RandomForest', RandomForestRegressor()), ...]
Data B models: [('LinearRegression', LinearRegression()), ...]
다음 단계
실시간 데이터 모니터링:
새로운 데이터에 대해 data_a 모델과 data_b 모델을 활용하여 예측값 생성.
결과 분석: