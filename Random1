송합니다. 작업이 순차적으로 시작되지 않는 문제에 대해 해결한 버전을 제공합니다. 순차 작업에서 각 함수가 순서대로 실행되고, 각 함수가 완료된 후 다음 함수가 실행되도록 코드를 수정하겠습니다. 또한, 작업 전체가 순차적으로 진행되며 각 함수 실행 시간을 실시간으로 도형에 표시하고, 최종 실행 시간도 도형에 남도록 처리하겠습니다.

최종 TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    public ObservableCollection<string> FunctionNames { get; set; }
    public ObservableCollection<int> FunctionTimes { get; set; }

    private string _cycleTime;
    public string CycleTime
    {
        get => _cycleTime;
        set
        {
            _cycleTime = value;
            OnPropertyChanged(nameof(CycleTime));
        }
    }

    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    private Stopwatch _overallStopwatch;
    private Stopwatch _functionStopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }

    public Action<TaskModel> StartNextTask { get; set; }

    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending";

        _overallStopwatch = new Stopwatch();
        _functionStopwatch = new Stopwatch();

        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();
        FunctionTimes = new ObservableCollection<int>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);

        _functionCount = SetFunctionListBySequenceFlag(SequenceFlag);
        InitializeFunctionColors(_functionCount);
    }

    /// <summary>
    /// 순차적으로 작업을 실행합니다.
    /// 각 함수가 끝나면 다음 함수가 실행됩니다.
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        Status = "Running";
        ProgressText = "Running...";
        _overallStopwatch.Restart();

        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, ExecuteDynamicTask(i)); // 각 함수가 순차적으로 실행됩니다.
        }

        _overallStopwatch.Stop();
        CycleTime = $"{_overallStopwatch.Elapsed.Seconds} seconds"; // 전체 작업 시간
        Status = "Completed";
        ProgressText = $"Completed in {CycleTime}";

        StartNextTask?.Invoke(this); // 다음 작업을 시작합니다.
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    public async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, ExecuteDynamicTask(taskIndex)); // 단독 함수 실행
    }

    /// <summary>
    /// SequenceFlag에 따라 함수 리스트를 설정하고, 함수 개수를 반환합니다.
    /// </summary>
    private int SetFunctionListBySequenceFlag(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                return 3;

            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                return 3;

            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                return 3;

            default:
                FunctionNames.Add("Task A");
                return 1;
        }
    }

    /// <summary>
    /// 각 함수의 경과 시간을 실시간으로 도형에 표시하고, 완료 후에는 시간을 남깁니다.
    /// </summary>
    private Func<Task> ExecuteDynamicTask(int index)
    {
        return async () =>
        {
            _functionStopwatch.Restart();

            while (_functionStopwatch.IsRunning)
            {
                await Task.Delay(500); // 0.5초마다 실시간 경과 시간 업데이트
                FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds;
                OnPropertyChanged(nameof(FunctionTimes));
            }

            await Task.Delay(1000); // 작업 시뮬레이션
            _functionStopwatch.Stop();
            FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds;
        };
    }

    /// <summary>
    /// 작업이 진행되면 도형 색상을 실시간으로 변경하고, 완료 시 완료 색상으로 바꿉니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 진행 중
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task();

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 완료 후 녹색으로 변경
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상 및 초기값 설정
    /// </summary>
    private void InitializeFunctionColors(int functionCount)
    {
        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray);
            FunctionTimes.Add(0); // 기본 0초로 초기화
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused";
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed";
    }
}
변경된 부분 설명:
순차 작업 실행:

ExecuteTaskSequence 함수에서 함수가 순차적으로 실행됩니다. 각 함수가 완료되면 다음 함수가 실행됩니다. 실행 중인 함수가 완료되지 않으면 다음 함수가 시작되지 않음을 보장합니다.
실시간 경과 시간:

각 함수가 실행될 때마다 실시간으로 경과 시간이 도형에 표시되며, 함수가 완료되면 도형 색상은 녹색으로 변경되고 최종 경과 시간이 도형에 남습니다.
Cycle Time (CT):

전체 작업이 완료되면 **Cycle Time (CT)**이 기록되며, 작업에 소요된 총 시간이 표시됩니다.
단독 함수 실행:

ExecuteSpecificTask 함수로 특정 함수를 우클릭하여 단독으로 실행할 수 있습니다.
함수 개수에 따른 도형 생성:

SetFunctionListBySequenceFlag() 함수는 **SequenceFlag**에 따라 동적으로 실행할 함수 리스트를 설정하고, 해당 함수 개수만큼 도형을 생성합니다.
결론:
이제 순차 작업이 정상적으로 실행되며, 각 함수가 완료된 후에만 다음 함수가 실행됩