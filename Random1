 답답하시겠네요. 디버그 출력에서는 로그가 생성되고 추가되는 것처럼 보이는데 실제 데이터베이스 테이블에는 반영되지 않는다면, 문제는 SaveChanges 호출 자체나 그 이후의 과정, 혹은 데이터베이스 레벨에 있을 가능성이 높습니다.

이전 코드들을 돌이켜보고 다른 원인을 생각해 보겠습니다.

가능한 원인 재점검:

트랜잭션 롤백: MasterDataViewModel의 SaveMasterDataChangesAsync 메서드에서 using (var transaction = _context.Database.BeginTransaction()) 블록을 사용합니다. 이 블록 안에서 _context.SaveChangesAsync() 호출은 성공했지만(로그 추가 포함), 그 이후 transaction.Commit()이 호출되기 전에 다른 예외가 발생하여 catch 블록으로 이동하고 transaction.Rollback()이 호출되면, 로그를 포함한 모든 변경 사항이 취소됩니다. SaveChangesAsync 자체는 성공했지만 트랜잭션 전체가 롤백되는 경우입니다.
데이터베이스 트리거: AuditLogs 테이블에 INSERT 작업을 방해하거나 변경하는 트리거(Trigger)가 설정되어 있을 수 있습니다. 예를 들어, INSTEAD OF INSERT 트리거가 있거나, 로그 삽입 후 다른 작업(예: 삭제)을 수행하는 AFTER INSERT 트리거가 있을 수 있습니다.
데이터베이스 권한: 애플리케이션이 사용하는 데이터베이스 계정에 AuditLogs 테이블에 대한 INSERT 권한이 없을 수 있습니다. (다른 테이블에는 권한이 있어도 특정 테이블에만 없을 수 있습니다.)
잘못된 DB 연결 확인: 혹시 Visual Studio에서 디버깅하며 확인하는 데이터베이스와, 실제로 로그가 저장될 것으로 기대하는 데이터베이스가 다른 경우일 수도 있습니다. App.config의 연결 문자열이 정확히 확인하려는 서버와 데이터베이스를 가리키는지 다시 한번 확인이 필요합니다.
EF6 내부 문제 또는 버그: 매우 드물지만, 사용 중인 Entity Framework 6 버전의 특정 버그로 인해 변경 추적이나 SQL 생성/실행에 문제가 있을 수 있습니다.
진단 및 해결 방향:

트랜잭션 커밋/롤백 확인: MasterDataViewModel의 SaveMasterDataChangesAsync 메서드 내 transaction.Commit() 직전과 catch 블록의 transaction.Rollback() 호출 시점에 디버그 출력을 추가하여 트랜잭션이 실제로 커밋되는지 확인합니다.
로그 데이터 단순화 테스트: LockerDbContext의 CreateAuditEntries 메서드에서 로그 객체(AuditLog)를 생성할 때, OldValues, NewValues, AffectedColumns 등 복잡한 필드를 임시로 비워두고 필수 값(Timestamp, UserName, Action, TableName)만 채워서 저장을 시도해 봅니다. 만약 이렇게 간단한 로그는 저장된다면, JSON 직렬화나 특정 데이터 값에 문제가 있는 것입니다.
SQL Server Profiler 사용 (권장): 데이터베이스 수준에서 어떤 일이 발생하는지 확인하는 가장 확실한 방법입니다. SQL Server Profiler 또는 Extended Events를 사용하여 애플리케이션이 저장 작업을 수행할 때 실제 SQL Server로 전송되는 INSERT INTO AuditLogs... SQL 문이 있는지, 있다면 성공적으로 실행되는지, 아니면 DB 내부에서 오류가 발생하는지 직접 확인합니다.
DB 스키마 및 권한 확인: SQL Server Management Studio(SSMS) 등을 사용하여 AuditLogs 테이블의 스키마(컬럼 타입, Null 허용 여부, 기본 키, 제약 조건)가 C# 모델과 일치하는지, 그리고 애플리케이션 연결 계정에 해당 테이블 INSERT 권한이 있는지 확인합니다.
수정해야 할 파일 목록:

ViewModels/MasterDataViewModel.cs (트랜잭션 로그 추가)
Data/LockerDbContext.cs (로그 데이터 단순화 테스트 옵션 추가)
아래에 이 두 파일의 수정된 전체 코드(주석 제외)를 작성합니다.

1. ViewModels/MasterDataViewModel.cs (수정)

SaveMasterDataChangesAsync 메서드의 트랜잭션 커밋/롤백 부분에 디버그 출력을 추가합니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private bool _disposed = false;

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { if (!App.IsShuttingDown) MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 [MasterData] DB 컨텍스트 생성 오류 무시됨: {ex.Message}"); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }
            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync()); AddItemCommand = new RelayCommand(AddItem, CanAddItemExecute); DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItemExecute); SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync(), CanSaveChangesExecute);
            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null || _disposed) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).ToListAsync(); LockerTypes = new ObservableCollection<LockerType>(lockerTypes); var floors = await _context.Floors.OrderBy(x => x.Name).ToListAsync(); Floors = new ObservableCollection<Floor>(floors); var zones = await _context.Zones.OrderBy(x => x.Name).ToListAsync(); Zones = new ObservableCollection<Zone>(zones); var subParts = await _context.SubParts.OrderBy(x => x.Name).ToListAsync(); SubParts = new ObservableCollection<SubPart>(subParts); var administrators = await _context.Administrators.OrderBy(x => x.Name).ToListAsync(); Administrators = new ObservableCollection<Administrator>(administrators); StatusMessage = "마스터 데이터 로드 완료."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; if (!App.IsShuttingDown && !_disposed) MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 마스터 데이터 로딩 오류 무시됨: {ex.Message}"); } }
        private bool CanAddItemExecute(object parameter) => !_disposed && _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private bool CanDeleteItemExecute(object parameter) => !_disposed && _context != null && SelectedItem != null;
        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private void AddItem(object parameter) { if (!CanAddItemExecute(parameter)) return; if (parameter is string category) { try { object newItem = null; string baseName = "새 항목"; string finalName = ""; switch (category.ToLower()) { case "lockertype": baseName = "새 종류"; finalName = GetUniqueName(baseName, LockerTypes.Select(i => i.Name).ToList()); newItem = _context.LockerTypes.Add(new LockerType { Name = finalName }); LockerTypes.Add((LockerType)newItem); break; case "floor": baseName = "새 층"; finalName = GetUniqueName(baseName, Floors.Select(i => i.Name).ToList()); newItem = _context.Floors.Add(new Floor { Name = finalName }); Floors.Add((Floor)newItem); break; case "zone": baseName = "새 구역"; finalName = GetUniqueName(baseName, Zones.Select(i => i.Name).ToList()); newItem = _context.Zones.Add(new Zone { Name = finalName }); Zones.Add((Zone)newItem); break; case "subpart": baseName = "새 소파트"; finalName = GetUniqueName(baseName, SubParts.Select(i => i.Name).ToList()); newItem = _context.SubParts.Add(new SubPart { Name = finalName }); SubParts.Add((SubPart)newItem); break; case "administrator": baseName = "새 관리자"; finalName = GetUniqueName(baseName, Administrators.Select(i => i.Name).ToList()); newItem = _context.Administrators.Add(new Administrator { Name = finalName }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = $"'{finalName}' 항목이 추가되었습니다. 필요 시 이름 수정 후 저장하세요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; if (!App.IsShuttingDown && !_disposed) MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private string GetUniqueName(string baseName, List<string> existingNames) { string finalName = baseName; int suffix = 1; while (existingNames.Contains(finalName)) { finalName = $"{baseName} {suffix++}"; } return finalName; }
        private void DeleteItem(object parameter) { if (!CanDeleteItemExecute(parameter)) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = SelectedItem; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; if (!App.IsShuttingDown && !_disposed) MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || _disposed || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }

        private async Task SaveMasterDataChangesAsync()
        {
            if (!CanSaveChangesExecute(null)) { StatusMessage = "저장할 변경 사항이 없습니다."; return; }

            var changedNameEntities = _context.ChangeTracker.Entries().Where(e => (e.State == EntityState.Added || e.State == EntityState.Modified) && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).ToList();
            foreach (var entry in changedNameEntities) { string currentName = entry.Property("Name").CurrentValue?.ToString(); int currentId = (int)(entry.Property("Id").CurrentValue ?? 0); if (string.IsNullOrWhiteSpace(currentName)) { MessageBox.Show("마스터 데이터 항목 이름은 비워둘 수 없습니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } bool isDuplicate = false; Type entityType = entry.Entity.GetType(); try { if (entityType == typeof(LockerType)) isDuplicate = await _context.LockerTypes.AnyAsync(e => e.Name == currentName && e.Id != currentId); else if (entityType == typeof(Floor)) isDuplicate = await _context.Floors.AnyAsync(e => e.Name == currentName && e.Id != currentId); else if (entityType == typeof(Zone)) isDuplicate = await _context.Zones.AnyAsync(e => e.Name == currentName && e.Id != currentId); else if (entityType == typeof(SubPart)) isDuplicate = await _context.SubParts.AnyAsync(e => e.Name == currentName && e.Id != currentId); else if (entityType == typeof(Administrator)) isDuplicate = await _context.Administrators.AnyAsync(e => e.Name == currentName && e.Id != currentId); } catch (Exception ex) { HandleGenericExceptionForMasterData("중복 검사 중 DB 오류", ex); return; } if (isDuplicate) { MessageBox.Show($"'{currentName}' 이름은 이미 존재합니다. 다른 이름을 사용해주세요.", "중복 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } }

            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList();
            var unrelatedEntries = _context.ChangeTracker.Entries().Where(e => !(e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator || e.Entity is AuditLog)).ToList();
            if (unrelatedEntries.Any()) { Debug.WriteLine($"경고: MasterDataViewModel 저장 시 관련 없는 엔티티 {unrelatedEntries.Count}개를 Detach합니다."); foreach (var unrelatedEntry in unrelatedEntries) { unrelatedEntry.State = EntityState.Detached; } }

            using (var transaction = _context.Database.BeginTransaction())
            {
                try
                {
                    Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨.");
                    var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, EntityType = e.Entity.GetType(), OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList();
                    Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}");
                    bool cascadeCancelled = false;
                    foreach (var modified in modifiedNameEntries)
                    {
                        if (HasAssociatedAssignments(modified.Entry.Entity, modified.OriginalName))
                        {
                            string msg = $"'{modified.OriginalName}' 값은 현재 다른 사물함에서 사용 중입니다.\n'{modified.CurrentName}' (으)로 변경하면 해당 사물함 정보도 모두 업데이트됩니다.\n\n계속 진행하시겠습니까?";
                            MessageBoxResult result = MessageBox.Show(msg, "연쇄 업데이트 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning);
                            if (result == MessageBoxResult.No) { cascadeCancelled = true; Debug.WriteLine($"사용자가 '{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트를 취소했습니다."); break; }
                        }
                    }

                    if (cascadeCancelled)
                    {
                        Debug.WriteLine("사용자 취소로 트랜잭션 롤백 시도...");
                        transaction.Rollback(); // *** 수정: 롤백 호출 추가 ***
                        Debug.WriteLine("트랜잭션 롤백 완료 (사용자 취소).");
                        StatusMessage = "사용자 요청으로 저장 작업이 취소되었습니다.";
                        RollbackMasterDataChanges(changesForRollback);
                        await LoadAllMasterDataAsync();
                        RaiseCanExecuteChanged();
                        return;
                    }

                    foreach (var modified in modifiedNameEntries)
                    {
                        StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'"); int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType"; else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor"; else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone"; else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart"; else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator";
                        if (!string.IsNullOrEmpty(targetColumn))
                        {
                            updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}";
                            try { updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}"); }
                            catch (Exception sqlEx) { Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}"); StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!"; throw new Exception($"연쇄 업데이트 SQL 실행 실패 ({modified.OriginalName} -> {modified.CurrentName}): {sqlEx.Message}", sqlEx); }
                        } else { Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다."); }
                    }

                    Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)...");
                    int masterDataChanges = await _context.SaveChangesAsync();
                    Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}");

                    transaction.Commit(); // *** 수정: 커밋 로그 추가 ***
                    Debug.WriteLine("트랜잭션 커밋 완료.");
                    StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다.";
                }
                catch (DbEntityValidationException vex) { Debug.WriteLine($"*** 마스터 데이터 SaveChanges 중 DbEntityValidationException 발생! 트랜잭션 롤백 시도...\n*** 오류: {vex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleValidationExceptionForMasterData(vex); RollbackMasterDataChanges(changesForRollback); }
                catch (DbUpdateException dbEx) { Debug.WriteLine($"*** 마스터 데이터 SaveChanges 중 DbUpdateException 발생! 트랜잭션 롤백 시도...\n*** 오류: {dbEx.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleDbUpdateExceptionForMasterData(dbEx); RollbackMasterDataChanges(changesForRollback); }
                catch (Exception ex) { Debug.WriteLine($"*** 마스터 데이터 저장/연쇄 업데이트 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleGenericExceptionForMasterData("마스터 데이터 저장", ex); RollbackMasterDataChanges(changesForRollback); }
            }
            await LoadAllMasterDataAsync();
            RaiseCanExecuteChanged();
        }
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusMessage = "마스터 데이터 변경 롤백됨."; _ = LoadAllMasterDataAsync(); }
        private void HandleDbUpdateExceptionForMasterData(DbUpdateException dbEx) { if (App.IsShuttingDown || _disposed) return; var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusMessage = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleValidationExceptionForMasterData(DbEntityValidationException vex) { if (App.IsShuttingDown || _disposed) return; var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusMessage = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private void HandleGenericExceptionForMasterData(string operation, Exception ex) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 {operation} 오류 무시됨: {ex.Message}"); return; } StatusMessage = $"{operation} 중 오류 발생: {ex.Message}"; MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }

        #endregion

        private void RaiseCanExecuteChanged() { (LoadAllMasterDataCommand as RelayCommand)?.RaiseCanExecuteChanged(); (AddItemCommand as RelayCommand)?.RaiseCanExecuteChanged(); (DeleteItemCommand as RelayCommand)?.RaiseCanExecuteChanged(); (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #region IDisposable 구현
        protected virtual void Dispose(bool disposing) { if (!_disposed) { _disposed = true; if (disposing) { Debug.WriteLine("MasterDataViewModel Dispose 시작..."); try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! MasterDataViewModel DbContext Dispose 오류: {ex.Message}"); } Debug.WriteLine("MasterDataViewModel 리소스 해제 완료."); } } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. Data/LockerDbContext.cs (최종 확인용)

(로그 로직 활성화 및 디버깅 출력 포함된 이전 최종 버전과 동일)

C#

using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        private const string ConnectionStringName = "LockerDbConnection";

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();
            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (로그 로직 활성화 및 디버깅)

        public override int SaveChanges()
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 시작...");
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}"); }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any()) { try { Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 시도..."); this.AuditLogs.AddRange(auditEntries); Debug.WriteLine($"  -> 로그 AddRange 완료."); var addedLogs = this.ChangeTracker.Entries<AuditLog>().Where(e => e.State == EntityState.Added).ToList(); Debug.WriteLine($"  -> ChangeTracker 확인: {addedLogs.Count}개의 AuditLog 엔티티가 Added 상태임."); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
            else { Debug.WriteLine("  -> 추가할 로그 없음 (변경 없거나 로그 생성 실패)."); }

            try { Debug.WriteLine($"  -> base.SaveChanges() 호출 시도..."); var result = base.SaveChanges(); Debug.WriteLine($"  -> base.SaveChanges() 완료. 결과 = {result}"); return result; }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 종료."); }
        }

        public override async Task<int> SaveChangesAsync()
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기) Override 시작...");
             List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}"); }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any()) { try { Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 시도..."); this.AuditLogs.AddRange(auditEntries); Debug.WriteLine($"  -> 로그 AddRange 완료."); var addedLogs = this.ChangeTracker.Entries<AuditLog>().Where(e => e.State == EntityState.Added).ToList(); Debug.WriteLine($"  -> ChangeTracker 확인: {addedLogs.Count}개의 AuditLog 엔티티가 Added 상태임."); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
             else { Debug.WriteLine("  -> 추가할 로그 없음 (변경 없거나 로그 생성 실패)."); }

            try { Debug.WriteLine($"  -> base.SaveChangesAsync() 호출 시도..."); var result = await base.SaveChangesAsync(); Debug.WriteLine($"  -> base.SaveChangesAsync() 완료. 결과 = {result}"); return result; }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기) Override 종료."); }
        }

        private List<AuditLog> CreateAuditEntries() { Debug.WriteLine("  CreateAuditEntries 시작..."); string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser"; var auditEntries = new List<AuditLog>(); var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList(); if (!changedEntries.Any()) { Debug.WriteLine("  CreateAuditEntries: 감지된 변경 엔티티 없음."); return auditEntries; } Debug.WriteLine($"  CreateAuditEntries: 감지된 변경 엔티티 수 = {changedEntries.Count}"); var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None }; foreach (var entry in changedEntries) { if (entry.Entity is AuditLog) { Debug.WriteLine("    - AuditLog 엔티티 변경 감지됨 (로깅 건너뜀)."); continue; } var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() }; try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; } var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>(); if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } } else if (entry.State == EntityState.Modified) { bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } } auditEntries.Add(auditEntry); Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}"); } UpdateLockerAssignmentTimestamps(changedEntries); Debug.WriteLine("  CreateAuditEntries 종료."); return auditEntries; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps: {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        #endregion

        #region Error Logging Helpers
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
핵심 변경 사항:

LockerDbContext.cs:
SaveChanges/SaveChangesAsync 메서드에 로그 생성 및 추가 로직이 활성화되어 있는지 확인하고, 각 단계별로 상세한 Debug.WriteLine 출력을 추가했습니다.
MainViewModel.cs / MasterDataViewModel.cs: 저장 메서드(SaveChangesAsync) 시작 부분에 ChangeTracker 상태를 확인하는 Debug.WriteLine을 추가했습니다.
다음 단계:

코드 적용 및 빌드: 위 코드로 해당 파일들을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
사물함 관리 또는 마스터 데이터 관리 화면에서 데이터를 수정/추가/삭제하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 주의 깊게 확인합니다.