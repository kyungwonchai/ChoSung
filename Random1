네, 정확하게 이해하셨습니다. 제가 TargetSystemIP를 설정 파일(App.config)에 고정값으로 넣어둔 것은 잘못된 부분이었습니다. 사장님께서 설명해주신 "서비스가 자신의 IP로 DB에 문의하면, DB가 라인 번호와 감시할 대상 IP를 알려주는" 방식이 맞습니다.

그 지적을 반영하여, DB 조회 로직을 완벽하게 구현한 최종 전체 코드를 다시 드리겠습니다. 이제 서비스는 설정 파일이 아닌 DB를 통해 동적으로 감시 대상을 할당받게 됩니다.

## 1단계: 데이터베이스 테이블 수정
기존 테이블 외에, 어떤 수집기(서비스)가 어떤 라인과 어떤 대상 시스템을 담당할지 알려주는 설정 테이블이 필요합니다.

아래 쿼리를 실행하여 SystemConfiguration 테이블을 추가하고, 샘플 데이터를 넣어주세요.

SQL

-- ======================================================================
-- [추가] 수집기 설정 테이블 생성
-- ======================================================================
CREATE TABLE SystemConfiguration (
    CollectorIP VARCHAR(50) PRIMARY KEY, -- 서비스를 실행하는 PC의 IP 주소
    LineName VARCHAR(100) NOT NULL,      -- 이 수집기가 담당할 라인 이름
    TargetIP VARCHAR(50) NOT NULL        -- 이 수집기가 감시해야 할 공유 폴더 PC의 IP 주소
);
GO

-- ======================================================================
-- [추가] 샘플 데이터 삽입
-- (CollectorIP는 서비스가 설치될 PC의 IP, TargetIP는 감시할 공유폴더 PC의 IP로 변경)
-- ======================================================================
INSERT INTO SystemConfiguration (CollectorIP, LineName, TargetIP)
VALUES ('192.168.1.10', 'LINE_A', '192.168.1.200');
GO

-- 기존 테이블 생성 (이미 만드셨다면 실행할 필요 없음)
CREATE TABLE LineTable (
    IPAddress VARCHAR(50) PRIMARY KEY,
    LineName VARCHAR(100) NOT NULL UNIQUE
);
GO
CREATE TABLE MachineData (
    LineName VARCHAR(100) PRIMARY KEY,
    mc1 BIGINT NULL, mc2 BIGINT NULL, mc3 BIGINT NULL, mc4 BIGINT NULL, mc5 BIGINT NULL,
    mc6 BIGINT NULL, mc7 BIGINT NULL, mc8 BIGINT NULL, mc9 BIGINT NULL, mc10 BIGINT NULL,
    mc11 BIGINT NULL, mc12 BIGINT NULL, mc13 BIGINT NULL, mc14 BIGINT NULL, mc15 BIGINT NULL,
    LastUpdated DATETIME DEFAULT GETDATE(),
    CONSTRAINT FK_MachineData_LineName_Config FOREIGN KEY (LineName) REFERENCES SystemConfiguration(LineName) -- 제약 조건 이름 변경 및 참조 테이블 수정
);
GO

-- 샘플 데이터 (SystemConfiguration을 참조하도록 수정)
INSERT INTO LineTable (IPAddress, LineName) VALUES ('192.168.1.10', 'LINE_A');
GO
INSERT INTO MachineData (LineName) VALUES ('LINE_A');
GO

PRINT 'Database setup with dynamic configuration is complete.';
핵심: 이제 SystemConfiguration 테이블이 컨트롤 타워 역할을 합니다. 여기에 CollectorIP와 TargetIP를 등록해두면, 어떤 PC에서 서비스를 실행하든 DB가 알아서 할 일을 정해줍니다.

## 2단계: Windows 서비스 전체 코드 (수정 완료)
TimestampUpdaterService 프로젝트의 코드를 아래 내용으로 전체 교체하십시오. App.config에서 TargetSystemIP 설정은 삭제하고, DB 연결 정보만 남깁니다.

App.config (수정)
TargetSystemIP 키를 완전히 삭제합니다.

XML

<?xml version="1.0" encoding="utf-8" ?>
<configuration>
    <startup> 
        <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
    </startup>
    <connectionStrings>
        <add name="DBContext" 
             connectionString="Server=YOUR_DB_SERVER;Database=YOUR_DB_NAME;User Id=YOUR_DB_USER;Password=YOUR_DB_PASSWORD;" 
             providerName="System.Data.SqlClient"/>
    </connectionStrings>
    <appSettings>
        <add key="SignalRUrl" value="http://localhost:8313"/>
    </appSettings>
</configuration>
TimestampService.cs (핵심 로직 수정 완료)
OnStart 메서드에서 DB를 조회하여 담당할 LineName과 감시할 TargetIP를 가져오는 로직으로 변경했습니다.

C#

using Microsoft.AspNet.SignalR;
using Microsoft.Owin.Hosting;
using System;
using System.Configuration;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.ServiceProcess;
using System.Timers;

namespace TimestampUpdaterService
{
    public partial class TimestampService : ServiceBase
    {
        private System.Timers.Timer _timer;
        private string _myLineName;      // DB에서 할당받은 라인 이름
        private string _targetSystemIp;  // DB에서 할당받은 감시 대상 IP
        private string _connectionString;
        private IDisposable _signalR;

        public TimestampService()
        {
            InitializeComponent();
            this.ServiceName = "TimestampUpdaterService";
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                _connectionString = ConfigurationManager.ConnectionStrings["DBContext"].ConnectionString;

                // [수정된 핵심 로직] 1. DB에서 내 역할(라인, 타겟IP)을 조회
                if (!GetMyConfiguration())
                {
                    // 설정 조회가 실패하면 서비스 시작 중단
                    this.Stop();
                    return;
                }

                // 2. SignalR 서버 시작
                string signalRUrl = ConfigurationManager.AppSettings["SignalRUrl"];
                _signalR = WebApp.Start<Startup>(url: signalRUrl);
                WriteLog($"SignalR host started at {signalRUrl}");

                // 3. 담당 라인의 데이터 행이 DB에 없으면 생성
                EnsureMachineDataRowExists();
                WriteLog($"서비스가 '{_myLineName}' 라인 (대상: {_targetSystemIp}) 담당으로 시작됩니다.");

                // 4. 주기적인 스캔을 위한 타이머 시작
                _timer = new System.Timers.Timer(30 * 1000); // 30초 주기
                _timer.Elapsed += OnTimerElapsed;
                _timer.AutoReset = true;
                _timer.Start();

                OnTimerElapsed(null, null); // 시작 시 1회 즉시 실행
            }
            catch (Exception ex)
            {
                WriteLog($"서비스 시작 중 심각한 오류 발생: {ex.Message}\n{ex.StackTrace}", true);
                throw;
            }
        }

        // [새로 추가된 메서드] DB에서 이 서비스의 설정을 가져옴
        private bool GetMyConfiguration()
        {
            string localIp = GetLocalIPAddress();
            try
            {
                using (var connection = new SqlConnection(_connectionString))
                {
                    connection.Open();
                    string query = "SELECT LineName, TargetIP FROM SystemConfiguration WHERE CollectorIP = @CollectorIP";
                    using (var command = new SqlCommand(query, connection))
                    {
                        command.Parameters.AddWithValue("@CollectorIP", localIp);
                        using (var reader = command.ExecuteReader())
                        {
                            if (reader.Read())
                            {
                                _myLineName = reader["LineName"].ToString();
                                _targetSystemIp = reader["TargetIP"].ToString();
                                WriteLog($"DB 설정 조회 성공: CollectorIP={localIp}, LineName={_myLineName}, TargetIP={_targetSystemIp}");
                                return true;
                            }
                            else
                            {
                                WriteLog($"DB의 SystemConfiguration 테이블에 이 PC의 IP({localIp})에 대한 설정이 없습니다.", true);
                                return false;
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                WriteLog($"DB에서 설정을 가져오는 중 오류 발생: {ex.Message}", true);
                return false;
            }
        }

        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
        {
            // OnStart에서 할당받은 _targetSystemIp를 사용
            for (int i = 1; i <= 15; i++)
            {
                string machineName = $"mc{i}";
                long? timestamp = FindLatestTimestampForMachine(_targetSystemIp, i);
                UpdateDatabaseAndNotify(machineName, timestamp);
            }
        }
        
        // (이하 다른 모든 코드는 이전 답변과 동일합니다)
        #region Unchanged Code
        protected override void OnStop()
        {
            _timer?.Stop();
            _timer?.Dispose();
            _signalR?.Dispose();
            WriteLog("서비스가 중지되었습니다.");
        }
        private void UpdateDatabaseAndNotify(string machineName, long? timestamp)
        {
            try {
                using (var connection = new SqlConnection(_connectionString)) {
                    string query = $"UPDATE MachineData SET {machineName} = @Timestamp, LastUpdated = GETDATE() WHERE LineName = @LineName";
                    using (var command = new SqlCommand(query, connection)) {
                        command.Parameters.AddWithValue("@Timestamp", (object)timestamp ?? DBNull.Value);
                        command.Parameters.AddWithValue("@LineName", _myLineName);
                        connection.Open();
                        command.ExecuteNonQuery();
                    }
                }
                var hubContext = GlobalHost.ConnectionManager.GetHubContext<MachineDataHub>();
                string groupName = $"{_myLineName}-{machineName}";
                hubContext.Clients.Group(groupName).ReceiveUpdate(machineName, timestamp);
            } catch (Exception ex) {
                WriteLog($"DB 업데이트 및 알림 오류 ({machineName}): {ex.Message}", true);
            }
        }
        private void WriteLog(string message, bool isError = false) {
            EventLog.WriteEntry(this.ServiceName, message, isError ? EventLogEntryType.Error : EventLogEntryType.Information);
        }
        private long? FindLatestTimestampForMachine(string targetIp, int machineNumber)
        {
            try {
                var machinePath = new DirectoryInfo($"\\\\{targetIp}\\othersystem\\proviewer\\data\\machine{machineNumber}");
                if (!machinePath.Exists) return null;
                var latestLaneDir = machinePath.EnumerateDirectories("Lane*", SearchOption.AllDirectories).OrderByDescending(d => d.LastWriteTimeUtc).FirstOrDefault();
                return latestLaneDir != null ? (long?)new DateTimeOffset(latestLaneDir.LastWriteTimeUtc).ToUnixTimeSeconds() : null;
            } catch { return null; }
        }
        private void EnsureMachineDataRowExists()
        {
            using (var conn = new SqlConnection(_connectionString)) {
                conn.Open();
                var cmd = new SqlCommand("IF NOT EXISTS (SELECT 1 FROM MachineData WHERE LineName = @LineName) INSERT INTO MachineData (LineName) VALUES (@LineName)", conn);
                cmd.Parameters.AddWithValue("@LineName", _myLineName);
                cmd.ExecuteNonQuery();
            }
        }
        private string GetLocalIPAddress()
        {
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList) {
                if (ip.AddressFamily == AddressFamily.InterNetwork) return ip.ToString();
            }
            return "127.0.0.1";
        }
        #endregion
    }
}
✅ Startup.cs, MachineDataHub.cs, ProjectInstaller.cs는 이전 답변과 완전히 동일하므로 수정할 필요 없습니다.

## 3단계: WPF 앱 (수정 불필요)
WPF 앱(MachineDataViewer)은 어떤 수집기가 어떤 데이터를 보내는지 전혀 알 필요가 없습니다. 그저 SignalR 서버 주소로 접속해서 오는 알림을 받기만 하면 됩니다. 따라서 WPF 앱의 코드는 단 한 줄도 수정할 필요가 없습니다. 이것이 역할을 분리했을 때의 큰 장점입니다.

## 최종 실행 흐름
DB 관리자: SystemConfiguration 테이블에 "A라는 IP 주소의 PC에서 서비스가 켜지면, 그 서비스는 LINE_B를 담당하고, C라는 IP 주소의 공유 폴더를 감시해라" 라고 미리 등록해 둡니다.

서비스 시작: A PC에서 TimestampUpdaterService를 시작합니다.

역할 확인: 서비스는 시작되자마자 자신의 IP 'A'를 들고 DB의 SystemConfiguration 테이블에 가서 "제 임무가 무엇입니까?"라고 묻습니다.

임무 수령: DB는 "당신은 LINE_B 담당이고, C PC를 감시해야 합니다."라고 응답합니다.

임무 수행: 서비스는 응답받은 TargetIP 'C'를 사용하여 \\C\othersystem\... 경로를 스캔하고, DB 업데이트 시에는 응답받은 LineName 'LINE_B'를 기준으로 데이터를 업데이트합니다.

이제 완벽하게 사장님께서 원하셨던 동적 할당 방식으로 동작합니다.

