using LockerManagementApp.Models;
using Microsoft.EntityFrameworkCore;
using System.Configuration; // Need to add reference to System.Configuration

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                // Get connection string from App.config
                string connectionString = ConfigurationManager.ConnectionStrings["LockerDbConnection"]?.ConnectionString
                                            ?? "Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;Encrypt=False;"; // Provide a default/fallback

                // Replace "YOUR_SERVER_NAME" with your actual SQL Server instance name (e.g., localhost, SQLEXPRESS, server.domain.com)
                // Use Integrated Security (Trusted_Connection=True) or SQL Server Authentication (User ID=your_user;Password=your_password;)
                // Encrypt=False is used for simplicity here, but consider setting it to True for production environments if SSL is configured on SQL Server.

                optionsBuilder.UseSqlServer(connectionString);
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure unique constraint on the physical locker location if desired
            // This ensures you can't accidentally create two DB entries for the same physical locker.
            // modelBuilder.Entity<LockerAssignment>()
            //    .HasIndex(l => new { l.Floor, l.Zone, l.SpecificLocation })
            //    .IsUnique();

            // Set default value behavior if needed (though handled by SQL DEFAULT constraint)
            // modelBuilder.Entity<LockerAssignment>()
            //     .Property(l => l.LastUpdated)
            //     .HasDefaultValueSql("GETDATE()");

            base.OnModelCreating(modelBuilder);
        }

        // Optional: Override SaveChanges to automatically update LastUpdated timestamp
        public override int SaveChanges()
        {
            UpdateTimestamps();
            return base.SaveChanges();
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            UpdateTimestamps();
            return base.SaveChangesAsync(cancellationToken);
        }

        private void UpdateTimestamps()
        {
            var entries = ChangeTracker
                .Entries()
                .Where(e => e.Entity is LockerAssignment && (
                        e.State == EntityState.Added ||
                        e.State == EntityState.Modified));

            foreach (var entityEntry in entries)
            {
                ((LockerAssignment)entityEntry.Entity).LastUpdated = DateTime.Now;

                // Optionally: Set Administrator here if you have a way to know the current user
                // ((LockerAssignment)entityEntry.Entity).Administrator = GetCurrentAdminUser();
            }
        }
    }