습니다. 기존의 복잡한 System.Drawing.Graphics 코드를 재사용해야 하는 상황이시군요. 문제없습니다.

WPF 환경에서 GDI+ 코드를 안전하게 통합하려면, WPF BitmapImage를 GDI+ Bitmap으로 변환하고, 그리기 작업이 끝나면 **다시 WPF용 BitmapSource로 되돌리는 '변환 파이프라인'**을 만들어야 합니다.

핵심은 그리기 작업을 하나의 독립된 함수로 캡슐화하여 필요할 때마다 호출하는 것입니다.

## 핵심 처리 흐름
파일 선택: LoadNewImage() 함수를 호출해 모든 상태를 초기화하고 원본 originalBitmapImage를 로드합니다.

그리기 실행:

originalBitmapImage (WPF)를 System.Drawing.Bitmap (GDI+)으로 변환합니다.

변환된 GDI+ Bitmap을 Graphics.FromImage()에 넘겨 복잡한 그리기 로직을 수행합니다.

그리기가 완료된 GDI+ Bitmap을 다시 WPF BitmapSource로 변환하여 돌려받습니다.

자르기 실행: 위에서 그려진 결과물(BitmapSource)을 가지고 CroppedBitmap 작업을 수행합니다.

## 통합 코드 예시
아래 코드는 파일 선택 -> GDI+로 그리기 -> 자르기의 전체 흐름을 안전하게 처리합니다.

C#

using System.IO; // MemoryStream을 위해 추가
using System.Drawing; // System.Drawing.Bitmap, Graphics 등을 위해 추가
using System.Windows.Media.Imaging; // BitmapImage, CroppedBitmap 등을 위해 추가

// ... 클래스 내부 ...

private BitmapImage originalBitmapImage; // 파일에서 로드한 원본을 저장하는 변수

// 1. 새 파일 로드 및 상태 초기화 함수 (이전 답변과 동일)
private void LoadNewImage(string filePath)
{
    try
    {
        originalBitmapImage = new BitmapImage();
        originalBitmapImage.BeginInit();
        originalBitmapImage.UriSource = new Uri(filePath);
        originalBitmapImage.CacheOption = BitmapCacheOption.OnLoad;
        originalBitmapImage.EndInit();
        originalBitmapImage.Freeze();

        imageControl.Source = originalBitmapImage;
        // 다른 관련 변수들도 모두 초기화...
    }
    catch (Exception ex)
    {
        MessageBox.Show($"이미지 로드 실패: {ex.Message}");
        originalBitmapImage = null;
    }
}


// ★★★ 2. GDI+ 그리기 작업을 캡슐화한 함수 ★★★
private BitmapSource DrawWithGdi(BitmapSource source)
{
    // [1단계: WPF BitmapSource -> GDI+ Bitmap 변환]
    System.Drawing.Bitmap gdiBitmap;
    using (var ms = new MemoryStream())
    {
        // Png 포맷으로 인코딩하여 스트림에 저장
        var encoder = new PngBitmapEncoder();
        encoder.Frames.Add(BitmapFrame.Create(source));
        encoder.Save(ms);
        ms.Position = 0; // 스트림 위치를 처음으로 리셋

        // 스트림으로부터 GDI+ 비트맵 생성
        gdiBitmap = new System.Drawing.Bitmap(ms);
    }

    // [2단계: 기존 GDI+ 그리기 로직 실행]
    // using 블록으로 Graphics 객체를 안전하게 사용
    using (Graphics g = Graphics.FromImage(gdiBitmap))
    {
        //
        // ★★★ 바로 이 부분에 기존의 복잡한 그리기 코드를 넣거나 호출합니다. ★★★
        // 예시: 빨간 사각형과 파란 텍스트 그리기
        g.FillRectangle(System.Drawing.Brushes.Red, new System.Drawing.Rectangle(10, 10, 100, 100));
        g.DrawString("Complex GDI+", new Font("Arial", 16), System.Drawing.Brushes.Blue, 20, 20);
        //
    }

    // [3단계: GDI+ Bitmap -> WPF BitmapSource 변환]
    // using 블록으로 스트림을 안전하게 사용
    using (var ms = new MemoryStream())
    {
        // 수정된 GDI+ 비트맵을 스트림에 저장
        gdiBitmap.Save(ms, System.Drawing.Imaging.ImageFormat.Png);
        ms.Position = 0;

        // 스트림으로부터 WPF 비트맵 생성
        var finalBitmapSource = new BitmapImage();
        finalBitmapSource.BeginInit();
        finalBitmapSource.StreamSource = ms;
        finalBitmapSource.CacheOption = BitmapCacheOption.OnLoad;
        finalBitmapSource.EndInit();
        finalBitmapSource.Freeze();

        // GDI+ 비트맵 리소스 해제
        gdiBitmap.Dispose();

        return finalBitmapSource;
    }
}


// 3. 그리기와 자르기를 실행하는 버튼 이벤트
private void ProcessImageButton_Click(object sender, RoutedEventArgs e)
{
    if (originalBitmapImage == null)
    {
        MessageBox.Show("먼저 이미지를 선택해주세요.");
        return;
    }

    // 1. GDI+로 그리기 실행
    BitmapSource drawnImage = DrawWithGdi(originalBitmapImage);

    // 2. 그려진 결과를 바탕으로 자르기 실행
    Int32Rect cropArea = new Int32Rect(0, 0, 200, 200); // 자를 영역 예시

    // 유효성 검사 (이제 그려진 이미지를 기준으로 검사)
    if (cropArea.X + cropArea.Width > drawnImage.PixelWidth ||
        cropArea.Y + cropArea.Height > drawnImage.PixelHeight)
    {
        MessageBox.Show("자르기 영역이 그려진 이미지 크기를 벗어났습니다.");
        imageControl.Source = drawnImage; // 자르기 실패 시 그려진 이미지만 표시
        return;
    }

    CroppedBitmap finalResult = new CroppedBitmap(drawnImage, cropArea);

    // 3. 최종 결과를 화면에 표시
    imageControl.Source = finalResult;
}
핵심 요약
DrawWithGdi 함수처럼 변환 -> 그리기 -> 변환 과정을 하나의 함수로 만드세요.

MemoryStream과 Graphics, Bitmap 객체는 반드시 using 블록으로 감싸 메모리 누수를 완벽하게 방지해야 합니다.

그리기 버튼을 누르면 원본(originalBitmapImage)을 DrawWithGdi 함수에 넣고, 그 결과물을 가지고 자르기 등 다음 작업을 진행하세요.

