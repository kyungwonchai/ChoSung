프로젝트 구조
MainWindow.xaml
MainWindow.xaml.cs
SettingsManager.cs
MLModelBuilder.cs
FileCleaner.cs
1. MainWindow.xaml
xml
코드 복사
<Window x:Class="SMDFileCleaner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="SMD File Cleaner" Height="450" Width="800">
    <Grid>
        <StackPanel>
            <TextBox Name="txtFolderPath" Width="400" Margin="10" GotFocus="TextBox_GotFocus" LostFocus="TextBox_LostFocus" Text="Enter folder path"/>
            <TextBox Name="txtFileExtension" Width="400" Margin="10" GotFocus="TextBox_GotFocus" LostFocus="TextBox_LostFocus" Text="Enter file extension (e.g., .jpg)"/>
            <TextBox Name="txtDriveName" Width="400" Margin="10" GotFocus="TextBox_GotFocus" LostFocus="TextBox_LostFocus" Text="Enter drive name (e.g., C:)"/>
            <Button Name="btnStart" Content="Start Cleaning" Width="200" Margin="10" Click="btnStart_Click"/>
            <Button Name="btnSaveSettings" Content="Save Settings" Width="200" Margin="10" Click="btnSaveSettings_Click"/>
            <Button Name="btnLoadSettings" Content="Load Settings" Width="200" Margin="10" Click="btnLoadSettings_Click"/>
            <ListBox Name="lstRecentLogs" Width="750" Height="150" Margin="10"/>
            <ListBox Name="lstDeletionLogs" Width="750" Height="150" Margin="10"/>
            <TextBlock Text="Current Pattern Rules:" Margin="10"/>
            <TextBlock Name="txtCurrentPatterns" Width="750" Height="50" Margin="10"/>
        </StackPanel>
    </Grid>
</Window>
2. MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private string logDirectory = @"C:\agent\SMDFIleClean";
        private MLModelBuilder _mlModelBuilder;
        private SettingsManager _settingsManager;

        public MainWindow()
        {
            InitializeComponent();
            _mlModelBuilder = new MLModelBuilder();
            _settingsManager = new SettingsManager();
            LoadSettings();
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                SaveSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnLoadSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                LoadSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void SaveSettings()
        {
            try
            {
                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = txtFileExtension.Text,
                    DriveName = txtDriveName.Text
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "Enter folder path";
                    txtFileExtension.Text = settings.FileExtension ?? "Enter file extension (e.g., .jpg)";
                    txtDriveName.Text = settings.DriveName ?? "Enter drive name (e.g., C:)";
                }
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private async void btnStart_Click(object sender, RoutedEventArgs e)
        {
            string folderPath = txtFolderPath.Text;
            string fileExtension = txtFileExtension.Text;
            string driveName = txtDriveName.Text;

            if (string.IsNullOrEmpty(folderPath) || folderPath == "Enter folder path" ||
                string.IsNullOrEmpty(fileExtension) || fileExtension == "Enter file extension (e.g., .jpg)" ||
                string.IsNullOrEmpty(driveName) || driveName == "Enter drive name (e.g., C:)")
            {
                MessageBox.Show("Please provide all inputs.");
                return;
            }

            try
            {
                var initialFiles = CollectInitialFileData(folderPath, fileExtension);
                _mlModelBuilder.TrainModel(initialFiles);

                await MonitorAndCleanFiles(folderPath, fileExtension, driveName);
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private List<FileData> CollectInitialFileData(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories);

                var fileDataList = files.Select(f => new FileData
                {
                    Hour = f.CreationTime.Hour,
                    DayOfWeek = (int)f.CreationTime.DayOfWeek
                }).ToList();

                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = $"Training on {files.Length} files";
                });

                return fileDataList;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return new List<FileData>();
            }
        }

        private async Task MonitorAndCleanFiles(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = GetDriveFreeSpace(driveName);
                    if (freeSpace < MinimumFreeSpace)
                    {
                        List<FileInfo> filesToDelete = GetFilesToDelete(folderPath, fileExtension);
                        await DeleteFilesAsync(filesToDelete);
                    }

                    UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return 0;
            }
        }

        private List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories)
                                      .OrderBy(f => f.CreationTime)
                                      .ToList();

                var filesToDelete = files.Where(file => _mlModelBuilder.Predict(file)).ToList();

                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = $"Monitoring {files.Count} files. {filesToDelete.Count} files marked for deletion.";
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return new List<FileInfo>();
            }
        }

        private async Task DeleteFilesAsync(List<FileInfo> files)
        {
            foreach (var file in files)
            {
                try
                {
                    file.Delete();
                    LogDeletion(file.FullName);
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories);
                long totalSize = files.Sum(f => f.Length);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add($"Folder: {folderPath}, Total Size: {totalSize / (1024 * 1024)} MB");
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogDeletion(string filePath)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "yyyyMMddlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: Deleted {filePath}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstDeletionLogs.Items.Add(logMessage);
                    if (lstDeletionLogs.Items.Count > 200)
                    {
                        lstDeletionLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add(logMessage);
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                // 에러 로깅에 실패한 경우 추가 조치 없음
            }
        }

        private void TextBox_GotFocus(object sender, RoutedEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if (textBox.Text == "Enter folder path" || textBox.Text == "Enter file extension (e.g., .jpg)" || textBox.Text == "Enter drive name (e.g., C:)")
                {
                    textBox.Text = string.Empty;
                }
            }
        }

        private void TextBox_LostFocus(object sender, RoutedEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if (string.IsNullOrWhiteSpace(textBox.Text))
                {
                    if (textBox.Name == "txtFolderPath")
                    {
                        textBox.Text = "Enter folder path";
                    }
                    else if (textBox.Name == "txtFileExtension")
                    {
                        textBox.Text = "Enter file extension (e.g., .jpg)";
                    }
                    else if (textBox.Name == "txtDriveName")
                    {
                        textBox.Text = "Enter drive name (e.g., C:)";
                    }
                }
            }
        }
    }
}
3. SettingsManager.cs
csharp
코드 복사
using System;
using System.IO;
using System.Xml.Linq;

namespace SMDFileCleaner
{
    public class SettingsManager
    {
        private readonly string settingsFilePath = "settings.xml";

        public void SaveSettings(Settings settings)
        {
            try
            {
                var settingsXml = new XElement("Settings",
                    new XElement("FolderPath", settings.FolderPath),
                    new XElement("FileExtension", settings.FileExtension),
                    new XElement("DriveName", settings.DriveName)
                );

                settingsXml.Save(settingsFilePath);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to save settings.", ex);
            }
        }

        public Settings LoadSettings()
        {
            try
            {
                if (File.Exists(settingsFilePath))
                {
                    var settingsXml = XElement.Load(settingsFilePath);
                    return new Settings
                    {
                        FolderPath = settingsXml.Element("FolderPath")?.Value,
                        FileExtension = settingsXml.Element("FileExtension")?.Value,
                        DriveName = settingsXml.Element("DriveName")?.Value
                    };
                }
                return null;
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to load settings.", ex);
            }
        }
    }

    public class Settings
    {
        public string FolderPath { get; set; }
        public string FileExtension { get; set; }
        public string DriveName { get; set; }
    }
}
4. MLModelBuilder.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileData> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileData>();
        }

        public void TrainModel(List<FileData> fileData)
        {
            try
            {
                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);
                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileData.Hour), nameof(FileData.DayOfWeek))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model.", ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileData
                {
                    Hour = fileInfo.CreationTime.Hour,
                    DayOfWeek = (int)fileInfo.CreationTime.DayOfWeek
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileData, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification.", ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var patternGroups = _fileDataList.GroupBy(f => new { f.Hour, f.DayOfWeek })
                    .Select(g => new { g.Key.Hour, g.Key.DayOfWeek, Count = g.Count() })
                    .OrderByDescending(g => g.Count);

                return string.Join(", ", patternGroups.Select(g => $"Hour: {g.Hour}, Day: {g.DayOfWeek}, Count: {g.Count}"));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns.", ex);
            }
        }
    }

    public class FileData
    {
        public float Hour { get; set; }
        public float DayOfWeek { get; set; }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
5. FileCleaner.cs
이 파일에는 파일 삭제와 관련된 로직이 포함됩니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;

        public FileCleaner(string logDirectory, MLModelBuilder mlModelBuilder, Dispatcher dispatcher)
        {
            this.logDirectory = logDirectory;
            this.mlModelBuilder = mlModelBuilder;
            this.dispatcher = dispatcher;
        }

        public async Task MonitorAndCleanFiles(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = GetDriveFreeSpace(driveName);
                    if (freeSpace < MinimumFreeSpace)
                    {
                        List<FileInfo> filesToDelete = GetFilesToDelete(folderPath, fileExtension);
                        await DeleteFilesAsync(filesToDelete);
                    }

                    UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return 0;
            }
        }

        private List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories)
                                      .OrderBy(f => f.CreationTime)
                                      .ToList();

                var filesToDelete = files.Where(file => mlModelBuilder.Predict(file)).ToList();

                dispatcher.Invoke(() =>
                {
                    // 현재 패턴을 UI에 업데이트
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return new List<FileInfo>();
            }
        }

        private async Task DeleteFilesAsync(List<FileInfo> files)
        {
            foreach (var file in files)
            {
                try
                {
                    file.Delete();
                    LogDeletion(file.FullName);
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories);
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    // 폴더 통계를 UI에 업데이트
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogDeletion(string filePath)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "yyyyMMddlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: Deleted {filePath}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                dispatcher.Invoke(() =>
                {
                    // 삭제 로그를 UI에 업데이트
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);
            }
            catch (Exception)
            {
                // 에러 로깅에 실패한 경우 추가 조치 없음
            }
        }
    }
}
설명
UI 구성: MainWindow.xaml에서 기본 UI를 정의합니다.
설정 저장 및 불러오기: SettingsManager 클래스를 통해 설정을 XML 파일에 저장하고 불러옵니다.
머신러닝 모델: MLModelBuilder 클래스를 통해 파일 생성 패턴을 분석하고 예측합니다.
파일 클리너: FileCleaner 클래스에서 파일을 모니터링하고, 조건에 맞는 파일을 삭제합니다.
예외 처리: 모든 주요 함수에 예외 처리를 추가하여 프로그램이 종료되지 않도록 합니다.
이제 전체 프로그램이 자동으로 설정을 저장하고 불러오며, 주기적으로 파일을 모니터링하고 삭제할 수 있습니다. 머신러닝 모델은 파일 생성 패턴을 분석하고, 현재 적용 중인 패턴을 UI에 표시합니다.