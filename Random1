def train_model(new_df_data, epochs=10, batch_size=64):
    new_df_data = filter_recent_data(new_df_data)  # 🔥 3개월 지난 데이터 제외

    # 기존 모델 불러오기
    model, encoder, scaler, max_qr_length = load_model()

    if model is None:
        print("🔴 기존 모델 없음. 새로 학습 시작.")
        encoder = LabelEncoder()
        full_df_data = new_df_data  # 새 데이터만 학습
    else:
        print("🟢 기존 모델 로드됨. 기존 + 추가 학습 진행.")
        old_df_data = load_data_from_mssql()  # 🔥 기존 데이터도 가져와서 유지
        full_df_data = pd.concat([old_df_data, new_df_data]).drop_duplicates().reset_index(drop=True)

    # QR 값, 모델명 추출
    qr_values = full_df_data["QR"].values
    model_names = full_df_data["Model"].values

    # ✅ 기존 encoder 유지하면서 새로운 데이터도 반영
    if model is None:
        encoder.fit(model_names)
    else:
        encoder.classes_ = np.concatenate((encoder.classes_, np.setdiff1d(model_names, encoder.classes_)))

    y_encoded = encoder.transform(model_names)

    max_qr_length = max(len(qr) for qr in qr_values)
    X_vectorized = vectorize_qr(qr_values, max_qr_length)
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X_vectorized)

    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_encoded, test_size=0.2, random_state=42)

    train_dataset = data_utils.TensorDataset(torch.tensor(X_train, dtype=torch.float32),
                                             torch.tensor(y_train, dtype=torch.long))
    train_loader = data_utils.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

    # ✅ 기존 모델 유지하면서, 출력 레이어 크기만 업데이트
    num_classes = len(encoder.classes_)
    if model is None:
        model = QRModel(X_train.shape[1], num_classes).to(device)
    elif model.fc4.out_features != num_classes:
        print(f"🔄 출력 레이어 크기 변경: {model.fc4.out_features} → {num_classes}")
        model.fc4 = nn.Linear(32, num_classes).to(device)  # 새로운 클래스 추가 반영

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    # 🔥 기존 데이터 유지한 채 추가 학습
    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()

        print(f"Epoch [{epoch+1}/{epochs}], Loss: {total_loss/len(train_loader):.4f}")

    save_model(model, encoder, scaler, max_qr_length)