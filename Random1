쿼리는 데이터를 영구적으로 삭제하므로, 실행하기 전에 반드시 데이터베이스의 백업을 수행하고, 테스트 환경에서 먼저 실행하여 예상대로 동작하는지 확인하는 것이 중요합니다.




User
WITH LotChanges AS (
    SELECT *,
           CASE 
               WHEN LAG(lotname) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1) = lotname THEN 0 
               ELSE 1 
           END AS IsNewLot
    FROM LOG_MEV_Backup
),
LotGroups AS (
    SELECT *,
           SUM(IsNewLot) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SubGroupID
    FROM LotChanges
),
RankedLots AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY line1, machine1, lane1, tb, SubGroupID ORDER BY datetime1) AS rn
    FROM LotGroups
)
UPDATE LOG_MEV_Backup
SET xxx = CASE 
            WHEN RankedLots.rn <= 20 THEN 1
            ELSE 0
          END
FROM LOG_MEV_Backup
INNER JOIN RankedLots
ON LOG_MEV_Backup.line1 = RankedLots.line1
   AND LOG_MEV_Backup.machine1 = RankedLots.machine1
   AND LOG_MEV_Backup.lane1 = RankedLots.lane1
   AND LOG_MEV_Backup.lotname = RankedLots.lotname
   AND LOG_MEV_Backup.tb = RankedLots.tb
   AND LOG_MEV_Backup.datetime1 = RankedLots.datetime1;
이걸 수정좀 해서...  datatime1 정렬했을때 가장 마지막부분 5개까지도 처리해줘.. 그건 xxx를 2로

ChatGPT
알겠습니다. 기존 쿼리를 수정하여 datetime1 기준으로 각 서브그룹 내에서 마지막 5개 로우에 대해 xxx 컬럼을 2로 설정하도록 하겠습니다. 이를 위해 RankedLots CTE(Common Table Expression) 내에서 ROW_NUMBER()를 역순으로 계산하는 추가 컬럼을 생성하고, 이를 기반으로 xxx 컬럼을 업데이트하는 로직을 추가하겠습니다.