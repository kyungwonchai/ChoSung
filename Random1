해했습니다. 메인 뷰모델을 통해 다른 클래스의 이벤트를 거치지 않고, SignalRClient와 직접적으로 상호작용하는 방식으로 싱글톤 패턴을 적용해 드리겠습니다. 다시 말해, MainViewModel과 SignalRClient가 직접 상호작용하고, 이 둘을 이용해 메시지를 보내고 응답을 처리하는 구조로 구성하겠습니다. 이때, SignalRClient는 싱글톤으로 유지되며, 다른 모든 클래스들이 MainViewModel과 상호작용하지 않도록 설계합니다.

아래는 각 클래스의 구성입니다.

1. SignalRClient 클래스 (전문적인 싱글톤 처리 및 메시지 전송/응답 관리)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR.Client;

public class SignalRClient
{
    private static SignalRClient _instance;  // Singleton 인스턴스
    private HubConnection _hubConnection;    // SignalR 연결 객체

    // 보낸 메시지와 응답을 처리하는 콜백
    public Action<string, string> OnMessageSentAndResponse { get; set; }  // 메시지와 응답 콜백
    public Action<string> OnLogMessage { get; set; }  // 로그 콜백

    // Singleton 패턴 인스턴스 반환
    public static SignalRClient Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new SignalRClient();
            }
            return _instance;
        }
    }

    // SignalRClient 생성자는 private로 외부에서 인스턴스 생성을 제한
    private SignalRClient() { }

    // SignalR 서버와 연결하는 메서드 (비동기)
    public async Task InitializeSignalRConnectionAsync(string hubUrl)
    {
        try
        {
            if (_hubConnection == null || _hubConnection.State != HubConnectionState.Connected)
            {
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl(hubUrl)  // 서버 URL 설정
                    .Build();

                // 서버에서 클라이언트로 응답 메시지를 받을 준비 (서버에서 응답 시 호출됨)
                _hubConnection.On<string>("ReceiveResponse", (responseMessage) =>
                {
                    OnMessageSentAndResponse?.Invoke(null, responseMessage);  // 서버 응답 콜백 호출
                });

                // SignalR 연결 시작
                await _hubConnection.StartAsync();
                Log("SignalR Connection Started");
            }
        }
        catch (Exception ex)
        {
            // 연결 중 오류 발생 시 로그 기록
            LogError(ex.Message);
        }
    }

    // 서버로 메시지를 전송하는 메서드 (비동기)
    public async Task SendMessageAsync(string message)
    {
        try
        {
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                // 서버로 메시지 전송
                await _hubConnection.InvokeAsync("SendMessage", message);
                Log($"Message sent: {message}");

                // 메시지 전송 후, 응답 대기 상태로 처리
                OnMessageSentAndResponse?.Invoke(message, "Waiting for response...");
            }
            else
            {
                LogError("SignalR is not connected.");
            }
        }
        catch (Exception ex)
        {
            // 전송 중 오류 발생 시 로그 기록
            LogError(ex.Message);
        }
    }

    // 로그 메시지 기록 함수
    private void Log(string message)
    {
        OnLogMessage?.Invoke(message);  // 로그 메시지 콜백 호출
    }

    // 에러 로그 기록 함수
    private void LogError(string errorMessage)
    {
        Log($"Error: {errorMessage}");  // 에러 로그 기록
    }
}
2. MainViewModel 클래스 (SignalRClient와 직접 상호작용하여 DataGrid 업데이트)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

public class MainViewModel : INotifyPropertyChanged
{
    private string _logMessage;

    // DataGrid에 표시할 메시지 목록 (최대 30개 유지)
    public ObservableCollection<MessageModel> Messages { get; set; } = new ObservableCollection<MessageModel>();

    // 로그 메시지 (UI에 표시할 로그)
    public string LogMessage
    {
        get { return _logMessage; }
        set
        {
            _logMessage = value;
            OnPropertyChanged();
        }
    }

    // INotifyPropertyChanged 구현
    public event PropertyChangedEventHandler PropertyChanged;

    // 생성자: SignalRClient를 초기화하고 직접 상호작용
    public MainViewModel()
    {
        // SignalR 서버 연결 설정
        InitializeSignalR();

        // SignalRClient와 상호작용하는 로직 설정
        SignalRClient.Instance.OnLogMessage = (logMessage) => LogMessage = logMessage;  // 로그 메시지 처리
        SignalRClient.Instance.OnMessageSentAndResponse = (sentMessage, responseMessage) =>
        {
            // 메시지 전송 후 응답을 받을 때 DataGrid 업데이트
            if (sentMessage != null)
            {
                AddMessageToDataGrid(DateTime.Now.ToString("yyyyMMdd HHmmssfff"), sentMessage, responseMessage);
            }
            else
            {
                // 응답 메시지만 처리하는 경우, 마지막 메시지 업데이트
                if (Messages.Count > 0)
                {
                    var lastMessage = Messages[^1];
                    lastMessage.Response = responseMessage;
                }
            }
        };
    }

    // SignalR 서버와의 연결 초기화
    private async void InitializeSignalR()
    {
        await SignalRClient.Instance.InitializeSignalRConnectionAsync("http://localhost:5000/myhub");
    }

    // DataGrid에 표시할 메시지를 추가하는 메서드 (최대 30개 유지)
    private void AddMessageToDataGrid(string sentTime, string sentMessage, string response)
    {
        if (Messages.Count >= 30)
        {
            Messages.RemoveAt(0);  // 30개를 넘으면 오래된 항목 제거
        }

        // 새 메시지 추가
        Messages.Add(new MessageModel
        {
            SentTime = sentTime,
            SentMessage = sentMessage,
            Response = response
        });
    }

    // UI에서 속성 변경을 알리는 메서드
    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }

    // 버튼 클릭 시 메시지 전송하는 메서드 (SignalRClient 사용)
    public async void SendMessage(string message)
    {
        await SignalRClient.Instance.SendMessageAsync(message);
    }
}
3. MessageModel 클래스 (DataGrid에 표시할 데이터 모델)
csharp
코드 복사
// 메시지 모델 클래스: DataGrid에 보낼 메시지와 응답을 표시하는 구조체
public class MessageModel
{
    public string SentTime { get; set; }    // 메시지 보낸 시간
    public string SentMessage { get; set; } // 보낸 메시지
    public string Response { get; set; }    // 서버 응답 메시지
}
4. MainWindow.xaml (UI - DataGrid 포함)
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- DataGrid to display messages -->
        <DataGrid ItemsSource="{Binding Messages}" AutoGenerateColumns="False" Height="350" VerticalAlignment="Top">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Sent Time" Binding="{Binding SentTime}" Width="200"/>
                <DataGridTextColumn Header="Sent Message" Binding="{Binding SentMessage}" Width="300"/>
                <DataGridTextColumn Header="Response" Binding="{Binding Response}" Width="300"/>
            </DataGrid.Columns>
        </DataGrid>

        <!-- Log Message TextBlock -->
        <TextBlock Text="{Binding LogMessage}" VerticalAlignment="Bottom" HorizontalAlignment="Center" Margin="10"/>
    </Grid>
</Window>
5. MainWindow.xaml.cs (MainViewModel과 UI 연결)
csharp
코드 복사
using System.Windows;

public partial class MainWindow : Window
{
    private MainViewModel _viewModel;

    public MainWindow()
    {
        InitializeComponent();
        _viewModel = new MainViewModel();
        DataContext = _viewModel;  // ViewModel을 DataContext로 설정
    }

    // 버튼을 눌렀을 때 메시지 전송하는 메서드 (예시로 추가)
    private void OnSendButtonClick(object sender, RoutedEventArgs e)
    {
        string message = "This is a test message";  // 보낼 메시지 설정
        _viewModel.SendMessage(message);  // ViewModel에서 메시지 전송
    }
}
설명
SignalRClient 클래스: