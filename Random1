합니다. 상황을 더 명확히 이해했습니다. App.xaml.cs에서 MainWindow의 정적 메서드를 호출할 때 MainWindow 클래스가 제대로 인식되지 않는 문제를 해결해야 합니다.

다시 한 번 전체 구조를 명확하게 정리하겠습니다. MainWindow를 싱글톤 패턴으로 구현하고, App.xaml.cs에서 이를 참조할 수 있도록 하겠습니다. 이렇게 하면 App.xaml.cs에서 MainWindow의 정적 메서드를 호출할 수 있습니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Runtime.InteropServices;
using System.Windows;
using DevExpress.Xpf.Core;
using DevExpress.Xpf.Layout.Core;

namespace ClipboardApp
{
    public partial class MainWindow : DXWindow
    {
        private static MainWindow _instance;
        public static MainWindow Instance
        {
            get { return _instance; }
        }

        // 외부 DLL 호출
        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll")]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        public MainWindow()
        {
            InitializeComponent();
            LoadClipboardContent();
            _instance = this; // 현재 인스턴스를 저장합니다.
        }

        private void LoadClipboardContent()
        {
            if (Clipboard.ContainsText())
            {
                string clipboardText = Clipboard.GetText();
                myTextBox.Text = clipboardText;
            }
        }

        public void DockNewWindow(string content)
        {
            NewWindow newWindow = new NewWindow
            {
                Owner = this
            };
            newWindow.newTextBox.Text = content;

            var newPanel = new LayoutPanel
            {
                Content = newWindow.Content,
                Caption = "New Tab"
            };

            dockLayoutManager.DockController.Dock(newPanel, dockLayoutManager.LayoutRoot, DockType.Fill);
        }

        public static void ActivateExistingInstance(string content)
        {
            if (_instance != null)
            {
                _instance.Dispatcher.Invoke(() =>
                {
                    IntPtr hWnd = FindWindow(null, "Clipboard App");
                    if (hWnd != IntPtr.Zero)
                    {
                        SetForegroundWindow(hWnd);
                        _instance.DockNewWindow(content);
                    }
                });
            }
        }
    }
}
App.xaml.cs
App.xaml.cs에서 MainWindow 인스턴스를 생성하고 관리합니다. 여기서 MainWindow를 참조할 수 있게 하는 방법입니다.

csharp
코드 복사
using System;
using System.Threading;
using System.Windows;

namespace ClipboardApp
{
    public partial class App : Application
    {
        private static Mutex mutex = null;

        protected override void OnStartup(StartupEventArgs e)
        {
            const string appName = "ClipboardApp";
            bool createdNew;

            mutex = new Mutex(true, appName, out createdNew);

            if (!createdNew)
            {
                // 이미 실행 중인 경우 기존 인스턴스 활성화 및 새 탭 추가
                string clipboardContent = Clipboard.GetText();
                if (MainWindow.Instance != null)
                {
                    MainWindow.ActivateExistingInstance(clipboardContent);
                }
                Application.Current.Shutdown();
                return;
            }

            base.OnStartup(e);
            MainWindow mainWindow = new MainWindow();
            mainWindow.Show();
        }
    }
}
NewWindow.xaml.cs
이 부분은 그대로 두어도 됩니다.

csharp
코드 복사
using System.Windows;

namespace ClipboardApp
{
    public partial class NewWindow : Window
    {
        public NewWindow()
        {
            InitializeComponent();
        }
    }
}
위의 코드로 App.xaml.cs에서 MainWindow의 싱글톤 인스턴스를 사용하여 정적 메서드를 호출할 수 있습니다. 이를 통해 MainWindow의 정적 메서드에 접근할 수 있고, 프로그램 실행 시 중복 실행 문제를 해결할 수 있습