// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure; // DbEntityEntry 사용
// using System.Data.Entity.Core.Objects; // ObjectContext 사용 제거
using System.Linq;
using System.Threading.Tasks;
using System.Web.Script.Serialization; // 또는 Newtonsoft.Json
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (로그 저장 로직 및 PK 조회 수정)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- 테이블 매핑을 위한 DbSet 속성들 ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        /// <summary>
        /// 기본 생성자. App.config의 "LockerDbConnection" 연결 문자열을 사용합니다.
        /// </summary>
        public LockerDbContext() : base("name=LockerDbConnection")
        {
            // Database.SetInitializer<LockerDbContext>(null);
        }

        /// <summary>
        /// 모델(테이블) 생성 시 추가 구성을 위한 메서드입니다 (Fluent API).
        /// </summary>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
        }

        #region SaveChanges Overrides for Audit Logging (Revised Logic)

        /// <summary>
        /// 동기 방식 변경 사항 저장 시 감사 로그를 기록합니다.
        /// </summary>
        public override int SaveChanges()
        {
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            // 로그 엔트리를 먼저 추가
            if (auditEntries != null && auditEntries.Any()) { this.AuditLogs.AddRange(auditEntries); }

            // 단 한 번의 SaveChanges 호출 (원본 변경 + 로그 추가)
            try { return base.SaveChanges(); }
            catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! SaveChanges 실패 (동기): {dbEx.ToString()}"); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
            // 로그 저장 실패는 여기서 처리하지 않음 (별도 로깅 또는 무시)
        }

        /// <summary>
        /// 비동기 방식 변경 사항 저장 시 감사 로그를 기록합니다.
        /// </summary>
        public override async Task<int> SaveChangesAsync()
        {
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            // 로그 엔트리를 먼저 추가
            if (auditEntries != null && auditEntries.Any()) { this.AuditLogs.AddRange(auditEntries); }

            // 단 한 번의 SaveChangesAsync 호출
            try { return await base.SaveChangesAsync(); }
            catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! SaveChangesAsync 실패 (비동기): {dbEx.ToString()}"); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
        }

        /// <summary>
        /// 현재 변경 추적 중인 엔티티를 기반으로 감사 로그 엔트리 목록을 생성합니다.
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                .ToList();
            var serializer = new JavaScriptSerializer { MaxJsonLength = int.MaxValue };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) continue; // 로그 자체는 로깅 안 함

                var auditEntry = new AuditLog
                {
                    Timestamp = DateTime.Now,
                    UserName = currentUserName,
                    TableName = entry.Entity.GetType().Name,
                    Action = entry.State.ToString()
                };

                // *** 수정된 부분: 기본 키 값을 간단하게 'Id' 속성으로 가정하고 접근 (try-catch 사용) ***
                try
                {
                    // 엔티티에 'Id'라는 이름의 기본 키 속성이 있다고 가정합니다.
                    // Added 상태일 때는 CurrentValue, Deleted 상태일 때는 OriginalValue 사용 고려 가능
                    if (entry.State == EntityState.Deleted)
                    {
                        auditEntry.RecordId = entry.OriginalValues["Id"]?.ToString();
                    }
                    else
                    {
                        auditEntry.RecordId = entry.CurrentValues["Id"]?.ToString();
                    }
                }
                catch (Exception ex)
                {
                    // 'Id' 속성이 없거나 다른 문제 발생 시
                    Debug.WriteLine($"감사 로그: 'Id' 기본 키 값 가져오기 실패 ({auditEntry.TableName}) - {ex.Message}");
                    auditEntry.RecordId = "PK Error";
                }

                // 이전/새 값 기록 로직 (이전과 동일)
                var oldValues = new Dictionary<string, object>();
                var newValues = new Dictionary<string, object>();
                var affectedColumns = new List<string>();

                if (entry.State == EntityState.Added)
                {
                    foreach (var propertyName in entry.CurrentValues.PropertyNames) newValues[propertyName] = entry.CurrentValues[propertyName];
                    try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Deleted)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames) oldValues[propertyName] = entry.OriginalValues[propertyName];
                    try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Modified)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames)
                    {
                        var originalValue = entry.OriginalValues[propertyName];
                        var currentValue = entry.CurrentValues[propertyName];
                        if (!Equals(originalValue, currentValue)) { affectedColumns.Add(propertyName); oldValues[propertyName] = originalValue; newValues[propertyName] = currentValue; }
                    }
                    if (affectedColumns.Any())
                    {
                        auditEntry.AffectedColumns = string.Join(",", affectedColumns);
                        try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                        try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                    }
                    else continue; // 실제 변경된 속성 없으면 로그 건너뜀
                }
                auditEntries.Add(auditEntry);
            }
            // LockerAssignment의 LastUpdated 업데이트
            UpdateLockerAssignmentTimestamps(changedEntries);
            return auditEntries;
        }

        // SaveAuditLogs, SaveAuditLogsAsync 메서드는 제거됨

        /// <summary>
        /// 변경된 LockerAssignment 엔티티의 LastUpdated 타임스탬프를 업데이트합니다.
        /// </summary>
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries)
        {
            var lockerEntries = changedEntries
                .Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified));
            foreach (var entry in lockerEntries)
            {
                ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now;
            }
        }

        #endregion
    }
}
```

**핵심 변경 사항:**

* **`CreateAuditEntries` 메서드:**
    * `ObjectContext` 관련 코드를 제거했습니다.
    * `RecordId`를 가져오는 부분을 다시 간단하게 `entry.Property("Id").CurrentValue` (또는 `OriginalValues`)를 사용하도록 변경하고 `try-catch`로 감쌌습니다. 이는 모든 테이블의 기본 키가 'Id'라고 가정하며, 그렇지 않은 경우 "PK Error"로 기록됩니다.
* **`SaveChanges`/`SaveChangesAsync` 메서드:**
    * 로그 엔트리(`auditEntries`)를 생성하고 `this.AuditLogs.AddRange(auditEntries)`를 통해 컨텍스트에 추가한 후, **단 한 번의 `base.SaveChanges()` 또는 `base.SaveChangesAsync()`** 를 호출하여 모든 변경 사항(원본 데이터 + 로그)을 저장하는 구조로 유지했습니다. (이전 단계에서 이미 수정된 내용)
    * 로그 저장 자체에서 발생하는 오류를 별도로 처리하지 않고, `SaveChanges` 전체의 성공/실패 여부에 따라 트랜잭션이 커밋/롤백되도록 합니다.