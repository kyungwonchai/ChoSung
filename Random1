를 사용하지 않고, 줄 번호와 줄 내용을 매핑한 딕셔너리를 사용하여 중복을 감지하는 방식으로 수정하겠습니다. 이 방식에서는 줄 번호와 해당 줄의 내용을 딕셔너리로 관리하며, 이미 처리된 줄 번호는 다시 처리되지 않도록 합니다.

최종 수정 코드: 줄 번호와 내용으로 중복 감지
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace LogMonitor.ViewModels
{
    public class FileWatcherViewModel : INotifyPropertyChanged
    {
        private FileSystemWatcher _fileWatcher;
        private string _logFilePath;
        private string _backupFolderPath;
        private int _maxLogLines = 1000;
        private readonly Dictionary<long, string> _logLinesDictionary = new Dictionary<long, string>(); // 줄 번호와 로그를 매핑하는 딕셔너리
        private long _lastFileLength = 0; // 마지막 파일 길이
        private bool _isMonitoringStarted = false; // 모니터링 시작 여부

        private const string ConfigFileName = "config.ini"; // 설정 파일 이름

        public event PropertyChangedEventHandler PropertyChanged;

        public FileWatcherViewModel()
        {
            LoadSettings(); // 설정 파일 로드
        }

        // 설정 파일에서 값 로드
        private void LoadSettings()
        {
            if (File.Exists(ConfigFileName))
            {
                var lines = File.ReadAllLines(ConfigFileName);
                foreach (var line in lines)
                {
                    var parts = line.Split('=');
                    if (parts.Length == 2)
                    {
                        var key = parts[0].Trim();
                        var value = parts[1].Trim();
                        if (key == "LogFilePath")
                        {
                            _logFilePath = value;
                        }
                        else if (key == "BackupFolderPath")
                        {
                            _backupFolderPath = value;
                        }
                        else if (key == "MaxLogLines")
                        {
                            if (int.TryParse(value, out int maxLines))
                            {
                                _maxLogLines = maxLines;
                            }
                        }
                    }
                }
            }
        }

        // 설정 파일에 값 저장
        private void SaveSettings()
        {
            var lines = new List<string>
            {
                $"LogFilePath={_logFilePath}",
                $"BackupFolderPath={_backupFolderPath}",
                $"MaxLogLines={_maxLogLines}"
            };

            File.WriteAllLines(ConfigFileName, lines);
        }

        // 로그 파일 변경 감시 시작
        private void StartFileWatcher()
        {
            if (_fileWatcher != null)
            {
                _fileWatcher.Dispose();
            }

            _fileWatcher = new FileSystemWatcher(Path.GetDirectoryName(_logFilePath))
            {
                Filter = Path.GetFileName(_logFilePath),
                NotifyFilter = NotifyFilters.LastWrite
            };

            _fileWatcher.Changed += OnLogFileChanged;
            _fileWatcher.EnableRaisingEvents = true;
        }

        // 로그 파일이 변경되었을 때 호출되는 이벤트 핸들러
        private async void OnLogFileChanged(object sender, FileSystemEventArgs e)
        {
            if (_isMonitoringStarted)
            {
                await ReadNewLinesAsync();
            }
        }

        // 새로운 로그 라인 읽기 (비동기)
        private async Task ReadNewLinesAsync()
        {
            await Task.Run(() =>
            {
                if (!File.Exists(_logFilePath))
                    return;

                using (var fs = new FileStream(_logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    // 이전에 읽었던 파일의 길이부터 읽기 시작
                    fs.Seek(_lastFileLength, SeekOrigin.Begin);

                    using (var sr = new StreamReader(fs, Encoding.Default))
                    {
                        long lineNumber = _logLinesDictionary.Count; // 기존 줄 수를 기반으로 새로운 줄 번호 계산

                        while (!sr.EndOfStream)
                        {
                            var line = sr.ReadLine();
                            if (!string.IsNullOrWhiteSpace(line))
                            {
                                // 현재 줄 번호와 로그 라인 쌍을 중복 감지
                                lineNumber++;
                                if (!_logLinesDictionary.ContainsKey(lineNumber))
                                {
                                    _logLinesDictionary[lineNumber] = line; // 줄 번호와 로그 라인을 저장
                                    string captureTime = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
                                    string formattedLine = $"[{captureTime}] [{lineNumber}]\t\t\t\t{line}";

                                    BackupLogLine(formattedLine); // 백업

                                    // UI 업데이트 (필요한 경우 추가)
                                    // Application.Current.Dispatcher.Invoke(() => LogListBox.Items.Add(formattedLine));

                                    // 최대 로그 라인 수 유지
                                    if (_logLinesDictionary.Count > _maxLogLines)
                                    {
                                        long oldestLine = lineNumber - _maxLogLines;
                                        _logLinesDictionary.Remove(oldestLine); // 오래된 로그 삭제
                                    }
                                }
                            }
                        }

                        // 마지막 파일 길이 저장
                        _lastFileLength = fs.Length;
                    }
                }
            });
        }

        // 로그 파일 선택 버튼 클릭 이벤트 핸들러
        public void SelectLogFile(string filePath)
        {
            _logFilePath = filePath;
            SaveSettings(); // 설정 저장
            _lastFileLength = new FileInfo(_logFilePath).Length; // 초기 파일 길이 설정
        }

        // 백업 폴더 선택 버튼 클릭 이벤트 핸들러
        public void SelectBackupFolder(string folderPath)
        {
            _backupFolderPath = folderPath;
            SaveSettings(); // 설정 저장
        }

        // 로그 감시 시작 버튼 클릭 이벤트 핸들러
        public void StartMonitoring()
        {
            if (!string.IsNullOrEmpty(_logFilePath))
            {
                _isMonitoringStarted = true; // 모니터링 시작 표시
                _lastFileLength = new FileInfo(_logFilePath).Length; // 시작 시점의 파일 길이로 설정
                StartFileWatcher();
            }
        }

        // 로그 지우기 버튼 클릭 이벤트 핸들러
        public void ClearLogs()
        {
            _logLinesDictionary.Clear();
        }

        // 백업 폴더에 로그 라인 저장
        private void BackupLogLine(string line)
        {
            if (string.IsNullOrEmpty(_backupFolderPath))
            {
                return;
            }

            // 날짜별 폴더 생성
            var dateFolder = Path.Combine(_backupFolderPath, DateTime.Now.ToString("yyyyMMdd"));
            if (!Directory.Exists(dateFolder))
            {
                Directory.CreateDirectory(dateFolder);
            }

            var backupFilePath = Path.Combine(dateFolder, $"backup_{DateTime.Now:yyyyMMdd}.log");

            using (var sw = new StreamWriter(backupFilePath, true, Encoding.Default))
            {
                sw.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {line}");
            }
        }

        // 프로그램 종료 시 마지막 상태를 저장하는 메서드
        private void OnExit(object sender, ExitEventArgs e)
        {
            SaveSettings(); // 설정 저장
        }

        // INotifyPropertyChanged 구현
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항:
해시값 제거 및 줄 번호와 내용으로 중복 감지:

각 줄을 읽을 때, 줄 번호와 해당 줄의 내용을 Dictionary<long, string>에 저장하여 중복을 감지합니다.
logLinesDictionary가 중복된 줄 번호를 기록하지 않기 때문에 중복된 줄은 처리되지 않습니다.
파일 길이를 통해 새로운 줄 읽기:

파일의 길이를 추적하여, 마지막 읽은 길이부터 새로운 줄을 읽습니다. 이전에 읽었던 내용은 다시 읽지 않습니다.
백업 기능:

백업 기능은 지정된 폴더에 로그를 날짜별로 저장합니다.
설정 파일:

로그 파일 경로, 백업 폴더 경로, 최대 로그 라인 수 등을 config.ini 파일에 저장하고 프로그램이 시작될 때 이를 로드합니다.
동작 방식:
파일 감시: FileSystemWatcher가 파일의 변경을 감지합니다.
중복 감지: 줄 번호와 해당 줄의 내용을 매핑한 딕셔너리를 사용하여 이미 처리된 줄 번호는 무시합니다.
백업: 로그는 지정된 백업 폴더에 날짜별로 백업됩니다.
최대 줄 수 제한: 최대 지정된 로그 줄 수를 초과할 경우 오래된 로그는 삭제됩니다.
이 코드로 줄 번호와 내용에 기반한 중복 감지 기능을 사용할 수 있습니다. 추가적인 질문이나 수정이 필요하시면 언제든지 말씀해 주세요!