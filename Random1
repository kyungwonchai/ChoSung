네, 계속해서 MGSPMonitorControl UI 프로그램의 코드를 드리겠습니다.

이번에는 로그인 창과 관련된 파일들 (LoginViewModel.cs, LoginWindow.xaml, LoginWindow.xaml.cs)과 메인 창의 ViewModel (MainViewModel.cs)의 기본 구조를 제공하겠습니다. 메인 창의 XAML과 나머지 상세 로직은 그 이후에 이어서 드리겠습니다.

4. ViewModels/ 폴더

4.1. ViewModels/LoginViewModel.cs

로그인 로직을 처리하는 ViewModel입니다.

C#

// MGSPMonitorControl/ViewModels/LoginViewModel.cs
using System;
using System.Security; // SecureString
using System.Threading.Tasks;
using System.Windows; // MessageBox
using System.Windows.Input; // ICommand
using MGSPMonitorControl.Models; // UserSession
using MGSPMonitorControl.Services; // IDatabaseService, IPasswordService

namespace MGSPMonitorControl.ViewModels
{
    public class LoginViewModel : ObservableObject // 이전 답변에서 제공한 ObservableObject 사용
    {
        private readonly IDatabaseService _databaseService;
        private readonly IPasswordService _passwordService;

        private string _username;
        public string Username
        {
            get => _username;
            set => SetProperty(ref _username, value);
        }

        // PasswordBox는 직접 바인딩이 어려우므로, View에서 SecureString을 전달받거나,
        // 다른 방법을 사용해야 합니다. 여기서는 View에서 LoginCommand 호출 시 PasswordBox를 직접 참조하여 전달합니다.
        // 또는, PasswordBoxHelper 같은 유틸리티 클래스 사용 가능.

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set => SetProperty(ref _errorMessage, value);
        }

        private bool _isLoggingIn;
        public bool IsLoggingIn
        {
            get => _isLoggingIn;
            set => SetProperty(ref _isLoggingIn, value);
        }

        public ICommand LoginCommand { get; }

        // 로그인 성공 시 호출될 이벤트 (App.xaml.cs에서 구독하여 메인 창 표시)
        public event Action<UserSession> LoginSuccess;

        public LoginViewModel(IDatabaseService databaseService, IPasswordService passwordService)
        {
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _passwordService = passwordService ?? throw new ArgumentNullException(nameof(passwordService));

            LoginCommand = new RelayCommand<object>(async (passwordBox) => await ExecuteLoginAsync(passwordBox as System.Windows.Controls.PasswordBox), CanExecuteLogin);
            // 초기화 시 사용자 생성 (예시 - 실제로는 별도 관리자 기능으로 구현)
            // Task.Run(async () => await EnsureDefaultUserExists()); 
        }
        
        // 예시: 기본 관리자 계정이 없으면 생성 (실제로는 더 안전한 방법으로 관리)
        private async Task EnsureDefaultUserExists()
        {
            // 간단히 admin 사용자가 있는지 확인하고 없으면 생성
            // 이 로직은 실제 애플리케이션에서는 더 안전하게 처리되어야 합니다.
            // 예를 들어, 최초 실행 시 설정 마법사를 통하거나, 별도의 관리 도구를 사용합니다.
            try
            {
                // 이 부분은 DatabaseService에 GetUserByUsername 같은 메서드가 있다면 더 좋음
                // 여기서는 간단히 AuthenticateUserAsync를 테스트용으로 사용 (실제로는 이러면 안됨)
                var existingAdmin = await _databaseService.AuthenticateUserAsync("admin", "admin", _passwordService); // 테스트용
                if (existingAdmin == null)
                {
                    Console.WriteLine("Default admin user not found. Attempting to create...");
                    // (비밀번호, 권한)
                    await _databaseService.CreateUserAsync("admin", "adminP@sswOrd", true, true, _passwordService);
                    Console.WriteLine("Default admin user (admin/adminP@sswOrd) created with full permissions.");
                    await _databaseService.CreateUserAsync("user", "userP@sswOrd", false, true, _passwordService);
                     Console.WriteLine("Default operator user (user/userP@sswOrd) created with power control permissions.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error ensuring default user: {ex.Message}");
                 // 실제로는 로그 파일에 기록
            }
        }


        private bool CanExecuteLogin(object parameter)
        {
            return !string.IsNullOrWhiteSpace(Username) && 
                   (parameter as System.Windows.Controls.PasswordBox)?.SecurePassword.Length > 0 && 
                   !IsLoggingIn;
        }

        private async Task ExecuteLoginAsync(System.Windows.Controls.PasswordBox passwordBox)
        {
            if (passwordBox == null) return;

            IsLoggingIn = true;
            ErrorMessage = string.Empty;
            SecureString securePassword = passwordBox.SecurePassword;
            
            // SecureString을 일반 string으로 변환 (주의: 메모리에 평문 비밀번호가 잠시 남게 됨)
            // 실제로는 SecureString을 최대한 유지하며 처리하는 것이 좋으나, 여기서는 단순화.
            IntPtr valuePtr = IntPtr.Zero;
            string password = "";
            try
            {
                valuePtr = System.Runtime.InteropServices.Marshal.SecureStringToGlobalAllocUnicode(securePassword);
                password = System.Runtime.InteropServices.Marshal.PtrToStringUni(valuePtr);
            }
            finally
            {
                System.Runtime.InteropServices.Marshal.ZeroFreeGlobalAllocUnicode(valuePtr);
            }

            try
            {
                UserSession userSession = await _databaseService.AuthenticateUserAsync(Username, password);

                if (userSession != null)
                {
                    // 로그인 성공
                    ErrorMessage = "Login successful!";
                    LoginSuccess?.Invoke(userSession); // 이벤트 발생
                }
                else
                {
                    ErrorMessage = "Invalid username or password.";
                }
            }
            catch (Exception ex)
            {
                // 실제로는 로깅 서비스 사용
                Console.WriteLine($"Login error: {ex.Message}");
                ErrorMessage = $"An error occurred during login: {ex.Message}";
            }
            finally
            {
                IsLoggingIn = false;
                // 로그인 시도 후 비밀번호 필드 초기화 (선택적)
                // passwordBox.Clear(); 
            }
        }
    }
}
참고: 위 EnsureDefaultUserExists 메서드는 개발 편의를 위한 예시이며, 실제 운영 환경에서는 사용자 계정 관리를 위한 별도의 안전한 방법을 사용해야 합니다.

5. Views/ 폴더 (또는 루트에 직접)

5.1. Views/LoginWindow.xaml (로그인 창 XAML)

XML

<Window x:Class="MGSPMonitorControl.Views.LoginWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:MGSPMonitorControl.Views"
        xmlns:viewmodels="clr-namespace:MGSPMonitorControl.ViewModels"
        mc:Ignorable="d"
        Title="Login - MGSP Monitor Control" Height="350" Width="400"
        WindowStartupLocation="CenterScreen" ResizeMode="NoResize" ShowInTaskbar="True"
        d:DataContext="{d:DesignInstance Type=viewmodels:LoginViewModel, IsDesignTimeCreatable=False}">
    <Grid Margin="20">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <TextBlock Grid.Row="0" Text="MGSP Monitor Control Login" FontSize="20" FontWeight="Bold" HorizontalAlignment="Center" Margin="0,0,0,20"/>

        <TextBlock Grid.Row="1" Text="Username:" Margin="0,5"/>
        <TextBox Grid.Row="2" x:Name="UsernameTextBox" Text="{Binding Username, UpdateSourceTrigger=PropertyChanged}" Height="25" Margin="0,0,0,10" VerticalContentAlignment="Center"/>

        <TextBlock Grid.Row="3" Text="Password:" Margin="0,5"/>
        <PasswordBox Grid.Row="4" x:Name="PasswordBox" Height="25" Margin="0,0,0,15" VerticalContentAlignment="Center" />

        <StackPanel Grid.Row="5" Orientation="Vertical">
            <Button Content="Login" Command="{Binding LoginCommand}" CommandParameter="{Binding ElementName=PasswordBox}" IsDefault="True" Height="30" Width="100" HorizontalAlignment="Center" Margin="0,0,0,10" IsEnabled="{Binding !IsLoggingIn}"/>
            <TextBlock Text="{Binding ErrorMessage}" Foreground="Red" HorizontalAlignment="Center" TextWrapping="Wrap"/>
            <TextBlock Text="{Binding IsLoggingIn, Converter={StaticResource BooleanToVisibilityConverter}}" Visibility="Collapsed" HorizontalAlignment="Center" Margin="0,5,0,0">
                <Run Text="Logging in..."/>
            </TextBlock>
        </StackPanel>
    </Grid>

    <Window.Resources>
        <local:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
    </Window.Resources>
</Window>
위 XAML에서 BooleanToVisibilityConverter가 사용되었으므로, 이 컨버터도 필요합니다.

5.1.1. Views/BooleanToVisibilityConverter.cs (또는 Converters/ 폴더)

C#

// MGSPMonitorControl/Views/BooleanToVisibilityConverter.cs (또는 Converters 폴더)
using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace MGSPMonitorControl.Views // 또는 Converters 네임스페이스
{
    [ValueConversion(typeof(bool), typeof(Visibility))]
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            bool boolValue = (bool)value;
            // 반전된 로직을 원하면 parameter를 사용 (예: parameter="Invert")
            // string direction = parameter as string;
            // if (direction == "Invert") boolValue = !boolValue;
            
            return boolValue ? Visibility.Visible : Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            Visibility visibilityValue = (Visibility)value;
            return visibilityValue == Visibility.Visible;
        }
    }
}
5.2. Views/LoginWindow.xaml.cs (로그인 창 코드 비하인드)

ViewModel을 생성하고 DataContext에 할당합니다. 로그인 성공 시 창을 닫습니다.

C#

// MGSPMonitorControl/Views/LoginWindow.xaml.cs
using System.Windows;
using MGSPMonitorControl.ViewModels;
using MGSPMonitorControl.Services; // IDatabaseService, IPasswordService
using MGSPMonitorControl.Models; // UserSession

namespace MGSPMonitorControl.Views
{
    public partial class LoginWindow : Window
    {
        private LoginViewModel _viewModel;

        // App.xaml.cs에서 로그인 성공 후 UserSession을 전달받기 위한 속성
        public UserSession AuthenticatedUserSession { get; private set; }

        public LoginWindow()
        {
            InitializeComponent();

            // 실제 서비스 인스턴스 주입 (DI 컨테이너가 있다면 더 좋음)
            // 여기서는 App.xaml.cs에서 서비스 인스턴스를 생성하고 전달하는 방식을 가정하거나,
            // 또는 서비스 로케이터 패턴을 사용할 수 있음.
            // 간단하게는 new로 생성. App.xaml.cs에서 이 창을 생성할 때 ViewModel을 주입할 수도 있음.
            // 여기서는 LoginWindow가 직접 서비스 인스턴스를 생성한다고 가정.
            // (더 나은 방법은 App.xaml.cs에서 ViewModel을 만들고 이 창의 DataContext로 설정하는 것)
            
            // 이 방식은 테스트 용이성이 떨어짐. App.xaml.cs에서 ViewModel을 만들어 주입하는게 좋음.
            // IDatabaseService databaseService = new DatabaseService(); 
            // IPasswordService passwordService = new PasswordService();
            // _viewModel = new LoginViewModel(databaseService, passwordService);
            
            // DataContext는 XAML에서 DesignInstance를 위해 설정했거나, App.xaml.cs에서 주입 가능
            // 만약 ViewModel을 여기서 생성한다면:
            // DataContext = _viewModel; 
            
            // _viewModel.LoginSuccess += (userSession) =>
            // {
            //     AuthenticatedUserSession = userSession;
            //     DialogResult = true; // 로그인 성공 시 창 닫고 true 반환
            //     Close();
            // };
        }

        // App.xaml.cs에서 ViewModel을 생성하여 이 창에 전달하고, 
        // 이 창은 해당 ViewModel의 이벤트만 구독하도록 수정하는 것이 더 나은 MVVM 패턴입니다.
        // 아래는 App.xaml.cs에서 ViewModel을 설정해준다고 가정한 코드입니다.
        public void InitializeViewModel(LoginViewModel viewModel)
        {
            _viewModel = viewModel;
            DataContext = _viewModel;

            _viewModel.LoginSuccess += (userSession) =>
            {
                AuthenticatedUserSession = userSession;
                DialogResult = true; 
                Close();
            };
        }
    }
}
LoginWindow.xaml.cs 참고: 위 코드에서는 InitializeViewModel 메서드를 추가하여 App.xaml.cs에서 LoginViewModel을 생성하고 이 창에 주입하는 방식을 제안했습니다. 이렇게 하면 의존성 관리가 더 용이해집니다.

6. ViewModels/MainViewModel.cs (메인 창 ViewModel - 기본 구조)

이제 메인 창의 ViewModel의 기본 구조를 정의합니다. 실제 기능 구현은 다음 단계에서 채워나갈 것입니다.

C#

// MGSPMonitorControl/ViewModels/MainViewModel.cs
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // Dispatcher 사용
using System.Windows.Input;
using MGSPMonitorControl.Models;
using MGSPMonitorControl.Services;
using MonitorControl.SharedModels; // BrokerMessage, LiveAgentInfoForUi 등

namespace MGSPMonitorControl.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly UserSession _currentUserSession;
        private readonly IDatabaseService _databaseService;
        private readonly IBrokerClientService _brokerClientService;
        // private readonly ILoggingService _uiLogger; // UI 자체 로깅용

        public ObservableCollection<ManagedAgentDisplay> Agents { get; } = new ObservableCollection<ManagedAgentDisplay>();
        public ObservableCollection<string> UiActionLogs { get; } = new ObservableCollection<string>(); // UI 동작 로그
        
        private ManagedAgentDisplay _selectedAgent;
        public ManagedAgentDisplay SelectedAgent
        {
            get => _selectedAgent;
            set => SetProperty(ref _selectedAgent, value);
        }

        private BrokerStatusDisplay _brokerStatus = new BrokerStatusDisplay();
        public BrokerStatusDisplay BrokerStatus
        {
            get => _brokerStatus;
            set => SetProperty(ref _brokerStatus, value);
        }
        
        private string _brokerConnectionStatus = "Disconnected";
        public string BrokerConnectionStatus 
        {
            get => _brokerConnectionStatus;
            set => SetProperty(ref _brokerConnectionStatus, value);
        }

        public string CurrentUsername => _currentUserSession?.Username ?? "N/A";
        public bool CanUserManageAgents => _currentUserSession?.CanManageAgents ?? false;
        public bool CanUserControlPower => _currentUserSession?.CanControlPower ?? false;


        // Commands
        public ICommand LoadAgentsCommand { get; }
        public ICommand AddAgentCommand { get; }
        public ICommand EditAgentCommand { get; }
        public ICommand DeleteAgentCommand { get; }
        public ICommand MonitorOnCommand { get; }
        public ICommand MonitorOffCommand { get; }
        public ICommand PingAgentCommand { get; }
        public ICommand RequestBrokerStatusCommand { get; }
        public ICommand ConnectToBrokerCommand { get; }
        public ICommand DisconnectFromBrokerCommand { get; }


        public MainViewModel(UserSession userSession, IDatabaseService databaseService, IBrokerClientService brokerClientService /*, ILoggingService uiLogger*/)
        {
            _currentUserSession = userSession ?? throw new ArgumentNullException(nameof(userSession));
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _brokerClientService = brokerClientService ?? throw new ArgumentNullException(nameof(brokerClientService));
            // _uiLogger = uiLogger;

            AddUiLog($"User '{_currentUserSession.Username}' logged in.");

            // BrokerClientService 이벤트 구독
            _brokerClientService.Connected += OnBrokerConnected;
            _brokerClientService.Disconnected += OnBrokerDisconnected;
            _brokerClientService.MessageReceived += OnBrokerMessageReceived;

            // Commands 초기화 (CanExecute 조건은 현재 로그인 사용자 권한 고려)
            LoadAgentsCommand = new RelayCommand(async () => await ExecuteLoadAgentsAsync(), () => _brokerClientService.IsConnected);
            AddAgentCommand = new RelayCommand(ExecuteAddAgent, () => CanUserManageAgents);
            EditAgentCommand = new RelayCommand(ExecuteEditAgent, () => SelectedAgent != null && CanUserManageAgents);
            DeleteAgentCommand = new RelayCommand(async () => await ExecuteDeleteAgentAsync(), () => SelectedAgent != null && CanUserManageAgents);
            
            MonitorOnCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOn"), 
                                              () => SelectedAgent != null && SelectedAgent.IsOnline && CanUserControlPower);
            MonitorOffCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOff"), 
                                               () => SelectedAgent != null && SelectedAgent.IsOnline && CanUserControlPower);
            PingAgentCommand = new RelayCommand(async () => await ExecutePingAgentAsync(), () => SelectedAgent != null && SelectedAgent.IsOnline);

            RequestBrokerStatusCommand = new RelayCommand(async () => await ExecuteRequestBrokerStatusAsync(), () => _brokerClientService.IsConnected);
            ConnectToBrokerCommand = new RelayCommand(async () => await _brokerClientService.ConnectAsync(), () => !_brokerClientService.IsConnected);
            DisconnectFromBrokerCommand = new RelayCommand(async () => await _brokerClientService.DisconnectAsync(), () => _brokerClientService.IsConnected);


            // 초기 Broker 연결 시도
            Task.Run(async () => await _brokerClientService.ConnectAsync());
        }

        private void AddUiLog(string message)
        {
            // UI 스레드에서 실행 보장
            Application.Current.Dispatcher.Invoke(() =>
            {
                UiActionLogs.Insert(0, $"[{DateTime.Now:HH:mm:ss}] {message}"); // 최신 로그가 위로
                if (UiActionLogs.Count > 200) UiActionLogs.RemoveAt(UiActionLogs.Count - 1); // 최대 로그 수 제한
            });
        }

        private async Task ExecuteLoadAgentsAsync()
        {
            AddUiLog("Loading managed agents from database...");
            try
            {
                var dbAgents = await _databaseService.GetManagedAgentsAsync();
                Application.Current.Dispatcher.Invoke(() =>
                {
                    Agents.Clear();
                    foreach (var agent in dbAgents)
                    {
                        Agents.Add(agent); // ManagedAgentDisplay 객체
                    }
                });
                AddUiLog($"Loaded {dbAgents.Count} agents from DB. Requesting initial status from Broker if connected.");
                // Broker 연결되어 있으면 초기 Agent 목록 요청 (Broker가 현재 온라인 상태 등 갱신)
                if(_brokerClientService.IsConnected)
                {
                    await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetInitialAgentList });
                }
            }
            catch (Exception ex)
            {
                AddUiLog($"Error loading agents: {ex.Message}");
                MessageBox.Show($"Error loading agents: {ex.Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ExecuteAddAgent()
        {
            AddUiLog("Opening Add Agent window...");
            var agentConfigVm = new AgentConfigViewModel(_databaseService, _currentUserSession.UserId);
            var agentConfigWindow = new Views.AgentConfigWindow(agentConfigVm); // ViewModel 주입
            
            if (agentConfigWindow.ShowDialog() == true)
            {
                AddUiLog($"Agent '{agentConfigVm.Agent.AgentName}' added/updated. Refreshing list.");
                Task.Run(async () => await ExecuteLoadAgentsAsync()); // 목록 새로고침
            }
        }

        private void ExecuteEditAgent()
        {
            if (SelectedAgent == null) return;
            AddUiLog($"Opening Edit Agent window for: {SelectedAgent.AgentName}");
            // DB에서 최신 정보 다시 로드 (동시성 문제 방지)
            var agentToEdit = Task.Run(async () => await _databaseService.GetManagedAgentByGuidAsync(SelectedAgent.AgentGuid)).Result;
            if(agentToEdit == null) {
                AddUiLog($"Agent {SelectedAgent.AgentName} not found in DB for editing.");
                MessageBox.Show("Selected agent not found in database. It might have been deleted.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Task.Run(async () => await ExecuteLoadAgentsAsync());
                return;
            }

            var agentConfigVm = new AgentConfigViewModel(_databaseService, _currentUserSession.UserId, agentToEdit);
            var agentConfigWindow = new Views.AgentConfigWindow(agentConfigVm);
            
            if (agentConfigWindow.ShowDialog() == true)
            {
                AddUiLog($"Agent '{agentConfigVm.Agent.AgentName}' updated. Refreshing list.");
                Task.Run(async () => await ExecuteLoadAgentsAsync());
            }
        }

        private async Task ExecuteDeleteAgentAsync()
        {
            if (SelectedAgent == null) return;
            if (MessageBox.Show($"Are you sure you want to delete agent '{SelectedAgent.AgentName}' (ID: {SelectedAgent.AgentIdProvidedByApp})?",
                                "Confirm Delete", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                AddUiLog($"Attempting to delete agent: {SelectedAgent.AgentName}");
                try
                {
                    bool success = await _databaseService.DeleteManagedAgentAsync(SelectedAgent.AgentGuid);
                    if (success)
                    {
                        AddUiLog($"Agent '{SelectedAgent.AgentName}' deleted successfully. Refreshing list.");
                        await ExecuteLoadAgentsAsync();
                    }
                    else
                    {
                        AddUiLog($"Failed to delete agent '{SelectedAgent.AgentName}'.");
                        MessageBox.Show("Failed to delete agent.", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
                catch (Exception ex)
                {
                    AddUiLog($"Error deleting agent '{SelectedAgent.AgentName}': {ex.Message}");
                    MessageBox.Show($"Error deleting agent: {ex.Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private async Task ExecuteMonitorControlAsync(string actionType) // "TurnMonitorOn" 또는 "TurnMonitorOff"
        {
            if (SelectedAgent == null) return;

            AddUiLog($"Sending '{actionType}' command to agent: {SelectedAgent.AgentName} (ID: {SelectedAgent.AgentIdProvidedByApp})");

            // 비밀번호 B 권한은 CanUserControlPower로 이미 버튼 활성화/비활성화에 사용됨.
            // 추가로 비밀번호 입력받아 DB에서 다시 검증하는 로직은 여기서는 생략 (요구사항에 따라 추가 가능)

            var payload = new UiControlAgentPayload // MonitorControl.SharedModels
            {
                TargetAgentIdProvidedByApp = SelectedAgent.AgentIdProvidedByApp,
                ControlAction = actionType,
                ControlType = SelectedAgent.ControlType,
                PrimaryIpAddress = SelectedAgent.PrimaryIpAddress,
                PrimaryPort = SelectedAgent.PrimaryPort,
                GatewayAgentIdToUse = SelectedAgent.ControlType == "Gatewayed" ? 
                                      GetGatewayAgentIdForTarget(SelectedAgent) : null, // Gateway Agent의 AgentIdProvidedByApp 찾아야 함
                // OriginalParameters는 현재 사용 안함
            };

            var message = new BrokerMessage // MonitorControl.SharedModels
            {
                Type = MessageType.UiRequest_ControlAgent,
                CorrelationId = Guid.NewGuid().ToString(), // 각 명령에 대한 고유 ID
                Payload = JsonConvert.SerializeObject(payload)
                // SourceId는 BrokerClientService에서 채워주거나, 여기서 UI의 고유 ID 설정 가능
            };

            await _brokerClientService.SendMessageAsync(message);
            // 결과는 OnBrokerMessageReceived -> BrokerToUi_ForwardAgentCommandResult 에서 처리
        }
        
        // 선택된 Agent가 Gatewayed 타입일 때, 사용할 Gateway Agent의 AgentIdProvidedByApp를 찾는 헬퍼 메서드
        // (DB의 ManagedAgent 테이블에 Gateway Agent의 IP와 Port가 있고, 그 Gateway Agent도 ManagedAgents에 등록되어 있어야 함)
        private string GetGatewayAgentIdForTarget(ManagedAgentDisplay targetAgent)
        {
            if (targetAgent.ControlType != "Gatewayed" || 
                string.IsNullOrEmpty(targetAgent.GatewayAgentIpAddress) || 
                !targetAgent.GatewayAgentPort.HasValue)
            {
                return null;
            }
            // DB에 저장된 GatewayAgentIpAddress가 실제로 다른 ManagedAgent의 PrimaryIpAddress와 일치하고,
            // 그 ManagedAgent의 ControlType이 'Direct' (또는 그 자체가 Gateway 역할 가능)인 경우,
            // 그 ManagedAgent의 AgentIdProvidedByApp를 반환해야 함.
            // 여기서는 단순화를 위해, UI가 ManagedAgent 추가/수정 시 'GatewayAgentIpAddress' 필드에
            // 실제 게이트웨이 역할을 할 Agent의 'AgentIdProvidedByApp' (즉, IP)를 입력한다고 가정.
            // 또는, UI에서 GatewayAgent를 선택하는 드롭다운을 제공하고 그 Agent의 ID를 저장해야 함.
            // 이 부분은 DB 스키마와 UI 입력 방식에 따라 더 정교하게 구현 필요.
            // 지금은 ManagedAgents.GatewayAgentIpAddress에 게이트웨이의 AgentIdProvidedByApp(IP)가 저장되어 있다고 가정.
            return targetAgent.GatewayAgentIpAddress; 
        }


        private async Task ExecutePingAgentAsync()
        {
            if (SelectedAgent == null) return;
            AddUiLog($"Pinging agent: {SelectedAgent.AgentName} (ID: {SelectedAgent.AgentIdProvidedByApp})");
            // Ping 명령은 Broker가 직접 대상 Agent에게 Ping을 보내고, Agent는 Pong을 Broker에게 보냄.
            // Broker는 Pong을 받으면 해당 Agent의 LastHeartbeat 등을 업데이트하고,
            // BrokerToUi_BroadcastAgentStatus를 통해 UI에 상태 변화를 알림.
            // UI가 직접 Ping/Pong 메시지를 처리할 필요는 없음.
            // 여기서는 Broker에게 Ping 요청을 보냄.
            var message = new BrokerMessage
            {
                Type = MessageType.UiRequest_ControlAgent, // Ping도 일종의 제어 명령으로 취급 가능
                CorrelationId = Guid.NewGuid().ToString(),
                Payload = JsonConvert.SerializeObject(new UiControlAgentPayload
                {
                    TargetAgentIdProvidedByApp = SelectedAgent.AgentIdProvidedByApp,
                    ControlAction = "PingAgent", // Broker가 이 Action을 보고 Agent.PingAgent 호출하도록
                    ControlType = SelectedAgent.ControlType, // Ping도 경로 정보 필요
                    PrimaryIpAddress = SelectedAgent.PrimaryIpAddress,
                    PrimaryPort = SelectedAgent.PrimaryPort,
                    GatewayAgentIdToUse = GetGatewayAgentIdForTarget(SelectedAgent)
                })
            };
            await _brokerClientService.SendMessageAsync(message);
        }

        private async Task ExecuteRequestBrokerStatusAsync()
        {
            AddUiLog("Requesting broker status and logs...");
            var message = new BrokerMessage { Type = MessageType.UiRequest_GetBrokerStatus };
            await _brokerClientService.SendMessageAsync(message);
        }

        #region Broker Event Handlers
        private void OnBrokerConnected()
        {
            BrokerConnectionStatus = "Connected to Broker";
            AddUiLog("Successfully connected to Broker Service.");
            // 연결 성공 시 UI 클라이언트 등록 및 초기 데이터 요청
            Task.Run(async () => {
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiClientHello }); // 선택적
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetInitialAgentList });
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetBrokerStatus });
                await ExecuteLoadAgentsAsync(); // DB에서도 목록 로드하여 Broker 정보와 병합 준비
            });
        }

        private void OnBrokerDisconnected()
        {
            BrokerConnectionStatus = "Disconnected from Broker. Attempting to reconnect...";
            AddUiLog("Disconnected from Broker Service. Will attempt to reconnect if service is restarted.");
            // UI에서 Agent들 상태를 'Offline'으로 변경하거나, 연결 시도 중임을 표시
            Application.Current.Dispatcher.Invoke(() =>
            {
                foreach(var agent in Agents) { agent.IsOnline = false; }
            });
            // BrokerClientService가 내부적으로 재연결 시도할 수 있음.
            // 또는 여기서 명시적으로 재연결 시도 명령 가능.
        }

        private void OnBrokerMessageReceived(BrokerMessage message) // MonitorControl.SharedModels.BrokerMessage
        {
             Application.Current.Dispatcher.Invoke(() => // UI 스레드에서 처리
            {
                // AddUiLog($"Broker Message Received: Type={message.Type}, Source={message.SourceId}, CorrId={message.CorrelationId}");
                switch (message.Type)
                {
                    case MessageType.BrokerToUi_InitialAgentList:
                        var agentListPayload = JsonConvert.DeserializeObject<List<LiveAgentInfoForUi>>(message.Payload);
                        if (agentListPayload != null)
                        {
                            UpdateAgentListFromBroker(agentListPayload, true);
                            AddUiLog($"Received initial list of {agentListPayload.Count} live agents from Broker.");
                        }
                        break;
                    case MessageType.BrokerToUi_BroadcastAgentRegisteredOrUpdated:
                        var registeredAgentInfo = JsonConvert.DeserializeObject<LiveAgentInfoForUi>(message.Payload);
                        if (registeredAgentInfo != null)
                        {
                            UpdateSingleAgentStatus(registeredAgentInfo);
                            AddUiLog($"Agent registered/updated on Broker: {registeredAgentInfo.AgentIdProvidedByApp}");
                        }
                        break;
                    case MessageType.BrokerToUi_BroadcastAgentDisconnected:
                        string disconnectedAgentId = message.SourceId; // Payload에 LiveAgentInfoForUi가 올 수도 있음
                        var agentToMarkOffline = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == disconnectedAgentId);
                        if (agentToMarkOffline != null)
                        {
                            agentToMarkOffline.IsOnline = false;
                            agentToMarkOffline.CurrentMonitorStatus = "Offline";
                            agentToMarkOffline.LastStatusMessageFromAgent = "Disconnected from Broker";
                            AddUiLog($"Agent disconnected from Broker: {disconnectedAgentId}");
                        }
                        break;
                    case MessageType.BrokerToUi_BroadcastAgentStatus:
                        var statusUpdateInfo = JsonConvert.DeserializeObject<LiveAgentInfoForUi>(message.Payload);
                        if (statusUpdateInfo != null)
                        {
                            UpdateSingleAgentStatus(statusUpdateInfo);
                            // AddUiLog($"Agent status update: {statusUpdateInfo.AgentIdProvidedByApp} - Monitor: {statusUpdateInfo.CurrentMonitorStatus}"); // 너무 잦을 수 있음
                        }
                        break;
                    case MessageType.BrokerToUi_ForwardAgentCommandResult:
                        var cmdResultPayload = JsonConvert.DeserializeObject<AgentCommandResultPayload>(message.Payload);
                        if (cmdResultPayload != null)
                        {
                            AddUiLog($"Result for command {message.CorrelationId} from Agent {message.SourceId}: {(cmdResultPayload.Success ? "OK" : "NG")} - {cmdResultPayload.Message}");
                            // 해당 Agent의 모니터 상태 업데이트
                            var agentForResult = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == message.SourceId);
                            if(agentForResult != null)
                            {
                                agentForResult.CurrentMonitorStatus = cmdResultPayload.CurrentMonitorStatus;
                                agentForResult.LastStatusMessageFromAgent = $"Cmd: {cmdResultPayload.Message}";
                            }
                            // DB에 로그 기록
                            LogCommandResultToDb(message.CorrelationId, message.SourceId, cmdResultPayload);
                        }
                        break;
                    case MessageType.BrokerToUi_CommandDispatchFailed:
                         var dispatchFailPayload = JsonConvert.DeserializeObject<dynamic>(message.Payload); // 간단히 dynamic 사용
                         string reason = dispatchFailPayload?.Message ?? "Unknown dispatch error";
                         AddUiLog($"Broker failed to dispatch command {message.CorrelationId}: {reason}");
                         // DB 로그에 'DispatchFailed' 상태로 기록
                         LogCommandDispatchFailureToDb(message.CorrelationId, reason);
                        break;
                    case MessageType.BrokerToUi_SendBrokerStatus:
                        var brokerStatusPayload = JsonConvert.DeserializeObject<BrokerStatusInfoPayload>(message.Payload);
                        if (brokerStatusPayload != null)
                        {
                            BrokerStatus.UpdateFromServerPayload(brokerStatusPayload);
                            AddUiLog("Broker status and logs updated.");
                        }
                        break;
                    // 다른 Broker -> UI 메시지 타입 처리...
                }
            });
        }
        
        private void UpdateAgentListFromBroker(List<LiveAgentInfoForUi> liveAgents, bool isInitialLoad)
        {
            // DB에서 로드된 목록(Agents)과 Broker에서 온 실시간 목록(liveAgents)을 병합/업데이트
            // AgentIdProvidedByApp (IP 기반 ID)를 키로 사용
            foreach (var liveAgent in liveAgents)
            {
                var existingAgent = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == liveAgent.AgentIdProvidedByApp);
                if (existingAgent != null)
                {
                    existingAgent.UpdateLiveStatus(liveAgent);
                }
                else
                {
                    // Broker에는 있지만 DB에는 없는 Agent (예: UI가 아직 DB에 추가 안 함)
                    // 이 경우 UI에 표시할지, 아니면 DB에 있는 것만 표시할지 정책 필요
                    // 여기서는 DB에 있는 것만 관리하고, Broker가 알려준 상태만 업데이트한다고 가정.
                    // 만약 DB에 없는 Agent도 목록에 추가하고 싶다면 여기서 new ManagedAgentDisplay 생성.
                    // AddUiLog($"Live agent '{liveAgent.AgentIdProvidedByApp}' from Broker not found in local DB list. Displaying temporarily or needs DB sync.");
                    // ManagedAgentDisplay tempAgent = new ManagedAgentDisplay { AgentIdProvidedByApp = liveAgent.AgentIdProvidedByApp, AgentName = "(From Broker - Not in DB)"};
                    // tempAgent.UpdateLiveStatus(liveInfo);
                    // Agents.Add(tempAgent);
                }
            }
            // Broker에 연결 끊긴 것으로 표시된 Agent들 처리
            if(isInitialLoad) {
                foreach(var dbAgent in Agents) {
                    if(!liveAgents.Any(la => la.AgentIdProvidedByApp == dbAgent.AgentIdProvidedByApp && la.IsOnline)) {
                        dbAgent.IsOnline = false;
                        dbAgent.CurrentMonitorStatus = "Offline";
                    }
                }
            }
        }

        private void UpdateSingleAgentStatus(LiveAgentInfoForUi liveInfo)
        {
            var agent = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == liveInfo.AgentIdProvidedByApp);
            if (agent != null)
            {
                agent.UpdateLiveStatus(liveInfo);
            }
            else
            {
                 // DB에 없는 Agent가 상태를 보고한 경우 (일반적으로는 Hello 후 DB에 등록되므로 발생 빈도 낮음)
                 AddUiLog($"Received status for unmanaged Agent ID: {liveInfo.AgentIdProvidedByApp}. Please add to DB if needed.");
                 // 임시로 목록에 추가하여 보여줄 수도 있음
                 // ManagedAgentDisplay tempAgent = new ManagedAgentDisplay { AgentIdProvidedByApp = liveInfo.AgentIdProvidedByApp, AgentName = $"(Live: {liveInfo.AgentIdProvidedByApp})"};
                 // tempAgent.UpdateLiveStatus(liveInfo);
                 // Agents.Add(tempAgent);
                 // SortAgents();
            }
        }
        
        private async void LogCommandResultToDb(string correlationId, string agentIdProvidedByApp, AgentCommandResultPayload resultPayload)
        {
            var agent = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == agentIdProvidedByApp);
            if (agent == null)
            {
                AddUiLog($"Cannot log result: Agent with ID {agentIdProvidedByApp} not found in UI's DB list for CorrId {correlationId}.");
                return;
            }

            var logEntry = new ControlActionLogEntry
            {
                AgentGuid = agent.AgentGuid, // DB의 ManagedAgents 테이블 기본키
                // ActionType은 원본 명령에서 가져와야 함 (CorrelationId로 매핑된 요청 정보에서)
                // 지금은 임시로 "ControlAction"
                ActionType = "ControlAction", // TODO: 원본 명령 타입 로깅
                RequestTimestamp = DateTime.UtcNow, // 실제로는 명령 시작 시간
                ExecutionCompletedTimestamp = DateTime.UtcNow, // 결과 받은 시간
                FinalStatus = resultPayload.Success ? "Success" : "FailureAtAgent",
                ResultMessage = resultPayload.Message,
                RequestedByUserId = _currentUserSession.UserId // 현재 로그인 사용자
                // ExecutedViaGatewayAgentId 등 추가 정보 로깅
            };
            try
            {
                await _databaseService.LogControlActionAsync(logEntry);
                AddUiLog($"Command result for {agent.AgentName} (CorrId: {correlationId}) logged to DB.");
            }
            catch (Exception ex)
            {
                AddUiLog($"Failed to log command result for {agent.AgentName} to DB: {ex.Message}");
            }
        }
        private async void LogCommandDispatchFailureToDb(string correlationId, string reason)
        {
            // TODO: 실패한 명령의 TargetAgentId를 알아내서 AgentGuid를 찾아야 함.
            // CorrelationId에 해당하는 원래 요청 정보를 어딘가에 저장해둬야 함.
            // 여기서는 임시로 AgentGuid를 비워두거나, 특정 실패 로그용 ID 사용.
            AddUiLog($"Logging command dispatch failure (CorrId: {correlationId}) to DB: {reason}");
            var logEntry = new ControlActionLogEntry
            {
                AgentGuid = Guid.Empty, // 실제로는 대상 AgentGuid를 찾아야 함
                ActionType = "DispatchAttempt",
                RequestTimestamp = DateTime.UtcNow,
                FinalStatus = "FailureAtBroker",
                ResultMessage = $"Broker failed to dispatch: {reason}",
                RequestedByUserId = _currentUserSession.UserId
            };
            try
            {
                // await _databaseService.LogControlActionAsync(logEntry);
            }
            catch (Exception ex)
            {
                AddUiLog($"Failed to log dispatch failure to DB: {ex.Message}");
            }
        }


        #endregion

        public void Cleanup() // 앱 종료 시 호출
        {
            AddUiLog("MainViewModel cleaning up...");
            if (_brokerClientService != null)
            {
                _brokerClientService.Connected -= OnBrokerConnected;
                _brokerClientService.Disconnected -= OnBrokerDisconnected;
                _brokerClientService.MessageReceived -= OnBrokerMessageReceived;
                Task.Run(async () => await _brokerClientService.DisconnectAsync()).Wait(); // 동기적으로 종료 시도
                (_brokerClientService as IDisposable)?.Dispose();
            }
        }
    }
}
여기까지 로그인 창과 메인 창 ViewModel의 기본 구조입니다. 다음으로 이 ViewModel들을 사용하는 XAML View (LoginWindow.xaml, MainWindow.xaml, 그리고 Agent 추가/수정용 AgentConfigWindow.xaml과 그 ViewModel) 및 App.xaml.cs를 제공하겠습니다.