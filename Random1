# ... (파일 상단 import 및 Flask 앱 초기화, 다른 모든 라우트들은 이전 최종본과 동일하게 유지) ...
# ... (login, logout, index, view_post, edit_post (이것은 잘 동작한다고 하셨음), upload_image, 카테고리 관리 등) ...

@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    # 카테고리 로드 부분은 그대로 둡니다.
    cats = []
    if Category:
        try:
            cats = Category.query.order_by(Category.name).all()
        except Exception as e:
            app.logger.error(f"Error fetching categories for new_post: {e}")
            flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")

    if request.method == 'POST':
        title = request.form.get('title')
        # 1. 폼에서 content를 받습니다. (edit_post.html의 form에 onsubmit="tinymce.triggerSave();" 필수)
        content_from_form = request.form.get('content', '') 
        
        category_id_str = request.form.get('category_id')
        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input', '').strip()

        if not title:
            flash('제목을 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, post=None, selected_category_id=category_id_str)

        # --- 디버깅: 서버가 받은 content 값을 터미널에 자세히 출력 ---
        app.logger.debug("="*50)
        app.logger.debug(f"NEW_POST: Raw 'content' received from form:")
        app.logger.debug(content_from_form)
        app.logger.debug("="*50)
        # --- 디버깅 끝 ---

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        
        try:
            if not Post: 
                app.logger.error("NEW_POST: Post model is not available!")
                raise Exception("Post model is not available.")

            # 2. Post 객체를 생성하고, 받은 content_from_form을 '그대로' 할당합니다.
            new_post_obj = Post(title=title, content="[PLACEHOLDER_WILL_BE_OVERWRITTEN]", category_id=processed_category_id)
            
            # 3. content를 명시적으로 다시 한번 할당 (SQLAlchemy가 객체를 추적하기 시작한 후)
            new_post_obj.content = content_from_form
            
            # --- 디버깅: Post 객체에 content가 할당된 후의 값 확인 ---
            app.logger.debug(f"NEW_POST: 'content' assigned to Post object (new_post_obj.content):")
            app.logger.debug(new_post_obj.content)
            app.logger.debug("="*50)
            # --- 디버깅 끝 ---

            # 비밀번호 처리 로직 (이전과 동일)
            if is_protected_from_form:
                if password_from_form: 
                    new_post_obj.set_password(password_from_form)
                else: 
                    flash('비밀번호로 보호를 선택했지만, 비밀번호를 입력하지 않았습니다. 보호되지 않은 글로 저장됩니다.', 'warning')
                    new_post_obj.is_password_protected = False
                    new_post_obj.password_hash = None
            else: 
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None
            
            # 4. 데이터베이스 세션에 추가
            db.session.add(new_post_obj)
            
            # --- 디버깅: db.session.add() 이후, commit() 직전 new_post_obj.content 확인 ---
            # SQLAlchemy가 변경 사항을 추적하는지 보기 위해 (보통 add 후에는 큰 변화 없음)
            app.logger.debug(f"NEW_POST: Post object content AFTER db.session.add() (new_post_obj.content):")
            app.logger.debug(new_post_obj.content)
            app.logger.debug("="*50)
            # --- 디버깅 끝 ---

            # 5. 데이터베이스에 최종 커밋
            db.session.commit() 

            # --- 디버깅: commit() 이후, new_post_obj.id 와 new_post_obj.content 확인 ---
            # (커밋 후에는 객체가 DB와 동기화됨)
            app.logger.debug(f"NEW_POST: Post object content AFTER db.session.commit() (Post ID: {new_post_obj.id}, new_post_obj.content):")
            app.logger.debug(new_post_obj.content)
            app.logger.debug("="*50)
            # --- 디버깅 끝 ---

            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        
        except Exception as e:
            if db and db.session.is_active : 
                db.session.rollback()
            app.logger.error(f"Error creating post in NEW_POST: {e}", exc_info=True) # exc_info=True 로 스택 트레이스 전체 로깅
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, post=None, selected_category_id=category_id_str)

    # GET 요청 시
    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None)

# ... (나머지 app.py 코드는 이전 최종본과 동일하게 유지: edit_post, view_post, upload_image, 카테고리 관리, 실행 부분 등) ...