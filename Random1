eraControl과 관련된 부분에서 문제가 발생하는 경우, 특히 .cameraControl에서 빨간 글씨로 표시되는 문제는 CameraX 및 Camera2 API와의 통합에서 발생하는 흔한 문제 중 하나입니다. 이 부분을 해결하기 위해, CameraX에서 Camera2 API를 사용한 제어 방법을 더 명확하게 설명드리겠습니다.

문제 원인
.cameraControl은 CameraX의 Camera 객체에서 제공하는 카메라 제어 인터페이스입니다. 그러나 코드가 컴파일되지 않거나 .cameraControl에서 오류가 발생한다면, 이는 Camera 객체가 올바르게 초기화되지 않았거나 관련 라이브러리가 제대로 설정되지 않았기 때문일 수 있습니다.

해결 방법
카메라 제어(cameraControl)를 사용하기 위해서는 CameraX와 Camera2 API를 올바르게 설정해야 합니다. 아래는 CameraX와 Camera2 API를 사용하여 카메라 컨트롤을 설정하는 방법을 다시 설명한 것입니다.

올바른 CameraX 설정과 Camera2Interop 사용
아래 코드는 CameraX와 Camera2 API를 통합하여 카메라를 제어하는 방법을 설명합니다.

kotlin
코드 복사
package com.example.myapp

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Rect
import android.hardware.camera2.CaptureRequest
import android.hardware.camera2.params.MeteringRectangle
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.camera.camera2.interop.Camera2CameraControl
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.core.Camera
import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var previewView: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private var camera: Camera? = null // Camera 객체 선언

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        previewView = findViewById(R.id.previewView)
        cameraExecutor = Executors.newSingleThreadExecutor()

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            // 프리뷰 빌더를 초기화하고 Camera2Interop을 사용해 추가 설정 적용
            val previewBuilder = Preview.Builder()
            val camera2Interop = Camera2Interop.Extender(previewBuilder)

            // 포커스 영역 설정 (예: 화면 중앙의 20% 영역)
            val sensorArraySize = cameraProvider.getAvailableCameraInfos()[0]
                .cameraControl.cameraInfo.sensorInfo.pixelArraySize

            val focusArea = Rect(
                (sensorArraySize.width * 0.4).toInt(),
                (sensorArraySize.height * 0.4).toInt(),
                (sensorArraySize.width * 0.6).toInt(),
                (sensorArraySize.height * 0.6).toInt()
            )

            val meteringRectangle = MeteringRectangle(focusArea, MeteringRectangle.METERING_WEIGHT_MAX)

            camera2Interop.setCaptureRequestOption(
                CaptureRequest.CONTROL_AF_MODE,
                CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
            )

            camera2Interop.setCaptureRequestOption(
                CaptureRequest.CONTROL_AF_REGIONS,
                arrayOf(meteringRectangle)
            )

            camera2Interop.setCaptureRequestOption(
                CaptureRequest.CONTROL_AE_REGIONS,
                arrayOf(meteringRectangle)
            )

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview
                ) // Camera 객체 초기화

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<String>, grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE_PERMISSIONS) {
            if (allPermissionsGranted()) {
                startCamera()
            } else {
                // 권한이 거부된 경우 처리
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA
        )
    }
}
중요한 부분들:
Camera 객체 선언 및 초기화:

camera: Camera? 변수를 선언하여 CameraX의 Camera 객체를 참조합니다.
camera = cameraProvider.bindToLifecycle(...)에서 Camera 객체를 초기화합니다. 이 객체는 카메라 제어(cameraControl)를 수행하는 데 필요합니다.
CameraControl 사용:

cameraControl을 사용하여 줌이나 포커스 설정 등을 제어할 수 있습니다. 예를 들어, 줌 기능을 설정하려면 camera?.cameraControl?.setZoomRatio(...)를 사용할 수 있습니다.
Camera2Interop 사용:

Camera2Interop.Extender를 사용하여 Camera2 API의 기능에 접근합니다. 이를 통해 포커스 영역, 자동 초점 모드 등을 설정할 수 있습니다.
의존성 추가:
CameraX와 Camera2Interop을 사용하려면 다음과 같은 의존성이 build.gradle(:app) 파일에 추가되어야 합니다.

gradle
코드 복사
dependencies {
    implementation "androidx.camera:camera-core:1.1.0"
    implementation "androidx.camera:camera-camera2:1.1.0"
    implementation "androidx.camera:camera-lifecycle:1.1.0"
    implementation "androidx.camera:camera-view:1.0.0-alpha31"
}
프로젝트 동기화:
의존성을 추가한 후, 반드시 프로젝트를 동기화(Sync)하세요. 그래야 Android Studio에서 라이브러리를 올바르게 인식하고 사용할 수 있습니다.
결론:
위 코드에서 cameraControl 관련 문제를 해결하기 위해 CameraX의 Camera 객체를 명확하게 초기화하고, 이를 통해 카메라 제어 기능을 사용할 수 있습니다. 추가적인 문제나 질문이 있다면 언제든지 말씀해 주세