말씀하신 요구 사항을 다시 정리하면 다음과 같습니다:

파일 이동 프로세스:

파일 이동은 별도로 주기적으로 이루어지며, 감지할 때 백업 폴더에 있는 파일을 대상으로 처리합니다.
초기 실행 시:

첫 실행 시 백업 폴더에서 최근 20개의 파일을 가져옵니다.
가져온 파일은 모두 완료된 파일로 처리합니다.
이후 새로 백업된 파일은 처리 대상으로 감지되고 정상적으로 처리됩니다.
무한 루프:

주기적으로 백업 폴더에서 파일을 감지하고 처리하는데, 백업된 파일 중 처음 20개는 이미 완료된 것으로 처리해야 하며, 그 이후로 들어오는 파일만 정상적으로 처리되도록 설정합니다.
다음은 요구 사항을 반영한 전체 코드를 작성하겠습니다.

수정된 FileProcessor.cs 코드
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Timers;

public class FileProcessor
{
    private string _inputDirectory;  // 원본 파일을 감지할 디렉토리
    private string _backupDirectory;  // 백업 디렉토리
    private Timer _cleanupTimer;  // 파일 삭제 타이머
    private bool _isInitialRun = true;  // 첫 실행 여부 체크

    public event Action<LogEntry> OnLogEntryDetected;

    public FileProcessor(string inputDirectory)
    {
        _inputDirectory = inputDirectory;
        _backupDirectory = @"C:\MESPRODFILE_Backup";

        // 24시간마다 한 번씩 파일 정리 작업 실행
        _cleanupTimer = new Timer(TimeSpan.FromDays(1).TotalMilliseconds);
        _cleanupTimer.Elapsed += (sender, args) => CleanupOldFiles();
        _cleanupTimer.Start();
    }

    /// <summary>
    /// 파일 감지 및 처리 작업 시작
    /// </summary>
    public void StartProcessing()
    {
        Task.Run(() => MoveFilesToBackup());
        Task.Run(() => MonitorBackupDirectory());
    }

    /// <summary>
    /// 주기적으로 원본 디렉토리에서 파일을 백업 디렉토리로 이동
    /// </summary>
    private void MoveFilesToBackup()
    {
        while (true)
        {
            var files = Directory.GetFiles(_inputDirectory, "*.txt");
            foreach (var file in files)
            {
                MoveFileToBackup(file);
            }
            Task.Delay(5000).Wait();  // 5초마다 디렉토리 확인
        }
    }

    /// <summary>
    /// 백업 폴더를 감시하여 파일을 처리
    /// </summary>
    private void MonitorBackupDirectory()
    {
        if (_isInitialRun)
        {
            // 첫 실행 시 최근 20개 파일을 미리 완료 처리
            ProcessRecentFiles();
            _isInitialRun = false;  // 초기 실행 체크 해제
        }

        while (true)
        {
            var files = Directory.GetFiles(_backupDirectory, "*.txt");
            foreach (var file in files)
            {
                ProcessFile(file);
            }
            Task.Delay(5000).Wait();  // 5초마다 백업 디렉토리 확인
        }
    }

    /// <summary>
    /// 첫 실행 시 백업 폴더에서 최근 20개의 파일을 완료 처리
    /// </summary>
    private void ProcessRecentFiles()
    {
        try
        {
            // 백업 폴더의 파일 목록에서 최근 20개 파일 가져오기
            var recentFiles = Directory.GetFiles(_backupDirectory, "*.txt")
                                       .OrderByDescending(f => File.GetLastWriteTime(f))
                                       .Take(20);

            foreach (var file in recentFiles)
            {
                Console.WriteLine($"Processing recent file (completed): {file}");
                CompleteFile(file);  // 완료 처리
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing recent files: {ex.Message}");
        }
    }

    /// <summary>
    /// 파일을 백업 폴더로 이동
    /// </summary>
    private void MoveFileToBackup(string filePath)
    {
        try
        {
            // 백업 폴더 경로 생성 (yyyyMMdd 형식)
            string backupSubDirectory = Path.Combine(_backupDirectory, DateTime.Now.ToString("yyyyMMdd"));
            if (!Directory.Exists(backupSubDirectory))
            {
                Directory.CreateDirectory(backupSubDirectory);
            }

            // 백업 파일 경로 설정
            string destinationPath = Path.Combine(backupSubDirectory, Path.GetFileName(filePath));

            // 파일 이동
            File.Move(filePath, destinationPath);

            Console.WriteLine($"Moved file to backup: {destinationPath}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error moving file to backup: {ex.Message}");
        }
    }

    /// <summary>
    /// 백업된 파일을 처리
    /// </summary>
    private void ProcessFile(string filePath)
    {
        try
        {
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 처리 완료 후 이벤트 발생
            OnLogEntryDetected?.Invoke(logEntry);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 완료된 파일로 처리 (첫 실행 시 20개)
    /// </summary>
    private void CompleteFile(string filePath)
    {
        try
        {
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 완료 처리를 위한 파일 내용 처리
            Console.WriteLine($"Completed file: {filePath} with Time: 0 (initial files)");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error completing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 로그 파일의 내용을 파싱하여 LogEntry 객체로 변환
    /// </summary>
    private LogEntry ParseLogEntry(string[] lines)
    {
        // 로그 엔트리 파싱 로직 구현 (필요에 따라 수정)
        var logEntry = new LogEntry
        {
            MAG_NO = ExtractField(lines, "MAG_NO"),
            MAG_QTY = int.Parse(ExtractField(lines, "MAG_QTY")),
            BASIC_MODEL = ExtractField(lines, "BASIC_MODEL"),
            MODEL_CODE = ExtractField(lines, "MODEL_CODE"),
            PO_NO = ExtractField(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(ExtractField(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(ExtractField(lines, "PO_PROD_QTY")),
            SequenceFlag = DetermineSequenceFlag(ExtractField(lines, "PO_PLAN_QTY"), ExtractField(lines, "PO_PROD_QTY")),
            Time = 0  // 완료된 파일로 처리할 경우 Time을 0으로 설정
        };
        return logEntry;
    }

    /// <summary>
    /// 로그 파일에서 각 필드를 추출하는 도우미 함수
    /// </summary>
    private string ExtractField(string[] lines, string fieldName)
    {
        var line = lines.FirstOrDefault(l => l.StartsWith(fieldName + "="));
        if (line != null)
        {
            return line.Split('=')[1].Trim();
        }
        return string.Empty;
    }

    /// <summary>
    /// 시퀀스 플래그 결정 (첫 파일: 1, 중간 파일: 2, 마지막 파일: 3)
    /// </summary>
    private int DetermineSequenceFlag(string planQty, string prodQty)
    {
        int plan = int.Parse(planQty);
        int prod = int.Parse(prodQty);
        if (prod == 0) return 1;  // 첫 번째 파일
        if (prod < plan) return 2;  // 중간 파일
        if (prod >= plan) return 3;  // 마지막 파일
        return 0;  // 기본값
    }

    /// <summary>
    /// 3개월 이상 지난 백업 파일을 삭제
    /// </summary>
    private void CleanupOldFiles()
    {
        try
        {
            // 3개월 전 날짜 계산
            DateTime thresholdDate = DateTime.Now.AddMonths(-3);

            var directories = Directory.GetDirectories(_backupDirectory);
            foreach (var directory in directories)
            {
                DateTime directoryDate;
                if (DateTime.TryParseExact(Path.GetFileName(directory), "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out directoryDate))
                {
                    // 3개월 이상 된 디렉토리 삭제
                    if (directoryDate < thresholdDate)
                    {
                        Directory.Delete(directory, true);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error cleaning up old files: {ex.Message}");
        }
    }
}
변경된 사항
파일 이동 작업과 감지 작업을 분리:

MoveFilesToBackup: 파일을 주기적으로 원본 디렉토리에서 백업 폴더로 이동하는 역할을 합니다.
MonitorBackupDirectory: 백업된 파일을 처리하는 역할을 담당하며, 새 파일이 감지되면 처리합니다.
초기 실행 시 최근 20개 파일 완료 처