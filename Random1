, 알겠습니다. SearchTimer_Tick에서 "대상 창/프로세스를 찾는 중..." 메시지가 계속 뜨는데, 사용자님께서는 'InlineTesterPBA'로 시작하는 프로세스가 분명히 실행 중이라고 생각하시는 상황이군요.

이 경우, GetTargetWindowHandle() 함수가 실제로 무엇을 찾고 있고, 왜 못 찾는지를 상세히 추적하는 로그가 필요합니다. 이 함수는 단순히 프로세스가 실행 중인지 뿐만 아니라, 화면 캡처에 사용할 수 있는 **유효한 창 핸들(Window Handle, HWND)**을 가지고 있는지를 최종적으로 확인하기 때문입니다.

요청하신 대로, GetTargetWindowHandle() 함수 내부에 아주 상세한 추적 로그를 추가하여, 현재 실행 중인 프로세스 목록 (검색 대상과 관련된), 찾으려는 대상 정보, 그리고 왜 일치하지 않는지에 대한 설명까지 로그로 남기도록 수정하겠습니다.

MainWindow.xaml.cs 파일 내 GetTargetWindowHandle() 함수 수정
아래 코드는 GetTargetWindowHandle() 함수만 수정한 것입니다. 기존 MainWindow.xaml.cs 파일에서 이 함수 부분을 아래 코드로 교체하시면 됩니다. 다른 부분은 수정하지 마세요.

C#

        // GetTargetWindowHandle 함수 (상세 추적 로그 추가 버전)
        private IntPtr GetTargetWindowHandle()
        {
            string target = txtTarget.Text; // UI에서 현재 설정된 대상 값
            string searchMethod = rbFindByTitle.IsChecked == true ? "창 제목" : "프로세스 이름";

            LogTrace($"GetTargetWindowHandle: 함수 진입. UI에 설정된 대상: '{target}', 탐색 방법: '{searchMethod}'");

            if (string.IsNullOrWhiteSpace(target))
            {
                LogTrace("GetTargetWindowHandle: 대상 문자열이 비어있으므로 IntPtr.Zero 반환.");
                return IntPtr.Zero;
            }

            if (rbFindByTitle.IsChecked == true)
            {
                LogTrace($"GetTargetWindowHandle: '창 제목으로 찾기' 실행. 찾을 제목: '{target}'");
                IntPtr hWndByTitle = FindWindow(null, target); // 첫 번째 인자는 ClassName, null이면 모든 클래스 대상
                if (hWndByTitle != IntPtr.Zero)
                {
                    LogTrace($"GetTargetWindowHandle: FindWindow API 성공! 창 제목 '{target}'에 해당하는 핸들 {hWndByTitle} 찾음.");
                }
                else
                {
                    LogTrace($"GetTargetWindowHandle: FindWindow API 실패. 창 제목 '{target}'에 해당하는 핸들 찾지 못함.");
                }
                return hWndByTitle;
            }
            else // rbFindByProcess.IsChecked == true (프로세스 이름으로 찾기)
            {
                string processNameForSearch = target.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ? Path.GetFileNameWithoutExtension(target) : target;
                LogTrace($"GetTargetWindowHandle: '프로세스 이름으로 찾기' 실행. 검색할 정제된 프로세스 이름: '{processNameForSearch}'");

                Process[] processes;
                try
                {
                    processes = Process.GetProcessesByName(processNameForSearch);
                }
                catch (Exception ex)
                {
                    LogTrace($"GetTargetWindowHandle: Process.GetProcessesByName('{processNameForSearch}') 호출 중 오류 발생: {ex.Message}. IntPtr.Zero 반환.");
                    return IntPtr.Zero;
                }
                
                LogTrace($"GetTargetWindowHandle: Process.GetProcessesByName('{processNameForSearch}') 결과, {processes.Length}개의 프로세스 인스턴스 발견.");

                if (processes.Length == 0)
                {
                    LogTrace($"GetTargetWindowHandle: '{processNameForSearch}' 이름의 활성 프로세스를 찾을 수 없음. IntPtr.Zero 반환.");
                    // 추가 디버깅: 현재 실행 중인 모든 프로세스 중 비슷한 이름이 있는지 확인 (너무 많을 수 있으니 주의)
                    /* var allProcs = Process.GetProcesses().Select(p => p.ProcessName).Distinct().OrderBy(name => name);
                    LogTrace($"GetTargetWindowHandle: 참고 - 현재 실행 중인 모든 프로세스 이름 (일부): {string.Join(", ", allProcs.Take(20))}{(allProcs.Count() > 20 ? "..." : "")}");
                    */
                    return IntPtr.Zero;
                }

                LogTrace($"GetTargetWindowHandle: 발견된 {processes.Length}개 프로세스 인스턴스 각각의 MainWindowHandle 검사 시작...");
                for (int i = 0; i < processes.Length; i++)
                {
                    Process p = processes[i];
                    IntPtr currentHandle = IntPtr.Zero;
                    string processIdInfo = "N/A";
                    string mainWindowTitle = "N/A";
                    bool hasExited = false;

                    try
                    {
                        if (!p.HasExited) // 프로세스가 이미 종료되었는지 확인
                        {
                            currentHandle = p.MainWindowHandle;
                            processIdInfo = p.Id.ToString();
                            mainWindowTitle = string.IsNullOrEmpty(p.MainWindowTitle) ? "(비어 있음)" : p.MainWindowTitle;
                        }
                        else
                        {
                            hasExited = true;
                        }
                    }
                    catch (InvalidOperationException ioe) // 프로세스가 이미 종료된 후 속성에 접근하려 할 때
                    {
                        LogTrace($"  - [{i+1}/{processes.Length}] 프로세스 '{p.ProcessName}' (ID 접근 불가) 검사 중 오류: {ioe.Message} (이미 종료된 프로세스일 수 있음)");
                        hasExited = true; // 오류 발생 시 종료된 것으로 간주
                    }
                    catch (Exception ex) // 기타 예외
                    {
                         LogTrace($"  - [{i+1}/{processes.Length}] 프로세스 '{p.ProcessName}' 검사 중 예외: {ex.Message}");
                    }


                    if (hasExited)
                    {
                        LogTrace($"  - [{i+1}/{processes.Length}] 프로세스 '{p.ProcessName}'는 이미 종료된 상태입니다. 건너뜁니다.");
                        continue;
                    }
                    
                    LogTrace($"  - [{i+1}/{processes.Length}] 검사 중: 프로세스 ID {processIdInfo} ('{p.ProcessName}'), MainWindowHandle: {currentHandle}, MainWindowTitle: '{mainWindowTitle}'");
                    
                    if (currentHandle != IntPtr.Zero)
                    {
                        LogTrace($"  - 유효한 MainWindowHandle ({currentHandle}) 발견! 이 핸들을 사용합니다.");
                        return currentHandle;
                    }
                    else
                    {
                        LogTrace($"  - 이 프로세스 인스턴스의 MainWindowHandle이 0입니다. (화면에 주 창이 없거나, 아직 생성되지 않았거나, UI가 없는 프로세스일 수 있습니다)");
                    }
                }

                LogTrace($"GetTargetWindowHandle: '{processNameForSearch}' 이름의 프로세스들은 {processes.Length}개 찾았으나, 모두 유효한 MainWindowHandle (0이 아닌 값)을 가지고 있지 않습니다. 캡처 가능한 창이 없다고 판단하여 IntPtr.Zero 반환.");
                return IntPtr.Zero;
            }
        }
사용 방법 및 다음 단계
위 GetTargetWindowHandle 함수 코드를 MainWindow.xaml.cs 파일의 기존 함수와 교체합니다.
프로그램을 다시 빌드하고 클릭원스로 게시한 후, 문제가 발생하는 PC에서 실행합니다.
프로그램이 대상을 찾지 못하고 1분마다 재탐색을 시도하는 상태가 되면, 몇 분 정도 기다렸다가 프로그램을 종료합니다.
C:\Agent\funcenvget\logs\trace_log.txt 파일을 엽니다.
파일 내용 중에서 GetTargetWindowHandle 함수가 호출될 때 기록되는 로그들을 찾아 그 내용을 전체적으로 복사해서 저에게 알려주세요.
특히 아래와 같은 로그 패턴을 주목해서 알려주시면 됩니다.

GetTargetWindowHandle: 'InlineTesterPBA' 이름으로 N개의 프로세스 찾음. (여기서 N이 몇 개인지)
GetTargetWindowHandle: 발견된 N개 프로세스 인스턴스 각각의 MainWindowHandle 검사 시작...
- [번호] 검사 중: 프로세스 ID XXX ('InlineTesterPBA...'), MainWindowHandle: YYY, MainWindowTitle: 'ZZZ' (여기서 YYY가 항상 0인지, 아니면 다른 값인지, ZZZ는 무엇인지)
GetTargetWindowHandle: ... MainWindowHandle이 0입니다. ...
GetTargetWindowHandle: ... 유효한 MainWindowHandle을 가진 프로세스가 없음 ...
이 로그를 보면, "InlineTesterPBA"로 시작하는 프로세스를 이름으로는 찾았는지, 찾았다면 왜 그 프로세스의 창 핸들(MainWindowHandle)을 가져오지 못하는지 (또는 가져왔는데 왜 0인지) 명확하게 알 수 있습니다.