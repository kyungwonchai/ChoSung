여러 요청 사항을 반영하여 SocketClientMergeOI 클래스에서 메시지 기록을 읽기 전용 ObservableCollection으로 관리하며, 메시지는 최대 50개로 제한하고, 발신자, 수신자, 전송 메시지, 응답 메시지 및 날짜 정보를 포함하도록 설계하겠습니다. 이 정보를 WPF의 DataGrid에 표시할 수 있도록 MainViewModel에서 바인딩하는 방식으로 구현할 것입니다.

SocketClientMergeOI 클래스
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientMergeOI
{
    private TcpClient _client; // TCP 클라이언트 객체
    private NetworkStream _stream; // 네트워크 스트림
    private readonly string _ipAddress; // 접속할 서버의 IP 주소
    private readonly int _port; // 접속할 서버의 포트 번호
    private bool _isConnected; // 서버와의 연결 여부 플래그
    private readonly int _retryInterval = 10000; // 10초 간격으로 재연결 시도

    // ObservableCollection을 사용하여 메시지 목록 관리
    public ObservableCollection<MessageLog> MessageLogs { get; private set; } // 읽기 전용

    // 생성자: IP 주소와 포트로 소켓 클라이언트를 초기화
    public SocketClientMergeOI(string ipAddress, int port)
    {
        _ipAddress = ipAddress; // 입력받은 IP 저장
        _port = port; // 입력받은 포트 저장
        _client = new TcpClient(); // TCP 클라이언트 생성
        _isConnected = false; // 초기 연결 상태 false
        MessageLogs = new ObservableCollection<MessageLog>(); // 메시지 로그 초기화
        StartConnectionAttemptAsync(); // 연결 시도 시작
    }

    // 서버에 연결 시도하는 비동기 함수
    private async void StartConnectionAttemptAsync()
    {
        while (!_isConnected) // 연결이 될 때까지 반복
        {
            try
            {
                await _client.ConnectAsync(_ipAddress, _port); // 서버에 연결 시도
                _isConnected = true; // 연결 성공
                _stream = _client.GetStream(); // 스트림 생성
                LogMessage("System", _ipAddress, "Connected", ""); // 연결 성공 로그 남김
                StartReceiving(); // 메시지 수신 대기
            }
            catch (Exception)
            {
                LogMessage("System", _ipAddress, "Retrying in 10 seconds...", ""); // 재시도 로그
                await Task.Delay(_retryInterval); // 10초 대기 후 재시도
            }
        }
    }

    // 메시지를 전송하고 응답을 받는 비동기 함수
    public async Task<string> SendAndReceiveMessageAsync(string message)
    {
        if (!_isConnected) // 연결이 되어 있지 않으면
            return "Not connected";

        string fullMessage = $"\x02{message}\x03"; // STX 및 ETX 추가
        byte[] messageBytes = Encoding.ASCII.GetBytes(fullMessage); // 메시지를 바이트 배열로 변환

        try
        {
            await _stream.WriteAsync(messageBytes, 0, messageBytes.Length); // 서버에 전송
            LogMessage("Client", _ipAddress, message, ""); // 전송 로그 남김
        }
        catch (Exception)
        {
            return "Send Failed";
        }

        // 서버로부터 응답 대기 및 검증
        string response = await ReceiveMessageAsync();
        LogMessage(_ipAddress, "Client", message, response); // 응답 로그 기록
        return ValidateResponse(message, response); // 응답 검증 후 결과 반환
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async Task<string> ReceiveMessageAsync()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

        try
        {
            int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 수신
            if (bytesRead > 0)
            {
                string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신된 데이터를 문자열로 변환
                return receivedMessage; // 변환된 메시지 반환
            }
        }
        catch (Exception)
        {
            _isConnected = false; // 연결이 끊긴 경우
            LogMessage("System", _ipAddress, "Connection lost", ""); // 연결 끊김 로그
            StartConnectionAttemptAsync(); // 다시 연결 시도
        }

        return string.Empty;
    }

    // 메시지 로그 추가 함수
    private void LogMessage(string sender, string receiver, string sentMessage, string responseMessage)
    {
        // 로그 항목 추가
        MessageLog log = new MessageLog
        {
            Timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
            Sender = sender,
            Receiver = receiver,
            SentMessage = sentMessage,
            ResponseMessage = responseMessage
        };

        if (MessageLogs.Count >= 50) // 최대 50개 로그 유지
        {
            MessageLogs.RemoveAt(0); // 오래된 항목 삭제
        }

        MessageLogs.Add(log); // 새로운 항목 추가
    }

    // 응답 검증 함수
    private string ValidateResponse(string sentMessage, string receivedMessage)
    {
        if (receivedMessage.StartsWith("\x02") && receivedMessage.EndsWith("\x03"))
        {
            string cleanMessage = receivedMessage.Trim('\x02', '\x03');
            if (cleanMessage == "OK")
            {
                return "OK";
            }
            else if (cleanMessage == sentMessage)
            {
                return "NG";
            }
        }
        return "Invalid Response";
    }

    // 연결을 중지하는 함수
    public void StopConnection()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
    }
}

// 메시지 로그를 위한 클래스
public class MessageLog
{
    public string Timestamp { get; set; } // 메시지의 타임스탬프
    public string Sender { get; set; } // 발신자
    public string Receiver { get; set; } // 수신자
    public string SentMessage { get; set; } // 전송된 메시지
    public string ResponseMessage { get; set; } // 수신된 응답 메시지
}
MainViewModel 클래스
csharp
코드 복사
using System.Collections.ObjectModel;

public class MainViewModel
{
    public ObservableCollection<MessageLog> MessageLogs { get; set; } // DataGrid에 바인딩될 메시지 로그 컬렉션
    private SocketClientMergeOI _socketClient; // SocketClientMergeOI 인스턴스

    public MainViewModel()
    {
        // 소켓 클라이언트 생성
        _socketClient = new SocketClientMergeOI("127.0.0.1", 2400);

        // 소켓 클라이언트의 메시지 로그를 MainViewModel의 MessageLogs에 바인딩
        MessageLogs = _socketClient.MessageLogs;
    }
}
XAML (DataGrid 바인딩)
xml
코드 복사
<Window x:Class="SocketClientApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Socket Client" Height="400" Width="600">
    <Grid>
        <!-- 메시지 로그를 보여줄 DataGrid -->
        <DataGrid ItemsSource="{Binding MessageLogs}" AutoGenerateColumns="False" IsReadOnly="True" Width="580" Height="350" HorizontalAlignment="Center" VerticalAlignment="Center">
            <DataGrid.Columns>
                <!-- 타임스탬프 -->
                <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="150"/>
                <!-- 발신자 -->
                <DataGridTextColumn Header="Sender" Binding="{Binding Sender}" Width="100"/>
                <!-- 수신자 -->
                <DataGridTextColumn Header="Receiver" Binding="{Binding Receiver}" Width="100"/>
                <!-- 전송 메시지 -->
                <DataGridTextColumn Header="Sent Message" Binding="{Binding SentMessage}" Width="150"/>
                <!-- 응답 메시지 -->
                <DataGridTextColumn Header="Response Message" Binding="{Binding ResponseMessage}" Width="150"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
SocketClientMergeOI 클래스:

**ObservableCollection<MessageLog>**을 사용해 최대 50개의 메시지 로그를 저장합니다.
메시지를 전송할 때와 수신할 때마다 로그를 추가하며, 오래된 로그는 자동으로 삭제됩니다.
LogMessage 함수를 통해 발신자, 수신자, 전송 메시지, 응답 메시지, 타임스탬프를 저장합니다.
MainViewModel 클래스:

SocketClientMergeOI 인스턴스에서 관리하는 **MessageLogs**를 뷰모델에서 받아서 UI에 바인딩할 수 있게 설정합니다.
DataGrid에 **ObservableCollection<Message