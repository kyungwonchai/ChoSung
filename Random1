## 1. 블렌더 모델 생성 스크립트
이 스크립트는 블렌더에서 실행하여 3D 랙 모델(Rack_Template)의 원본을 만드는 파이썬 코드입니다.

Python

# 파일명: Rack_Template_Generator.py (블렌더 스크립팅 창에서 실행)

import bpy
import math
import random # 마스크에 랜덤 색상을 적용하기 위해 random 모듈을 가져옵니다.

# --- 스크립트 실행 전 준비 작업 ---
# 기존 씬에 있는 모든 오브젝트를 선택하고 삭제하여 깨끗한 상태에서 시작합니다.
bpy.ops.object.select_all(action='SELECT')
bpy.ops.object.delete()

# =================================================================
# 1. 머티리얼(재질) 생성
# =================================================================
def create_metal_material(name, color_rgba, metallic=1.0, roughness=0.3):
    """금속 속성을 가진 머티리얼을 생성하는 함수"""
    # 새 머티리얼 데이터를 생성합니다.
    mat = bpy.data.materials.new(name=name)
    # 노드 기반의 머티리얼 설정을 활성화합니다.
    mat.use_nodes = True
    nodes = mat.node_tree.nodes
    # 기본 셰이더인 Principled BSDF 노드를 가져옵니다.
    principled_bsdf = nodes.get("Principled BSDF")
    if principled_bsdf:
        # 이 노드의 입력값들을 설정하여 재질을 정의합니다.
        principled_bsdf.inputs["Base Color"].default_value = color_rgba  # 기본 색상 (R,G,B,A)
        principled_bsdf.inputs["Metallic"].default_value = metallic      # 금속성 (1.0 = 100% 금속)
        principled_bsdf.inputs["Roughness"].default_value = roughness    # 표면 거칠기 (낮을수록 반사가 심함)
    return mat

# --- 사용할 머티리얼들을 미리 생성합니다 ---
# 랙의 프레임, 칸막이 등에 사용될 기본 회색 메탈 재질
rack_material = create_metal_material("Metal_Rack", (0.6, 0.6, 0.6, 1.0))
# 마스크에 랜덤으로 적용될 핑크색, 노란색 메탈 재질
pink_metal_material = create_metal_material("LightPink_Metal", (1.0, 0.7, 0.8, 1.0))
yellow_metal_material = create_metal_material("Yellow_Metal", (1.0, 0.9, 0.2, 1.0))
# 랜덤 선택을 위해 두 머티리얼을 리스트에 담아둡니다.
mask_materials = [pink_metal_material, yellow_metal_material]


# =================================================================
# 2. 랙 모델의 크기 및 구조 정의
# =================================================================
SLOT_COUNT = 12
FLOOR_NAMES = ['A', 'B', 'C'] # 위에서부터 A, B, C 층
SLOT_WIDTH = 0.08      # 슬롯 1개의 너비
SLOT_HEIGHT = 0.6      # 슬롯 1개의 높이
SLOT_DEPTH = 0.5       # 랙의 깊이
DIVIDER_THICKNESS = 0.01 # 칸막이 두께
FRAME_THICKNESS = 0.04 # 외부 프레임 두께
LAMP_RADIUS = 0.01     # 램프의 반지름
LAMP_DEPTH = 0.005     # 램프의 두께
MASK_THICKNESS = 0.01  # 마스크 판 자체의 수직 두께

# =================================================================
# 3. 랙 모델링 자동 생성 시작
# =================================================================
# 모든 파트를 담을 최상위 부모 오브젝트를 생성합니다. (유니티에서 관리가 편해짐)
rack_parent = bpy.data.objects.new("Rack_Template", None)
bpy.context.collection.objects.link(rack_parent)

def create_box(name, size, position, material):
    """주어진 정보로 사각형 파트를 만들고 재질을 입히는 함수"""
    bpy.ops.mesh.primitive_cube_add(location=position)
    box = bpy.context.active_object
    box.name = name
    # 유니티의 스케일(1,1,1)과 맞추기 위해 크기를 scale로 조절합니다.
    box.scale = (size[0] / 2, size[1] / 2, size[2] / 2)
    box.parent = rack_parent
    # 오브젝트에 머티리얼을 적용합니다.
    if box.data.materials:
        box.data.materials[0] = material
    else:
        box.data.materials.append(material)
    return box

# --- 외부 프레임 및 뒷면 패널 생성 ---
RACK_TOTAL_WIDTH = (SLOT_WIDTH * SLOT_COUNT) + (DIVIDER_THICKNESS * (SLOT_COUNT + 1))
RACK_TOTAL_HEIGHT = (SLOT_HEIGHT * FLOOR_COUNT) + (DIVIDER_THICKNESS * (FLOOR_COUNT - 1)) + (FRAME_THICKNESS * 2)
top_frame_z = RACK_TOTAL_HEIGHT / 2 - FRAME_THICKNESS / 2
bottom_frame_z = -RACK_TOTAL_HEIGHT / 2 + FRAME_THICKNESS / 2
create_box("Frame_Top", (RACK_TOTAL_WIDTH, SLOT_DEPTH, FRAME_THICKNESS), (0, 0, top_frame_z), rack_material)
create_box("Frame_Bottom", (RACK_TOTAL_WIDTH, SLOT_DEPTH, FRAME_THICKNESS), (0, 0, bottom_frame_z), rack_material)
back_panel_y = -SLOT_DEPTH / 2 + (DIVIDER_THICKNESS / 2)
panel_height = RACK_TOTAL_HEIGHT - (FRAME_THICKNESS * 2)
create_box("Back_Panel", (RACK_TOTAL_WIDTH, DIVIDER_THICKNESS, panel_height), (0, back_panel_y, 0), rack_material)

# --- 층별 구조 (구분선, 칸막이, 램프, 마스크) 생성 ---
start_x = -RACK_TOTAL_WIDTH / 2
start_z = RACK_TOTAL_HEIGHT / 2 - FRAME_THICKNESS

# 층(A, B, C)을 순회하며 생성
for i, floor_name in enumerate(FLOOR_NAMES):
    floor_base_z = start_z - i * (SLOT_HEIGHT + DIVIDER_THICKNESS)
    
    # 층간 가로 구분선 생성 (맨 아래층 제외)
    if i < FLOOR_COUNT - 1:
        divider_z = floor_base_z - SLOT_HEIGHT - (DIVIDER_THICKNESS / 2)
        create_box(f"Floor_Divider_{floor_name}", (RACK_TOTAL_WIDTH, SLOT_DEPTH, DIVIDER_THICKNESS), (0, 0, divider_z), rack_material)
    
    # 각 층의 세로 칸막이(SLOT_COUNT + 1개)를 순회하며 생성
    for j in range(SLOT_COUNT + 1):
        divider_x = start_x + (DIVIDER_THICKNESS / 2) + j * (SLOT_WIDTH + DIVIDER_THICKNESS)
        divider_z = floor_base_z - (SLOT_HEIGHT / 2)
        create_box(f"Vertical_Divider_{floor_name}{j+1:02d}", (DIVIDER_THICKNESS, SLOT_DEPTH, SLOT_HEIGHT), (divider_x, 0, divider_z), rack_material)

        # 슬롯 내부 오브젝트 (램프, 마스크)는 칸막이 사이에 1개씩 생성 (SLOT_COUNT개)
        if j < SLOT_COUNT:
            slot_center_x = divider_x + (DIVIDER_THICKNESS / 2) + (SLOT_WIDTH / 2)
            slot_center_z = floor_base_z - (SLOT_HEIGHT / 2)

            # 램프 생성
            lamp_y = SLOT_DEPTH / 2 - LAMP_DEPTH / 2
            lamp_z = floor_base_z - 0.001
            bpy.ops.mesh.primitive_cylinder_add(vertices=16, radius=LAMP_RADIUS, depth=LAMP_DEPTH, location=(slot_center_x, lamp_y, lamp_z), rotation=(math.radians(90), 0, 0))
            lamp_obj = bpy.context.active_object
            lamp_obj.name = f"Lamp_{floor_name}{j+1:02d}" # 이름 부여 (예: Lamp_A01)
            lamp_obj.parent = rack_parent
            lamp_obj.data.materials.append(rack_material) # 램프에도 메탈 재질 적용
            
            # 마스크 생성 (3D 블록 형태)
            mask_height = SLOT_HEIGHT * 0.85
            mask_size = (SLOT_WIDTH * 0.95, SLOT_DEPTH * 0.98, mask_height)
            # 마스크 Z위치를 슬롯 바닥에 놓이도록 계산
            slot_bottom_z = floor_base_z - SLOT_HEIGHT
            mask_z_pos = slot_bottom_z + (mask_height / 2)
            mask_position = (slot_center_x, 0, mask_z_pos)
            mask_obj = create_box(f"Mask_{floor_name}{j+1:02d}", mask_size, mask_position, rack_material) # 이름 부여 (예: Mask_A01)

            # 마스크에 핑크 또는 노랑 메탈 재질을 랜덤으로 덮어쓰기
            chosen_material = random.choice(mask_materials)
            mask_obj.data.materials[0] = chosen_material

print("모든 오브젝트에 메탈 재질을 적용하고 마스크를 바닥에 배치했습니다: Rack_Template")
## 2. 유니티 씬 자동 구성 스크립트 (에디터 툴)
이 스크립트는 유니티 에디터의 상단 메뉴에 버튼을 만들어, 씬 구성(랙 배치, 이름 부여)을 자동화하는 C# 코드입니다. Editor 폴더 안에 있어야 합니다.

C#

// 파일명: RackLayoutGenerator.cs (반드시 'Editor' 폴더 안에 위치)

using UnityEngine;
using UnityEditor;

public class RackLayoutGenerator
{
    // --- 여기서 배치 설정을 수정할 수 있습니다 ---
    private static readonly int RACK_COUNT_PER_ROW = 12;      // 한 줄(세트)에 배치될 랙의 개수
    private static readonly float RACK_GAP = 0.01f;           // 랙과 랙 사이의 미세한 간격
    private static readonly float AISLE_WIDTH = 4.0f;         // 두 줄의 랙 세트 사이의 복도 넓이

    // 유니티 상단 메뉴에 "Tools/SMD Rack/Generate Final Layout" 항목을 추가합니다.
    [MenuItem("Tools/SMD Rack/Generate Final Layout")]
    private static void GenerateLayout()
    {
        // 1. 사용자가 Project 창에서 선택한 프리팹을 가져옵니다.
        GameObject rackPrefab = Selection.activeObject as GameObject;
        // 프리팹이 선택되지 않았으면 오류 메시지를 띄우고 중단합니다.
        if (rackPrefab == null || PrefabUtility.GetPrefabAssetType(rackPrefab) == PrefabAssetType.NotAPrefab)
        {
            EditorUtility.DisplayDialog("오류", "Project 창에서 랙 '프리팹'을 먼저 선택해주세요.", "확인");
            return;
        }

        // 2. 랙들을 담을 최상위 부모 오브젝트("Rack_Installations")를 찾거나, 없으면 새로 생성합니다.
        string parentName = "Rack_Installations";
        GameObject parentObject = GameObject.Find(parentName);
        if (parentObject == null)
        {
            parentObject = new GameObject(parentName);
        }
        else // 만약 이미 존재한다면, 기존에 있던 랙들을 모두 삭제하여 깨끗하게 다시 시작합니다.
        {
            for (int i = parentObject.transform.childCount - 1; i >= 0; i--)
            {
                GameObject.DestroyImmediate(parentObject.transform.GetChild(i).gameObject);
            }
        }
        
        // 3. 프리팹의 전체 크기를 자식들의 렌더러를 모두 포함하여 정확하게 계산합니다.
        Bounds totalBounds = new Bounds();
        Renderer[] renderers = rackPrefab.GetComponentsInChildren<Renderer>();
        if(renderers.Length > 0)
        {
            totalBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers)
            {
                totalBounds.Encapsulate(renderer.bounds);
            }
        }
        float rackWidth = totalBounds.size.x;

        // 4. 눕혀진 랙을 똑바로 세우기 위한 기본 회전 값을 미리 계산해둡니다. (X축으로 -90도 회전)
        Quaternion standingRotation = Quaternion.Euler(-90, 0, 0);

        // --- 5. 랙 세트 배치 ---
        // 첫 번째 줄 (A열) 생성
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackInstance.name = $"A_{i + 1:02d}"; // 이름 부여 (예: A_01, A_12)
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, 0);
            rackInstance.transform.rotation = standingRotation; // 똑바로 세우는 회전 적용
        }
        
        // 두 번째 줄 (B열, 마주보는 줄) 생성
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackInstance.name = $"B_{i + 1:02d}"; // 이름 부여 (예: B_01, B_12)
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, AISLE_WIDTH);
            // 먼저 랙을 똑바로 세운 뒤(standingRotation), 그 상태에서 Y축으로 180도 더 돌려 마주보게 합니다.
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 180, 0);
        }

        EditorUtility.DisplayDialog("완료", "두 랙 세트가 서로 마주보도록 최종 배치되었습니다.", "확인");
    }
}
## 3. 유니티 기능 담당 스크립트 (게임 실행 시 동작)
이 스크립트는 게임이 실행될 때의 모든 동작(바코드 처리, 램프 점등, 애니메이션)을 담당하는 C# 코드입니다. Scripts 폴더 안에 있어야 합니다.

C#

// 파일명: RackSystemManager.cs (일반 'Scripts' 폴더 안에 위치)

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Text.RegularExpressions; // 바코드 해석을 위해 정규식 사용
using System.Text; // 콘솔에 전체 키 목록 출력을 위해 사용

public class RackSystemManager : MonoBehaviour
{
    // --- Inspector 창에서 연결할 변수들 ---
    [Header("핵심 연결 대상")]
    [Tooltip("모든 랙들의 최상위 부모 오브젝트 (Rack_Installations)")]
    public Transform rackContainer;

    [Header("머티리얼")]
    [Tooltip("꺼져 있을 때의 기본 램프 머티리얼")]
    public Material defaultLampMaterial;
    [Tooltip("켜졌을 때의 발광 램프 머티리얼")]
    public Material litLampMaterial;

    [Header("애니메이션")]
    [Tooltip("마스크 슬라이드 시간")]
    public float animationDuration = 0.5f;
    [Tooltip("마스크가 앞으로 나오는 거리")]
    public float slideOutDistance = 0.4f;

    // --- 스크립트 내부에서 사용할 데이터 저장소 ---
    // Key: 고유 이름(예: A_01_Mask_C05), Value: 해당 게임 오브젝트
    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    
    // --- 마지막으로 활성화된 오브젝트 상태를 기억하기 위한 변수들 ---
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Renderer lastLitLamp;
    private Vector3 lastMaskOriginalLocalPosition;

    // 게임이 시작될 때 한 번만 호출되는 함수
    void Start()
    {
        InitializeAllRacks(); // 랙 초기화 함수 실행
    }

    // 씬에 배치된 모든 램프와 마스크를 찾아 데이터 저장소(Dictionary)에 등록하는 함수
    void InitializeAllRacks()
    {
        Debug.Log("랙 시스템 초기화를 시작합니다...");
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        // 디버깅용: 유효한 모든 바코드 키 목록을 담을 문자열 빌더
        StringBuilder validBarcodes = new StringBuilder("--- 복사해서 사용 가능한 전체 유효 바코드 목록 ---\n");

        // rackContainer의 모든 자식 랙(A_01, B_01 등)을 순회
        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name; // 랙의 이름 (예: "A_01")
            // 해당 랙 하위의 모든 렌더러(보이는 모든 부품)를 가져옴
            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name; // 부품의 로컬 이름 (예: "Lamp_C05")
                // 글로벌 고유 키(주소) 생성 (예: "A_01_Lamp_C05")
                string globalKey = $"{rackName}_{localName}";

                // 이름에 따라 램프와 마스크를 구분하여 각각의 저장소에 등록
                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                    {
                        lampRenderers.Add(globalKey, rend);
                        if (defaultLampMaterial != null) rend.material = defaultLampMaterial;
                    }
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                    {
                        maskObjects.Add(globalKey, rend.gameObject);
                        
                        // 바코드 형식으로 변환하여 디버그 목록에 추가
                        string floor = localName.Substring(5, 1);
                        string slotNum = localName.Substring(6, 2);
                        validBarcodes.AppendLine($"MMF10{rackName.Replace("_", "")}{floor}{slotNum}");
                    }
                }
            }
        }
        
        // 요청했던 전체 유효 바코드 목록을 콘솔에 한 번에 출력
        Debug.Log(validBarcodes.ToString());
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    // 바코드 입력을 받아 처리하는 메인 함수
    public void ProcessBarcode(string barcode)
    {
        Debug.Log($"입력된 바코드 처리 시작: {barcode}");
        ResetPreviousSlot(); // 이전에 켜졌던 램프나 나온 마스크를 원상복구

        // 바코드 유효성 검사 (길이가 11이 아니거나 MMF10으로 시작하지 않으면 무시)
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10"))
        {
            Debug.LogError($"잘못된 바코드 형식입니다: {barcode}. (콘솔에 출력된 목록을 복사하세요)");
            return;
        }

        // 바코드 해석 (예: MMF10B08C05)
        string row = barcode.Substring(5, 1);     // "B"
        string rackNum = barcode.Substring(6, 2); // "08"
        string floor = barcode.Substring(8, 1);   // "C"
        string slotNum = barcode.Substring(9, 2); // "05"

        // 해석된 정보로 딕셔너리에서 검색할 키(주소)를 조합
        string rackID = $"{row}_{rackNum}"; // "B_08"
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}"; // "B_08_Lamp_C05"
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}"; // "B_08_Mask_C05"
        
        // 램프 저장소에서 해당 키로 램프를 찾고, 찾으면 불을 켬
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }
        else { Debug.LogWarning($"경고: {lampKey} 이름의 램프를 찾지 못했습니다."); }

        // 마스크 저장소에서 해당 키로 마스크를 찾고, 찾으면 애니메이션 실행
        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
        else { Debug.LogWarning($"경고: {maskKey} 이름의 마스크를 찾지 못했습니다."); }
    }

    // 이전에 활성화된 슬롯을 원래 상태로 되돌리는 함수
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false)); // 다시 들어가는 애니메이션 실행
            lastMovedMask = null;
        }
    }

    // 마스크를 부드럽게 움직이는 애니메이션 코루틴
    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true; // 애니메이션 동안 물리 효과를 잠시 끔

        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        // 랙이 세워지면서 축이 변경되었으므로, 로컬 Y축(up)이 앞뒤 방향이 됨
        Vector3 slideDirection = Vector3.up; 

        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }

        float timeElapsed = 0;
        // 설정된 시간(animationDuration) 동안 부드럽게 위치를 변경
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null; // 다음 프레임까지 대기
        }
        mask.transform.localPosition = endPosition; // 정확한 위치로 보정

        if (rb != null) rb.isKinematic = false; // 애니메이션이 끝나면 물리 효과를 다시 켬
    }
    
    // UI의 InputField의 OnEndEdit 이벤트와 연결되어, 엔터 입력 시 호출될 함수
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper()); // 입력된 텍스트로 바코드 처리 함수 실행
        }
    }
}