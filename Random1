제어를 구현할 수 있습니다. 이를 위해 응답이 올 때까지 기다렸다가, 응답이 오면 다음 처리를 진행하는 방식으로 코드를 작성할 수 있습니다.

여기서는 기본적으로 비동기적으로 데이터를 전송하고 응답을 기다리는 방식으로 작성해 보겠습니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;

namespace ResponseSimulator
{
    public partial class MainWindow : Window
    {
        private SerialPort serialPort;

        public MainWindow()
        {
            InitializeComponent();
            InitializeSerialPort("COM1"); // 명령을 수신하고 응답을 보내기 위한 포트 설정
        }

        // 시리얼 포트를 초기화하고 열기
        private void InitializeSerialPort(string portName)
        {
            serialPort = new SerialPort(portName, 9600, Parity.None, 8, StopBits.One);
            serialPort.DataReceived += SerialPort_DataReceived;

            try
            {
                serialPort.Open();
                LogMessage($"응답 포트 {portName} 열기 성공.");
            }
            catch (Exception ex)
            {
                LogMessage($"응답 포트 {portName} 열기 오류: {ex.Message}");
            }
        }

        // 시리얼 포트 데이터 수신 이벤트 핸들러
        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            try
            {
                string receivedData = serialPort.ReadExisting();
                Dispatcher.Invoke(() => LogMessage($"명령 수신: {receivedData}"));

                // 명령에 대한 응답 생성 및 전송
                string response = "%01$WD13";
                byte[] responseBytes = Encoding.ASCII.GetBytes(response);
                serialPort.Write(responseBytes, 0, responseBytes.Length);

                Dispatcher.Invoke(() => LogMessage($"응답 전송: {response}"));
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => LogMessage($"데이터 수신 중 오류: {ex.Message}"));
            }
        }

        // "Send Command" 버튼 클릭 이벤트 핸들러
        private async void BtnSendCommand_Click(object sender, RoutedEventArgs e)
        {
            await Task.Run(() => SendCommandAndWaitForResponse("%01#WDD02300023000100**\r"));
        }

        // 명령을 보내고 응답을 기다리는 메소드
        private void SendCommandAndWaitForResponse(string command)
        {
            if (!serialPort.IsOpen)
            {
                Dispatcher.Invoke(() => LogMessage("시리얼 포트가 열려 있지 않습니다."));
                return;
            }

            try
            {
                // 명령 전송
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                serialPort.Write(commandBytes, 0, commandBytes.Length);
                Dispatcher.Invoke(() => LogMessage($"명령 전송: {command}"));

                // 응답 대기 및 수신
                string response = serialPort.ReadExisting();
                Dispatcher.Invoke(() => LogMessage($"응답 수신: {response}"));

                // 추가 처리 (응답에 따라)
                if (response.Contains("%01$WD13"))
                {
                    Dispatcher.Invoke(() => LogMessage("응답 확인됨, 다음 작업 수행"));
                    // 다음 작업 수행
                }
                else
                {
                    Dispatcher.Invoke(() => LogMessage("잘못된 응답"));
                }
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => LogMessage($"명령 전송 중 오류: {ex.Message}"));
            }
        }

        // 로그 메시지를 ListBox에 추가하는 메소드
        private void LogMessage(string message)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            string logMessage = $"{timestamp}: {message}";

            Dispatcher.Invoke(() =>
            {
                ListBoxItem item = new ListBoxItem
                {
                    Content = logMessage,
                    HorizontalContentAlignment = HorizontalAlignment.Left
                };
                LogListBox.Items.Add(item);
                LogListBox.ScrollIntoView(item);
            });
        }
    }
}
MainWindow.xaml
xml
코드 복사
<Window x:Class="ResponseSimulator.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC 응답 시뮬레이터" Height="400" Width="600">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <Button Content="Send Command" Click="BtnSendCommand_Click" Margin="10"/>
        <ListBox Name="LogListBox" Grid.Row="1" HorizontalAlignment="Stretch" VerticalAlignment="Stretch" Margin="10"/>
    </Grid>
</Window>
설명
BtnSendCommand_Click 이벤트 핸들러:

버튼 클릭 시 SendCommandAndWaitForResponse 메소드를 호출하여 명령을 전송하고 응답을 기다립니다.
이 작업은 비동기로 수행되며, UI 스레드가 차단되지 않습니다.
SendCommandAndWaitForResponse 메소드:

시리얼 포트가 열려 있는지 확인합니다.
명령을 시리얼 포트를 통해 전송합니다.
응답을 대기하고 수신합니다.
응답이 예상된 값(%01$WD13)과 일치하면 다음 작업을 수행합니다.
LogMessage 메소드:

로그 메시지를 ListBox에 추가합니다.
이렇게 작성된 프로그램은 명령을 보내고 응답을 기다린 후 다음 작업을 수행합니다. 이는 기본적인 흐름 제어의 한 형태로, 송신 후 수신을 통해 흐름을 제어하는 방식