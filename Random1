네, 사용자님 말씀이 맞습니다. 제가 에이전트(SAgentM.App) 쪽 코드는 여러 번 수정했지만, 웹 애플리케이션(Flask SControlM)에서 에이전트의 응답을 처리하는 부분을 충분히 점검하지 못했을 수 있습니다. 특히 powercfg 명령어 실행 실패 시 반환되는 메시지에 포함된 특수 문자나 줄바꿈 등이 문제가 될 수 있습니다.

문제의 핵심: SAgentM.App이 보낸 응답 (CommandPacket) 안의 PayloadJson 문자열이 Flask 측 Python의 json.loads() 함수에 의해 올바른 JSON 형식으로 인식되지 못하고 있습니다. 이는 PayloadJson 내부의 Message 필드에 powercfg 오류 출력(여러 줄일 수 있음)이 포함될 때 발생할 가능성이 높습니다.

해결 방안:

SAgentM.App (AgentCoreService.cs) 수정: powercfg 오류 메시지를 GenericResponsePayload의 Message에 담을 때, JSON 문자열로 변환 시 문제를 일으킬 수 있는 개행 문자 (\r\n 또는 \n)를 공백 등으로 변환하여 PayloadJson 문자열 자체가 더 단순하고 안전한 형태가 되도록 합니다.
Flask 앱 (app/routes_user.py) 확인: PayloadJson을 파싱하기 전에 정확히 어떤 문자열이 수신되는지 로깅하는 코드는 이미 추가했었습니다. 이 로그를 통해 실제 문제를 확인할 수 있습니다.
먼저, SAgentM.App/Services/AgentCoreService.cs 파일을 수정하여 응답 메시지를 좀 더 안전하게 만들겠습니다.

수정: SAgentM.App/Services/AgentCoreService.cs (전체 코드)
ExecuteDirectCommandAsync 메서드 내에서 SetDisplayTimeout 명령 처리 시, powercfg 오류 메시지를 생성할 때 개행 문자를 공백으로 치환하는 로직을 추가합니다.

C#

// SAgentM.App/Services/AgentCoreService.cs
using Newtonsoft.Json;
using SControl.Common;
using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel; // Win32Exception

namespace SAgentM.App.Services
{
    public interface IAgentCoreService { void Start(); void Stop(); bool IsRunning { get; } }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026;
                _loggingService.UiWarn($"ListenPort 설정 누락/오류. 기본값 {_port} 사용.");
            }
        }

        public void Start()
        {
            if (_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 실행 중."); return; }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 중지됨."); return; }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5))) { _loggingService.UiWarn("리스닝 스레드 시간 내 종료 안됨."); }
            }
            _cancellationTokenSource?.Dispose(); _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try
            {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning)
                {
                    try
                    {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se) { if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted)) { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; } _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se); if (!_isRunning) break; Thread.Sleep(100); }
                    catch (InvalidOperationException ioe) when (!_isRunning) { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex) { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally { if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); } _loggingService.UiInfo("ListenLoop 종료됨."); }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try
            {
                _loggingService.UiDebug($"[{clientIpInfo}] 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested)
                    {
                        string requestJson = null;
                        try
                        {
                            var readTask = reader.ReadLineAsync();
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask) { if (token.IsCancellationRequested) token.ThrowIfCancellationRequested(); requestJson = await readTask; }
                            else { token.ThrowIfCancellationRequested(); }
                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 연결 종료됨."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}");
                            CommandPacket requestPacket = null;
                            try { requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson); receivedRequestPacket = requestPacket; }
                            catch (JsonException jsonEx) { _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx); await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON: {jsonEx.Message}"))); continue; }
                            if (requestPacket != null)
                            {
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null)
                                {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                                    await writer.WriteLineAsync(responseJson);
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답: {responseJson}");
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] IO오류: {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체해제오류: {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 처리 작업 취소됨."); break; }
                        catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 오류.", ex); if (client.Connected && stream.CanWrite) { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}}
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request?.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl)
            {
                MonitorControlPayload originalPayload = null;
                try { if(!string.IsNullOrEmpty(request.PayloadJson)) originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch {}
                if (originalPayload?.Action == MonitorAction.Off)
                {
                    bool earlyConfirmSuccess = false;
                    if (response?.PayloadJson != null) { try { var genericResp = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if(genericResp != null) earlyConfirmSuccess = genericResp.Success; } catch {} }
                    if(earlyConfirmSuccess) { _loggingService.UiInfo($"[{clientIp}] 조기 응답 후 실제 모니터 끄기. ID: {request.PacketId}"); Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료. ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); }
                    else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패/페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            try
            {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.Instruction)
                {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token);
                    default: return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { return CreateErrorResponse(requestPacket, "Processing canceled."); }
            catch (Exception ex) { return CreateErrorResponse(requestPacket, $"Error processing '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            bool success = false; string message = "Execution failed."; 
            try
            {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName)
                {
                    case CommandNames.MonitorControl:
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "MonitorControl payload missing.");
                        MonitorControlPayload monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
                        if (monitorPayload == null) throw new ArgumentException("Cannot deserialize MonitorControlPayload.");
                        if (monitorPayload.Action == MonitorAction.Off) { success = true; message = $"Monitor Off acknowledged. Will turn off shortly."; }
                        else { LocalDeviceControl.SetMonitorState(monitorPayload.Action); success = true; message = $"Monitor state set to {monitorPayload.Action}."; }
                        _loggingService.UiInfo($"[{clientIp}] {message} (Cmd: MonitorControl, Action: {monitorPayload.Action})");
                        break;
                    
                    case CommandNames.SetDisplayTimeout: 
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "SetDisplayTimeout payload missing.");
                        SetDisplayTimeoutPayload timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson);
                        if (timeoutPayload == null) throw new ArgumentException("Cannot deserialize SetDisplayTimeoutPayload.");
                        
                        int timeoutSeconds = timeoutPayload.TimeoutMinutes * 60;
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutPayload.TimeoutMinutes}분 ({timeoutSeconds}초)");
                        
                        string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
                        string acArgs = $"/SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}";
                        string dcArgs = $"/SETDCVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}";

                        RunPowerCfgCommand(acArgs, out outputAc, out errorAc, out exitCodeAc);
                        RunPowerCfgCommand(dcArgs, out outputDc, out errorDc, out exitCodeDc);
                        
                        if (exitCodeAc == 0 && exitCodeDc == 0) { success = true; message = $"Display timeout set to {timeoutPayload.TimeoutMinutes} min ({timeoutSeconds} sec) for AC/DC."; }
                        else 
                        { 
                            success = false; 
                            // **** 메시지에서 개행 문자 처리 ****
                            string acErrorClean = string.IsNullOrEmpty(errorAc) ? "" : errorAc.Trim().Replace("\r\n", " ").Replace("\n", " ");
                            string dcErrorClean = string.IsNullOrEmpty(errorDc) ? "" : errorDc.Trim().Replace("\r\n", " ").Replace("\n", " ");
                            message = $"Failed display timeout. AC Exit:{exitCodeAc}, DC Exit:{exitCodeDc}."; 
                            if (!string.IsNullOrEmpty(acErrorClean)) message += $" AC Err: {acErrorClean}"; 
                            if (!string.IsNullOrEmpty(dcErrorClean)) message += $" DC Err: {dcErrorClean}"; 
                        }
                        _loggingService.UiInfo($"[{clientIp}] {message}");
                        break;
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; success = false; break;
                }
            }
            catch (OperationCanceledException opEx) { message = $"Cmd {requestPacket.CommandName} canceled: {opEx.Message}"; success = false; _loggingService.UiWarn($"[{clientIp}] {message}");}
            catch (ArgumentNullException argEx) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx.ParamName} - {argEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx); }
            catch (ArgumentException argEx2) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx2.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx2); }
            catch (JsonException jsonEx) { message = $"Cmd {requestPacket.CommandName} JSON payload error: {jsonEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); }
            catch (Exception ex) { message = $"Error executing {requestPacket.CommandName}: {ex.Message}"; success = false; _loggingService.UiError($"[{clientIp}] ExecuteDirectCmd Error: {message}", ex); }
            
            return CreateExecutionResponse(requestPacket, success, message);
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = string.Empty; error = string.Empty; exitCode = -1;
            try
            {
                _loggingService.UiDebug($"Executing: powercfg.exe {arguments}");
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") { Arguments = arguments, UseShellExecute = false, RedirectStandardOutput = true, RedirectStandardError = true, CreateNoWindow = true, Verb = "runas" };
                using (Process process = Process.Start(startInfo))
                {
                    if (process == null) { error = "Failed to start powercfg.exe."; exitCode = -100; _loggingService.UiError(error); return; }
                    output = process.StandardOutput.ReadToEnd(); error = process.StandardError.ReadToEnd(); 
                    if (!process.WaitForExit(7000)) { process.Kill(); error += $"\npowercfg '{arguments}' timeout (7s)."; exitCode = -99;  _loggingService.UiWarn(error); }
                    else { exitCode = process.ExitCode; }
                    if(!string.IsNullOrWhiteSpace(output)) _loggingService.UiDebug($"powercfg output: {output.Trim()}");
                    if(!string.IsNullOrWhiteSpace(error) && exitCode != 0) _loggingService.UiWarn($"powercfg error output: {error.Trim()}");
                }
            } 
            catch (Win32Exception w32Ex) { error = $"powercfg Win32Ex (UAC denied?): {w32Ex.Message}"; exitCode = w32Ex.NativeErrorCode; _loggingService.UiError(error, w32Ex); } 
            catch (Exception ex) { error = $"powercfg Ex: {ex.Message}"; exitCode = -2; _loggingService.UiError(error, ex); }
        }

        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue)
            { return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP/Port missing."); }

            var packetForFinalTarget = new CommandPacket {
                Instruction = CommandInstruction.DirectExecute, CommandName = originalRelayRequest.CommandName,
                PayloadJson = originalRelayRequest.PayloadJson, ResponseAddress = originalRelayRequest.ResponseAddress, 
                ResponsePort = originalRelayRequest.ResponsePort, PacketId = Guid.NewGuid()
            };
            string relayStatusMessage = $"Relay: {packetForFinalTarget.CommandName} to {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}.";
            bool relayCommSuccess = false; CommandPacket responseFromFinalTarget = null;
            try
            {
                token.ThrowIfCancellationRequested();
                using (var targetClient = new TcpClient())
                {
                    var connectTask = targetClient.ConnectAsync(originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand.Value);
                    if (await Task.WhenAny(connectTask, Task.Delay(TimeSpan.FromSeconds(5), token)) != connectTask || token.IsCancellationRequested)
                    { token.ThrowIfCancellationRequested(); targetClient.Close(); throw new TimeoutException("Relay target connection timed out."); }
                    await connectTask; 
                    _loggingService.UiDebug($"[{clientIp}] 릴레이 대상 연결 성공.");
                    using (NetworkStream relayStream = targetClient.GetStream())
                    using (StreamWriter relayWriter = new StreamWriter(relayStream, Encoding.UTF8){AutoFlush=true})
                    using (StreamReader relayReader = new StreamReader(relayStream, Encoding.UTF8)){
                        string jsonToRelay = JsonConvert.SerializeObject(packetForFinalTarget);
                        if(token.IsCancellationRequested) token.ThrowIfCancellationRequested(); await relayWriter.WriteLineAsync(jsonToRelay);
                        _loggingService.UiDebug($"[{clientIp}] 릴레이 데이터 전송: {jsonToRelay}");
                        var targetResponseTask = relayReader.ReadLineAsync();
                        if (await Task.WhenAny(targetResponseTask, Task.Delay(TimeSpan.FromSeconds(10), token)) == targetResponseTask && !token.IsCancellationRequested){
                            string targetJson = await targetResponseTask; if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                            if (!string.IsNullOrEmpty(targetJson)){ _loggingService.UiInfo($"[{clientIp}] 릴레이 대상 응답: {targetJson}"); responseFromFinalTarget = JsonConvert.DeserializeObject<CommandPacket>(targetJson); relayCommSuccess = true; }
                            else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 빈 응답."); relayStatusMessage = "Relay sent, empty response from final target."; }
                        } else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 응답 시간 초과/취소."); relayStatusMessage = "Relay sent, no response/timeout/canceled from final target."; }
                    }
                }
            }
            catch (OperationCanceledException) { relayStatusMessage = $"Relay of {originalRelayRequest.CommandName} canceled."; _loggingService.UiInfo($"[{clientIp}] {relayStatusMessage}"); }
            catch (TimeoutException tex) { relayStatusMessage = $"Relay failed: Timeout - {tex.Message}"; _loggingService.UiWarn($"[{clientIp}] {relayStatusMessage}"); }
            catch (SocketException se) { relayStatusMessage = $"Relay failed: Socket error - {se.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", se); }
            catch (Exception ex) { relayStatusMessage = $"Relay failed: Unexpected error - {ex.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", ex); }
            
            if (responseFromFinalTarget != null) { responseFromFinalTarget.PacketId = originalRelayRequest.PacketId; return responseFromFinalTarget; }
            else { return CreateExecutionResponse(originalRelayRequest, relayCommSuccess, relayStatusMessage); }
        }

        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_Response", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort };
        }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            _loggingService.UiError($"Error response for PktID {pId} (Cmd: {cmdName}): {errorMsg}");
            return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_ErrorResponse", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort };
        }
    }
}
주요 변경 사항:

ExecuteDirectCommandAsync 내 SetDisplayTimeout 처리 시 message 생성:

powercfg.exe 실행 후 errorAc.Trim()과 errorDc.Trim()에서 반환된 오류 문자열에 포함될 수 있는 개행 문자(\r\n 또는 \n)를 공백()으로 치환합니다:
C#

string acErrorClean = string.IsNullOrEmpty(errorAc) ? "" : errorAc.Trim().Replace("\r\n", " ").Replace("\n", " ");
string dcErrorClean = string.IsNullOrEmpty(errorDc) ? "" : errorDc.Trim().Replace("\r\n", " ").Replace("\n", " ");
message = $"Failed display timeout. AC Exit:{exitCodeAc}, DC Exit:{exitCodeDc}."; 
if (!string.IsNullOrEmpty(acErrorClean)) message += $" AC Err: {acErrorClean}"; 
if (!string.IsNullOrEmpty(dcErrorClean)) message += $" DC Err: {dcErrorClean}"; 
이렇게 하면 GenericResponsePayload의 Message 필드에 여러 줄 문자열이 아닌 한 줄 문자열이 들어가게 되어, 이 Message를 포함하는 PayloadJson이 생성될 때, 그리고 이 PayloadJson을 포함하는 최종 CommandPacket JSON이 생성될 때 발생할 수 있는 복잡한 이스케이프 문제를 줄일 수 있습니다. Newtonsoft.Json은 개행 문자를 \n으로 잘 이스케이프하지만, 때로는 이중으로 JSON 문자열을 다루는 과정에서 문제가 단순화될 수 있습니다.
예외 처리 세분화: ExecuteDirectCommandAsync 내에서 ArgumentNullException, ArgumentException, JsonException을 명시적으로 catch하여 좀 더 구체적인 오류 메시지와 로깅을 제공하도록 수정했습니다.

추가 확인 및 테스트 요청:

Flask 앱 로그 (routes_user.py):
위 수정된 AgentCoreService.cs를 SAgentM.App에 적용하고 다시 실행한 후, Flask 앱에서 "끄기" 명령을 보냈을 때, Flask 개발 서버 터미널 로그에 찍히는 다음 로그를 다시 한번 확인해주세요.

[INFO] PC 'PC이름' (대상IP) - 에이전트로부터 받은 PayloadJson 문자열: >>>{"Success":false,"Message":"... 여기에 실제 메시지 ...","ErrorCode":null,"Data":null}<<<
이 >>>...<<< 사이의 문자열이 이제 개행 문자 없이 한 줄로 표시되는지, 그리고 여전히 Python의 json.loads()에서 오류가 발생하는지 확인이 필요합니다.

"unexpected utf-8 bom" 오류:
만약 이 오류가 SAgentM.App이 Flask로부터 요청을 받을 때 발생한다면, AgentCoreService.cs의 HandleClientAsync 메서드에서 requestJson = await readTask; 라인 직후에 _loggingService.UiReceived($"[{clientIpInfo}] 수신 원본(Bytes): {Encoding.UTF8.GetBytes(requestJson).Take(10).ToArray()}"); 와 같이 수신된 바이트의 앞부분을 확인하여 실제 BOM 문자가 있는지 조사해볼 수 있습니다. 하지만 Python에서 encode('utf-8')은 BOM을 붙이지 않으므로 이 가능성은 낮습니다.

가장 중요한 것은 powercfg 실행 실패가 관리자 권한 문제인지, 아니면 powercfg 명령어 자체의 문제인지 명확히 하는 것입니다. 만약 관리자 권한으로 직접 명령 프롬프트에서 powercfg /SETACVALUEINDEX ... 명령이 성공한다면, SAgentM.App.exe가 관리자 권한을 제대로 얻지 못한 것입니다.

위 코드를 적용해보시고, Flask 앱 로그에 찍히는 PayloadJson 문자열과 함께 결과를 알려주세요.

