네, 알겠습니다. 제가 이전 답변들에서 여러 파일에 걸쳐 수정 사항을 안내해 드리다 보니 혼란스러우셨을 것 같습니다. "글마다 비밀번호 적용" 기능을 구현하기 위해 최종적으로 수정해야 하는 파일들의 전체 코드를 다시 한번 명확하게 정리해서 드리겠습니다.

수정이 필요한 주요 파일:

models.py: Post 모델에 비밀번호 관련 필드 및 메서드 추가.
app.py: 비밀번호 설정/확인 로직 및 관련 라우트 수정.
templates/edit_post.html: 글 작성/수정 시 비밀번호 설정 UI 추가.
templates/view_post.html: 비밀번호가 설정된 글 보기 처리.
templates/index.html (선택적 수정): 목록에 비밀글 표시.
중요: 아래 코드를 적용하시기 전에, 기존 board.db 파일을 삭제하고 애플리케이션을 재시작하여 데이터베이스 스키마를 새로 생성해야 합니다. (이전에 이 작업을 하셨다면 반복할 필요는 없지만, 확실하게 하기 위해 권장합니다.)

1. flask_board/models.py (전체 코드)

Python

from flask_sqlalchemy import SQLAlchemy
from datetime import datetime, timezone
import re
from werkzeug.security import generate_password_hash, check_password_hash # 비밀번호 해싱을 위해 추가

db = SQLAlchemy()

def slugify(text_to_slugify):
    """
    문자열로부터 URL 친화적인 슬러그를 생성합니다.
    """
    if not text_to_slugify:
        return "default-slug" # 기본값
        
    text_processed = str(text_to_slugify)
    # 한글 등을 고려하여 유니코드 단어 문자(\w)를 사용하고, re.UNICODE 플래그는 Python 3에서 기본 동작
    text_processed = re.sub(r'[^\w\s-]', '', text_processed).strip().lower()
    text_processed = re.sub(r'[-\s]+', '-', text_processed)
    
    if not text_processed: # 모든 문자가 제거된 경우
        return "default-slug" 
    return text_processed

class Category(db.Model):
    __tablename__ = 'category'
    id = db.Column(db.Integer, primary_key=True)
    name = db.Column(db.String(100), nullable=False, unique=True)
    slug = db.Column(db.String(120), nullable=False, unique=True)
    posts_in_category = db.relationship('Post', back_populates='category', lazy='dynamic', foreign_keys='Post.category_id')

    def __init__(self, name):
        self.name = name
        self.slug = self._generate_unique_slug(name)

    def _generate_unique_slug(self, name_to_slug):
        base_slug = slugify(name_to_slug)
        current_slug_candidate = base_slug
        counter = 1
        while Category.query.filter_by(slug=current_slug_candidate).first():
            current_slug_candidate = f"{base_slug}-{counter}"
            counter += 1
        return current_slug_candidate

    def __repr__(self):
        return f'<Category {self.name}>'

class Post(db.Model):
    __tablename__ = 'post'
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    slug = db.Column(db.String(200), unique=True, nullable=False)
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, index=True, default=lambda: datetime.now(timezone.utc))
    category_id = db.Column(db.Integer, db.ForeignKey('category.id'), nullable=True)
    category = db.relationship('Category', back_populates='posts_in_category', foreign_keys=[category_id])

    # --- 게시글 비밀번호 기능 추가 ---
    password_hash = db.Column(db.String(256), nullable=True) 
    is_password_protected = db.Column(db.Boolean, default=False, nullable=False)
    # --- 게시글 비밀번호 기능 추가 끝 ---

    def __init__(self, title, content, category_id=None, slug_text=None): # password 관련 인자 제거, set_password로 처리
        self.title = title
        self.content = content
        self.category_id = category_id
        
        # is_password_protected와 password_hash는 set_password 또는 명시적 해제를 통해 관리
        self.is_password_protected = False # 기본값
        self.password_hash = None      # 기본값

        if slug_text:
            self.slug = slug_text
        else:
            self.slug = self._generate_unique_slug(self.title)

    def _generate_unique_slug(self, title_to_slug):
        base_slug = slugify(title_to_slug)
        current_slug_candidate = base_slug
        counter = 1
        while Post.query.filter_by(slug=current_slug_candidate).first():
            current_slug_candidate = f"{base_slug}-{counter}"
            counter += 1
        return current_slug_candidate

    # --- 게시글 비밀번호 메서드 ---
    def set_password(self, password):
        if password: # 비밀번호가 제공된 경우 (빈 문자열이 아님)
            self.password_hash = generate_password_hash(password)
            self.is_password_protected = True
        else: # 비밀번호가 제공되지 않거나 빈 문자열인 경우 (보호 해제)
            self.password_hash = None
            self.is_password_protected = False

    def check_password(self, password):
        if not self.password_hash or not self.is_password_protected: # 해시가 없거나 보호 플래그가 꺼져있으면 False
            return False
        return check_password_hash(self.password_hash, password)
    # --- 게시글 비밀번호 메서드 끝 ---

    def __repr__(self):
        return f'<Post {self.title}>'
2. flask_board/app.py (전체 코드 - 비밀번호 로직 중점 수정)

Python

import os
import uuid
import re
from functools import wraps
from datetime import datetime, timezone, timedelta

from flask import (
    Flask, render_template, request, redirect, url_for, flash, session, jsonify, abort
)
from werkzeug.utils import secure_filename

# --- 사용자 정의 모듈 임포트 ---
try:
    from config import Config
except ImportError:
    print("CRITICAL: config.py not found. Using emergency defaults.")
    class Config: # 임시 Config
        SECRET_KEY = os.environ.get('SECRET_KEY') or 'emergency_secret_key_please_set_properly'
        SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///board.db'
        SQLALCHEMY_TRACK_MODIFICATIONS = False
        ADMIN_PASSWORD = os.environ.get('ADMIN_PASSWORD') or 'kkkwww'
        UPLOAD_FOLDER = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'static/uploads')
        ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
        MAX_CONTENT_LENGTH = 50 * 1024 * 1024 # 예시: 50MB (테스트 후 실제 원하는 값으로!)

try:
    from models import db, Post, Category
except ImportError:
    print("CRITICAL: models.py not found or models cannot be imported.")
    db = None; Post = None; Category = None

app = Flask(__name__)
app.config.from_object(Config)

if db: 
    db.init_app(app)
else:
    print("CRITICAL: Database (db) object not initialized from models.py.")


upload_folder_path = app.config.get('UPLOAD_FOLDER', './static/uploads_fallback')
if not os.path.exists(upload_folder_path):
    try: os.makedirs(upload_folder_path)
    except OSError as e: app.logger.error(f"Error creating upload folder {upload_folder_path}: {e}")

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config.get('ALLOWED_EXTENSIONS', {'png', 'jpg', 'jpeg', 'gif'})

# --- 인증 및 전역 변수 ---
def is_admin_logged_in(): return session.get('is_admin_logged_in', False)

@app.context_processor
def inject_global_vars():
    all_cats = []
    if Category:
        try: all_cats = Category.query.order_by(Category.name).all()
        except Exception as e: app.logger.error(f"Error fetching categories for context: {e}")
    return dict(is_admin=is_admin_logged_in(), now=datetime.now(timezone.utc), all_categories=all_cats)

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin_logged_in():
            flash('로그인이 필요합니다.', 'warning'); return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    if is_admin_logged_in(): return redirect(url_for('index'))
    if request.method == 'POST':
        password = request.form.get('password')
        if password == app.config['ADMIN_PASSWORD']:
            session['is_admin_logged_in'] = True; session.permanent = True
            app.permanent_session_lifetime = timedelta(days=7)
            flash('로그인되었습니다.', 'success'); return redirect(request.args.get('next') or url_for('index'))
        else: flash('잘못된 비밀번호입니다.', 'danger')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('is_admin_logged_in', None); flash('로그아웃되었습니다.', 'info'); return redirect(url_for('index'))

# --- 게시판 라우트 ---
@app.route('/')
def index():
    if not Post: flash("게시글 기능을 사용할 수 없습니다.", "danger"); return render_template('index.html', posts_pagination=None, current_category=None)
    page = request.args.get('page', 1, type=int)
    posts_pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=None)

@app.route('/post/<string:slug>', methods=['GET', 'POST'])
def view_post(slug):
    if not Post: abort(500, description="Post model not available.")
    post_instance = Post.query.filter_by(slug=slug).first_or_404()
    session_key_for_post_unlock = f'unlocked_post_{post_instance.id}'
    is_unlocked_in_session = session.get(session_key_for_post_unlock, False)

    if post_instance.is_password_protected and post_instance.password_hash: # 보호 플래그와 해시 둘 다 확인
        if is_unlocked_in_session:
            return render_template('view_post.html', post=post_instance, show_password_form=False)
        else:
            if request.method == 'POST':
                submitted_password = request.form.get('post_password_view')
                if post_instance.check_password(submitted_password): # check_password는 해시 존재 시에만 유효
                    session[session_key_for_post_unlock] = True
                    flash('비밀번호가 확인되었습니다.', 'success')
                    return redirect(url_for('view_post', slug=post_instance.slug))
                else:
                    flash('비밀번호가 올바르지 않습니다.', 'danger')
            return render_template('view_post.html', post=post_instance, show_password_form=True)
    else: # 보호되지 않았거나, 보호 플래그는 True인데 해시가 없는 비정상 상태 포함
        if post_instance.is_password_protected and not post_instance.password_hash:
             app.logger.warning(f"Post ID {post_instance.id} is marked protected but has no password hash.")
        return render_template('view_post.html', post=post_instance, show_password_form=False)


@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    cats = []; 
    if Category: 
        try: cats = Category.query.order_by(Category.name).all()
        except Exception as e: app.logger.error(f"Error fetching categories: {e}")

    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        
        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input')

        if not title or not content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None

        try:
            if not Post: raise Exception("Post model not available.")
            new_post_obj = Post(title=title, content=content, category_id=processed_category_id)
            
            if is_protected_from_form:
                if password_from_form: # 보호 체크 & 비밀번호 입력됨
                    new_post_obj.set_password(password_from_form) # is_password_protected도 True로 설정됨
                else: # 새 글인데 보호 체크하고 비밀번호 입력 안 한 경우
                    flash('비밀번호로 보호를 선택했지만, 비밀번호를 입력하지 않았습니다. 보호되지 않은 글로 저장됩니다.', 'warning')
                    new_post_obj.is_password_protected = False 
                    new_post_obj.password_hash = None
            else: # 보호 체크 안 함
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None
            
            db.session.add(new_post_obj)
            db.session.commit()
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        except Exception as e:
            db.session.rollback(); app.logger.error(f"Error creating post: {e}")
            flash(f'게시글 작성 중 오류: {str(e)}', 'danger')
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None)


@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    if not Post or not Category: abort(500)
    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()
    cats = []
    try: cats = Category.query.order_by(Category.name).all()
    except Exception as e: app.logger.error(f"Error fetching categories: {e}")
    
    selected_category_id = str(post_to_edit.category_id) if post_to_edit.category_id is not None else ""
    
    if request.method == 'POST':
        original_title = post_to_edit.title
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        selected_category_id = category_id_str

        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input')

        if not post_to_edit.title or not post_to_edit.content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        post_to_edit.category_id = processed_category_id

        if is_protected_from_form:
            # "보호" 체크 시
            if password_from_form: # 새 비밀번호가 입력된 경우 -> 비밀번호 변경/설정
                post_to_edit.set_password(password_from_form)
            elif post_to_edit.password_hash: # 새 비밀번호 입력 없고, 기존 비밀번호가 있는 경우 -> 기존 비밀번호 유지, 보호 상태 유지
                post_to_edit.is_password_protected = True # 명시적으로 보호 상태 유지
            else: # 새 비밀번호 입력 없고, 기존 비밀번호도 없는 경우 -> 보호할 비밀번호가 없으므로 보호 해제
                flash('비밀번호 보호를 선택했지만, 설정할 비밀번호가 없습니다. 보호되지 않습니다.', 'warning')
                post_to_edit.is_password_protected = False
                post_to_edit.password_hash = None
        else: # "보호" 체크 해제 시 -> 비밀번호 보호 해제
            post_to_edit.set_password(None) # password_hash = None, is_password_protected = False 로 설정됨

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title)
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit()
            flash('게시글이 성공적으로 수정되었습니다.', 'success')
            return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback(); app.logger.error(f"Error editing post {slug}: {e}")
            flash(f'게시글 수정 중 오류: {str(e)}', 'danger')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

    return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

# --- 나머지 라우트 (delete_post, upload_image, 카테고리 관리, 디버그, 실행 부분) ---
# 이 부분은 이전 답변의 최종 app.py 코드와 동일하게 유지합니다.
# 공간 절약을 위해 여기에 모든 코드를 다시 반복하지 않겠습니다.
# 이전에 제공해드린 app.py 전체 코드에서 위 new_post, edit_post, view_post 부분만
# 지금 드린 내용으로 교체하시면 됩니다.

@app.route('/delete/<string:slug>', methods=['POST'])
@admin_required
def delete_post(slug):
    if not Post: abort(500)
    post_to_delete = Post.query.filter_by(slug=slug).first_or_404()
    try:
        db.session.delete(post_to_delete); db.session.commit()
        flash('게시글이 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback(); app.logger.error(f"Error deleting post {slug}: {e}"); flash(f'삭제 오류: {str(e)}', 'danger')
    return redirect(url_for('index'))

@app.route('/upload_image', methods=['POST'])
@admin_required
def upload_image():
    if 'file' not in request.files: return jsonify({'error': {'message': 'No file part'}}), 400
    file = request.files['file']
    if file.filename == '': return jsonify({'error': {'message': 'No selected file'}}), 400
    if file and allowed_file(file.filename):
        original_filename = secure_filename(file.filename); filename_prefix = str(uuid.uuid4())[:8]
        base, ext = os.path.splitext(original_filename); safe_base = re.sub(r'[^\w-]', '', base)[:50]
        filename = f"{filename_prefix}_{safe_base}{ext}"; counter = 1; temp_filename_to_check = filename
        upload_path = app.config.get('UPLOAD_FOLDER', './static/uploads_fallback')
        final_filepath = os.path.join(upload_path, temp_filename_to_check)
        while os.path.exists(final_filepath):
            temp_filename_to_check = f"{filename_prefix}_{safe_base}_{counter}{ext}"
            final_filepath = os.path.join(upload_path, temp_filename_to_check); counter += 1
        filename = temp_filename_to_check
        try:
            file.save(final_filepath); image_url = url_for('static', filename=f'uploads/{filename}') 
            return jsonify({'location': image_url})
        except Exception as e:
            app.logger.error(f"Image upload failed: {e}, filepath: {final_filepath}")
            return jsonify({'error': {'message': f'Image upload failed: {str(e)}'}}), 500
    return jsonify({'error': {'message': f'Allowed types: {app.config.get("ALLOWED_EXTENSIONS", set())}'}}), 400

@app.route('/admin/categories')
@admin_required
def admin_categories(): return render_template('admin_categories.html')

@app.route('/admin/category/new', methods=['GET', 'POST'])
@admin_required
def new_category():
    if not Category: abort(500)
    if request.method == 'POST':
        name = request.form.get('name')
        if not name: flash('카테고리 이름을 입력해주세요.', 'warning')
        else:
            try:
                if Category.query.filter_by(name=name).first(): flash('이미 존재하는 카테고리 이름.', 'warning')
                else:
                    db.session.add(Category(name=name)); db.session.commit()
                    flash(f'카테고리 "{name}" 추가 완료.', 'success'); return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback(); app.logger.error(f"Error creating category: {e}"); flash(f'카테고리 추가 오류: {str(e)}', 'danger')
        return render_template('edit_category.html', category_name=name, category=None)
    return render_template('edit_category.html', category=None, category_name='')

@app.route('/admin/category/edit/<int:category_id>', methods=['GET', 'POST'])
@admin_required
def edit_category(category_id):
    if not Category: abort(500)
    category_to_edit = Category.query.get_or_404(category_id); category_name_for_form = category_to_edit.name
    if request.method == 'POST':
        new_name = request.form.get('name'); category_name_for_form = new_name
        if not new_name: flash('카테고리 이름을 입력해주세요.', 'warning')
        elif new_name == category_to_edit.name: flash('변경된 내용이 없습니다.', 'info'); return redirect(url_for('admin_categories'))
        else:
            try:
                if Category.query.filter(Category.name == new_name, Category.id != category_id).first(): flash('이미 존재하는 카테고리 이름.', 'warning')
                else:
                    original_name = category_to_edit.name; category_to_edit.name = new_name
                    category_to_edit.slug = category_to_edit._generate_unique_slug(new_name); db.session.commit()
                    flash(f'카테고리 "{original_name}"이 "{new_name}"(으)로 수정 완료.', 'success'); return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback(); app.logger.error(f"Error editing category: {e}"); flash(f'카테고리 수정 오류: {str(e)}', 'danger')
        return render_template('edit_category.html', category=category_to_edit, category_name=category_name_for_form)
    return render_template('edit_category.html', category=category_to_edit, category_name=category_name_for_form)

@app.route('/admin/category/delete/<int:category_id>', methods=['POST'])
@admin_required
def delete_category(category_id):
    if not Category: abort(500)
    category_to_delete = Category.query.get_or_404(category_id)
    if category_to_delete.posts_in_category.count() > 0:
        flash(f'"{category_to_delete.name}"에 속한 글이 있어 삭제 불가.', 'danger'); return redirect(url_for('admin_categories'))
    try:
        db.session.delete(category_to_delete); db.session.commit(); flash(f'카테고리 "{category_to_delete.name}" 삭제 완료.', 'success')
    except Exception as e:
        db.session.rollback(); app.logger.error(f"Error deleting category: {e}"); flash(f'카테고리 삭제 오류: {str(e)}', 'danger')
    return redirect(url_for('admin_categories'))

@app.route('/category/<string:slug>')
def posts_by_category(slug):
    if not Category or not Post: abort(500)
    category = Category.query.filter_by(slug=slug).first_or_404(); page = request.args.get('page', 1, type=int)
    posts_pagination = category.posts_in_category.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=category)

@app.cli.command('init-db')
def init_db_cli_command():
    if db is None: print("DB not initialized."); return
    with app.app_context(): db.drop_all(); db.create_all()
    print('Initialized the database.')

_db_initialized_flag = False
@app.before_request
def ensure_tables_exist():
    global _db_initialized_flag
    if not _db_initialized_flag and db is not None:
        with app.app_context(): db.create_all()
        _db_initialized_flag = True

@app.route('/debug_config_check')
def debug_config_check():
    max_size = app.config.get('MAX_CONTENT_LENGTH')
    if max_size is None: return "MAX_CONTENT_LENGTH is not set."
    is_5gb = (max_size == 5000 * 1024 * 1024)
    return f"MAX_CONTENT_LENGTH: {max_size} bytes. Is this 5GB? {is_5gb}"

if __name__ == '__main__':
    if db is not None:
        with app.app_context(): db.create_all() 
    app.run(host='10.244.122.25', port=8099, debug=True, threaded=True)
3. templates/view_post.html (전체 코드 - 비밀번호 폼 및 내용 표시 로직 포함)

HTML

{% extends "base.html" %}

{% block title %}{{ post.title }} - 나의 게시판{% endblock %}

{% block content %}
{# base.html에서 col-md-9 안으로 이동했으므로, 이 div는 필요 없을 수 있음. 레이아웃에 따라 조절. #}
{# <div class="container mt-4"> #}

    {# show_password_form 플래그는 app.py의 view_post 라우트에서 전달됨 #}
    {% if show_password_form %}
        {# --- 비밀번호 입력 폼 --- #}
        <div class="password-form-container mt-5 p-4 border rounded bg-light shadow-sm">
            <h4 class="mb-3 text-center">비밀번호 입력</h4>
            <p class="text-center text-muted">이 게시글은 비밀번호로 보호되어 있습니다. 내용을 보시려면 비밀번호를 입력해주세요.</p>
            <form method="POST" action="{{ url_for('view_post', slug=post.slug) }}">
                <div class="form-group">
                    <label for="post_password_view_input" class="sr-only">비밀번호:</label> {# sr-only for accessibility #}
                    <input type="password" class="form-control form-control-lg" id="post_password_view_input" name="post_password_view" placeholder="비밀번호" required autofocus>
                </div>
                <button type="submit" class="btn btn-primary btn-block">확인</button>
                <div class="text-center mt-3">
                    <a href="{{ url_for('index') }}" class="btn btn-link btn-sm">목록으로 돌아가기</a>
                </div>
            </form>
        </div>
        {# --- 비밀번호 입력 폼 끝 --- #}
    {% else %}
        {# --- 실제 게시글 내용 --- #}
        <article class="mt-4">
            <header class="mb-4 pb-3 border-bottom">
                <h1>{{ post.title }}</h1>
                <div class="text-muted">
                    <small>
                        작성일: {{ post.timestamp.strftime('%Y년 %m월 %d일 %H:%M') }} (UTC)
                        {% if post.category %}
                            | 카테고리: <a href="{{ url_for('posts_by_category', slug=post.category.slug) }}">{{ post.category.name }}</a>
                        {% endif %}
                        {% if post.is_password_protected and post.password_hash %} {# 비밀글 표시 (해시가 실제로 있을 때만) #}
                            | <span class="text-danger font-weight-bold">🔒 비밀글</span>
                        {% endif %}
                    </small>
                </div>
                {% if is_admin %}
                    <div class="mt-2">
                        <a href="{{ url_for('edit_post', slug=post.slug) }}" class="btn btn-sm btn-outline-secondary">수정</a>
                        <form action="{{ url_for('delete_post', slug=post.slug) }}" method="POST" class="d-inline" onsubmit="return confirm('정말로 이 게시글을 삭제하시겠습니까?');">
                            <button type="submit" class="btn btn-sm btn-outline-danger">삭제</button>
                        </form>
                    </div>
                {% endif %}
            </header>
            <section class="post-content lead"> {# 'lead' 클래스 추가로 본문 텍스트 약간 크게 #}
                {{ post.content | safe }}
            </section>
        </article>
        <hr class="my-4">
        <a href="{{ url_for('index') }}" class="btn btn-outline-primary">목록으로 돌아가기</a>
        {# --- 실제 게시글 내용 끝 --- #}
    {% endif %}

{# </div> #}
{% endblock %}
4. templates/index.html (비밀글 아이콘 표시 부분만 수정 - 선택 사항)

HTML

{# ... index.html의 게시글 루프 내 <small> 태그 안쪽 ... #}
<small class="text-muted">
    작성일: {{ post_item.timestamp.strftime('%Y년 %m월 %d일 %H:%M') }} (UTC)
    {% if post_item.category %}
        | 카테고리: <a href="{{ url_for('posts_by_category', slug=post_item.category.slug) }}">{{ post_item.category.name }}</a>
    {% endif %}
    {% if post_item.is_password_protected and post_item.password_hash %} {# 비밀글 표시 (해시가 실제로 있을 때만) #}
        | <span class="text-danger" title="비밀글">🔒</span>
    {% endif %}
</small>
{# ... #}
templates/edit_post.html은 이전 답변("아씨발 됐고 edit post 수정된 최종을달라고 수정한걸 되는걸 달라고")에서 드린 최종 버전을 사용하시면 됩니다. (비밀번호 입력 필드가 항상 보이는 버전)

적용 순서:

위에 제공된 models.py, app.py, templates/view_post.html, templates/index.html (선택) 코드로 해당 파일들을 완전히 교체합니다.
templates/edit_post.html은 이전 답변에서 드린 "비밀번호 입력 필드 항상 표시" 버전인지 확인합니다.
데이터베이스 파일 (board.db)을 삭제합니다.
Flask 애플리케이션을 재시작합니다.