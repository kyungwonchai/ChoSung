겠습니다. 이전에 제공한 WPF 사물함 관리 프로그램의 전체 소스 코드를 상세한 한글 주석과 함께 다시 제공해 드립니다. MVVM 패턴, DevExpress 22.2 컨트롤, MS SQL Server 단일 테이블 연동, CRUD 기능, 필터링, 그리고 사용자 이동 편의성을 위한 기능들이 포함되어 있습니다.

1. 데이터베이스 설정 (MS SQL Server)

먼저, SQL Server Management Studio (SSMS) 등을 사용하여 데이터베이스와 테이블을 생성합니다.

SQL

-- 데이터베이스가 존재하지 않으면 새로 생성합니다.
IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'LockerManagementDB')
BEGIN
    CREATE DATABASE LockerManagementDB;
END
GO

-- 생성된 데이터베이스를 사용합니다.
USE LockerManagementDB;
GO

-- 테이블이 이미 존재하면 삭제합니다 (스크립트 재실행 용이성을 위해).
IF OBJECT_ID('dbo.LockerAssignments', 'U') IS NOT NULL
    DROP TABLE dbo.LockerAssignments;
GO

-- 기본 사물함 배정 정보를 저장할 테이블을 생성합니다.
CREATE TABLE LockerAssignments (
    Id INT PRIMARY KEY IDENTITY(1,1),             -- 각 레코드의 고유 식별자 (자동 증가)
    LockerType NVARCHAR(50) NOT NULL,            -- 사물함 종류 ('개인사물함', '락커', '신발장')
    Floor NVARCHAR(10) NOT NULL,                 -- 층 ('B1', '1', '2', '3', '4')
    Zone NVARCHAR(50) NOT NULL,                  -- 구역 ('A'~'H', 'B1'~'B4', '기타' 등)
    SpecificLocation NVARCHAR(100) NOT NULL,     -- 세부 위치 (수기입력 - 물리적 사물함을 식별하는 고유값)
    UserName NVARCHAR(100) NULL,                -- 사용자 이름 (수기입력 - 비어있으면 NULL)
    KnoxId NVARCHAR(100) NULL,                   -- Knox ID (수기입력 - 비어있으면 NULL)
    SubPart NVARCHAR(50) NULL,                   -- 소속 파트 ('Main(시생산)', 'MainA'~'Z' - 비어있으면 NULL)
    Administrator NVARCHAR(100) NULL,           -- 관리자 ('홍길동A'~'X' - 이 레코드/배정을 관리하는 사람)
    LastUpdated DATETIME2 NOT NULL DEFAULT GETDATE() -- 마지막 수정일시 (변경 추적용)
);
GO

-- 옵션: 초기 데이터로 빈 사물함 몇 개를 추가합니다.
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'A', 'A-01', 'System', GETDATE()),
('개인사물함', '1', 'A', 'A-02', 'System', GETDATE()),
('락커', 'B1', 'B1', 'R-B1-01', 'System', GETDATE()),
('신발장', '2', '2F', 'S-2F-01', 'System', GETDATE());

-- 옵션: 사용자 배정 예시 데이터를 추가합니다.
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, UserName, KnoxId, SubPart, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'B', 'B-15', '김철수', 'kimcs', 'MainA', '홍길동A', GETDATE());
GO

-- 옵션: 검색 성능 향상을 위해 인덱스를 추가합니다. (특히 사물함 개수가 많을 경우 유용)
CREATE INDEX IX_LockerAssignments_Location ON dbo.LockerAssignments (Floor, Zone, SpecificLocation);
CREATE INDEX IX_LockerAssignments_User ON dbo.LockerAssignments (UserName);
GO

PRINT '데이터베이스 및 테이블 생성이 완료되었습니다.';

2. WPF 프로젝트 설정 (Visual Studio)

Visual Studio에서 새 "WPF 앱 (.NET Framework)" 또는 "WPF 애플리케이션" 프로젝트를 생성합니다. (.NET Framework 4.7.2 이상 또는 .NET 6/7/8 권장).
NuGet 패키지 설치:
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore.Tools
DevExpress WPF 관련 패키지 (최소 DevExpress.Wpf.Core, DevExpress.Wpf.Grid, 선호하는 테마 예: DevExpress.Wpf.Themes.Office2019Colorful)
폴더 생성: 프로젝트 구조화를 위해 Models, ViewModels, Views, Data, Infrastructure (또는 Helpers) 폴더를 생성합니다.
3. 모델 (Models/LockerAssignment.cs)

데이터베이스 LockerAssignments 테이블의 한 행을 나타내는 C# 클래스입니다.

C#

using System;
using System.ComponentModel; // INotifyPropertyChanged를 위해 추가
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Runtime.CompilerServices; // CallerMemberName을 위해 추가

namespace LockerManagementApp.Models
{
    /// <summary>
    /// 사물함 배정 정보를 나타내는 데이터 모델 클래스입니다.
    /// INotifyPropertyChanged를 구현하여 속성 변경 시 UI가 업데이트되도록 합니다.
    /// </summary>
    [Table("LockerAssignments")] // 데이터베이스의 'LockerAssignments' 테이블과 매핑
    public class LockerAssignment : INotifyPropertyChanged // 속성 변경 알림 인터페이스 구현
    {
        private int _id;
        private string _lockerType = string.Empty;
        private string _floor = string.Empty;
        private string _zone = string.Empty;
        private string _specificLocation = string.Empty;
        private string? _userName;
        private string? _knoxId;
        private string? _subPart;
        private string? _administrator;
        private DateTime _lastUpdated = DateTime.Now;


        [Key] // 기본 키 속성임을 나타냅니다.
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)] // 데이터베이스에서 값이 자동으로 생성됨 (자동 증가)
        public int Id
        {
            get => _id;
            set => SetProperty(ref _id, value); // 변경 시 알림
        }

        [Required(ErrorMessage = "사물함 종류는 필수 항목입니다.")] // 필수 입력 값 검증
        [StringLength(50)] // 문자열 최대 길이 제한
        public string LockerType
        {
            get => _lockerType;
            set => SetProperty(ref _lockerType, value);
        }

        [Required(ErrorMessage = "층 정보는 필수 항목입니다.")]
        [StringLength(10)]
        public string Floor
        {
            get => _floor;
            set => SetProperty(ref _floor, value);
        }

        [Required(ErrorMessage = "구역 정보는 필수 항목입니다.")]
        [StringLength(50)]
        public string Zone
        {
            get => _zone;
            set => SetProperty(ref _zone, value);
        }

        [Required(ErrorMessage = "세부 위치는 필수 항목입니다.")]
        [StringLength(100)]
        public string SpecificLocation // 물리적 사물함을 고유하게 식별하는 값
        {
            get => _specificLocation;
            set => SetProperty(ref _specificLocation, value);
        }

        [StringLength(100)]
        public string? UserName // 사용자 이름 (Nullable: 비어있을 수 있음)
        {
            get => _userName;
            set
            {
                if (SetProperty(ref _userName, value))
                {
                    OnPropertyChanged(nameof(IsAssigned)); // UserName 변경 시 IsAssigned 상태도 변경됨을 알림
                }
            }
        }

        [StringLength(100)]
        public string? KnoxId // Knox ID (Nullable)
        {
            get => _knoxId;
            set => SetProperty(ref _knoxId, value);
        }

        [StringLength(50)]
        public string? SubPart // 소속 파트 (Nullable)
        {
            get => _subPart;
            set => SetProperty(ref _subPart, value);
        }

        [StringLength(100)]
        public string? Administrator // 관리자 (Nullable)
        {
            get => _administrator;
            set => SetProperty(ref _administrator, value);
        }

        // 마지막 수정일시는 일반적으로 UI에서 직접 수정하지 않으므로 setter에 알림이 필수는 아님
        public DateTime LastUpdated
        {
            get => _lastUpdated;
            set => SetProperty(ref _lastUpdated, value);
        }

        /// <summary>
        /// 현재 사물함이 사용자에게 배정되었는지 여부를 나타냅니다. (데이터베이스에는 매핑되지 않음)
        /// </summary>
        [NotMapped] // 이 속성은 데이터베이스 컬럼이 아님
        public bool IsAssigned => !string.IsNullOrWhiteSpace(UserName);

        /// <summary>
        /// 디버깅이나 간단한 표시 목적으로 객체를 문자열로 표현합니다.
        /// </summary>
        public override string ToString()
        {
            return $"{Floor}-{Zone}-{SpecificLocation}: {(IsAssigned ? UserName : "(비어 있음)")}";
        }

        // --- INotifyPropertyChanged 구현 ---
        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        /// 속성 변경을 알립니다.
        /// </summary>
        /// <param name="propertyName">변경된 속성의 이름 (CallerMemberName으로 자동 제공됨)</param>
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        /// <summary>
        /// 속성 값을 설정하고 변경되었을 경우 PropertyChanged 이벤트를 발생시킵니다.
        /// </summary>
        /// <typeparam name="T">속성의 타입</typeparam>
        /// <param name="storage">속성의 backing field</param>
        /// <param name="value">새로운 값</param>
        /// <param name="propertyName">변경된 속성의 이름</param>
        /// <returns>값이 변경되었으면 true, 아니면 false</returns>
        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false; // 값이 같으면 변경 안 함
            storage = value;
            OnPropertyChanged(propertyName); // 값이 변경되었으므로 알림 발생
            return true;
        }
        // --- INotifyPropertyChanged 구현 끝 ---
    }
}
주요 변경: LockerAssignment 모델이 INotifyPropertyChanged를 직접 구현하도록 수정했습니다. 이렇게 하면 GridControl에서 개별 셀 수정 시 UI가 즉각적으로 반응하고, IsAssigned 같은 계산된 속성도 올바르게 업데이트됩니다.

4. 데이터 컨텍스트 (Data/LockerDbContext.cs)

Entity Framework Core를 사용하여 데이터베이스와 상호작용하는 클래스입니다.

C#

using LockerManagementApp.Models;
using Microsoft.EntityFrameworkCore;
using System.Configuration; // App.config 사용을 위해 System.Configuration 참조 추가 필요

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework Core DbContext 클래스. 데이터베이스 연결 및 테이블 접근을 관리합니다.
    /// </summary>
    public class LockerDbContext : DbContext
    {
        /// <summary>
        /// LockerAssignments 테이블에 접근하기 위한 DbSet입니다.
        /// </summary>
        public DbSet<LockerAssignment> LockerAssignments { get; set; }

        /// <summary>
        /// 데이터베이스 연결 방법을 설정합니다.
        /// </summary>
        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured) // 이미 설정되지 않았을 경우에만 실행
            {
                // App.config 파일에서 "LockerDbConnection" 이름의 연결 문자열을 가져옵니다.
                string connectionString = ConfigurationManager.ConnectionStrings["LockerDbConnection"]?.ConnectionString
                                            // App.config에 연결 문자열이 없거나 읽기 실패 시 사용할 기본(폴백) 연결 문자열
                                            ?? "Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;Encrypt=False;";

                // 중요: "YOUR_SERVER_NAME" 부분을 실제 SQL Server 인스턴스 이름으로 변경해야 합니다.
                // 예: (localdb)\MSSQLLocalDB, localhost, .\SQLEXPRESS, 서버주소 등
                // Trusted_Connection=True 는 Windows 인증을 사용합니다.
                // SQL Server 인증을 사용하려면 User ID=your_user;Password=your_password; 형태로 변경합니다.
                // Encrypt=False 는 개발 편의를 위한 설정이며, 프로덕션 환경에서는 True 사용 및 SQL Server SSL 구성 고려가 필요합니다.

                optionsBuilder.UseSqlServer(connectionString); // SQL Server 사용 설정
            }
        }

        /// <summary>
        /// 모델(테이블) 구성을 위한 메서드입니다. Fluent API를 사용하여 추가 설정을 할 수 있습니다.
        /// </summary>
        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // 예시: 물리적 위치(층, 구역, 세부위치)에 대해 고유 제약 조건을 설정할 수 있습니다.
            // 이렇게 하면 동일한 실제 사물함에 대해 중복된 데이터 행 생성을 방지할 수 있습니다.
            // modelBuilder.Entity<LockerAssignment>()
            //    .HasIndex(l => new { l.Floor, l.Zone, l.SpecificLocation }) // 이 컬럼 조합으로 인덱스 생성
            //    .IsUnique(); // 고유 값만 허용

            // SQL DEFAULT 제약 조건이 이미 처리하지만, 여기서 기본값 설정을 명시할 수도 있습니다.
            // modelBuilder.Entity<LockerAssignment>()
            //     .Property(l => l.LastUpdated)
            //     .HasDefaultValueSql("GETDATE()"); // SQL Server의 GETDATE() 함수를 기본값으로 사용

            base.OnModelCreating(modelBuilder); // 기본 모델 구성 로직 호출
        }

        /// <summary>
        /// 데이터베이스 변경 사항을 저장하기 전에 LastUpdated 타임스탬프를 자동으로 업데이트합니다.
        /// </summary>
        public override int SaveChanges()
        {
            UpdateTimestamps(); // 타임스탬프 업데이트 로직 호출
            return base.SaveChanges(); // 기본 저장 로직 실행
        }

        /// <summary>
        /// 비동기 방식으로 데이터베이스 변경 사항을 저장하기 전에 LastUpdated 타임스탬프를 자동으로 업데이트합니다.
        /// </summary>
        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            UpdateTimestamps(); // 타임스탬프 업데이트 로직 호출
            return base.SaveChangesAsync(cancellationToken); // 기본 비동기 저장 로직 실행
        }

        /// <summary>
        /// 추가(Added)되거나 수정(Modified)된 LockerAssignment 엔티티의 LastUpdated 속성을 현재 시간으로 설정합니다.
        /// </summary>
        private void UpdateTimestamps()
        {
            // 변경 추적기(ChangeTracker)에서 LockerAssignment 타입이면서 상태가 Added 또는 Modified인 엔티티들을 가져옵니다.
            var entries = ChangeTracker
                .Entries()
                .Where(e => e.Entity is LockerAssignment && (
                        e.State == EntityState.Added ||
                        e.State == EntityState.Modified));

            // 각 엔티티에 대해 LastUpdated 속성을 현재 시간으로 설정합니다.
            foreach (var entityEntry in entries)
            {
                ((LockerAssignment)entityEntry.Entity).LastUpdated = DateTime.Now;

                // 옵션: 여기서 현재 로그인한 관리자 정보를 Administrator 속성에 설정할 수도 있습니다.
                // if (entityEntry.State == EntityState.Modified || entityEntry.State == EntityState.Added)
                // {
                //     ((LockerAssignment)entityEntry.Entity).Administrator = GetCurrentAdminUser(); // 현재 관리자 정보 가져오는 함수 필요
                // }
            }
        }
    }
}
App.config 파일 설정: 프로젝트 루트에 있는 App.config 파일을 열고 <configuration> 섹션 안에 <connectionStrings>를 추가하거나 수정합니다.

XML

<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <connectionStrings>
    <add name="LockerDbConnection"
         connectionString="Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;Encrypt=False;"
         providerName="System.Data.SqlClient"/>
  </connectionStrings>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/> </startup>
</configuration>
 1 5. ViewModel 베이스 및 RelayCommand (Infrastructure)   
1.
stackoverflow.com
stackoverflow.com

MVVM 패턴 구현을 위한 표준 헬퍼 클래스입니다.

(Infrastructure/ViewModelBase.cs)

C#

using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// 모든 ViewModel 클래스가 상속받는 기본 클래스입니다.
    /// INotifyPropertyChanged 인터페이스 구현을 제공하여 속성 변경 알림을 단순화합니다.
    /// </summary>
    public abstract class ViewModelBase : INotifyPropertyChanged
    {
        /// <summary>
        /// 속성 값이 변경될 때 발생하는 이벤트입니다.
        /// </summary>
        public event PropertyChangedEventHandler? PropertyChanged;

        /// <summary>
        /// PropertyChanged 이벤트를 발생시키는 보호된 메서드입니다.
        /// </summary>
        /// <param name="propertyName">변경된 속성의 이름입니다. [CallerMemberName] 특성 덕분에 자동으로 채워집니다.</param>
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        /// <summary>
        /// 속성 값을 설정하고, 값이 실제로 변경된 경우에만 PropertyChanged 이벤트를 발생시킵니다.
        /// </summary>
        /// <typeparam name="T">속성의 타입입니다.</typeparam>
        /// <param name="storage">속성 값을 저장하는 private 필드 (backing field)입니다.</param>
        /// <param name="value">설정하려는 새로운 값입니다.</param>
        /// <param name="propertyName">변경된 속성의 이름입니다.</param>
        /// <returns>값이 성공적으로 변경되었으면 true, 그렇지 않으면 false를 반환합니다.</returns>
        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string? propertyName = null)
        {
            // 기존 값과 새 값이 동일하면 아무 작업도 수행하지 않습니다.
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;

            storage = value; // 새 값으로 필드를 업데이트합니다.
            OnPropertyChanged(propertyName); // 속성 변경 알림을 발생시킵니다.
            return true; // 값 변경이 성공했음을 나타냅니다.
        }
    }
}
(Infrastructure/RelayCommand.cs)

C#

using System;
using System.Windows.Input;

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// ICommand 인터페이스의 간단한 구현체입니다. ViewModel에서 UI 작업(버튼 클릭 등)을 처리하는 데 사용됩니다.
    /// </summary>
    public class RelayCommand : ICommand
    {
        private readonly Action<object?> _execute; // 명령이 실행될 때 호출될 메서드 (Action 델리게이트)
        private readonly Predicate<object?>? _canExecute; // 명령을 실행할 수 있는지 여부를 결정하는 메서드 (Predicate 델리게이트, 선택 사항)

        /// <summary>
        /// 명령의 실행 가능 상태가 변경될 수 있음을 WPF CommandManager에 알리는 이벤트입니다.
        /// </summary>
        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; } // WPF의 전역 이벤트에 핸들러 추가
            remove { CommandManager.RequerySuggested -= value; } // 핸들러 제거
        }

        /// <summary>
        /// 새로운 RelayCommand 인스턴스를 생성합니다.
        /// </summary>
        /// <param name="execute">명령 실행 시 호출될 Action입니다. null일 수 없습니다.</param>
        /// <param name="canExecute">명령 실행 가능 여부를 반환하는 Predicate입니다. null이면 항상 실행 가능한 것으로 간주됩니다.</param>
        public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute)); // execute는 필수
            _canExecute = canExecute;
        }

        /// <summary>
        /// 현재 상태에서 명령을 실행할 수 있는지 여부를 결정합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        /// <returns>실행 가능하면 true, 그렇지 않으면 false입니다.</returns>
        public bool CanExecute(object? parameter)
        {
            // _canExecute 델리게이트가 null이면 항상 true를 반환하고, 아니면 해당 델리게이트의 결과를 반환합니다.
            return _canExecute == null || _canExecute(parameter);
        }

        /// <summary>
        /// 명령을 실행합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        public void Execute(object? parameter)
        {
            _execute(parameter); // 등록된 Action을 실행합니다.
        }

        /// <summary>
        /// CanExecuteChanged 이벤트를 강제로 발생시켜 명령의 실행 가능 상태를 다시 평가하도록 요청합니다.
        /// (ViewModel 속성 변경 시 이 메서드를 호출하여 버튼 활성화/비활성화 업데이트 가능)
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
6. 메인 ViewModel (ViewModels/MainViewModel.cs)

애플리케이션의 주요 로직과 데이터 상태를 관리합니다. View와 Model 사이의 중개자 역할을 합니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System.Collections.ObjectModel; // ObservableCollection 사용
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Microsoft.EntityFrameworkCore; // ToListAsync(), DbUpdateException 등 사용
using System.Windows; // MessageBox 사용

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 애플리케이션의 메인 ViewModel 클래스입니다.
    /// 사물함 데이터 로딩, 저장, 추가, 삭제, 배정 해제 등의 로직을 처리하고
    /// View에 필요한 데이터와 Command를 제공합니다.
    /// </summary>
    public class MainViewModel : ViewModelBase
    {
        private LockerDbContext _context; // 데이터베이스 컨텍스트 인스턴스
        private ObservableCollection<LockerAssignment> _lockerAssignments; // View에 바인딩될 사물함 목록 (UI 변경 자동 감지)
        private LockerAssignment? _selectedAssignment; // View의 GridControl에서 현재 선택된 항목
        private string _statusBarText = "준비 완료"; // View 하단 상태 표시줄에 표시될 텍스트
        private string _currentAdmin = "홍길동A"; // 예시: 현재 로그인한 관리자 (실제로는 로그인 정보나 설정에서 가져와야 함)

        /// <summary>
        /// View의 GridControl에 바인딩될 사물함 배정 목록입니다.
        /// ObservableCollection을 사용하여 목록 변경(추가/삭제) 시 UI가 자동으로 업데이트됩니다.
        /// </summary>
        public ObservableCollection<LockerAssignment> LockerAssignments
        {
            get => _lockerAssignments;
            set => SetProperty(ref _lockerAssignments, value); // 변경 시 UI 알림
        }

        /// <summary>
        /// View의 GridControl에서 사용자가 선택한 사물함 배정 정보입니다.
        /// 양방향(TwoWay) 바인딩을 통해 View에서의 선택이 ViewModel에 반영되고, ViewModel에서의 변경이 View에 반영됩니다.
        /// </summary>
        public LockerAssignment? SelectedAssignment
        {
            get => _selectedAssignment;
            set
            {
                // SetProperty는 값이 실제로 변경되었을 때만 true를 반환합니다.
                if (SetProperty(ref _selectedAssignment, value))
                {
                    // 선택된 항목이 변경되었으므로, 선택된 항목에 의존하는 Command들의 CanExecute 상태를 갱신해야 합니다.
                    // 예: 삭제 버튼, 배정 해제 버튼의 활성화/비활성화 여부
                    ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged();
                }
            }
        }

        /// <summary>
        /// View 하단의 상태 표시줄에 표시될 텍스트입니다.
        /// </summary>
        public string StatusBarText
        {
            get => _statusBarText;
            set => SetProperty(ref _statusBarText, value); // 변경 시 UI 알림
        }

        // --- Commands (View에서 버튼 등에 바인딩될 명령) ---
        public ICommand LoadDataCommand { get; }       // 데이터 로드 명령
        public ICommand SaveChangesCommand { get; }    // 변경 사항 저장 명령
        public ICommand AddNewCommand { get; }         // 새 사물함 추가 명령 (행 추가)
        public ICommand DeleteCommand { get; }         // 선택된 사물함 삭제 명령
        public ICommand ClearAssignmentCommand { get; } // 선택된 사물함의 사용자 배정 정보 해제 명령

        // --- View의 ComboBox 등에 사용할 미리 정의된 목록 ---
        // 실제 애플리케이션에서는 설정 파일이나 데이터베이스에서 로드하는 것이 더 좋습니다.
        public List<string> LockerTypes { get; } = new List<string> { "개인사물함", "락커", "신발장" };
        public List<string> Floors { get; } = new List<string> { "B1", "1", "2", "3", "4" };
        public List<string> Zones { get; } = new List<string> { "A", "B", "C", "D", "E", "F", "G", "H", "B1", "B2", "B3", "B4", "1F", "2F", "3F", "4F", "기타" };
        public List<string> SubParts { get; } = new List<string> { "Main(시생산)", "MainA", "MainB", "MainC", /* ... MainZ까지 추가 */ "MainD", "MainE", "MainF", "MainG", "MainH", "MainI", "MainJ", "MainK", "MainL", "MainM", "MainN", "MainO", "MainP", "MainQ", "MainR", "MainS", "MainT", "MainU", "MainV", "MainW", "MainX", "MainY", "MainZ" };
        public List<string> Administrators { get; } = new List<string> { "홍길동A", "홍길동B", "홍길동C", /* ... 홍길동X까지 추가 */ "홍길동D", "홍길동E", "홍길동F", "홍길동G", "홍길동H", "홍길동I", "홍길동J", "홍길동K", "홍길동L", "홍길동M", "홍길동N", "홍길동O", "홍길동P", "홍길동Q", "홍길동R", "홍길동S", "홍길동T", "홍길동U", "홍길동V", "홍길동W", "홍길동X" };


        /// <summary>
        /// MainViewModel 생성자입니다.
        /// 데이터베이스 컨텍스트를 초기화하고, Command들을 RelayCommand로 생성하며, 초기 데이터를 로드합니다.
        /// </summary>
        public MainViewModel()
        {
            _context = new LockerDbContext(); // 데이터베이스 컨텍스트 생성
            // ObservableCollection<LockerAssignment> 초기화 (빈 리스트로 시작)
            _lockerAssignments = new ObservableCollection<LockerAssignment>();

            // Command 초기화
            LoadDataCommand = new RelayCommand(async _ => await LoadDataAsync()); // 데이터 로드 (비동기)
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync()); // 변경 사항 저장 (비동기)
            AddNewCommand = new RelayCommand(AddNewLocker); // 새 사물함 추가 (동기: UI에 행만 추가)
            // 삭제 명령: SelectedAssignment가 null이 아닐 때만 실행 가능 (CanExecute 람다식)
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            // 배정 해제 명령: SelectedAssignment가 null이 아니고, IsAssigned가 true일 때만 실행 가능
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);

            // ViewModel 생성 시 자동으로 데이터 로드 시작 (비동기 호출이므로 await 하지 않음)
            _ = LoadDataAsync();
        }

        /// <summary>
        /// 데이터베이스에서 사물함 목록을 비동기적으로 로드하여 LockerAssignments 컬렉션에 채웁니다.
        /// </summary>
        private async Task LoadDataAsync()
        {
            StatusBarText = "데이터 로딩 중...";
            try
            {
                // Entity Framework Core를 사용하여 데이터베이스에서 모든 LockerAssignments를 가져옵니다.
                // 성능을 위해 AsNoTracking()을 사용할 수 있지만, 편집 기능을 사용하므로 추적 상태로 둡니다.
                // OrderBy를 사용하여 정렬 순서를 지정합니다.
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor)       // 층 오름차순
                                               .ThenBy(l => l.Zone)       // 구역 오름차순
                                               .ThenBy(l => l.SpecificLocation) // 세부위치 오름차순
                                               .ToListAsync(); // 비동기적으로 리스트로 변환

                // 기존 컬렉션을 새로 로드된 데이터로 교체합니다.
                // 이렇게 하면 UI(GridControl)가 자동으로 업데이트됩니다.
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"총 {LockerAssignments.Count}개의 레코드를 로드했습니다.";
            }
            catch (Exception ex) // 예외 처리
            {
                StatusBarText = $"데이터 로딩 오류: {ex.Message}";
                // 사용자에게 오류 메시지 표시
                MessageBox.Show($"데이터베이스 연결 또는 쿼리 실행 중 오류가 발생했습니다:\n{ex.Message}\n\nApp.config의 연결 문자열을 확인하고 데이터베이스 서버가 실행 중인지 확인하세요.", "로드 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// UI에서 발생한 변경 사항(추가, 수정, 삭제)을 데이터베이스에 비동기적으로 저장합니다.
        /// </summary>
        private async Task SaveChangesAsync()
        {
            StatusBarText = "변경 사항 저장 중...";
            try
            {
                // 기본적인 유효성 검사 예시: 새 항목 또는 수정된 항목 중 물리적 위치가 중복되는지 확인
                var duplicates = LockerAssignments
                    // 현재 컨텍스트에서 추가(Added) 또는 수정(Modified) 상태인 엔티티만 필터링
                    .Where(l => _context.Entry(l).State == EntityState.Added || _context.Entry(l).State == EntityState.Modified)
                    // 층, 구역, 세부위치로 그룹화
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    // 그룹 내 항목 수가 1개를 초과하는 경우 (중복)
                    .Where(g => g.Count() > 1)
                    // 중복된 키(위치 정보) 선택
                    .Select(g => g.Key);

                // 중복이 발견되면
                if (duplicates.Any())
                {
                     MessageBox.Show($"저장할 수 없습니다. 중복된 물리적 사물함 위치가 발견되었습니다: {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                     StatusBarText = "중복 위치로 인해 저장 실패.";
                     return; // 저장 작업 중단
                }


                // 변경된 엔티티들에 대해 현재 관리자 정보 설정 (DbContext의 SaveChanges 오버라이드에서도 가능)
                var changedEntries = _context.ChangeTracker.Entries<LockerAssignment>()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

                foreach(var entry in changedEntries)
                {
                    // LastUpdated는 DbContext의 SaveChanges 오버라이드에서 자동으로 처리됩니다.
                    entry.Entity.Administrator = _currentAdmin; // 변경을 수행한 관리자 정보 기록
                }


                // DbContext를 통해 변경 사항을 데이터베이스에 저장합니다.
                int changedCount = await _context.SaveChangesAsync(); // 비동기 저장
                StatusBarText = $"성공적으로 {changedCount}개의 변경 사항을 저장했습니다.";

                // 옵션: 저장 후 데이터를 다시 로드하여 데이터베이스에서 계산된 값 등을 반영할 수 있습니다.
                // await LoadDataAsync();
            }
            catch (DbUpdateException dbEx) // 데이터베이스 업데이트 관련 예외 처리
            {
                 // InnerException에 더 구체적인 오류 정보(예: 제약 조건 위반)가 있을 수 있습니다.
                var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                StatusBarText = $"데이터 저장 오류: {innerExceptionMessage}";
                MessageBox.Show($"데이터베이스에 변경 사항을 저장하는 중 오류가 발생했습니다:\n{innerExceptionMessage}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 // 저장 실패 시 변경 사항 롤백 고려 (더 복잡한 로직 필요)
                 // await RollbackChangesAsync();
            }
            catch (Exception ex) // 기타 일반적인 예외 처리
            {
                StatusBarText = $"데이터 저장 오류: {ex.Message}";
                MessageBox.Show($"저장 중 예기치 않은 오류가 발생했습니다:\n{ex.Message}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        /// <summary>
        /// GridControl에 새로운 빈 사물함 행을 추가합니다. (아직 데이터베이스에는 저장되지 않음)
        /// </summary>
        private void AddNewLocker(object? parameter) // parameter는 일반적으로 사용되지 않음
        {
            // 새 LockerAssignment 객체 생성
            var newAssignment = new LockerAssignment
            {
                // 기본값 설정 (ComboBox 목록의 첫 번째 항목 등)
                LockerType = LockerTypes.FirstOrDefault() ?? "개인사물함",
                Floor = Floors.FirstOrDefault() ?? "1",
                Zone = Zones.FirstOrDefault() ?? "A",
                // 세부 위치는 사용자가 입력해야 하므로 임시 고유값 설정
                SpecificLocation = "새 위치-" + Guid.NewGuid().ToString().Substring(0, 4),
                Administrator = _currentAdmin, // 생성 시 관리자 정보 설정
                LastUpdated = DateTime.Now // 생성 시각 설정 (저장 시 덮어쓰여짐)
            };

            // ObservableCollection에 추가하여 UI(GridControl)에 새 행 표시
            LockerAssignments.Add(newAssignment);
            // EF Core의 DbContext에도 추가하여 변경 사항 추적 시작
            _context.LockerAssignments.Add(newAssignment);

            // 새로 추가된 행을 GridControl에서 선택 상태로 만들어 사용자 편집 유도
            SelectedAssignment = newAssignment;
            StatusBarText = "새 사물함이 추가되었습니다. 세부 정보를 입력하고 '변경 사항 저장'을 클릭하세요.";
        }

        /// <summary>
        /// GridControl에서 선택된 사물함 정보를 데이터베이스와 UI에서 삭제합니다.
        /// </summary>
        private async Task DeleteSelectedAsync()
        {
            if (SelectedAssignment == null) return; // 선택된 항목이 없으면 아무 작업 안 함

            // 사용자에게 삭제 확인 메시지 표시
            if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함 정보를 정말 삭제하시겠습니까?",
                                "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "레코드 삭제 중...";
                try
                {
                    var assignmentToDelete = SelectedAssignment; // 삭제할 객체 참조 저장

                    // DbContext에서 해당 엔티티를 제거 대상으로 표시
                    _context.LockerAssignments.Remove(assignmentToDelete);
                    // 변경 사항(삭제)을 즉시 데이터베이스에 저장
                    int changedCount = await _context.SaveChangesAsync();

                    // 데이터베이스에서 성공적으로 삭제된 경우에만 UI(ObservableCollection)에서도 제거
                    LockerAssignments.Remove(assignmentToDelete);
                    SelectedAssignment = null; // 선택 해제
                    StatusBarText = $"성공적으로 {changedCount}개의 레코드를 삭제했습니다.";
                }
                 catch (DbUpdateException dbEx) // 데이터베이스 업데이트 관련 예외 처리
                {
                    // 외래 키 제약 조건 등 삭제 실패 원인 확인
                    var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                    StatusBarText = $"데이터 삭제 오류: {innerExceptionMessage}";
                    MessageBox.Show($"데이터베이스에서 레코드를 삭제하는 중 오류가 발생했습니다:\n{innerExceptionMessage}", "삭제 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    // 오류 발생 시 데이터 일관성을 위해 다시 로드하는 것이 좋을 수 있음
                     await LoadDataAsync();
                }
                catch (Exception ex) // 기타 예외 처리
                {
                    StatusBarText = $"데이터 삭제 오류: {ex.Message}";
                     MessageBox.Show($"삭제 중 예기치 않은 오류가 발생했습니다:\n{ex.Message}", "삭제 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                     await LoadDataAsync(); // 오류 발생 시 데이터 일관성을 위해 다시 로드
                }
            }
        }

         /// <summary>
         /// 선택된 사물함의 사용자 배정 정보(UserName, KnoxId, SubPart 등)를 지웁니다.
         /// 사용자 이동(퇴사, 부서 변경 등) 시 빈 사물함으로 만드는 데 사용됩니다.
         /// </summary>
        private void ClearSelectedAssignment(object? parameter) // parameter는 일반적으로 사용되지 않음
        {
             if (SelectedAssignment != null)
            {
                // 사용자 관련 필드를 null 또는 빈 문자열로 설정
                SelectedAssignment.UserName = null;
                SelectedAssignment.KnoxId = null;
                SelectedAssignment.SubPart = null;
                // 관리자 정보는 유지하거나 규칙에 따라 지울 수 있음
                // SelectedAssignment.Administrator = null;

                // 중요: LockerAssignment가 INotifyPropertyChanged를 구현했으므로,
                // 속성 변경 시 자동으로 UI가 업데이트됩니다.
                // OnPropertyChanged(nameof(SelectedAssignment.IsAssigned)); // IsAssigned도 업데이트 알림

                // EF Core 컨텍스트에서 해당 엔티티의 상태를 '수정됨(Modified)'으로 명시적으로 설정할 수도 있습니다.
                // (일반적으로 속성 변경 시 자동으로 감지하지만 명확성을 위해 추가 가능)
                 _context.Entry(SelectedAssignment).State = EntityState.Modified;
                 // 누가 배정을 해제했는지 관리자 정보 업데이트
                 SelectedAssignment.Administrator = _currentAdmin;
                 // LastUpdated는 SaveChanges 시 자동으로 업데이트되지만, 여기서 명시적으로 설정해도 무방
                 // SelectedAssignment.LastUpdated = DateTime.Now;

                StatusBarText = $"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함의 배정을 해제했습니다. 변경 사항을 저장하세요.";

                 // 옵션: 배정 해제 작업을 즉시 데이터베이스에 저장하려면 아래 주석 해제
                 // _ = SaveChangesAsync();
            }
        }

        /// <summary>
        /// ViewModel이 소멸될 때 (예: 창이 닫힐 때) 호출되어 DbContext 같은 리소스를 정리합니다.
        /// </summary>
        public void Cleanup()
        {
            // DbContext가 사용하는 리소스를 해제합니다.
            _context?.Dispose();
        }
    }
}
7. 메인 View (Views/MainWindow.xaml)

사용자 인터페이스를 정의하는 XAML 파일입니다. DevExpress GridControl을 사용하여 데이터를 표시하고 편집합니다.

XML

<dx:ThemedWindow
    x:Class="LockerManagementApp.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
    xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
    xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
    xmlns:local="clr-namespace:LockerManagementApp.Views"
    xmlns:viewmodels="clr-namespace:LockerManagementApp.ViewModels"
    xmlns:models="clr-namespace:LockerManagementApp.Models"
    Title="사물함 관리 프로그램 (DevExpress MVVM)" Height="700" Width="1200"
    Loaded="ThemedWindow_Loaded"
    Closing="ThemedWindow_Closing">

    <dx:ThemedWindow.DataContext>
        <viewmodels:MainViewModel/>
    </dx:ThemedWindow.DataContext>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <Border Grid.Row="0" Background="{dx:ThemeResource ThemeBrush}" Padding="5">
             <StackPanel Orientation="Horizontal">
                <Button Content="🔄 로드/새로고침" Margin="3" Command="{Binding LoadDataCommand}" ToolTip="데이터베이스에서 최신 정보를 불러옵니다."/>
                <Button Content="💾 변경 사항 저장" Margin="3" Command="{Binding SaveChangesCommand}" ToolTip="그리드에서 변경된 내용을 데이터베이스에 저장합니다."/>
                <Button Content="➕ 새 사물함 추가" Margin="3" Command="{Binding AddNewCommand}" ToolTip="새로운 사물함 정보를 추가합니다 (새 행이 추가되며 직접 편집)."/>
                <Button Content="❌ 선택 항목 삭제" Margin="3" Command="{Binding DeleteCommand}" ToolTip="선택된 사물함 정보를 데이터베이스에서 삭제합니다."/>
                <Button Content="🧹 배정 해제" Margin="3,3,15,3" Command="{Binding ClearAssignmentCommand}" ToolTip="선택된 사물함의 사용자 배정 정보(이름, ID 등)를 제거합니다."/>
            </StackPanel>
        </Border>

        <dxg:GridControl Grid.Row="1"
                         ItemsSource="{Binding LockerAssignments}"                 SelectedItem="{Binding SelectedAssignment, Mode=TwoWay}" AutoGenerateColumns="None"                             EnableSmartColumnsGeneration="False"                    SelectionMode="Row"                                   >

            <dxg:GridControl.View>
                <dxg:TableView AllowPerPixelScrolling="True"        ShowTotalSummary="False"             ShowGroupPanel="True"                AllowEditing="True"                  AllowAddingNewItems="False"          AllowDeletingItems="False"           NavigationStyle="Cell"               ShowAutoFilterRow="True"             NewItemRowPosition="None"            AlternateRowBackground="{dx:ThemeResource {dxgt:GridRowThemeKey ResourceKey=AlternateRowBackgroundBrush}}" ShowIndicator="True"                 >
                     <dxg:TableView.RowCellMenuCustomizations>
                         <dx:BarButtonItem Content="선택 항목 배정 해제"
                                           Command="{Binding View.DataContext.ClearAssignmentCommand}" Glyph="{dx:DXImage Svg/Actions/DeleteList.svg}"/> <dx:BarItemSeparator/>
                         <dx:BarButtonItem Content="선택 행 삭제"
                                           Command="{Binding View.DataContext.DeleteCommand}" Glyph="{dx:DXImage Svg/Actions/Delete.svg}"/> </dxg:TableView.RowCellMenuCustomizations>
                </dxg:TableView>
            </dxg:GridControl.View>

            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="LockerType" Header="종류" Width="100" Fixed="Left"> <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.LockerTypes, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}" IsTextEditable="False"/> </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                 <dxg:GridColumn FieldName="Floor" Header="층" Width="60">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Floors, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}" IsTextEditable="False"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>

                <dxg:GridColumn FieldName="Zone" Header="구역" Width="80">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Zones, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}" IsTextEditable="True"/> </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                <dxg:GridColumn FieldName="SpecificLocation" Header="세부 위치" Width="120"/>

                <dxg:GridColumn FieldName="UserName" Header="성명" Width="100"/>
                <dxg:GridColumn FieldName="KnoxId" Header="Knox ID" Width="100"/>

                <dxg:GridColumn FieldName="SubPart" Header="소파트" Width="120">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.SubParts, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                 <dxg:GridColumn FieldName="Administrator" Header="관리 담당자" Width="120">
                      <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Administrators, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>

                <dxg:GridColumn FieldName="LastUpdated" Header="최종 수정일시" Width="150" AllowEditing="False" ReadOnly="True">
                     <dxg:GridColumn.EditSettings>
                        <dxe:DateEditSettings MaskType="DateTime" Mask="yyyy-MM-dd HH:mm:ss" MaskUseAsDisplayFormat="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                <dxg:GridColumn FieldName="Id" Header="ID" Visible="False" ReadOnly="True"/>

            </dxg:GridControl.Columns>

            <dxg:GridControl.ViewSettings>
                <dxg:TableViewSettings ShowSearchPanelMode="Always" ShowSearchPanelFindButton="True" ShowSearchPanelCloseButton="True" SearchPanelHighlightResults="True"/>
            </dxg:GridControl.ViewSettings>

        </dxg:GridControl>

        <StatusBar Grid.Row="2" Background="{dx:ThemeResource EditorGroupBox.Background}">
            <StatusBarItem>
                <TextBlock Text="{Binding StatusBarText}" Margin="5,0"/>
            </StatusBarItem>
        </StatusBar>
    </Grid>
</dx:ThemedWindow>
(Views/MainWindow.xaml.cs) - MVVM 패턴에서는 Code-behind 파일의 코드를 최소화합니다. 주로 View 자체의 이벤트 처리나 ViewModel에서 직접 처리하기 어려운 UI 관련 로직만 남깁니다.

C#

using DevExpress.Xpf.Core; // ThemedWindow, ApplicationThemeHelper 등 사용
using LockerManagementApp.ViewModels; // MainViewModel 참조
using System.Windows; // RoutedEventArgs 등 사용

namespace LockerManagementApp.Views
{
    /// <summary>
    /// MainWindow.xaml에 대한 상호 작용 논리
    /// MVVM 패턴을 따르므로, 복잡한 로직은 ViewModel에 위치해야 합니다.
    /// </summary>
    public partial class MainWindow : ThemedWindow // 기본 Window 대신 DevExpress ThemedWindow 상속
    {
        public MainWindow()
        {
            InitializeComponent(); // XAML 로드 및 컨트롤 초기화

            // 옵션: 애플리케이션 시작 시 DevExpress 테마 설정
            // 사용 가능한 테마 이름 확인 필요 (예: Office2019Colorful, VS2017Dark 등)
            ApplicationThemeHelper.ApplicationThemeName = Theme.Office2019ColorfulName;
        }

        /// <summary>
        /// 현재 Window의 DataContext를 MainViewModel 타입으로 안전하게 캐스팅하여 반환하는 편의 속성입니다.
        /// </summary>
        private MainViewModel? ViewModel => DataContext as MainViewModel;

        /// <summary>
        /// Window가 로드되었을 때 호출되는 이벤트 핸들러입니다.
        /// </summary>
        private void ThemedWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // ViewModel 생성자에서 이미 데이터 로드를 시작하지만,
            // 명시적으로 여기서 로드 명령을 실행하고 싶다면 아래 주석 해제
            // ViewModel?.LoadDataCommand.Execute(null);
        }

        /// <summary>
        /// Window가 닫히기 전에 호출되는 이벤트 핸들러입니다.
        /// </summary>
        private void ThemedWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
             // 옵션: 저장되지 않은 변경 사항이 있을 경우 사용자에게 저장 여부 확인 로직 추가 가능
             // if (ViewModel != null && ViewModel.HasUnsavedChanges) // HasUnsavedChanges 속성 구현 필요
             // {
             //     var result = MessageBox.Show("저장되지 않은 변경 사항이 있습니다. 저장하시겠습니까?", "확인", MessageBoxButton.YesNoCancel, MessageBoxImage.Question);
             //     if (result == MessageBoxResult.Yes)
             //     {
             //         ViewModel.SaveChangesCommand.Execute(null);
             //         // 저장 완료를 기다려야 할 수도 있음 (비동기 처리 시)
             //     }
             //     else if (result == MessageBoxResult.Cancel)
             //     {
             //         e.Cancel = true; // 창 닫기 취소
             //     }
             // }

            // ViewModel의 Cleanup 메서드를 호출하여 사용한 리소스(예: DbContext)를 정리합니다.
            ViewModel?.Cleanup();
        }
    }
}
8. 애플리케이션 진입점 (App.xaml / App.xaml.cs)

애플리케이션 시작 시 실행되는 부분입니다.

(App.xaml) - StartupUri가 MainWindow.xaml을 가리키도록 합니다.

XML

<Application x:Class="LockerManagementApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:LockerManagementApp"
             StartupUri="Views/MainWindow.xaml"> <Application.Resources>
        </Application.Resources>
</Application>
(App.xaml.cs) - 일반적으로 간단한 앱에서는 코드가 거의 없지만, 전역 설정이나 예외 처리 로직을 추가할 수 있습니다.

C#

using System;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading; // DispatcherUnhandledException 사용

namespace LockerManagementApp
{
    /// <summary>
    /// App.xaml에 대한 상호 작용 논리
    /// 애플리케이션 수준의 이벤트 처리 및 초기 설정을 담당할 수 있습니다.
    /// </summary>
    public partial class App : Application
    {
        /// <summary>
        /// 애플리케이션 시작 시 호출됩니다.
        /// </summary>
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // 전역 예외 처리 설정 (애플리케이션 안정성 향상)
            SetupGlobalExceptionHandling();
        }

        /// <summary>
        /// 처리되지 않은 예외를 처리하기 위한 핸들러를 설정합니다.
        /// </summary>
        private void SetupGlobalExceptionHandling()
        {
            // UI 스레드에서 처리되지 않은 예외
            DispatcherUnhandledException += (s, e) =>
            {
                LogAndShowException(e.Exception, "UI Thread Exception");
                e.Handled = true; // true로 설정하면 애플리케이션이 비정상 종료되지 않음
            };

            // 백그라운드 스레드(Task)에서 처리되지 않은 예외
            TaskScheduler.UnobservedTaskException += (s, e) =>
            {
                LogAndShowException(e.Exception, "Background Task Exception");
                e.SetObserved(); // 예외가 관찰되었음을 표시
            };

            // AppDomain 수준의 예외 (일반적으로 마지막 방어선)
            AppDomain.CurrentDomain.UnhandledException += (s, e) =>
            {
                LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception");
                // 여기서는 애플리케이션 종료를 막기 어려울 수 있음
            };
        }

        /// <summary>
        /// 예외 정보를 로그(여기서는 MessageBox로 단순화)하고 사용자에게 알립니다.
        /// </summary>
        /// <param name="exception">발생한 예외 객체</param>
        /// <param name="source">예외 발생 출처</param>
        private void LogAndShowException(Exception exception, string source)
        {
            // 실제 애플리케이션에서는 파일, 데이터베이스, 이벤트 로그 등에 기록해야 합니다.
            string errorMessage = $"예기치 않은 오류가 발생했습니다 ({source}):\n\n{exception.Message}\n\nStack Trace:\n{exception.StackTrace}";
            MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error);

            // 필요하다면 추가적인 정리 작업 수행
            // Environment.Exit(1); // 심각한 오류 시 강제 종료 고려
        }
    }
}

코드 실행 방법:

제공된 SQL 스크립트를 사용하여 SQL Server에 데이터베이스와 테이블을 생성합니다.
Visual Studio에서 WPF 프로젝트를 생성합니다.
필요한 NuGet 패키지(EF Core, DevExpress)를 설치합니다.
프로젝트에 Models, ViewModels, Views, Data, Infrastructure 폴더를 만들고 각 폴더에 제공된 C# 및 XAML 파일을 추가합니다.
매우 중요: App.config 파일과 Data/LockerDbContext.cs 파일 내의 **연결 문자열 (connectionString)**을 실제 사용하는 SQL Server 인스턴스 정보에 맞게 수정합니다.