삼성 Certi Expert 대비 C++ 힙 구현 (배열 사용)
삼성 Expert 시험에서는 vector 사용이 금지될 수 있으므로, 배열을 직접 사용하여 최대 힙(Max Heap)을 구현합니다.
배열을 이용한 완전 이진 트리 기반의 힙을 효율적으로 관리하는 것이 중요합니다.

📌 최대 힙(Max Heap) 기본 개념
완전 이진 트리(Complete Binary Tree) 구조
부모 노드의 값이 자식보다 크거나 같음
삽입(Insert): 새로운 값을 배열 끝에 추가 후, 부모와 비교하여 Up-Heap 조정
삭제(Delete Max): 루트 제거 후 마지막 요소를 루트로 이동, Down-Heap 조정
📌 C++ 배열 기반 최대 힙 구현
삼성 Certi Expert 시험 대비하여, 정적 배열을 사용하여 최대 힙을 구현합니다.
배열 크기를 MAX_SIZE로 정하고, 0번 인덱스를 사용하지 않음으로써 부모/자식 관계를 쉽게 계산합니다.

cpp
코드 복사
#include <iostream>

using namespace std;

#define MAX_SIZE 1001 // 힙의 최대 크기 (1000개 데이터 저장 가능)

class MaxHeap {
private:
    int heap[MAX_SIZE]; // 정적 배열 기반 힙
    int size; // 현재 힙의 요소 개수

public:
    // 생성자: 힙 초기화 (size를 0으로 설정)
    MaxHeap() { size = 0; }

    // 부모 노드의 인덱스를 반환
    int parent(int index) { return index / 2; }

    // 왼쪽 자식 노드의 인덱스를 반환
    int leftChild(int index) { return index * 2; }

    // 오른쪽 자식 노드의 인덱스를 반환
    int rightChild(int index) { return index * 2 + 1; }

    // 힙이 비어있는지 확인
    bool isEmpty() { return size == 0; }

    // 현재 힙의 크기 반환
    int getSize() { return size; }

    // 힙에 새로운 값 추가 (삽입 연산)
    void insert(int value) {
        if (size >= MAX_SIZE - 1) {
            cout << "Heap is full!\n";
            return;
        }

        // 힙의 마지막 위치에 새로운 값 추가
        heap[++size] = value;

        // Up-Heap 과정: 부모와 비교하여 위치 조정
        int index = size;
        while (index > 1 && heap[parent(index)] < heap[index]) {
            swap(heap[parent(index)], heap[index]); // 부모와 자리 교환
            index = parent(index); // 부모로 이동하여 반복
        }
    }

    // 최대값(루트) 삭제 후 반환 (삭제 연산)
    int deleteMax() {
        if (isEmpty()) {
            cout << "Heap is empty!\n";
            return -1;
        }

        int maxValue = heap[1]; // 루트 값 저장
        heap[1] = heap[size--]; // 마지막 요소를 루트로 이동 후 크기 감소

        // Down-Heap 과정: 자식과 비교하여 위치 조정
        int index = 1;
        while (leftChild(index) <= size) {
            int largerChild = leftChild(index);
            if (rightChild(index) <= size && heap[rightChild(index)] > heap[largerChild]) {
                largerChild = rightChild(index); // 오른쪽 자식이 더 크면 선택
            }

            if (heap[index] >= heap[largerChild]) break; // 부모가 크면 정렬 완료

            swap(heap[index], heap[largerChild]); // 자리 변경
            index = largerChild; // 인덱스 갱신
        }

        return maxValue; // 삭제된 최대값 반환
    }

    // 힙 출력 (디버깅용)
    void printHeap() {
        cout << "Heap: ";
        for (int i = 1; i <= size; i++) {
            cout << heap[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    MaxHeap maxHeap; // 최대 힙 객체 생성

    // 예제 데이터 삽입
    maxHeap.insert(10);
    maxHeap.insert(20);
    maxHeap.insert(30);
    maxHeap.insert(5);
    maxHeap.insert(50);
    maxHeap.insert(40);

    maxHeap.printHeap(); // 현재 힙 상태 출력

    // 최대값 삭제 후 출력
    cout << "Deleted Max: " << maxHeap.deleteMax() << endl;
    maxHeap.printHeap();

    return 0;
}
📌 주요 동작 과정 (상세 설명)
1️⃣ 삽입 연산 (Insert)
배열 끝에 새로운 값 추가 (heap[++size] = value)
Bubble-Up (Up-Heap)
부모와 비교하여 값이 더 크면 위치 변경
부모보다 작거나 루트에 도달하면 종료
2️⃣ 삭제 연산 (Delete Max)
루트(최대값)를 저장 후, 마지막 요소를 루트로 이동
Heapify (Down-Heap)
왼쪽, 오른쪽 자식 중 더 큰 값과 비교하여 자리 변경
부모가 자식보다 크거나 리프 노드 도달 시 종료
📌 출력 예시
cpp
코드 복사
Heap: 50 30 40 5 10 20
Deleted Max: 50
Heap: 40 30 20 5 10
📌 시간 복잡도 분석
연산	시간 복잡도
삽입 (Insert)	O(log N)
삭제 (Delete Max)	O(log N)
최대값 반환 (Get Max)	O(1)
힙 연산은 log N의 시간 복잡도를 가지므로, 100만 개의 데이터도 약 20번의 비교로 처리 가능
우선순위 큐를 직접 구현할 때 매우 유용
📌 시험 대비 정리
✅ 배열 기반 최대 힙 직접 구현 (vector 금지)
✅ Bubble-Up (삽입)과 Heapify (삭제) 과정 구현
✅ 완전 이진 트리 속성을 유지하면서 효율적인 연산 수행
✅ 시간 복잡도 O(log N) 보장으로 대량 데이터 처리 가능

📌 삼성 Certi Expert 대비 팁
1️⃣ 배열로 직접 구현하는 연습 필수 (vector 사용 불가)
2️⃣ 완전 이진 트리 성질 숙지 (부모 = index/2, 왼쪽 자식 = index*2, 오른쪽 자식 = index*2+1)
3️⃣ Bubble-Up & Heapify 과정 익히기 (swap을 활용한 자리 변경)
4️⃣ 시간 복잡도 고려한 최적화 구현 연습