었네요. 스위치문에서 SequenceFlag에 따라 각기 다른 함수 조합이 실행되며, 함수 개수만큼 도형이 동적으로 생성되도록 해야 합니다.

수정 사항 요약:
SequenceFlag에 따른 함수 개수를 동적으로 반영해 도형이 자동으로 설정되도록 수정하겠습니다.
각 함수 실행 시간이 실시간으로 도형에 표시되고, 완료 후 최종 시간도 도형에 남도록 수정합니다.
전체 작업이 끝난 후 **Cycle Time(CT)**도 기록되도록 수정합니다.
TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, SequenceFlag에 따라 선택된 함수가 순차적으로 실행되고,
/// 함수 개수에 맞춰 도형이 생성되며, 각 함수가 몇 초 동안 실행되었는지 표시됩니다.
/// 전체 작업이 완료되면 Cycle Time (CT) 컬럼에 기록됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }

    // 각 함수가 몇 초 걸렸는지를 저장 (도형 내부에 표시될 숫자값)
    public ObservableCollection<int> FunctionTimes { get; set; }

    // 전체 작업의 총 실행 시간을 기록하는 CT (Cycle Time)
    private string _cycleTime;
    public string CycleTime
    {
        get => _cycleTime;
        set
        {
            _cycleTime = value;
            OnPropertyChanged(nameof(CycleTime));
        }
    }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    // 작업 전체의 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _overallStopwatch;

    // 각 함수의 실행 시간을 측정하기 위한 Stopwatch
    private Stopwatch _functionStopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    // 동적으로 추가된 함수의 개수 (사용자 정의)
    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending"; // 처음엔 대기 상태
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        _overallStopwatch = new Stopwatch(); // 전체 작업 경과 시간 측정
        _functionStopwatch = new Stopwatch(); // 각 함수 실행 시간을 측정하기 위한 Stopwatch

        FunctionStatusColors = new ObservableCollection<Brush>(); // 도형 상태 리스트 초기화
        FunctionNames = new ObservableCollection<string>(); // 함수 이름 리스트 초기화
        FunctionTimes = new ObservableCollection<int>(); // 각 함수의 경과 시간을 저장하는 리스트 초기화

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        // 함수 개수는 시퀀스 플래그에 따라 결정
        _functionCount = SetFunctionListBySequenceFlag(SequenceFlag);
        InitializeFunctionColors(_functionCount); // 함수 개수에 맞게 도형 초기화
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트
        _overallStopwatch.Restart(); // 전체 작업 Stopwatch 시작

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        // 동적으로 할당된 함수 수에 따라 함수 실행
        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, ExecuteDynamicTask(i)); // 각 함수에 맞는 도형 및 경과 시간 업데이트
        }

        // 전체 작업이 완료되면 Cycle Time (전체 작업 시간)을 기록
        _overallStopwatch.Stop();
        CycleTime = $"{_overallStopwatch.Elapsed.Seconds} seconds"; // 전체 작업 시간 CT 컬럼에 기록

        // 작업 완료 후 상태 변경
        Status = "Completed";
        ProgressText = $"Completed in {CycleTime}";
        StartNextTask?.Invoke(this); // 다음 작업 시작
    }

    /// <summary>
    /// SequenceFlag에 따라 함수 리스트를 설정하고, 함수 개수를 반환합니다.
    /// 각 시퀀스에 따라 다른 함수 조합을 설정합니다.
    /// </summary>
    private int SetFunctionListBySequenceFlag(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                // 시작 시퀀스 - 3개의 함수 (Task A, B, C)
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                return 3;

            case 2:
                // 중간 시퀀스 - 3개의 함수 (Task C, B, D)
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                return 3;

            case 3:
                // 끝 시퀀스 - 4개의 함수 (Task A, B, E)
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                return 3;

            default:
                // 기본값 - 1개의 함수
                FunctionNames.Add("Task A");
                return 1;
        }
    }

    /// <summary>
    /// 동적으로 추가된 함수 실행 (예: Task A, Task B, Task C 등).
    /// 함수가 완료될 때마다 도형에 걸린 시간을 남깁니다.
    /// </summary>
    private Func<Task> ExecuteDynamicTask(int index)
    {
        return async () =>
        {
            _functionStopwatch.Restart(); // 함수 실행 시간을 측정하기 시작

            // 작업이 진행 중일 때 실시간으로 도형에 숫자 표시
            while (_functionStopwatch.IsRunning)
            {
                await Task.Delay(500); // 0.5초마다 실시간 경과 시간 업데이트
                FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds; // 도형에 실시간으로 경과 시간 표시
                OnPropertyChanged(nameof(FunctionTimes)); // 경과 시간 업데이트
            }

            await Task.Delay(1000); // 작업 시뮬레이션
            _functionStopwatch.Stop(); // 함수 완료 후 경과 시간 기록
            FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds; // 완료 후 최종 경과 시간 기록
        };
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// 함수가 실행된 시간은 도형에 표시됩니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, ExecuteDynamicTask(taskIndex));
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정하고, 실시간 경과 시간을 보여줄 초기 설정.
    /// </summary>
    private void InitializeFunctionColors(int functionCount)
    {
        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
            FunctionTimes.Add(0); // 경과 시간 초기값
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
변경된 부분 설명:
SetFunctionListBySequenceFlag(): 이 메서드에서 SequenceFlag에 따라 실행할 함수 리스트와 함수 개수를 설정합니다.

SequenceFlag == 1: Task A, Task B, Task C가 실행되며 3개의 도형이 나타납니다.
SequenceFlag == 2: Task C, Task B, Task D가 실행됩니다.
SequenceFlag == 3: Task A, Task B, Task E가 실행됩니다.
각 시퀀스마다 다른 함수 조합이 사용됩니다.
도형 상태 및 경과 시간:

각 도형 상태와 경과 시간은 함수 실행 시간에 따라 실시간으로 표시됩니다.
함수 실행이 완료되면 도형 색상은 녹색으로 변경되고, 경과 시간은 도형 내부에 남습니다.
Cycle Time (CT):

전체 작업이 끝나면 Cycle Time이 CT 컬럼에 기록되며, 전체 작업의 소요 시간을 표시합니다.
결론:
이제 SequenceFlag에 따라 실행할 함수가 동적으로 결정되고, 각 함수의 실행 시간이 실시간으로 표시됩니다. 추가적으로 수정할 사항이 있으면 언제든지 말씀해 주세요!