알겠습니다. 샘플 데이터가 부족한 경우를 처리하고, 최소 샘플 수를 확인하여 에러 메시지가 출력되지 않도록 수정하겠습니다. 이를 위해 최소 샘플 수를 확인하고, 충분한 데이터가 없는 경우 사용자에게 메시지를 표시하도록 하겠습니다.

수정된 MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private const int MinimumSampleSize = 10; // 최소 샘플 수
        private string logDirectory = @"C:\agent\SMDFIleClean";
        private MLModelBuilder _mlModelBuilder;
        private SettingsManager _settingsManager;
        private FileCleaner _fileCleaner;
        private List<FileRecord> _trainingData;

        public MainWindow()
        {
            InitializeComponent();
            _mlModelBuilder = new MLModelBuilder();
            _settingsManager = new SettingsManager();
            _fileCleaner = new FileCleaner(logDirectory, _mlModelBuilder, Dispatcher, LogRecentActivity, LogDeletionActivity, UpdateFolderStatistics);
            LoadSettings();
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                SaveSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnLoadSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                LoadSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnSelectFolder_Click(object sender, RoutedEventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                dialog.SelectedPath = txtFolderPath.Text;
                if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    txtFolderPath.Text = dialog.SelectedPath;
                }
            }
        }

        private void SaveSettings()
        {
            try
            {
                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = cmbFileExtension.Text,
                    DriveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\"
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "D:\\";
                    cmbFileExtension.Text = settings.FileExtension ?? ".jpg";
                }
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private async void btnStart_Click(object sender, RoutedEventArgs e)
        {
            string folderPath = txtFolderPath.Text;
            string fileExtension = cmbFileExtension.Text;
            string driveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\";

            if (string.IsNullOrEmpty(folderPath) || folderPath == "Enter folder path" ||
                string.IsNullOrEmpty(fileExtension))
            {
                MessageBox.Show("Please provide all inputs.");
                return;
            }

            try
            {
                _trainingData = CollectInitialFileData(folderPath, fileExtension);
                if (_trainingData.Count < MinimumSampleSize)
                {
                    MessageBox.Show($"Not enough samples to train the model. Minimum required samples: {MinimumSampleSize}");
                    return;
                }

                dataGridTrainingData.ItemsSource = _trainingData;
                _mlModelBuilder.TrainModel(_trainingData);

                await MonitorAndDisplayFilesToDelete(folderPath, fileExtension, driveName);
            }
            catch (Exception ex)
            {
                LogError("Failed to train model: " + ex.Message);
            }
        }

        private List<FileRecord> CollectInitialFileData(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories)
                                      .Where(f => !IsSystemVolumeInformation(f))
                                      .ToList();

                var fileDataList = files.Select(f => new FileRecord
                {
                    Hour = f.CreationTime.Hour,
                    DayOfWeek = (int)f.CreationTime.DayOfWeek
                }).ToList();

                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = $"Training on {files.Count} files";
                });

                return fileDataList;
            }
            catch (Exception ex)
            {
                LogError("Failed to collect initial file data: " + ex.Message);
                return new List<FileRecord>();
            }
        }

        private bool IsSystemVolumeInformation(FileInfo fileInfo)
        {
            return fileInfo.DirectoryName.Contains("System Volume Information");
        }

        private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = _fileCleaner.GetDriveFreeSpace(driveName);
                    if (freeSpace < MinimumFreeSpace)
                    {
                        List<FileInfo> filesToDelete = _fileCleaner.GetFilesToDelete(folderPath, fileExtension);
                        DisplayFilesToDelete(filesToDelete);
                        //await _fileCleaner.DeleteFilesAsync(filesToDelete); // 실제 삭제 코드 (주석 처리)
                    }

                    _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    LogError("Failed during monitoring: " + ex.Message);
                }
            }
        }

        private void DisplayFilesToDelete(List<FileInfo> filesToDelete)
        {
            Dispatcher.Invoke(() =>
            {
                lstPriorityFiles.Items.Clear();
                foreach (var file in filesToDelete)
                {
                    lstPriorityFiles.Items.Add(file.FullName);
                }
                dataGridTrainingResults.ItemsSource = filesToDelete.Select(f => new { f.Name, f.CreationTime });
            });
        }

        private void LogRecentActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                lstRecentLogs.Items.Add(message);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogDeletionActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                lstDeletionLogs.Items.Add(message);
                if (lstDeletionLogs.Items.Count > 200)
                {
                    lstDeletionLogs.Items.RemoveAt(0);
                }
            });
        }

        private void UpdateFolderStatistics(long totalSize, string folderPath)
        {
            Dispatcher.Invoke(() =>
            {
                lstRecentLogs.Items.Add($"Folder: {folderPath}, Total Size: {totalSize / (1024 * 1024)} MB");
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add(logMessage);
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                // 에러 로깅에 실패한 경우 추가 조치 없음
                Console.WriteLine("Error logging failed: " + ex.Message);
            }
        }
    }
}
수정된 MLModelBuilder.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileRecord> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileRecord>();
        }

        public void TrainModel(List<FileRecord> fileData)
        {
            try
            {
                if (fileData == null || fileData.Count < 10) // 최소 샘플 수 확인
                {
                    throw new InvalidOperationException("Not enough samples to train the model. Minimum required samples: 10");
                }

                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);

                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileRecord.Hour), nameof(FileRecord.DayOfWeek))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model: " + ex.Message, ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileRecord
                {
                    Hour = fileInfo.CreationTime.Hour,
                    DayOfWeek = (int)fileInfo.CreationTime.DayOfWeek
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileRecord, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification: " + ex.Message, ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var patternGroups = _fileDataList.GroupBy(f => new { f.Hour, f.DayOfWeek })
                    .Select(g => new { g.Key.Hour, g.Key.DayOfWeek, Count = g.Count() })
                    .OrderByDescending(g => g.Count);

                return string.Join(", ", patternGroups.Select(g => $"Hour: {g.Hour}, Day: {g.DayOfWeek}, Count: {g.Count}"));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns: " + ex.Message, ex);
            }
        }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
설명
최소 샘플 수 확인: 모델 학습 전에 최소 샘플 수를 확인하여 데이터가 부족한 경우 오류 메시지를 출력하고 학습을 중지합니다.
에러 메시지 출력 개선: 부족한 데이터로 인해 발생할 수 있는 오류 메시지를 명확히 하여 사용자에게 표시합니다.
UI 업데이트: 학습 데이터와 학습 결과를 UI의 데이터 그리드(DataGrid)에 표시합니다.
이제 최소 샘플 수를 확인하고, 데이터가 부족한 경우 오류 메시지를 표시하도록 수정되었습니다. 이 코드를 사용하면 충분한 데이터가 있는 경우에만 모델을 학습시키고, 학습 데이터와 학습 결과를 UI에 표시할 수 있습