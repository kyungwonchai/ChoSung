using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MinimumFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB
        private const long MaxFolderSize = 8L * 1024 * 1024 * 1024; // 8 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;
        private readonly Logger logger;
        private readonly Action<long, string> updateFolderStatistics;

        public FileCleaner(string logDirectory, MLModelBuilder mlModelBuilder, Dispatcher dispatcher, Logger logger, Action<long, string> updateFolderStatistics)
        {
            this.logDirectory = logDirectory;
            this.mlModelBuilder = mlModelBuilder;
            this.dispatcher = dispatcher;
            this.logger = logger;
            this.updateFolderStatistics = updateFolderStatistics;
        }

        public long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get drive free space: " + ex.Message);
                return 0;
            }
        }

        public List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension, bool forceDelete = false)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                var filesToDelete = files.Where(file => forceDelete || file.CreationTime < DateTime.Now.AddDays(-35)).OrderBy(file => file.CreationTime).ToList();

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(files.Sum(f => f.Length), folderPath);
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get files to delete: " + ex.Message);
                return new List<FileInfo>();
            }
        }

        private IEnumerable<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                logger.LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        public async Task DeleteFilesAsync(List<FileInfo> files, string folderPath, bool forceDelete = false, CancellationToken cancellationToken = default)
        {
            long currentFolderSize = files.Sum(f => f.Length);
            long freeSpace = GetDriveFreeSpace(folderPath.Split('\\')[0] + "\\");

            var startTime = DateTime.Now;

            foreach (var file in files)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    logger.LogRecentActivity("파일 삭제 중지됨.");
                    break;
                }

                if (currentFolderSize <= MaxFolderSize && !forceDelete)
                {
                    logger.LogRecentActivity("현재 폴더 크기가 8GB 이하입니다.");
                    break;
                }

                if (freeSpace > MinimumFreeSpace && !forceDelete)
                {
                    logger.LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 삭제를 하지 않습니다.");
                    break;
                }

                try
                {
                    file.Delete();
                    currentFolderSize -= file.Length;
                    logger.LogDeletionActivity($"파일 삭제됨: {file.FullName}");

                    var elapsed = DateTime.Now - startTime;
                    if (elapsed.TotalMinutes < 3)
                    {
                        await Task.Delay(5000, cancellationToken); // 처음 3분 동안 5초 간격으로 파일 삭제
                    }
                    else
                    {
                        await Task.Delay(100, cancellationToken); // 3분 이후에는 100ms 간격으로 파일 삭제
                    }
                }
                catch (OperationCanceledException)
                {
                    logger.LogRecentActivity("파일 삭제 작업이 취소되었습니다.");
                    break;
                }
                catch (Exception ex)
                {
                    logger.LogError("Failed to delete file: " + ex.Message);
                }
            }

            updateFolderStatistics(currentFolderSize, folderPath);
        }

        public void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(totalSize, folderPath);
                });
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to update folder statistics: " + ex.Message);
            }
        }
    }
}
