아래는 요청하신 버튼을 누르면 DB에서 데이터를 내려받아 DataGrid에 표시하는 예제입니다. CommandLog 테이블에서 데이터를 가져와 버튼 클릭 시 DataGrid에 표시하는 방식으로 구현하겠습니다.

1. CommandQueueViewModel에 DB로부터 데이터를 가져오는 메서드 추가
먼저, **DatabaseHelper**에서 DB로부터 데이터를 가져오는 메서드를 구현한 후, **CommandQueueViewModel**에 이를 연결합니다.

CommandQueueViewModel.cs
csharp
코드 복사
public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> CommandLogEntries { get; set; } = new ObservableCollection<CommandItem>(); // DB에서 가져온 데이터를 저장할 컬렉션

    private readonly DatabaseHelper _dbHelper; // DB 헬퍼 인스턴스

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper(); // DB 헬퍼 인스턴스 초기화
    }

    // DB에서 데이터를 가져오는 메서드
    public async Task LoadCommandLogAsync()
    {
        // DB에서 데이터를 가져옴
        var commandLogs = await _dbHelper.GetCommandLogsAsync();

        // 기존 컬렉션 초기화
        CommandLogEntries.Clear();

        // 가져온 데이터를 ObservableCollection에 추가
        foreach (var log in commandLogs)
        {
            CommandLogEntries.Add(new CommandItem
            {
                CommandText = log.CommandText,
                Status = log.Status,
                RetryCount = log.RetryCount,
                ResponseTime = log.ResponseTime,
                Result = log.Result,
                CommandTime = log.Timestamp.ToString("yyMMdd HH:mm:ss.fff")
            });
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
DatabaseHelper.cs (DB로부터 데이터를 가져오는 메서드 추가)
csharp
코드 복사
public class DatabaseHelper
{
    private readonly string _connectionString = "your_connection_string_here"; // DB 연결 문자열

    // DB에서 CommandLog 테이블의 데이터를 비동기로 가져오는 메서드
    public async Task<List<CommandLogEntry>> GetCommandLogsAsync()
    {
        var commandLogs = new List<CommandLogEntry>();

        using (SqlConnection conn = new SqlConnection(_connectionString))
        {
            await conn.OpenAsync();
            string query = "SELECT CommandText, SentCommand, Status, RetryCount, ResponseTime, Result, Timestamp FROM CommandLog";
            using (SqlCommand cmd = new SqlCommand(query, conn))
            {
                SqlDataReader reader = await cmd.ExecuteReaderAsync();
                while (await reader.ReadAsync())
                {
                    commandLogs.Add(new CommandLogEntry
                    {
                        CommandText = reader["CommandText"].ToString(),
                        Status = reader["Status"].ToString(),
                        RetryCount = Convert.ToInt32(reader["RetryCount"]),
                        ResponseTime = Convert.ToInt32(reader["ResponseTime"]),
                        Result = Convert.ToInt32(reader["Result"]),
                        Timestamp = Convert.ToDateTime(reader["Timestamp"])
                    });
                }
            }
        }

        return commandLogs;
    }
}

public class CommandLogEntry
{
    public string CommandText { get; set; }
    public string Status { get; set; }
    public int RetryCount { get; set; }
    public int ResponseTime { get; set; }
    public int Result { get; set; }
    public DateTime Timestamp { get; set; }
}
2. XAML 코드 (버튼과 DataGrid 배치)
상단에 40px 높이의 버튼을 좌측 100px 너비로 배치합니다.
나머지 영역은 DataGrid로 구성됩니다.
MainWindow.xaml
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- 상단에 버튼 -->
        <Grid.RowDefinitions>
            <RowDefinition Height="40"/> <!-- 버튼의 높이 40 -->
            <RowDefinition Height="*"/> <!-- 나머지는 DataGrid -->
        </Grid.RowDefinitions>

        <!-- 좌측에 너비 100의 버튼 -->
        <Button Content="Load Data" Width="100" Height="30" HorizontalAlignment="Left" VerticalAlignment="Center" Margin="10"
                Click="LoadDataButton_Click" />

        <!-- DataGrid: Remaining 영역 -->
        <DataGrid Grid.Row="1" ItemsSource="{Binding CommandLogEntries}" AutoGenerateColumns="False" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Command Text" Binding="{Binding CommandText}" Width="200"/>
                <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="100"/>
                <DataGridTextColumn Header="Retry Count" Binding="{Binding RetryCount}" Width="100"/>
                <DataGridTextColumn Header="Response Time" Binding="{Binding ResponseTime}" Width="100"/>
                <DataGridTextColumn Header="Result" Binding="{Binding Result}" Width="100"/>
                <DataGridTextColumn Header="Timestamp" Binding="{Binding CommandTime}" Width="150"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
3. 버튼 클릭 이벤트 핸들러 (MainWindow.xaml.cs)
버튼을 클릭하면 DB에서 데이터를 내려받아 DataGrid에 표시하도록 하는 이벤트 핸들러입니다.

csharp
코드 복사
public partial class MainWindow : Window
{
    private CommandQueueViewModel _viewModel;

    public MainWindow()
    {
        InitializeComponent();
        _viewModel = new CommandQueueViewModel();
        this.DataContext = _viewModel; // ViewModel을 DataContext에 설정
    }

    // 버튼 클릭 시 데이터를 로드하는 메서드
    private async void LoadDataButton_Click(object sender, RoutedEventArgs e)
    {
        await _viewModel.LoadCommandLogAsync(); // 데이터를 로드하여 DataGrid에 표시
    }
}
전체 흐름 설명:
DatabaseHelper는 CommandLog 테이블에서 데이터를 가져오는 메서드를 제공합니다.
CommandQueueViewModel에서는 이 데이터를 ObservableCollection인 CommandLogEntries에 저장합니다. 이 컬렉션이 DataGrid에 바인딩되어 있으므로, 컬렉션이 변경되면 자동으로 UI가 갱신됩니다.
MainWindow.xaml에서 상단에 40px 높이의 버튼과 DataGrid를 배치하여 데이터를 표시합니다.
버튼을 클릭하면 DB에서 데이터를 가져와 DataGrid에 표시됩니다.
이 구조는 MVVM 패턴을 따르면서, 데이터베이스와 UI를 연결하여 데이터 바인딩을 구현한 예시입니다.