kay, let's design and build a Locker Management program using WPF, DevExpress 22.2, the MVVM pattern, and targeting MS SQL Server 2014 with a single table approach.

This will be a comprehensive example focusing on the core requirements: displaying data, CRUD operations, easy updates for frequent moves, and filtering, all following MVVM best practices.

Assumptions:

You have DevExpress WPF Controls v22.2 installed.
You have SQL Server 2014 (or a compatible version) accessible.
You are familiar with setting up a basic WPF project in Visual Studio.
We'll use Entity Framework Core (EF Core) for data access, as it integrates well with MVVM and simplifies database operations. It works fine with SQL Server 2014.
1. Database Setup (MS SQL Server)

Execute this SQL script in your SQL Server Management Studio (SSMS) or equivalent tool to create the database and table.

SQL

-- Create a new database (if it doesn't exist)
IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'LockerManagementDB')
BEGIN
    CREATE DATABASE LockerManagementDB;
END
GO

-- Use the new database
USE LockerManagementDB;
GO

-- Drop the table if it already exists (for easy rerunning of the script)
IF OBJECT_ID('dbo.LockerAssignments', 'U') IS NOT NULL
    DROP TABLE dbo.LockerAssignments;
GO

-- Create the main table
CREATE TABLE LockerAssignments (
    Id INT PRIMARY KEY IDENTITY(1,1),             -- Unique ID for each record
    LockerType NVARCHAR(50) NOT NULL,            -- '개인사물함', '락커', '신발장'
    Floor NVARCHAR(10) NOT NULL,                 -- 'B1', '1', '2', '3', '4'
    Zone NVARCHAR(50) NOT NULL,                  -- 'A'~'H', 'B1'~'B4', '기타' etc.
    SpecificLocation NVARCHAR(100) NOT NULL,     -- 수기입 (Manual Input) - Unique identifier for the physical locker
    UserName NVARCHAR(100) NULL,                -- 성명 (수기입) - NULL if vacant
    KnoxId NVARCHAR(100) NULL,                   -- Knox ID (수기입) - NULL if vacant
    SubPart NVARCHAR(50) NULL,                   -- 소파트 ('Main(시생산)', 'MainA'~'Z') - NULL if vacant
    Administrator NVARCHAR(100) NULL,           -- 관리자 ('홍길동A'~'X') - Who manages this record/assignment
    LastUpdated DATETIME2 NOT NULL DEFAULT GETDATE() -- Audit trail: When was it last changed?
);
GO

-- Optional: Add some initial dummy data (e.g., empty lockers)
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'A', 'A-01', 'System', GETDATE()),
('개인사물함', '1', 'A', 'A-02', 'System', GETDATE()),
('락커', 'B1', 'B1', 'R-B1-01', 'System', GETDATE()),
('신발장', '2', '2F', 'S-2F-01', 'System', GETDATE());

-- Add an example assignment
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, UserName, KnoxId, SubPart, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'B', 'B-15', '김철수', 'kimcs', 'MainA', '홍길동A', GETDATE());
GO

-- Add an index for faster lookups, especially if you have many lockers
CREATE INDEX IX_LockerAssignments_Location ON dbo.LockerAssignments (Floor, Zone, SpecificLocation);
CREATE INDEX IX_LockerAssignments_User ON dbo.LockerAssignments (UserName);
GO

PRINT 'Database and Table created successfully.';

2. WPF Project Setup (Visual Studio)

Create a new "WPF App (.NET Framework)" or "WPF Application" project. (Ensure .NET Framework 4.7.2 or later, or .NET 6/7/8 is selected).
Install NuGet Packages:
Microsoft.EntityFrameworkCore.SqlServer
Microsoft.EntityFrameworkCore.Tools (for migrations, though we created the DB manually)
Search for and add the necessary DevExpress WPF packages. At a minimum, you'll likely need:
DevExpress.Wpf.Core
DevExpress.Wpf.Grid (for GridControl)
DevExpress.Wpf.Themes.Office2019Colorful (or your preferred theme)
Create Folders: Organize your project with folders like Models, ViewModels, Views, Data, Infrastructure (or Helpers).
3. Model (Models/LockerAssignment.cs)

This class represents a single row in your LockerAssignments table.

C#

using System;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace LockerManagementApp.Models
{
    [Table("LockerAssignments")] // Maps to the table name
    public class LockerAssignment
    {
        [Key] // Primary Key
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)] // Auto-increment
        public int Id { get; set; }

        [Required(ErrorMessage = "사물함 종류는 필수입니다.")]
        [StringLength(50)]
        public string LockerType { get; set; } = string.Empty; // Initialize to avoid nulls

        [Required(ErrorMessage = "층 정보는 필수입니다.")]
        [StringLength(10)]
        public string Floor { get; set; } = string.Empty;

        [Required(ErrorMessage = "구역 정보는 필수입니다.")]
        [StringLength(50)]
        public string Zone { get; set; } = string.Empty;

        [Required(ErrorMessage = "세부 위치는 필수입니다.")]
        [StringLength(100)]
        public string SpecificLocation { get; set; } = string.Empty; // This should uniquely identify the physical locker

        [StringLength(100)]
        public string? UserName { get; set; } // Nullable

        [StringLength(100)]
        public string? KnoxId { get; set; } // Nullable

        [StringLength(50)]
        public string? SubPart { get; set; } // Nullable

        [StringLength(100)]
        public string? Administrator { get; set; } // Nullable

        public DateTime LastUpdated { get; set; } = DateTime.Now;

        // Optional: Not mapped to DB, useful for display logic if needed
        [NotMapped]
        public bool IsAssigned => !string.IsNullOrWhiteSpace(UserName);

        // Override ToString for better debugging or simple display
        public override string ToString()
        {
            return $"{Floor}-{Zone}-{SpecificLocation}: {(IsAssigned ? UserName : "(비어 있음)")}";
        }
    }
}
4. Data Context (Data/LockerDbContext.cs)

This class uses EF Core to interact with the database.

C#

using LockerManagementApp.Models;
using Microsoft.EntityFrameworkCore;
using System.Configuration; // Need to add reference to System.Configuration

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }

        protected override void OnConfiguring(DbContextOptionsBuilder optionsBuilder)
        {
            if (!optionsBuilder.IsConfigured)
            {
                // Get connection string from App.config
                string connectionString = ConfigurationManager.ConnectionStrings["LockerDbConnection"]?.ConnectionString
                                            ?? "Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;Encrypt=False;"; // Provide a default/fallback

                // Replace "YOUR_SERVER_NAME" with your actual SQL Server instance name (e.g., localhost, SQLEXPRESS, server.domain.com)
                // Use Integrated Security (Trusted_Connection=True) or SQL Server Authentication (User ID=your_user;Password=your_password;)
                // Encrypt=False is used for simplicity here, but consider setting it to True for production environments if SSL is configured on SQL Server.

                optionsBuilder.UseSqlServer(connectionString);
            }
        }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            // Configure unique constraint on the physical locker location if desired
            // This ensures you can't accidentally create two DB entries for the same physical locker.
            // modelBuilder.Entity<LockerAssignment>()
            //    .HasIndex(l => new { l.Floor, l.Zone, l.SpecificLocation })
            //    .IsUnique();

            // Set default value behavior if needed (though handled by SQL DEFAULT constraint)
            // modelBuilder.Entity<LockerAssignment>()
            //     .Property(l => l.LastUpdated)
            //     .HasDefaultValueSql("GETDATE()");

            base.OnModelCreating(modelBuilder);
        }

        // Optional: Override SaveChanges to automatically update LastUpdated timestamp
        public override int SaveChanges()
        {
            UpdateTimestamps();
            return base.SaveChanges();
        }

        public override Task<int> SaveChangesAsync(CancellationToken cancellationToken = default)
        {
            UpdateTimestamps();
            return base.SaveChangesAsync(cancellationToken);
        }

        private void UpdateTimestamps()
        {
            var entries = ChangeTracker
                .Entries()
                .Where(e => e.Entity is LockerAssignment && (
                        e.State == EntityState.Added ||
                        e.State == EntityState.Modified));

            foreach (var entityEntry in entries)
            {
                ((LockerAssignment)entityEntry.Entity).LastUpdated = DateTime.Now;

                // Optionally: Set Administrator here if you have a way to know the current user
                // ((LockerAssignment)entityEntry.Entity).Administrator = GetCurrentAdminUser();
            }
        }
    }
}
Important: Add a connection string to your App.config file:

XML

<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <connectionStrings>
    <add name="LockerDbConnection"
         connectionString="Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;Encrypt=False;"
         providerName="System.Data.SqlClient"/>
  </connectionStrings>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2"/>
  </startup>
</configuration>
5. ViewModel Base and RelayCommand (Infrastructure)

These are standard MVVM helper classes.

(Infrastructure/ViewModelBase.cs)

C#

using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace LockerManagementApp.Infrastructure
{
    public abstract class ViewModelBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler? PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
(Infrastructure/RelayCommand.cs)   

C#

using System;
using System.Windows.Input;

namespace LockerManagementApp.Infrastructure
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object?> _execute;
        private readonly Predicate<object?>? _canExecute;

        public event EventHandler? CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public RelayCommand(Action<object?> execute, Predicate<object?>? canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object? parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object? parameter)
        {
            _execute(parameter);
        }
    }
}
6. Main ViewModel (ViewModels/MainViewModel.cs)

This is the heart of the application logic.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Microsoft.EntityFrameworkCore; // For ToListAsync()
using System.Windows; // For MessageBox

namespace LockerManagementApp.ViewModels
{
    public class MainViewModel : ViewModelBase
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments = new ObservableCollection<LockerAssignment>();
        private LockerAssignment? _selectedAssignment;
        private string _statusBarText = "Ready";
        private string _currentAdmin = "홍길동A"; // Example: Get this from login or config

        public ObservableCollection<LockerAssignment> LockerAssignments
        {
            get => _lockerAssignments;
            set => SetProperty(ref _lockerAssignments, value);
        }

        public LockerAssignment? SelectedAssignment
        {
            get => _selectedAssignment;
            set
            {
                if (SetProperty(ref _selectedAssignment, value))
                {
                    // Raise CanExecuteChanged for commands that depend on selection
                    ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public string StatusBarText
        {
            get => _statusBarText;
            set => SetProperty(ref _statusBarText, value);
        }

        // --- Commands ---
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; } // Command to easily clear user info

        // --- Predefined Lists for ComboBoxes/Lookups (Improvement) ---
        // These could be loaded from DB or config
        public List<string> LockerTypes { get; } = new List<string> { "개인사물함", "락커", "신발장" };
        public List<string> Floors { get; } = new List<string> { "B1", "1", "2", "3", "4" };
        // Zones might be dynamic, but provide some examples
        public List<string> Zones { get; } = new List<string> { "A", "B", "C", "D", "E", "F", "G", "H", "B1", "B2", "B3", "B4", "1F", "2F", "3F", "4F", "기타" };
        public List<string> SubParts { get; } = new List<string> { "Main(시생산)", "MainA", "MainB", "MainC" /* ...add all A-Z */ };
        public List<string> Administrators { get; } = new List<string> { "홍길동A", "홍길동B", "홍길동C" /* ...add all A-X */ };


        public MainViewModel()
        {
            _context = new LockerDbContext();

            LoadDataCommand = new RelayCommand(async _ => await LoadDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker); // Note: Adding requires Save
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);

            // Load data on startup
            _ = LoadDataAsync();
        }

        private async Task LoadDataAsync()
        {
            StatusBarText = "Loading data...";
            try
            {
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor)
                                               .ThenBy(l => l.Zone)
                                               .ThenBy(l => l.SpecificLocation)
                                               .ToListAsync();
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"Loaded {LockerAssignments.Count} records.";
            }
            catch (Exception ex)
            {
                StatusBarText = $"Error loading data: {ex.Message}";
                MessageBox.Show($"Database connection or query failed:\n{ex.Message}\n\nCheck your connection string in App.config and ensure the database server is running.", "Load Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task SaveChangesAsync()
        {
            StatusBarText = "Saving changes...";
            try
            {
                // Basic Validation Example (ensure physical location is unique if adding)
                // More robust validation should be in the model or a validation service
                var duplicates = LockerAssignments
                    .Where(l => _context.Entry(l).State == EntityState.Added || _context.Entry(l).State == EntityState.Modified)
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key);

                if (duplicates.Any())
                {
                     MessageBox.Show($"Cannot save. Duplicate physical locker locations found: {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "Validation Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                     StatusBarText = "Save failed due to duplicate locations.";
                     return; // Prevent saving
                }


                // Assign current admin before saving changes
                var changedEntries = _context.ChangeTracker.Entries<LockerAssignment>()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

                foreach(var entry in changedEntries)
                {
                    entry.Entity.Administrator = _currentAdmin; // Set the admin who made the change
                    // LastUpdated is handled by DbContext override
                }


                int changedCount = await _context.SaveChangesAsync();
                StatusBarText = $"Saved {changedCount} changes successfully.";
                // Optional: Reload data to refresh any calculated fields or defaults from DB
                // await LoadDataAsync();
            }
            catch (DbUpdateException dbEx) // Catch specific DB errors
            {
                 // Check inner exception for constraint violations etc.
                var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                StatusBarText = $"Error saving data: {innerExceptionMessage}";
                MessageBox.Show($"Failed to save changes to the database:\n{innerExceptionMessage}", "Save Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 // Consider reverting changes if save fails completely
                 // await RollbackChangesAsync(); // Implement rollback logic if needed
            }
            catch (Exception ex)
            {
                StatusBarText = $"Error saving data: {ex.Message}";
                MessageBox.Show($"An unexpected error occurred while saving:\n{ex.Message}", "Save Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void AddNewLocker(object? parameter)
        {
            var newAssignment = new LockerAssignment
            {
                // Set default values if appropriate
                LockerType = LockerTypes.FirstOrDefault() ?? "개인사물함",
                Floor = Floors.FirstOrDefault() ?? "1",
                Zone = Zones.FirstOrDefault() ?? "A",
                SpecificLocation = "New-" + Guid.NewGuid().ToString().Substring(0, 4), // Placeholder
                Administrator = _currentAdmin,
                LastUpdated = DateTime.Now // Set initial time
            };
            LockerAssignments.Add(newAssignment);
            _context.LockerAssignments.Add(newAssignment); // Add to context tracking
            SelectedAssignment = newAssignment; // Select the new row for editing
            StatusBarText = "New locker added. Fill details and Save.";
        }

        private async Task DeleteSelectedAsync()
        {
            if (SelectedAssignment == null) return;

            if (MessageBox.Show($"Are you sure you want to delete the record for {SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}?",
                                "Confirm Delete", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "Deleting record...";
                try
                {
                    var assignmentToDelete = SelectedAssignment; // Keep reference
                    _context.LockerAssignments.Remove(assignmentToDelete);
                    int changedCount = await _context.SaveChangesAsync(); // Save deletion immediately

                    // Remove from ObservableCollection only after successful DB delete
                    LockerAssignments.Remove(assignmentToDelete);
                    SelectedAssignment = null; // Deselect
                    StatusBarText = $"Deleted {changedCount} record successfully.";
                }
                 catch (DbUpdateException dbEx) // Catch specific DB errors
                {
                    var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                    StatusBarText = $"Error deleting data: {innerExceptionMessage}";
                    MessageBox.Show($"Failed to delete the record from the database:\n{innerExceptionMessage}", "Delete Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    // Optionally reload data to ensure consistency if delete fails
                     await LoadDataAsync();
                }
                catch (Exception ex)
                {
                    StatusBarText = $"Error deleting data: {ex.Message}";
                     MessageBox.Show($"An unexpected error occurred while deleting:\n{ex.Message}", "Delete Error", MessageBoxButton.OK, MessageBoxImage.Error);
                     // Optionally reload data to ensure consistency if delete fails
                     await LoadDataAsync();
                }
            }
        }

         // --- Easy Move/Clear Feature ---
        private void ClearSelectedAssignment(object? parameter)
        {
             if (SelectedAssignment != null)
            {
                // Clear user-specific fields
                SelectedAssignment.UserName = null;
                SelectedAssignment.KnoxId = null;
                SelectedAssignment.SubPart = null;
                // Administrator might stay or be cleared depending on rules
                // SelectedAssignment.Administrator = null;

                // IMPORTANT: We need to notify the UI that these properties changed!
                // If LockerAssignment implemented INotifyPropertyChanged, it would happen automatically.
                // Since it doesn't, we need a way to refresh the grid row or manually trigger updates.
                // Easiest way with DevExpress GridControl is often to rely on its internal update mechanisms
                // when the underlying data object changes, especially if using standard editing.
                // Alternatively, replace the item in the collection (less efficient).
                // Let's assume GridControl handles the update after modification + Save.

                // Mark the entity as modified in the context
                 _context.Entry(SelectedAssignment).State = EntityState.Modified;
                 SelectedAssignment.Administrator = _currentAdmin; // Track who cleared it
                 SelectedAssignment.LastUpdated = DateTime.Now; // Explicitly set time here too

                StatusBarText = $"Cleared assignment for {SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}. Save changes.";

                 // Optional: Immediately save the clearing action
                 // _ = SaveChangesAsync();
            }
        }

        // Cleanup context when ViewModel is no longer needed (e.g., window closing)
        public void Cleanup()
        {
            _context?.Dispose();
        }
    }
}
7. Main View (Views/MainWindow.xaml)

This uses DevExpress GridControl for powerful data display and editing.

XML

<dx:ThemedWindow
    x:Class="LockerManagementApp.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
    xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
    xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
    xmlns:local="clr-namespace:LockerManagementApp.Views"
    xmlns:viewmodels="clr-namespace:LockerManagementApp.ViewModels"
    xmlns:models="clr-namespace:LockerManagementApp.Models"
    Title="사물함 관리 프로그램 (DevExpress MVVM)" Height="600" Width="1000"
    Loaded="ThemedWindow_Loaded"
    Closing="ThemedWindow_Closing">

    <dx:ThemedWindow.DataContext>
        <viewmodels:MainViewModel/>
    </dx:ThemedWindow.DataContext>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <Border Grid.Row="0" Background="{dx:ThemeResource ThemeBrush}" Padding="5">
             <StackPanel Orientation="Horizontal">
                <Button Content="🔄 Load/Refresh" Margin="3" Command="{Binding LoadDataCommand}" ToolTip="데이터베이스에서 최신 정보를 불러옵니다."/>
                <Button Content="💾 Save Changes" Margin="3" Command="{Binding SaveChangesCommand}" ToolTip="변경 사항을 데이터베이스에 저장합니다."/>
                <Button Content="➕ Add New Locker" Margin="3" Command="{Binding AddNewCommand}" ToolTip="새로운 사물함 정보를 추가합니다 (행 추가 후 편집)."/>
                <Button Content="❌ Delete Selected" Margin="3" Command="{Binding DeleteCommand}" ToolTip="선택된 사물함 정보를 삭제합니다."/>
                 <Button Content="🧹 Clear Assignment" Margin="3,3,15,3" Command="{Binding ClearAssignmentCommand}" ToolTip="선택된 사물함의 사용자 배정 정보를 제거합니다."/>
            </StackPanel>
        </Border>

        <dxg:GridControl Grid.Row="1"
                         ItemsSource="{Binding LockerAssignments}"
                         SelectedItem="{Binding SelectedAssignment, Mode=TwoWay}"
                         AutoGenerateColumns="None"
                         EnableSmartColumnsGeneration="True">

            <dxg:GridControl.View>
                <dxg:TableView AllowPerPixelScrolling="True"
                               ShowTotalSummary="False"
                               ShowGroupPanel="True"  AllowEditing="True"    AllowAddingNewItems="False" AllowDeletingItems="False" NavigationStyle="Cell" ShowAutoFilterRow="True" NewItemRowPosition="None">
                     <dxg:TableView.RowCellMenuCustomizations>
                         <dx:BarButtonItem Content="Clear Assignment"
                                           Command="{Binding View.DataContext.ClearAssignmentCommand}"
                                           Glyph="{dx:DXImage 'Svg/Actions/DeleteList.svg'}"/>
                         <dx:BarButtonItem Content="Delete Row"
                                           Command="{Binding View.DataContext.DeleteCommand}"
                                            Glyph="{dx:DXImage Svg/Actions/Delete.svg}"/>
                     </dxg:TableView.RowCellMenuCustomizations>
                </dxg:TableView>
            </dxg:GridControl.View>

            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="LockerType" Header="종류">
                    <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.LockerTypes, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="False"/> </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                 <dxg:GridColumn FieldName="Floor" Header="층">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Floors, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="False"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>

                <dxg:GridColumn FieldName="Zone" Header="구역">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Zones, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="True"/> </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                <dxg:GridColumn FieldName="SpecificLocation" Header="세부 위치"/>

                 <dxg:GridColumn FieldName="UserName" Header="성명"/>
                <dxg:GridColumn FieldName="KnoxId" Header="Knox ID"/>

                <dxg:GridColumn FieldName="SubPart" Header="소파트">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.SubParts, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                 <dxg:GridColumn FieldName="Administrator" Header="관리자">
                      <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding DataContext.Administrators, RelativeSource={RelativeSource AncestorType={x:Type dx:ThemedWindow}}}"
                                                  IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>

                <dxg:GridColumn FieldName="LastUpdated" Header="최종 수정일" AllowEditing="False">
                     <dxg:GridColumn.EditSettings>
                        <dxe:DateEditSettings MaskType="DateTime" Mask="yyyy-MM-dd HH:mm:ss" MaskUseAsDisplayFormat="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>

                <dxg:GridColumn FieldName="Id" Header="ID" Visible="False" ReadOnly="True"/> </dxg:GridControl.Columns>

            <dxg:GridControl.ViewSettings>
                 <dxg:TableViewSettings ShowSearchPanelMode="Always" />
             </dxg:GridControl.ViewSettings>

        </dxg:GridControl>

        <StatusBar Grid.Row="2" Background="{dx:ThemeResource EditorGroupBox.Background}">
            <StatusBarItem>
                <TextBlock Text="{Binding StatusBarText}" Margin="5,0"/>
            </StatusBarItem>
        </StatusBar>
    </Grid>
</dx:ThemedWindow>
(Views/MainWindow.xaml.cs) - Code-behind should be minimal in MVVM.

C#

using DevExpress.Xpf.Core; // For ThemedWindow and ApplicationThemeHelper
using LockerManagementApp.ViewModels;
using System.Windows;

namespace LockerManagementApp.Views
{
    public partial class MainWindow : ThemedWindow // Use ThemedWindow
    {
        public MainWindow()
        {
            InitializeComponent();
            // Optional: Set a DevExpress Theme
            ApplicationThemeHelper.ApplicationThemeName = Theme.Office2019ColorfulName; // Or another theme
        }

        private MainViewModel? ViewModel => DataContext as MainViewModel;

        // Optional: Load data when the window is loaded
        private void ThemedWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // ViewModel constructor already calls LoadDataAsync, but if you prefer explicit call:
            // ViewModel?.LoadDataCommand.Execute(null);
        }

        // Optional: Clean up resources like DbContext when closing
        private void ThemedWindow_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
             // Ask user to save unsaved changes if necessary (more advanced)
             // ...

            ViewModel?.Cleanup(); // Dispose DbContext
        }
    }
}
8. Application Entry Point (App.xaml / App.xaml.cs)

(App.xaml) - Ensure StartupUri points to your MainWindow.

XML

<Application x:Class="LockerManagementApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:LockerManagementApp"
             StartupUri="Views/MainWindow.xaml"> <Application.Resources>

    </Application.Resources>
</Application>
(App.xaml.cs) - Usually empty for basic apps, but good for global setup/exception handling.

C#

using System.Windows;

namespace LockerManagementApp
{
    /// <summary>
    /// Interaction logic for App.xaml
    /// </summary>
    public partial class App : Application
    {
        // Optional: Global Exception Handling
        // protected override void OnStartup(StartupEventArgs e)
        // {
        //     base.OnStartup(e);
        //     SetupExceptionHandling();
        // }

        // private void SetupExceptionHandling()
        // {
        //     AppDomain.CurrentDomain.UnhandledException += (s, e) =>
        //         LogUnhandledException((Exception)e.ExceptionObject, "AppDomain.CurrentDomain.UnhandledException");

        //     DispatcherUnhandledException += (s, e) =>
        //     {
        //         LogUnhandledException(e.Exception, "Application.Current.DispatcherUnhandledException");
        //         e.Handled = true; // Prevent application crash
        //     };

        //     TaskScheduler.UnobservedTaskException += (s, e) =>
        //     {
        //         LogUnhandledException(e.Exception, "TaskScheduler.UnobservedTaskException");
        //         e.SetObserved(); // Mark as handled
        //     };
        // }

        // private void LogUnhandledException(Exception exception, string source)
        // {
        //      // Log the exception details (to file, event log, etc.)
        //      MessageBox.Show($"An unhandled exception occurred ({source}):\n{exception.Message}", "Application Error", MessageBoxButton.OK, MessageBoxImage.Error);
        //      // Consider more robust logging and potentially shutting down gracefully
        // }
    }
}
How it Addresses Your Requirements:

WPF + DevExpress 22.2: Uses ThemedWindow, GridControl, ComboBoxEditSettings, etc.
Management Items (종류, 층, 구역, 세부위치, 성명, KnoxID, 소파트, 관리자): All are columns in the GridControl bound to the LockerAssignment model. Dropdowns are provided for predefined lists (종류, 층, 구역, 소파트, 관리자).
MVVM Pattern: Clear separation between Model (LockerAssignment), View (MainWindow.xaml), and ViewModel (MainViewModel). Uses INotifyPropertyChanged, ObservableCollection, and ICommand (RelayCommand).
Single MS SQL Table: Uses EF Core (LockerDbContext) to map to the LockerAssignments table.
CRUD Operations:
Create: "Add New Locker" button adds a new row to the grid and context; edit inline and click "Save Changes".
Read: Data is loaded into the grid on startup/refresh.
Update: Edit directly in the grid cells. Click "Save Changes".
Delete: Select a row and click "Delete Selected".
Easy Movement:
Assigning: Find an empty row (UserName is null), fill in UserName, KnoxId, SubPart, Administrator. Click Save.
Moving:
Go to the old locker row, clear UserName, KnoxId, SubPart (or use the "Clear Assignment" button/menu).
Go to the new (empty) locker row, fill in the details.
Click "Save Changes". This saves both modifications.
The "Clear Assignment" command simplifies step 1 of moving.
Flexibility: All relevant fields are editable in the grid.
Search/Filter: DevExpress GridControl provides powerful built-in filtering:
Auto-Filter Row: Type directly below column headers.
Header Filters: Click the filter icon in column headers.
Search Panel: Press Ctrl+F to search across all columns.
Grouping: Drag column headers to the panel above the grid.
Multiple Administrators: The application itself doesn't handle simultaneous user conflicts out-of-the-box. If two admins edit the same record and save, the last one wins by default with EF Core's basic setup. For high concurrency, you'd need to implement optimistic concurrency checking in EF Core. The Administrator field tracks who last saved changes to a record.
To Run This Code:

Create the database using the SQL script.
Create the WPF project in Visual Studio.
Add the NuGet packages.
Create the folders and add the C# and XAML files as shown.