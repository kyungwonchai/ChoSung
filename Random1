네, AgentCoreService.cs 파일 내에서 SetDisplayTimeout (아마도 CommandNames.SetDisplayTimeout을 의미) 또는 SetDisplayTimeoutPayload에 빨간 줄(오류)이 표시된다면, 해당 식별자를 컴파일러가 찾지 못하고 있다는 의미입니다.

이는 주로 다음과 같은 이유로 발생합니다:

using SControl.Common; 지시문 누락: AgentCoreService.cs 파일 상단에 SControl.Common 네임스페이스를 사용하겠다는 선언이 빠졌을 수 있습니다. SetDisplayTimeoutPayload 클래스와 CommandNames 클래스 (내부의 SetDisplayTimeout 상수)는 SControl.Common 네임스페이스 안에 정의되어 있습니다.
SControl.Common 프로젝트 참조 누락: SAgentM.App 프로젝트가 SControl.Common 프로젝트를 올바르게 참조하고 있지 않을 수 있습니다.
SControl.Common 프로젝트 빌드 오류 또는 코드 누락: SControl.Common 프로젝트 자체에 빌드 오류가 있거나, 해당 정의가 실수로 누락/주석 처리되었을 수 있습니다.
해결 단계:

1단계: SControl.Common 프로젝트의 관련 코드 재확인

먼저, SControl.Common 프로젝트에 다음 코드들이 올바르게 정의되어 있는지 다시 한번 확인해주세요. (이전에 제공된 코드입니다.)

SControl.Common/Enums.cs 파일 내용 중 CommandNames 부분:

C#

// SControl.Common/Enums.cs
namespace SControl.Common
{
    // ... 다른 enum 정의들 ...

    public static class CommandNames
    {
        public const string MonitorControl = "MONITOR_CONTROL";
        public const string SetDisplayTimeout = "SET_DISPLAY_TIMEOUT"; // <<--- 이 정의가 있어야 합니다.
    }

    // ... MonitorAction enum 정의 ...
}
SControl.Common/Payloads.cs 파일 내용 중 SetDisplayTimeoutPayload 부분:

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    // ... MonitorControlPayload, GenericResponsePayload 정의 ...

    public class SetDisplayTimeoutPayload // <<--- 이 클래스 정의가 있어야 합니다.
    {
        public int TimeoutMinutes { get; set; }
    }
}
위 정의들이 SControl.Common 프로젝트에 정확히 있는지 확인하시고, SControl.Common 프로젝트를 먼저 오류 없이 빌드해주세요.

2단계: SAgentM.App/Services/AgentCoreService.cs 파일 수정

AgentCoreService.cs 파일 상단에 필요한 using 지시문을 추가하고, 관련 코드를 다시 한번 확인합니다. 이전 응답에서 AgentCoreService.cs 전체 코드를 드렸었는데, 해당 코드에는 이미 using SControl.Common; 이 포함되어 있어야 합니다.

다음은 SetDisplayTimeout 관련 오류를 해결하기 위해 using 지시문과 해당 명령 처리 부분을 포함한 AgentCoreService.cs의 수정된 전체 코드입니다.

수정: SAgentM.App/Services/AgentCoreService.cs (전체 코드, using 지시문 및 관련 코드 확인)
C#

// SAgentM.App/Services/AgentCoreService.cs
using Newtonsoft.Json;
using SControl.Common; // <<--- 중요: 이 using 지시문이 있는지 확인하세요!
using System;
using System.Configuration;
using System.Diagnostics; // Process 클래스 사용을 위해 추가
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SAgentM.App.Services
{
    public interface IAgentCoreService
    {
        void Start();
        void Stop();
        bool IsRunning { get; }
    }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026; 
                _loggingService.UiWarn($"ListenPort 설정이 App.config에 없거나 잘못되어 기본값 {_port} 포트를 사용합니다.");
            }
        }

        public void Start()
        {
            if (_isRunning)
            {
                _loggingService.UiWarn("AgentCoreService가 이미 실행 중입니다.");
                return;
            }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning)
            {
                _loggingService.UiWarn("AgentCoreService가 이미 중지되어 있습니다.");
                return;
            }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5)))
                {
                    _loggingService.UiWarn("리스닝 스레드가 시간 내에 종료되지 않았습니다.");
                }
            }
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try
            {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning)
                {
                    try
                    {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se)
                    {
                        if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted))
                        { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; }
                        _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se);
                        if (!_isRunning) break; Thread.Sleep(100);
                    }
                    catch (InvalidOperationException ioe) when (!_isRunning)
                    { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex)
                    { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally
            {
                if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); }
                _loggingService.UiInfo("ListenLoop 종료됨.");
            }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try
            {
                _loggingService.UiDebug($"[{clientIpInfo}] 클라이언트 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested)
                    {
                        string requestJson = null;
                        try
                        {
                            var readTask = reader.ReadLineAsync();
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask)
                            {
                                if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 후 취소 감지."); token.ThrowIfCancellationRequested(); }
                                requestJson = await readTask;
                            }
                            else { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 대기 중 취소 감지."); token.ThrowIfCancellationRequested(); }

                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 연결 종료 (스트림 끝)."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}");

                            CommandPacket requestPacket = null;
                            try
                            {
                                requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson);
                                receivedRequestPacket = requestPacket;
                            }
                            catch (JsonException jsonEx)
                            {
                                _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx);
                                await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON format: {jsonEx.Message}"))); continue;
                            }

                            if (requestPacket != null)
                            {
                                _loggingService.UiInfo($"[{clientIpInfo}] 명령 처리 시작: ID={requestPacket.PacketId}, Cmd={requestPacket.CommandName}");
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null)
                                {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] 응답 전송 전 취소 감지."); token.ThrowIfCancellationRequested(); }
                                    await writer.WriteLineAsync(responseJson);
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답 전송: {responseJson}");
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] 네트워크 IO 오류 (연결 끊김 예상): {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체 이미 해제됨 (연결 끊김 예상): {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 작업 취소됨."); break; }
                        catch (Exception ex)
                        {
                            _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 예기치 않은 오류.", ex);
                            if (client.Connected && stream.CanWrite)
                            { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}
                        }
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 자체가 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부에서 심각한 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request != null && request.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl)
            {
                MonitorControlPayload originalPayload = null;
                try { originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch { /* 무시 */ }
                if (originalPayload != null && originalPayload.Action == MonitorAction.Off)
                {
                    bool earlyConfirmWasSuccess = false;
                    if (response != null && !string.IsNullOrEmpty(response.PayloadJson))
                    { try { var genericRespPayload = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if (genericRespPayload != null) earlyConfirmWasSuccess = genericRespPayload.Success; } catch {/* 무시 */} }
                    if(earlyConfirmWasSuccess)
                    {
                        _loggingService.UiInfo($"[{clientIp}] 조기 확인 응답 전송 완료. 실제 모니터 끄기 (백그라운드). ID: {request.PacketId}");
                        Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료 (백그라운드). ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); 
                    } else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패 또는 페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiDebug($"[{clientIp}] 명령 처리 시작: {requestPacket.CommandName}, ID: {requestPacket.PacketId}");
            try
            {
                if (token.IsCancellationRequested) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 시작 전 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); token.ThrowIfCancellationRequested(); }
                switch (requestPacket.Instruction)
                {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token);
                    default: _loggingService.UiWarn($"[{clientIp}] 알 수 없는 Instruction: {requestPacket.Instruction}, Packet ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 중 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, "Operation was canceled during command processing."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 명령 처리 중 오류: {requestPacket.CommandName}, ID: {requestPacket.PacketId}", ex); return CreateErrorResponse(requestPacket, $"Error processing command '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 직접 실행 명령: {requestPacket.CommandName}");
            bool success = false; string message = "Command execution failed or not implemented."; CommandPacket responsePacketToReturn = null;
            try
            {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName)
                {
                    case CommandNames.MonitorControl:
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "MonitorControl: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        MonitorControlPayload monitorPayload = null;
                        try { monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"MonitorControl: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (monitorPayload == null) { message = "MonitorControl: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        _loggingService.UiInfo($"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");
                        if (monitorPayload.Action == MonitorAction.Off)
                        { success = true; message = $"Monitor Off acknowledged. Will turn off shortly. Early confirm sent."; _loggingService.UiInfo($"[{clientIp}] {message} (ID: {requestPacket.PacketId})"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        else { LocalDeviceControl.SetMonitorState(monitorPayload.Action); success = true; message = $"Monitor state set to {monitorPayload.Action}."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        break;
                    
                    case CommandNames.SetDisplayTimeout: // <<--- SetDisplayTimeout 명령 처리 부분
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "SetDisplayTimeout: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        SetDisplayTimeoutPayload timeoutPayload = null; // <<--- SetDisplayTimeoutPayload 사용
                        try { timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"SetDisplayTimeout: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (timeoutPayload == null) { message = "SetDisplayTimeout: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutPayload.TimeoutMinutes}분");
                        try
                        {
                            string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
                            RunPowerCfgCommand($"/CHANGE DISPLAYTIMEOUTAC {timeoutPayload.TimeoutMinutes}", out outputAc, out errorAc, out exitCodeAc);
                            RunPowerCfgCommand($"/CHANGE DISPLAYTIMEOUTDC {timeoutPayload.TimeoutMinutes}", out outputDc, out errorDc, out exitCodeDc);
                            if (exitCodeAc == 0 && exitCodeDc == 0) { success = true; message = $"Display timeout set to {timeoutPayload.TimeoutMinutes} min for AC/DC."; _loggingService.UiInfo($"[{clientIp}] {message}"); }
                            else { success = false; message = $"Failed to set display timeout. AC Exit: {exitCodeAc}, DC Exit: {exitCodeDc}."; if (!string.IsNullOrEmpty(errorAc)) message += $"\nAC Err: {errorAc.Trim()}"; if (!string.IsNullOrEmpty(errorDc)) message += $"\nDC Err: {errorDc.Trim()}"; _loggingService.UiError($"[{clientIp}] {message}"); }
                        } catch (Exception ex) { success = false; message = $"Error executing powercfg: {ex.Message}"; _loggingService.UiError($"[{clientIp}] {message}", ex); }
                        responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
                        break;
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break;
                }
            }
            catch (OperationCanceledException) { message = $"Direct command {requestPacket.CommandName} execution canceled."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            catch (Exception ex) { message = $"Error executing direct command {requestPacket.CommandName}: {ex.Message}"; _loggingService.UiError($"[{clientIp}] {message}", ex); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            return responsePacketToReturn;
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = string.Empty; error = string.Empty; exitCode = -1;
            try
            {
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") { Arguments = arguments, UseShellExecute = false, RedirectStandardOutput = true, RedirectStandardError = true, CreateNoWindow = true, Verb = "runas" };
                using (Process process = Process.Start(startInfo))
                {
                    if (process == null) { error = "Failed to start powercfg.exe."; _loggingService.UiError(error); return; }
                    output = process.StandardOutput.ReadToEnd(); error = process.StandardError.ReadToEnd(); process.WaitForExit(5000); 
                    if (process.HasExited) { exitCode = process.ExitCode; } else { process.Kill(); error += "\npowercfg.exe timeout."; _loggingService.UiWarn(error); }
                }
            } catch (Exception ex) { error = $"powercfg.exe exception: {ex.Message}"; _loggingService.UiError(error, ex); exitCode = -2; }
        }

        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이 명령: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue) { return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP or Port missing."); }
            var packetForFinalTarget = new CommandPacket { Instruction = CommandInstruction.DirectExecute, CommandName = originalRelayRequest.CommandName, PayloadJson = originalRelayRequest.PayloadJson, ResponseAddress = originalRelayRequest.ResponseAddress, ResponsePort = originalRelayRequest.ResponsePort, };
            string relayStatusMessage = $"Relay: {packetForFinalTarget.CommandName} to {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}.";
            bool relaySuccess = false; CommandPacket responseFromFinalTarget = null;
            try
            {
                token.ThrowIfCancellationRequested();
                using (var targetClient = new TcpClient())
                {
                    var connectTask = targetClient.ConnectAsync(originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand.Value);
                    if (await Task.WhenAny(connectTask, Task.Delay(TimeSpan.FromSeconds(5), token)) != connectTask || token.IsCancellationRequested) { token.ThrowIfCancellationRequested(); targetClient.Close(); throw new TimeoutException("Connection to relay target timed out."); }
                    await connectTask; _loggingService.UiDebug($"[{clientIp}] 릴레이 대상 ({originalRelayRequest.FinalTargetIpForRelayedCommand}) 연결 성공.");
                    using (NetworkStream s = targetClient.GetStream()) using (StreamWriter w = new StreamWriter(s, Encoding.UTF8){AutoFlush=true}) using (StreamReader r = new StreamReader(s, Encoding.UTF8)){
                        string jsonToRelay = JsonConvert.SerializeObject(packetForFinalTarget); if(token.IsCancellationRequested) token.ThrowIfCancellationRequested(); await w.WriteLineAsync(jsonToRelay); _loggingService.UiDebug($"[{clientIp}] 릴레이 데이터 전송: {jsonToRelay}");
                        var targetResponseTask = r.ReadLineAsync();
                        if (await Task.WhenAny(targetResponseTask, Task.Delay(TimeSpan.FromSeconds(10), token)) == targetResponseTask && !token.IsCancellationRequested){
                            string targetJson = await targetResponseTask; if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                            if (!string.IsNullOrEmpty(targetJson)){ _loggingService.UiInfo($"[{clientIp}] 릴레이 대상 응답: {targetJson}"); responseFromFinalTarget = JsonConvert.DeserializeObject<CommandPacket>(targetJson); relaySuccess = true; }
                            else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 빈 응답."); relayStatusMessage = "Relay sent, but empty response from final target."; }
                        } else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 응답 시간 초과/취소."); relayStatusMessage = "Relay sent, but no response or timed out/canceled."; }
                    }
                }
            }
            catch (OperationCanceledException) { relayStatusMessage = $"Relay of {originalRelayRequest.CommandName} canceled."; _loggingService.UiInfo($"[{clientIp}] {relayStatusMessage}"); }
            catch (TimeoutException tex) { relayStatusMessage = $"Relay failed: Timeout - {tex.Message}"; _loggingService.UiWarn($"[{clientIp}] {relayStatusMessage}"); }
            catch (SocketException se) { relayStatusMessage = $"Relay failed: Socket error - {se.Message} (Code: {se.SocketErrorCode})"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", se); }
            catch (Exception ex) { relayStatusMessage = $"Relay failed: Unexpected error - {ex.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", ex); }
            return responseFromFinalTarget ?? CreateExecutionResponse(originalRelayRequest, relaySuccess, relayStatusMessage);
        }

        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null)
        {
            return new CommandPacket { PacketId = req.PacketId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{req.CommandName}_Response", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }), ResponseAddress = req.ResponseAddress, ResponsePort = req.ResponsePort };
        }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            _loggingService.UiError($"Error response for Packet ID {pId} (Cmd: {cmdName}): {errorMsg}");
            return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_ErrorResponse", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort };
        }
    }
}
확인 및 조치 사항:

using SControl.Common; 확인: 위 코드 상단에 using SControl.Common; 지시문이 포함되어 있는지 다시 한번 확인해주십시오. 이 지시문이 있어야 CommandNames.SetDisplayTimeout 상수와 SetDisplayTimeoutPayload 클래스를 정상적으로 인식할 수 있습니다.
System.Diagnostics 참조: Process 클래스를 사용하기 위해 using System.Diagnostics; 지시문도 추가했습니다.
Newtonsoft.Json 참조: JsonConvert를 사용하기 위해 using Newtonsoft.Json; 지시문이 필요합니다. (이미 사용 중이실 것으로 예상됩니다.)
SControl.Common 프로젝트 빌드: SAgentM.App 프로젝트를 빌드하기 전에, SControl.Common 프로젝트가 오류 없이 성공적으로 빌드되었는지 확인하십시오.
프로젝트 참조 확인: Visual Studio의 솔루션 탐색기에서 SAgentM.App 프로젝트 아래의 "참조" 항목을 확장하여, SControl.Common이 정상적으로 참조 목록에 포함되어 있는지 확인합니다. 만약 없다면, 마우스 우클릭 후 "참조 추가"를 통해 SControl.Common 프로젝트를 추가해야 합니다.
위 사항들을 확인하고 코드를 적용하시면 SetDisplayTimeout 및 SetDisplayTimeoutPayload 관련 오류가 해결될 것입니다.

문제가 계속 발생하면, Visual Studio의 "오류 목록" 창에 표시되는 정확한 오류 메시지 전체를 알려주시면 추가적인 도움을 드릴 수 있습니다.

