해했습니다. **작업 엔트리(PO_NO, MAG_NO 등)**와 해당 엔트리에 대한 함수들이 얼마나 쌓여 있는지를 별도의 DataGrid에 표시하고 싶다는 말씀이시군요. 이 기능을 구현하려면 TaskQueue에서 각 작업의 엔트리 정보를 유지하고, 현재 쌓여 있는 함수들을 DataGrid에 표시하는 방식을 사용해야 합니다.

요구 사항:
**파일이 캐치되었을 때 작업 엔트리(PO_NO, MAG_NO 등)**가 생성되고, 그 엔트리에 따른 함수 리스트가 쌓여야 한다.
함수가 얼마나 쌓였는지를 별도의 DataGrid에 PO_NO, MAG_NO와 함께 표시해야 한다.
DataGrid는 실시간으로 작업의 상태를 반영하며, 각 작업이 몇 개의 함수로 구성되어 있고, **각 함수의 상태(대기, 실행 중, 완료)**를 보여줄 수 있어야 한다.
구현 방법:
TaskQueue에서 작업 엔트리와 각 작업의 함수들을 ObservableCollection으로 관리하여 DataGrid에 실시간 바인딩.
**각 작업(TaskItem)**이 PO_NO, MAG_NO, 함수 리스트를 포함하고, 함수들의 상태를 실시간으로 반영.
MainViewModel에서 별도의 DataGrid를 추가하여, 작업 엔트리의 함수 상태를 표시.
TaskItem 클래스 (작업 엔트리)
csharp
코드 복사
using System.Collections.ObjectModel;

public class TaskItem
{
    public string PO_NO { get; set; }       // PO_NO 정보
    public string MAG_NO { get; set; }      // MAG_NO 정보
    public string Status { get; set; }      // 엔트리 전체 상태 (Pending, Running, Completed)

    // 각 작업 엔트리에 따른 함수 리스트 (대기, 실행, 완료 상태)
    public ObservableCollection<FunctionItem> Functions { get; set; }

    public TaskItem()
    {
        Functions = new ObservableCollection<FunctionItem>();
    }
}

/// <summary>
/// 각 작업 엔트리 내에서 함수별 상태를 관리하는 클래스
/// </summary>
public class FunctionItem
{
    public string Name { get; set; }    // 함수 이름 (Task A, Task B 등)
    public string Status { get; set; }  // 함수 상태 (Pending, Running, Completed)
}
TaskQueue.cs (수정된 TaskQueue)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Threading;

public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();

    // TaskItem 목록 (작업 엔트리들이 쌓여 있는 리스트)
    public ObservableCollection<TaskItem> TaskEntries { get; private set; }

    private bool _isRunning = false;
    private bool _isPaused = false;

    private Dispatcher _dispatcher;

    public TaskQueue()
    {
        TaskEntries = new ObservableCollection<TaskItem>();
        _dispatcher = Dispatcher.CurrentDispatcher;
    }

    /// <summary>
    /// 새로운 작업 엔트리를 추가하고, 각 엔트리에 해당하는 함수 리스트를 초기화.
    /// PO_NO, MAG_NO 정보를 함께 표시.
    /// </summary>
    public void EnqueueTask(string po_no, string mag_no, int sequenceFlag)
    {
        // 새로운 TaskItem 생성
        var taskItem = new TaskItem
        {
            PO_NO = po_no,
            MAG_NO = mag_no,
            Status = "Pending"
        };

        // 시퀀스 플래그에 따른 함수 목록 초기화
        switch (sequenceFlag)
        {
            case 1:
                taskItem.Functions.Add(new FunctionItem { Name = "Task A", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task B", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task C", Status = "Pending" });
                break;
            case 2:
                taskItem.Functions.Add(new FunctionItem { Name = "Task C", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task B", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task D", Status = "Pending" });
                break;
            case 3:
                taskItem.Functions.Add(new FunctionItem { Name = "Task A", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task B", Status = "Pending" });
                taskItem.Functions.Add(new FunctionItem { Name = "Task E", Status = "Pending" });
                break;
        }

        // TaskEntries 목록에 새 엔트리 추가
        _dispatcher.Invoke(() =>
        {
            TaskEntries.Add(taskItem);
        });

        // 함수 실행
        RunNextTask(taskItem);
    }

    /// <summary>
    /// 작업 엔트리 내의 함수들을 순차적으로 실행.
    /// </summary>
    private async void RunNextTask(TaskItem taskItem)
    {
        foreach (var function in taskItem.Functions)
        {
            if (_isPaused)
            {
                return; // 일시정지 상태일 때는 작업 실행 중지
            }

            // 함수 상태를 "Running"으로 변경
            _dispatcher.Invoke(() =>
            {
                function.Status = "Running";
            });

            await Task.Delay(1000); // 각 함수가 1초씩 실행된다고 가정

            // 함수 상태를 "Completed"로 변경
            _dispatcher.Invoke(() =>
            {
                function.Status = "Completed";
            });
        }

        // 모든 함수가 완료되었으므로 엔트리 상태를 "Completed"로 변경
        _dispatcher.Invoke(() =>
        {
            taskItem.Status = "Completed";
        });
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;

            // 대기 중이던 작업을 다시 시작
            foreach (var taskItem in TaskEntries)
            {
                if (taskItem.Status == "Pending")
                {
                    RunNextTask(taskItem);
                }
            }
        }
    }
}
MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection (PO_NO, MAG_NO, 함수 리스트 포함)
    public ObservableCollection<TaskItem> TaskList { get; set; }

    private TaskQueue _taskQueue;

    public ICommand PauseAllCommand { get; }
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        _taskQueue = new TaskQueue();
        TaskList = _taskQueue.TaskEntries;

        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);

        // 테스트용 작업 추가 (PO_NO, MAG_NO, 시퀀스 플래그)
        _taskQueue.EnqueueTask("PO12345", "MAG001", 1);
        _taskQueue.EnqueueTask("PO67890", "MAG002", 2);
        _taskQueue.EnqueueTask("PO54321", "MAG003", 3);
    }

    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
XAML (DataGrid 구현)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Task Queue Example" Height="400" Width="800">
    <Grid>
        <!-- DataGrid: TaskList를 바인딩하여 PO_NO, MAG_NO, 함수 상태를 표시 -->
        <DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- PO_NO -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*" />

                <!-- MAG_NO -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />

                <!-- 전체 상태 -->
                <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="*" />

                <!-- 함수 리스트를 DataGridTemplateColumn으로 추가 -->
                <DataGridTemplateColumn Header="Functions">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding Functions}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <StackPanel Orientation="Horizontal">
                                            <!-- 함수 이름 -->
                                            <TextBlock Text="{Binding Name}" Margin="5,0" />
                                            <!-- 함수 상태 -->
                                            <TextBlock Text="{Binding Status}" Margin="5,0" />
                                        </StackPanel>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>

        <!-- 일시정지 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Margin="10"/>
        
        <!-- 재개 버튼 -->
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Margin="10"/>
    </Grid>
</Window>
설명:
TaskItem은 PO_NO, MAG_NO, **상태(Status)**와 함께 **함수 리스트(FunctionItem)**를 관리합니다.
DataGrid는 각 TaskItem에 대한 PO_NO, MAG_NO, 상태, 그리고 함수 리스트를 표시.
함수 목록은 ItemsControl을 사용해 각 함수 이름과 상태를 보여줍니다.
각 작업이 추가될 때, 시퀀스 플래그에 맞춰 해당 함수 목록을 추가하고, 상태를 관리합니다.
Pause/Resume 명령어를 통해 작업을 일시정지하거나 재개할 수 있습니다.
이렇게 구현하면, 각 PO_NO 및 MAG_NO 작업 내에서 어떤 함수가 실행 중인지와 **함수 상태(대기, 실행 중, 완료)**를 별도의 DataGrid에서 실시간으로 확인할 수 있습니다.

혹시 추가로 필요한 기능이나 더 궁금한 점이 있으면 언제든지 말씀해 주세요!