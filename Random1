이제 진짜 정확하게 이해했고, 그걸 기준으로 완벽한 MSSQL 2014 쿼리를 다시 설계해줄게.

[요구사항 최종 정리]
1. 테이블 구조 (ExcelData)
주요 컬럼:

line1, model1, type1, ecn1, edition1, time1 → 고유 키 + 시간

ACT2_1 ~ ACT2_8 (8개 float)

ACT2BEST_1 ~ ACT2BEST_8 (8개 float)

2. 목적
최근 5시간 데이터만 사용 (time1 기준)

각 고유 Key (line1, model1, type1, ecn1, edition1) + time1 단위로:

ACT2_1~8, ACT2BEST_1~8 각각에 대해

0 초과만 사용

1사분위수(Q1) ~ 3사분위수(Q3) 범위만 유지 (이상치 제거)

그 안에서 최대값만 사용

그런 시간별 최대값 2개에서:

두 값 중 더 작은 값을 NeckCT 라고 정의

고유 Key 조합별로 NeckCT 가 가장 작았던 시간만 최종 1건으로 선택해서 조회

[최종 결과 컬럼]
| line1 | model1 | type1 | ecn1 | edition1 | time1 | Max_ACT2 | Max_ACT2BEST | NeckCT |

[MSSQL 2014 전체 쿼리 (주석 포함)]
sql
코드 복사
-- 1. 최근 5시간 이내 원본 데이터 필터링
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- 2. 16개 컬럼을 행(Row)으로 변환 (ACT2/ACT2BEST 구분 위해 ColName 사용)
Unpivoted AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2_1, ACT2_2, ACT2_3, ACT2_4, ACT2_5, ACT2_6, ACT2_7, ACT2_8,
            ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
            ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
        )
    ) AS u
    WHERE Value > 0
),

-- 3. 각 ColName별 Q1, Q3 계산 → 이상치 범위 추출
WithQuantiles AS (
    SELECT
        ColName,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3,
        line1, model1, type1, ecn1, edition1, time1, Value
    FROM Unpivoted
),

-- 4. 이상치 제거 (Q1~Q3 범위만 유지)
Filtered AS (
    SELECT *
    FROM WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

-- 5. 그룹 분류: ACT2 또는 ACT2BEST
WithGroup AS (
    SELECT *,
        CASE 
            WHEN ColName LIKE 'ACT2BEST[_]%' THEN 'ACT2BEST'
            WHEN ColName LIKE 'ACT2[_]%' THEN 'ACT2'
        END AS GroupType
    FROM Filtered
),

-- 6. 시간대별 최대값 계산 (ACT2 / ACT2BEST 각각)
PerTimeMax AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(CASE WHEN GroupType = 'ACT2' THEN Value END) AS Max_ACT2,
        MAX(CASE WHEN GroupType = 'ACT2BEST' THEN Value END) AS Max_ACT2BEST
    FROM WithGroup
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- 7. 두 그룹 최대값 중 작은 값을 NeckCT 로 지정
WithNeck AS (
    SELECT *,
        CASE 
            WHEN Max_ACT2 IS NOT NULL AND Max_ACT2BEST IS NOT NULL THEN
                CASE WHEN Max_ACT2 < Max_ACT2BEST THEN Max_ACT2 ELSE Max_ACT2BEST END
        END AS NeckCT
    FROM PerTimeMax
),

-- 8. 각 Key 조합별로 NeckCT 가 가장 낮은 시간 1건만 남기기
Ranked AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY line1, model1, type1, ecn1, edition1
            ORDER BY NeckCT ASC
        ) AS RN
    FROM WithNeck
    WHERE Max_ACT2 IS NOT NULL AND Max_ACT2BEST IS NOT NULL
)

-- 9. 최종 결과 출력
SELECT
    line1, model1, type1, ecn1, edition1, time1,
    Max_ACT2, Max_ACT2BEST, NeckCT
FROM Ranked
WHERE RN = 1
ORDER BY line1, model1, type1, ecn1, edition1;
설명 요약
Unpivot → 16개 CT 컬럼을 세로로 펼침

PERCENTILE_CONT → 컬럼별 1사분위, 3사분위 계산

Q1~Q3 필터링 → 이상치 제거

GroupType 으로 ACT2 vs ACT2BEST 구분

시간별 최대값 추출

NeckCT = 두 그룹 중 더 작은 값

각 Key 조합별 NeckCT 최소 time1 1개만 추출
