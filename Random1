주어진 조건에 맞게 시간대 분류를 정확히 하기 위해 새로 작성한 쿼리를 제공합니다.

시간대 분류 조건:

21시: 21:00 ~ 22:20
22시: 22:30 ~ 23:20
23시: 23:30 ~ 00:20
00시: 00:30 ~ 01:20
05시: 05:30 ~ 06:50
나머지 시간은 그대로 유지
정확한 쿼리
sql
코드 복사
WITH view1 AS (
    SELECT 
        Line,
        DATEADD(MINUTE, -10, datev) AS datev1,
        pickupcnt
    FROM table_lossdata
)
SELECT 
    Line,
    pickupcnt,
    datev1,
    CONVERT(VARCHAR(13), datev1, 120) AS 시간,
    CASE
        -- 21시 조건: 21:00 ~ 22:20
        WHEN (DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) >= 0)
          OR (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) <= 20) THEN '21'
        -- 22시 조건: 22:30 ~ 23:20
        WHEN (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) <= 20) THEN '22'
        -- 23시 조건: 23:30 ~ 00:20
        WHEN (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) <= 20) THEN '23'
        -- 00시 조건: 00:30 ~ 01:20
        WHEN (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) <= 20) THEN '00'
        -- 05시 조건: 05:30 ~ 06:50
        WHEN (DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 6 AND DATEPART(MINUTE, datev1) <= 50) THEN '05'
        -- 나머지 시간은 기본 HOUR 반환
        ELSE RIGHT('0' + CONVERT(VARCHAR, DATEPART(HOUR, datev1)), 2)
    END AS 분류시간
FROM view1
ORDER BY datev1;
설명
view1 생성:

datev에서 10분을 뺀 datev1 생성.
기준 데이터를 정리.
CASE 조건 분류:

시간대 분류:
21:00 ~ 22:20은 21로.
22:30 ~ 23:20은 22로.
23:30 ~ 00:20은 23로.
00:30 ~ 01:20은 00로.
05:30 ~ 06:50은 05로.
나머지는 기본적으로 HOUR 값 그대로 반환.
결과 정렬:

datev1 기준 오름차순 정렬.
예시 결과
Line	pickupcnt	datev1	시간	분류시간
A	10	2025-01-20 21:05:00	2025-01-20 21	21
A	20	2025-01-20 22:35:00	2025-01-20 22	22
A	30	2025-01-20 23:45:00	2025-01-20 23	23
A	40	2025-01-20 00:45:00	2025-01-21 00	00