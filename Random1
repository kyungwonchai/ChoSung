네, 알겠습니다. Flask 웹 애플리케이션의 IP 기반 인증 및 권한 부여 로직을 담당하는 app/auth.py 파일의 최종 전체 코드를 한국어 설명과 함께 다시 제공해 드리겠습니다.

이 파일은 다음 주요 기능들을 포함합니다:

get_current_user_role() 함수: 현재 접속한 사용자의 IP 주소를 기반으로 'admin'(관리자), 'user'(허용된 사용자), 또는 'guest'(그 외) 역할을 결정합니다.
ip_auth_required() 데코레이터: 특정 역할(예: 'admin')이 필요한 웹 페이지(라우트)에 접근을 제한합니다. 권한이 없는 경우 403 Forbidden 오류를 발생시킵니다.
inject_user_info_to_templates() 컨텍스트 프로세서: 모든 HTML 템플릿에서 현재 접속한 사용자의 IP(current_user_ip)와 역할(current_user_role) 정보를 쉽게 사용할 수 있도록 해줍니다.
최종: app/auth.py (전체 코드)
Python

# scontrol_flask_web/app/auth.py
from functools import wraps
from flask import request, current_app, abort, g # render_template는 현재 직접 사용하지 않으므로 제거 가능
from .models import AdminIP, AllowedUserIP # 데이터베이스 모델 임포트

def get_current_user_role():
    """
    현재 요청 컨텍스트(g)에 사용자 IP와 역할 정보가 이미 있다면 그것을 사용하고,
    없다면 요청으로부터 사용자 IP를 확인하여 DB 조회 후 역할을 결정하고 g에 저장합니다.
    역할은 'admin', 'user', 'guest' 중 하나입니다.
    """
    # 현재 요청(g) 내에 역할 정보가 이미 캐시되어 있는지 확인
    if hasattr(g, 'current_user_role'):
        return g.current_user_role

    user_ip = None
    # 웹 서버 앞단에 프록시(예: Nginx)가 있는 경우 X-Forwarded-For 헤더를 통해 실제 클라이언트 IP를 가져옵니다.
    # 이 헤더는 신뢰할 수 있는 프록시에 의해서만 설정되어야 합니다.
    if request.headers.getlist("X-Forwarded-For"):
        # X-Forwarded-For 헤더는 콤마로 구분된 여러 IP를 포함할 수 있으므로, 첫 번째 IP를 사용합니다.
        user_ip = request.headers.getlist("X-Forwarded-For")[0].split(',')[0].strip()
    else:
        # 직접 접속 환경에서는 remote_addr을 사용합니다.
        user_ip = request.remote_addr
    
    # 요청 컨텍스트(g)에 사용자 IP와 기본 역할(guest) 저장
    g.user_ip = user_ip
    g.current_user_role = 'guest' # 기본값

    if not user_ip: # IP 주소를 얻지 못한 경우 (매우 드문 경우)
        current_app.logger.warning("사용자 IP 주소를 확인할 수 없습니다.")
        return g.current_user_role

    # 1. 관리자 IP 목록(DB)에서 확인
    admin_entry = AdminIP.query.filter_by(ip_address=user_ip).first()
    if admin_entry:
        g.current_user_role = 'admin'
        return g.current_user_role

    # 2. 허용된 사용자 IP 목록(DB)에서 확인
    allowed_user_entry = AllowedUserIP.query.filter_by(ip_address=user_ip).first()
    if allowed_user_entry:
        g.current_user_role = 'user'
        return g.current_user_role
        
    # 어느 목록에도 없으면 'guest' 역할 유지
    return g.current_user_role


def ip_auth_required(role_required=None):
    """
    IP 주소 기반 접근 제어 데코레이터입니다.
    뷰 함수에 적용하여 특정 역할의 사용자만 접근할 수 있도록 제한합니다.

    :param role_required: 필요한 최소 역할 ('admin', 'user'). 
                          None이면 'admin' 또는 'user' 역할 중 하나이기만 하면 통과.
    """
    def decorator(f):
        @wraps(f) # 원래 함수의 메타데이터(이름 등)를 유지하기 위해 사용
        def decorated_function(*args, **kwargs):
            user_role = get_current_user_role() # 현재 사용자의 역할 가져오기
            
            # 역할에 따른 접근 제어 로직
            if role_required == 'admin' and user_role != 'admin':
                current_app.logger.warning(
                    f"접근 거부 (관리자 권한 필요): IP {g.user_ip} -> {request.path}"
                )
                abort(403) # 403 Forbidden 오류 발생
            elif role_required == 'user' and user_role not in ['admin', 'user']:
                current_app.logger.warning(
                    f"접근 거부 (사용자 권한 필요): IP {g.user_ip} -> {request.path}"
                )
                abort(403)
            elif role_required is None and user_role not in ['admin', 'user']: # 단순히 로그인(IP 허용) 여부만 확인
                current_app.logger.warning(
                    f"접근 거부 (허용된 IP 아님): IP {g.user_ip} -> {request.path}"
                )
                abort(403)
            
            # 모든 권한 검사를 통과하면 원래 뷰 함수 실행
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def inject_user_info_to_templates():
    """
    모든 Jinja2 템플릿에서 현재 사용자의 IP 주소와 역할을 사용할 수 있도록 
    컨텍스트 변수를 주입하는 컨텍스트 프로세서입니다.
    이 함수는 app/__init__.py의 create_app 함수 내에 app.context_processor로 등록되어야 합니다.
    """
    # get_current_user_role() 호출 시 g.user_ip와 g.current_user_role이 설정됨
    # 이 함수는 각 요청에 대해 템플릿이 렌더링되기 직전에 호출됩니다.
    current_role = get_current_user_role() 
    return dict(
        current_user_ip=getattr(g, 'user_ip', 'IP 확인 불가'), 
        current_user_role=current_role
    )

auth.py 주요 내용 설명:

get_current_user_role() 함수:
현재 요청을 보낸 클라이언트의 IP 주소를 확인합니다 (X-Forwarded-For 헤더 우선 고려, 없으면 request.remote_addr).
확인된 IP 주소를 admin_ips 테이블과 allowed_user_ips 테이블에서 순서대로 조회합니다.
조회 결과에 따라 사용자의 역할을 'admin', 'user', 또는 'guest'로 결정하여 Flask의 g 객체 (요청 간 데이터를 저장하는 임시 객체)에 g.user_ip와 g.current_user_role로 저장하고, 역할을 반환합니다. g 객체에 이미 역할 정보가 있다면 DB 조회를 건너뛰고 캐시된 값을 사용합니다.
ip_auth_required(role_required=None) 데코레이터:
Flask의 라우트(뷰 함수) 위에 @ip_auth_required('admin')과 같이 사용하여 해당 페이지에 대한 접근 권한을 검사합니다.
role_required='admin': 오직 'admin' 역할만 접근 허용.
role_required='user': 'admin' 또는 'user' 역할 접근 허용.
role_required=None (또는 데코레이터 인자 없이 @ip_auth_required() 사용 시): 'admin' 또는 'user' 역할이면 접근 허용 (즉, 'guest'만 아니면 됨).
권한이 없으면 abort(403)를 호출하여 "접근 금지" 오류 페이지를 반환합니다.
inject_user_info_to_templates() 컨텍스트 프로세서:
이 함수는 app/__init__.py 파일의 create_app 함수 내에서 app.context_processor(inject_user_info_to_templates)와 같이 등록되어야 합니다 (이전 응답에서 이미 등록함).
등록되면, 모든 Jinja2 템플릿 안에서 {{ current_user_ip }}와 {{ current_user_role }} 변수를 통해 현재 접속한 사용자의 IP와 역할을 바로 사용할 수 있습니다. (예: layout.html의 네비게이션 메뉴 표시 조건 등)
이 auth.py 파일은 Flask 애플리케이션의 IP 기반 인증/인가 시스템의 핵심입니다. 이 파일이 app 폴더 내에 올바르게 위치하고, app/__init__.py에서 inject_user_info_to_templates 컨텍스트 프로세서가 잘 등록되어 있으며, 각 라우트 함수에 @ip_auth_required() 데코레이터가 필요에 맞게 적용되어 있는지 확인하시면 됩니다.

만약 이전에 auth.py 관련하여 IndentationError가 발생했다면, 위 코드로 교체하시고 Python의 들여쓰기 규칙(보통 공백 4칸 또는 탭 1개 일관되게 사용)이 잘 지켜졌는지 다시 한번 확인해 보시기 바랍니다.

다음 단계로 진행할 준비가 되셨으면 알려주세요. 보통 사용자 제어판의 UI(control_panel.html) 및 관련 라우트(routes_user.py)를이어서 구현하게 됩니다.

Gemini에게 수정 가능한 문서나 코드를 작성해 달라고 해 보세요.

사용해 보기