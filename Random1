// 비동기 작업을 큐에 추가하고 처리하는 메서드
private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
{
    var newCommand = new CommandItem 
    { 
        CommandText = commandText, 
        Status = "Pending", 
        MaxRetryLimit = RetryLimit, 
        RetryCount = 0, 
        CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff")
    };

    App.Current.Dispatcher.Invoke(() => RemainingCommands.Add(newCommand)); // UI에 명령 추가

    commandQueue.Enqueue(async () =>
    {
        newCommand.Status = "Processing"; // 명령 상태를 "Processing"으로 변경
        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신

        int retryCount = 0; // 재시도 횟수 초기화
        Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치
        _isProcessing = true;

        // 최대 재시도 횟수까지 반복
        while (retryCount < RetryLimit) 
        {
            try
            {
                stopwatch.Restart(); // 스톱워치 시작

                // 비동기 작업 실행
                string result = await taskFunc();

                // 응답 시간 0.1초 단위로 갱신
                while (stopwatch.ElapsedMilliseconds < ResponseTimeout)
                {
                    newCommand.ResponseTime = (int)(stopwatch.ElapsedMilliseconds / 100); // 0.1초 단위로 응답 시간 설정
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신
                    await Task.Delay(100); // 0.1초 대기
                }

                stopwatch.Stop(); // 응답 종료 시 스톱워치 정지
                int responseTime = (int)stopwatch.ElapsedMilliseconds;
                newCommand.ResponseTime = responseTime; // 최종 응답 시간 기록

                if (responseTime > ResponseTimeout)
                {
                    newCommand.Status = "Timeout"; // Timeout 상태로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신

                    newCommand.Result = 0; // 실패 결과 설정
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Timeout occurred");
                    StopQueueProcessing(newCommand); // 큐 중단
                    return new CommandResult { Success = false, Message = "Response Timeout" }; // Timeout 결과 반환
                }

                if (responseValidator(result)) // 응답 검증
                {
                    newCommand.Status = "Completed"; // 상태를 성공으로 변경
                    newCommand.Result = 1; // 성공 결과 설정
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, result);
                    UpdateProgress(); // 프로그레스바 업데이트
                    _isProcessing = false; // 처리 종료
                    return new CommandResult { Success = true, Message = result }; // 성공 결과 반환
                }
                else
                {
                    retryCount++; // 재시도 횟수 증가
                    newCommand.Status = $"Retrying {retryCount}/{RetryLimit}"; // 재시도 중 상태로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신

                    if (retryCount >= RetryLimit)
                    {
                        newCommand.Status = "Failed"; // 재시도 실패 상태로 변경
                        newCommand.Result = 0; // 실패 결과 설정
                        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, "Failed after retries");
                        StopQueueProcessing(newCommand); // 큐 중단
                        return new CommandResult { Success = false, Message = result }; // 실패 결과 반환
                    }

                    await Task.Delay(RetryInterval); // 재시도 대기 시간
                }
            }
            catch (Exception ex) // 예외 처리
            {
                newCommand.Status = "Failed"; // 예외 발생 시 실패 상태로 변경
                App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 갱신
                newCommand.Result = 0; // 실패 결과 설정
                stopwatch.Stop(); // 응답 시간 측정 종료
                int responseTime = (int)stopwatch.ElapsedMilliseconds;
                newCommand.ResponseTime = responseTime; // 응답 시간 기록
                await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                StopQueueProcessing(newCommand); // 큐 중단
                return new CommandResult { Success = false, Message = ex.Message }; // 실패 결과 반환
            }
        }

        UpdateProgress(); // 프로그레스바 업데이트
        _isProcessing = false; // 처리 종료
        return new CommandResult { Success = false }; // 실패 결과 반환
    });

    if (!_isProcessing)
    {
        _isProcessing = true; // 작업 중 상태로 변경
        await ProcessCommandQueue(); // 큐에서 작업 처리
    }

    UpdateProgress(); // 프로그레스바 상태 업데이트
}
