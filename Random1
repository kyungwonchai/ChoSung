알겠습니다. 말씀하신 내용은 각 행이 몇 번째 줄인지 표시하고, 그 행의 내용을 키로 하여 중복되지 않도록 캐치하는 기능을 추가하는 것입니다.

이를 위해 다음 사항을 반영할 수 있습니다:

줄 번호를 기록: 각 줄이 몇 번째 줄인지 기록하여 출력 시 함께 표시합니다.
중복 체크: 이미 처리한 줄의 내용을 저장해두고, 이후에 동일한 내용을 다시 처리하지 않도록 합니다.
수정된 C# 코드
csharp
코드 복사
using System;
using System.IO;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;

namespace FileLineWriter
{
    public partial class MainWindow : Window
    {
        private readonly string _sourceFilePath = @"C:\Agent\_Gen1\largefile.txt";  // 원본 파일 경로
        private readonly double _defaultDelay = 50;  // 0.05초 (밀리초 단위)
        private readonly int _specialDelay = 5000;  // 5초 (특정 키워드가 있을 때 대기 시간)
        private readonly string _positionFilePath = @"C:\Agent\_Gen1\lastPosition.txt"; // 마지막 위치를 저장할 파일 경로
        private long _lastReadPosition = 0;  // 마지막 읽은 위치를 저장
        private HashSet<string> _processedLines = new HashSet<string>();  // 중복 방지용 처리된 줄을 저장

        public MainWindow()
        {
            InitializeComponent();
            LoadLastPosition();  // 프로그램 시작 시 마지막 읽은 위치 로드
        }

        // 프로그램 시작 시 마지막으로 읽은 위치를 파일에서 읽어오는 메서드
        private void LoadLastPosition()
        {
            if (File.Exists(_positionFilePath))
            {
                string positionString = File.ReadAllText(_positionFilePath);
                if (long.TryParse(positionString, out long position))
                {
                    _lastReadPosition = position;
                }
            }
        }

        // 마지막 읽은 위치를 파일에 기록하는 메서드
        private void SaveLastPosition()
        {
            File.WriteAllText(_positionFilePath, _lastReadPosition.ToString());
        }

        // '시작' 버튼 클릭 시 호출되는 메서드
        private async void StartButton_Click(object sender, RoutedEventArgs e)
        {
            string destinationFilePath = FilePathTextBox.Text;

            // 파일 경로가 입력되지 않았으면 알림 표시
            if (string.IsNullOrEmpty(destinationFilePath))
            {
                MessageBox.Show("파일 경로를 입력해주세요.");
                return;
            }

            // 원본 파일이 존재하는지 확인
            if (!File.Exists(_sourceFilePath))
            {
                MessageBox.Show("원본 파일을 찾을 수 없습니다.");
                return;
            }

            // 경로에서 폴더 확인 후, 없으면 폴더 생성
            string directoryPath = Path.GetDirectoryName(destinationFilePath);
            if (!Directory.Exists(directoryPath))
            {
                Directory.CreateDirectory(directoryPath);
            }

            // 파일이 존재하지 않으면 빈 파일 생성
            if (!File.Exists(destinationFilePath))
            {
                File.Create(destinationFilePath).Close(); // 파일을 생성하고, 바로 닫음
            }

            // 상태 표시 업데이트
            StatusTextBlock.Text = "상태: 처리 중";

            // 원본 파일의 내용을 마지막 읽은 위치에서부터 한 줄씩 읽기
            using (FileStream fs = new FileStream(_sourceFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            {
                fs.Seek(_lastReadPosition, SeekOrigin.Begin);  // 마지막 읽은 위치로 이동
                using (StreamReader reader = new StreamReader(fs))
                {
                    string line;
                    int lineNumber = 0;
                    while ((line = reader.ReadLine()) != null)
                    {
                        lineNumber++;

                        // 이미 처리된 줄인지 확인 (중복 방지)
                        if (_processedLines.Contains(line))
                        {
                            continue;  // 중복된 줄은 건너뜀
                        }

                        // 지정된 파일에 한 줄씩 추가
                        await WriteLineToLog(line, destinationFilePath, lineNumber);

                        // 현재 줄을 중복 방지용 HashSet에 추가
                        _processedLines.Add(line);

                        // 기본 지연 시간 (0.05초)
                        await Task.Delay(TimeSpan.FromMilliseconds(_defaultDelay));

                        // 현재 파일 포인터 위치 저장
                        _lastReadPosition = fs.Position;
                    }
                }
            }

            // 마지막 읽은 위치를 파일에 저장
            SaveLastPosition();

            // 상태 표시 완료
            StatusTextBlock.Text = "상태: 완료";
        }

        // 지정된 로그 파일에 한 줄씩 쓰는 메서드
        private async Task WriteLineToLog(string line, string destinationFilePath, int lineNumber)
        {
            // 지정된 파일에 라인을 추가 (줄 번호 포함)
            using (StreamWriter writer = File.AppendText(destinationFilePath))
            {
                await writer.WriteLineAsync($"[{lineNumber}] {line}");
            }

            // FST, FNL, PLAN 이 포함된 줄이 있을 때는 5초 대기
            if (line.Contains("FST") || line.Contains("FNL") || line.Contains("PLAN"))
            {
                await Task.Delay(_specialDelay);
            }
        }
    }
}
주요 수정 사항:
중복 방지를 위한 HashSet 사용:

_processedLines라는 HashSet<string>을 사용해 이미 처리된 줄을 기록합니다.
HashSet은 빠르게 중복된 줄을 확인하고, 중복된 줄은 건너뛰게 됩니다.
줄 번호 표시:

lineNumber 변수를 추가해 파일의 줄 번호를 기록하고, 출력할 때 해당 줄 번호와 함께 파일에 기록합니다.
각 줄을 로그 파일에 쓸 때 [{lineNumber}] {line} 형식으로 줄 번호와 함께 기록됩니다.
파일을 다시 읽을 때도 중복 방지:

프로그램이 다시 시작될 때도 중복되지 않은 줄만 읽어 처리하도록 HashSet을 사용하여 각 줄의 내용을 확인합니다.
프로그램 종료 후 재시작:

프로그램이 종료된 후 재시작되더라도 마지막 읽은 위치에서 다시 시작하고, 중복된 줄은 건너뛰며 새로운 줄만 기록하게 됩니다.
동작 방식:
파일 읽기 중 중복 방지: 각 줄의 내용을 HashSet에 저장해두고, 이후에 동일한 줄이 나타나면 중복을 피하기 위해 건너뛰게 됩니다.

줄 번호 기록: 각 줄의 번호를 기록하고, 로그 파일에 기록할 때 줄 번호를 포함하여 기록합니다.

프로그램 종료 후 재시작 시 중복 방지: 프로그램이 재시작되더라도 마지막 읽은 위치에서 이어서 새로운 내용을 처리하고, 중복된 줄은 기록하지 않습니다.

이 코드로 프로그램이 재시작되더라도 중복 없이 로그 파일을 읽고 처리할 수 있으며, 각 줄의 번호도 기록할 수 있습니다. 추가적인 기능이 필요하시면 언제든지 말씀해주세