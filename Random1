드를 유지하면서 파일 강제 삭제 로직을 수정하도록 하겠습니다. 필요한 부분만 변경하고, 전체 코드 중 파일 관련 부분을 수정하겠습니다.

FileManager.cs
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace FileCleanupApp
{
    public class FileManager
    {
        private string targetFolder;
        private int retentionDays;
        private long maxDiskUsage;
        private string logFolder = @"C:\agent\smdfilecleaner\log";

        public FileManager(string targetFolder, int retentionDays, long maxDiskUsage)
        {
            this.targetFolder = targetFolder;
            this.retentionDays = retentionDays;
            this.maxDiskUsage = maxDiskUsage;

            // 로그 폴더가 없으면 생성
            if (!Directory.Exists(logFolder))
            {
                Directory.CreateDirectory(logFolder);
            }
        }

        public async Task CleanUpAsync()
        {
            DateTime serverTime = await TimeSyncManager.GetServerTimeAsync();
            var files = new DirectoryInfo(targetFolder).GetFiles().OrderBy(f => f.CreationTime).ToList();
            long currentUsage = files.Sum(f => f.Length);
            string logFilePath = Path.Combine(logFolder, serverTime.ToString("yyyyMMdd") + ".txt");

            using (StreamWriter logWriter = new StreamWriter(logFilePath, true))
            {
                // 보관 기간이 지난 파일 삭제
                foreach (var file in files)
                {
                    if (serverTime - file.CreationTime > TimeSpan.FromDays(retentionDays) && !IsFileLocked(file))
                    {
                        logWriter.WriteLine($"{serverTime}: Deleted {file.FullName} due to retention policy");
                        file.Delete();
                        currentUsage -= file.Length;
                    }
                }

                // 하드 디스크 용량 확보를 위해 오래된 파일 삭제
                files = new DirectoryInfo(targetFolder).GetFiles().OrderBy(f => f.CreationTime).ToList(); // 파일 목록 갱신
                foreach (var file in files)
                {
                    if (currentUsage <= maxDiskUsage)
                    {
                        break;
                    }

                    if (!IsFileLocked(file))
                    {
                        logWriter.WriteLine($"{serverTime}: Deleted {file.FullName} due to disk space limit");
                        file.Delete();
                        currentUsage -= file.Length;
                    }
                }
            }

            CleanUpLogs(serverTime);
        }

        private void CleanUpLogs(DateTime serverTime)
        {
            var logFiles = new DirectoryInfo(logFolder).GetFiles("*.txt").OrderBy(f => f.CreationTime).ToList();

            foreach (var logFile in logFiles)
            {
                if (serverTime - logFile.CreationTime > TimeSpan.FromDays(60))
                {
                    logFile.Delete();
                }
            }
        }

        private bool IsFileLocked(FileInfo file)
        {
            try
            {
                using (FileStream stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None))
                {
                    stream.Close();
                }
            }
            catch (IOException)
            {
                return true;
            }

            return false;
        }
    }
}
Scheduler.cs
Scheduler 클래스에서 CleanUpAsync 메서드를 호출하도록 합니다.

csharp
코드 복사
using System;
using System.Threading;
using System.Threading.Tasks;

namespace FileCleanupApp
{
    public class Scheduler
    {
        private FileManager fileManager;
        private CancellationTokenSource cancellationTokenSource;

        public Scheduler(FileManager fileManager)
        {
            this.fileManager = fileManager;
            this.cancellationTokenSource = new CancellationTokenSource();
        }

        public void Start()
        {
            Task.Run(() => RunPeriodicTask(TimeSpan.FromHours(4), cancellationTokenSource.Token));
        }

        private async Task RunPeriodicTask(TimeSpan interval, CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                await fileManager.CleanUpAsync();
                await Task.Delay(interval, cancellationToken);
            }
        }

        public void Stop()
        {
            cancellationTokenSource.Cancel();
        }
    }
}
이 코드는 기존 코드를 유지하면서 필요한 부분만 수정한 것입니다. 보관 기간이 지난 파일을 우선적으로 삭제하고, 용량을 확보하기 위해 보관 기간이 남은 파일 중 오래된 파일을 순차적으로 삭제하는 로직으로 변경하였습니다. 또한, 파일 목록을 갱신하여 용량 확보를 위한 삭제 과정에서 충돌을 피하도록 하였습니