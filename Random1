갤럭시 탭 S8의 S펜에서 버튼을 누르는 기능을 활용하려면 MotionEvent를 사용하여 버튼을 감지하고, 이를 통해 지우개 기능을 구현할 수 있습니다.

안드로이드 Compose에서 MotionEvent를 사용하는 방법을 통해 S펜의 버튼을 감지하고 지우개 기능을 구현해보겠습니다.

수정된 ImageDisplayScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Paint
import android.view.MotionEvent
import android.view.View
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }
    var eraseMode by remember { mutableStateOf(false) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val view = LocalView.current
    val window = (context as? ComponentActivity)?.window
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier
        .fillMaxSize()
        .pointerInteropFilter { event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                    eraseMode = event.buttonState == MotionEvent.BUTTON_SECONDARY
                }
                MotionEvent.ACTION_UP -> {
                    eraseMode = false
                }
            }
            false
        }
    ) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode && !eraseMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        Canvas(modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragStart = { offset -> currentPathPoints = listOf(offset) },
                    onDragEnd = {
                        if (drawMode && !eraseMode) {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                        } else if (eraseMode) {
                            // 지우개 모드에서는 색을 투명으로 설정하여 경로 추가
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, Color.Transparent)
                        }
                        currentPathPoints = listOf()
                    },
                    onDrag = { change, _ ->
                        currentPathPoints = currentPathPoints + change.position
                        change.consume()
                    }
                )
            }
        ) {
            for (path in drawingPaths) {
                val paintColor = if (path.color == Color.Transparent) Color.White else path.color
                for (i in 1 until path.points.size) {
                    drawLine(
                        color = paintColor,
                        start = path.points[i - 1],
                        end = path.points[i],
                        strokeWidth = if (path.color == Color.Transparent) 10f else 3f // 지우개 모드에서는 더 두껍게
                    )
                }
            }
            for (i in 1 until currentPathPoints.size) {
                drawLine(
                    color = if (eraseMode) Color.White else color,
                    start = currentPathPoints[i - 1],
                    end = currentPathPoints[i],
                    strokeWidth = if (eraseMode) 10f else 3f // 지우개 모드에서는 더 두껍게
                )
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(horizontal = 20.dp, vertical = 0.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    window?.let { captureAndUploadBitmap(it, view, scope) }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

fun captureAndUploadBitmap(window: android.view.Window, view: View, scope: CoroutineScope) {
    val bitmap = Bitmap.createBitmap(view.width, view.height, Bitmap.Config.ARGB_8888)
    val location = IntArray(2)
    view.getLocationInWindow(location)
    try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            PixelCopy.request(
                window, android.graphics.Rect(
                    location[0], location[1],
                    location[0] + view.width, location[1] + view.height
                ), bitmap, { copyResult ->
                    if (copyResult == PixelCopy.SUCCESS) {
                        scope.launch {
                            uploadBitmap(bitmap)
                        }
                    }
                }, view.handler
            )
        } else {
            view.draw(Canvas(bitmap))
            scope.launch {
                uploadBitmap(bitmap)
            }
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
위 코드에서 pointerInteropFilter를 사용하여 MotionEvent를 감지하고, S펜의 버튼 상태에 따라 eraseMode를 설정합니다. 이렇게 하면 S펜의 버튼을 누른 상태에서 그리면 지우개 모드로 동작하게 됩니다.






