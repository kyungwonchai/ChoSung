네, 다음은 두 가지 문제를 해결한 코드입니다:

펜을 새로 터치할 때 이전 점과 연결되지 않도록 수정합니다.
컬러 선택 시 이전 선의 색상은 변경되지 않고, 새로 그리는 선만 선택한 색상으로 표시되도록 합니다.
MainActivity.kt
기존 코드에 변동사항 없습니다.

ImageListScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Color as AndroidColor
import android.graphics.Paint
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.launch
import java.io.ByteArrayOutputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    Column {
        if (selectedImage == null) {
            Button(
                onClick = { onFetchData() },
                modifier = Modifier.padding(20.dp)
            ) {
                Text(if (imageList.isEmpty()) "Fetch Data" else "Reload Data")
            }
        }

        LazyColumn(modifier = Modifier.weight(1f).padding(horizontal = 20.dp)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            ImageDisplayScreen(
                bitmap = it,
                imageTitle = selectedImageTitle,
                datetime = selectedDatetime,
                onBack = onBack,
                onFit = onFit,
                isRefreshing = isRefreshing,
                onToggleRefresh = onToggleRefresh
            )
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(drawMode) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        if (!drawMode) {
                            scale *= zoom
                            offset = Offset(offset.x + pan.x, offset.y + pan.y)
                        }
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        if (drawMode) {
            Canvas(modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { offset -> currentPathPoints = listOf(offset) },
                        onDragEnd = {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                            currentPathPoints = listOf()
                        },
                        onDrag = { change, _ ->
                            currentPathPoints = currentPathPoints + change.position
                            change.consume()
                        }
                    )
                }
            ) {
                for (path in drawingPaths) {
                    for (i in 1 until path.points.size) {
                        drawLine(
                            color = path.color,
                            start = path.points[i - 1],
                            end = path.points[i],
                            strokeWidth = 3f
                        )
                    }
                }
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(20.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    scope.launch {
                        uploadBitmap(currentBitmap)
                    }
                }) {
                    Text("Upload")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
ImageData.kt
기존 코드에 변동사항 없습니다.

DatabaseHelper.kt
기존 코드에 변동사항 없습니다.

이 코드에서는 다음과 같은 변경 사항이 있습니다:

DrawingPath 데이터 클래스를 추가하여 각 드로잉 경로와 색상을 저장합니다.
drawingPaths 리스트를 사용하여 완료된 경로를 저장하고, 현재 경로는 currentPathPoints에 저장합니다.
드로잉이 끝나면 drawingPaths에 현재 경로를 추가하고 currentPathPoints를 초기화합니다.
Canvas에서 drawingPaths와 currentPathPoints를 사용하여 각각의 경로를 그립니다.
ColorPicker에서 선택한 색상을 새로 그리는 선에만 적용하도록 수정했습니다.
이제 드로잉이 자연스럽게 처리되고, 새로 터치할 때 이전 점과 연결되지 않으며, 색상도 각 경로별로 다