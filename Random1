네, 알겠습니다. 이전에 DatabaseService.cs의 오류를 수정했으니, 이제 제어 UI 프로그램(MGSPMonitorControl)의 다음 파일들의 코드를 드리겠습니다.

먼저 중계 프로그램(MGSPBrokerService)과 통신을 담당할 TCP 클라이언트 서비스와, MVVM 패턴을 지원하기 위한 간단한 헬퍼 클래스들을 제공하겠습니다.

3. Services/ 폴더 (계속)

3.1. Services/BrokerClientService.cs (중계 프로그램 TCP 통신 클라이언트)

이 클래스는 MGSPBrokerService의 UI 연결용 포트(예: 9001)로 접속하여 메시지를 주고받습니다.

C#

// MGSPMonitorControl/Services/BrokerClientService.cs
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MGSPMonitorControl.Models; // UserSession 등 로컬 모델
using MonitorControl.SharedModels; // BrokerMessage 등 공용 모델
using Newtonsoft.Json;
using System.Configuration; // App.config 사용

namespace MGSPMonitorControl.Services
{
    public interface IBrokerClientService
    {
        bool IsConnected { get; }
        Task<bool> ConnectAsync();
        Task DisconnectAsync();
        Task SendMessageAsync(BrokerMessage message);

        event Action<BrokerMessage> MessageReceived; // Broker로부터 메시지 수신 시 발생
        event Action Connected; // Broker 연결 성공 시
        event Action Disconnected; // Broker 연결 끊김 시
    }

    public class BrokerClientService : IBrokerClientService, IDisposable
    {
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;

        private readonly string _brokerIp;
        private readonly int _brokerPort;
        // private readonly ILoggingService _logger; // 필요시 로깅 서비스 주입

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null && !_isDisposed;

        public event Action<BrokerMessage> MessageReceived;
        public event Action Connected;
        public event Action Disconnected;

        public BrokerClientService(/* ILoggingService logger */)
        {
            // _logger = logger;
            // App.config에서 Broker 접속 정보 읽기
            string brokerAddress = ConfigurationManager.AppSettings["BrokerAddress"]; // 예: "127.0.0.1:9001"
            if (string.IsNullOrWhiteSpace(brokerAddress) || !brokerAddress.Contains(":"))
            {
                // _logger?.LogError("BrokerAddress not found or invalid in App.config. Using default.");
                Console.WriteLine("[ERROR] BrokerAddress not found or invalid in App.config. Using default 127.0.0.1:9001.");
                brokerAddress = "127.0.0.1:9001"; // 기본값
            }

            var parts = brokerAddress.Split(':');
            _brokerIp = parts[0];
            if (!int.TryParse(parts[1], out _brokerPort))
            {
                // _logger?.LogError($"Invalid Broker Port in App.config: {parts[1]}. Using default 9001.");
                Console.WriteLine($"[ERROR] Invalid Broker Port in App.config: {parts[1]}. Using default 9001.");
                _brokerPort = 9001; // 기본값
            }
            Console.WriteLine($"BrokerClientService initialized. Target Broker: {_brokerIp}:{_brokerPort}");
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected) return true;
            if (_isDisposed) throw new ObjectDisposedException(nameof(BrokerClientService));

            _cts?.Cancel(); // 이전 작업 취소
            _cts?.Dispose();
            _cts = new CancellationTokenSource();
            var token = _cts.Token;

            try
            {
                // _logger?.LogInfo($"Attempting to connect to Broker: {_brokerIp}:{_brokerPort}");
                Console.WriteLine($"UI: Attempting to connect to Broker: {_brokerIp}:{_brokerPort}");
                _tcpClient = new TcpClient();
                var connectTask = _tcpClient.ConnectAsync(_brokerIp, _brokerPort);
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5), token);

                if (await Task.WhenAny(connectTask, timeoutTask).ConfigureAwait(false) == connectTask &&
                    connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    // _logger?.LogInfo("UI: Successfully connected to Broker.");
                    Console.WriteLine("UI: Successfully connected to Broker.");

                    _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(token), token);
                    Connected?.Invoke(); // 연결 성공 이벤트 발생
                    return true;
                }
                else
                {
                    _tcpClient.Close();
                    if (token.IsCancellationRequested) { /*_logger?.LogInfo("UI: Connection attempt to Broker cancelled.");*/ Console.WriteLine("UI: Connection attempt to Broker cancelled."); }
                    else { /*_logger?.LogWarning($"UI: Timeout or error connecting to Broker {_brokerIp}:{_brokerPort}."); */ Console.WriteLine($"UI: Timeout or error connecting to Broker {_brokerIp}:{_brokerPort}."); }
                    Disconnected?.Invoke(); // 연결 실패도 Disconnected로 처리
                    return false;
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                // _logger?.LogInfo("UI: Connection attempt to Broker cancelled by token.");
                Console.WriteLine("UI: Connection attempt to Broker cancelled by token.");
                _tcpClient?.Close();
                Disconnected?.Invoke();
                return false;
            }
            catch (Exception ex)
            {
                // _logger?.LogError($"UI: Error connecting to Broker: {ex.Message}", ex);
                Console.WriteLine($"[ERROR] UI: Error connecting to Broker: {ex.Message}");
                _tcpClient?.Close();
                Disconnected?.Invoke();
                return false;
            }
        }

        private async Task ReceiveMessagesAsync(CancellationToken token)
        {
            // _logger?.LogInfo("UI: Starting to receive messages from Broker.");
            Console.WriteLine("UI: Starting to receive messages from Broker.");
            try
            {
                while (!token.IsCancellationRequested && IsConnected && _streamReader != null)
                {
                    string messageJson = await _streamReader.ReadLineAsync().ConfigureAwait(false);
                    if (messageJson == null)
                    {
                        // _logger?.LogInfo("UI: Broker disconnected or stream closed.");
                        Console.WriteLine("UI: Broker disconnected or stream closed.");
                        break;
                    }
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null)
                        {
                            // _logger?.LogDebug($"UI: Message received from Broker: {message.Type}");
                            Console.WriteLine($"UI: Message received from Broker: {message.Type}, CorrId: {message.CorrelationId}");
                            MessageReceived?.Invoke(message);
                        }
                        else { /* _logger?.LogWarning($"UI: Failed to deserialize message from Broker: {messageJson}"); */ Console.WriteLine($"UI: Failed to deserialize message from Broker: {messageJson}"); }
                    }
                    catch (JsonException jsonEx) { /*_logger?.LogError($"UI: JSON deserialization error from Broker: {jsonEx.Message}. Received: {messageJson}", jsonEx); */ Console.WriteLine($"UI: JSON deserialization error from Broker: {jsonEx.Message}. Received: {messageJson}");}
                }
            }
            catch (IOException ioEx) when (token.IsCancellationRequested || !IsConnected)
            { /*_logger?.LogInfo($"UI: IOException in receive loop from Broker (likely connection closed or cancelled): {ioEx.Message}");*/ Console.WriteLine($"UI: IOException in receive loop from Broker (likely connection closed or cancelled): {ioEx.Message}"); }
            catch (ObjectDisposedException)
            { /*_logger?.LogInfo("UI: Receive loop from Broker terminated due to object disposal.");*/ Console.WriteLine("UI: Receive loop from Broker terminated due to object disposal."); }
            catch (OperationCanceledException)
            { /*_logger?.LogInfo("UI: Receive loop from Broker cancelled."); */ Console.WriteLine("UI: Receive loop from Broker cancelled."); }
            catch (Exception ex)
            { if(!token.IsCancellationRequested && !_isDisposed) /*_logger?.LogError($"UI: Unexpected error in receive loop from Broker: {ex.Message}", ex);*/ Console.WriteLine($"[ERROR] UI: Unexpected error in receive loop from Broker: {ex.Message}"); }
            finally
            {
                // _logger?.LogInfo("UI: Receive loop from Broker ended.");
                Console.WriteLine("UI: Receive loop from Broker ended.");
                if (!_isDisposed && !token.IsCancellationRequested) // 의도치 않은 종료 시
                {
                    CleanupConnectionResources(false);
                    Disconnected?.Invoke(); // 연결 끊김 이벤트 발생
                }
            }
        }

        public async Task SendMessageAsync(BrokerMessage message)
        {
            if (!IsConnected || _streamWriter == null || _isDisposed || (_cts != null && _cts.IsCancellationRequested))
            {
                // _logger?.LogWarning($"UI: Cannot send message to Broker. Not connected, writer is null, disposed, or sending cancelled. MessageType: {message.Type}");
                Console.WriteLine($"UI: Cannot send message to Broker. Not connected, writer is null, disposed, or sending cancelled. MessageType: {message.Type}");
                return;
            }

            try
            {
                string messageJson = JsonConvert.SerializeObject(message);
                // lock을 사용하여 _streamWriter에 대한 동시 접근을 막음
                bool sent = false;
                lock (_sendLock)
                {
                    if (IsConnected && _streamWriter != null && !_isDisposed && (_cts == null || !_cts.IsCancellationRequested))
                    {
                        _streamWriter.WriteLine(messageJson); // 동기적 쓰기 (WriteLineAsync 사용 가능)
                        sent = true;
                    }
                }
                if (sent) { /*_logger?.LogDebug($"UI: Message sent to Broker: {message.Type}, CorrId: {message.CorrelationId}");*/ Console.WriteLine($"UI: Message sent to Broker: {message.Type}, CorrId: {message.CorrelationId}");}
                else { /*_logger?.LogWarning($"UI: Send cancelled or not possible for {message.Type} inside lock.");*/ Console.WriteLine($"UI: Send cancelled or not possible for {message.Type} inside lock."); }
            }
            catch (ObjectDisposedException) { /*_logger?.LogWarning($"UI: Attempted to send {message.Type} to Broker on a disposed stream/writer.");*/ Console.WriteLine($"UI: Attempted to send {message.Type} to Broker on a disposed stream/writer."); HandleSendError(); }
            catch (IOException ioEx) { /*_logger?.LogError($"UI: IOException sending {message.Type} to Broker (connection may be lost): {ioEx.Message}", ioEx);*/ Console.WriteLine($"UI: IOException sending {message.Type} to Broker (connection may be lost): {ioEx.Message}"); HandleSendError(); }
            catch (JsonException jsonEx) { /*_logger?.LogError($"UI: Error serializing message {message.Type} to send to Broker: {jsonEx.Message}.", jsonEx);*/ Console.WriteLine($"UI: Error serializing message {message.Type} to send to Broker: {jsonEx.Message}.");}
            catch (Exception ex) { /*_logger?.LogError($"UI: Error sending {message.Type} to Broker: {ex.Message}", ex);*/ Console.WriteLine($"[ERROR] UI: Error sending {message.Type} to Broker: {ex.Message}"); HandleSendError(); }
        }
        
        private void HandleSendError()
        {
            if (!_isDisposed)
            {
                 CleanupConnectionResources(false);
                 Disconnected?.Invoke();
            }
        }


        public Task DisconnectAsync()
        {
            // _logger?.LogInfo("UI: Disconnecting from Broker (explicit request)...");
            Console.WriteLine("UI: Disconnecting from Broker (explicit request)...");
            if (_isDisposed) return Task.FromResult(false); // .NET 4.5엔 Task.CompletedTask 없음

            _cts?.Cancel(); // 모든 비동기 작업(연결 시도, 수신 루프) 취소 요청
            CleanupConnectionResources(false); // Dispose 호출 전 연결 자원 정리
            Disconnected?.Invoke(); // 즉시 이벤트 발생
            return Task.FromResult(true);
        }

        private void CleanupConnectionResources(bool calledFromDispose)
        {
            if (!calledFromDispose && _isDisposed) return; 

            lock(_sendLock) // SendMessageAsync와 동기화
            {
                try { _streamWriter?.Dispose(); } catch { /* 무시 */ }
                _streamWriter = null;
            }
            try { _streamReader?.Dispose(); } catch { /* 무시 */ }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { /* 무시 */ }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { /* 무시 */ } 
            _tcpClient = null;
            
            if (!calledFromDispose)
            {
                 // _logger?.LogInfo("UI: Broker TCP client connection resources released due to disconnection.");
                 Console.WriteLine("UI: Broker TCP client connection resources released due to disconnection.");
            }
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            // _logger?.LogInfo("UI: Disposing BrokerClientService.");
            Console.WriteLine("UI: Disposing BrokerClientService.");
            _cts?.Cancel();
            _cts?.Dispose();
            _cts = null;

            CleanupConnectionResources(true);
            // _logger?.LogInfo("UI: BrokerClientService disposed.");
            Console.WriteLine("UI: BrokerClientService disposed.");
            GC.SuppressFinalize(this);
        }
    }
}
BrokerClientService.cs 참고:

App.config 설정: 이 클래스는 App.config 파일에서 BrokerAddress라는 키로 중계 서버의 주소 및 포트(예: 127.0.0.1:9001)를 읽어오도록 되어 있습니다. App.config 파일 예시는 이전 DatabaseService.cs 제공 시 함께 드렸습니다. System.Configuration.dll 참조가 필요합니다.
로깅: 주석 처리된 _logger 부분을 사용하여 실제 로깅 서비스(별도 구현 또는 주입)를 연동할 수 있습니다. 현재는 Console.WriteLine으로 대체되어 있습니다.
비동기 쓰기: SendMessageAsync 내부의 _streamWriter.WriteLine(messageJson)은 현재 동기적 호출입니다. 더 많은 동시 요청을 처리하려면 await _streamWriter.WriteLineAsync(messageJson)로 변경하고 메서드 전체의 비동기 흐름을 조정할 수 있습니다. 여기서는 단순성을 위해 동기 쓰기 후 Task.FromResult를 사용했습니다.
3.2. ViewModels/ObservableObject.cs (MVVM 헬퍼 - INotifyPropertyChanged 구현)

CommunityToolkit.Mvvm 대신 사용할 간단한 기본 클래스입니다.

C#

// MGSPMonitorControl/ViewModels/ObservableObject.cs
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MGSPMonitorControl.ViewModels
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected virtual bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = "")
        {
            if (EqualityComparer<T>.Default.Equals(storage, value))
                return false;

            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
3.3. ViewModels/RelayCommand.cs (MVVM 헬퍼 - ICommand 구현)

CommunityToolkit.Mvvm 대신 사용할 간단한 ICommand 구현입니다.

C#

// MGSPMonitorControl/ViewModels/RelayCommand.cs
using System;
using System.Windows.Input;

namespace MGSPMonitorControl.ViewModels
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;

        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public RelayCommand(Action execute, Func<bool> canExecute = null)
            : this(o => execute(), canExecute == null ? (Predicate<object>)null : o => canExecute())
        {
            if (execute == null) throw new ArgumentNullException(nameof(execute));
        }


        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
여기까지 Services 폴더의 BrokerClientService.cs와 MVVM 패턴을 위한 기본적인 헬퍼 클래스(ObservableObject, RelayCommand)를 제공했습니다.