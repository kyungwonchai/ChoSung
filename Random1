가 발생한 원인은 클립보드에 복사되는 텍스트의 메모리 처리 방식에 오류가 있기 때문입니다. 이를 해결하기 위해 WinAPI를 활용해 데이터를 정확히 클립보드에 복사하도록 수정된 코드를 제공하겠습니다.

최종 수정된 코드: 시트 전체 복사 후 클립보드에 넣기
vba
코드 복사
#If VBA7 Then
    Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
#Else
    Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function EmptyClipboard Lib "user32" () As Long
    Private Declare Function CloseClipboard Lib "user32" () As Long
    Private Declare Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
    Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
    Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
#End If

Const CF_TEXT As Long = 1
Const GMEM_MOVEABLE As Long = &H2

Sub CopyTextToClipboard(ByVal Text As String)
    Dim hGlobal As LongPtr
    Dim lpGlobal As LongPtr
    
    ' 클립보드 열기
    If OpenClipboard(0&) Then
        EmptyClipboard
        
        ' 메모리 할당
        hGlobal = GlobalAlloc(GMEM_MOVEABLE, LenB(Text) + 1) ' 텍스트 길이 계산
        lpGlobal = GlobalLock(hGlobal)
        
        If lpGlobal Then
            ' 텍스트를 메모리에 복사
            Dim i As Long
            For i = 1 To Len(Text)
                Dim charByte As Byte
                charByte = Asc(Mid(Text, i, 1))
                CopyMemory ByVal lpGlobal + i - 1, charByte, 1
            Next i
            
            ' NULL 종료 문자 추가
            CopyMemory ByVal lpGlobal + Len(Text), vbNullChar, 1
            
            GlobalUnlock hGlobal
            SetClipboardData CF_TEXT, hGlobal
        End If
        
        CloseClipboard
    End If
End Sub

Sub CopySheetWithoutQuotes()
    Dim ws As Worksheet
    Dim rng As Range
    Dim row As Range
    Dim cell As Range
    Dim clipboardData As String
    
    ' 현재 시트와 범위 지정
    Set ws = ThisWorkbook.Sheets(1)
    Set rng = ws.UsedRange ' 시트의 데이터가 있는 전체 범위
    
    ' 시트 내용 읽기
    clipboardData = ""
    For Each row In rng.Rows
        For Each cell In row.Cells
            ' 셀 값 읽기 및 탭으로 구분
            clipboardData = clipboardData & cell.Value & vbTab
        Next cell
        ' 마지막 탭 제거 및 줄바꿈 추가
        clipboardData = Left(clipboardData, Len(clipboardData) - 1) & vbCrLf
    Next row
    
    ' 클립보드에 복사
    CopyTextToClipboard clipboardData
    
    MsgBox "시트 내용이 클립보드에 복사되었습니다!", vbInformation
End Sub
코드 수정 사항
텍스트 메모리 처리:

클립보드에 데이터를 복사하기 전에 텍스트를 정확히 메모리에 할당하도록 CopyMemory를 사용했습니다.
텍스트를 한 글자씩 처리하며 메모리에 복사한 후 NULL 종료 문자를 추가했습니다.
전체 시트 복사 처리:

UsedRange를 사용해 시트의 모든 데이터를 읽고 각 셀 값을 **탭(vbTab)**으로 구분해 결합했습니다.
행 끝마다 줄바꿈(vbCrLf)을 추가해 줄 단위로 데이터를 정리했습니다.
클립보드 동작 개선:

클립보드 작업이 실패하지 않도록 GlobalAlloc, GlobalLock, GlobalUnlock 등의 API를 신중하게 사용했습니다.
실행 방법
VBA 에디터 열기:

Alt + F11을 눌러 VBA 편집기를 엽니다.
코드 붙여넣기:

위 코드를 새로운 모듈(Module)에 붙여넣습니다.
매크로 실행:

Alt + F8을 눌러 CopySheetWithoutQuotes 매크로를 실행합니다.
메모장에 붙여넣기:

클립보드에 복사된 내용을 메모장에 붙여넣습니다.
결과 예시
엑셀 시트 내용:

A	B	C
Hello	World	Test
Data	Value	Text
메모장에서 붙여넣기:

mathematica
코드 복사
Hello   World   Test
Data    Value   Text
문제 해결