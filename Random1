네, 다음으로 수정된 Infrastructure/AuditLogInterceptor.cs 파일의 전체 코드(주석 제외)를 드리겠습니다.

이 코드에서는 'Added' 상태의 로그가 생성되고 저장되는 과정을 더 상세히 추적하기 위해 GenerateAuditLogs 메서드의 Added 상태 처리 부분과 SaveAuditLogs 메서드에 디버그 출력(Debug.WriteLine)을 추가했습니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Validation; // LogValidationErrors 사용

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}";

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { GenerateAuditLogs(interceptionContext); }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { SaveAuditLogs(interceptionContext); }
        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            foreach (var context in interceptionContext.DbContexts)
            {
                if (!(context is LockerDbContext dbContext) || !dbContext.ChangeTracker.HasChanges()) continue;

                bool isMaster = dbContext.IsMasterSave;
                string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
                string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

                if (!changedEntries.Any()) continue;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨 (isMaster={isMaster}).");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added)
                    {
                        Debug.WriteLine($"    - Added 상태 감지됨: {auditEntry.TableName}");
                        foreach (var pn in entry.CurrentValues.PropertyNames) { newValues[pn] = entry.CurrentValues[pn]; }
                        Debug.WriteLine($"    - Added 로그 NewValues 생성 시도...");
                        try
                        {
                             auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings);
                             Debug.WriteLine($"    - Added 로그 NewValues 직렬화 성공.");
                        }
                        catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; }
                    }
                    else if (entry.State == EntityState.Deleted) { Debug.WriteLine($"    - Deleted 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } Debug.WriteLine($"    - Deleted 로그 데이터 생성 완료."); }
                    else if (entry.State == EntityState.Modified) { Debug.WriteLine($"    - Modified 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } Debug.WriteLine($"    - Modified 로그 데이터 생성 완료."); } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                    if (auditEntry != null)
                    {
                        Debug.WriteLine($"    -> auditEntries 리스트에 추가 시도: {auditEntry.TableName}, Action: {auditEntry.Action}");
                        auditEntries.Add(auditEntry);
                        Debug.WriteLine($"    -> auditEntries 리스트에 추가 완료. 현재 리스트 개수: {auditEntries.Count}");
                    } else { Debug.WriteLine($"    !!! 로그 객체 생성 실패? ({entry.Entity.GetType().Name})"); }
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any())
                {
                    string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode());
                    interceptionContext.UserState = auditEntries;
                    Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장.");
                }
                 dbContext.IsMasterSave = false;
            }
        }

        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            List<AuditLog> auditEntries = interceptionContext.UserState as List<AuditLog>;
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges 시작. UserState에서 가져온 로그 수 = {auditEntries?.Count ?? 0}");
            if (auditEntries != null && auditEntries.Any())
            {
                 foreach(var log in auditEntries) Debug.WriteLine($"  - 저장 대상 로그: {log.Action} on {log.TableName}");
            }

            if (interceptionContext.Exception == null && auditEntries != null && auditEntries.Any())
            {
                try
                {
                    using (var logContext = new Data.LockerDbContext())
                    {
                        Debug.WriteLine($"  -> {auditEntries.Count}개 로그 저장 시도 (새 Context 사용)...");
                        logContext.AuditLogs.AddRange(auditEntries);
                        Debug.WriteLine($"  -> logContext.SaveChanges() 호출 시도...");
                        int logResult = logContext.SaveChanges();
                        Debug.WriteLine($"  -> 로그 저장 완료. 결과 = {logResult}");
                    }
                }
                catch (DbEntityValidationException vex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Validation): {vex.ToString()}"); LogValidationErrors(vex); } // 로그 저장 실패 시 상세 오류 추가
                catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Update): {dbEx.ToString()}"); LogDbUpdateException(dbEx); } // 로그 저장 실패 시 상세 오류 추가
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - General): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"  -> 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"  -> 저장할 로그 없음."); }
            interceptionContext.UserState = null;
        }

        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) { try { var objectContext = ((IObjectContextAdapter)context).ObjectContext; var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity); if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) { return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value)); } if (entry.State == EntityState.Added) return "New"; } catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); } return "N/A"; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        // 오류 로깅 헬퍼 (DbContext에서 가져옴 - 필요 시)
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
    }
}
핵심 변경 사항:

GenerateAuditLogs 메서드:
if (entry.State == EntityState.Added) 블록 안에 진입했는지, NewValues 직렬화가 성공했는지, auditEntries.Add() 호출 전후 상태를 확인하는 Debug.WriteLine을 추가했습니다.
SaveAuditLogs 메서드:
메서드 시작 시 UserState에서 가져온 로그 목록과 개수를 출력합니다.
로그를 저장하는 logContext.SaveChanges() 호출 전후 및 결과값을 출력합니다.
로그 저장 실패 시 발생하는 예외(DbEntityValidationException, DbUpdateException, Exception)를 catch 블록에서 잡고 상세 내용을 디버그 창에 출력하도록 수정했습니다.
다음 단계:

코드 적용 및 빌드: 위 코드로 AuditLogInterceptor.cs 파일을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
메인 화면(사물함 관리) 에서 새로운 행을 추가하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 매우 주의 깊게 확인합니다.
GenerateAuditLogs 로그:
Added 상태 감지됨: LockerAssignment 메시지가 나타나나요?
Added 로그 NewValues 직렬화 성공. 메시지가 나타나나요?
auditEntries 리스트에 추가 시도... 및 ...추가 완료. 메시지가 나타나나요?
UserState에 저장. 메시지에 로그 개수 1이 표시되나요?
SaveAuditLogs 로그:
SavedChanges 시작. UserState에서 가져온 로그 수 = 1 메시지가 나타나나요?
저장 대상 로그: Added on LockerAssignment 메시지가 나타나나요?
로그 저장 시도... 메시지가 나타나나요?
logContext.SaveChanges() 호출 시도... 메시지가 나타나나요?
로그 저장 완료. 결과 = 1 메시지가 나타나나요? 아니면 이 단계에서 예외 로그가 출력되나요?