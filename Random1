아래는 전문가 수준의 WPF DevExpress 22.2 프로젝트 코드입니다. MVVM 패턴을 철저히 지키고, MainViewModel을 중심으로 필요한 클래스들을 분리하여 작성했습니다. 각 부분에 한글 설명을 상세히 추가하였으니 참고해 주세요.

1. MSSQL 데이터베이스 스키마
먼저 MSSQL에 필요한 테이블을 생성합니다.

sql
코드 복사
CREATE TABLE Tasks (
    TaskID INT IDENTITY(1,1) PRIMARY KEY,
    TaskName NVARCHAR(100) NOT NULL, -- 과제명
    ProblemDescription NVARCHAR(MAX), -- 문제점 설명
    ProgressStatus NVARCHAR(50), -- 진행 상황
    CompletionStatus BIT, -- 완료 여부 (0: 미완료, 1: 완료)
    RegistrationDate DATE, -- 등록일
    CompletionDate DATE, -- 완료일
    PriorityLevel INT, -- 중요도 (1~5)
    IsImportant BIT -- 중요한 과제 여부
);
2. 프로젝트 구조
View (XAML): MainWindow.xaml
ViewModel: MainViewModel.cs
Model: TaskModel.cs
서비스 클래스: TaskService.cs (DB에서 데이터를 가져오는 서비스)
3. MainWindow.xaml (View)
View는 GridControl을 사용하여 데이터를 표시하고, 체크 박스를 통해 완료 여부를 필터링할 수 있습니다. 필터된 데이터는 완료된 항목은 회색, 중요한 항목은 주황색으로 강조 표시됩니다.

xml
코드 복사
<Window x:Class="TaskManagement.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        xmlns:local="clr-namespace:TaskManagement"
        Title="Task Management" Height="600" Width="900">

    <Grid>
        <!-- Task 리스트를 위한 GridControl -->
        <dxg:GridControl ItemsSource="{Binding TaskList}" AutoGenerateColumns="AddNew">
            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="TaskName" Header="과제명" />
                <dxg:GridColumn FieldName="ProblemDescription" Header="문제점" />
                <dxg:GridColumn FieldName="ProgressStatus" Header="진행 상황" />
                <dxg:GridColumn FieldName="CompletionStatus" Header="완료 여부">
                    <dxg:GridColumn.EditSettings>
                        <dxe:CheckEditSettings />
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>
                <dxg:GridColumn FieldName="RegistrationDate" Header="등록일" />
                <dxg:GridColumn FieldName="CompletionDate" Header="완료일" />
                <dxg:GridColumn FieldName="PriorityLevel" Header="중요도" />
            </dxg:GridControl.Columns>

            <!-- 조건부 서식: 중요한 항목을 주황색으로, 완료된 항목을 회색으로 -->
            <dxg:GridControl.View>
                <dxg:TableView ShowSearchPanelMode="Always" AutoWidth="True" AllowSorting="True" />
            </dxg:GridControl.View>

            <dxg:GridControl.ViewBehaviors>
                <dxg:FormatConditionCollection>
                    <!-- 중요한 과제 -->
                    <dxg:FormatCondition Expression="[IsImportant] = true" FieldName="IsImportant" Value="True" Format="Orange" />
                    <!-- 완료된 과제 -->
                    <dxg:FormatCondition Expression="[CompletionStatus] = true" FieldName="CompletionStatus" Value="True" Format="LightGray" />
                </dxg:FormatConditionCollection>
            </dxg:GridControl.ViewBehaviors>
        </dxg:GridControl>
    </Grid>
</Window>
4. TaskModel.cs (Model)
Task 데이터를 정의하는 모델입니다. 데이터 바인딩이 가능한 INotifyPropertyChanged 인터페이스를 구현하여 변경사항을 UI에 자동으로 반영합니다.

csharp
코드 복사
using System;
using System.ComponentModel;

namespace TaskManagement
{
    public class TaskModel : INotifyPropertyChanged
    {
        public int TaskID { get; set; }
        public string TaskName { get; set; }
        public string ProblemDescription { get; set; }
        public string ProgressStatus { get; set; }
        public bool CompletionStatus { get; set; }
        public DateTime RegistrationDate { get; set; }
        public DateTime? CompletionDate { get; set; }
        public int PriorityLevel { get; set; }
        public bool IsImportant { get; set; }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
5. TaskService.cs (데이터베이스 연동 서비스)
DB와 통신하는 클래스입니다. SqlConnection을 사용하여 MSSQL에서 데이터를 가져와서 TaskModel 객체 리스트로 반환합니다.

csharp
코드 복사
using System.Collections.Generic;
using System.Data.SqlClient;

namespace TaskManagement
{
    public class TaskService
    {
        private string connectionString = "your_connection_string_here"; // MSSQL 연결 문자열

        // DB에서 Task 데이터를 불러옴
        public List<TaskModel> GetTasks()
        {
            var tasks = new List<TaskModel>();
            string query = "SELECT * FROM Tasks";

            using (SqlConnection conn = new SqlConnection(connectionString))
            {
                conn.Open();
                using (SqlCommand cmd = new SqlCommand(query, conn))
                {
                    SqlDataReader reader = cmd.ExecuteReader();
                    while (reader.Read())
                    {
                        tasks.Add(new TaskModel
                        {
                            TaskID = reader.GetInt32(0),
                            TaskName = reader.GetString(1),
                            ProblemDescription = reader.GetString(2),
                            ProgressStatus = reader.GetString(3),
                            CompletionStatus = reader.GetBoolean(4),
                            RegistrationDate = reader.GetDateTime(5),
                            CompletionDate = reader.IsDBNull(6) ? (DateTime?)null : reader.GetDateTime(6),
                            PriorityLevel = reader.GetInt32(7),
                            IsImportant = reader.GetBoolean(8)
                        });
                    }
                }
            }
            return tasks;
        }
    }
}
6. MainViewModel.cs (ViewModel)
TaskService에서 데이터를 받아와서 ObservableCollection에 바인딩합니다. UI에서 데이터를 필터링하고, 완료 상태에 따라 정렬하는 기능도 제공합니다.

csharp
코드 복사
using DevExpress.Mvvm;
using System.Collections.ObjectModel;
using System.Linq;
using System.Windows.Input;

namespace TaskManagement
{
    public class MainViewModel : ViewModelBase
    {
        private TaskService _taskService;

        public ObservableCollection<TaskModel> TaskList { get; set; }

        public MainViewModel()
        {
            _taskService = new TaskService();
            LoadTasks();
        }

        // DB에서 Task 데이터를 로드
        private void LoadTasks()
        {
            var tasks = _taskService.GetTasks();
            TaskList = new ObservableCollection<TaskModel>(tasks);
        }

        // 완료된 Task만 필터링
        public void FilterCompletedTasks()
        {
            var filteredTasks = TaskList.Where(t => t.CompletionStatus == true).ToList();
            TaskList.Clear();
            foreach (var task in filteredTasks)
            {
                TaskList.Add(task);
            }
        }

        // 모든 Task 다시 로드
        public void ShowAllTasks()
        {
            LoadTasks();
        }

        // 우선순위별로 정렬
        public void SortByPriority()
        {
            var sortedTasks = TaskList.OrderBy(t => t.PriorityLevel).ToList();
            TaskList.Clear();
            foreach (var task in sortedTasks)
            {
                TaskList.Add(task);
            }
        }
    }
}
한글 설명
MSSQL 데이터베이스: Tasks 테이블에 과제명, 문제점, 진행 상태, 완료 여부, 등록일, 완료일, 중요도와 같은 데이터를 저장하고, 각 데이터를 식별하는 TaskID를 자동 증가값으로 설정했습니다.

MVVM 구조: MainViewModel이 중심이 되어 TaskService를 통해 DB에서 데이터를 받아와 TaskList로 관리하며, 이 ObservableCollection<TaskModel>은 UI에서 바인딩됩니다. TaskModel은 Task의 데이터를 정의하고, INotifyPropertyChanged를 구현하여 UI와 데이터 간의 자동 동기화를 지원합니다.

UI: GridControl을 사용하여 데이터를 테이블 형식으로 표시하고, 완료 여부나 중요도에 따른 조건부 서식을 적용하여 직관적인 UI를 제공합니다. 또한 ShowSearchPanelMode="Always" 속성을 통해 사용자가 데이터를 쉽게 검색할 수 있도록 했습니다.

추가 기능: 완료된 항목만 필터링할 수 있는 기능과 우선순위에 따라 정렬하는 기능을 MainViewModel에 구현하여 사용자가 데이터를 효율적으로 관리할 수 있도록 했습니다.

이 프로젝트는 MVVM 패턴을 철저히