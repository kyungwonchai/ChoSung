현재 보이는 표 데이터를 엑셀로 다운로드할 수 있도록 관련 코드를 제공합니다. Flask에서 이를 구현하기 위해 Pandas의 to_excel 메서드를 사용하여 데이터를 Excel 파일로 저장하고, 사용자에게 다운로드 링크를 제공합니다.

Flask 서버 코드 수정
python
코드 복사
from flask import Flask, render_template, request, make_response
import pandas as pd
import pymssql
import io

app = Flask(__name__)

@app.route('/PLCErr', methods=['GET'])
def plcerr():
    conn = get_db_connection()
    query = """
        SELECT 
            linename AS '라인명',
            errN AS '에러번호',
            errValue AS '에러값',
            CONVERT(VARCHAR, Time1, 121) AS '시간'
        FROM View_PLCErrjoin
    """
    df = pd.read_sql(query, conn)
    conn.close()

    # 검색 처리
    search_query = request.args.get("search", "").strip()
    if search_query:
        df = df[
            df["라인명"].str.contains(search_query, case=False, na=False) |
            df["에러번호"].astype(str).str.contains(search_query, case=False, na=False) |
            df["에러값"].astype(str).str.contains(search_query, case=False, na=False)
        ]

    # 페이지네이션 처리
    page = int(request.args.get("page", 1))
    per_page = 20
    total_pages = -(-len(df) // per_page)  # 총 페이지 수
    df_page = df.iloc[(page - 1) * per_page : page * per_page]

    return render_template(
        'plcerr.html',
        data=df_page.to_dict(orient='records'),
        search_query=search_query
    )

@app.route('/download_excel', methods=['GET'])
def download_excel():
    # 데이터 재생성 (현재 페이지의 데이터만 다운로드)
    conn = get_db_connection()
    query = """
        SELECT 
            linename AS '라인명',
            errN AS '에러번호',
            errValue AS '에러값',
            CONVERT(VARCHAR, Time1, 121) AS '시간'
        FROM View_PLCErrjoin
    """
    df = pd.read_sql(query, conn)
    conn.close()

    # 검색 조건 적용
    search_query = request.args.get("search", "").strip()
    if search_query:
        df = df[
            df["라인명"].str.contains(search_query, case=False, na=False) |
            df["에러번호"].astype(str).str.contains(search_query, case=False, na=False) |
            df["에러값"].astype(str).str.contains(search_query, case=False, na=False)
        ]

    # 페이지네이션 적용
    page = int(request.args.get("page", 1))
    per_page = 20
    df_page = df.iloc[(page - 1) * per_page : page * per_page]

    # 엑셀 파일 생성
    output = io.BytesIO()
    with pd.ExcelWriter(output, engine='openpyxl') as writer:
        df_page.to_excel(writer, index=False, sheet_name='PLCErr')

    # 응답 설정
    response = make_response(output.getvalue())
    response.headers['Content-Disposition'] = 'attachment; filename=PLCErr.xlsx'
    response.headers['Content-Type'] = 'application/vnd.openxmlformats-officedocument.spreadsheetml.sheet'
    return response
HTML 수정 (엑셀 다운로드 버튼 추가)
html
코드 복사
<div style="text-align: right; margin-bottom: 10px;">
    <form method="GET" action="/download_excel">
        <input type="hidden" name="search" value="{{ search_query }}">
        <input type="hidden" name="page" value="{{ current_page }}">
        <button 
            type="submit" 
            style="padding: 10px 20px; background-color: #00bcd4; color: white; border: none; border-radius: 5px; cursor: pointer;"
        >
            엑셀 다운로드
        </button>
    </form>
</div>
주요 구현 내용
Flask /download_excel 엔드포인트:

현재 페이지 데이터를 가져와 Excel 파일을 생성하고, 클라이언트에 반환합니다.
검색어와 페이지 정보를 쿼리 파라미터로 전달하여 데이터 필터링.
io.BytesIO를 사용한 메모리 내 Excel 생성:

Pandas의 to_excel 메서드를 사용하여 Excel 파일을 메모리에서 생성.
openpyxl 엔진을 사용하여 .xlsx 파일 생성.
HTML에서 엑셀 다운로드 버튼:

현재 검색어와 페이지 정보를 숨겨진 입력 필드로 전달하여 /download_excel 요청 시 필터링된 데이터를 생성.
버튼 클릭 시 해당 데이터를 엑셀로 다운로드.
페이지네이션과 검색 조건 유지:

search와 page 정보를 URL로 전달하여 현재 페이지 데이터만 다운로드.
테스트
엑셀 다운로드 버튼 클릭:

현재 페이지의 필터링된 데이터만 포함된 .xlsx 파일이 다운로드됩니다.
검색어 적용 확인:

검색 조건에 맞는 데이터만 다운로드되는지 확인하세요.
페이지네이션 확인:
