 관리를 쉽게 하기 위해서는 로그 레벨과 로그 카테고리를 구분하고, LogHelper 클래스에서 이를 처리할 수 있는 구조를 설계하는 것이 좋습니다. 로그 레벨은 일반적으로 Info, Debug, Warning, Error와 같은 수준별로 구분할 수 있고, 카테고리는 로그의 출처나 관심 영역(예: Communication, UI, Database) 등을 구분할 수 있습니다. 또한, 로그를 파일로 남길 때 파일을 나누거나 로그 뷰어를 통해 필터링할 수 있도록 구현할 수 있습니다.

1. 로그 레벨 및 카테고리 구분
먼저, 로그 메시지를 관리할 수 있는 LogLevel과 LogCategory라는 enum을 만들어서 로그의 타입을 구분합니다.

csharp
코드 복사
public enum LogLevel
{
    Info,
    Debug,
    Warning,
    Error
}

public enum LogCategory
{
    Communication,
    UI,
    Database,
    TaskQueue
}
2. LogHelper 클래스 확장
LogHelper 클래스에서 로그 레벨과 카테고리를 받아 처리하도록 변경합니다. 또한, 로그 메시지를 필터링하거나 로그 파일을 카테고리별로 나눠 기록할 수 있도록 설계할 수 있습니다.

csharp
코드 복사
public class LogHelper
{
    private static readonly object _lock = new object();
    private static readonly string logFilePath = "log.txt";

    // 로그를 파일에 남기거나 필요한 추가 처리를 위해 메서드를 확장
    public static void Log(LogLevel level, LogCategory category, string message)
    {
        string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} [{level}] [{category}] {message}";
        
        // 파일에 로그 기록
        lock (_lock)
        {
            System.IO.File.AppendAllText(logFilePath, logMessage + Environment.NewLine);
        }

        // 필요하면 로그 레벨에 따라 콘솔 출력 혹은 다른 처리를 추가 가능
        if (level == LogLevel.Error)
        {
            // 콘솔 또는 다른 서비스에 출력
            Console.WriteLine(logMessage);
        }
    }

    // 편의성을 위해 로그 레벨별로 바로 호출할 수 있는 메서드
    public static void LogInfo(LogCategory category, string message)
    {
        Log(LogLevel.Info, category, message);
    }

    public static void LogError(LogCategory category, string message)
    {
        Log(LogLevel.Error, category, message);
    }

    public static void LogWarning(LogCategory category, string message)
    {
        Log(LogLevel.Warning, category, message);
    }
    
    public static void LogDebug(LogCategory category, string message)
    {
        Log(LogLevel.Debug, category, message);
    }
}
3. ViewModel에서 로그 사용
이제 ViewModel에서 LogHelper를 사용하여 로그를 남길 때, 카테고리와 레벨을 지정할 수 있습니다.

csharp
코드 복사
public class MainViewModel : ViewModelBase
{
    public void ExecuteTask()
    {
        try
        {
            // 작업 수행 코드
            LogHelper.LogInfo(LogCategory.TaskQueue, "작업 시작");

            // 작업 수행 성공 시
            LogHelper.LogInfo(LogCategory.TaskQueue, "작업 성공");

        }
        catch (Exception ex)
        {
            // 오류 발생 시 로그 기록
            LogHelper.LogError(LogCategory.TaskQueue, $"작업 실패: {ex.Message}");
        }
    }

    public void CommunicateWithServer()
    {
        try
        {
            LogHelper.LogDebug(LogCategory.Communication, "서버와 통신 시작");

            // 통신 코드
            LogHelper.LogInfo(LogCategory.Communication, "서버 통신 성공");
        }
        catch (Exception ex)
        {
            LogHelper.LogError(LogCategory.Communication, $"서버 통신 실패: {ex.Message}");
        }
    }
}
4. 로그 파일 관리 및 필터링
로그 파일이 너무 커지지 않도록 파일을 일정 크기나 날짜별로 분할하거나, 로그 뷰어에서 카테고리별로 필터링할 수 있게 하는 추가 기능을 도입할 수 있습니다.

날짜별 파일 저장: 매일 새로운 로그 파일을 생성할 수 있습니다. 예를 들어, 파일 이름에 날짜를 추가하여 관리합니다.
csharp
코드 복사
private static string GetLogFilePath()
{
    string date = DateTime.Now.ToString("yyyy-MM-dd");
    return $"log_{date}.txt";
}
로그 뷰어: 로그를 뷰어에서 카테고리나 레벨로 필터링할 수 있도록 하면 관리가 더욱 편리합니다. WPF에서 간단한 로그 뷰어 UI를 만들어 로그를 출력하거나 검색할 수 있습니다.
5. LogHelper와 MVVM 패턴 연동
MVVM 패턴에서는 LogHelper에서 발생하는 로그를 ObservableCollection으로 바인딩해 UI에서 실시간으로 로그를 확인할 수 있게 할 수도 있습니다.

csharp
코드 복사
public class MainViewModel : ViewModelBase
{
    public ObservableCollection<string> LogMessages { get; private set; }

    public MainViewModel()
    {
        LogMessages = new ObservableCollection<string>();
        LogHelper.OnLogReceived += AddLogMessage;
    }

    private void AddLogMessage(string message)
    {
        // UI 바인딩을 위해 로그 메시지 추가
        App.Current.Dispatcher.Invoke(() => LogMessages.Add(message));
    }
}
이 방식으로 로그를 효율적으로 관리하고, 카테고리별, 레벨별로 쉽게 필터링할 수 있어 디버깅이나 로그 분석이 훨씬 수월해집니다.




