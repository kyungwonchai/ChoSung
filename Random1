DataContext.SendToPLCCommand와 같은 방식으로 명령을 사용했던 것은 명령(Command) 패턴을 활용한 것입니다. WPF에서는 MVVM 패턴을 사용하여 UI 요소와 데이터를 바인딩하고, 명령 패턴을 통해 버튼 클릭 등의 이벤트를 처리합니다.

기존 코드에서 사용된 명령 패턴
기존 코드에서 SendToPLCCommand와 같은 RelayCommand는 명령 패턴을 구현하여 ViewModel에서 정의된 메서드를 바인딩할 수 있게 해주는 역할을 합니다. 이러한 명령은 WPF의 ICommand 인터페이스를 구현하여 사용자의 액션(예: 버튼 클릭)을 ViewModel의 메서드에 연결합니다.

변경된 코드 설명
변경된 코드에서는 동적 버튼 생성을 위해 ButtonCommands라는 **ObservableCollection**을 사용하고 있습니다. 각 버튼이 개별적으로 생성되고 각 버튼에 명령이 바인딩되어 있으며, KeyValuePair 형식으로 명령을 컬렉션에 추가합니다. 이는 여러 버튼을 동적으로 생성하고, 각 버튼이 서로 다른 명령을 실행할 수 있도록 하는 유연성을 제공합니다.

왜 코드가 변경되었나?
기존의 코드 구조에서는 정적 버튼에 각각 명령을 직접 바인딩하는 방식이었다면, 변경된 코드에서는 버튼을 동적으로 생성하고, 각 버튼에 동적으로 명령을 바인딩하는 방식을 사용했습니다. 이렇게 변경한 이유는 다음과 같습니다:

유연성 증가: 버튼의 개수나 기능이 고정적이지 않고, 필요에 따라 동적으로 변경할 수 있는 경우가 생깁니다.
재사용성 향상: 한 번 정의된 명령을 다양한 UI 요소에 재사용할 수 있습니다.
코드 간소화: 중복되는 명령 정의를 줄이고, 명령의 정의를 보다 효율적으로 관리할 수 있습니다.
기존 방식과 새 방식의 차이
기존 방식: 개별 명령이 각각의 버튼에 직접 바인딩되며, UI 요소와 ViewModel 간의 명령 바인딩이 고정적이었습니다.
새 방식: 동적 버튼 생성 및 동적 명령 바인딩을 사용하여, UI 요소와 명령 바인딩이 유연하게 관리됩니다.
원래 방식으로 돌아가려면?
만약 기존 방식인 정적 명령 바인딩으로 돌아가길 원한다면, 아래와 같이 다시 코드를 작성하면 됩니다.

MainWindow.xaml
xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <StackPanel Orientation="Vertical" Margin="10">
            <!-- 기존 명령 바인딩을 위한 버튼 -->
            <Button Content="Send to PLC 0" Command="{Binding SendToPLCCommand}" CommandParameter="0" Margin="5"/>
            <Button Content="Send to PLC 1" Command="{Binding SendToPLCCommand}" CommandParameter="1" Margin="5"/>
            <Button Content="Send to PLC 2" Command="{Binding SendToPLCCommand}" CommandParameter="2" Margin="5"/>
            <Button Content="Send to PLC 3" Command="{Binding SendToPLCCommand}" CommandParameter="3" Margin="5"/>
            <Button Content="Send to PLC 4" Command="{Binding SendToPLCCommand}" CommandParameter="4" Margin="5"/>

            <!-- 텍스트박스와 전송 버튼 -->
            <TextBox x:Name="ValueInputTextBox" Width="200" Margin="5"/>
            <Button Content="텍스트 값 전송" Command="{Binding SendTextBoxValueCommand}" Margin="5" />

            <!-- DT2330 처리용 버튼 -->
            <Button Content="DT2330 처리" Command="{Binding ProcessDT2330Command}" Margin="5" />
        </StackPanel>
    </Grid>
</Window>
MainViewModel.cs
csharp
코드 복사
using System;
using System.ComponentModel;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        // 명령 생성
        public ICommand SendToPLCCommand { get; }
        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            // 명령 바인딩
            SendToPLCCommand = new RelayCommand<int>(async (number) => await SendNumberToPLC(number));
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        public async Task SendNumberToPLC(int number)
        {
            string command = $"%01#WDD0230000230{number:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(command);
            LogMessage($"Sent {number} to PLC");
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                await _comPortManager.SendDataToPLCAsync(command);
                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
요약
이렇게 수정하면 기존 명령 바인딩 방식으로 돌아가고, 버튼마다 고정된 명령을 사용하여 PLC에 값을 보낼 수 있습니다. 변경된 방식과 기존 방식을 모두 이해하여, 상황에 맞게 적용할 수 있습니다.

명령 패턴은 WPF에서 MVVM 패턴을 구현할 때 매우 유용하게 사용됩니다. 상황에 맞게 정적 명령 바인딩 또는 동적 명령 바인딩 방식을 선택하여 사용할 수 있습니