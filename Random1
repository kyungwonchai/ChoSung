아요! 그 에러는 아주 자주 발생하는 실수예요.
RelayCommand의 기본 생성자는 Action을 받지만,
ExecuteButtonCommand 함수의 시그니처가 void ExecuteButtonCommand(object parameter)처럼 파라미터가 있는 경우에는 타입이 달라서 에러가 납니다.

해결 방법 1: object 파라미터가 필요 없는 경우
csharp
코드 복사
// ViewModel
public ICommand ButtonCommand { get; }

public MainViewModel()
{
    ButtonCommand = new RelayCommand(ExecuteButtonCommand);
}

private void ExecuteButtonCommand()
{
    // 여기에 원하는 클래스 함수 호출
}
그리고 RelayCommand는 이렇게 정의돼 있어야 합니다:

csharp
코드 복사
public class RelayCommand : ICommand
{
    private readonly Action _execute;

    public RelayCommand(Action execute)
    {
        _execute = execute;
    }

    public bool CanExecute(object parameter) => true;

    public void Execute(object parameter)
    {
        _execute();
    }

    public event EventHandler CanExecuteChanged;
}
해결 방법 2: object 파라미터가 필요한 경우
만약 ExecuteButtonCommand(object param)처럼 파라미터가 꼭 필요한 함수를 연결하고 싶다면, RelayCommand<object>처럼 제네릭으로 만들어야 해요.

csharp
코드 복사
public class RelayCommand<T> : ICommand
{
    private readonly Action<T> _execute;

    public RelayCommand(Action<T> execute)
    {
        _execute = execute;
    }

    public bool CanExecute(object parameter) => true;

    public void Execute(object parameter)
    {
        _execute((T)parameter);
    }

    public event EventHandler CanExecuteChanged;
}
사용 예:

csharp
코드 복사
public ICommand ButtonCommand { get; }

public MainViewModel()
{
    ButtonCommand = new RelayCommand<object>(ExecuteButtonCommand);
}

private void ExecuteButtonCommand(object param)
{
    // param 사용 가능
}