Camera2Interop은 CameraX에서 Camera2 API에 대한 직접적인 제어를 가능하게 해주는 클래스입니다. 이 클래스는 androidx.camera.camera2.interop.Camera2Interop 패키지에 있으며, 이 기능을 사용하려면 추가적인 종속성을 build.gradle 파일에 추가해야 합니다.

1. build.gradle 파일 수정
먼저, Camera2Interop을 사용하기 위해 CameraX의 추가 라이브러리를 build.gradle에 추가해야 합니다.

gradle
코드 복사
dependencies {
    implementation "androidx.camera:camera-camera2:1.1.0"
    implementation "androidx.camera:camera-lifecycle:1.1.0"
    implementation "androidx.camera:camera-view:1.0.0-alpha32"
    implementation "androidx.camera:camera2:1.1.0"
    implementation 'com.google.mlkit:barcode-scanning:17.0.2'
}
이것은 CameraX 라이브러리에서 Camera2 기능을 활용하기 위한 종속성을 포함합니다.

2. 코드 수정
이제 Camera2Interop을 사용하여 초점 모드를 설정하는 부분을 수정한 전체 코드를 제공합니다.

kotlin
코드 복사
package com.dxmxsmd.mobilechecker

import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.util.Log
import android.widget.TextView
import androidx.activity.ComponentActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.camera.camera2.interop.Camera2Interop
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var viewFinder: PreviewView
    private lateinit var cameraExecutor: ExecutorService

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewFinder = findViewById(R.id.viewFinder)

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        cameraExecutor = Executors.newSingleThreadExecutor()
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder()
                .build()
                .also {
                    it.setSurfaceProvider(viewFinder.surfaceProvider)
                }

            val barcodeScanner = BarcodeScanning.getClient()

            val imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor, { imageProxy ->
                        processImageProxy(barcodeScanner, imageProxy)
                    })
                }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            val useCaseGroup = UseCaseGroup.Builder()
                .addUseCase(preview)
                .addUseCase(imageAnalysis)
                .build()

            try {
                cameraProvider.unbindAll()

                val camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, useCaseGroup
                )

                // Set continuous auto-focus mode using Camera2Interop
                val cameraControl = camera.cameraControl
                val camera2Interop = Camera2Interop.Extender(cameraControl)
                camera2Interop.setCaptureRequestOption(
                    CaptureRequest.CONTROL_AF_MODE,
                    CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                )

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    private fun processImageProxy(barcodeScanner: BarcodeScanner, imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        val rawValue = barcode.rawValue
                        findViewById<TextView>(R.id.text_view_result).text = rawValue
                    }
                }
                .addOnFailureListener {
                    // Handle failure
                }
                .addOnCompleteListener {
                    imageProxy.close()
                }
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)
    }
}
주요 사항:
Camera2Interop.Extender 사용:

Camera2Interop.Extender를 사용하여 CaptureRequest 옵션을 설정합니다. 이를 통해 연속 초점 모드(CONTROL_AF_MODE_CONTINUOUS_PICTURE)가 활성화됩니다.
UseCaseGroup 사용:

여러 UseCase를 그룹으로 묶어 한 번에 바인딩합니다. 이는 미리보기와 이미지 분석을 함께 수행하는 데 유용합니다.
종속성 추가:

build.gradle에 필요한 Camera2 및 관련 라이브러리 종속성을 추가했습니다.
이제 이 코드로 CameraX와 Camera2Interop을 통해 가능한 최적의 초점 조정 속도를 얻을 수 있습니다. 이 방법으로도 해결되지 않는다면, 하드웨어의 한계나 더 고급 카메라 API 사용을