문제 분석:

출력 로그를 보면, MainViewModel의 SaveChangesAsync 메서드는 시작되고(MainViewModel SaveChangesAsync 시작...), DbContext의 SaveChangesAsync 호출 시도 및 완료 로그(MainVM _context.SaveChangesAsync 완료. 결과 = 1)까지 정상적으로 나타납니다. 결과 = 1은 LockerAssignment 한 행이 성공적으로 DB에 추가되었음을 의미합니다.

하지만, 그 사이에 AuditLogInterceptor 관련 디버그 메시지가 전혀 없습니다. 이는 MainViewModel이 _context.SaveChangesAsync()를 호출했을 때, 우리가 만든 AuditLogInterceptor가 전혀 실행되지 않았다는 것을 의미합니다. 인터셉터가 실행되지 않으니 로그가 생성되지도, 저장되지도 않는 것입니다.

가장 유력한 원인:

인터셉터 등록 누락 또는 시점 오류: App.xaml.cs 파일의 OnStartup 메서드에서 DbInterception.Add(new AuditLogInterceptor()); 코드를 사용하여 인터셉터를 Entity Framework에 등록해야 하는데, 이 코드가 누락되었거나, 애플리케이션의 첫 번째 DbContext 인스턴스(아마도 MainViewModel의 _context)가 생성된 이후에 호출되었을 수 있습니다. 인터셉터는 관련된 DbContext가 처음 사용되기 전에 등록되어야 합니다.
해결 방향:

App.xaml.cs 확인 및 수정: OnStartup 메서드 시작 부분에서 DbInterception.Add(new AuditLogInterceptor()); 코드가 반드시 호출되도록 확인하고 수정합니다.
AuditLogInterceptor.cs 재확인: 인터셉터 코드 자체는 이전 단계에서 디버깅 코드가 추가된 상태로 유지합니다.
수정해야 할 파일 목록:

App.xaml.cs
Infrastructure/AuditLogInterceptor.cs (확인용으로 최종본 재제공)
아래에 이 두 파일의 수정된 전체 코드(주석 제외)를 작성합니다.

1. App.xaml.cs (수정)

OnStartup 메서드에서 DbInterception.Add() 호출을 확인하고, 전역 예외 처리기도 유지합니다.

C#

using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using System.Data.Entity.Infrastructure.Interception; // DbInterception 사용
using LockerManagementApp.Infrastructure; // AuditLogInterceptor 네임스페이스

namespace LockerManagementApp
{
    public partial class App : Application
    {
        public static bool IsShuttingDown { get; private set; } = false;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // *** 중요: 인터셉터 등록 ***
            // DbContext가 처음 사용되기 전에 인터셉터를 등록해야 합니다.
            DbInterception.Add(new AuditLogInterceptor());
            Debug.WriteLine("AuditLogInterceptor 등록 완료.");

            SetupGlobalExceptionHandling();
            Debug.WriteLine("애플리케이션 시작됨.");
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Debug.WriteLine("애플리케이션 종료 시작됨.");
            IsShuttingDown = true;
            base.OnExit(e);
            Debug.WriteLine("애플리케이션 종료 완료.");
        }

        #region 전역 예외 처리 (Global Exception Handling)
        private void SetupGlobalExceptionHandling()
        {
            DispatcherUnhandledException += App_DispatcherUnhandledException;
            TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            Debug.WriteLine("전역 예외 처리기 설정 완료.");
        }
        private void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) { Debug.WriteLine("--- DispatcherUnhandledException 발생 ---"); LogAndShowException(e.Exception, "UI Thread Exception"); e.Handled = true; }
        private void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e) { Debug.WriteLine("--- TaskScheduler_UnobservedTaskException 발생 ---"); LogAndShowException(e.Exception, "Background Task Exception"); e.SetObserved(); }
        private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) { Debug.WriteLine("--- CurrentDomain_UnhandledException 발생 ---"); LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception", !e.IsTerminating); }
        private void LogAndShowException(Exception exception, string source, bool showMessageBox = true) { string errorMessage = $"예기치 않은 오류 발생 ({source}):\n\n{exception.ToString()}"; Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}"); if (showMessageBox && !IsShuttingDown) { try { MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception msgEx) { Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}"); } } }
        #endregion
    }
}
2. Infrastructure/AuditLogInterceptor.cs (최종 확인용)

(이전 단계에서 제공한 디버깅 강화 버전과 동일)

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Validation;

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}";

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.NonQueryExecuting: Interceptor called.");
            GenerateAuditLogs(interceptionContext);
        }

        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            SaveAuditLogs(interceptionContext);
        }

        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Starting log generation...");
            foreach (var context in interceptionContext.DbContexts)
            {
                if (!(context is LockerDbContext dbContext)) { Debug.WriteLine($"  -> Context is not LockerDbContext type. Skipping."); continue; }

                bool hasChanges = false;
                try { hasChanges = dbContext.ChangeTracker.HasChanges(); Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}' HasChanges = {hasChanges}"); }
                catch (Exception ex) { Debug.WriteLine($"  !!! Context '{dbContext.GetHashCode()}' HasChanges 확인 중 오류: {ex.Message}"); continue; }
                if (!hasChanges) { Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}' 변경 사항 없음. Skipping."); continue; }

                bool isMaster = dbContext.IsMasterSave;
                string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
                string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

                if (!changedEntries.Any()) { Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}' HasChanges는 True였으나, 필터링된 changedEntries 없음. Skipping."); continue; }
                Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨 (isMaster={isMaster}).");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) { Debug.WriteLine("    - AuditLog 엔티티 변경 감지됨 (로깅 건너뜀)."); continue; }

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added)
                    {
                        Debug.WriteLine($"    - Added 상태 감지됨: {auditEntry.TableName}");
                        foreach (var pn in entry.CurrentValues.PropertyNames) { newValues[pn] = entry.CurrentValues[pn]; }
                        Debug.WriteLine($"    - Added 로그 NewValues 생성 시도...");
                        try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); Debug.WriteLine($"    - Added 로그 NewValues 직렬화 성공."); }
                        catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; }
                    }
                    else if (entry.State == EntityState.Deleted) { Debug.WriteLine($"    - Deleted 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } Debug.WriteLine($"    - Deleted 로그 데이터 생성 완료."); }
                    else if (entry.State == EntityState.Modified) { Debug.WriteLine($"    - Modified 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); bool propertyChanged = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { propertyChanged = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (propertyChanged) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } Debug.WriteLine($"    - Modified 로그 데이터 생성 완료."); } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                    if (auditEntry != null) { Debug.WriteLine($"    -> auditEntries 리스트에 추가 시도: {auditEntry.TableName}, Action: {auditEntry.Action}"); auditEntries.Add(auditEntry); Debug.WriteLine($"    -> auditEntries 리스트에 추가 완료. 현재 리스트 개수: {auditEntries.Count}. 추가된 로그 정보: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}, User: {auditEntry.UserName}"); }
                    else { Debug.WriteLine($"    !!! 로그 객체 생성 실패? ({entry.Entity.GetType().Name})"); }
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any()) { string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode()); interceptionContext.UserState = auditEntries; Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장."); }
                 dbContext.IsMasterSave = false;
            }
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Log generation finished.");
        }

        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            List<AuditLog> auditEntries = interceptionContext.UserState as List<AuditLog>;
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges 시작. UserState에서 가져온 로그 수 = {auditEntries?.Count ?? 0}");
            if (auditEntries != null && auditEntries.Any()) { foreach(var log in auditEntries) Debug.WriteLine($"  - 저장 대상 로그: {log.Action} on {log.TableName} by {log.UserName}"); }

            if (interceptionContext.Exception == null && auditEntries != null && auditEntries.Any())
            {
                try { using (var logContext = new Data.LockerDbContext()) { Debug.WriteLine($"  -> {auditEntries.Count}개 로그 저장 시도 (새 Context 사용)..."); logContext.AuditLogs.AddRange(auditEntries); Debug.WriteLine($"  -> logContext.SaveChanges() 호출 시도..."); int logResult = logContext.SaveChanges(); Debug.WriteLine($"  -> 로그 저장 완료. 결과 = {logResult}"); } }
                catch (DbEntityValidationException vex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Validation): {vex.ToString()}"); LogValidationErrors(vex); }
                catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Update): {dbEx.ToString()}"); LogDbUpdateException(dbEx); }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - General): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"  -> 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"  -> 저장할 로그 없음."); }
            interceptionContext.UserState = null;
        }

        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) { try { var objectContext = ((IObjectContextAdapter)context).ObjectContext; var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity); if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) { return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value)); } if (entry.State == EntityState.Added) return "New"; } catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); } return "N/A"; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
    }
}
핵심 변경 사항:

App.xaml.cs: OnStartup 메서드에서 DbInterception.Add(new AuditLogInterceptor());를 호출하여 인터셉터가 애플리케이션 시작 시 등록되도록 했습니다.
AuditLogInterceptor.cs: 'Added' 상태 처리 및 로그 저장 단계의 디버깅 출력을 유지했습니다.
다음 단계:

코드 적용 및 빌드: 위 코드로 해당 파일들을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
메인 화면(사물함 관리) 에서 새로운 행을 추가하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 확인합니다.
AuditLogInterceptor.NonQueryExecuting: Interceptor called. 메시지가 나타나나요?
AuditLogInterceptor.GenerateAuditLogs: Starting log generation... 메시지가 나타나나요?
Context '...' 에서 ...개 변경 감지됨... 메시지가 나타나나요?
Added 상태 감지됨: LockerAssignment 메시지가 나타나나요?
UserState에 저장. 메시지가 나타나나요?
AuditLogInterceptor.SavedChanges 시작... 메시지가 나타나나요?
로그 저장 완료. 결과 = 1 메시지가 나타나나요?
로그 보기 창 확인: 저장 작업 후, "로그 보기" 창을 열어 'Added' 로그가 기록되었는지 확인합니다.
만약 App.xaml.cs에서 인터셉터 등록이 누락되었던 것이 원인이라면, 이제 인