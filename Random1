네, WPF 프로그램 간 안정적인 소켓 통신을 구현하여 원격 PC의 모니터를 제어하고, 이 명령을 다른 PC로 중계하는 시스템을 구축하는 것은 충분히 가능합니다. 안정성을 최우선으로 고려하고 SOLID 원칙과 디자인 패턴을 적용하여 간결하고 가독성 좋은 코드를 만드는 데 중점을 두겠습니다.

핵심 요구사항 분석

절대적인 안정성: 연결 끊김, 프로그램 비정상 종료, 메모리 누수 방지.
명령 전달: 특정 IP로 명령 전송.
명령 중계 (토스): 특정 IP로부터 받은 명령을 다른 IP로 전달.
명령 실행: 특정 IP로부터 받은 명령을 로컬에서 실행.
SOLID 원칙 및 디자인 패턴 준수: 유지보수 용이, 확장성 고려.
간결하고 가독성 좋은 코드.
사용 시나리오: 어느 PC에서든 다른 PC의 모니터 제어 (절전/끄기/켜기), 중계를 통해 또 다른 PC 제어.
구조 설계 제안

안정성과 각 기능의 분리를 위해 다음과 같은 클래스 및 인터페이스를 제안합니다.

ICommand 인터페이스 및 Command 클래스: 통신에 사용될 명령의 규격.
ISocketCommunicator 인터페이스: 소켓 통신의 핵심 로직 추상화.
SocketCommunicator 클래스: ISocketCommunicator의 구현체. TCP/IP 기반으로 메시지 프레이밍, 비동기 송수신, 연결 관리, 오류 처리, 자동 재연결 시도 등을 담당.
ICommandHandler 인터페이스: 수신된 명령을 처리하는 로직 추상화.
LocalCommandExecutor 클래스: 로컬 PC에서 명령을 실행 (예: 모니터 제어). ICommandHandler 구현.
RelayCommandHandler 클래스: 명령을 다른 PC로 중계. ICommandHandler 구현.
CommandProcessor 클래스: 수신된 명령을 분석하여 적절한 ICommandHandler에게 위임.
NetworkServiceManager (Facade 패턴): WPF 애플리케이션이 상호작용할 단일 진입점. SocketCommunicator를 초기화하고, CommandProcessor를 통해 명령을 라우팅.
메시지 프레이밍의 중요성

TCP는 스트림 기반 프로토콜이므로, 메시지의 경계를 명확히 구분해야 합니다. 일반적인 방법은 다음과 같습니다:

길이 접두사 (Length Prefixing): 각 메시지 앞에 4바이트(예시)로 메시지의 길이를 먼저 보내고, 그 다음에 실제 메시지를 보냅니다. 수신 측은 길이를 먼저 읽고, 그 길이만큼 데이터를 읽어 하나의 완전한 메시지로 처리합니다. JSON과 같은 텍스트 기반 메시지에 매우 효과적입니다.
클래스 설계 (C# 예시)

1. 명령 (Command.cs)

C#

using System.Text.Json;
using System.Text.Json.Serialization;

public enum CommandAction
{
    Execute, // 로컬 실행
    Relay    // 다른 IP로 중계
}

public enum MonitorCommandType
{
    Off,
    On,
    Sleep
}

// 실제 통신에 사용될 명령 패킷
public class CommandPacket
{
    public CommandAction Action { get; set; }
    public string? TargetIpForRelay { get; set; } // Action이 Relay일 경우, 중계 대상 IP
    public string CommandType { get; set; } = string.Empty; // 예: "MONITOR_CONTROL", "SYSTEM_SHUTDOWN"
    public string Payload { get; set; } = string.Empty; // 실제 명령 내용 (예: JSON 직렬화된 MonitorCommand)

    // 직렬화/역직렬화 헬퍼
    public string ToJson() => JsonSerializer.Serialize(this);
    public static CommandPacket? FromJson(string json) => JsonSerializer.Deserialize<CommandPacket>(json);
}

// 모니터 제어 명령의 페이로드 예시
public class MonitorControlPayload
{
    public MonitorCommandType MonitorAction { get; set; }
    // 필요시 추가 파라미터

    public string ToJson() => JsonSerializer.Serialize(this);
    public static MonitorControlPayload? FromJson(string json) => JsonSerializer.Deserialize<MonitorControlPayload>(json);
}
2. 소켓 통신 인터페이스 및 구현 (SocketCommunicator.cs)

안정성을 위해 TcpClient와 TcpListener를 사용하고, 모든 네트워크 작업은 async/await를 사용하여 비동기적으로 처리합니다. CancellationToken을 사용하여 작업을 안전하게 취소할 수 있도록 합니다.

C#

using System;
using System.Collections.Concurrent;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public interface ISocketCommunicator : IDisposable
{
    Task StartListeningAsync(int port, CancellationToken cancellationToken);
    Task SendCommandAsync(string targetIp, int targetPort, CommandPacket command);
    event Func<CommandPacket, string, Task>? CommandReceivedAsync; // CommandPacket, SourceIP
    event Action<string, string>? LogMessage; // Message, Level (INFO, ERROR)
    event Action<string>? ClientConnected; // Client IP
    event Action<string>? ClientDisconnected; // Client IP
}

public class SocketCommunicator : ISocketCommunicator
{
    private TcpListener? _listener;
    private readonly ConcurrentDictionary<string, TcpClient> _connectedClients = new ConcurrentDictionary<string, TcpClient>();
    private readonly int _bufferSize = 4096; // 4KB
    private readonly TimeSpan _connectTimeout = TimeSpan.FromSeconds(5);
    private readonly TimeSpan _keepAliveInterval = TimeSpan.FromSeconds(30); // TCP Keep-alive (OS level)

    public event Func<CommandPacket, string, Task>? CommandReceivedAsync;
    public event Action<string, string>? LogMessage;
    public event Action<string>? ClientConnected;
    public event Action<string>? ClientDisconnected;


    public async Task StartListeningAsync(int port, CancellationToken cancellationToken)
    {
        if (_listener != null)
        {
            LogMessage?.Invoke($"Listener already started on port {port}.", "INFO");
            return;
        }

        try
        {
            _listener = new TcpListener(IPAddress.Any, port);
            _listener.Start();
            LogMessage?.Invoke($"Server started. Listening on port {port}...", "INFO");

            while (!cancellationToken.IsCancellationRequested)
            {
                TcpClient client = await _listener.AcceptTcpClientAsync(cancellationToken).ConfigureAwait(false);
                string clientIp = ((IPEndPoint)client.Client.RemoteEndPoint!).Address.ToString();
                LogMessage?.Invoke($"Client connected: {clientIp}", "INFO");
                ClientConnected?.Invoke(clientIp);

                // TCP Keep-Alive 설정 (OS 레벨에서 관리)
                SetKeepAlive(client.Client, (ulong)_keepAliveInterval.TotalMilliseconds, 1000UL);


                if (_connectedClients.TryAdd(clientIp, client)) // 간단히 IP로 관리, 더 복잡한 경우 고유 ID 사용
                {
                    // 클라이언트별로 독립적인 처리 루프 시작 (메모리 누수 방지 위해 Task 반환값 관리 필요시 조정)
                    _ = HandleClientAsync(client, clientIp, cancellationToken);
                }
                else
                {
                    LogMessage?.Invoke($"Failed to add client {clientIp} to connected list. Closing connection.", "WARN");
                    client.Close(); // Dispose는 HandleClientAsync에서 최종적으로 처리
                }
            }
        }
        catch (OperationCanceledException)
        {
            LogMessage?.Invoke("Listening operation was canceled.", "INFO");
        }
        catch (SocketException ex)
        {
            LogMessage?.Invoke($"SocketException in StartListeningAsync: {ex.Message}", "ERROR");
        }
        catch (Exception ex)
        {
            LogMessage?.Invoke($"Error in StartListeningAsync: {ex.Message}", "ERROR");
        }
        finally
        {
            StopListening();
        }
    }

    private void SetKeepAlive(Socket socket, ulong time, ulong interval)
    {
        try
        {
            // byte representations of true, time, interval
            byte[] SIO_KEEPALIVE_VALS = new byte[12];
            BitConverter.GetBytes(1U).CopyTo(SIO_KEEPALIVE_VALS, 0); // on/off
            BitConverter.GetBytes(time).CopyTo(SIO_KEEPALIVE_VALS, 4); // time ms
            BitConverter.GetBytes(interval).CopyTo(SIO_KEEPALIVE_VALS, 8); // interval ms

            socket.IOControl(IOControlCode.KeepAliveValues, SIO_KEEPALIVE_VALS, null);
        }
        catch (Exception ex)
        {
            LogMessage?.Invoke($"Failed to set TCP Keep-Alive: {ex.Message}", "WARN");
        }
    }


    private async Task HandleClientAsync(TcpClient client, string clientIp, CancellationToken cancellationToken)
    {
        try
        {
            using (client) // Ensure client is disposed when this method exits
            using (var stream = client.GetStream())
            {
                byte[] lengthBuffer = new byte[4]; // 메시지 길이 저장 버퍼 (int = 4 bytes)

                while (client.Connected && !cancellationToken.IsCancellationRequested)
                {
                    // 1. 메시지 길이 읽기
                    int bytesRead = await ReadExactlyAsync(stream, lengthBuffer, 0, 4, cancellationToken).ConfigureAwait(false);
                    if (bytesRead == 0) break; // 연결 종료

                    int messageLength = BitConverter.ToInt32(lengthBuffer, 0);
                    if (messageLength <= 0 || messageLength > 1024 * 1024) // 1MB 이상 메시지 거부 (DoS 방지)
                    {
                        LogMessage?.Invoke($"Invalid message length received from {clientIp}: {messageLength}. Closing connection.", "WARN");
                        break;
                    }

                    // 2. 실제 메시지 읽기
                    byte[] messageBuffer = new byte[messageLength];
                    bytesRead = await ReadExactlyAsync(stream, messageBuffer, 0, messageLength, cancellationToken).ConfigureAwait(false);
                    if (bytesRead == 0) break; // 연결 종료

                    string messageJson = Encoding.UTF8.GetString(messageBuffer, 0, bytesRead);
                    CommandPacket? command = CommandPacket.FromJson(messageJson);

                    if (command != null && CommandReceivedAsync != null)
                    {
                        await CommandReceivedAsync(command, clientIp).ConfigureAwait(false);
                    }
                    else if (command == null)
                    {
                        LogMessage?.Invoke($"Failed to deserialize command from {clientIp}. JSON: {messageJson}", "WARN");
                    }
                }
            }
        }
        catch (OperationCanceledException)
        {
            LogMessage?.Invoke($"Client handling for {clientIp} was canceled.", "INFO");
        }
        catch (IOException ex) when (ex.InnerException is SocketException se)
        {
            LogMessage?.Invoke($"IOException (SocketException) with client {clientIp}: {se.Message}. ErrorCode: {se.SocketErrorCode}", "ERROR");
        }
        catch (IOException ex)
        {
            LogMessage?.Invoke($"IOException with client {clientIp}: {ex.Message}", "ERROR");
        }
        catch (Exception ex)
        {
            LogMessage?.Invoke($"Error handling client {clientIp}: {ex.Message}", "ERROR");
        }
        finally
        {
            if (_connectedClients.TryRemove(clientIp, out TcpClient? removedClient))
            {
                // removedClient는 using 문에 의해 이미 Dispose될 예정이거나 Dispose 되었음.
                // 명시적으로 Close()를 호출할 필요는 없지만, 안전을 위해 호출 가능 (이미 닫혔다면 무시됨)
                removedClient?.Close();
            }
            LogMessage?.Invoke($"Client disconnected: {clientIp}", "INFO");
            ClientDisconnected?.Invoke(clientIp);
        }
    }

    // 정확히 요청된 바이트 수만큼 읽거나, 스트림이 끝나거나, 취소될 때까지 읽는 헬퍼 메서드
    private async Task<int> ReadExactlyAsync(NetworkStream stream, byte[] buffer, int offset, int count, CancellationToken cancellationToken)
    {
        int totalBytesRead = 0;
        while (totalBytesRead < count)
        {
            int bytesRead = await stream.ReadAsync(buffer, offset + totalBytesRead, count - totalBytesRead, cancellationToken).ConfigureAwait(false);
            if (bytesRead == 0) // 스트림 끝 (연결 종료)
            {
                return totalBytesRead;
            }
            totalBytesRead += bytesRead;
        }
        return totalBytesRead;
    }


    public async Task SendCommandAsync(string targetIp, int targetPort, CommandPacket command)
    {
        TcpClient? client = null;
        NetworkStream? stream = null;
        string? connectedClientKey = null; // 실제 연결된 IP:Port (NAT 환경 등 고려)

        try
        {
            // 기존 연결 재사용 시도 (실제로는 더 정교한 연결 풀링 또는 관리 필요)
            // 여기서는 매번 새 연결을 생성하는 것으로 간소화.
            // 안정적인 단일 연결을 유지하려면 ConnectAsync를 별도로 호출하고 그 TcpClient를 재사용.

            client = new TcpClient();
            SetKeepAlive(client.Client, (ulong)_keepAliveInterval.TotalMilliseconds, 1000UL);

            // 연결 시도 (비동기, 타임아웃 적용)
            var connectTask = client.ConnectAsync(targetIp, targetPort);
            if (await Task.WhenAny(connectTask, Task.Delay(_connectTimeout)).ConfigureAwait(false) != connectTask || !client.Connected)
            {
                if (!client.Connected) client.Close(); // 연결 실패 시 정리
                throw new SocketException((int)SocketError.TimedOut);
            }
            
            stream = client.GetStream();
            connectedClientKey = ((IPEndPoint)client.Client.RemoteEndPoint!).ToString(); // 로깅용
            LogMessage?.Invoke($"Connected to {connectedClientKey} for sending command.", "INFO");

            string jsonCommand = command.ToJson();
            byte[] messageBytes = Encoding.UTF8.GetBytes(jsonCommand);
            byte[] lengthPrefix = BitConverter.GetBytes(messageBytes.Length);

            // 1. 길이 접두사 전송
            await stream.WriteAsync(lengthPrefix, 0, lengthPrefix.Length).ConfigureAwait(false);
            // 2. 실제 메시지 전송
            await stream.WriteAsync(messageBytes, 0, messageBytes.Length).ConfigureAwait(false);
            await stream.FlushAsync().ConfigureAwait(false);

            LogMessage?.Invoke($"Command '{command.CommandType}' sent to {targetIp}:{targetPort}.", "INFO");
        }
        catch (SocketException ex)
        {
            LogMessage?.Invoke($"SocketException when sending to {targetIp}:{targetPort}: {ex.Message} (Code: {ex.SocketErrorCode})", "ERROR");
            // 재시도 로직 또는 사용자 알림 등을 여기에 추가할 수 있습니다.
            throw; // 호출자에게 예외를 다시 던져서 처리하도록 함
        }
        catch (Exception ex)
        {
            LogMessage?.Invoke($"Error sending command to {targetIp}:{targetPort}: {ex.Message}", "ERROR");
            throw;
        }
        finally
        {
            // 중요: SendCommandAsync가 일회성 전송 후 연결을 닫는다면 아래 코드가 맞습니다.
            // 만약 연결을 유지하고 싶다면, client와 stream을 닫지 않고 관리해야 합니다.
            // 이 예제에서는 "명령 전달" 기능에 초점을 맞춰 일회성으로 처리합니다.
            stream?.Close(); // 스트림을 닫으면 내부적으로 Flush도 호출될 수 있음
            client?.Close(); // TcpClient를 닫으면 연결된 소켓과 스트림도 해제됨
            if (connectedClientKey != null)
            {
                LogMessage?.Invoke($"Disconnected from {connectedClientKey} after sending command.", "INFO");
            }
        }
    }

    private void StopListening()
    {
        try
        {
            _listener?.Stop();
            _listener = null;
            LogMessage?.Invoke("Listener stopped.", "INFO");

            foreach (var clientPair in _connectedClients)
            {
                clientPair.Value.Close(); // Dispose는 HandleClientAsync의 finally 블록에서 처리
            }
            _connectedClients.Clear();
        }
        catch (Exception ex)
        {
            LogMessage?.Invoke($"Error stopping listener: {ex.Message}", "ERROR");
        }
    }

    public void Dispose()
    {
        StopListening();
        // 추가적인 관리 리소스가 있다면 여기서 해제
        GC.SuppressFinalize(this);
    }
}
3. 명령 처리기 인터페이스 및 구현 (CommandHandler.cs)

C#

using System;
using System.Runtime.InteropServices; // For P/Invoke
using System.Threading.Tasks;


public interface ICommandHandler
{
    // sourceIp는 명령을 보낸 클라이언트의 IP
    Task HandleAsync(CommandPacket command, string sourceIp);
}

// 로컬 명령 실행기 (예: 모니터 제어)
public class LocalCommandExecutor : ICommandHandler
{
    private Action<string, string> _logMessage; // 로깅 델리게이트

    // Windows API 상수 (모니터 제어용)
    private const int HWND_BROADCAST = 0xFFFF;
    private const int WM_SYSCOMMAND = 0x0112;
    private const int SC_MONITORPOWER = 0xF170;
    private const int MONITOR_ON = -1;
    private const int MONITOR_LOW_POWER = 1; // 절전
    private const int MONITOR_OFF = 2;       // 끄기

    [DllImport("user32.dll", CharSet = CharSet.Auto)]
    private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

    public LocalCommandExecutor(Action<string, string> logMessage)
    {
        _logMessage = logMessage;
    }

    public Task HandleAsync(CommandPacket command, string sourceIp)
    {
        _logMessage?.Invoke($"Executing local command '{command.CommandType}' from {sourceIp}. Payload: {command.Payload}", "INFO");

        if (command.CommandType == "MONITOR_CONTROL")
        {
            MonitorControlPayload? monitorPayload = MonitorControlPayload.FromJson(command.Payload);
            if (monitorPayload != null)
            {
                switch (monitorPayload.MonitorAction)
                {
                    case MonitorCommandType.On:
                        SetMonitorState(MONITOR_ON);
                        _logMessage?.Invoke("Monitor turned ON.", "ACTION");
                        break;
                    case MonitorCommandType.Off:
                        SetMonitorState(MONITOR_OFF);
                        _logMessage?.Invoke("Monitor turned OFF.", "ACTION");
                        break;
                    case MonitorCommandType.Sleep:
                        SetMonitorState(MONITOR_LOW_POWER);
                        _logMessage?.Invoke("Monitor set to SLEEP.", "ACTION");
                        break;
                }
            }
            else
            {
                 _logMessage?.Invoke($"Failed to deserialize MonitorControlPayload from {command.Payload}", "WARN");
            }
        }
        // 다른 로컬 실행 명령들...
        return Task.CompletedTask;
    }

    private void SetMonitorState(int state)
    {
        // WPF 애플리케이션에서는 UI 스레드에서 호출해야 할 수도 있으나,
        // SendMessage는 일반적으로 스레드에 안전합니다.
        // 만약 특정 UI 요소와 상호작용해야 한다면 Dispatcher 사용.
        SendMessage((IntPtr)HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)state);
    }
}

// 명령 중계기
public class RelayCommandHandler : ICommandHandler
{
    private readonly ISocketCommunicator _communicator;
    private readonly int _defaultRelayPort; // 중계 대상 PC가 리슨하는 포트
    private Action<string, string> _logMessage;

    public RelayCommandHandler(ISocketCommunicator communicator, int defaultRelayPort, Action<string, string> logMessage)
    {
        _communicator = communicator;
        _defaultRelayPort = defaultRelayPort;
        _logMessage = logMessage;
    }

    public async Task HandleAsync(CommandPacket command, string sourceIp)
    {
        if (string.IsNullOrEmpty(command.TargetIpForRelay))
        {
            _logMessage?.Invoke($"Relay command from {sourceIp} is missing TargetIpForRelay.", "WARN");
            return;
        }

        _logMessage?.Invoke($"Relaying command '{command.CommandType}' from {sourceIp} to {command.TargetIpForRelay}. Payload: {command.Payload}", "INFO");

        // 중계할 때는 Action을 Execute로 변경하고 TargetIpForRelay는 비운다.
        var commandToRelay = new CommandPacket
        {
            Action = CommandAction.Execute, // 중계받는 쪽에서는 직접 실행하도록
            CommandType = command.CommandType,
            Payload = command.Payload
            // TargetIpForRelay는 여기서는 설정하지 않음 (이미 사용됨)
        };

        try
        {
            // TODO: 포트 번호를 명령에 포함하거나 설정에서 가져오도록 개선 가능
            await _communicator.SendCommandAsync(command.TargetIpForRelay, _defaultRelayPort, commandToRelay);
            _logMessage?.Invoke($"Successfully relayed command to {command.TargetIpForRelay}.", "INFO");
        }
        catch (Exception ex)
        {
            _logMessage?.Invoke($"Failed to relay command to {command.TargetIpForRelay}: {ex.Message}", "ERROR");
            // 실패 처리 (예: 원 요청자에게 알림)
        }
    }
}
4. 명령 처리기 (CommandProcessor.cs)

C#

using System;
using System.Threading.Tasks;

public class CommandProcessor
{
    private readonly ICommandHandler _localExecutor;
    private readonly ICommandHandler _relayHandler;
    private Action<string, string> _logMessage;


    public CommandProcessor(ICommandHandler localExecutor, ICommandHandler relayHandler, Action<string, string> logMessage)
    {
        _localExecutor = localExecutor;
        _relayHandler = relayHandler;
        _logMessage = logMessage;
    }

    public async Task ProcessIncomingCommandAsync(CommandPacket command, string sourceIp)
    {
        _logMessage?.Invoke($"Processing command Action: {command.Action}, Type: {command.CommandType} from {sourceIp}", "DEBUG");
        switch (command.Action)
        {
            case CommandAction.Execute:
                await _localExecutor.HandleAsync(command, sourceIp);
                break;
            case CommandAction.Relay:
                await _relayHandler.HandleAsync(command, sourceIp);
                break;
            default:
                 _logMessage?.Invoke($"Unknown command action: {command.Action}", "WARN");
                break;
        }
    }
}
5. NetworkServiceManager.cs (Facade)

C#

using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows; // For Dispatcher (UI 업데이트용)

public class NetworkServiceManager : IDisposable
{
    private readonly ISocketCommunicator _communicator;
    private readonly CommandProcessor _commandProcessor;
    private readonly CancellationTokenSource _cts = new CancellationTokenSource();
    private readonly int _listeningPort;
    private readonly int _defaultRemotePort; // 명령 전송 시 기본 대상 포트

    // WPF UI 업데이트를 위한 이벤트들 (Dispatcher 사용 필요)
    public event Action<string>? LogReceived; // 로그 메시지
    public event Action<string>? PeerConnected;
    public event Action<string>? PeerDisconnected;
    public event Action<string, string>? CommandExecutedRemotely; // 실행된 명령, 대상 IP

    public NetworkServiceManager(int listeningPort, int defaultRemotePort)
    {
        _listeningPort = listeningPort;
        _defaultRemotePort = defaultRemotePort;

        // 로깅 델리게이트
        Action<string, string> logger = (message, level) => {
            string logEntry = $"[{level}] {DateTime.Now:HH:mm:ss}: {message}";
            Application.Current?.Dispatcher.Invoke(() => LogReceived?.Invoke(logEntry));
            // Console.WriteLine(logEntry); // 콘솔에도 출력 (디버깅용)
        };

        _communicator = new SocketCommunicator();
        _communicator.LogMessage += logger;
        _communicator.CommandReceivedAsync += OnCommandReceivedFromNetwork;
        _communicator.ClientConnected += (ip) => Application.Current?.Dispatcher.Invoke(() => PeerConnected?.Invoke(ip));
        _communicator.ClientDisconnected += (ip) => Application.Current?.Dispatcher.Invoke(() => PeerDisconnected?.Invoke(ip));


        var localExecutor = new LocalCommandExecutor(logger);
        var relayHandler = new RelayCommandHandler(_communicator, defaultRemotePort, logger); // 중계 시 사용할 포트
        _commandProcessor = new CommandProcessor(localExecutor, relayHandler, logger);
    }

    private Task OnCommandReceivedFromNetwork(CommandPacket command, string sourceIp)
    {
        // 네트워크 스레드에서 호출되므로, CommandProcessor는 스레드 안전하게 설계되거나
        // 여기서 UI 스레드로 مارshal 할 필요는 없음 (로직 처리만 하므로).
        // 단, CommandProcessor 내부의 핸들러가 UI를 직접 건드린다면 해당 부분에서 Dispatcher 필요.
        // LocalCommandExecutor의 SendMessage는 일반적으로 괜찮음.
        return _commandProcessor.ProcessIncomingCommandAsync(command, sourceIp);
    }

    public void Start()
    {
        Task.Run(() => _communicator.StartListeningAsync(_listeningPort, _cts.Token));
    }

    public async Task SendExecuteCommandAsync(string targetIp, string commandType, string payloadJson)
    {
        var command = new CommandPacket
        {
            Action = CommandAction.Execute,
            CommandType = commandType,
            Payload = payloadJson
        };
        try
        {
            await _communicator.SendCommandAsync(targetIp, _defaultRemotePort, command);
            Application.Current?.Dispatcher.Invoke(() => CommandExecutedRemotely?.Invoke($"{commandType} to {targetIp}", "SUCCESS"));
        }
        catch (Exception ex)
        {
            Application.Current?.Dispatcher.Invoke(() => CommandExecutedRemotely?.Invoke($"{commandType} to {targetIp} FAILED: {ex.Message}", "ERROR"));
        }
    }

    public async Task SendRelayCommandAsync(string relayNodeIp, string finalTargetIp, string commandType, string payloadJson)
    {
        var command = new CommandPacket
        {
            Action = CommandAction.Relay,
            TargetIpForRelay = finalTargetIp,
            CommandType = commandType,
            Payload = payloadJson
        };
        try
        {
            await _communicator.SendCommandAsync(relayNodeIp, _defaultRemotePort, command);
            Application.Current?.Dispatcher.Invoke(() => CommandExecutedRemotely?.Invoke($"RELAY {commandType} via {relayNodeIp} to {finalTargetIp}", "SUCCESS"));
        }
        catch (Exception ex)
        {
             Application.Current?.Dispatcher.Invoke(() => CommandExecutedRemotely?.Invoke($"RELAY {commandType} via {relayNodeIp} to {finalTargetIp} FAILED: {ex.Message}", "ERROR"));
        }
    }

    // 예시: 원격 PC 모니터 끄기
    public async Task TurnOffMonitorAsync(string targetIp)
    {
        var payload = new MonitorControlPayload { MonitorAction = MonitorCommandType.Off };
        await SendExecuteCommandAsync(targetIp, "MONITOR_CONTROL", payload.ToJson());
    }

    // 예시: 원격 PC 모니터 켜기
    public async Task TurnOnMonitorAsync(string targetIp)
    {
        var payload = new MonitorControlPayload { MonitorAction = MonitorCommandType.On };
        await SendExecuteCommandAsync(targetIp, "MONITOR_CONTROL", payload.ToJson());
    }

    // 예시: 원격 PC 모니터 절전
    public async Task SleepMonitorAsync(string targetIp)
    {
        var payload = new MonitorControlPayload { MonitorAction = MonitorCommandType.Sleep };
        await SendExecuteCommandAsync(targetIp, "MONITOR_CONTROL", payload.ToJson());
    }

    // 예시: PC1을 통해 PC2의 모니터 끄기
    // MyPC -> (SendRelayCommandAsync) -> PC1 -> (SendCommandAsync) -> PC2 (Executes MONITOR_OFF)
    public async Task TurnOffMonitorViaRelayAsync(string pc1Ip, string pc2Ip)
    {
        var payload = new MonitorControlPayload { MonitorAction = MonitorCommandType.Off };
        await SendRelayCommandAsync(pc1Ip, pc2Ip, "MONITOR_CONTROL", payload.ToJson());
    }


    public void Dispose()
    {
        _cts.Cancel(); // 모든 비동기 작업에 취소 요청
        _communicator.Dispose();
        _cts.Dispose();
        GC.SuppressFinalize(this);
    }
}
WPF 애플리케이션에서의 사용 (MainWindow.xaml.cs 등)

C#

// MainWindow.xaml.cs
public partial class MainWindow : Window, IDisposable
{
    private NetworkServiceManager _networkManager;
    // ObservableCollection<string> Logs for ListBox binding
    // ObservableCollection<string> ConnectedPeers for ListBox binding

    public MainWindow()
    {
        InitializeComponent();
        // 포트 설정은 App.config나 사용자 설정에서 가져오는 것이 좋음
        _networkManager = new NetworkServiceManager(listeningPort: 12345, defaultRemotePort: 12345);

        // 이벤트 구독 (UI 업데이트)
        _networkManager.LogReceived += (log) => { /* Add to Logs ObservableCollection */ };
        _networkManager.PeerConnected += (ip) => { /* Add to ConnectedPeers ObservableCollection */ };
        _networkManager.PeerDisconnected += (ip) => { /* Remove from ConnectedPeers ObservableCollection */ };
        _networkManager.CommandExecutedRemotely += (status, type) => { /* Update status bar or log */ };

        _networkManager.Start(); // 서버 리스닝 시작
    }

    private async void SendMonitorOffButton_Click(object sender, RoutedEventArgs e)
    {
        string targetIp = TargetIpTextBox.Text; // UI에서 IP 입력 받음
        if (!string.IsNullOrWhiteSpace(targetIp))
        {
            await _networkManager.TurnOffMonitorAsync(targetIp);
        }
    }

    private async void SendRelayMonitorOffButton_Click(object sender, RoutedEventArgs e)
    {
        string relayIp = RelayIpTextBox.Text;
        string finalTargetIp = FinalTargetIpTextBox.Text;
        if (!string.IsNullOrWhiteSpace(relayIp) && !string.IsNullOrWhiteSpace(finalTargetIp))
        {
            await _networkManager.TurnOffMonitorViaRelayAsync(relayIp, finalTargetIp);
        }
    }
    // ... 다른 버튼 핸들러들 (모니터 켜기, 절전)

    public void Dispose()
    {
        _networkManager?.Dispose();
    }

    // Window_Closed 이벤트에서 Dispose 호출
    private void Window_Closed(object sender, EventArgs e)
    {
        Dispose();
    }
}
SOLID 원칙 및 디자인 패턴 적용

SRP (단일 책임 원칙): 각 클래스(SocketCommunicator, LocalCommandExecutor, RelayCommandHandler, CommandProcessor)는 하나의 주요 책임만 가집니다.
OCP (개방-폐쇄 원칙): 새로운 명령 유형이나 처리기를 추가할 때 기존 코드를 수정하기보다는 새로운 ICommandHandler 구현을 추가하는 방식으로 확장 가능합니다. (예: 새로운 SystemShutdownHandler)
LSP (리스코프 치환 원칙): ICommandHandler의 구현체들은 ICommandHandler 타입으로 서로 대체 가능합니다.
ISP (인터페이스 분리 원칙): ISocketCommunicator, ICommandHandler 등 역할에 맞는 작은 인터페이스를 사용합니다.
DIP (의존관계 역전 원칙): CommandProcessor는 구체적인 핸들러가 아닌 ICommandHandler 추상화에 의존합니다. NetworkServiceManager도 ISocketCommunicator에 의존합니다. 의존성 주입(DI)을 통해 이를 달성합니다 (생성자 주입).
Facade 패턴: NetworkServiceManager가 복잡한 네트워크 통신 및 명령 처리 서브시스템에 대한 간결한 인터페이스를 제공합니다.
Strategy 패턴 (암시적): CommandProcessor가 CommandAction에 따라 다른 ICommandHandler (전략)를 선택하여 작업을 위임하는 형태로 볼 수 있습니다.
안정성 확보를 위한 추가 고려사항

TCP Keep-Alive: SocketCommunicator에 SetKeepAlive 메서드를 추가하여 운영체제 레벨에서 TCP 연결이 유효한지 주기적으로 확인하도록 설정했습니다. 이는 네트워크 중간 장비(방화벽, NAT)가 비활성 TCP 세션을 종료하는 것을 방지하는 데 도움이 됩니다.
비동기 프로그래밍: async/await를 전반적으로 사용하여 UI 스레드가 차단되는 것을 방지하고, 서버가 여러 클라이언트를 효율적으로 동시에 처리할 수 있도록 합니다. ConfigureAwait(false)를 적절히 사용하여 불필요한 컨텍스트 스위칭을 줄입니다.
오류 처리 및 로깅: 모든 네트워크 작업과 주요 로직에는 try-catch 블록을 사용하여 예외를 처리하고, LogMessage 이벤트를 통해 상세한 로그를 남겨 문제 발생 시 원인 파악을 용이하게 합니다. SocketException의 SocketErrorCode를 확인하면 더 구체적인 오류 원인을 알 수 있습니다.
CancellationToken: 장기 실행 작업(서버 리스닝, 클라이언트 핸들링)에 CancellationToken을 전달하여 프로그램 종료 시 또는 필요에 따라 작업을 안전하게 중단할 수 있도록 합니다.
메시지 프레이밍: SocketCommunicator에서 메시지 길이를 먼저 보내고 실제 메시지를 보내는 방식을 사용하여 메시지 경계를 명확히 합니다. 이는 TCP 스트림에서 여러 메시지가 붙거나 나뉘어 수신되는 문제를 해결합니다.
리소스 관리 (IDisposable): TcpClient, TcpListener, NetworkStream 등 IDisposable을 구현하는 객체들은 using 문을 사용하거나 finally 블록에서 Dispose() (또는 Close())를 호출하여 시스템 리소스를 적시에 해제합니다. SocketCommunicator와 NetworkServiceManager 자체도 IDisposable을 구현하여 관리하는 리소스를 정리합니다.
연결 타임아웃: SendCommandAsync에서 ConnectAsync를 사용할 때 Task.WhenAny와 Task.Delay를 조합하여 연결 시도에 타임아웃을 적용합니다.
버퍼 크기 및 메시지 크기 제한: 과도한 메모리 사용이나 DoS 공격을 방지하기 위해 수신 버퍼 크기와 허용되는 최대 메시지 크기에 제한을 둘 수 있습니다. (예제에서는 1MB로 제한)
동시성 관리: 서버에서 여러 클라이언트를 동시에 처리하기 위해 ConcurrentDictionary를 사용하여 연결된 클라이언트 목록을 스레드 안전하게 관리합니다.
이 구조는 요구사항을 충족하면서 안정성과 유지보수성을 높이는 데 중점을 둡니다. WPF UI와의 연동은 Dispatcher를 사용하여 UI 스레드에서 안전하게 업데이트하도록 처리해야 합니다. (예제 코드에 Application.Current.Dispatcher.Invoke 반영)