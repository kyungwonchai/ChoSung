이전 코드 구조로 돌아가서 selectedImage와 currentBitmap 변수가 제대로 업데이트되고, UI가 이를 반영하도록 하는 문제를 해결해보겠습니다.

selectedImage와 currentBitmap이 올바르게 사용되도록 상태 관리 및 SignalR 이벤트 핸들러를 개선합니다.

MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.*
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import kotlin.concurrent.fixedRateTimer

class MainActivity : ComponentActivity() {
    private lateinit var hubConnection: HubConnection
    private val mainScope = CoroutineScope(Dispatchers.Main + SupervisorJob())

    private val selectedImageTitle = mutableStateOf("")
    private val selectedDatetime = mutableStateOf("")
    private val selectedImage = mutableStateOf<Bitmap?>(null)
    private val currentBitmap = mutableStateOf<Bitmap?>(null)

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d("MainActivity", "onCreate called")
        setupSignalR()

        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
                    var isRefreshing by remember { mutableStateOf(false) }

                    LaunchedEffect(selectedImage.value) {
                        currentBitmap.value = selectedImage.value
                    }

                    ImageListScreen(
                        imageList = imageList,
                        selectedImage = selectedImage.value,
                        selectedImageTitle = selectedImageTitle.value,
                        selectedDatetime = selectedDatetime.value,
                        onFetchData = {
                            mainScope.launch(Dispatchers.IO) {
                                val newList = fetchDataFromDatabase()
                                withContext(Dispatchers.Main) {
                                    imageList = newList
                                }
                            }
                        },
                        onImageSelected = { imageTitle, datetime ->
                            Log.d("MainActivity", "Image selected: $imageTitle, $datetime")
                            selectedImageTitle.value = imageTitle
                            selectedDatetime.value = datetime
                            mainScope.launch(Dispatchers.IO) {
                                val image = fetchImageFromDatabase(imageTitle, datetime)
                                withContext(Dispatchers.Main) {
                                    selectedImage.value = image
                                    currentBitmap.value = image
                                }
                            }
                        },
                        onBack = {
                            selectedImage.value = null
                            currentBitmap.value = null
                        },
                        onFit = {
                            currentBitmap.value = selectedImage.value
                        },
                        currentBitmap = currentBitmap.value,
                        isRefreshing = isRefreshing,
                        onToggleRefresh = { isRefreshing = it }
                    )
                }
            }
        }
    }

    private fun setupSignalR() {
        Log.d("SignalR", "setupSignalR called")
        hubConnection = HubConnectionBuilder.create("https://yourserver/signalrhub").build()

        hubConnection.on("UpdateImage", { imageTitle: String, datetime: String ->
            Log.d("SignalR", "UpdateImage event received with title: $imageTitle and datetime: $datetime")
            mainScope.launch {
                updateImage(imageTitle, datetime)
            }
        }, String::class.java, String::class.java)

        hubConnection.start()
            .doOnComplete {
                Log.d("SignalR", "Hub connection started successfully")
            }
            .doOnError { error ->
                Log.e("SignalR", "Error starting hub connection: ${error.message}")
            }
            .blockingAwait()
    }

    private suspend fun updateImage(imageTitle: String, datetime: String) {
        val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
        newBitmap?.let {
            Log.d("SignalR", "Image updated for title: $imageTitle and datetime: $datetime")
            withContext(Dispatchers.Main) {
                selectedImageTitle.value = imageTitle
                selectedDatetime.value = datetime
                selectedImage.value = newBitmap
                currentBitmap.value = newBitmap
            }
        }
    }

    override fun onDestroy() {
        Log.d("SignalR", "onDestroy called")
        hubConnection.stop()
            .doOnComplete {
                Log.d("SignalR", "Hub connection stopped successfully")
            }
            .doOnError { error ->
                Log.e("SignalR", "Error stopping hub connection: ${error.message}")
            }
            .blockingAwait()
        super.onDestroy()
    }
}

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    currentBitmap: Bitmap?,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    Column {
        if (selectedImage == null) {
            Button(
                onClick = { onFetchData() },
                modifier = Modifier.padding(16.dp)
            ) {
                Text(if (imageList.isEmpty()) "Fetch Data" else "Reload Data")
            }
        }

        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            currentBitmap?.let { bitmap ->
                ImageDisplayScreen(
                    bitmap = bitmap,
                    imageTitle = selectedImageTitle,
                    datetime = selectedDatetime,
                    onBack = onBack,
                    onFit = onFit,
                    isRefreshing = isRefreshing,
                    onToggleRefresh = onToggleRefresh
                )
            }
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()

    LaunchedEffect(currentBitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        currentBitmap = newBitmap
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        scale *= zoom
                        offset = Offset(offset.x + pan.x, offset.y + pan.y)
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            null
        }
    }
}
주요 변경 사항:
상태 변수로 mutableStateOf 사용: selectedImageTitle, selectedDatetime, selectedImage, 및 currentBitmap을 mutableStateOf로 정의하여 상태 변화를 감지합니다.
setupSignalR: SignalR 이벤트에서 selectedImageTitle과 selectedDatetime을 설정하고, updateImage 함수를 호출하여 이미지를 업데이트합니다.
updateImage: 이미지 데이터를 업데이트하고 상태 변수를 통해 UI를 갱신합니다.
이제 selectedImage와 currentBitmap이 상태 변수로 관리되므로 SignalR 이벤트에서 이미지를 업데이트할 때 UI가 이를 반영하도록 합니다