import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import pymssql
import numpy as np
import os
import json
from collections import defaultdict

# 데이터베이스 연결 설정
DB_CONFIG = {
    "server": "YOUR_SERVER",  # MSSQL 서버 주소
    "user": "YOUR_USER",  # 사용자명
    "password": "YOUR_PASSWORD",  # 비밀번호
    "database": "YOUR_DATABASE"  # 데이터베이스 이름
}

# 모델 및 토크나이저 저장 경로 설정
MODEL_PATH = "qr_model.pth"
TOKENIZER_PATH = "tokenizer.json"

# QR 코드 데이터셋 정의
class QRDataset(Dataset):
    def __init__(self, data, tokenizer):
        self.data = data  # (QR 코드, 모델명 인덱스) 형태의 리스트
        self.tokenizer = tokenizer  # QR 코드 문자열을 숫자로 변환하는 함수

    def __len__(self):
        return len(self.data)

    def __getitem__(self, idx):
        qr_code, label = self.data[idx]
        qr_encoded = self.tokenizer(qr_code)  # QR 코드 문자열을 숫자 리스트로 변환
        return torch.tensor(qr_encoded, dtype=torch.float32), torch.tensor(label, dtype=torch.long)

# LSTM 기반의 QR 코드 예측 모델 정의
class QRModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(QRModel, self).__init__()
        self.lstm = nn.LSTM(input_dim, hidden_dim, batch_first=True)  # LSTM 레이어
        self.fc = nn.Linear(hidden_dim, output_dim)  # Fully Connected 레이어
    
    def forward(self, x):
        _, (h_n, _) = self.lstm(x)  # LSTM의 최종 hidden state 가져오기
        return self.fc(h_n.squeeze(0))  # FC 레이어를 통과시켜 모델명 예측

# 데이터베이스에서 데이터 가져오기 (Stored Procedure 실행)
def fetch_data():
    conn = pymssql.connect(**DB_CONFIG)
    cursor = conn.cursor()
    cursor.execute("EXEC your_stored_procedure")  # 프로시저 실행
    data = cursor.fetchall()  # 데이터 가져오기
    conn.close()
    return data

# QR 코드 문자열을 숫자로 변환하는 토크나이저 생성
def create_tokenizer(data):
    unique_chars = sorted(set("".join(qr for _, qr in data)))  # QR 코드에서 유일한 문자 집합 생성
    char_to_idx = {char: idx for idx, char in enumerate(unique_chars, start=1)}  # 문자 인덱스 매핑
    char_to_idx["<PAD>"] = 0  # 패딩 문자 추가
    
    def tokenizer(qr_code):
        return [char_to_idx.get(char, 0) for char in qr_code]  # 문자열을 숫자로 변환
    
    return tokenizer, char_to_idx

# 모델 저장 및 불러오기 기능
def save_model(model, tokenizer):
    torch.save(model.state_dict(), MODEL_PATH)  # 모델 가중치 저장
    with open(TOKENIZER_PATH, "w") as f:
        json.dump(tokenizer, f)  # 토크나이저 저장

def load_model(input_dim, hidden_dim, output_dim):
    model = QRModel(input_dim, hidden_dim, output_dim)
    if os.path.exists(MODEL_PATH):
        model.load_state_dict(torch.load(MODEL_PATH))  # 저장된 모델 불러오기
    return model

def load_tokenizer():
    with open(TOKENIZER_PATH, "r") as f:
        char_to_idx = json.load(f)  # 토크나이저 불러오기
    def tokenizer(qr_code):
        return [char_to_idx.get(char, 0) for char in qr_code]
    return tokenizer

# 모델 학습 함수
def train_model(model, dataset, epochs=10, batch_size=32, lr=0.001):
    dataloader = DataLoader(dataset, batch_size=batch_size, shuffle=True)
    criterion = nn.CrossEntropyLoss()  # 손실 함수 (CrossEntropy)
    optimizer = optim.Adam(model.parameters(), lr=lr)  # 옵티마이저 설정
    
    for epoch in range(epochs):
        total_loss = 0
        for inputs, labels in dataloader:
            outputs = model(inputs)
            loss = criterion(outputs, labels)
            optimizer.zero_grad()
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        print(f"Epoch {epoch+1}/{epochs}, Loss: {total_loss:.4f}")
    
    save_model(model, dataset.tokenizer)  # 학습 후 모델 저장

# 데이터 로드 및 학습 실행
if __name__ == "__main__":
    raw_data = fetch_data()  # 데이터베이스에서 데이터 불러오기
    filtered_data = [(model if model else None, qr) for model, qr in raw_data]  # 모델명이 없는 경우 처리
    model_map = defaultdict(list)
    for model, qr in filtered_data:
        model_map[qr].append(model)  # QR별로 모델명 저장
    
    # 모델명이 없는 경우, 동일한 QR의 과거 기록을 활용
    processed_data = [(model_map[qr][0] if model_map[qr] else "UNKNOWN", qr) for _, qr in filtered_data]
    
    tokenizer, char_to_idx = create_tokenizer(processed_data)  # QR 코드 토큰화
    model_list = list(set(model for model, _ in processed_data))  # 고유한 모델명 리스트 생성
    model_to_idx = {model: idx for idx, model in enumerate(model_list)}  # 모델명 -> 인덱스 변환
    idx_to_model = {idx: model for model, idx in model_to_idx.items()}  # 인덱스 -> 모델명 변환
    
    dataset = QRDataset([(qr, model_to_idx[model]) for model, qr in processed_data], tokenizer)
    input_dim = max(len(qr) for _, qr in processed_data)  # QR 코드 길이 설정
    hidden_dim = 128  # LSTM 숨은 차원 크기
    output_dim = len(model_list)  # 모델명 개수
    
    model = load_model(input_dim, hidden_dim, output_dim)  # 기존 모델 불러오기
    train_model(model, dataset)  # 모델 학습 실행