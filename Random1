네, VBA의 Function에서도 인수를 전달받을 때 ByVal (값에 의한 전달) 대신 ByRef (참조에 의한 전달)를 사용할 수 있습니다. Sub 프로시저와 마찬가지로 Function에서도 ByRef를 사용하는 경우가 있습니다.

ByVal과 ByRef의 기본 개념

ByVal (By Value - 값에 의한 전달):

프로시저(Function 또는 Sub)에 변수의 복사본이 전달됩니다.
프로시저 내에서 해당 매개변수(인수)의 값을 변경해도, 호출한 곳의 원본 변수 값에는 영향을 주지 않습니다.
VBA에서 특별히 지정하지 않으면 대부분의 기본 데이터 타입(Integer, String, Boolean 등)은 ByVal로 간주될 수 있으나, 명시적으로 적어주는 것이 좋습니다. (실제로는 VBA의 기본값은 ByRef이지만, 많은 개발자들이 ByVal을 기본처럼 사용하거나 혼동하는 경우가 있어 명시하는 것이 안전합니다. 정확히는, VBA의 인자 전달 기본 방식은 ByRef입니다. 하지만 습관적으로 ByVal을 선호하는 개발자도 많습니다.)
ByRef (By Reference - 참조에 의한 전달):

프로시저에 변수의 **메모리 주소(참조)**가 전달됩니다.
프로시저 내에서 해당 매개변수의 값을 변경하면, 호출한 곳의 원본 변수 값도 함께 변경됩니다.
객체(Object) 변수는 기본적으로 ByRef와 유사하게 동작합니다 (정확히는 객체 참조가 값으로 전달되지만, 그 참조를 통해 원본 객체 수정이 가능).
Function에서 ByRef를 사용하는 경우

Function은 주로 특정 계산을 수행하고 그 결과를 반환 값으로 돌려주는 역할을 합니다. 하지만 다음과 같은 경우 Function에서도 ByRef 인수를 사용할 수 있습니다.

함수의 주된 반환 값 외에 추가적인 정보를 호출한 곳으로 전달하고 싶을 때:
함수는 Return 문이나 함수 이름에 값을 할당하는 방식으로 단 하나의 값만 직접 반환할 수 있습니다. 만약 함수가 여러 개의 결과를 반환해야 하거나, 주된 결과 외에 상태 정보 등을 추가로 전달하고 싶을 때 ByRef 인수를 사용하여 원본 변수를 직접 수정할 수 있습니다.

VBA

Function ProcessData(ByVal inputData As Integer, ByRef statusMessage As String, ByRef errorCode As Long) As Double
    ' inputData를 가공하여 결과 계산
    Dim result As Double
    result = inputData * 1.5

    If result > 100 Then
        statusMessage = "처리 성공: 결과가 100을 초과합니다."
        errorCode = 0 ' 성공 코드
    Else
        statusMessage = "처리 경고: 결과가 100 이하입니다."
        errorCode = 1 ' 경고 코드
    End If

    ProcessData = result ' 주된 결과 반환
End Function

Sub TestProcessData()
    Dim myData As Integer
    Dim msg As String
    Dim errCode As Long
    Dim funcResult As Double

    myData = 70
    funcResult = ProcessData(myData, msg, errCode) ' msg와 errCode는 ByRef로 전달되어 함수 내에서 변경됨

    MsgBox "함수 결과: " & funcResult & vbCrLf & _
           "상태 메시지: " & msg & vbCrLf & _
           "에러 코드: " & errCode
End Sub
위 예시에서 ProcessData 함수는 계산된 result를 반환하면서, 추가적으로 statusMessage와 errorCode 변수의 값을 ByRef를 통해 수정하여 호출한 TestProcessData 서브루틴으로 전달합니다.

입력받은 인수를 함수 내에서 직접 수정하고, 그 수정된 상태를 호출부에 반영해야 할 때 (동시에 함수 자체의 반환 값도 필요할 경우):
어떤 객체나 배열을 입력받아 내용을 수정한 후, 작업 성공 여부 등을 함수 값으로 반환하는 경우를 생각해 볼 수 있습니다.

VBA

Function NormalizeArray(ByRef dataArray() As Double) As Boolean
    Dim i As Long
    Dim sum As Double
    Dim count As Long

    On Error GoTo ErrorHandler
    count = UBound(dataArray) - LBound(dataArray) + 1
    If count <= 0 Then
        NormalizeArray = False ' 배열이 비었거나 잘못됨
        Exit Function
    End If

    For i = LBound(dataArray) To UBound(dataArray)
        sum = sum + dataArray(i)
    Next i

    If sum = 0 Then
        NormalizeArray = False ' 합계가 0이면 정규화 불가
        Exit Function
    End If

    For i = LBound(dataArray) To UBound(dataArray)
        dataArray(i) = dataArray(i) / sum ' 원본 배열의 요소 직접 수정
    Next i

    NormalizeArray = True ' 성공 여부 반환
    Exit Function

ErrorHandler:
    NormalizeArray = False
End Function

Sub TestNormalize()
    Dim arr() As Double
    arr = VBA.Array(10, 20, 30, 40) ' 초기 배열
    Dim success As Boolean

    success = NormalizeArray(arr) ' arr은 ByRef로 전달되어 함수 내에서 수정됨

    If success Then
        Dim strArr As String
        strArr = Join(arr, ", ")
        MsgBox "정규화 성공: " & strArr
    Else
        MsgBox "정규화 실패."
    End If
End Sub
ByRef는 Sub로만 하는가?

아닙니다. ByRef는 Function과 Sub 모두에서 사용될 수 있습니다.

Sub에서 ByRef: Sub는 반환 값이 없으므로, 프로시저 외부로 어떤 결과를 전달하거나 원본 데이터를 수정해야 할 때 ByRef 인수가 매우 유용하게 사용됩니다. 이것이 Sub에서 ByRef를 자주 보게 되는 이유입니다.
Function에서 ByRef: 위에서 설명한 것처럼, Function의 주된 반환 값 외에 추가적인 변경사항을 전달해야 할 때 사용됩니다.
주의사항 및 권장사항:

가독성: ByRef를 사용하면 함수/서브루틴이 호출부의 변수를 예기치 않게 변경할 수 있으므로 코드의 흐름을 파악하기 어렵게 만들 수 있습니다. 따라서 ByRef 사용은 신중해야 하며, 이름이나 주석을 통해 해당 인수가 수정될 수 있음을 명확히 하는 것이 좋습니다.
Function의 순수성: 이상적으로 함수는 입력 값에만 의존하여 결과를 반환하고, 외부 상태를 변경하지 않는 것(Side effect가 없는 것)이 좋습니다. (이를 "순수 함수"라고도 합니다). ByRef를 사용하여 인수를 수정하는 것은 이러한 순수성을 해칠 수 있습니다.
대안: Function이 여러 값을 반환해야 할 경우, ByRef 대신 다음과 같은 방법을 고려할 수 있습니다.
사용자 정의 타입(Type) 또는 클래스(Class) 반환: 여러 값을 담을 수 있는 구조체나 객체를 만들어 반환합니다.