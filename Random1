이 요구사항을 충족하기 위해, ComPortManager와 MainViewModel에 몇 가지 수정과 추가 작업이 필요합니다. 여기서는 PLC에 1부터 4까지의 값을 쓰고, 3초 후 DT2330에 해당 값이 들어오는지 확인하는 로직을 추가합니다. 그런 다음 로그를 남기고 DT2330의 값을 0으로 초기화하는 절차를 구현합니다.

1. MainViewModel.cs 수정
먼저 MainViewModel에 로직을 추가하여 값을 쓰고, 3초 후에 값을 확인하는 작업을 합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        // Zero부터 4까지 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        // DT2330 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> DT2330Commands { get; set; }

        // 명령 생성
        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            DT2330Commands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();
            InitializeDT2330Commands();

            // 명령 초기화
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 1; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value))));
            }
        }

        private void InitializeDT2330Commands()
        {
            for (int i = 0; i <= 4; i++)
            {
                int value = i;
                DT2330Commands.Add(new KeyValuePair<string, ICommand>(
                    $"Process DT2330 - {i}",
                    new RelayCommand(async () => await ProcessDT2330Value(value))));
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            // Step 1: Write value to DT2300
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(writeCommand);
            LogMessage($"Sent {number} to DT2300");

            // Step 2: Wait for 3 seconds
            await Task.Delay(3000);

            // Step 3: Read from DT2330
            string response = await _comPortManager.ReadFromPLCAsync("023300");
            if (response.Contains(number.ToString()))
            {
                LogMessage($"Operation completed successfully. Value {number} received from DT2330.");
                await _comPortManager.ClearPLCValueAsync("023300");
            }
            else
            {
                LogMessage($"Operation failed. Expected value {number} not received.");
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                await _comPortManager.SendDataToPLCAsync(command);
                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ProcessDT2330Value(int value)
        {
            // DT2330 값을 처리하고, 특정 작업을 수행합니다
            LogMessage($"Processed value from DT2330: {value}");

            // 필요에 따라 값을 초기화하거나 다른 작업을 수행할 수 있습니다
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
2. ComPortManager.cs 추가
PLC로부터 값을 읽어오고 값을 초기화하는 메서드는 이미 이전에 제공된 코드를 기반으로 작성되었습니다. 여기서는 추가 수정 없이 기존 코드에서 제공된 ReadFromPLCAsync 및 ClearPLCValueAsync 메서드를 사용하면 됩니다.

csharp
코드 복사
public async Task<string> ReadFromPLCAsync(string address)
{
    if (_port == null || !_port.IsOpen)
    {
        throw new InvalidOperationException("The serial port is not open.");
    }

    try
    {
        string command = $"%01#RDD{address}**\r";
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        _port.Write(commandBytes, 0, commandBytes.Length);
        var response = await Task.Run(() => _port.ReadLine());
        return response;
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error reading from PLC: {ex.Message}");
        return string.Empty;
    }
}

public async Task ClearPLCValueAsync(string address)
{
    if (_port == null || !_port.IsOpen)
    {
        throw new InvalidOperationException("The serial port is not open.");
    }

    try
    {
        string command = $"%01#WDD{address}0000**\r";
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        await Task.Run(() => _port.Write(commandBytes, 0, commandBytes.Length));
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error clearing PLC value: {ex.Message}");
    }
}
3. 설명
PLC에 값 쓰기: WriteToPLCAndCheckResponse 메서드는 DT2300에 1부터 4까지의 값을 쓰는 역할을 합니다.

3초 대기 후 확인: 값을 쓴 후 Task.Delay(3000)를 사용하여 3초간 대기합니다.

DT2330 값 확인 및 초기화: 대기 후, ReadFromPLCAsync 메서드를 사용하여 DT2330에서 값을 읽고, 받은 값이 전송된 값과 일치하는지 확인합니다. 값이 일치하면 로그를 찍고, ClearPLCValueAsync 메서드를 사용하여 DT2330의 값을 0으로 초기화합니다.

로깅: 각 단계마다 로그를 찍어 작업 상태를 기록합니다. 작업이 실패하거나 성공한 경우도 로그로 남기게 됩니다.

이 코드 수정으로 인해 PLC와의 통신이 보다 안정적이고 명확하게 관리될 것입니다. 또한, 각 작업의 결과가 로그로 남기 때문에 문제를 디버깅하거나 상태를 모니터링하는 데 도움이 됩니