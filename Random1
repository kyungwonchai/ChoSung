알겠습니다. 서버에서 APK 버전 관리를 위한 시스템을 구축하고, Android 애플리케이션에서 자동 업데이트 기능을 구현하는 전체 동작 원리와 각 단계에 대한 코드를 설명해 드리겠습니다.

전체 동작 원리
Flask 서버 설정:

Flask 서버를 구축하여 APK 버전 정보를 제공하고, APK 파일을 다운로드할 수 있는 엔드포인트를 만듭니다.
서버는 JSON 형식으로 현재 APK 버전과 다운로드 URL을 클라이언트(Android 앱)에게 제공합니다.
Android 애플리케이션 설정:

Android 애플리케이션은 앱이 시작될 때 Flask 서버로부터 현재 APK의 최신 버전 정보를 요청합니다.
서버로부터 받은 버전 정보와 현재 설치된 앱의 버전을 비교하여, 새 버전이 있으면 APK 파일을 다운로드하고 설치합니다.
단계별 구현
1. Flask 서버 설정
Flask 서버는 APK 버전 정보와 APK 파일을 제공하는 역할을 합니다.

1-1. Flask 애플리케이션 구성
bash
코드 복사
# Flask 설치
pip install Flask
프로젝트 디렉터리 구조:

arduino
코드 복사
apk-version-manager/
├── app.py
├── static/
│   └── apks/
│       ├── apk1.apk
└── version_files/
    ├── apk1_version.json
1-2. Flask 서버 코드 (app.py)
python
코드 복사
from flask import Flask, jsonify, send_from_directory

app = Flask(__name__)

# APK 버전 정보 제공 엔드포인트
@app.route('/api/apk1/version', methods=['GET'])
def apk1_version():
    version_info = {
        "version": "1.2",  # APK 버전 정보
        "apk_url": "/download/apk1"  # APK 파일 다운로드 경로
    }
    return jsonify(version_info)  # JSON 형식으로 반환

# APK 파일 다운로드 엔드포인트
@app.route('/download/apk1', methods=['GET'])
def download_apk1():
    return send_from_directory('static/apks', 'apk1.apk')

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8116)  # 모든 네트워크 인터페이스에서 접근 가능하게 설정
/api/apk1/version: 현재 APK 버전 정보를 제공하는 엔드포인트입니다.
/download/apk1: APK 파일을 클라이언트에 제공하는 엔드포인트입니다.
app.run(host='0.0.0.0', port=8116): 서버를 포트 8116에서 실행하여 외부에서 접근 가능하도록 합니다.
2. Android 애플리케이션 설정
Android 애플리케이션은 서버로부터 APK 버전 정보를 요청하고, 필요시 새 버전을 다운로드 및 설치합니다.

2-1. Android 프로젝트 설정
build.gradle 파일에 OkHttp 및 Kotlin Coroutines 의존성을 추가합니다:

gradle
코드 복사
dependencies {
    implementation 'com.squareup.okhttp3:okhttp:4.9.0'
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'
}
2-2. AndroidManifest.xml 설정
APK 파일 설치를 위해 AndroidManifest.xml에 FileProvider 설정을 추가합니다:

xml
코드 복사
<application
    android:networkSecurityConfig="@xml/network_security_config"
    android:allowBackup="true"
    android:icon="@mipmap/ic_launcher"
    android:label="@string/app_name"
    android:roundIcon="@mipmap/ic_launcher_round"
    android:supportsRtl="true"
    android:theme="@style/AppTheme">

    <!-- FileProvider 설정 -->
    <provider
        android:name="androidx.core.content.FileProvider"
        android:authorities="${applicationId}.provider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths" />
    </provider>

</application>
그리고 res/xml/file_paths.xml 파일을 생성하여 파일 경로를 설정합니다:

xml
코드 복사
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-files-path name="external_files" path="." />
</paths>
2-3. MainActivity 코드
MainActivity.kt 파일에서 서버로부터 APK 버전 정보를 가져오고, 업데이트를 수행하는 코드를 작성합니다.

kotlin
코드 복사
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.FileProvider
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONException
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 네트워크 작업을 비동기로 실행
        CoroutineScope(Dispatchers.IO).launch {
            checkForUpdates(this@MainActivity, "apk1")
        }
    }

    private suspend fun checkForUpdates(context: Context, apkName: String) {
        Log.d("TTTTT", "Starting checkForUpdates for $apkName")

        val client = OkHttpClient()
        val request = Request.Builder()
            .url("http://10.244.122.222:8116/api/$apkName/version")
            .build()

        try {
            val response = client.newCall(request).execute()

            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code: ${response.code}")
                return
            }

            var responseData = response.body?.string()?.trim()
            Log.d("TTTTT", "Received response: $responseData")

            // JSON 파싱 전에 데이터 정리 및 형식 확인
            if (responseData != null && responseData.startsWith("{") && responseData.endsWith("}")) {
                try {
                    val jsonObject = JSONObject(responseData)
                    val latestVersion = jsonObject.getString("version")
                    val apkUrl = jsonObject.getString("apk_url")
                    Log.d("TTTTT", "Parsed version: $latestVersion, apk_url: $apkUrl")

                    // APK 다운로드 및 설치 로직
                    downloadAndInstallApk(context, apkUrl, apkName)
                } catch (e: JSONException) {
                    Log.e("TTTTT", "Failed to parse JSON: $responseData", e)
                }
            } else {
                Log.e("TTTTT", "Response is not a valid JSON: $responseData")
            }
        } catch (e: Exception) {
            Log.e("TTTTT", "Error during checkForUpdates: ${e.message}", e)
        }
    }

    private suspend fun downloadAndInstallApk(context: Context, apkUrl: String, apkName: String) {
        Log.d("TTTTT", "Starting download for $apkName from $apkUrl")

        val client = OkHttpClient()
        val request = Request.Builder().url("http://10.244.122.222:8116$apkUrl").build()

        try {
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code during download: ${response.code}")
                return
            }

            val apkFile = File(context.getExternalFilesDir(null), "$apkName.apk")
            FileOutputStream(apkFile).use { fos ->
                fos.write(response.body?.bytes())
                Log.d("TTTTT", "APK file downloaded successfully to ${apkFile.absolutePath}")
            }

            val apkUri: Uri = FileProvider.getUriForFile(
                context,
                context.applicationContext.packageName + ".provider",
                apkFile
            )

            withContext(Dispatchers.Main) {
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
                    setDataAndType(apkUri, "application/vnd.android.package-archive")
                }
                context.startActivity(intent)
                Log.d("TTTTT", "APK installation initiated for $apkName")
            }

        } catch (e: Exception) {
            Log.e("TTTTT", "Error during downloadAndInstallApk: ${e.message}", e)
        }
    }
}
checkForUpdates: 서버에서 APK 버전 정보를 요청하고, 최신 버전을 확인합니다. 최신 버전이 있으면 downloadAndInstallApk 메서드를 호출하여 APK를 다운로드하고 설치합니다.
downloadAndInstallApk: 서버에서 APK 파일을 다운로드하고, Android의 FileProvider를 통해 설치를 시작합니다.
전체 동작 순서
Flask 서버 시작: app.py를 실행하여 Flask 서버를 시작합니다.
Android 앱 시작: MainActivity에서 앱이 시작될 때 서버로부터 APK 버전 정보를 요청합니다.
버전 정보 비교: 서버에서 받은 APK 버전 정보와 현재 앱의 버전을 비교합니다.
APK 다운로드 및 설치: 최신 버전이 있으면, APK 파일을 다운로드하고 설치를 진행합니다.
사용자 알림 및 설치: 사용자가 APK 설치를 승인하면 새로운 APK 파일이 설치됩니다.
이 순서대로 구성된 코드는 서버와 클라이언트 간의 통신을 통해 APK 파일을 자동으로 업데이트하는 기능을 제공합니다. 이 과정을 따라 설정하면, 사내 네트워크 환경에서 안전하게 APK 파일을 관리하고 업데이트할 수 있습니다.