AML을 사용하여 스타일을 정의하고, 애니메이션을 적용해 더 화려한 ProgressBar를 만들 수 있습니다. 여기서는 Storyboard를 활용한 애니메이션과 LinearGradientBrush 등을 사용하여 시각적으로 더 예쁜 ProgressBar를 구현해보겠습니다.

1. XAML에서 예쁘게 줄어드는 ProgressBar 구현
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Animated ProgressBar" Height="200" Width="400">
    <Grid>
        <!-- ProgressBar 템플릿 재정의 -->
        <ProgressBar x:Name="CustomProgressBar" Height="30" Width="300" VerticalAlignment="Top" Margin="50,30,50,0" Minimum="0" Maximum="100" Value="{Binding ProgressValue}">
            <ProgressBar.Style>
                <Style TargetType="ProgressBar">
                    <Setter Property="Template">
                        <Setter.Value>
                            <ControlTemplate TargetType="ProgressBar">
                                <Grid x:Name="ProgressGrid" Height="30" Width="300">
                                    <!-- ProgressBar 배경 -->
                                    <Rectangle Fill="LightGray" RadiusX="10" RadiusY="10"/>
                                    
                                    <!-- 애니메이션이 적용되는 진행 표시 바 -->
                                    <Rectangle x:Name="PART_Track" HorizontalAlignment="Left" RadiusX="10" RadiusY="10">
                                        <Rectangle.Fill>
                                            <!-- 그라디언트 효과를 적용하여 색상을 더 예쁘게 표현 -->
                                            <LinearGradientBrush StartPoint="0,0" EndPoint="1,0">
                                                <GradientStop Color="#FF4CAF50" Offset="0.0"/>
                                                <GradientStop Color="#FF8BC34A" Offset="1.0"/>
                                            </LinearGradientBrush>
                                        </Rectangle.Fill>
                                    </Rectangle>
                                </Grid>
                                <ControlTemplate.Triggers>
                                    <Trigger Property="IsIndeterminate" Value="True">
                                        <Setter TargetName="PART_Track" Property="Visibility" Value="Collapsed"/>
                                    </Trigger>
                                    <Trigger Property="Value" Value="0">
                                        <Setter TargetName="PART_Track" Property="Width" Value="0"/>
                                    </Trigger>
                                    <Trigger Property="Value" Value="{Binding RelativeSource={RelativeSource TemplatedParent}, Path=Maximum}">
                                        <Setter TargetName="PART_Track" Property="Width" Value="{Binding ElementName=ProgressGrid, Path=ActualWidth}"/>
                                    </Trigger>
                                </ControlTemplate.Triggers>
                            </ControlTemplate>
                        </Setter.Value>
                    </Setter>
                </Style>
            </ProgressBar.Style>
        </ProgressBar>

        <!-- 버튼으로 작업 시작 -->
        <Button Content="Start Operation" Width="150" Height="30" VerticalAlignment="Bottom" HorizontalAlignment="Center" Margin="10" Command="{Binding StartCommand}"/>
    </Grid>
</Window>
2. ViewModel에서 ProgressBar 업데이트
ProgressBar의 Value 속성은 ViewModel에서 업데이트되며, 애니메이션이 적용된 UI에서 이 값에 따라 ProgressBar가 줄어듭니다.

MainViewModel.cs
csharp
코드 복사
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;

namespace YourNamespace
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private int _progressValue;

        public int ProgressValue
        {
            get { return _progressValue; }
            set
            {
                _progressValue = value;
                OnPropertyChanged(nameof(ProgressValue));
            }
        }

        public ICommand StartCommand { get; }

        public MainViewModel()
        {
            StartCommand = new RelayCommand(async () => await StartOperation());
        }

        private async Task StartOperation()
        {
            int totalTime = 100;  // ProgressBar의 최대값을 100으로 설정
            int interval = 1;     // 1%씩 증가

            for (int i = 0; i <= totalTime; i++)
            {
                ProgressValue = i;
                await Task.Delay(70);  // 7초 동안 완료되도록 설정 (70ms * 100 = 7000ms)
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class RelayCommand : ICommand
    {
        private readonly Func<Task> _execute;
        private readonly Func<bool> _canExecute;

        public RelayCommand(Func<Task> execute, Func<bool> canExecute = null)
        {
            _execute = execute;
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute();
        }

        public async void Execute(object parameter)
        {
            await _execute();
        }

        public event EventHandler CanExecuteChanged;
    }
}
3. 설명
ProgressBar 스타일 커스터마이징:
ProgressBar의 기본 템플릿을 재정의하여 좀 더 세련된 외관을 제공합니다.
LinearGradientBrush를 사용하여 그라디언트 색상이 적용된 진행 바를 생성합니다.
RadiusX, RadiusY 속성을 사용하여 ProgressBar의 모서리를 둥글게 만들었습니다.
애니메이션:
ProgressBar는 Value 값에 따라 Rectangle의 너비가 조정되며, UI에서 점진적으로 줄어드는 효과를 시각적으로 표현합니다.
Progress 업데이트:
MainViewModel에서 ProgressValue를 변경하여 ProgressBar를 업데이트합니다.
StartOperation 메서드에서 7초 동안 1%씩 증가하는 방식으로 진행됩니다. Task.Delay(70)는 매 1%씩 업데이트될 때 70ms를 기다리도록 설정하였습니다.
4. 결과
이 예제에서는 ProgressBar가 그라디언트 색상으로 표시되고, 7초 동안 천천히 줄어드는 모습을 확인할 수 있습니다. 애니메이션을 추가하지 않더라도 WPF에서의 UI 스타일을 조정하여 매우 매력적인 ProgressBar를 만들 수 있습니다.

추가적으로 더 고급스러운 애니메이션이나 스타일을 적용하고 싶다면 WPF의 Storyboard를 이용해 다양한 트리거와 애니메이션을 설정할 수 있