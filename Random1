
import React from 'react';
import type { LabelElement } from '../App';

interface PrintPreviewProps {
  elements: LabelElement[];
  printSettings: { width: number; height: number };
}

const PrintPreview: React.FC<PrintPreviewProps> = ({ elements, printSettings }) => {

  const renderContent = (element: LabelElement) => {
    const style: React.CSSProperties = {
      position: 'absolute',
      left: `${element.x}px`,
      top: `${element.y}px`,
      width: `${element.width}px`,
      height: `${element.height}px`,
      fontSize: `${element.fontSize}px`,
      boxSizing: 'border-box',
      overflow: 'hidden',
      color: element.color,
      backgroundColor: element.backgroundColor,
      whiteSpace: 'pre-wrap',
      wordBreak: 'break-word',
      border: element.borderWidth ? `${element.borderWidth}px solid ${element.borderColor}` : 'none',
    };
    
    switch (element.type) {
      case 'label':
      case 'textbox':
        style.padding = '2px';
        return <div style={style}>{element.content}</div>;
      case 'line':
      case 'rectangle':
        return <div style={style}></div>
      case 'relative-time':
        {
          const now = new Date();
          const targetTime = new Date(now.getTime() - (element.hoursAgo || 0) * 3600 * 1000);
          const timeString = targetTime.toLocaleString();
          style.padding = '2px';
          return <div style={style}>{timeString}</div>;
        }
      default:
        return null;
    }
  };

  return (
    <div id="print-area" className="hidden print:block">
      <div
        className="relative overflow-hidden bg-white"
        style={{
          width: `${printSettings.width}px`,
          height: `${printSettings.height}px`,
        }}
      >
        {elements.map((el) => (
          <React.Fragment key={el.id}>
            {renderContent(el)}
          </React.Fragment>
        ))}
      </div>
    </div>
  );
};

export default PrintPreview;










import React from 'react';
import type { LabelElement as LabelElementData } from '../App';
import LabelElement from './LabelElement';

interface EditorCanvasProps {
  elements: LabelElementData[];
  selectedElementId: string | null;
  onSelectElement: (id: string | null) => void;
  onUpdateElement: (id: string, newProps: Partial<LabelElementData>) => void;
  canvasWidth: number;
  canvasHeight: number;
  isEditMode: boolean;
}

const EditorCanvas: React.FC<EditorCanvasProps> = ({
  elements,
  selectedElementId,
  onSelectElement,
  onUpdateElement,
  canvasWidth,
  canvasHeight,
  isEditMode,
}) => {

  const style = {
    width: `${canvasWidth}px`,
    height: `${canvasHeight}px`,
  };

  const handleCanvasClick = (e: React.MouseEvent<HTMLDivElement>) => {
    // Deselect element if clicking on the canvas background, only in edit mode
    if (isEditMode && e.target === e.currentTarget) {
      onSelectElement(null);
    }
  };

  return (
    <div className="w-full h-full flex items-center justify-center">
      <div
        id="label-canvas"
        className="bg-white shadow-xl relative border border-slate-400 overflow-hidden"
        style={style}
        onClick={handleCanvasClick}
      >
        {/* The blue dashed border for the print area has been removed. The canvas itself is now the print area. */}
        {elements.map((element) => (
          <LabelElement
            key={element.id}
            element={element}
            isSelected={element.id === selectedElementId}
            onSelect={() => onSelectElement(element.id)}
            onUpdate={onUpdateElement}
            bounds={{ width: canvasWidth, height: canvasHeight }}
            isEditMode={isEditMode}
          />
        ))}
      </div>
    </div>
  );
};

export default EditorCanvas;