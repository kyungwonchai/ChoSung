표시하도록 하겠습니다.

수정된 MLModelBuilder.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileRecord> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileRecord>();
        }

        public void TrainModel(List<FileRecord> fileData)
        {
            try
            {
                if (fileData == null || fileData.Count < 10) // 최소 샘플 수 확인
                {
                    throw new InvalidOperationException("Not enough samples to train the model. Minimum required samples: 10");
                }

                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);

                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileRecord.Size))
                    .Append(_mlContext.Transforms.Conversion.ConvertType("Features", outputKind: DataKind.Single))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model: " + ex.Message, ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileRecord
                {
                    Size = (float)fileInfo.Length // float 형식으로 변환
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileRecord, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification: " + ex.Message, ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var regexPatterns = GetRegexPatterns();
                if (regexPatterns.Count == 0)
                {
                    return "No patterns found.";
                }

                return string.Join(", ", regexPatterns.Select(p => p.ToString()));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns: " + ex.Message, ex);
            }
        }

        public List<Regex> GetRegexPatterns()
        {
            var patterns = new List<Regex>();
            var regexes = new List<Regex>
            {
                new Regex(@"(\d{4})-(\d{2})-(\d{2})"), // 날짜 패턴 (예: 2022-01-01)
                new Regex(@"IMG_(\d{8})"), // 이미지 파일 패턴 (예: IMG_20220101)
                // 필요한 다른 정규식 패턴 추가
            };

            foreach (var regex in regexes)
            {
                var matches = _fileDataList.Where(f => regex.IsMatch(f.FilePath)).ToList();
                if (matches.Count > 0)
                {
                    patterns.Add(regex);
                }
            }

            return patterns;
        }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
수정된 MainWindow.xaml.cs
csharp
코드 복사
private async void btnStart_Click(object sender, RoutedEventArgs e)
{
    string folderPath = txtFolderPath.Text;
    string fileExtension = cmbFileExtension.Text;
    string driveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\";

    if (string.IsNullOrEmpty(folderPath) || folderPath == "폴더 경로 입력" ||
        string.IsNullOrEmpty(fileExtension))
    {
        System.Windows.Forms.MessageBox.Show("모든 입력값을 제공해주세요.");
        return;
    }

    try
    {
        Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 중..."; });

        _trainingData = await Task.Run(() => CollectInitialFileData(folderPath, fileExtension));
        if (_trainingData.Count < MinimumSampleSize)
        {
            System.Windows.Forms.MessageBox.Show($"학습 모델을 훈련시키기에 샘플이 충분하지 않습니다. 최소 샘플 수: {MinimumSampleSize}");
            Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: 샘플 부족"; });
            return;
        }

        Dispatcher.Invoke(() =>
        {
            dataGridTrainingData.ItemsSource = _trainingData;
            _mlModelBuilder.TrainModel(_trainingData);
            txtTrainingStatus.Text = "학습 완료";
            txtCurrentPatterns.Text = string.Join(", ", _mlModelBuilder.GetRegexPatterns().Select(p => p.ToString()));
        });

        await Task.Run(() => MonitorAndDisplayFilesToDelete(folderPath, fileExtension, driveName));
    }
    catch (Exception ex)
    {
        LogError("모델 훈련 실패: " + ex.Message);
        Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: " + ex.Message; });
    }
}
이제 MLModelBuilder에서 학습한 데이터로부터 정규식을 찾아내고, MainWindow.xaml.cs에서 이를 표시하도록 수정했습니다. GetCurrentPatterns 메