겠습니다. 기존 방식에서 함수 이름을 문자열로 처리하는 것은 실제 비동기 함수 호출 시 적합하지 않습니다. 문자열로는 실제 함수를 호출할 수 없기 때문입니다. 따라서 실제 비동기 함수를 함수 참조로 저장하고, 해당 함수들을 순차적으로 실행할 수 있도록 수정하겠습니다.

목표:
비동기 함수를 직접 정의하고, 그 함수를 리스트에 저장하여 순차적으로 실행할 수 있게 합니다.
각 함수 실행 후 도형이 자동으로 색상이 바뀌고, 실행 시간이 표시되도록 처리합니다.
수정된 TaskModel.cs (실제 함수를 참조로 저장하고 실행하도록 수정)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;
using System.Collections.Generic; // List 사용

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 실행된 함수가 몇 초 동안 실행되었는지 경과 시간을 표시하며, 추가된 함수에 따라 도형 개수가 자동으로 반영됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }

    // 실제 비동기 함수를 저장하는 리스트
    public List<Func<Task>> FunctionTasks { get; set; }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    // 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _stopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending";

        _stopwatch = new Stopwatch(); // Stopwatch 초기화

        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();
        FunctionTasks = new List<Func<Task>>(); // 비동기 함수를 저장할 리스트 초기화

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);

        InitializeFunctions(); // 함수 및 도형 초기화
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running...";
        _stopwatch.Restart(); // Stopwatch 시작

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행합니다.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, FunctionTasks[i]); // 함수 리스트에 저장된 함수를 순차적으로 실행
        }

        // 작업 완료 후 상태 변경 및 경과 시간 표시
        Status = "Completed";
        ProgressText = $"Completed in {_stopwatch.Elapsed.Seconds} seconds";

        StartNextTask?.Invoke(this);
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    public async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, FunctionTasks[taskIndex]); // 특정 함수만 실행
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// 작업 완료 시 경과 시간을 갱신합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            ProgressText = $"Running... ({_stopwatch.Elapsed.Seconds} seconds elapsed)";
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 함수 및 도형을 초기화하는 메서드
    /// </summary>
    private void InitializeFunctions()
    {
        switch (SequenceFlag)
        {
            case 1:
                AddFunction("Task A", ExecuteTaskA);
                AddFunction("Task B", ExecuteTaskB);
                AddFunction("Task C", ExecuteTaskC);
                break;
            case 2:
                AddFunction("Task C", ExecuteTaskC);
                AddFunction("Task B", ExecuteTaskB);
                AddFunction("Task D", ExecuteTaskD);
                break;
            case 3:
                AddFunction("Task A", ExecuteTaskA);
                AddFunction("Task B", ExecuteTaskB);
                AddFunction("Task E", ExecuteTaskE);
                break;
        }

        _functionCount = FunctionNames.Count; // 함수 개수를 도형 개수로 설정
    }

    /// <summary>
    /// 함수와 도형을 추가하는 메서드입니다.
    /// 함수가 추가되면 도형도 자동으로 회색으로 추가됩니다.
    /// </summary>
    private void AddFunction(string functionName, Func<Task> function)
    {
        FunctionNames.Add(functionName); // 함수 이름 추가
        FunctionTasks.Add(function); // 실제 비동기 함수 추가
        FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색) 추가
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task A Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기
        ProgressText = $"Task B Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기
        ProgressText = $"Task C Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기
        ProgressText = $"Task D Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기
        ProgressText = $"Task E Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused";
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed";
    }
}
설명:
비동기 함수 저장:

FunctionTasks 리스트는 실제 비동기 함수를 저장합니다. 각 함수는 **AddFunction()**을 통해 이름과 함수 참조로 저장됩니다. 예를 들어, Task A는 ExecuteTaskA() 함수를 참조합니다.
순차적으로 함수 실행:

**ExecuteTaskSequence()**에서 함수 리스트를 순차적으로 실행합니다. FunctionTasks[i]는 비동기 함수를 참조하여 순서대로 호출됩니다.
단독 함수 실행:

**ExecuteSpecificTask()**에서 특정 인덱스의 함수를 단독 실행할 수 있습니다. 이때도 **FunctionTasks[taskIndex]**에서 해당 함수를 찾아 실행합니다.
동적 함수 추가:

새로운 함수를 추가하려면, **AddFunction()**을 호출하여 함수 이름과 실제 비동기 함수를 리스트에 추가합니다. 이렇게 하면 도형 개수도 자동으로 추가됩니다.
예를 들어, 새로운 함수 Task F를 추가하고 싶다면:
csharp
코드 복사
AddFunction("Task F", ExecuteTaskF);
함수 추가 예시:
만약 새로운 함수 Task F를 추가하려면, 아래와 같이 새로운 함수를 추가하면 됩니다:

새로운 비동기 함수 정의:

csharp
코드 복사
private async Task ExecuteTaskF()
{
    await Task.Delay(1000); // 1초 대기
    ProgressText = $"Task F Completed in {_stopwatch.Elapsed.Seconds} seconds";
}
InitializeFunctions()에 함수 추가:

csharp
코드 복사
case 3:
    AddFunction("Task A", ExecuteTaskA);
    AddFunction("Task B", ExecuteTaskB);
    AddFunction("Task F", ExecuteTaskF); // 새로운 함수 추가
    break;
이제 새로운 Task F 함수가 추가되며, 해당 도형도 자동으로 추가되고 실행됩니다.

이제 각 작업이 순차적으로 실행되며, 실제 비동기 함수가 참조로 저장되어 순차적으로 도형과 함께 실행됩니다. 추가적인 질문이 있거나 더 도움이 필요하면 언제든 말씀해 주세요