송합니다. 원하시는 바를 명확하게 반영하지 못한 점 다시 한 번 사과드립니다. 이번에는 요청하신 내용을 정확히 반영하여 특정 영역만 카메라의 초점과 인식에 관여하게 하고, 나머지 영역은 무시하도록 코드를 작성하겠습니다.

수정된 XML 및 Kotlin 코드
XML 레이아웃 (activity_main.xml):
카메라 미리보기와 특정 영역(노란 테두리)을 포함하는 레이아웃을 정의합니다.
xml
코드 복사
<?xml version="1.0" encoding="utf-8"?>
<RelativeLayout xmlns:android="http://schemas.android.com/apk/res/android"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 카메라 미리보기 -->
    <androidx.camera.view.PreviewView
        android:id="@+id/viewFinder"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:layout_centerInParent="true" />

    <!-- 인식 영역 (노란색 테두리) -->
    <View
        android:id="@+id/focus_area"
        android:layout_width="100dp"
        android:layout_height="100dp"
        android:layout_centerInParent="true"
        android:background="@drawable/focus_border" />

    <!-- 인식된 텍스트를 보여줄 영역 -->
    <TextView
        android:id="@+id/text_view_result"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content"
        android:layout_alignParentBottom="true"
        android:layout_centerHorizontal="true"
        android:text="Scan Result"
        android:textSize="18sp"
        android:textColor="#FFFFFF"
        android:background="#000000"
        android:padding="16dp" />
</RelativeLayout>
Drawable 리소스 (focus_border.xml):
노란색 테두리를 만드는 리소스 파일입니다.
xml
코드 복사
<shape xmlns:android="http://schemas.android.com/apk/res/android">
    <solid android:color="@android:color/transparent" />
    <stroke
        android:width="2dp"
        android:color="#FFFF00" /> <!-- 노란색 테두리 -->
</shape>
Kotlin 코드 (MainActivity.kt):
카메라 미리보기에서 노란 테두리 안쪽 영역만 인식되도록 하며, Continuous Auto Focus 모드를 적용하여 해당 영역에만 초점을 맞춥니다.
kotlin
코드 복사
package com.dxmxsmd.mobilechecker

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Rect
import android.os.Bundle
import android.util.Log
import android.widget.TextView
import android.view.View
import androidx.activity.ComponentActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.camera2.interop.ExperimentalCamera2Interop
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var viewFinder: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var focusArea: View

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewFinder = findViewById(R.id.viewFinder)
        focusArea = findViewById(R.id.focus_area)

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        cameraExecutor = Executors.newSingleThreadExecutor()
    }

    @OptIn(ExperimentalCamera2Interop::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val previewBuilder = Preview.Builder()

            // Camera2Interop을 사용하여 연속 자동 초점 모드 설정
            val camera2Interop = Camera2Interop.Extender(previewBuilder)
            camera2Interop.setCaptureRequestOption(
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE,
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
            )

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(viewFinder.surfaceProvider)
            }

            val barcodeScanner = BarcodeScanning.getClient()

            val imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor, { imageProxy ->
                        processImageProxy(barcodeScanner, imageProxy)
                    })
                }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                cameraProvider.unbindAll()
                val camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageAnalysis
                )

                // 초점 영역을 노란 테두리 영역으로 제한
                val meteringPoint = viewFinder.meteringPointFactory.createPoint(
                    focusArea.x + focusArea.width / 2f,
                    focusArea.y + focusArea.height / 2f
                )
                val action = FocusMeteringAction.Builder(meteringPoint, FocusMeteringAction.FLAG_AF)
                    .setAutoCancelDuration(10, java.util.concurrent.TimeUnit.SECONDS)
                    .build()

                camera.cameraControl.startFocusAndMetering(action)

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    private fun processImageProxy(barcodeScanner: BarcodeScanner, imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val rotationDegrees = imageProxy.imageInfo.rotationDegrees

            // 미리보기 화면에서 포커스 영역의 위치를 계산
            val viewRect = Rect(
                focusArea.left,
                focusArea.top,
                focusArea.right,
                focusArea.bottom
            )

            // 전체 이미지의 크기와 포커스 영역의 위치를 기반으로 관심 영역 계산
            val cropRect = Rect(
                (viewRect.left * mediaImage.width / viewFinder.width),
                (viewRect.top * mediaImage.height / viewFinder.height),
                (viewRect.right * mediaImage.width / viewFinder.width),
                (viewRect.bottom * mediaImage.height / viewFinder.height)
            )

            // 관심 영역을 설정한 후 이미지 인식 수행
            val image = InputImage.fromMediaImage(mediaImage, rotationDegrees).apply {
                cropRect = cropRect
            }

            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        val rawValue = barcode.rawValue
                        findViewById<TextView>(R.id.text_view_result).text = rawValue
                    }
                }
                .addOnFailureListener {
                    // Handle failure
                }
                .addOnCompleteListener {
                    imageProxy.close()
                }
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)
    }
}
주요 변경 사항:
특정 영역만 초점 맞추기:

FocusMeteringAction을 사용해 cameraControl.startFocusAndMetering을 호출하여, 카메라가 특정 영역(노란색 테두리)만 초점을 맞추도록 설정했습니다.
해당 영역만 인식:

이미지 인식 시에도 노란색 테두리 영역만을 사용하도록 이미지의 해당 영역을 잘라내어 인식합니다.
이렇게 하면, 카메라는 노란색 테두리로 정의된 영역에만 초점을 맞추고, 그 외 영역은 초점에 영향을 주지 않습니다. 또한, 해당 영역 내에서만 QR 코드 및 바코드 인식을 수행합니다. 이를 통해 초점이 필요한 영역에만 맞춰지고, 더 정확한 인식을