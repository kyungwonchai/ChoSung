알겠습니다! 보낸 명령, 받은 명령, 응답 시간까지 DB에 기록하는 것을 포함하여, 전체 코드를 주석을 상세히 추가하여 다시 제공하겠습니다. CommandQueueViewModel에서 명령을 보낼 때의 응답 시간도 측정하여 DB에 기록하고, 모든 파일을 완성된 상태로 제공합니다.

1. DB 테이블 생성 스크립트
sql
코드 복사
CREATE TABLE CommandLog (
    Id INT PRIMARY KEY IDENTITY(1,1),
    CommandText NVARCHAR(255), -- 보낸 명령어 텍스트
    SentCommand NVARCHAR(255), -- 실제로 보낸 명령어
    ReceivedCommand NVARCHAR(255), -- 받은 응답
    Status NVARCHAR(50), -- 작업 상태 (Pending, Processing, Completed, Failed)
    Result INT, -- 작업 결과 (1: 성공, 0: 실패)
    RetryCount INT, -- 재시도 횟수
    ResponseTime INT, -- 응답 시간 (밀리초)
    Output NVARCHAR(MAX), -- 명령의 결과 또는 오류 메시지
    Timestamp DATETIME DEFAULT GETDATE() -- 작업 완료 시간
);
DB 설명:
CommandLog 테이블에 보낸 명령(SentCommand), 받은 응답(ReceivedCommand), **응답 시간(ResponseTime)**을 추가 기록하여 모든 정보를 DB에 저장합니다.
2. DatabaseHelper.cs
csharp
코드 복사
using System;
using System.Data.SqlClient;
using System.Threading.Tasks;

public class DatabaseHelper
{
    private string connectionString = "your_connection_string_here"; // DB 연결 문자열

    // 명령과 결과를 DB에 기록하는 함수
    public async Task LogCommandToDatabase(string commandText, string sentCommand, string receivedCommand, string status, int result, int retryCount, int responseTime, string output)
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync();

            // SQL 쿼리 작성: 보낸 명령, 받은 응답, 응답 시간 등 기록
            string query = "INSERT INTO CommandLog (CommandText, SentCommand, ReceivedCommand, Status, Result, RetryCount, ResponseTime, Output, Timestamp) " +
                           "VALUES (@CommandText, @SentCommand, @ReceivedCommand, @Status, @Result, @RetryCount, @ResponseTime, @Output, GETDATE())";

            using (SqlCommand command = new SqlCommand(query, connection))
            {
                // SQL 파라미터 설정
                command.Parameters.AddWithValue("@CommandText", commandText);  // 명령어 텍스트
                command.Parameters.AddWithValue("@SentCommand", sentCommand);  // 보낸 명령
                command.Parameters.AddWithValue("@ReceivedCommand", receivedCommand);  // 받은 응답
                command.Parameters.AddWithValue("@Status", status);            // 상태
                command.Parameters.AddWithValue("@Result", result);            // 결과
                command.Parameters.AddWithValue("@RetryCount", retryCount);    // 재시도 횟수
                command.Parameters.AddWithValue("@ResponseTime", responseTime); // 응답 시간
                command.Parameters.AddWithValue("@Output", output);            // 결과/오류 메시지

                // SQL 명령 실행
                await command.ExecuteNonQueryAsync();
            }
        }
    }
}
DatabaseHelper 설명:
DB에 보낸 명령, 받은 응답, 응답 시간을 포함하여 모든 정보를 기록하는 함수입니다.
3. CommandQueueViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics; // 응답 시간 측정에 사용

public class CommandQueueViewModel : INotifyPropertyChanged
{
    // 명령 큐
    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    
    // UI에 표시할 명령 리스트
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();

    // INotifyPropertyChanged 인터페이스 구현
    public event PropertyChangedEventHandler PropertyChanged;

    // 처리 중 여부 플래그
    private bool _isProcessing; 
    
    // DB 헬퍼 클래스
    private readonly DatabaseHelper _dbHelper;

    // 기본 재시도 횟수와 재시도 간격
    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 2000; // 기본 재시도 간격 2초 (2000ms)

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 처리 중 상태 플래그 초기화
    }

    // 비동기 작업을 큐에 추가하는 함수 (보낸 명령, 응답 검사 포함)
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    // 명령을 큐에 추가하고 처리하는 함수
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        // 새 명령 아이템 생성 및 UI에 추가
        var newCommand = new CommandItem { CommandText = commandText, Status = "Pending" };
        RemainingCommands.Add(newCommand);

        // 명령을 큐에 추가
        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing"; // 명령 처리 시작
            int retryCount = 0; // 재시도 횟수 초기화
            Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치

            while (retryCount < RetryLimit) // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
            {
                try
                {
                    stopwatch.Restart(); // 응답 시간 측정 시작
                    string result = await taskFunc(); // 비동기 작업 실행
                    stopwatch.Stop(); // 응답 시간 측정 완료

                    int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산
                    newCommand.Output = result; // 받은 응답 저장

                    // 응답 검증 - 응답이 정상인지 확인
                    if (responseValidator(result))
                    {
                        // 정상 응답일 경우 성공 처리
                        newCommand.Status = "Completed";
                        newCommand.Result = 1;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        return new CommandResult { Success = true, Message = result };
                    }
                    else
                    {
                        // 응답이 정상적이지 않을 경우 재시도
                        retryCount++;
                        if (retryCount >= RetryLimit)
                        {
                            // 최대 재시도 횟수를 초과할 경우 실패 처리
                            newCommand.Status = "Failed";
                            newCommand.Result = 0;
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Failed after maximum retries: " + result);
                            StopProcessing(); // 큐 처리 중단
                            return new CommandResult { Success = false, Message = result };
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    // 예외 발생 시 실패 처리
                    newCommand.Status = "Failed";
                    newCommand.Result = 0;
                    stopwatch.Stop(); // 예외 시에도 응답 시간 측정 종료
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;

                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred: " + ex.Message); // 오류 알람
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }
            return new CommandResult { Success = false };
        });

        // 작업이 처리 중이 아닌 경우 즉시 처리 시작
        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 명령 큐를 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue(); // 큐에서 작업을 꺼냄
            await command(); // 큐에 있는 작업 실행
            UpdateProgress(); // 프로그레스바 상태 업데이트
        }

        _isProcessing = false; // 모든 작업 완료 후 처리 중 상태 해제
    }

    // 큐 처리 중단 함수
    private void StopProcessing()
    {
        commandQueue.Clear(); // 큐를 비우고 처리 중단
        _isProcessing = false; // 처리 중 상태 해제
    }

    // 알람 표시 (실제 구현은 UI 관련 코드로 연결)
    private void ShowAlarm(string message)
    {
        Console.WriteLine("ALARM: " + message); // 콘솔에 알람 출력 (UI에서 알람 처리 필요)
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count;
    }

    // INotifyPropertyChanged 인터페이스 구현
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    // 프로그레스 상태 저장
    public int Progress { get; private set; }
}
CommandQueueViewModel 설명:
응답 시간을 측정하기 위해 Stopwatch를 사용하여 응답 시간을 기록.
보낸 명령(SentCommand), 받은 응답(ReceivedCommand), **응답 시간(ResponseTime)**까지 DB에 저장.
재시도 횟수를 초과하면 작업 실패로 처리하고 큐 중지 및 알람을 띄움.
4. CommandItem.cs
csharp
코드 복사
public class CommandItem
{
    public string CommandText { get; set; } // 명령어 또는 작업 설명
    public string Status { get; set; } // 작업 상태 (Pending, Processing, Completed, Failed)
    public string Output { get; set; } // 명령의 출력 또는 오류 메시지
    public int Result { get; set; } // 결과 (1: 성공, 0: 실패)
}
CommandItem 설명:
명령의 상태와 결과를 UI에 반영하며, 명령의 출력 값(받은 응답 또는 오류 메시지)을 저장합니다.
5. ClassC (비동기 함수 및 응답 검증)
csharp
코드 복사
public class ClassC
{
    private readonly CommandQueueViewModel _commandQueue;

    public ClassC(CommandQueueViewModel commandQueue)
    {
        _commandQueue = commandQueue;
    }

    // FA 함수 (예시)
    public async Task<string> FA(string param)
    {
        await Task.Delay(500); // 비동기 작업 시뮬레이션
        return "FA Success Response"; // 정상 응답 예시
    }

    // FA 응답 검증 함수
    private bool ValidateFAResponse(string response)
    {
        return response.Contains("Success"); // 응답이 'Success' 포함 여부 확인
    }

    // 큐에 FA 함수 실행 및 검증 추가
    public void EnqueueFA()
    {
        _commandQueue.AddAsyncTaskCommand(() => FA("Param1"), "FA Command", "FA Command Sent", ValidateFAResponse);
    }
}
ClassC 설명:
FA 명령의 응답을 검증하여 정상적인 응답일 때만 다음 작업을 진행.
응답이 정상이 아닐 경우 재시도하고, 실패 시 큐 중단.
6. XAML (UI)
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 남아 있는 명령을 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding CommandQueue.RemainingCommands}" HorizontalAlignment="Left" Height="300" VerticalAlignment="Top" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 명령 텍스트 -->
                        <TextBlock Text="{Binding CommandText}" Width="200"/>
                        <!-- 작업 상태 -->
                        <TextBlock Text=" 상태: " Width="70"/>
                        <TextBlock Text="{Binding Status}" Width="100"/>
                        <!-- 결과 -->
                        <TextBlock Text="{Binding Output}" Width="300"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 남아 있는 명령 수 시각적으로 표시) -->
        <ProgressBar VerticalAlignment="Top" Height="300" Width="30" Orientation="Vertical" Value="{Binding CommandQueue.Progress}" Maximum="10" HorizontalAlignment="Right" Margin="0,0,50,0"/>
    </Grid>
</Window>
XAML 설명:
ListBox: 명령의 상태, 결과, 명령 텍스트를 UI에 표시.
ProgressBar: 큐에 남은 명령 개수를 시각적으로 표현.
결론
보낸 명령(SentCommand), 받은 응답(ReceivedCommand), **응답 시간(ResponseTime)**을 DB에 기록.
N회 응답 시도 후 실패 시 큐 중단 및 알람 표시.
재시도 횟수와 응답 검증을 통해 안정적으로 명령을 처리.
UI에서 명령의 상태와 결과를 확인 가능