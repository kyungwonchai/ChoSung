말 죄송합니다. 이제는 **AlternationIndex**를 사용하지 않는 방식으로, 완전히 다른 방법을 제시하겠습니다. AlternationIndex, RelativeSource, Tag 등을 사용하지 않고 문제를 해결하는 방법을 설명드리겠습니다.

목표:
툴팁에 각 도형에 맞는 함수 이름을 표시합니다.
AlternationIndex, RelativeSource, Tag 등을 사용하지 않는 방식으로 해결합니다.
해결 방안: **ItemsControl**에서 데이터 직접 바인딩
**ItemsControl**의 ItemsSource를 **FunctionNames**와 **FunctionStatusColors**를 함께 묶어서 사용하고, 도형에 함수 이름을 직접 바인딩하는 방식입니다.

1. TaskModel.cs (새로운 바인딩을 위한 코드 수정)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수와 도형 상태를 한 곳에서 관리
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }

    private TaskQueue _taskQueue;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;
        _taskQueue = taskQueue;

        // 리스트 초기화
        FunctionStatusList = new ObservableCollection<FunctionStatus>();

        Status = "Pending";
        ResumeCommand = new RelayCommand(ResumeTask);

        // 함수 추가 (예시)
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
    }

    /// <summary>
    /// 함수 이름, 작업, 도형 색상을 함께 관리
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);  // 도형과 상태를 함께 관리
    }

    /// <summary>
    /// 특정 행부터 작업을 재개하는 함수 (Resume 버튼 클릭 시 호출)
    /// </summary>
    public async void ResumeTask()
    {
        Status = "Running";  // 상태를 Running으로 변경
        _taskQueue.EnqueueTask(async () => await ExecuteTaskSequence());  // 작업을 큐에 등록
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            functionStatus.UpdateStatus(Brushes.SkyBlue);  // 실행 중
            await functionStatus.Task();  // 비동기 작업 실행
            functionStatus.UpdateStatus(Brushes.Green);  // 완료됨
        }
        Status = "Completed";
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}

public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush statusColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = statusColor;
    }

    public void UpdateStatus(Brush newColor)
    {
        StatusColor = newColor;
        OnPropertyChanged(nameof(StatusColor));  // UI 업데이트
    }
}
2. XAML 코드 수정
xml
코드 복사
<ItemsControl ItemsSource="{Binding FunctionStatusList}">
    <ItemsControl.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal" Margin="5">
                <!-- 함수 이름을 직접 표시 -->
                <TextBlock Text="{Binding FunctionName}" VerticalAlignment="Center" HorizontalAlignment="Left"/>

                <!-- 도형 (Ellipse) -->
                <Ellipse Width="30" Height="30" Fill="{Binding StatusColor}">
                    <!-- 툴팁에 함수 이름 표시 -->
                    <Ellipse.ToolTip>
                        <TextBlock Text="{Binding FunctionName}" />
                    </Ellipse.ToolTip>
                </Ellipse>
            </StackPanel>
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>
핵심 변경 사항:
FunctionStatus 클래스:

함수 이름, 작업, 도형의 상태를 하나의 클래스로 묶었습니다.
각 함수와 그에 대한 도형 상태를 **FunctionStatusList**로 관리하여 도형 상태와 함수 이름을 함께 처리합니다.
XAML에서 바인딩:

**FunctionStatusList**에 있는 FunctionName과 StatusColor를 각각 TextBlock과 Ellipse에 바인딩합니다.
ToolTip에서도 FunctionName을 직접 참조하여 함수 이름을 표시합니다.
장점:
명확한 데이터 바인딩: 이제 각 함수와 도형 상태가 FunctionStatus라는 하나의 클래스로 묶여 있어, ItemsControl에서 각각을 관리하기 쉽습니다.
간결한 XAML: 복잡한 AlternationIndex나 RelativeSource를 사용하지 않고, 단순히 **FunctionName**과 **StatusColor**를 직접 바인딩하여 도형과 툴팁을 관리합니다.
이제 이 방법으로 함수 이름이 정상