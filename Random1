된 데이터가 항상 맨 위에 들어가야 한다면, ObservableCollection의 Insert 메서드를 사용하여 **컬렉션의 첫 번째 위치(인덱스 0)**에 항목을 추가하도록 수정해야 합니다. 기본적으로 Add 메서드는 데이터가 컬렉션의 끝에 추가되기 때문에, 새 데이터가 맨 위에 표시되지 않는 문제를 해결할 수 있습니다.

수정된 코드
1. MergeOIErrLogManager
ObservableCollection에 데이터를 추가할 때 맨 위에 삽입하도록 수정합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly object _lock = new object();

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 이벤트로 전달된 로그 처리
    /// </summary>
    /// <param name="logLine">로그 라인</param>
    public void HandleLogEvent(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            Application.Current.Dispatcher.Invoke(() => // 반드시 UI 스레드에서 실행
            {
                lock (_lock)
                {
                    // 항상 맨 위에 삽입
                    LogEntries.Insert(0, newEntry);

                    // 오래된 로그 삭제 (최근 2일치까지만 유지)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. MainViewModel
LogEntries 속성을 통해 UI에서 항상 최신 데이터가 맨 위에 표시되도록 합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    private readonly MergeOIErrLogManager _logManager;
    private readonly SocketClientMergeOI _socketClient;

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => _logManager.LogEntries;

    public MainViewModel()
    {
        _logManager = new MergeOIErrLogManager();
        _socketClient = new SocketClientMergeOI();

        // 이벤트 구독
        _socketClient.OnLogReceived += _logManager.HandleLogEvent;

        // 테스트: 소켓 메시지 시뮬레이션
        Task.Run(() => SimulateSocketMessages());
    }

    /// <summary>
    /// 테스트용: 소켓 메시지 시뮬레이션
    /// </summary>
    private async Task SimulateSocketMessages()
    {
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Connection lost");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("INFO: Reconnected");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Timeout");
    }
}
3. SocketClientMergeOI
이벤트를 통해 MergeOIErrLogManager로 메시지를 전달합니다.

csharp
코드 복사
using System;

public class SocketClientMergeOI
{
    public event Action<string> OnLogReceived;

    private void RaiseLogEvent(string logMessage)
    {
        OnLogReceived?.Invoke(logMessage);
    }

    public void ProcessSocketMessage(string receivedMessage)
    {
        if (receivedMessage.Contains("ERROR"))
        {
            string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] ERROR: {receivedMessage}";
            RaiseLogEvent(logMessage);
        }
    }
}
4. XAML
UI는 LogEntries에 바인딩된 데이터를 자동으로 갱신하며, 새 데이터가 항상 맨 위에 표시됩니다.

xml
코드 복사
<DataGrid ItemsSource="{Binding LogEntries, UpdateSourceTrigger=PropertyChanged}" 
          AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
    <DataGrid.Columns>
        <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
        <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
        <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
    </DataGrid.Columns>
</DataGrid>
주요 변경 사항 요약
LogEntries.Insert(0, newEntry) 사용

Add 대신 Insert를 사용하여 컬렉션의 맨 앞에 데이터를 삽입합니다.
ObservableCollection의 Insert 메서드는 UI에 즉시 반영됩니다.
UI 강제 업데이트

Application.Current.Dispatcher.Invoke를 통해 항상 UI 스레드에서 ObservableCollection을 수정.
오래된 로그 삭제

2일 이상된 로그는 자동으로 삭제.
테스트 결과
새로 들어온 로그가 항상 DataGrid의 맨 위에 표시됩니다.