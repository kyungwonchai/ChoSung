기존의 네임드 파이프(named pipe)를 TCP/IP 소켓 통신으로 대체하여 서비스를 수정하려면, 다음과 같은 주요 단계가 필요합니다:

TCP 서버와 클라이언트 설정: 네임드 파이프 대신 TCP 서버와 클라이언트를 사용하여 통신합니다.
LogService 수정: TCP 서버를 사용하여 로그를 전송하도록 수정합니다.
MainWindow 및 MainViewModel 수정: 클라이언트 측에서 TCP 클라이언트를 사용하여 로그를 수신하도록 수정합니다.
아래는 기존 네임드 파이프 기반의 코드를 TCP/IP 소켓 기반으로 수정한 예제입니다.

1. TcpLogService 클래스 (기존 LogService 대체)
csharp
코드 복사
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class TcpLogService
    {
        private static TcpLogService _instance;
        private TcpListener _listener;
        private CancellationTokenSource _cancellationTokenSource;

        public static TcpLogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new TcpLogService();
                }
                return _instance;
            }
        }

        private TcpLogService()
        {
            // 로그 파일이 저장될 디렉터리 설정
            string logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(logDirectory);
        }

        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => StartServer(_cancellationTokenSource.Token));
        }

        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _listener?.Stop();
        }

        // TCP 서버 시작 메서드
        private async Task StartServer(CancellationToken cancellationToken)
        {
            _listener = new TcpListener(IPAddress.Any, 9000); // 모든 IP의 포트 9000에서 대기
            _listener.Start();
            Console.WriteLine("TCP server started on port 9000.");

            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    TcpClient client = await _listener.AcceptTcpClientAsync(); // 클라이언트 연결 대기
                    Console.WriteLine("Client connected.");
                    _ = Task.Run(() => HandleClient(client, cancellationToken)); // 클라이언트 처리
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Server error: {ex.Message}");
                }
            }

            _listener.Stop();
        }

        // 클라이언트 연결을 처리하는 메서드
        private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)
        {
            using (client)
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) != 0)
                {
                    string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    // 여기서 추가로 로그 메시지 처리 가능
                }
            }
        }

        // 로그 메시지를 기록하고 TCP 클라이언트로 전송하는 메서드
        public void LogMessage(string message)
        {
            try
            {
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";

                // 로그 메시지를 콘솔에 출력 (필요시 파일에도 저장 가능)
                Console.WriteLine(logEntry);

                // TCP 클라이언트에게 전송할 로직 추가 필요
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }
    }
}
2. MainWindow.xaml.cs 수정
TCP 클라이언트를 사용하여 로그 서버에 연결하고, 로그를 수신합니다.

csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;

            StartListeningToLogs(); // 로그 수신을 시작
        }

        // TCP 서버로부터 로그를 수신하는 메서드
        private void StartListeningToLogs()
        {
            Task.Run(async () =>
            {
                try
                {
                    _tcpClient = new TcpClient("127.0.0.1", 9000); // 로컬호스트의 포트 9000에 연결
                    _networkStream = _tcpClient.GetStream();

                    byte[] buffer = new byte[1024];
                    int bytesRead;

                    // 로그 메시지를 지속적으로 수신하여 UI에 표시
                    while ((bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
                    {
                        string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                        Dispatcher.Invoke(() => _viewModel.LogMessages.Add(message)); // UI에 로그 메시지 추가
                    }
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
                }
                finally
                {
                    _networkStream?.Close();
                    _tcpClient?.Close();
                }
            });
        }

        // 필요한 UI 이벤트 핸들러 (예: 서비스 시작/중지 등)
        private void StartService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StartService();
        }

        private void StopService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StopService();
        }

        private void RefreshStatus_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.RefreshServiceStatus();
        }
    }
}
3. MainViewModel.cs 수정
TCP 클라이언트를 사용하여 로그 서버에 연결할 때 필요한 로직을 추가합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ServiceControllerHelper _serviceControllerHelper;
        private string _serviceStatus;

        // 로그 메시지를 저장할 ObservableCollection
        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();

        public string ServiceStatus
        {
            get => _serviceStatus;
            set
            {
                _serviceStatus = value;
                OnPropertyChanged(nameof(ServiceStatus));
            }
        }

        public MainViewModel()
        {
            _serviceControllerHelper = new ServiceControllerHelper();
            RefreshServiceStatus();
        }

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            _serviceControllerHelper.StartService();
            RefreshServiceStatus();
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            _serviceControllerHelper.StopService();
            RefreshServiceStatus();
        }

        // 서비스 상태를 갱신하는 메서드
        public void RefreshServiceStatus()
        {
            ServiceStatus = _serviceControllerHelper.GetServiceStatus();
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
코드 설명
TcpLogService 클래스:

기존 LogService 대신 TCP 소켓을 사용하여 로그 메시지를 클라이언트에 전달하는 서버로 동작합니다.
StartServer 메서드가 클라이언트 연결을 대기하고, HandleClient 메서드가 클라이언트와의 통신을 처리합니다.
LogMessage 메서드를 통해 서비스 내에서 발생하는 모든 로그 메시지를 관리하고, 클라이언트로 전송합니다.
MainWindow.xaml.cs:

StartListeningToLogs 메서드에서 TCP 클라이언트를 사용하여 로그 서버에 연결하고, 로그 메시지를 수신하여 UI에 표시합니다.
MainViewModel.cs:

서비스 제어를 위한 기본 메서드와 함께 로그 메시지를 저장하는 ObservableCollection을 사용하여 로그를 UI에 바인딩합니다.
TCP/IP 소켓을 이용한 IPC의 장점
안정성: 네트워크 기반 통신을 위해 설계되었으며, 네임드 파이프보다 더 안정적일 수 있습니다.
유연성: 로컬 및 원격 연결 모두에서 사용할 수 있으며, 다양한 네트워크 환경에 적응할 수 있습니다.
스케일링: TCP 소켓은 여러 클라이언트와의 동시 연결을 지원하므로, 확장성이 뛰어납니다.
위와 같은 방법으로 TCP/IP 소켓을 이용하여 네임드 파이프를 대체할 수 있습니다. TCP/IP 소켓은 네트워크 통신에서 널리 사용되는 방법이며, 로컬뿐만 아니라 네트워크를 통한 원격 통신에도 적합합니