알겠습니다. App.xaml.cs에서 MainWindow의 메서드를 호출하는 대신, 메세지 브로커 패턴을 사용하여 MainWindow에서 처리하도록 할 수 있습니다. 이를 위해 MainWindow 인스턴스를 추적하고, 그 인스턴스가 ActivateExistingInstance 메서드를 호출하도록 하겠습니다.

1. MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Runtime.InteropServices;
using System.Windows;
using DevExpress.Xpf.Core;
using DevExpress.Xpf.Layout.Core;

namespace ClipboardApp
{
    public partial class MainWindow : DXWindow
    {
        private static MainWindow _instance;

        // 외부 DLL 호출
        [DllImport("user32.dll")]
        private static extern bool SetForegroundWindow(IntPtr hWnd);
        [DllImport("user32.dll")]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        public MainWindow()
        {
            InitializeComponent();
            LoadClipboardContent();
            _instance = this; // 현재 인스턴스를 저장합니다.
        }

        private void LoadClipboardContent()
        {
            if (Clipboard.ContainsText())
            {
                string clipboardText = Clipboard.GetText();
                myTextBox.Text = clipboardText;
            }
        }

        private void DockNewWindow(string content)
        {
            NewWindow newWindow = new NewWindow
            {
                Owner = this
            };
            newWindow.newTextBox.Text = content;

            var newPanel = new LayoutPanel
            {
                Content = newWindow.Content,
                Caption = "New Tab"
            };

            dockLayoutManager.DockController.Dock(newPanel, dockLayoutManager.LayoutRoot, DockType.Fill);
        }

        public static void ActivateExistingInstance(string content)
        {
            if (_instance != null)
            {
                _instance.Dispatcher.Invoke(() =>
                {
                    IntPtr hWnd = FindWindow(null, "Clipboard App");
                    if (hWnd != IntPtr.Zero)
                    {
                        SetForegroundWindow(hWnd);
                        _instance.DockNewWindow(content);
                    }
                });
            }
        }
    }
}
2. App.xaml.cs
App.xaml.cs에서 ActivateExistingInstance 메서드를 호출하는 대신, 프로그램 시작 시 클립보드 내용을 확인하여 처리하도록 합니다.

csharp
코드 복사
using System;
using System.Threading;
using System.Windows;

namespace ClipboardApp
{
    public partial class App : Application
    {
        private static Mutex mutex = null;

        protected override void OnStartup(StartupEventArgs e)
        {
            const string appName = "ClipboardApp";
            bool createdNew;

            mutex = new Mutex(true, appName, out createdNew);

            if (!createdNew)
            {
                // 이미 실행 중인 경우 기존 인스턴스 활성화 및 새 탭 추가
                string clipboardContent = Clipboard.GetText();
                MainWindow.ActivateExistingInstance(clipboardContent);
                Application.Current.Shutdown();
                return;
            }

            base.OnStartup(e);
            new MainWindow().Show();
        }
    }
}
이제 프로그램이 중복 실행될 때, 기존 인스턴스를 활성화하고 새로운 탭을 추가하는 기능이 제대로 동작할 것입니다.

3. NewWindow.xaml.cs
이 부분은 그대로 두어도 됩니다. 추가적인 코드 변경은 필요하지 않습니다.

csharp
코드 복사
using System.Windows;

namespace ClipboardApp
{
    public partial class NewWindow : Window
    {
        public NewWindow()
        {
            InitializeComponent();
        }
    }
}
이 방식으로 중복 실행을 처리하고, 새로운 클립보드 내용을 포함하는 윈도우를 생성하여 도킹할 수 있습니다. 이를 통해 사용자 요구사항을 충족하는 프로그램을 완성할 수