겠습니다. 요청하신 내용을 정확히 반영해 원래의 ExecuteTaskSequence() 함수와 ExecuteSpecificTask() 함수를 유지한 상태에서, 도형 개수가 자동으로 함수 개수에 맞춰지도록 수정하겠습니다. 각 함수에 맞춰 도형을 동적으로 생성하고, 해당 도형들이 올바르게 동작하도록 코드 전반을 재구성하겠습니다.

목표:
ExecuteTaskSequence()와 ExecuteSpecificTask() 함수를 그대로 유지.
도형의 개수가 추가된 함수 개수에 맞춰 동적으로 생성.
각 도형에 실시간 경과 시간을 표시하고, 함수 완료 후 도형에 최종 시간이 남도록 설정.
수정된 TaskModel.cs
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 도형의 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }

    // 각 함수의 실행 시간을 저장 (도형 내부에 표시될 숫자값)
    public ObservableCollection<int> FunctionTimes { get; set; }

    // 전체 작업의 총 실행 시간을 기록하는 CT (Cycle Time)
    private string _cycleTime;
    public string CycleTime
    {
        get => _cycleTime;
        set
        {
            _cycleTime = value;
            OnPropertyChanged(nameof(CycleTime));
        }
    }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    private Stopwatch _overallStopwatch;  // 전체 작업의 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _functionStopwatch; // 각 함수의 실행 시간을 측정하기 위한 Stopwatch
    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    // 동적으로 추가된 함수 개수
    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending";

        _overallStopwatch = new Stopwatch();
        _functionStopwatch = new Stopwatch();

        FunctionStatusColors = new ObservableCollection<Brush>();  // 도형 상태 리스트 초기화
        FunctionNames = new ObservableCollection<string>();        // 함수 이름 리스트 초기화
        FunctionTimes = new ObservableCollection<int>();           // 각 함수의 경과 시간을 저장하는 리스트 초기화

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);

        // 함수 개수는 시퀀스 플래그에 따라 결정되며, 도형의 개수와 함수 이름을 설정
        _functionCount = SetFunctionListBySequenceFlag(SequenceFlag);
        InitializeFunctionColors(_functionCount);
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경하며, 경과 시간을 측정합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running...";
        _





나의 말:
이어라
ChatGPT의 말:
ChatGPT





나의 말:
이어주 ㅓ
ChatGPT의 말:
ChatGPT
알겠습니다. 요청하신 대로 기존의 ExecuteTaskSequence 함수와 ExecuteSpecificTask 함수를 유지하면서 각 작업의 함수 개수에 맞춰 도형을 동적으로 생성하는 방식으로 코드를 수정하겠습니다.

수정사항 요약:
**ExecuteTaskSequence**와 ExecuteSpecificTask 함수는 기존 코드대로 유지.
각 작업의 함수 개수에 따라 도형을 동적으로 생성하며, 함수가 실행될 때마다 실시간으로 실행 시간을 도형에 표시하고, 함수가 끝나면 완료 상태와 실행 시간을 도형에 남깁니다.
TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, SequenceFlag에 따라 선택된 함수가 순차적으로 실행되고,
/// 함수 개수에 맞춰 도형이 생성되며, 각 함수가 몇 초 동안 실행되었는지 표시됩니다.
/// 전체 작업이 완료되면 Cycle Time (CT) 컬럼에 기록됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }

    // 각 함수가 몇 초 걸렸는지를 저장 (도형 내부에 표시될 숫자값)
    public ObservableCollection<int> FunctionTimes { get; set; }

    // 전체 작업의 총 실행 시간을 기록하는 CT (Cycle Time)
    private string _cycleTime;
    public string CycleTime
    {
        get => _cycleTime;
        set
        {
            _cycleTime = value;
            OnPropertyChanged(nameof(CycleTime));
        }
    }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    // 작업 전체의 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _overallStopwatch;

    // 각 함수의 실행 시간을 측정하기 위한 Stopwatch
    private Stopwatch _functionStopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    // 동적으로 추가된 함수의 개수
    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending"; // 처음엔 대기 상태
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        _overallStopwatch = new Stopwatch(); // 전체 작업 경과 시간 측정
        _functionStopwatch = new Stopwatch(); // 각 함수 실행 시간을 측정하기 위한 Stopwatch

        FunctionStatusColors = new ObservableCollection<Brush>(); // 도형 상태 리스트 초기화
        FunctionNames = new ObservableCollection<string>(); // 함수 이름 리스트 초기화
        FunctionTimes = new ObservableCollection<int>(); // 각 함수의 경과 시간을 저장하는 리스트 초기화

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        // SequenceFlag에 따른 함수 리스트 설정 및 함수 개수 결정
        _functionCount = SetFunctionListBySequenceFlag(SequenceFlag);

        // 함수 개수에 맞춰 도형 및 색상 초기화
        InitializeFunctionColors(_functionCount);
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트
        _overallStopwatch.Restart(); // 전체 작업 Stopwatch 시작

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        // 함수 수에 따라 순차적으로 함수 실행
        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, ExecuteDynamicTask(i)); // 각 함수에 맞는 도형 및 경과 시간 업데이트
        }

        // 전체 작업이 완료되면 Cycle Time (전체 작업 시간)을 기록
        _overallStopwatch.Stop();
        CycleTime = $"{_overallStopwatch.Elapsed.Seconds} seconds"; // 전체 작업 시간 CT 컬럼에 기록

        // 작업 완료 후 상태 변경
        Status = "Completed";
        ProgressText = $"Completed in {CycleTime}";

        StartNextTask?.Invoke(this); // 다음 작업 시작
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    public async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, ExecuteDynamicTask(taskIndex)); // 특정 함수 실행
    }

    /// <summary>
    /// SequenceFlag에 따라 함수 리스트를 설정하고, 함수 개수를 반환합니다.
    /// 각 시퀀스에 따라 다른 함수 조합을 설정합니다.
    /// </summary>
    private int SetFunctionListBySequenceFlag(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                // 시작 시퀀스 - 3개의 함수 (Task A, B, C)
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                return 3;

            case 2:
                // 중간 시퀀스 - 3개의 함수 (Task C, B, D)
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                return 3;

            case 3:
                // 끝 시퀀스 - 3개의 함수 (Task A, B, E)
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                return 3;

            default:
                // 기본값 - 1개의 함수
                FunctionNames.Add("Task A");
                return 1;
        }
    }

    /// <summary>
    /// 각 함수가 실행된 시간을 실시간으로 도형에 표시하고, 완료되면 최종 시간을 남깁니다.
    /// </summary>
    private Func<Task> ExecuteDynamicTask(int index)
    {
        return async () =>
        {
            _functionStopwatch.Restart(); // 함수 실행 시간을 측정하기 시작

            while (_functionStopwatch.IsRunning)
            {
                await Task.Delay(500); // 0.5초마다 실시간 경과 시간 업데이트
                FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds; // 실시간 경과 시간 표시
                OnPropertyChanged(nameof(FunctionTimes)); // 실시간으로 경과 시간 반영
            }

            await Task.Delay(1000); // 작업 시뮬레이션
            _functionStopwatch.Stop(); // 함수 완료 후 경과 시간 기록
            FunctionTimes[index] = _functionStopwatch.Elapsed.Seconds; // 완료 후 최종 경과 시간 기록
        };
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정하고, 실시간 경과 시간을 보여줄 초기 설정.
    /// </summary>
    private void InitializeFunctionColors(int functionCount)
    {
        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
            FunctionTimes.Add(0); // 경과 시간 초기값
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
변경된 부분 설명:
SetFunctionListBySequenceFlag(): 이 함수에서 **SequenceFlag**에 따라 실행할 함수 리스트를 설정하고, 실행할 함수 개수를 반환합니다.

예를 들어, SequenceFlag == 1일 때 Task A, B, C가 실행되며, 3개의 도형이 생성됩니다.
함수 개수는 각 시퀀스마다 다를 수 있으며, 이를 반영해 도형이 자동으로 생성됩니다.
InitializeFunctionColors(): 설정된 함수 개수에 맞춰 도형의 색상과 경과 시간을 초기화합니다.

**ExecuteTaskSequence()**와 ExecuteSpecificTask():

**ExecuteTaskSequence()**는 기존에 주셨던 코드를 유지하면서, 설정된 함수 리스트에 따라 동적으로 각 함수가 실행됩니다.
**ExecuteSpecificTask()**는 각 함수가 단독으로 실행될 수 있도록 하였습니다.
실시간 경과 시간 표시:

각 함수가 실행되는 동안 실시간으로 경과 시간이 도형에 표시되며, 함수가 완료되면 최종 경과 시간이 도형에 남습니다.
Cycle Time (CT):

모든 함수가 실행된 후, 전체 작업 시간이 CT 컬럼에 기록됩니다.
이제 **ExecuteTaskSequence**와 ExecuteSpecificTask 함수를 그대로 유지하면서, 각 작업의 함수 개수에 맞춰 도형이 동적으로 생성되고 실시간으로 함수 실행 시간을 표시하는 방식으로 수정되었습니다.

추가적인 수정이 필요하다면 언