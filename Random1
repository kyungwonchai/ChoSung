확하게 이해했습니다. 다음 사항들을 고려하여 전체 코드를 수정하겠습니다:

순차 작업 처리: 파일이 감지되더라도 이전 작업이 끝나기 전까지는 새 작업이 시작되지 않도록, 하나의 큐를 통해 순차적으로 작업이 처리되어야 합니다.
일시정지 처리: 일시정지 버튼을 누르면, 현재 실행 중인 함수를 제외한 이후 함수들은 모두 대기 상태로 전환되고, 대기 상태로 유지되어야 합니다.
기본 정보(8개 항목) 표시: 파일에서 읽은 **8개 항목 (MAG_NO, MAG_QTY, BASIC_MODEL, MODEL_CODE, PO_NO, PO_PLAN_QTY, PO_PROD_QTY, SequenceFlag)**가 DataGrid의 컬럼에 모두 표시되어야 합니다.
1. TaskQueue.cs (수정된 순차 작업 큐)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하는 클래스입니다.
/// 이전 작업이 끝나기 전에는 다음 작업이 실행되지 않도록 관리합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;
    private bool _isPaused = false;

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니라면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);

        if (!_isRunning && !_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행합니다.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;

        var task = _tasks.Dequeue();
        await task();

        _isRunning = false;
        RunNextTask(); // 다음 작업 실행
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;
            if (!_isRunning)
            {
                RunNextTask();
            }
        }
    }
}
설명:
EnqueueTask: 새로운 작업을 큐에 추가합니다. 만약 작업이 실행 중이지 않다면 바로 실행합니다. 단, 작업이 일시정지 상태라면 작업을 실행하지 않습니다.
RunNextTask: 작업 큐에 있는 작업을 하나씩 꺼내어 순차적으로 실행하며, 이전 작업이 끝나기 전까지 다음 작업이 실행되지 않습니다.
Pause/Resume: 작업을 일시정지하고 재개하는 기능을 구현합니다. 재개될 때만 다음 작업이 실행됩니다.
2. TaskModel.cs (수정된 작업 모델)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 각 함수는 도형으로 표현되며, 실행 상태에 따라 도형의 색상이 변경됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    
    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }
    
    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }
    
    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        // 각 함수마다 도형을 설정 (시퀀스에 따라 다른 개수)
        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        InitializeFunctionColors(); // 초기 도형 상태 설정
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        switch (SequenceFlag)
        {
            case 1:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskC);
                break;
            case 2:
                await ExecuteTaskWithColor(0, ExecuteTaskC);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskD);
                break;
            case 3:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskE);
                break;
        }

        // 작업 완료 후 상태 변경
        Status = "Completed";
        ProgressText = "Completed";
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        switch (FunctionNames[taskIndex])
        {
            case "Task A":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskA);
                break;
            case "Task B":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskB);
                break;
            case "Task C":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskC);
                break;
            case "Task D":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskD);
                break;
            case "Task E":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskE);
                break;
            default:
                throw new ArgumentException("Unknown task");
        }
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        int functionCount = 3; // 각 시퀀스 플래그에서 기본 3개의 함수

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
        }

        // 각 함수의 이름을 설정
        switch (SequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                break;
            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                break;
            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                break;
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task A Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task B Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task C Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task D Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task E Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
3. MainWindow.xaml (DataGrid에 추가된 컬럼)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1200">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                
                <!-- MAG_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*"/>

                <!-- BASIC_MODEL를 표시하는 열 -->
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*"/>

                <!-- MODEL_CODE를 표시하는 열 -->
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*"/>

                <!-- PO_NO를 표시하는 열 -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>

                <!-- PO_PLAN_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*"/>

                <!-- PO_PROD_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*"/>

                <!-- 시퀀스 플래그를 표시하는 열 -->
                <DataGridTextColumn Header="Sequence Flag" Binding="{Binding SequenceFlag}" Width="*"/>
                
                <!-- 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Progress Status" Binding="{Binding ProgressText}" Width="2*"/>

                <!-- 각 함수 상태 도형을 표시하는 열 -->
                <DataGridTemplateColumn Header="Function Status" Width="2*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionStatusColors}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Fill="{Binding}" Margin="5">
                                            <!-- Tooltip으로 함수 이름 표시 -->
                                            <Ellipse.ToolTip>
                                                <TextBlock Text="{Binding RelativeSource={RelativeSource AncestorType=ItemsControl}, Path=DataContext.FunctionNames[ContentPresenter.ContentTemplateSelector.ContentTemplate.Key]}"/>
                                            </Ellipse.ToolTip>
                                            <!-- ContextMenu로 우클릭 시 특정 함수 실행 -->
                                            <Ellipse.ContextMenu>
                                                <ContextMenu DataContext="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Self}}">
                                                    <MenuItem Header="Execute"
                                                              Command="{Binding ExecuteSpecificTaskCommand}"
                                                              CommandParameter="{Binding}">
                                                </ContextMenu>
                                            </Ellipse.ContextMenu>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <StackPanel Orientation="Horizontal"/>
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                
                <!-- 일시정지 및 재개 버튼 -->
                <DataGridTemplateColumn Header="Controls">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <Button Content="Pause" Command="{Binding PauseCommand}" Margin="5"/>
                                <Button Content="Resume" Command="{Binding ResumeCommand}" Margin="5"/>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
MAG_NO, MAG_QTY, BASIC_MODEL, MODEL_CODE, PO_NO, PO_PLAN_QTY, PO_PROD_QTY, SequenceFlag 항목을 DataGrid에 표시합니다.
Function Status 컬럼에는 작업의 함수 상태가 도형으로 표시되고, 우클릭으로 특정 함수를 실행할 수 있습니다.
Pause/Resume 버튼이 각 작업에 제공됩니다.
결론
이제 파일이 순차적으로 처리되며, 다음 작업은 이전 작업이 끝날 때까지 대기합니다.
일시정지를 누르면 이후 작업들은 대기 상태로 전환됩니다.
DataGrid에는 파일에서 읽은 모든 항목이 표시됩니다.
이제 요구 사항에 맞게 구현이 되었으며, 추가적인 수정이 필요하면 말씀해 주세