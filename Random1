정말 죄송합니다. 이제 말씀하신 **파일 순서( MAG_NO, MAG_QTY, BASIC_MODEL, MODEL_CODE, PO_NO, PO_PLAN_QTY, PO_PROD_QTY )**를 정확히 반영하여 FileProcessor와 관련 파일 전체를 수정하겠습니다. 각 파일을 주석 포함하여 제공하겠습니다.

FileProcessor.cs (수정된 전체 코드)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// FileProcessor는 지정된 폴더에서 로그 파일을 감지하고, 새로운 파일이 있을 때 LogEntry로 변환하여 처리합니다.
/// 날짜 정보를 추출하여 파일을 정렬하고, 새로 추가된 파일만 처리합니다.
/// PO_NO 별로 PO_PLAN_QTY에 맞춰 시퀀스 플래그(1, 2, 3)를 결정합니다.
/// </summary>
public class FileProcessor
{
    private readonly string _logDirectory; // 로그 파일 경로
    private Action<LogEntry> _onFileDetected; // 파일이 감지되었을 때 호출될 콜백
    private DateTime _lastProcessedFileDateTime = DateTime.MinValue; // 마지막으로 처리된 파일의 시간
    private Dictionary<string, int> _poNoToProdQtyMap = new Dictionary<string, int>(); // PO_NO별로 누적 생산 수량을 저장

    public FileProcessor(string logDirectory, Action<LogEntry> onFileDetected)
    {
        _logDirectory = logDirectory;
        _onFileDetected = onFileDetected;
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 새로운 파일이 있으면 날짜 순으로 정렬 후 처리합니다.
    /// </summary>
    public async void StartProcessing()
    {
        while (true)
        {
            // 지정된 디렉토리에서 모든 파일을 가져옵니다.
            var files = Directory.GetFiles(_logDirectory, "*.txt");

            // 파일 이름에서 날짜를 추출하고 날짜 순으로 정렬합니다.
            var sortedFiles = files
                .Where(f => TryExtractDateTimeFromFileName(f, out _))
                .OrderBy(f => ExtractDateTimeFromFileName(f))
                .ToList();

            // 새로운 파일이 있는지 확인하고 처리
            foreach (var file in sortedFiles)
            {
                DateTime fileDateTime = ExtractDateTimeFromFileName(file);

                // 새로 추가된 파일만 처리 (마지막으로 처리된 파일 이후의 파일)
                if (fileDateTime > _lastProcessedFileDateTime)
                {
                    var logEntry = ParseLogFile(file);

                    // PO_NO의 누적 생산 수량을 업데이트하고 시퀀스 플래그를 결정
                    logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

                    // 새로운 로그 엔트리를 콜백에 전달
                    _onFileDetected?.Invoke(logEntry);

                    // 마지막 처리 시간 업데이트
                    _lastProcessedFileDateTime = fileDateTime;
                }
            }

            await Task.Delay(5000); // 5초마다 폴더를 확인
        }
    }

    /// <summary>
    /// PO_NO별 누적 생산 수량을 바탕으로 시퀀스 플래그(1: 첫 파일, 2: 중간 파일, 3: 마지막 파일)를 결정합니다.
    /// </summary>
    private int DetermineSequenceFlag(LogEntry logEntry)
    {
        // PO_NO별 누적 생산 수량을 관리하는 딕셔너리에서 현재 PO_NO의 생산 수량을 가져옴
        if (!_poNoToProdQtyMap.TryGetValue(logEntry.PO_NO, out int currentProdQty))
        {
            currentProdQty = 0; // 해당 PO_NO가 처음 발견된 경우 누적 생산량은 0
        }

        // 현재 파일에서 생산된 물량을 누적 생산 수량에 더함
        int updatedProdQty = currentProdQty + logEntry.MAG_QTY;

        // 시퀀스 플래그 결정: 첫 파일, 중간 파일, 마지막 파일
        if (currentProdQty == 0)
        {
            // 처음 생산되는 파일일 경우
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 1; // 첫 파일
        }
        else if (updatedProdQty >= logEntry.PO_PLAN_QTY)
        {
            // 생산량이 계획 수량에 도달하면 마지막 파일로 간주
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 3; // 마지막 파일
        }
        else
        {
            // 중간 파일일 경우
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 2; // 중간 파일
        }
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출하여 DateTime으로 변환합니다.
    /// 파일명 형식은 "W_test_yyyyMMddHHmmss.txt" 형식으로 가정합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName); // 확장자를 제외한 파일 이름만 가져옴
        var dateTimePart = baseFileName.Split('_')[1]; // 파일명에서 날짜 부분 추출

        // "yyyyMMddHHmmss" 형식을 DateTime으로 변환
        DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out DateTime fileDateTime);
        return fileDateTime;
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출할 수 있는지 확인합니다.
    /// </summary>
    private bool TryExtractDateTimeFromFileName(string fileName, out DateTime fileDateTime)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName);
        var dateTimePart = baseFileName.Split('_')[1];

        // 날짜 형식이 올바른지 검증
        return DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out fileDateTime);
    }

    /// <summary>
    /// 로그 파일을 읽어서 LogEntry 객체로 변환합니다.
    /// 파일 내 데이터는 다음 순서로 제공됩니다:
    /// 1. MAG_NO, 2. MAG_QTY, 3. BASIC_MODEL, 4. MODEL_CODE, 5. PO_NO, 6. PO_PLAN_QTY, 7. PO_PROD_QTY
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);
        return new LogEntry
        {
            MAG_NO = lines[0], // MAG_NO
            MAG_QTY = int.Parse(lines[1]), // MAG_QTY
            BASIC_MODEL = lines[2], // BASIC_MODEL
            MODEL_CODE = lines[3], // MODEL_CODE
            PO_NO = lines[4], // PO_NO
            PO_PLAN_QTY = int.Parse(lines[5]), // PO_PLAN_QTY (전체 생산 계획 수량)
            PO_PROD_QTY = int.Parse(lines[6]), // PO_PROD_QTY (현재까지 누적된 생산 수량)
            // SequenceFlag는 DetermineSequenceFlag 메서드를 통해 결정됨
        };
    }
}
주요 변경 사항:
파일 내 항목 순서:

파일에서 읽는 순서를 맞추기 위해 MAG_NO, MAG_QTY, BASIC_MODEL, MODEL_CODE, PO_NO, PO_PLAN_QTY, PO_PROD_QTY 순으로 데이터를 읽습니다.
각각의 항목이 파일에서 제공되는 순서대로 처리되며, 이를 통해 로그 엔트리로 변환합니다.
시퀀스 플래그(SequenceFlag):

DetermineSequenceFlag 메서드를 사용하여 PO_NO의 생산 순서에 따라 처음, 중간, 끝 파일을 구분합니다.
각 MAG_QTY를 누적하여 PO_PLAN_QTY와 비교해 마지막 파일인지 판단합니다.
LogEntry.cs
csharp
코드 복사
/// <summary>
/// 로그 파일에서 읽은 데이터를 저장하는 LogEntry 클래스.
/// 파일 내 데이터는 다음 순서로 제공됩니다:
/// 1. MAG_NO, 2. MAG_QTY, 3. BASIC_MODEL, 4. MODEL_CODE, 5. PO_NO, 6. PO_PLAN_QTY, 7. PO_PROD_QTY
/// </summary>
public class LogEntry
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; } // 전체 생산 계획 수량
    public int PO_PROD_QTY { get; set; } // 현재까지 누적된 생산 수량
    public int SequenceFlag { get; set; } // 시퀀스 플래그 (1: 첫 파일, 2: 중간 파일, 3: 마지막 파일)
}
설명:
LogEntry 클래스는 파일에서 읽은 데이터를 구조화된 형태로 저장합니다.
각 파일의 MAG_NO, MAG_QTY, BASIC_MODEL, MODEL_CODE, PO_NO, PO_PLAN_QTY, PO_PROD_QTY 정보를 포함합니다.
**SequenceFlag**는 해당 파일이 처음인지, 중간인지, 끝인지 나타냅니다.
MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.Threading.Tasks;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel입니다.
/// 로그 파일을 감지하고 작업을 처리하는 역할을 합니다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // DB 헬퍼 클래스 인스턴스 (MSSQL에 로그 전송 담당)
    private DBHelper _dbHelper;

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업을 일시 정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업을 재개
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // MSSQL 데이터베이스 연결 문자열 설정
        string connectionString = "your_connection_string_here";
        _dbHelper = new DBHelper(connectionString);

        // 작업 큐와 DB 헬퍼 인스턴스를 설정
        _taskQueue = new TaskQueue(_dbHelper);

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 일시 정지 및 재개 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        var task = new TaskModel(logEntry, _taskQueue);
        TaskList.Add(task); // 작업 목록에 추가
    }

    /// <summary>
    /// 모든 작업을 일시 정지하는 메서드입니다.
    /// </summary>
    private void PauseAllTasks()
    {
        // 모든 작업 일시 정지 로직 구현 필요
    }

    /// <summary>
    /// 모든 작업을 재개하는 메서드입니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        // 모든 작업 재개 로직 구현 필요
    }
}
설명:
OnLogEntryDetected 메서드에서 새로운 로그 파일을 감지하면, **TaskModel**을 생성하여 작업 큐에 추가합니다.
파일 감지를 담당하는 FileProcessor와 작업 큐를 연결합니다.
이 코드는 요청하신 요구 사항을 반영하여, 파일을 정확한 순서로 처리하고 PO_NO 별로 **시퀀스 플래그(처음, 중간, 마지막)**를