 5초 간격으로 해당 함수를 재시도하고, 최대 5회까지 재시도를 시도하는 로직입니다. 모든 시도에서 실패하면 최종적으로 실패(NG) 결과를 반환합니다.

코드 구현
csharp
코드 복사
private async Task<string> ProcessMESOI(string val, int sequence)
{
    // 결과를 저장할 Dictionary
    var resultMap = new Dictionary<string, Func<Task<string>>>();
    var resultStatus = new Dictionary<string, string>();

    // 시퀀스에 따라 실행할 함수 선택
    switch (sequence)
    {
        case 1:
            resultMap["SendtoMergeOI_MAGNO"] = () => SendtoMergeOI_MAGNO(val);
            resultMap["SendtoMergeOI_ForceSave"] = () => SendtoMergeOI_ForceSave(val);
            break;

        case 2:
            resultMap["SendtoMergeOI_MAGNO"] = () => SendtoMergeOI_MAGNO(val);
            break;

        case 3:
            resultMap["SendtoMergeOI_ForceSave"] = () => SendtoMergeOI_ForceSave(val);
            break;

        case 4:
            resultMap["SendtoMergeOI_NewFunction1"] = () => SendtoMergeOI_NewFunction1(val);
            resultMap["SendtoMergeOI_NewFunction2"] = () => SendtoMergeOI_NewFunction2(val);
            break;

        default:
            return "NG: Invalid sequence";
    }

    // 함수 실행 및 재시도 로직
    foreach (var func in resultMap)
    {
        int retries = 0;
        bool success = false;

        while (retries < 5 && !success)
        {
            string result = await func.Value();
            if (result == "OK")
            {
                resultStatus[func.Key] = "OK";
                success = true;
            }
            else
            {
                resultStatus[func.Key] = $"NG: {func.Key} ({result})";
                retries++;
                if (retries < 5)
                {
                    await Task.Delay(5000); // 5초 대기
                }
            }
        }

        // 5회 시도 후에도 실패했다면 최종 실패 처리
        if (!success)
        {
            return resultStatus[func.Key]; // 가장 먼저 실패한 함수 반환
        }
    }

    // 모든 함수 성공 시 OK 반환
    return "OK";
}

// 예제 함수들
private async Task<string> SendtoMergeOI_MAGNO(string val)
{
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "MAGNO" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

private async Task<string> SendtoMergeOI_ForceSave(string val)
{
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "ForceSave" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

private async Task<string> SendtoMergeOI_NewFunction1(string val)
{
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "NewValue1" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

private async Task<string> SendtoMergeOI_NewFunction2(string val)
{
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "NewValue2" ? "OK" : "MG"; // 조건에 따라 결과 반환
}
동작 설명
함수 맵핑:

실행할 함수들을 Dictionary<string, Func<Task<string>>>에 저장하여 관리합니다.
각 함수의 이름(Key)과 해당 비동기 작업(Value)을 매핑합니다.
재시도 로직:

각 함수마다 최대 5회까지 재시도를 수행합니다.
한 번 실패할 때마다 5초 대기 후 재시도하며, 5회 모두 실패하면 해당 함수의 NG 메시지를 반환합니다.
성공 여부 확인:

모든 함수가 "OK"를 반환한 경우에만 최종적으로 "OK"를 반환합니다.
하나라도 실패하면 즉시 NG 메시지를 반환합니다.
결과 저장:

resultStatus에 각 함수의 실행 결과를 저장해 실패 원인을 추적할 수 있습니다.
결과 예제
예제 1: 모든 함수 성공
csharp
코드 복사
string result = await ProcessMESOI("MAGNO", 1);
/* 결과:
"OK"
*/
예제 2: 함수 하나 실패 (5회 재시도 후 실패)
csharp
코드 복사
string result = await ProcessMESOI("INVALID", 1);
/* 결과:
"NG: SendtoMergeOI_MAGNO (MG)"
*/
예제 3: 여러 함수, 첫 번째 함수 성공, 두 번째 함수 실패
csharp
코드 복사
string result = await ProcessMESOI("MAGNO_INVALID", 4);
/* 결과:
"NG: SendtoMergeOI_NewFunction2 (MG)"
*/
주요 장점
재시도 구현:

각 함수가 실패해도 5초 간격으로 최대 5회까지 재시도하므로 일시적인 오류에 유연하게 대처합니다.
유연한 함수 관리:

Dictionary를 사용해 함수 이름과 로직을 매핑하므로 시퀀스와 함수 구성이 독립적이며 확장성 높습니다.
실패 원인 명확화:
