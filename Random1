물론입니다. 요청하신 대로 CSV 출력 컬럼을 경로, 저장소명칭(중복없이 추천), 프로그램 역할(추정), 추천토픽명으로 수정한 전체 파이썬 코드를 다시 작성해 드립니다.

저장소 명칭: 동일한 실행 내에서 중복된 이름이 생성될 경우, -1, -2 와 같이 숫자를 붙여 고유성을 보장합니다.

추천 토픽명: 분석된 프로그램의 역할(특징)들을 aspnet-core, web-api 와 같이 GitHub 토픽 형식에 맞게 변환하여 쉼표로 구분된 문자열로 제공합니다.

최종 Python 코드 (analyze_solutions_v2.py)
아래 코드를 analyze_solutions_v2.py 같은 이름으로 저장하여 사용하시면 됩니다.

Python

import os
import re
import csv
import xml.etree.ElementTree as ET
from pathlib import Path

# --- 분석을 위한 키워드 사전 ---
# 키워드(소문자)와 매칭될 특징(태그)을 정의합니다. 필요에 따라 확장할 수 있습니다.
FEATURE_KEYWORDS = {
    # .csproj 파일의 PackageReference 분석용
    'microsoft.aspnetcore': 'ASP.NET Core',
    'microsoft.entityframeworkcore': 'EF Core DB',
    'dapper': 'Dapper DB',
    'newtonsoft.json': 'JSON 처리',
    'xunit': 'xUnit 테스트',
    'nunit': 'NUnit 테스트',
    'mstest.testframework': 'MSTest 테스트',
    'microsoft.extensions.hosting': 'Worker 서비스',
    'microsoft.net.http': 'HTTP 클라이언트',
    'automapper': 'AutoMapper',
    'serilog': 'Serilog 로깅',
    'hangfire': 'Hangfire 백그라운드 작업',
    'identityserver': 'IdentityServer 인증',
    'microsoft.aspnetcore.identity': 'ASP.NET Identity',

    # 소스코드(*.cs) 내용 분석용
    'controllerbase': 'Web API',
    'controller': 'MVC 웹',
    'dbcontext': 'EF Core DB',
    'wpf': 'WPF 데스크톱 앱',
    'windows.forms': 'WinForms 데스크톱 앱',
    'xamarin.forms': 'Xamarin 모바일 앱',
    'maui': '.NET MAUI 모바일/데스크톱 앱',
    'console.writeline': '콘솔 애플리케이션',
    'httpclient': 'HTTP 클라이언트',
    'blazor': 'Blazor 웹 앱',
    'grpc': 'gRPC 서비스',
}

def find_project_files(sln_path):
    """솔루션(.sln) 파일 내용에서 프로젝트(.csproj) 파일 경로를 찾습니다."""
    project_files = []
    sln_dir = os.path.dirname(sln_path)
    try:
        with open(sln_path, 'r', encoding='utf-8-sig') as f:
            content = f.read()
            matches = re.findall(r'Project\("\{[A-Z0-9-]+\}"\) = ".*?", "(.*?\.csproj)",', content, re.IGNORECASE)
            for proj_path in matches:
                full_proj_path = os.path.join(sln_dir, proj_path.replace('\\', os.sep))
                if os.path.exists(full_proj_path):
                    project_files.append(full_proj_path)
    except FileNotFoundError:
        print(f"  [오류] 솔루션 파일을 찾을 수 없습니다: {sln_path}")
    except Exception as e:
        print(f"  [오류] 솔루션 파일 분석 중 오류 발생: {e}")
    return project_files

def analyze_project_and_sources(csproj_path):
    """프로젝트 파일과 소스 코드를 분석하여 특징 태그 집합을 반환합니다."""
    features = set()
    project_dir = os.path.dirname(csproj_path)

    # 1. .csproj 파일 분석 (NuGet 패키지 참조 확인)
    try:
        tree = ET.parse(csproj_path)
        root = tree.getroot()
        for package_ref in root.findall(".//*[local-name()='PackageReference']"):
            package_name = package_ref.get('Include', '').lower()
            for keyword, feature in FEATURE_KEYWORDS.items():
                if keyword in package_name:
                    features.add(feature)
    except (ET.ParseError, FileNotFoundError):
        # print(f"  [경고] .csproj 파일 처리 실패: {csproj_path}")
        pass # 오류가 있어도 중단하지 않음

    # 2. 소스 코드(*.cs) 파일 분석 (주요 키워드 확인)
    for source_file_path in Path(project_dir).rglob('*.cs'):
        try:
            with open(source_file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content_lower = f.read().lower()
                for keyword, feature in FEATURE_KEYWORDS.items():
                    if keyword in content_lower:
                        features.add(feature)
        except Exception:
            pass # 개별 소스 파일 읽기 오류는 무시하고 계속 진행

    return features

def generate_base_repo_name(sln_path):
    """솔루션 파일명으로 GitHub 저장소 기본 이름을 생성합니다."""
    base_name = os.path.basename(sln_path)
    name_without_ext = os.path.splitext(base_name)[0]
    repo_name = re.sub(r'[^a-zA-Z0-9]', '-', name_without_ext).lower()
    return re.sub(r'-+', '-', repo_name).strip('-')

def generate_topics_from_features(features_set):
    """분석된 특징 집합으로 GitHub 토픽 문자열을 생성합니다."""
    if not features_set:
        return ""
    
    topics = [
        feature.lower().replace(' ', '-').replace('.', '')
        for feature in sorted(list(features_set))
    ]
    return ', '.join(topics)

def main():
    """메인 실행 함수"""
    input_file = 's1.txt'
    output_file = 'solution_analysis_result.csv'

    if not os.path.exists(input_file):
        print(f"입력 파일 '{input_file}'을 찾을 수 없습니다.")
        with open(input_file, 'w', encoding='utf-8') as f:
            f.write("C:\\path\\to\\your\\first-project.sln\n")
            f.write("D:\\another-project\\another-project.sln\n")
        print(f"예시 입력 파일 '{input_file}'을 생성했습니다. 내용을 수정 후 다시 실행해주세요.")
        return

    analysis_results = []
    generated_repo_names = set()

    print(f"'{input_file}' 파일에서 솔루션 목록을 읽는 중...")
    with open(input_file, 'r', encoding='utf-8') as f:
        sln_paths = [line.strip() for line in f if line.strip().endswith('.sln')]

    print(f"총 {len(sln_paths)}개의 솔루션을 분석합니다.")
    print("-" * 30)

    for sln_path in sln_paths:
        if not os.path.exists(sln_path):
            print(f"[경고] 경로를 찾을 수 없습니다. 건너뜁니다: {sln_path}")
            continue

        print(f"분석 중: {sln_path}")
        
        all_features = set()
        project_files = find_project_files(sln_path)

        if project_files:
            for csproj_path in project_files:
                project_features = analyze_project_and_sources(csproj_path)
                all_features.update(project_features)

        # 1. 프로그램 역할(추정) 생성
        program_role = ', '.join(sorted(list(all_features))) if all_features else "기본 .NET 프로젝트"

        # 2. 저장소명칭(중복없이 추천) 생성
        base_repo_name = generate_base_repo_name(sln_path)
        final_repo_name = base_repo_name
        counter = 1
        while final_repo_name in generated_repo_names:
            final_repo_name = f"{base_repo_name}-{counter}"
            counter += 1
        generated_repo_names.add(final_repo_name)

        # 3. 추천토픽명 생성
        recommended_topics = generate_topics_from_features(all_features)
        
        # 최종 결과 추가
        analysis_results.append([sln_path, final_repo_name, program_role, recommended_topics])
        print(f"  -> 역할: {program_role}")
        print(f"  -> 저장소명: {final_repo_name}")
        print(f"  -> 토픽: {recommended_topics}")


    # CSV 파일로 결과 저장
    try:
        with open(output_file, 'w', newline='', encoding='utf-8-sig') as f:
            writer = csv.writer(f)
            # 새로운 컬럼명으로 헤더 작성
            writer.writerow(['경로', '저장소명칭(중복없이 추천)', '프로그램 역할(추정)', '추천토픽명'])
            writer.writerows(analysis_results)
        print("-" * 30)
        print(f"분석 완료! 결과가 '{output_file}' 파일에 저장되었습니다.")
    except Exception as e:
        print(f"\n[오류] 결과를 CSV 파일에 쓰는 중 오류가 발생했습니다: {e}")

if __name__ == '__main__':
    main()
사용 방법 및 결과
사용 방법은 이전과 동일합니다.

위 코드를 파이썬 파일(예: analyze_solutions_v2.py)로 저장합니다.

같은 위치에 분석할 솔루션의 전체 경로가 담긴 s1.txt 파일을 준비합니다.

터미널에서 python analyze_solutions_v2.py 명령으로 스크립트를 실행합니다.

실행이 완료되면 solution_analysis_result.csv 파일이 생성되며, 내용은 아래와 같은 형식으로 채워집니다.

solution_analysis_result.csv 출력 예시:

경로	저장소명칭(중복없이 추천)	프로그램 역할(추정)	추천토픽명
C:\git\MyWebApp\MyWebApp.sln	mywebapp	ASP.NET Core, EF Core DB, MVC 웹	aspnet-core, ef-core-db, mvc-웹