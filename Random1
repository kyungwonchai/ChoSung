네, 방금 수정된 App.xaml.cs와 ProxiedTcpClient.cs 파일의 전체 코드를 다시 드리겠습니다.

App.xaml.cs (전체 코드)

C#

// MonitorAgent/App.xaml.cs
using System;
using System.Windows;
// System.Windows.Forms와 System.Drawing 참조 및 using 지시문 추가
using System.Windows.Forms; // NotifyIcon, ContextMenuStrip, ToolStripSeparator 등
using System.Drawing;       // Icon, SystemIcons 등
using MonitorAgent.Core;
using MonitorAgent.Services;
using MonitorAgent.Config;
using System.Threading.Tasks;
// Mutex 사용 시 (중복 실행 방지)
// using System.Threading;

namespace MonitorAgent
{
    public partial class App : System.Windows.Application
    {
        private NotifyIcon _notifyIcon;
        private AgentCoreService _agentCoreService;
        private FileLoggingService _loggingService;
        private AgentIdentifier _agentIdentifier;
        private ServerUrlProvider _serverUrlProvider;
        private MonitorControlService _monitorControlService;

        // MainWindow _statusWindow; // 상태 표시창 (선택적)

        protected override async void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // 애플리케이션 중복 실행 방지 (선택적)
            // bool createdNew;
            // Mutex mutex = new Mutex(true, "Global\\MonitorAgentSingleton_" + _agentIdentifier?.Id, out createdNew); // Agent ID별 Mutex
            // if (!createdNew)
            // {
            //     System.Windows.MessageBox.Show("Monitor Agent is already running.", "Monitor Agent", MessageBoxButton.OK, MessageBoxImage.Information);
            //     Shutdown();
            //     return;
            // }


            // 1. 서비스 초기화
            _loggingService = new FileLoggingService(); // 로거 최우선 초기화
            _agentIdentifier = new AgentIdentifier(_loggingService);
            _serverUrlProvider = new ServerUrlProvider(_loggingService);
            _monitorControlService = new MonitorControlService(_loggingService);

            _agentCoreService = new AgentCoreService(_loggingService, _agentIdentifier, _serverUrlProvider, _monitorControlService);

            _agentCoreService.OnStatusChanged += CoreService_OnStatusChanged;
            _agentCoreService.OnLogRelay += CoreService_OnLogRelay;


            // 2. 트레이 아이콘 설정
            SetupTrayIcon();

            // 3. Agent 핵심 서비스 시작
            try
            {
                await _agentCoreService.StartAsync();
                // AgentCoreService 시작 후 RuntimeConfig가 로드되었을 것이므로, 로그 레벨 설정 가능
                // 예를 들어, AgentCoreService에 RuntimeConfig를 가져오는 메서드가 있다면:
                // var currentConfig = _agentCoreService.GetCurrentRuntimeConfig(); // 예시 메서드
                // if (currentConfig != null && !string.IsNullOrEmpty(currentConfig.LogLevel))
                // {
                //    _loggingService.SetLogLevel(currentConfig.LogLevel);
                // }
            }
            catch (Exception ex)
            {
                _loggingService.LogError("Failed to start AgentCoreService during application startup.", ex);
                System.Windows.MessageBox.Show($"Critical error starting agent: {ex.Message}\nCheck logs for details.", "Monitor Agent Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown();
                return;
            }
            
            // (선택적) 상태 표시창 생성 및 표시
            // _statusWindow = new MainWindow();
            // _statusWindow.Show();
            // 이 프로젝트에서는 MainWindow.xaml을 만들지 않았으므로 주석 처리.
        }

        private void SetupTrayIcon()
        {
            _notifyIcon = new NotifyIcon // System.Windows.Forms.NotifyIcon
            {
                // Icon 리소스 로드 (프로젝트 리소스에 아이콘 파일(예: agent.ico) 추가 후 사용)
                // 예시1: Icon = new System.Drawing.Icon(GetType(), "agent.ico"); // 리소스로 포함된 경우
                // 예시2: (프로젝트 루트에 agent.ico가 있고, 속성에서 '포함 리소스'로 설정된 경우)
                // Stream iconStream = System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("MonitorAgent.agent.ico");
                // if (iconStream != null) _notifyIcon.Icon = new System.Drawing.Icon(iconStream);
                // else _notifyIcon.Icon = SystemIcons.Application; // 기본 아이콘
                Icon = SystemIcons.Application, // 간단한 시스템 아이콘 사용 (System.Drawing 참조 필요)
                Visible = true,
                Text = "Monitor Agent - Initializing..."
            };

            var contextMenu = new ContextMenuStrip(); // System.Windows.Forms.ContextMenuStrip
            contextMenu.Items.Add("Show Status", null, OnShowStatusClicked);
            contextMenu.Items.Add(new ToolStripSeparator()); // System.Windows.Forms.ToolStripSeparator
            contextMenu.Items.Add("Exit", null, OnExitClicked);

            _notifyIcon.ContextMenuStrip = contextMenu;
            _notifyIcon.DoubleClick += OnShowStatusClicked;
        }
        
        private void CoreService_OnStatusChanged(AgentOperationalStatus status, string message)
        {
            Dispatcher.Invoke(() =>
            {
                if (_notifyIcon != null)
                {
                    string trayText = $"Monitor Agent - {status}: {message}";
                    // 트레이 아이콘 텍스트 길이 제한 (보통 63자, 안전하게 60자)
                    _notifyIcon.Text = trayText.Length > 60 ? trayText.Substring(0, 57) + "..." : trayText;
                }
                // _statusWindow?.UpdateStatus(status, message);
            });
             _loggingService.LogDebug($"Tray Updated: {status} - {message}");
        }
        
        private void CoreService_OnLogRelay(string logMessage)
        {
            // Dispatcher.Invoke(() => _statusWindow?.AddLogMessage(logMessage));
        }

        private void OnShowStatusClicked(object sender, EventArgs e)
        {
            string currentStatusText = _notifyIcon?.Text ?? "Status unavailable.";
            System.Windows.MessageBox.Show(currentStatusText, "Monitor Agent Status", MessageBoxButton.OK, MessageBoxImage.Information);
            
            // 전용 상태창 로직 (MainWindow.xaml이 있다고 가정하고 ViewModel을 사용한다면)
            // if (_statusWindow == null || !_statusWindow.IsLoaded) // IsLoaded 등으로 창 존재 여부 확인
            // {
            //     // var viewModel = new StatusViewModel(_agentCoreService); // 예시
            //     // _statusWindow = new MainWindow { DataContext = viewModel };
            //     _statusWindow = new MainWindow(); // 간단히 생성
            //     _statusWindow.Closed += (s, args) => _statusWindow = null; // 닫힐 때 참조 제거
            //     _statusWindow.Show();
            // }
            // else
            // {
            //     _statusWindow.Activate();
            // }
        }

        private async void OnExitClicked(object sender, EventArgs e)
        {
            if (_notifyIcon != null)
            {
                _notifyIcon.Visible = false; // 아이콘 먼저 숨김
            }
            if (_agentCoreService != null)
            {
                await _agentCoreService.StopAsync();
                _agentCoreService.Dispose();
                _agentCoreService = null;
            }
            _notifyIcon?.Dispose();
            _notifyIcon = null;
            _loggingService?.LogInfo("Monitor Agent application exit initiated by user.");
            Shutdown();
        }

        protected override async void OnExit(ExitEventArgs e)
        {
            // OnExitClicked에서 이미 처리되었을 수 있지만, 만약을 위해 한 번 더 호출하거나 플래그로 관리
            if (_agentCoreService != null)
            {
                await _agentCoreService.StopAsync(); // 중복 호출되어도 StopAsync 내부에서 처리될 수 있도록 설계
                _agentCoreService.Dispose();
                _agentCoreService = null;
            }
            if (_notifyIcon != null)
            {
                _notifyIcon.Dispose();
                _notifyIcon = null;
            }
            _loggingService?.LogInfo("Monitor Agent application exited.");
            base.OnExit(e);
        }
    }
}
ProxiedTcpClient.cs (전체 코드)

C#

// MonitorAgent/Network/ProxiedTcpClient.cs
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Models;
using MonitorAgent.Services;
using Newtonsoft.Json;

namespace MonitorAgent.Network
{
    public class ProxiedTcpClient : IDisposable
    {
        private readonly string _gatewayIp;
        private readonly int _gatewayPort;
        private readonly string _proxiedAgentId;
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cancellationTokenSource;
        private Task _receiveLoopTask;
        private readonly TimeSpan _retryConnectDelay = TimeSpan.FromSeconds(15);
        private readonly TimeSpan _heartbeatInterval = TimeSpan.FromMinutes(1);
        private Timer _heartbeatTimer;
        private bool _isDisposed = false;


        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null;

        public event Action<InternalTcpMessage> OnGatewayMessageReceived;
        public event Action OnDisconnectedFromGateway; 

        public ProxiedTcpClient(string gatewayIp, int gatewayPort, string proxiedAgentId, ILoggingService logger)
        {
            _gatewayIp = gatewayIp;
            _gatewayPort = gatewayPort;
            _proxiedAgentId = proxiedAgentId;
            _logger = logger;
        }

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected) return true;
            if (_isDisposed) throw new ObjectDisposedException(nameof(ProxiedTcpClient));

            // 이전 CancellationTokenSource가 있다면 Dispose
            _cancellationTokenSource?.Cancel();
            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = new CancellationTokenSource();
            var token = _cancellationTokenSource.Token;
            
            while(!token.IsCancellationRequested)
            {
                try
                {
                    _logger.LogInfo($"Attempting to connect to Gateway: {_gatewayIp}:{_gatewayPort}");
                    _tcpClient = new TcpClient(); // 매 시도마다 새 TcpClient 인스턴스 생성
                    
                    var connectTask = _tcpClient.ConnectAsync(_gatewayIp, _gatewayPort);
                    var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(10), token); 

                    Task completedTask = await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false);

                    if (token.IsCancellationRequested) // 연결 시도 중 외부에서 취소 요청
                    {
                        _tcpClient.Close(); // 사용한 리소스 정리
                        _logger.LogInfo("Connection attempt cancelled externally.");
                        return false; 
                    }

                    if (completedTask == timeoutDelayTask) // 타임아웃 발생
                    {
                        _tcpClient.Close(); 
                        _logger.LogWarning($"Timeout connecting to Gateway {_gatewayIp}:{_gatewayPort}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...");
                        await Task.Delay(_retryConnectDelay, token); 
                        continue; 
                    }
                    
                    // connectTask가 완료됨 (성공, 실패, 또는 취소 상태일 수 있음)
                    if (connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                    {
                        _networkStream = _tcpClient.GetStream();
                        _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                        _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                        _logger.LogInfo("Successfully connected to Gateway.");

                        _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(token), token);
                        
                        _heartbeatTimer?.Dispose();
                        _heartbeatTimer = new Timer(HeartbeatTimerCallback, null, _heartbeatInterval, _heartbeatInterval);

                        return true; 
                    }
                    else // 연결 실패 (Faulted, Canceled, 또는 RanToCompletion이지만 Not Connected)
                    {
                        _tcpClient.Close(); // 사용한 TcpClient 정리
                        string failureReason = $"Connection task status: {connectTask.Status}.";
                        if (connectTask.IsFaulted)
                        {
                             failureReason += $" Exception: {connectTask.Exception?.GetBaseException().Message}";
                             _logger.LogError($"Failed to connect to Gateway: {failureReason}", connectTask.Exception);
                        }
                        else if (connectTask.IsCanceled) // connectTask 자체의 CancellationToken에 의해 취소 (여기서는 timeoutDelayTask의 token과 다름)
                        {
                             failureReason += " Task was internally cancelled.";
                             _logger.LogWarning($"Failed to connect to Gateway: {failureReason}");
                        }
                        else if(!_tcpClient.Connected && connectTask.Status == TaskStatus.RanToCompletion)
                        {
                            failureReason += " Task RanToCompletion but TcpClient is not connected.";
                            _logger.LogWarning($"Failed to connect to Gateway: {failureReason}");
                        }
                        else {
                            _logger.LogWarning($"Failed to connect to Gateway: {failureReason}");
                        }
                        
                        _logger.LogInfo($"Retrying connection in {_retryConnectDelay.TotalSeconds} seconds...");
                        await Task.Delay(_retryConnectDelay, token);
                        continue; 
                    }
                }
                catch (SocketException sockEx)
                {
                     _logger.LogError($"SocketException while connecting to Gateway: {sockEx.Message}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...", sockEx);
                     _tcpClient?.Close(); // 확실히 닫기
                }
                catch (OperationCanceledException) when (token.IsCancellationRequested)
                {
                    _logger.LogInfo("Connection attempt or retry delay cancelled by CancellationTokenSource.");
                    _tcpClient?.Close();
                    return false; // 루프 및 메서드 종료
                }
                catch (Exception ex)
                {
                    _logger.LogError($"General error connecting to Gateway: {ex.Message}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...", ex);
                     _tcpClient?.Close();
                }
                
                // 재시도 전 명시적 딜레이 (위의 catch 블록에서 continue로 바로 넘어가지 않은 경우)
                // 이 부분은 이미 각 실패 경로에서 await Task.Delay(retry, token)를 호출하므로 중복될 수 있음.
                // 따라서, 각 실패 경로에서 continue 전에 await Task.Delay를 확실히 호출하도록 수정.
                // 위의 로직에서는 이미 각 실패 케이스(타임아웃, 연결 실패)에서 await Task.Delay 후 continue 하므로, 이 부분은 필요 없음.
                // if (token.IsCancellationRequested) break;
                // await Task.Delay(_retryConnectDelay, token);
            }
            return false; 
        }
        
        private async void HeartbeatTimerCallback(object state)
        {
            // 이 콜백은 Timer의 스레드 풀 스레드에서 실행됨
            // 따라서 SendHeartbeatAsync가 예외를 던지지 않도록 주의해야 함
            try
            {
                await SendHeartbeatAsync().ConfigureAwait(false);
            }
            catch (Exception ex)
            {
                _logger.LogError("Error during heartbeat timer callback.", ex);
            }
        }


        private async Task ReceiveMessagesAsync(CancellationToken token)
        {
            try
            {
                // StreamReader가 null이 아니고, token이 취소되지 않았고, TcpClient가 연결되어 있는 동안 반복
                while (!token.IsCancellationRequested && IsConnected && _streamReader != null)
                {
                    string jsonLine = null;
                    // ReadLineAsync에 타임아웃을 직접 걸기는 어려우나, 
                    // NetworkStream의 ReadTimeout을 설정하는 방법도 있음 (동기 읽기에는 효과적, 비동기는 주의)
                    // 여기서는 연결이 끊기면 ReadLineAsync가 null을 반환하거나 예외를 던질 것으로 기대.
                    var readTask = _streamReader.ReadLineAsync();
                    
                    // ReadLineAsync가 CancellationToken을 직접 지원하지 않으므로,
                    // token.IsCancellationRequested를 주기적으로 확인하거나,
                    // Task.WhenAny와 Task.Delay(token)를 사용하여 간접적인 취소 확인 가능
                    var completedTask = await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)).ConfigureAwait(false);

                    if (completedTask == readTask)
                    {
                        jsonLine = await readTask.ConfigureAwait(false); // 실제 결과 가져오기
                        if (jsonLine == null) 
                        {
                            _logger.LogInfo("Connection to Gateway closed by remote host (ReadLineAsync returned null).");
                            break;
                        }
                        if (string.IsNullOrWhiteSpace(jsonLine)) continue;

                        InternalTcpMessage receivedMsg = InternalTcpMessage.FromJson(jsonLine);
                        if (receivedMsg != null)
                        {
                            OnGatewayMessageReceived?.Invoke(receivedMsg);
                        }
                        else
                        {
                            _logger.LogWarning($"Failed to parse JSON message from Gateway: {jsonLine}");
                        }
                    }
                    else // Task.Delay(Timeout.Infinite, token)가 먼저 완료 => CancellationToken에 의해 취소됨
                    {
                         _logger.LogInfo("ReceiveMessagesAsync cancelled via CancellationToken.");
                         break;
                    }
                }
            }
            catch (IOException ioEx) 
            {
                 // IOException은 연결이 갑자기 끊겼을 때 자주 발생 (예: 상대방 소켓 종료)
                 if (token.IsCancellationRequested)
                     _logger.LogInfo($"Receive loop cancelled with IOException: {ioEx.Message}");
                 else
                     _logger.LogWarning($"IOException in Gateway message receiving loop (likely connection lost): {ioEx.Message}");
            }
            catch (ObjectDisposedException odEx)
            {
                if (token.IsCancellationRequested)
                     _logger.LogInfo($"Receive loop cancelled with ObjectDisposedException: {odEx.Message}");
                else
                    _logger.LogWarning($"ObjectDisposedException in Gateway message receiving loop: {odEx.Message}. Stream or client might have been closed.");
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                _logger.LogInfo("ReceiveMessagesAsync operation explicitly cancelled.");
            }
            catch (Exception ex)
            {
                if(!token.IsCancellationRequested) // 취소 중이 아닐 때만 에러 로깅
                    _logger.LogError($"Unhandled error in Gateway message receiving loop: {ex.ToString()}", ex);
            }
            finally
            {
                _logger.LogInfo("Gateway message receiving loop ended.");
                if (!token.IsCancellationRequested && !_isDisposed) // 의도치 않은 종료이고, Dispose 중이 아닐 때
                {
                    CloseConnectionResources(false); // 연결 자원만 닫고, 재연결 유도
                    OnDisconnectedFromGateway?.Invoke(); 
                }
            }
        }

        public async Task SendMessageAsync(InternalTcpMessage message)
        {
            if (!IsConnected || _streamWriter == null)
            {
                _logger.LogWarning("Not connected to Gateway or StreamWriter is null. Cannot send message.");
                return;
            }
            if (_isDisposed)
            {
                _logger.LogWarning("Attempted to send message on a disposed client.");
                return;
            }

            try
            {
                string jsonMessage = message.ToJson();
                await _streamWriter.WriteLineAsync(jsonMessage).ConfigureAwait(false);
                _logger.LogDebug($"Message sent to Gateway: {message.MessageType}");
            }
            catch (ObjectDisposedException odEx)
            {
                _logger.LogError($"Error sending message to Gateway (ObjectDisposedException): {odEx.Message}. Connection might be closing.", odEx);
                // 연결 문제 발생 시 정리 및 재연결 유도
                if (!_isDisposed)
                {
                    CloseConnectionResources(false);
                    OnDisconnectedFromGateway?.Invoke();
                }
            }
            catch (IOException ioEx)
            {
                 _logger.LogError($"Error sending message to Gateway (IOException): {ioEx.Message}. Connection might be lost.", ioEx);
                if (!_isDisposed)
                {
                    CloseConnectionResources(false);
                    OnDisconnectedFromGateway?.Invoke();
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Error sending message to Gateway: {ex.Message}", ex);
                if (!_isDisposed)
                {
                    CloseConnectionResources(false);
                    OnDisconnectedFromGateway?.Invoke();
                }
            }
        }
        
        private async Task SendHeartbeatAsync()
        {
            if (!IsConnected || _isDisposed) return;
            var heartbeatMsg = new InternalTcpMessage
            {
                MessageType = InternalMessageType.ProxiedHeartbeat,
                SourceAgentId = _proxiedAgentId,
                Payload = DateTime.UtcNow.ToString("o") 
            };
            // _logger.LogDebug("Sending heartbeat to Gateway."); // 너무 자주 로깅될 수 있음
            await SendMessageAsync(heartbeatMsg);
        }

        private void CloseConnectionResources(bool calledFromDispose)
        {
            if(!calledFromDispose && _isDisposed) return; // Dispose 중이면 중복 호출 방지

            _heartbeatTimer?.Dispose();
            _heartbeatTimer = null;

            // 스트림과 클라이언트를 닫을 때 예외가 발생할 수 있으므로 try-catch
            try { _streamWriter?.Dispose(); } catch (Exception ex) { _logger.LogDebug($"Error disposing StreamWriter: {ex.Message}"); }
            _streamWriter = null;
            try { _streamReader?.Dispose(); } catch (Exception ex) { _logger.LogDebug($"Error disposing StreamReader: {ex.Message}"); }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch (Exception ex) { _logger.LogDebug($"Error disposing NetworkStream: {ex.Message}"); }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch (Exception ex) { _logger.LogDebug($"Error closing TcpClient: {ex.Message}"); } // Close는 Dispose를 호출
            _tcpClient = null;
            
            if (!calledFromDispose) // Dispose에서 호출된 게 아니라면 (예: 연결 끊김) 로깅
                 _logger.LogInfo("Proxied TCP client connection resources released due to disconnection.");
        }

        public void Disconnect() // 외부에서 명시적으로 연결 종료 요청 시
        {
            _logger.LogInfo("Disconnecting from Gateway (explicit request)...");
            if (_isDisposed) return;

            _cancellationTokenSource?.Cancel(); // 모든 비동기 작업(연결 시도, 수신 루프) 취소 요청
            
            // _receiveLoopTask가 완료될 때까지 잠시 기다릴 수 있으나,
            // 너무 오래 기다리면 UI가 멈출 수 있으므로 주의.
            // 여기서는 Cancel만 하고, 루프 내에서 정리되도록 함.

            CloseConnectionResources(false); // 연결 자원 정리

            // CancellationTokenSource는 재사용하지 않으므로 Dispose.
            // _cancellationTokenSource?.Dispose(); // Dispose 메서드에서 처리
            // _cancellationTokenSource = null; 
            _logger.LogInfo("Explicit disconnection process initiated for Gateway.");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            _logger.LogInfo("Disposing ProxiedTcpClient...");
            
            _cancellationTokenSource?.Cancel(); // 모든 진행 중인 작업 취소

            // _receiveLoopTask가 실행 중이었다면 종료 대기 (선택적, 타임아웃 설정 가능)
            // if (_receiveLoopTask != null && !_receiveLoopTask.IsCompleted)
            // {
            //    try { _receiveLoopTask.Wait(TimeSpan.FromSeconds(2)); } // 짧은 시간만 대기
            //    catch (Exception ex) { _logger.LogDebug($"Exception waiting for receive loop task: {ex.Message}"); }
            // }

            CloseConnectionResources(true); // Dispose 중임을 알림

            _cancellationTokenSource?.Dispose();
            _cancellationTokenSource = null;
            
            _logger.LogInfo("ProxiedTcpClient disposed.");
            GC.SuppressFinalize(this); // 파이널라이저 호출 방지
        }
    }