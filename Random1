물론입니다. 이미지 새로 고침 로직과 SingleR 수신 및 요청 시 바로 갱신하는 부분을 추가하도록 하겠습니다.

이미지 새로 고침 로직 추가
먼저, 이미지를 주기적으로 새로 고침하는 로직을 ImageDisplayScreen에 추가합니다.

ImageDisplayScreen (이미지 새로 고침 로직 추가)
kotlin
코드 복사
@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        currentBitmap = newBitmap
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        scale *= zoom
                        offset = Offset(offset.x + pan.x, offset.y + pan.y)
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}
위의 코드에서, currentBitmap이라는 상태 변수를 사용하여 이미지를 저장하고, isRefreshing이 true일 때 주기적으로 이미지를 새로 고침합니다.

SingleR을 사용한 실시간 이미지 갱신
SingleR을 사용하여 서버에서 수신하는 요청에 따라 이미지를 즉시 갱신하는 방법을 설명하겠습니다. 여기서는 SingleR 라이브러리를 사용하여 클라이언트와 서버 간의 실시간 통신을 설정합니다.

SingleR 설정 및 핸들러 추가
SingleR을 사용하려면 com.microsoft.signalr 라이브러리를 프로젝트에 추가해야 합니다. build.gradle 파일에 다음을 추가합니다:

gradle
코드 복사
dependencies {
    implementation 'com.microsoft.signalr:signalr:5.0.11'
}
다음은 SingleR 클라이언트 설정 및 핸들러를 추가하는 예제입니다. 클라이언트 설정은 MainActivity 또는 ViewModel에서 초기화할 수 있습니다.

MainActivity.kt (SingleR 설정 및 핸들러 추가)
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import java.util.*
import kotlin.concurrent.fixedRateTimer
import kotlin.math.roundToInt

class MainActivity : ComponentActivity() {
    private lateinit var hubConnection: HubConnection

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        hubConnection = HubConnectionBuilder.create("https://yourserver/signalrhub")
            .build()
        
        hubConnection.on("UpdateImage", { imageTitle: String, datetime: String ->
            runOnUiThread {
                // 여기에서 이미지 갱신 로직을 호출
                updateImage(imageTitle, datetime)
            }
        }, String::class.java, String::class.java)
        
        hubConnection.start().blockingAwait()
        
        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    ImageListScreen()
                }
            }
        }
    }

    private fun updateImage(imageTitle: String, datetime: String) {
        // 이미지를 새로고침하는 로직을 여기에 추가
        val scope = CoroutineScope(Dispatchers.Main)
        scope.launch {
            val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
            if (newBitmap != null) {
                // UI 갱신 로직
            }
        }
    }

    override fun onDestroy() {
        hubConnection.stop().blockingAwait()
        super.onDestroy()
    }
}

@Composable
fun ImageListScreen() {
    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }
    var isRefreshing by remember { mutableStateOf(false) }

    val scope = rememberCoroutineScope()

    Column {
        Button(
            onClick = {
                scope.launch {
                    imageList = fetchDataFromDatabase()
                }
            },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("Fetch Data")
        }
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.imageTitle, modifier = Modifier.weight(1f))
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        scope.launch {
                            selectedImage = fetchImageFromDatabase(imageData.imageTitle, imageData.datetime)
                        }
                    }) {
                        Text("Load Image")
                    }
                }
            }
        }
        selectedImage?.let { bitmap ->
            ImageDisplayScreen(
                bitmap = bitmap,
                imageTitle = "currentImageTitle",
                datetime = "currentDateTime",
                onBack = { selectedImage = null },
                onFit = { selectedImage = bitmap }, // 단순히 현재 이미지를 다시 설정하여 fit 효과를 줌
                isRefreshing = isRefreshing,
                onToggleRefresh = { isRefreshing = it }
            )
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            Log.d("Database", "Attempting to connect to database...")
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            Log.d("Database", "Connection established.")
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
                Log.d("Database", "Fetched data: $imageTitle, $datetime")
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            Log.e("Database", "Error fetching data", e)
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            Log.d("Database", "Attempting to fetch image for $imageTitle at $datetime...")
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
                Log.d("Database", "Image fetched successfully.")
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            Log.e("Database", "Error fetching image", e)
            null
        }
    }
}
주요 변경 사항:
이미지 새로 고침 로직: ImageDisplayScreen에 fixedRateTimer를 사용하여 주기적으로 이미지를 새로 고침.
SingleR 설정 및 핸들러 추가: MainActivity에 SingleR 설정과 핸들러를 추가하여 서버에서 이미지를 갱신하도록 설정.
ImageDisplayScreen에 필요한 매개변수 추가: imageTitle과 datetime을 매개변수로 전달하여 이미지 갱신 시 사용할 수 있도록 설정.
이제 앱을 빌드하고 실행하여 모든 기능이 의도한 대로 동작하는지 확인하세요.