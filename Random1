이제 새로운 요구 사항을 반영하여, 작업의 일시정지, 특정 함수만 실행, Ctrl + 도형을 클릭하여 해당 작업의 특정 함수를 실행하는 구조로 변경하겠습니다. 작업 전체의 순차적인 처리는 유지하면서, 사용자가 원하는 시점에 특정 작업만 실행할 수 있도록 설계할 것입니다.

요구사항 요약:
작업 일시정지 기능: 모든 작업을 멈출 수 있어야 하며, 이때 전체 작업은 대기 상태로 변경됩니다.
Ctrl + 도형을 클릭하면 해당 작업의 특정 함수만 실행: 도형을 누르면 해당 행에서 그 함수만 실행되도록 해야 합니다.
작업은 순차적으로 진행되되, 특정 작업만 실행하는 경우도 지원해야 합니다.
전체 구조:
TaskQueue는 순차적으로 작업을 실행하지만, 일시정지 상태가 되면 모든 작업이 멈춥니다.
특정 작업을 Ctrl + 도형을 통해 개별적으로 실행할 수 있습니다.
일시정지 상태에서 특정 작업만 실행할 수 있는 기능을 추가합니다.
PlcCommunication.cs (COM 포트 통신)
Services/PlcCommunication.cs

csharp
코드 복사
using System;
using System.Threading.Tasks;

public class PlcCommunication
{
    // COM 포트 1과 2를 관리하는 필드
    private readonly string _comPort1;
    private readonly string _comPort2;

    // 생성자에서 두 개의 COM 포트를 초기화
    public PlcCommunication(string comPort1, string comPort2)
    {
        _comPort1 = comPort1;
        _comPort2 = comPort2;
    }

    /// <summary>
    /// COM 포트 1을 통해 데이터를 전송하는 메서드
    /// </summary>
    public async Task SendDataToComPort1(string data)
    {
        Console.WriteLine($"COM 포트 1로 데이터 전송 중: {data}");
        // 실제 COM 포트로 데이터를 전송하는 로직을 여기에 구현
        await Task.Delay(1000); // 데이터 전송 중 대기
        Console.WriteLine("COM 포트 1로 데이터 전송 완료");
    }

    /// <summary>
    /// COM 포트 2를 통해 데이터를 전송하는 메서드
    /// </summary>
    public async Task SendDataToComPort2(string data)
    {
        Console.WriteLine($"COM 포트 2로 데이터 전송 중: {data}");
        // 실제 COM 포트로 데이터를 전송하는 로직을 여기에 구현
        await Task.Delay(1000); // 데이터 전송 중 대기
        Console.WriteLine("COM 포트 2로 데이터 전송 완료");
    }
}
TaskQueue.cs (작업 처리 및 특정 함수 실행)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Func<string, Task>, Task<bool>>> _tasks; // 작업 리스트 (상태 업데이트)
    private CancellationTokenSource _cancellationTokenSource;
    private PlcCommunication _plcCommunication; // PLC 통신 인스턴스
    private bool _isPaused = false; // 일시정지 상태를 관리하는 필드

    public TaskQueue(PlcCommunication plcCommunication)
    {
        _tasks = new List<Func<Func<string, Task>, Task<bool>>>(); // 작업 초기화
        _cancellationTokenSource = new CancellationTokenSource(); // 취소 토큰 생성
        _plcCommunication = plcCommunication;
        AddDefaultTasks(); // 기본 작업 추가
    }

    // 기본 작업을 추가하는 메서드 (여러 작업을 큐에 추가)
    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    // 작업 큐를 순차적으로 실행하는 메서드
    public async Task<bool> ExecuteTaskQueue(Func<string, Task> updateStatus)
    {
        foreach (var task in _tasks)
        {
            if (_cancellationTokenSource.Token.IsCancellationRequested)
                return false;

            // 작업 일시정지 상태일 경우 대기
            while (_isPaused)
            {
                await Task.Delay(500); // 500ms마다 일시정지 상태를 체크
            }

            var success = await task(updateStatus);
            if (!success) return false;
        }
        return true;
    }

    // 작업 일시정





나의 말:
이어서
ChatGPT의 말:
ChatGPT
csharp
코드 복사
    // 작업 일시정지 상태로 설정하는 메서드
    public void PauseAllTasks()
    {
        _isPaused = true;
    }

    // 작업을 다시 실행 상태로 변경하는 메서드
    public void ResumeAllTasks()
    {
        _isPaused = false;
    }

    // 개별 작업을 특정 함수부터 실행하는 메서드
    public async Task<bool> ExecuteSpecificTask(Func<string, Task> updateStatus, int taskIndex)
    {
        if (taskIndex < 0 || taskIndex >= _tasks.Count)
        {
            return false; // 잘못된 작업 인덱스일 경우
        }

        // 일시정지 상태일 때에도 특정 작업은 실행 가능하도록
        var success = await _tasks[taskIndex](updateStatus);
        return success;
    }

    // 작업을 취소하는 메서드
    public void Cancel()
    {
        _cancellationTokenSource.Cancel();
    }

    // 모든 작업을 취소하는 메서드
    public void CancelAll()
    {
        _cancellationTokenSource.Cancel();
    }

    // COM 포트 1과 2를 통해 데이터를 전송하며 순차적으로 처리
    private async Task<bool> TaskA(Func<string, Task> updateStatus)
    {
        await updateStatus("Task A: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task A");
        
        await updateStatus("Task A: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task A");

        await updateStatus("Task A completed.");
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB(Func<string, Task> updateStatus)
    {
        await updateStatus("Task B: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task B");
        
        await updateStatus("Task B: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task B");

        await updateStatus("Task B completed.");
        return true;
    }

    private async Task<bool> TaskC(Func<string, Task> updateStatus)
    {
        await updateStatus("Task C: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task C");
        
        await updateStatus("Task C: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task C");

        await updateStatus("Task C completed.");
        return true;
    }
}
TaskModel.cs (작업 상태 및 특정 함수 실행 처리)
Models/TaskModel.cs

csharp
코드 복사
using System.Threading.Tasks;
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsPaused { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand PauseCommand { get; } // 일시정지 명령어
    public ICommand ResumeCommand { get; } // 다시 시작 명령어
    public ICommand ExecuteSpecificTaskCommand { get; } // 특정 함수 실행 명령어

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        StartCommand = new RelayCommand(StartTask);
        PauseCommand = new RelayCommand(PauseTask); // 일시정지
        ResumeCommand = new RelayCommand(ResumeTask); // 다시 시작
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask); // 특정 함수 실행

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsRunning));

        // 비동기 작업을 실행하고, TaskQueue의 상태를 실시간으로 업데이트
        var success = await _taskQueue.ExecuteTaskQueue(UpdateTaskStatus);

        Status = success ? "Completed" : "Failed";
        IsCompleted = success;
        IsError = !success;
        IsRunning = false;

        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCompleted));
        OnPropertyChanged(nameof(IsError));
        OnPropertyChanged(nameof(IsRunning));
    }

    // 작업 일시정지
    private void PauseTask()
    {
        _taskQueue.PauseAllTasks();
        Status = "Paused";
        IsPaused = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsPaused));
    }

    // 작업 다시 시작
    private void ResumeTask()
    {
        _taskQueue.ResumeAllTasks();
        Status = "Running";
        IsPaused = false;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsPaused));
    }

    // 특정 함수만 실행
    private async void ExecuteSpecificTask(int taskIndex)
    {
        Status = $"Running task {taskIndex}";
        var success = await _taskQueue.ExecuteSpecificTask(UpdateTaskStatus, taskIndex);
        Status = success ? "Completed" : "Failed";
        OnPropertyChanged(nameof(Status));
    }

    /// <summary>
    /// TaskQueue의 상태를 실시간으로 업데이트하는 메서드
    /// </summary>
    private async Task UpdateTaskStatus(string message)
    {
        Status = message;
        OnPropertyChanged(nameof(Status));
        await Task.CompletedTask; // 비동기 처리 완료
    }
}
MainViewModel.cs (작업 처리 및 특정 작업 실행)
ViewModels/MainViewModel.cs

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;
    private FileProcessor _fileProcessor;

    public ICommand PauseAllCommand { get; }
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // PLC 통신 클래스 생성 (두 개의 COM 포트 사용)
        var plcCommunication = new PlcCommunication("COM1", "COM2");

        _taskQueue = new TaskQueue(plcCommunication);

        // 파일 처리 클래스 생성 (경로와 PLC 통신 클래스 전달)
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", plcCommunication);

        // 파일 감지 이벤트 연결 (작업 실행 여부에 따라 다르게 처리)
        _fileProcessor.NewFileDetected += OnNewFileDetected;

        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 파일이 감지되었을 때 호출되는 메서드.
    /// Dispatcher.Invoke를 사용하여 UI 스레드에서 안전하게 작업 추가.
    /// </summary>
    private void OnNewFileDetected(LogEntry logEntry, bool executeTask)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var taskModel = new TaskModel(logEntry, _taskQueue, executeTask);
            TaskList.Add(taskModel);

            // 최대 18개의 항목만 유지
            if (TaskList.Count > 18)
            {
                TaskList.RemoveAt(0);
            }
        });
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.PauseAllTasks();
        foreach (var task in TaskList)
        {
            task.Status = "Paused";
        }
    }

    /// <summary>
    /// 모든 작업을 다시 시작합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.ResumeAllTasks();
        foreach (var task in TaskList)
        {
            task.Status = "Running";
        }
    }
}
MainWindow.xaml (UI 변경, 도형 및 컨트롤 추가)
xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/win





나의 말:
이어
ChatGPT의 말:
ChatGPT
xml
코드 복사
fx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />

                <!-- 작업 진행 상태를 동그라미로 표시하는 열 -->
                <DataGridTemplateColumn Header="Task Status" Width="*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Grid>
                                <!-- 상태를 표시할 동그라미 도형 -->
                                <Ellipse Width="20" Height="20" Stroke="Black" StrokeThickness="1">
                                    <Ellipse.Style>
                                        <Style TargetType="Ellipse">
                                            <Style.Triggers>
                                                <!-- 완료된 작업은 녹색 -->
                                                <DataTrigger Binding="{Binding IsCompleted}" Value="True">
                                                    <Setter Property="Fill" Value="LightGreen"/>
                                                </DataTrigger>
                                                <!-- 에러가 발생한 작업은 빨간색 -->
                                                <DataTrigger Binding="{Binding IsError}" Value="True">
                                                    <Setter Property="Fill" Value="Red"/>
                                                </DataTrigger>
                                                <!-- 대기 중인 작업은 스카이블루 -->
                                                <DataTrigger Binding="{Binding IsRunning}" Value="True">
                                                    <Setter Property="Fill" Value="SkyBlue"/>
                                                </DataTrigger>
                                                <!-- 일시정지된 작업은 회색 -->
                                                <DataTrigger Binding="{Binding IsPaused}" Value="True">
                                                    <Setter Property="Fill" Value="Gray"/>
                                                </DataTrigger>
                                            </Style.Triggers>
                                        </Style>
                                    </Ellipse.Style>
                                </Ellipse>
                                <Grid.ContextMenu>
                                    <ContextMenu>
                                        <!-- Ctrl + 도형 클릭하여 특정 함수만 실행 -->
                                        <MenuItem Header="여기서부터 시작" Command="{Binding ExecuteSpecificTaskCommand}" CommandParameter="0"/>
                                    </ContextMenu>
                                </Grid.ContextMenu>
                            </Grid>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>

        <!-- 일시정지 및 다시 시작 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="120,0,0,10"/>
    </Grid>
</Window>
설명:
TaskQueue.cs:

PauseAllTasks: 모든 작업을 일시정지시킬 수 있는 메서드를 추가했습니다.
ResumeAllTasks: 일시정지된 작업을 다시 실행할 수 있는 메서드를 추가했습니다.
ExecuteSpecificTask: 특정 작업의 함수만 실행할 수 있도록 추가했습니다. 이 메서드는 Ctrl + 도형을 클릭했을 때 해당 작업을 선택적으로 실행합니다.
TaskModel.cs:

PauseTask: 작업을 개별적으로 일시정지할 수 있는 기능을 추가했습니다.
ExecuteSpecificTaskCommand: 각 작업의 특정 함수를 실행할 수 있는 명령어를 추가했습니다.
MainViewModel.cs:

일시정지 및 다시 시작: 모든 작업을 일시정지하거나 다시 시작할 수 있도록 UI에 명령어를 바인딩했습니다.
작업 추가: 파일 감지 시 작업을 추가하고, 최대 18개의 작업만 유지합니다.
MainWindow.xaml:

DataGrid의 동그라미 도형을 통해 작업 상태를 시각적으로 표시하며, 일시정지 상태는 회색, 진행 중인 작업은 스카이블루, 완료된 작업은 녹색, 에러는 빨간색으로 표시됩니다.
**ContextMenu (우클릭 메뉴)**를 통해 특정 함수만 실행할 수 있는 메뉴 항목을 추가했습니다. Ctrl + 도형을 통해 사용자는 작업의 특정 함수를 실행할 수 있습니다.
이제 이 코드는 모든 작업을 일시정지하거나 재시작할 수 있으며, Ctrl + 도형 클릭을 통해 특정 작업만 실행할 수 있는 기능을 포함하고 있습니