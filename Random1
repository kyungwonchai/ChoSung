네, app/__init__.py 파일에서 "name 'current_app' is not defined" 오류가 발생하셨군요. 이 오류는 Flask의 current_app 프록시 객체를 사용하려고 할 때, 해당 시점에 활성화된 애플리케이션 컨텍스트(Application Context)가 없기 때문에 발생합니다.

create_app 함수 내에서 Flask 애플리케이션 인스턴스는 app이라는 변수로 직접 참조 가능합니다. 따라서 create_app 함수 내부에서 로깅을 할 때는 current_app.logger 대신 app.logger를 사용하는 것이 더 직접적이고 안전합니다.

또한, datetimeformat 필터 내에서도 current_app.logger를 사용한 부분이 있었는데, 이 부분도 app.logger로 변경하거나, 필터가 실제 템플릿 렌더링 시점에 호출될 때는 이미 앱 컨텍스트가 활성화되어 current_app 사용이 가능하지만, 일관성을 위해 app 객체를 직접 사용할 수 있다면 그것을 사용하는 것이 좋습니다. (다만, 필터 함수는 app 객체를 직접 클로저로 잡지 않는 이상 current_app을 사용하는 것이 일반적입니다. 여기서는 로깅 부분만 수정하고, 필터 내부는 current_app을 그대로 두거나, 로깅이 꼭 필요하지 않다면 제거할 수 있습니다.)

가장 문제가 되는 부분은 create_app 함수 마지막의 로깅 라인일 것입니다. 이 부분을 app.logger로 수정하겠습니다.

수정: app/__init__.py (전체 코드)
current_app.logger를 app.logger로 변경하고, datetimeformat 필터 내의 로깅은 그대로 두거나 (템플릿 렌더링 시 컨텍스트 존재) 필요시 app 객체를 전달하는 방식으로 수정할 수 있습니다. 여기서는 create_app 함수 내의 로깅만 수정합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app # current_app 임포트는 유지 (컨텍스트 프로세서나 필터에서 사용될 수 있음)
from flask_sqlalchemy import SQLAlchemy
from config import config # 프로젝트 루트의 config.py 임포트
import datetime

db = SQLAlchemy() # SQLAlchemy 객체 전역 선언

def create_app(config_name='default'):
    """
    Flask 애플리케이션 인스턴스를 생성하고 초기화하는 팩토리 함수입니다.
    """
    app = Flask(__name__) # 여기서 'app' 인스턴스 생성
    
    # 1. 설정 로드
    app.config.from_object(config[config_name])
    config[config_name].init_app(app) 

    # 2. 확장 기능 초기화 (예: SQLAlchemy)
    db.init_app(app)

    # 3. Jinja2 커스텀 필터 및 컨텍스트 프로세서 등록
    # datetime 필터 등록
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: 
            return ""
        if isinstance(value, str): 
            original_value_for_log = value # 로깅을 위해 원본 값 저장
            try: 
                # 다양한 ISO 및 일반적인 날짜/시간 형식 파싱 시도
                # 'Z' 제거, 마이크로초 부분 제거, T를 공백으로 변경 등 시도
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: # 마이크로초가 있다면 제거
                    processed_value = processed_value.split('.')[0]
                
                processed_value = processed_value.replace('T', ' ')

                # 알려진 형식들로 파싱 시도
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try:
                        parsed_dt = datetime.datetime.strptime(processed_value, dt_format)
                        break
                    except ValueError:
                        continue
                
                if parsed_dt is None: # 모든 형식 파싱 실패
                    # app.logger 사용 (create_app 함수 스코프 내에서는 app 직접 사용)
                    app.logger.warning(f"날짜 문자열 파싱 실패 (format_datetime filter): '{original_value_for_log}'")
                    return original_value_for_log # 파싱 실패 시 원본 값 반환
                value = parsed_dt
            except Exception as e_parse: 
                app.logger.error(f"날짜 문자열 파싱 중 예외 발생 (format_datetime filter) '{original_value_for_log}': {e_parse}")
                return original_value_for_log 
        
        if not isinstance(value, (datetime.datetime, datetime.date)):
             return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    
    @app.context_processor
    def inject_now(): 
        return {'now': datetime.datetime.utcnow()}

    # IP 주소 및 사용자 역할 정보를 모든 템플릿에 주입하는 컨텍스트 프로세서 등록
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)

    # 4. 블루프린트(Blueprint) 등록
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 

    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 
    
    # 애플리케이션 생성 완료 로깅 (current_app 대신 app.logger 사용)
    app.logger.info("Flask application created and configured successfully.")
    # DB URI는 민감 정보일 수 있으므로, DEBUG 모드에서만 로깅하거나 주의해서 로깅
    if app.debug:
        app.logger.debug(f"Database URI: {app.config.get('SQLALCHEMY_DATABASE_URI')}")

    return app
주요 변경 사항:

로거 사용 변경:
create_app 함수 마지막 부분의 current_app.logger.info(...)와 current_app.logger.debug(...) 호출을 app.logger.info(...) 와 app.logger.debug(...) 로 변경했습니다. create_app 함수 내에서는 app 변수를 통해 Flask 애플리케이션 인스턴스에 직접 접근할 수 있으므로, 이 인스턴스의 로거를 사용하는 것이 더 명확하고 컨텍스트 문제 발생 가능성이 적습니다.
datetimeformat 필터 내 로깅 수정:
날짜/시간 문자열 파싱 실패 시 로깅하는 부분도 app.logger.warning(...) 또는 app.logger.error(...)를 사용하도록 변경했습니다. (current_app은 템플릿 렌더링 시점에는 컨텍스트가 활성화되어 사용 가능하지만, create_app 스코프에서는 app을 직접 사용하는 것이 일관성 있고 안전합니다.)
datetimeformat 필터의 파싱 로직을 좀 더 다양한 형식을 포괄하고, 오류 발생 시 원본 값을 반환하도록 견고하게 수정했습니다.
추가 확인 사항:
