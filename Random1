해했습니다. 용량이 부족할 때 필요한 용량만큼만 파일을 삭제하도록 수정하겠습니다. 필요한 용량만큼 파일을 삭제할 때까지 반복적으로 삭제 작업을 수행하도록 하겠습니다.

FileManager.cs
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

namespace FileCleanupApp
{
    public class FileManager
    {
        private string targetFolder;
        private int retentionDays;
        private long maxDiskUsage;
        private string logFolder = @"C:\agent\smdfilecleaner\log";

        public FileManager(string targetFolder, int retentionDays, long maxDiskUsage)
        {
            this.targetFolder = targetFolder;
            this.retentionDays = retentionDays;
            this.maxDiskUsage = maxDiskUsage;

            // 로그 폴더가 없으면 생성
            if (!Directory.Exists(logFolder))
            {
                Directory.CreateDirectory(logFolder);
            }
        }

        public async Task CleanUpAsync()
        {
            DateTime serverTime = await TimeSyncManager.GetServerTimeAsync();
            var files = new DirectoryInfo(targetFolder).GetFiles().OrderBy(f => f.CreationTime).ToList();
            long currentUsage = files.Sum(f => f.Length);
            string logFilePath = Path.Combine(logFolder, serverTime.ToString("yyyyMMdd") + ".txt");

            using (StreamWriter logWriter = new StreamWriter(logFilePath, true))
            {
                // 보관 기간이 지난 파일 삭제
                foreach (var file in files)
                {
                    if (serverTime - file.CreationTime > TimeSpan.FromDays(retentionDays) && !IsFileLocked(file))
                    {
                        logWriter.WriteLine($"{serverTime}: Deleted {file.FullName} due to retention policy");
                        currentUsage -= file.Length;
                        file.Delete();
                    }
                }

                // 하드 디스크 용량 확보를 위해 필요한 만큼만 파일 삭제
                files = new DirectoryInfo(targetFolder).GetFiles().OrderBy(f => f.CreationTime).ToList(); // 파일 목록 갱신
                long spaceNeeded = currentUsage - maxDiskUsage;
                foreach (var file in files)
                {
                    if (currentUsage <= maxDiskUsage)
                    {
                        break;
                    }

                    if (!IsFileLocked(file))
                    {
                        logWriter.WriteLine($"{serverTime}: Deleted {file.FullName} due to disk space limit");
                        currentUsage -= file.Length;
                        file.Delete();

                        if (currentUsage <= maxDiskUsage)
                        {
                            break;
                        }
                    }
                }
            }

            CleanUpLogs(serverTime);
        }

        private void CleanUpLogs(DateTime serverTime)
        {
            var logFiles = new DirectoryInfo(logFolder).GetFiles("*.txt").OrderBy(f => f.CreationTime).ToList();

            foreach (var logFile in logFiles)
            {
                if (serverTime - logFile.CreationTime > TimeSpan.FromDays(60))
                {
                    logFile.Delete();
                }
            }
        }

        private bool IsFileLocked(FileInfo file)
        {
            try
            {
                using (FileStream stream = file.Open(FileMode.Open, FileAccess.ReadWrite, FileShare.None))
                {
                    stream.Close();
                }
            }
            catch (IOException)
            {
                return true;
            }

            return false;
        }
    }
}
Scheduler.cs
Scheduler 클래스에서 CleanUpAsync 메서드를 호출하도록 합니다.

csharp
코드 복사
using System;
using System.Threading;
using System.Threading.Tasks;

namespace FileCleanupApp
{
    public class Scheduler
    {
        private FileManager fileManager;
        private CancellationTokenSource cancellationTokenSource;

        public Scheduler(FileManager fileManager)
        {
            this.fileManager = fileManager;
            this.cancellationTokenSource = new CancellationTokenSource();
        }

        public void Start()
        {
            Task.Run(() => RunPeriodicTask(TimeSpan.FromHours(4), cancellationTokenSource.Token));
        }

        private async Task RunPeriodicTask(TimeSpan interval, CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                await fileManager.CleanUpAsync();
                await Task.Delay(interval, cancellationToken);
            }
        }

        public void Stop()
        {
            cancellationTokenSource.Cancel();
        }
    }
}
이제 수정된 FileManager 클래스는 하드 디스크 용량이 부족할 때 필요한 만큼의 용량을 확보하기 위해 필요한 파일만 삭제합니다. 먼저 보관 기간이 지난 파일을 삭제한 후, 여전히 용량이 부족한 경우에 오래된 파일을 순차적으로 삭제하여 필요한 용량만큼 확보합니다.