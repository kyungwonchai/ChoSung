, 이전 설명과 코드 수정에도 불구하고 종료 시 시스템 오류 창이 계속 나타난다니 답답하시겠네요. 제공해주신 분석 내용을 바탕으로 다시 한번 코드를 점검하고, 종료 시 안정성을 높이는 방향으로 수정해 보겠습니다.

말씀하신 대로 종료 시점에 발생하는 오류는 비동기 작업의 완료 시점과 리소스 해제 시점 간의 경쟁 상태 또는 전역적으로 처리되지 않은 예외 때문에 발생할 가능성이 높습니다. 시스템 오류 창(빨간 X)이 뜬다는 것은 App.xaml.cs의 전역 예외 처리기, 특히 UI 스레드 예외를 처리하는 DispatcherUnhandledException 핸들러가 예외를 제대로 처리하지 못했거나(e.Handled = true 설정 누락) 핸들러 자체가 설정되지 않았을 가능성을 시사합니다.

해결 방향:

전역 예외 처리기 복원 및 강화 (App.xaml.cs): DispatcherUnhandledException 핸들러에서 e.Handled = true;를 설정하여 처리되지 않은 UI 스레드 예외가 발생해도 애플리케이션이 강제 종료되는 것을 최대한 방지합니다. 또한 모든 전역 예외 처리기 설정을 확인합니다.
리소스 해제 로직 안정성 강화 (MainViewModel.cs, LogViewModel.cs, MainWindow.xaml.cs):
각 ViewModel의 Dispose 메서드 내에서 다른 객체의 Dispose를 호출할 때 try-catch로 감싸서 Dispose 과정 자체에서 예외가 발생해도 전파되지 않도록 합니다.
MainWindow_Closing 이벤트 핸들러 내부의 ViewModel.Dispose() 호출도 try-catch로 감쌉니다.
Dispose 메서드 시작과 끝에 디버그 출력을 추가하여 해제 순서를 추적합니다.
수정해야 할 파일 목록:

App.xaml.cs
ViewModels/MainViewModel.cs
ViewModels/LogViewModel.cs
(Views/MainWindow.xaml.cs도 수정되지만, 3개 파일 요청에 따라 우선순위에서 제외하고 아래 코드에 포함하여 안내)
아래에 이 3개 파일의 수정된 전체 코드(주석 제외)를 작성합니다.

1. App.xaml.cs (수정)

전역 예외 처리기 설정을 확인하고, DispatcherUnhandledException 핸들러에서 e.Handled = true;를 설정합니다.

C#

using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace LockerManagementApp
{
    public partial class App : Application
    {
        public static bool IsShuttingDown { get; private set; } = false;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            SetupGlobalExceptionHandling(); // 전역 예외 처리기 설정 호출 확인
            Debug.WriteLine("애플리케이션 시작됨.");
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Debug.WriteLine("애플리케이션 종료 시작됨.");
            IsShuttingDown = true;
            base.OnExit(e);
            Debug.WriteLine("애플리케이션 종료 완료.");
        }

        #region 전역 예외 처리 (Global Exception Handling)

        private void SetupGlobalExceptionHandling()
        {
            DispatcherUnhandledException += App_DispatcherUnhandledException;
            TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            Debug.WriteLine("전역 예외 처리기 설정 완료.");
        }

        private void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            LogAndShowException(e.Exception, "UI Thread Exception");
            // *** 중요: 처리된 것으로 표시하여 앱 크래시 방지 ***
            e.Handled = true;
        }

        private void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            LogAndShowException(e.Exception, "Background Task Exception");
            e.SetObserved();
        }

        private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception", !e.IsTerminating);
        }

        private void LogAndShowException(Exception exception, string source, bool showMessageBox = true)
        {
            string errorMessage = $"예기치 않은 오류 발생 ({source}):\n\n{exception.ToString()}";
            Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}");

            if (showMessageBox && !IsShuttingDown)
            {
                try { MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
                catch (Exception msgEx) { Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}"); }
            }
        }

        #endregion
    }
}
2. ViewModels/MainViewModel.cs (수정)

Dispose 메서드 내부의 다른 리소스 해제 호출 부분을 try-catch로 감쌉니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;
        private object _selectedCellValue;
        private string _selectedCellColumnFieldName;

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set => SetProperty(ref _selectedAssignment, value); }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        public object SelectedCellValue { get => _selectedCellValue; private set => SetProperty(ref _selectedCellValue, value); }
        public string SelectedCellColumnFieldName { get => _selectedCellColumnFieldName; private set => SetProperty(ref _selectedCellColumnFieldName, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { if (!App.IsShuttingDown) MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 DB 컨텍스트 생성 오류 무시됨: {ex.Message}"); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync(), CanExecuteCommand); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync(), CanSaveChangesExecute); AddNewCommand = new RelayCommand(AddNewLocker, CanExecuteCommand); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), CanDeleteExecute); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, CanClearAssignmentExecute); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword, CanExecuteCommand); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync(), CanExecuteCommand); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow, CanExecuteCommand);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private bool CanExecuteCommand(object parameter) => !_disposed;
        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private bool CanDeleteExecute(object parameter) => !_disposed && SelectedAssignment != null;
        private bool CanClearAssignmentExecute(object parameter) => !_disposed && SelectedAssignment != null && SelectedAssignment.IsAssigned;

        private async Task LoadInitialDataAsync() { if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; await LoadMasterDataAsync(); if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (!CanExecuteCommand(null) || _context == null || _cts.IsCancellationRequested) return; StatusBarText = "사물함 목록 로딩 중..."; List<LockerAssignment> assignments = null; try { var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList(); if (trackedAssignments.Any()) { foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; } if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨 (await 이후)."); return; } Application.Current.Dispatcher.Invoke(() => { if (_cts.IsCancellationRequested || _disposed || Application.Current == null) return; LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; (DeleteCommand as RelayCommand)?.RaiseCanExecuteChanged(); (ClearAssignmentCommand as RelayCommand)?.RaiseCanExecuteChanged(); }); } catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadAssignmentsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { var types = await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var floors = await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var zones = await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var subParts = await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var administrators = await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; Application.Current.Dispatcher.Invoke(() => { if (_cts.IsCancellationRequested || _disposed || Application.Current == null) return; AllLockerTypes = new ObservableCollection<LockerType>(types); AllFloors = new ObservableCollection<Floor>(floors); AllZones = new ObservableCollection<Zone>(zones); AllSubParts = new ObservableCollection<SubPart>(subParts); AllAdministrators = new ObservableCollection<Administrator>(administrators); if (!_cts.IsCancellationRequested && !_disposed) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; }); } } catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadMasterDataAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { if (!CanExecuteCommand(parameter)) return; try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!CanExecuteCommand(parameter)) return; if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { if (!App.IsShuttingDown && !_disposed) MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 마스터 데이터 관리 창 열기 오류 무시됨: {ex.Message}"); } }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync() { if (!CanSaveChangesExecute(null)) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (!CanExecuteCommand(parameter)) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        private async Task DeleteSelectedAsync() { if (!CanDeleteExecute(null)) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (!CanClearAssignmentExecute(parameter)) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; if (!_disposed && !App.IsShuttingDown) MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; if (!_disposed && !App.IsShuttingDown) MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Highlight Logic (이전과 동일)
        public void UpdateHighlightInfo(string fieldName, LockerAssignment currentItem) { var targetColumns = new List<string> { "LockerType", "Floor", "Zone", "SubPart", "Administrator" }; if (currentItem != null && fieldName != null && targetColumns.Contains(fieldName)) { var propertyInfo = typeof(LockerAssignment).GetProperty(fieldName); if (propertyInfo != null) { SelectedCellValue = propertyInfo.GetValue(currentItem); SelectedCellColumnFieldName = fieldName; } else { ClearHighlightInfo(); } } else { ClearHighlightInfo(); } }
        private void ClearHighlightInfo() { SelectedCellValue = null; SelectedCellColumnFieldName = null; }
        #endregion

        #region Helper Methods (오류 메시지 표시 전 App.IsShuttingDown 확인)
        private void HandleGenericException(string operation, Exception ex) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 {operation} 오류 무시됨: {ex.Message}"); return; } StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 DB 업데이트 오류 무시됨: {dbEx.Message}"); return; } Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 유효성 검사 오류 무시됨: {vex.Message}"); return; } var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (Dispose 내부 try-catch 추가)
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _disposed = true; // 플래그 먼저 설정
                if (disposing)
                {
                    Debug.WriteLine("MainViewModel Dispose 시작...");
                    try { _cts?.Cancel(); } catch (Exception ex) { Debug.WriteLine($"!!! CancellationTokenSource Cancel 오류: {ex.Message}"); }
                    try { _cts?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! CancellationTokenSource Dispose 오류: {ex.Message}"); }
                    try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! MainViewModel DbContext Dispose 오류: {ex.Message}"); } // DbContext Dispose 예외 처리
                    try { LogVM?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogViewModel Dispose 오류: {ex.Message}"); } // LogVM Dispose 예외 처리
                    Debug.WriteLine("MainViewModel 리소스 해제 시도 완료.");
                }
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. ViewModels/LogViewModel.cs (수정)

Dispose 메서드 내부의 _context.Dispose() 호출을 try-catch로 감쌉니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Collections.Generic;

namespace LockerManagementApp.ViewModels
{
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private ObservableCollection<AuditLog> _auditLogs;
        private string _statusMessage;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;

        public ObservableCollection<AuditLog> AuditLogs { get => _auditLogs; set => SetProperty(ref _auditLogs, value); }
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        public LogViewModel()
        {
            AuditLogs = new ObservableCollection<AuditLog>();
            try { _context = new LockerDbContext(); }
            catch (Exception ex)
            {
                if (!App.IsShuttingDown) MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                else Debug.WriteLine($"종료 중 [Log] DB 컨텍스트 생성 오류 무시됨: {ex.Message}");
                StatusMessage = "[Log] DB 연결 오류!"; LoadLogsCommand = new RelayCommand(_ => { }, _ => !_disposed); return;
            }
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync(), CanExecuteLoadLogs);
            if (_context != null) { _ = LoadLogsAsync(); }
        }

        public async Task LoadLogsAsync()
        {
            if (!CanExecuteLoadLogs()) return;
            StatusMessage = "로그 로딩 중...";
            (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged();
            List<AuditLog> logs = null;
            try
            {
                if (!CanExecuteLoadLogs()) return;
                logs = await _context.AuditLogs.OrderByDescending(log => log.Timestamp).Take(1000).AsNoTracking().ToListAsync(_cts.Token);
                if (_disposed || _cts.IsCancellationRequested) { Debug.WriteLine("LoadLogsAsync 작업 취소됨 (await 이후)."); return; }
                Application.Current.Dispatcher.Invoke(() =>
                {
                    if (_disposed || _cts.IsCancellationRequested || Application.Current == null) return;
                    AuditLogs = new ObservableCollection<AuditLog>(logs);
                    StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
                });
            }
            catch (OperationCanceledException) { Debug.WriteLine("LoadLogsAsync 작업 취소됨."); if (!_disposed) StatusMessage = "로그 로딩 취소됨."; }
            catch (ObjectDisposedException) { Debug.WriteLine("LoadLogsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusMessage = "로그 로딩 중 오류 발생 (컨텍스트 해제됨)."; }
            catch (SqlException sqlEx) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 DB 오류: {sqlEx.Message}"; MessageBox.Show(StatusMessage, "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (EntityException entityEx) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 EF 오류: {entityEx.Message}"; MessageBox.Show(StatusMessage, "EF 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (Exception ex) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            finally { /* finally에서는 UI 업데이트 제거됨 */ }
        }

        private bool CanExecuteLoadLogs(object parameter = null) => !_disposed && _context != null && !_cts.IsCancellationRequested;

        #region IDisposable 구현 (Dispose 내부 try-catch 추가)
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                 _disposed = true;
                if (disposing)
                {
                    Debug.WriteLine("LogViewModel Dispose 시작...");
                    try { _cts?.Cancel(); } catch (Exception ex) { Debug.WriteLine($"!!! LogVM CancellationTokenSource Cancel 오류: {ex.Message}"); }
                    try { _cts?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogVM CancellationTokenSource Dispose 오류: {ex.Message}"); }
                    // *** 수정: DbContext Dispose 호출을 try-catch로 감쌈 ***
                    try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogViewModel DbContext Dispose 오류: {ex.Message}"); }
                    Debug.WriteLine("LogViewModel 리소스 해제 완료.");
                }
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
핵심 변경 사항:

App.xaml.cs: 전역 예외 처리기 설정(SetupGlobalExceptionHandling) 호출을 OnStartup에 포함하고, DispatcherUnhandledException 핸들러에서 e.Handled = true를 설정하여 UI 스레드 예외로 인한 앱 크래시를 방지합니다. 또한 LogAndShowException 메서드에서 App.IsShuttingDown 플래그를 확인하여 종료 중에는 메시지 박스를 표시하지 않습니다.
MainViewModel.cs / LogViewModel.cs:
Dispose(bool disposing) 메서드 내에서 _context?.Dispose() 및 다른 Dispose 호출 부분을 각각 try-catch 블록으로 감쌌습니다. 이를 통해 리소스 해제 과정 자체에서 예외가 발생하더라도 프로그램 전체가 비정상 종료되는 것을 방지하고 오류를 디버그 출력으로 기록합니다.
오류 메시지를 표시하는 Handle...Exception 헬퍼 메서드와 생성자의 catch 블록에서도 if (!App.IsShuttingDown) 조건을 추가하여 종료 중에는 메시지 박스가 나타나지 않도록 수정했습니다.
이제 애플리케이션 종료 시점에 발생하는 예외는 전역 예외 처리기에 의해 처리되거나(e.Handled = true), ViewModel의 Dispose 메서드 내부 try-catch에 의해 처리되어 시스템 오류 창이 나타나는 현상이 해결될 가능성이 높습니다.