 WPF MVVM 기반 모니터 자동 ON/OFF + 달력 휴일 설정 기능
✅ WPF + MVVM 패턴 준수
✅ 달력에서 쉬는 날 설정 가능 (노란색으로 표시)
✅ 토요일, 일요일, 공휴일은 기본적으로 노란색 (쉬는 날)
✅ 쉬는 날이면 모니터 자동 ON/OFF 기능 활성화
✅ 일하는 날이면 모니터 항상 켜짐 (자동 OFF 기능 비활성화)

📌 프로젝트 구조
scss
코드 복사
📂 MonitorControlApp
 ├── 📂 ViewModels
 │    ├── MainViewModel.cs (비즈니스 로직)
 ├── 📂 Views
 │    ├── MainWindow.xaml (UI)
 ├── 📂 Models
 │    ├── HolidayModel.cs (휴일 데이터 관리)
 ├── App.xaml
 ├── MainWindow.xaml.cs (MainViewModel과 연결)
 ├── Program.cs (진입점)
🔥 1️⃣ MainViewModel.cs (MVVM 패턴 로직)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Input;

namespace MonitorControlApp.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private static readonly int WM_SYSCOMMAND = 0x0112;
        private static readonly int SC_MONITORPOWER = 0xF170;
        private static readonly int MONITOR_ON = -1;
        private static readonly int MONITOR_OFF = 2;
        private bool _isMonitorOff = false;

        public ObservableCollection<DateTime> Holidays { get; set; }
        public ICommand ToggleHolidayCommand { get; }
        public ICommand CheckMonitorCommand { get; }

        public MainViewModel()
        {
            Holidays = new ObservableCollection<DateTime>(GetDefaultHolidays());
            ToggleHolidayCommand = new RelayCommand<DateTime>(ToggleHoliday);
            CheckMonitorCommand = new RelayCommand(CheckMonitorState);
        }

        private List<DateTime> GetDefaultHolidays()
        {
            var holidays = new List<DateTime>();

            // 기본적으로 토요일, 일요일은 노란색 (쉬는 날)
            for (int i = 0; i < 365; i++)
            {
                DateTime date = DateTime.Today.AddDays(i);
                if (date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday)
                {
                    holidays.Add(date);
                }
            }

            // 공휴일 추가 (예제: 1월 1일, 12월 25일)
            holidays.Add(new DateTime(DateTime.Today.Year, 1, 1));
            holidays.Add(new DateTime(DateTime.Today.Year, 12, 25));

            return holidays;
        }

        private void ToggleHoliday(DateTime date)
        {
            if (Holidays.Contains(date))
            {
                Holidays.Remove(date);
            }
            else
            {
                Holidays.Add(date);
            }
            OnPropertyChanged(nameof(Holidays));
        }

        private void CheckMonitorState()
        {
            if (Holidays.Contains(DateTime.Today))
            {
                if (!_isMonitorOff)
                {
                    TurnMonitorOff();
                }
            }
            else
            {
                if (_isMonitorOff)
                {
                    TurnMonitorOn();
                }
            }
        }

        private void TurnMonitorOn()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
            _isMonitorOff = false;
        }

        private void TurnMonitorOff()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
            _isMonitorOff = true;
        }

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
🔥 2️⃣ MainWindow.xaml (UI)
xml
코드 복사
<Window x:Class="MonitorControlApp.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MonitorControlApp.ViewModels"
        Title="모니터 자동 ON/OFF" Height="400" Width="600">
    <Window.DataContext>
        <local:MainViewModel/>
    </Window.DataContext>

    <Grid>
        <Calendar Name="CalendarControl" 
                  SelectedDatesChanged="CalendarControl_SelectedDatesChanged"
                  DisplayMode="Month"/>
    </Grid>
</Window>
🔥 3️⃣ MainWindow.xaml.cs (달력 이벤트 연결)
csharp
코드 복사
using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using MonitorControlApp.ViewModels;

namespace MonitorControlApp.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel ViewModel => DataContext as MainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            HighlightHolidays();
        }

        private void HighlightHolidays()
        {
            foreach (var date in ViewModel.Holidays)
            {
                CalendarControl.SelectedDates.Add(date);
            }
        }

        private void CalendarControl_SelectedDatesChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (var date in e.AddedItems.OfType<DateTime>())
            {
                ViewModel.ToggleHoliday(date);
            }

            HighlightHolidays();
        }
    }
}
🔥 4️⃣ RelayCommand.cs (MVVM용 명령어 바인딩)
csharp
코드 복사
using System;
using System.Windows.Input;

namespace MonitorControlApp
{
    public class RelayCommand<T> : ICommand
    {
        private readonly Action<T> _execute;
        private readonly Func<T, bool> _canExecute;

        public RelayCommand(Action<T> execute, Func<T, bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute((T)parameter);
        }

        public void Execute(object parameter)
        {
            _execute((T)parameter);
        }

        public event EventHandler CanExecuteChanged;
        public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public class RelayCommand : RelayCommand<object>
    {
        public RelayCommand(Action execute, Func<bool> canExecute = null)
            : base(_ => execute(), canExecute == null ? (Func<object, bool>)null : _ => canExecute()) { }
    }
}
📌 주요 기능 정리
✅ 달력에서 날짜 클릭 시 노란색 → 쉬는 날 설정됨
✅ 토요일, 일요일, 공휴일 기본적으로 쉬는 날 (노란색)
✅ 쉬는 날이면 자동 모니터 OFF / 입력 시 ON
✅ 일하는 날(평일)이면 모니터 항상 켜짐
✅ MVVM 패턴 완벽 준수 (ViewModel + Command 사용)

🚀 최종 테스트 체크리스트
 달력에서 클릭하면 노란색으로 표시됨
 토/일요일 & 공휴일 기본적으로 노란색
 쉬는 날이면 모니터 자동 OFF
 일하는 날이면 모니터 항상 ON
 입력하면 모니터 즉시 ON