이제 작업을 PO 단위가 아닌 MAG_NO 단위로 처리하고, TaskA, TaskB, TaskC 작업의 상태를 실시간으로 DataGrid의 우측 상태 정보에 표시하는 기능을 추가하겠습니다. 또한, 작업이 완료된 이후, 최대 18개의 항목만 유지하고 나머지 작업 항목은 자동으로 삭제되도록 구현하겠습니다.

수정 사항 요약:

MAG_NO 단위 작업 처리: 작업을 MAG_NO 단위로 처리.
실시간 상태 업데이트: TaskA, TaskB, TaskC 작업의 상태를 실시간으로 DataGrid에 표시.
최대 18개의 작업만 유지: 완료된 작업이 18개를 넘으면 이전 작업은 삭제.
TaskModel.cs (실시간 상태 업데이트 및 최대 18개 유지 로직)
Models/TaskModel.cs

csharp
코드 복사
using System.Threading.Tasks;
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsCancelled { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand CancelCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        StartCommand = new RelayCommand(StartTask);
        CancelCommand = new RelayCommand(CancelTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsRunning));

        // 비동기 작업을 실행하고, TaskQueue의 상태를 실시간으로 업데이트
        var success = await _taskQueue.ExecuteTaskQueue(UpdateTaskStatus);

        Status = success ? "Completed" : "Failed";
        IsCompleted = success;
        IsError = !success;
        IsRunning = false;

        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCompleted));
        OnPropertyChanged(nameof(IsError));
        OnPropertyChanged(nameof(IsRunning));
    }

    private void CancelTask()
    {
        _taskQueue.Cancel();
        Status = "Cancelled";
        IsCancelled = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCancelled));
    }

    /// <summary>
    /// TaskQueue의 상태를 실시간으로 업데이트하는 메서드
    /// </summary>
    private void UpdateTaskStatus(string message)
    {
        Status = message;
        OnPropertyChanged(nameof(Status));
    }
}
TaskQueue.cs (실시간 상태 업데이트 로직 추가)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Func<string, Task>, Task<bool>>> _tasks; // 작업 리스트 (실시간 상태 업데이트 가능)
    private CancellationTokenSource _cancellationTokenSource;

    public TaskQueue()
    {
        _tasks = new List<Func<Func<string, Task>, Task<bool>>>(); // 작업 초기화
        _cancellationTokenSource = new CancellationTokenSource(); // 취소 토큰 생성
        AddDefaultTasks(); // 기본 작업 추가
    }

    // 기본 작업을 추가하는 메서드 (여러 작업을 큐에 추가)
    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    // 작업 큐를 순차적으로 실행하는 메서드
    public async Task<bool> ExecuteTaskQueue(Func<string, Task> updateStatus)
    {
        foreach (var task in _tasks)
        {
            if (_cancellationTokenSource.Token.IsCancellationRequested)
                return false;

            var success = await task(updateStatus);
            if (!success) return false;
        }
        return true;
    }

    // 개별 작업을 취소하는 메서드
    public void Cancel()
    {
        _cancellationTokenSource.Cancel();
    }

    // 모든 작업을 취소하는 메서드
    public void CancelAll()
    {
        _cancellationTokenSource.Cancel();
    }

    // 예시로 작성한 작업 (실시간 상태 업데이트)
    private async Task<bool> TaskA(Func<string, Task> updateStatus)
    {
        await updateStatus("Task A is starting...");
        await Task.Delay(1000);  // 비동기 작업 대기
        await updateStatus("Task A completed.");
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB(Func<string, Task> updateStatus)
    {
        await updateStatus("Task B is starting...");
        await Task.Delay(1000);
        await updateStatus("Task B completed.");
        return true;
    }

    private async Task<bool> TaskC(Func<string, Task> updateStatus)
    {
        await updateStatus("Task C is starting...");
        await Task.Delay(1000);
        await updateStatus("Task C completed.");
        return true;
    }
}
MainViewModel.cs (최대 18개의 항목만 유지하는 로직 추가)
ViewModels/MainViewModel.cs

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;
    private FileProcessor _fileProcessor;

    public ICommand CancelAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        _taskQueue = new TaskQueue();

        // PLC 통신 클래스 생성
        var plcCommunication = new PlcCommunication();

        // 파일 처리 클래스 생성 (경로와 PLC 통신 클래스 전달)
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", plcCommunication);

        // 파일 감지 이벤트 연결 (작업 실행 여부에 따라 다르게 처리)
        _fileProcessor.NewFileDetected += OnNewFileDetected;

        CancelAllCommand = new RelayCommand(CancelAllTasks);
    }

    /// <summary>
    /// 새로운 파일이 감지되었을 때 호출되는 메서드.
    /// Dispatcher.Invoke를 사용하여 UI 스레드에서 안전하게 작업 추가.
    /// </summary>
    private void OnNewFileDetected(LogEntry logEntry, bool executeTask)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var taskModel = new TaskModel(logEntry, _taskQueue, executeTask);
            TaskList.Add(taskModel);

            // 최대 18개의 항목만 유지
            if (TaskList.Count > 18)
            {
                TaskList.RemoveAt(0);
            }
        });
    }

    /// <summary>
    /// 모든 작업을 취소합니다.
    /// </summary>
    private void CancelAllTasks()
    {
        _taskQueue.CancelAll();
        foreach (var task in TaskList)
        {
            task.Status = "Cancelled";
        }
    }
}
MainWindow.xaml (UI 변경)
Views/MainWindow.xaml

xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />

                <!-- 작업 진행 상태를 표시하는 열 (실시간 상태 업데이트) -->
                <DataGridTextColumn Header="Task Status" Binding="{Binding Status}" Width="2*" />
            </DataGrid.Columns>

            <!-- DataGrid Row 스타일을 변경하여 작업 상태에 따른 배경 색상을 지정합니다 -->
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Style.Triggers>
                        <!-- 완료된 작업은 녹색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCompleted}" Value="True">
                            <Setter Property="Background" Value="LightGreen"/>
                        </DataTrigger>
                        <!-- 에러가 발생한 작업은 빨간색 배경으로 -->
                        <DataTrigger Binding="{Binding IsError}" Value="True">
                            <Setter Property="Background" Value="Red"/>
                        </DataTrigger>
                        <!-- 취소된 작업은 흰색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCancelled}" Value="True">
                            <Setter Property="Background" Value="White"/>
                        </DataTrigger>
                        <!-- 진행 중인 작업은 스카이블루 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="True">
                            <Setter Property="Background" Value="SkyBlue"/>
                        </DataTrigger>
                        <!-- 초기 10개는 회색 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="False">
                            <Setter Property="Background" Value="LightGray"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>

        <!-- 모든 작업을 취소하는 버튼 -->
        <Button Content="Cancel All" Command="{Binding CancelAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
    </Grid>
</Window>
설명:
TaskModel.cs:

실시간 상태 업데이트를 위한 UpdateTaskStatus 메서드를 추가하여, 작업 진행 상황이 DataGrid의 Task Status 열에 실시간으로 표시됩니다.
TaskA, TaskB, TaskC의 상태 변화가 즉시 반영됩니다.
TaskQueue.cs:

각 작업에 대해 상태 메시지를 업데이트하고 실시간으로 UI에 반영하는 기능을 추가했습니다.
TaskA, TaskB, TaskC 각각 상태 메시지를 전달하여 작업 진행 상황을 표시합니다.
MainViewModel.cs:

작업 목록을 최대 18개만 유지하는 로직을 추가했습니다. 18개를 초과하면 가장 오래된 작업을 삭제합니다.
MainWindow.xaml:

DataGrid에서 실시간 작업 상태를 표시하도록 설정되었습니다.
완료된 작업은 녹색, 진행 중인 작업은 스카이블루, 에러는 빨간색, 취소된 작업은 흰색, 초기 10개는 회색으로 설정됩니다.
이제 이 코드는 MAG_NO 단위로 작업을 처리하며, 실시간 상태 업데이트를 DataGrid에 반영하고, 최대 18개의 작업만 유지하면서 완료된 작업은 자동으로 삭제됩니다.