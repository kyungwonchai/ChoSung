@startuml

' Black and White Theme for PlantUML diagrams
!theme plain
skinparam monochrome true
skinparam shadowing false
skinparam backgroundColor #FFFFFF
skinparam defaultFontName "맑은 고딕"
skinparam defaultFontColor #000000
skinparam defaultFontSize 10

' Arrow styles
skinparam arrowColor #000000
skinparam arrowFontColor #333333
skinparam arrowFontSize 9

' Note styles
skinparam noteBackgroundColor #FFFFF0
skinparam noteBorderColor #333333
skinparam noteFontColor #000000

' Element styles
skinparam componentBorderColor #000000
skinparam componentBackgroundColor #FFFFFF

skinparam actorBorderColor #000000
skinparam actorBackgroundColor #FFFFFF

skinparam rectangleBorderColor #000000
skinparam rectangleBackgroundColor #FFFFFF

skinparam packageBorderColor #888888
skinparam packageBackgroundColor #F9F9F9
skinparam packageFontColor #000000

skinparam databaseBorderColor #000000
skinparam databaseBackgroundColor #FFFFFF

skinparam queueBorderColor #000000
skinparam queueBackgroundColor #FFFFFF

skinparam nodeBorderColor #000000
skinparam nodeBackgroundColor #FFFFFF

skinparam cloudBorderColor #000000
skinparam cloudBackgroundColor #FFFFFF

skinparam interfaceBorderColor #000000
skinparam interfaceBackgroundColor #FFFFFF

' 6.3.3 Intelligent Analysis Pipeline Structure Model (Advanced Patterns - Revised)
title 6.3.3 지능형 분석 파이프라인 구조 모델 (전략적 전처리 + 데코레이터 적용)

!theme plain
skinparam monochrome true
skinparam shadowing false
skinparam defaultFontName "맑은 고딕"
skinparam defaultFontSize 10
skinparam class {
    BorderColor #6B7280
    BackgroundColor #FFFFFF
    HeaderBackgroundColor #F3F4F6
}
skinparam interface {
    BorderColor #059669
    BackgroundColor #ECFDF5
}

package "빌더 패턴 (Builder Pattern)" {
  class 파이프라인빌더 <<Builder>> {
    - _filters: List<I파이프라인필터>
    --
    + 디코더추가(): 파이프라인빌더
    + 전처리기추가(strategy: I전처리전략, decorators: IFrameProcessor[]): 파이프라인빌더
    + 얼굴검출기추가(executor: I모델실행기구현): 파이프라인빌더
    + 특징매칭기추가(strategy: I매칭전략): 파이프라인빌더
    + 빌드(): 지능형분석파이프라인
  }
}

package "파이프-필터 패턴 (Pipe-Filter)" {
  interface "I파이프라인필터" as IFilter {
    + 처리(데이터: 분석데이터): Task<분석데이터>
  }
  class "영상디코더" as Decoder {
    - _sourceReader: ISourceReader
    + 처리(데이터: 분석데이터): Task<분석데이터>
  }
  class "프레임전처리기" as Preprocessor {
    - _baseProcessor: IFrameProcessor
    + 처리(데이터: 분석데이터): Task<분석데이터>
  }
  class "얼굴검출필터" as FaceDetector {
    - _executor: AI모델실행기
    + 처리(데이터: 분석데이터): Task<분석데이터>
  }
  class "특징매칭필터" as FeatureMatcher {
     - _matchingStrategy: I매칭전략
     - _observers: List<I분석결과옵저버>
     --
     + 옵저버추가(observer: I분석결과옵저버)
     + 옵저버제거(observer: I분석결과옵저버)
     + 옵저버에게알림()
     + 처리(데이터: 분석데이터): Task<분석데이터>
  }
  Decoder .up.|> IFilter
  Preprocessor .up.|> IFilter
  FaceDetector .up.|> IFilter
  FeatureMatcher .up.|> IFilter
  Decoder -> Preprocessor : "FrameData"
  Preprocessor -> FaceDetector
  FaceDetector -> FeatureMatcher
}
package "전략적 전처리 (Strategy + Decorator)" {
    interface IFrameProcessor {
      + process(frame: Frame): Frame
    }
    
    '--- Strategy Pattern ---
    interface I전처리전략 <<Strategy>> {
    }
    I전처리전략 .up.|> IFrameProcessor
    class 야간영상전략 {
        - _brightness: float
        + process(frame: Frame): Frame
    }
    class 저해상도개선전략 {
        - _scaleFactor: int
        + process(frame: Frame): Frame
    }
    야간영상전략 .up.|> I전처리전략
    저해상도개선전략 .up.|> I전처리전략
    note left of I전처리전략
     <b>Strategy Pattern:</b>
     영상 조건(야간, 저화질 등)에 따라
     최적의 기본 전처리 알고리즘을
     선택하고 교체할 수 있습니다.
    end note
    
    '--- Decorator Pattern ---
    abstract class FrameProcessorDecorator {
        # _wrappee: IFrameProcessor
        + process(frame: Frame): Frame
    }
    FrameProcessorDecorator .up.|> IFrameProcessor
    FrameProcessorDecorator o-- "1" IFrameProcessor
    class 노이즈제거데코레이터 {
        - _strength: double
        + process(frame: Frame): Frame
    }
    노이즈제거데코레이터 -up-|> FrameProcessorDecorator
    note right of FrameProcessorDecorator
     <b>Decorator Pattern:</b>
     선택된 기본 전략 위에
     노이즈 제거, 선명도 향상 등
     부가 기능을 동적으로 추가합니다.
    end note
}
Preprocessor o-- "1" IFrameProcessor : "uses"

package "브릿지 패턴 (Bridge)" {
  class "AI모델실행기" as Abstraction {
      # _implementor: I모델실행기구현
      + 예측(input: Tensor): Tensor
  }
  interface "I모델실행기구현" as Implementor {
     + 모델실행(input: Tensor): Tensor
  }
  Abstraction o-- "1" Implementor
  class "TFServing구현" as TFServing {
    - _endpointUrl: string
    - _timeout: int
    + 모델실행(input: Tensor): Tensor 
  }
  TFServing .up.|> Implementor
}
FaceDetector ..> Abstraction : "uses"

package "전략 패턴 (Strategy) - 매칭용" {
    interface I매칭전략 { 
      + 매칭(vector1, vector2): double 
    }
    class 코사인유사도전략 {
      - _threshold: double
      + 매칭(vector1, vector2): double 
    }
    class 유클리드거리전략 {
      - _normalize: boolean
      + 매칭(vector1, vector2): double
    }
    코사인유사도전략 .up.|> I매칭전략
    유클리드거리전략 .up.|> I매칭전략
}
FeatureMatcher o--> "1" I매칭전략 : "uses"

package "옵저버 패턴 (Observer)" {
    interface I분석결과옵저버 { 
      + 갱신(결과: 분석결과) 
    }
    class 실시간경보관리자 { 
      - _alertingService: IAlertingService
      + 갱신(결과: 분석결과) 
    }
    실시간경보관리자 .up.|> I분석결과옵저버
}
FeatureMatcher ..> I분석결과옵저버 : "notifies"

class 지능형분석파이프라인 {
  - _startFilter: I파이프라인필터
  - _pipelineConfig: PipelineConfig
  + 분석실행()
}
지능형분석파이프라인 o--> "1" IFilter
파이프라인빌더 ..> 지능형분석파이프라인 : "builds"
