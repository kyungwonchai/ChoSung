등록된 작업이 두 번 실행되고 리턴되는 현상은 여러 원인이 있을 수 있습니다. 주로 비동기 작업을 처리하는 과정에서 중복 실행이 발생할 때 나타나는 현상입니다. 아래는 그 원인과 해결 방법을 설명합니다.

원인
중복 등록: Enqueue 함수가 호출될 때 동일한 작업이 중복으로 등록되었을 가능성이 있습니다. 이 경우, CommandQueue.Enqueue가 두 번 호출되면서 동일한 작업이 두 번 실행될 수 있습니다.
비동기 함수의 중복 실행: 비동기 함수 내부에서 await를 사용하는 동안 다른 위치에서 같은 함수를 호출하여 작업이 중복으로 등록될 수 있습니다.
TaskQueue 내부의 처리 문제: TaskQueue가 다음 작업을 실행할 때 현재 작업이 아직 완료되지 않았음에도 불구하고 중복으로 실행될 수 있습니다. 이 경우, 큐의 상태 관리가 제대로 되지 않아서 발생할 수 있습니다.
해결 방법
다음은 이러한 중복 실행 및 리턴을 방지하기 위한 방법입니다.

1. 작업이 이미 큐에 있는지 확인
먼저, EnqueueTask를 호출하기 전에 동일한 작업이 이미 큐에 등록되어 있는지 확인할 수 있습니다. 이를 위해 HashSet 등을 사용해 중복된 작업이 들어가는 것을 방지할 수 있습니다.

csharp
코드 복사
private HashSet<Func<Task<bool>>> _taskSet = new HashSet<Func<Task<bool>>>();

public Task<bool> EnqueueTask(Func<Task<bool>> task)
{
    // 이미 같은 작업이 큐에 있는지 확인
    if (_taskSet.Contains(task))
    {
        return Task.FromResult(false); // 중복된 작업이므로 추가하지 않음
    }

    // 작업을 HashSet에 추가
    _taskSet.Add(task);

    CommandQueue.Enqueue(async () =>
    {
        bool result = false;
        try
        {
            result = await task();
        }
        catch (Exception)
        {
            result = false;
        }
        finally
        {
            // 작업이 완료되면 HashSet에서 제거
            _taskSet.Remove(task);
        }

        return result;
    });

    return Task.FromResult(true);
}
2. TaskQueue 상태 관리 개선
TaskQueue에서 작업이 중복으로 실행되지 않도록 큐의 상태를 더 명확히 관리할 필요가 있습니다. 예를 들어, 작업이 완료되기 전에는 추가적인 실행이 되지 않도록 IsRunning 상태를 활용할 수 있습니다.

csharp
코드 복사
private bool _isRunning = false;

public async Task<bool> EnqueueTask(Func<Task<bool>> task)
{
    if (_isRunning)
    {
        // 작업이 이미 실행 중이면 대기
        return false;
    }

    _isRunning = true;

    bool result = false;
    try
    {
        result = await task();
    }
    catch (Exception)
    {
        result = false;
    }
    finally
    {
        _isRunning = false;
    }

    return result;
}
3. TaskCompletionSource로 명시적으로 제어
TaskCompletionSource를 활용하면 작업이 완료될 때까지 기다린 후에 명확하게 결과를 제어할 수 있습니다.

csharp
코드 복사
public async Task<bool> EnqueueTask(Func<Task<bool>> task)
{
    var tcs = new TaskCompletionSource<bool>();

    CommandQueue.Enqueue(async () =>
    {
        try
        {
            bool success = await task();
            tcs.SetResult(success);
        }
        catch (Exception)
        {
            tcs.SetResult(false);
        }
    });

    return await tcs.Task;
}
이렇게 하면 TaskCompletionSource가 실제 작업의 완료 상태에 따라 명시적으로 결과를 설정하므로, 중복 리턴이 발생하지 않습니다.

결론
Enqueue 시 중복된 작업을 방지하는 로직을 추가하거나 큐의 상태를 더 명확히 관리하여 중복 실행을 방지할 수 있습니다.