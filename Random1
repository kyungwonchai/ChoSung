import pdfplumber
import re
import numpy as np
import traceback
from typing import List, Dict, Any

# ==============================================================================
# 데이터 구조 및 헬퍼 클래스 (이전과 동일)
# ==============================================================================
class TextElement:
    def __init__(self, element: Dict[str, Any]):
        self.text = element.get('text', '')
        self.x0, self.top, self.x1, self.bottom = [round(element.get(k, 0), 2) for k in ['x0', 'top', 'x1', 'bottom']]

    def __repr__(self):
        return f"'{self.text}' @ ({self.x0}, {self.top})"

def find_nearest_element(anchor: TextElement, candidates: List[TextElement]) -> TextElement | None:
    if not candidates: return None
    anchor_center = np.array([(anchor.x0 + anchor.x1) / 2, (anchor.top + anchor.bottom) / 2])
    min_dist = float('inf')
    nearest_element = None
    for cand in candidates:
        cand_center = np.array([(cand.x0 + cand.x1) / 2, (cand.top + cand.bottom) / 2])
        dist = np.linalg.norm(anchor_center - cand_center)
        if dist < min_dist:
            min_dist = dist
            nearest_element = cand
    return nearest_element

# ==============================================================================
# ? 디버깅 로그 생성 메인 함수 ?
# ==============================================================================
def debug_identifier_detection(pdf_path: str, output_log_path: str):
    print(f"디버깅 시작: '{pdf_path}' 파일을 분석하여 '{output_log_path}'에 로그를 기록합니다.")
    
    # --- 패턴 정의 ---
    material_code_pattern = re.compile(r"^\d{4}-\d{6}$")
    top_left_pattern = re.compile(r"^\d{2}[A-Z]?$")
    bottom_right_pattern = re.compile(r"^\d+\s?[xX*]\s?\d+$")
    
    patterns = {
        "자재코드": material_code_pattern,
        "좌상단": top_left_pattern,
        "우하단": bottom_right_pattern
    }

    with open(output_log_path, 'w', encoding='utf-8') as f:
        try:
            with pdfplumber.open(pdf_path) as pdf:
                for page_num, page in enumerate(pdf.pages, 1):
                    f.write("\n" + "="*25 + f" PAGE {page_num} " + "="*25 + "\n")
                    words = [TextElement(w) for w in page.extract_words()]
                    
                    if not words:
                        f.write("이 페이지에서 단어를 찾지 못했습니다.\n")
                        continue

                    # --- 1차 기록: 모든 단어와 패턴 매칭 결과 ---
                    f.write("\n--- 1. Raw Word Extraction & Regex Matching ---\n")
                    f.write(f"총 {len(words)}개의 단어를 추출했습니다.\n\n")
                    
                    material_codes, tl_codes, br_codes = [], [], []
                    
                    for i, word in enumerate(words):
                        matched_pattern = "None"
                        for name, pattern in patterns.items():
                            if pattern.match(word.text):
                                matched_pattern = name
                                if name == "자재코드": material_codes.append(word)
                                elif name == "좌상단": tl_codes.append(word)
                                elif name == "우하단": br_codes.append(word)
                                break # 첫 매칭 후 중단
                        
                        f.write(f"  Obj {i+1:03d} | Text: '{word.text}'".ljust(40) + f"| Pos: (x0={word.x0}, top={word.top})".ljust(40) + f"| Matched: {matched_pattern}\n")
                    
                    # --- 2차 기록: 최근접 탐색 분석 ---
                    f.write("\n\n--- 2. Nearest Neighbor Analysis ---\n")
                    f.write(f"페이지에서 발견된 식별자: 자재코드({len(material_codes)}개), 좌상단({len(tl_codes)}개), 우하단({len(br_codes)}개)\n\n")

                    if not material_codes:
                        f.write("분석할 자재코드가 없습니다.\n")
                        continue

                    for i, mc in enumerate(material_codes):
                        f.write(f"Analyzing Material Code {i+1}: '{mc.text}' at (x0={mc.x0}, top={mc.top})\n")
                        
                        # 최근접 좌상단/우하단 찾기
                        nearest_tl = find_nearest_element(mc, tl_codes)
                        nearest_br = find_nearest_element(mc, br_codes)
                        
                        if nearest_tl:
                            f.write(f"  -> Nearest TL Found: '{nearest_tl.text}' at (x0={nearest_tl.x0}, top={nearest_tl.top})\n")
                        else:
                            f.write("  -> Nearest TL Found: None\n")
                            
                        if nearest_br:
                            f.write(f"  -> Nearest BR Found: '{nearest_br.text}' at (x0={nearest_br.x0}, top={nearest_br.top})\n")
                        else:
                            f.write("  -> Nearest BR Found: None\n")
                            
                        # 최종 샘플 유효성 판단
                        if nearest_tl and nearest_br:
                            f.write("  ==> RESULT: SUCCESS - This is a valid sample for learning.\n\n")
                        else:
                            f.write("  ==> RESULT: FAILED - Could not find a valid TL/BR pair.\n\n")

            print("디버깅 로그 파일 생성이 완료되었습니다.")

        except Exception as e:
            error_message = f"!!! 치명적인 오류 발생: {e} !!!"
            print(error_message)
            f.write(error_message + "\n")
            f.write(traceback.format_exc())

# --- 메인 실행 부분 ---
if __name__ == "__main__":
    pdf_file_path = "YOUR_PDF_FILE_PATH.pdf"
    output_log_path = "debug_log.txt"
    debug_identifier_detection(pdf_file_path, output_log_path)