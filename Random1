1. templates/edit_post.html (비밀번호 이중 입력 UI 추가)

비밀번호 입력 부분을 "새 비밀번호"와 "새 비밀번호 확인" 두 개의 필드로 만들고, 관련 안내 문구를 수정합니다.

templates/edit_post.html (전체 수정본)

HTML

{% extends "base.html" %}

{% block title %}{{ '게시글 수정' if post else '새 게시글 작성' }} - 나의 게시판{% endblock %}

{% block head_extra %}
    <script src="{{ url_for('static', filename='tinymce/tinymce.min.js') }}" referrerpolicy="origin"></script>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4">
    <h2>{{ '게시글 수정' if post else '새 게시글 작성' }}</h2>
    <form method="POST" action="{{ url_for('edit_post', slug=post.slug) if post else url_for('new_post') }}" onsubmit="tinymce.triggerSave();">
        
        <div class="form-group">
            <label for="title">제목</label>
            <input type="text" class="form-control" id="title" name="title" value="{{ title or (post.title if post else '') }}" required>
        </div>

        <div class="form-group">
            <label for="category_id">카테고리</label>
            <select class="form-control" id="category_id" name="category_id">
                <option value="">-- 카테고리 선택 안 함 --</option>
                {% for category_item in categories %}
                    <option value="{{ category_item.id }}" {% if selected_category_id and category_item.id == selected_category_id|int %}selected{% endif %}>
                        {{ category_item.name }}
                    </option>
                {% endfor %}
            </select>
        </div>

        <div class="form-group form-check">
            <input type="checkbox" class="form-check-input" id="is_password_protected_checkbox" name="is_password_protected_checkbox" value="y"
                   {% if post and post.is_password_protected %}checked{% endif %}>
            <label class="form-check-label" for="is_password_protected_checkbox">이 글을 비밀번호로 보호합니다 (체크 시 아래 비밀번호 사용).</label>
        </div>

        {# --- 비밀번호 입력 필드 (항상 보임) --- #}
        <div id="password_fields_container">
            <div class="form-group">
                <label for="post_password_input">새 비밀번호</label>
                <input type="password" class="form-control" id="post_password_input" name="post_password_input" placeholder="비밀번호 보호 체크 시 사용할 새 비밀번호">
                <small class="form-text text-muted">
                    비밀번호로 보호하려면 위 체크박스를 선택하고 새 비밀번호를 입력하세요.
                </small>
            </div>
            <div class="form-group">
                <label for="post_password_confirm_input">새 비밀번호 확인</label>
                <input type="password" class="form-control" id="post_password_confirm_input" name="post_password_confirm_input" placeholder="새 비밀번호 다시 한번 입력">
                <small class="form-text text-muted">
                    글 수정 시, 비밀번호를 변경하고 싶을 때만 새 비밀번호와 확인 비밀번호를 입력하세요. 비워두면 기존 비밀번호가 유지됩니다 (보호 체크 시).
                    보호를 해제하려면 위 체크박스를 해제하세요.
                </small>
            </div>
        </div>
        {# --- 비밀번호 입력 필드 끝 --- #}

        <div class="form-group">
            <label for="content_editor">내용</label>
            <textarea class="form-control" id="content_editor" name="content" rows="15">{{ content or (post.content if post else '') }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장</button>
        <a href="{{ url_for('index') }}" class="btn btn-secondary">취소</a>
    </form>
</div>
{% endblock %}

{% block scripts_extra %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    if (typeof tinymce !== 'undefined') {
        tinymce.init({
            selector: 'textarea#content_editor',
            plugins: 'preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars fullscreen image link media template codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons accordion',
            menubar: 'file edit view insert format tools table help',
            toolbar: 'undo redo | accordion accordionremove | blocks fontfamily fontsize | bold italic underline strikethrough | align numlist bullist | link image media table | lineheight outdent indent| forecolor backcolor removeformat | charmap emoticons | code fullscreen preview | save print | pagebreak anchor codesample | ltr rtl',
            height: 600,
            language: 'ko_KR',
            relative_urls: false,
            remove_script_host: false,
            document_base_url: "{{ request.url_root.rstrip('/') }}",
            automatic_uploads: true,
            images_upload_url: "{{ url_for('upload_image') }}",
            file_picker_types: 'image',
            paste_data_images: true,
            images_upload_handler: function (blobInfo, progress) {
                return new Promise((resolve, reject) => {
                    const image_size_mb = blobInfo.blob().size / 1024 / 1024;
                    const client_max_size_mb = 10; 
                    if (image_size_mb > client_max_size_mb) {
                        reject({ message: `이미지 용량이 너무 큽니다 (${image_size_mb.toFixed(1)}MB). 최대 허용 용량은 ${client_max_size_mb}MB 입니다.`, remove: true });
                        return;
                    }
                    const xhr = new XMLHttpRequest();
                    xhr.withCredentials = false;
                    xhr.open('POST', "{{ url_for('upload_image') }}");
                    xhr.upload.onprogress = (e) => { if (e.lengthComputable) progress(e.loaded / e.total * 100); };
                    xhr.onload = () => {
                        if (xhr.status < 200 || xhr.status >= 300) {
                            let errorMessage = 'HTTP Error: ' + xhr.status;
                            try { const jsonError = JSON.parse(xhr.responseText); if (jsonError && jsonError.error && jsonError.error.message) errorMessage = jsonError.error.message; } catch (e) {
                                if (xhr.status === 413) errorMessage = '파일이 너무 큽니다. 서버에서 요청을 거부했습니다 (HTTP 413).';
                                else if (xhr.responseText && xhr.responseText.length < 300) errorMessage = `서버 오류: ${xhr.status} - ${xhr.responseText.substring(0,100)}`;
                                else errorMessage = `서버에서 예상치 못한 응답을 받았습니다 (HTTP ${xhr.status}).`;
                            }
                            reject({ message: errorMessage, remove: true }); return;
                        }
                        try { const json = JSON.parse(xhr.responseText); if (!json || typeof json.location != 'string') { reject({ message: '서버로부터 잘못된 JSON 응답을 받았습니다: ' + xhr.responseText, remove: true }); return; } resolve(json.location);
                        } catch (e) { reject({ message: `서버 응답 처리 중 오류 발생 (JSON 파싱 실패): ${e.message} 응답내용: ${xhr.responseText.substring(0,100)}`, remove: true }); }
                    };
                    xhr.onerror = () => { reject({ message: '네트워크 오류로 이미지 업로드에 실패했습니다. 서버 연결을 확인해주세요.', remove: true }); };
                    const formData = new FormData();
                    formData.append('file', blobInfo.blob(), blobInfo.filename());
                    xhr.send(formData);
                });
            },
            content_style: 'body { font-family:Helvetica,Arial,sans-serif; font-size:16px } img { max-width: 100%; height: auto; }'
        });
    } else {
        console.error("CRITICAL: TinyMCE library (tinymce) is not defined. Check script src path.");
        // 사용자에게 에디터 로드 실패 알림 로직 (필요시)
    }
});
</script>
{% endblock %}
edit_post.html 변경 사항:

비밀번호 입력 부분을 "새 비밀번호" (name="post_password_input")와 "새 비밀번호 확인" (name="post_password_confirm_input") 두 개의 필드로 나누었습니다.
각 필드 아래에 사용자 안내 문구를 수정하여, 언제 비밀번호를 입력해야 하는지 명확히 했습니다.
2. flask_board/app.py (new_post 및 edit_post 라우트 비밀번호 처리 로직 수정)

이제 서버 측에서는 두 개의 비밀번호 입력값을 받아서 일치하는지 확인하고, 일치할 경우에만 비밀번호를 설정/변경합니다.

flask_board/app.py (전체 코드 - 비밀번호 이중 입력 처리 로직 포함)

Python

import os
import uuid
import re
from functools import wraps
from datetime import datetime, timezone, timedelta

from flask import (
    Flask, render_template, request, redirect, url_for, flash, session, jsonify, abort, current_app
)
from werkzeug.utils import secure_filename

# --- 사용자 정의 모듈 임포트 ---
try:
    from config import Config
except ImportError:
    print("CRITICAL: config.py not found. Using emergency defaults.")
    class Config: # 임시 Config
        SECRET_KEY = os.environ.get('SECRET_KEY') or 'emergency_secret_key_please_set_properly_!@#$'
        SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///board.db'
        SQLALCHEMY_TRACK_MODIFICATIONS = False
        ADMIN_PASSWORD = os.environ.get('ADMIN_PASSWORD') or 'kkkwww'
        UPLOAD_FOLDER = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'static/uploads')
        ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif', 'webp'}
        MAX_CONTENT_LENGTH = 50 * 1024 * 1024 
        DEBUG = True

try:
    from models import db, Post, Category
except ImportError:
    print("CRITICAL: models.py not found or models cannot be imported.")
    db = None; Post = None; Category = None

app = Flask(__name__)
app.config.from_object(Config)

if app.debug:
    import logging
    app.logger.setLevel(logging.DEBUG)
else:
    import logging
    app.logger.setLevel(logging.INFO)

if db: 
    db.init_app(app)
else:
    app.logger.critical("Database (db) object not initialized from models.py.")

upload_folder_path = app.config.get('UPLOAD_FOLDER', './static/uploads_fallback')
if not os.path.exists(upload_folder_path):
    try: os.makedirs(upload_folder_path)
    except OSError as e: app.logger.error(f"Error creating upload folder {upload_folder_path}: {e}")

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config.get('ALLOWED_EXTENSIONS', {'png', 'jpg', 'jpeg', 'gif'})

def is_admin_logged_in(): return session.get('is_admin_logged_in', False)

@app.context_processor
def inject_global_vars():
    all_cats = []
    if Category:
        try: all_cats = Category.query.order_by(Category.name).all()
        except Exception as e: app.logger.error(f"Error fetching categories for context: {e}")
    return dict(is_admin=is_admin_logged_in(), now=datetime.now(timezone.utc), all_categories=all_cats)

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin_logged_in():
            flash('로그인이 필요합니다.', 'warning'); return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    # ... (이전과 동일) ...
    if is_admin_logged_in(): return redirect(url_for('index'))
    if request.method == 'POST':
        password = request.form.get('password')
        if password == app.config['ADMIN_PASSWORD']:
            session['is_admin_logged_in'] = True; session.permanent = True
            app.permanent_session_lifetime = timedelta(days=7)
            flash('로그인되었습니다.', 'success'); return redirect(request.args.get('next') or url_for('index'))
        else: flash('잘못된 비밀번호입니다.', 'danger')
    return render_template('login.html')

@app.route('/logout')
def logout():
    # ... (이전과 동일) ...
    session.pop('is_admin_logged_in', None); flash('로그아웃되었습니다.', 'info'); return redirect(url_for('index'))

@app.route('/')
def index():
    # ... (이전과 동일) ...
    if not Post: flash("게시글 기능을 사용할 수 없습니다.", "danger"); return render_template('index.html', posts_pagination=None, current_category=None)
    page = request.args.get('page', 1, type=int)
    posts_pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=None)

@app.route('/post/<string:slug>', methods=['GET', 'POST'])
def view_post(slug):
    # ... (이전과 동일 - 비밀번호 확인 로직 포함) ...
    if not Post: abort(500, description="Post model not available.")
    post_instance = Post.query.filter_by(slug=slug).first_or_404()
    session_key_for_post_unlock = f'unlocked_post_{post_instance.id}'
    is_unlocked_in_session = session.get(session_key_for_post_unlock, False)

    if post_instance.is_password_protected and post_instance.password_hash:
        if is_unlocked_in_session:
            return render_template('view_post.html', post=post_instance, show_password_form=False)
        else:
            if request.method == 'POST':
                submitted_password = request.form.get('post_password_view')
                if post_instance.check_password(submitted_password):
                    session[session_key_for_post_unlock] = True
                    flash('비밀번호가 확인되었습니다.', 'success')
                    return redirect(url_for('view_post', slug=post_instance.slug))
                else:
                    flash('비밀번호가 올바르지 않습니다.', 'danger')
            return render_template('view_post.html', post=post_instance, show_password_form=True)
    else:
        if post_instance.is_password_protected and not post_instance.password_hash:
             app.logger.warning(f"Post ID {post_instance.id} is marked protected but has no password hash. Treating as unprotected.")
        return render_template('view_post.html', post=post_instance, show_password_form=False)


@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    cats = []
    if Category:
        try: cats = Category.query.order_by(Category.name).all()
        except Exception as e: app.logger.error(f"Error fetching categories for new_post: {e}")

    if request.method == 'POST':
        title = request.form.get('title')
        content_from_form = request.form.get('content', '') 
        category_id_str = request.form.get('category_id')
        
        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input', '').strip()
        password_confirm_from_form = request.form.get('post_password_confirm_input', '').strip() # 비밀번호 확인 필드

        if not title:
            flash('제목을 입력해주세요.', 'warning')
            # 폼 값 유지를 위해 변수들을 다시 전달
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, 
                                   post=None, selected_category_id=category_id_str, 
                                   is_password_protected_form_value=is_protected_from_form)


        app.logger.debug(f"--- NEW_POST: Raw content received from form: [{content_from_form}]")
        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        
        try:
            if not Post: raise Exception("Post model is not available.")
            new_post_obj = Post(title=title, content=content_from_form, category_id=processed_category_id)
            
            password_error = False # 비밀번호 관련 오류 플래그
            if is_protected_from_form:
                if password_from_form: # 비밀번호가 입력되었으면
                    if password_from_form == password_confirm_from_form: # 비밀번호와 확인이 일치하면
                        new_post_obj.set_password(password_from_form)
                    else: # 비밀번호 불일치
                        flash('새 비밀번호와 비밀번호 확인이 일치하지 않습니다.', 'danger')
                        password_error = True # 오류 플래그 설정
                        new_post_obj.is_password_protected = False # 임시로 보호 해제 (저장 방지 또는 재입력 유도)
                        new_post_obj.password_hash = None
                else: # 보호 체크는 했으나 비밀번호 입력 안 함 (새 글)
                    flash('비밀번호로 보호를 선택했지만, 새 비밀번호를 입력하지 않았습니다. 비밀번호를 입력하거나 보호 체크를 해제하세요.', 'warning')
                    password_error = True
                    new_post_obj.is_password_protected = False
                    new_post_obj.password_hash = None
            else: # 보호 체크 안 함
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None
            
            if password_error: # 비밀번호 관련 오류가 있었다면 폼으로 다시 돌려보냄
                 return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, 
                                   post=None, selected_category_id=category_id_str,
                                   is_password_protected_form_value=is_protected_from_form) # 체크박스 상태 유지

            app.logger.debug(f"--- NEW_POST: Post object content before add/commit: [{new_post_obj.content}]")
            db.session.add(new_post_obj)
            db.session.commit()
            app.logger.debug(f"--- NEW_POST: Post object content AFTER db.session.commit() (Post ID: {new_post_obj.id}, new_post_obj.content): [{new_post_obj.content if new_post_obj else 'N/A'}]")
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        
        except Exception as e:
            if db and db.session.is_active : db.session.rollback()
            app.logger.error(f"Error creating post in NEW_POST: {e}", exc_info=True)
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, post=None, selected_category_id=category_id_str, is_password_protected_form_value=is_protected_from_form)

    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None, is_password_protected_form_value=False)


@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    if not Post or not Category: abort(500)
    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()
    cats = []
    try: cats = Category.query.order_by(Category.name).all()
    except Exception as e: app.logger.error(f"Error fetching categories for edit_post: {e}")
    
    selected_category_id = str(post_to_edit.category_id) if post_to_edit.category_id is not None else ""
    # GET 요청 시 템플릿에 is_password_protected_form_value 전달
    is_password_protected_for_template = post_to_edit.is_password_protected 
    
    if request.method == 'POST':
        original_title = post_to_edit.title
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content', '')
        category_id_str = request.form.get('category_id'); selected_category_id = category_id_str

        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input', '').strip()
        password_confirm_from_form = request.form.get('post_password_confirm_input', '').strip()
        
        # POST 요청 시에도 is_password_protected_form_value 업데이트 (폼 값 유지용)
        is_password_protected_for_template = is_protected_from_form


        if not post_to_edit.title:
            flash('제목을 입력해주세요.', 'warning')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id, is_password_protected_form_value=is_password_protected_for_template)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        post_to_edit.category_id = processed_category_id
        
        password_error = False
        if is_protected_from_form: # "보호" 체크 시
            if password_from_form: # 새 비밀번호가 입력된 경우
                if password_from_form == password_confirm_from_form: # 비밀번호 일치
                    post_to_edit.set_password(password_from_form)
                else: # 비밀번호 불일치
                    flash('새 비밀번호와 비밀번호 확인이 일치하지 않습니다. 비밀번호가 변경되지 않았습니다.', 'danger')
                    password_error = True
                    # is_password_protected는 True로 유지하되, 비밀번호 변경은 안 함 (기존 비밀번호 유지)
                    # 이 경우, 폼을 다시 보여줘야 하므로 commit 하지 않음
            elif post_to_edit.password_hash: # 새 비밀번호 입력 없고, 기존 비밀번호가 있는 경우 -> 기존 비밀번호 유지
                post_to_edit.is_password_protected = True 
            else: # 새 비밀번호 입력 없고, 기존 비밀번호도 없는 경우 -> 보호할 비밀번호가 없으므로 보호 해제
                flash('비밀번호 보호를 선택했지만, 설정할 (새) 비밀번호가 없고 기존 비밀번호도 없습니다. 보호되지 않습니다.', 'warning')
                post_to_edit.is_password_protected = False
                post_to_edit.password_hash = None
        else: # "보호" 체크 해제 시 -> 비밀번호 보호 해제
            post_to_edit.set_password(None) 
        
        if password_error: # 비밀번호 확인 불일치 시
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id, is_password_protected_form_value=is_password_protected_for_template)

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title)
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit(); flash('게시글이 성공적으로 수정되었습니다.', 'success'); return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback(); app.logger.error(f"Error editing post {slug}: {e}", exc_info=True); flash(f'게시글 수정 중 오류: {str(e)}', 'danger')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id, is_password_protected_form_value=is_password_protected_for_template)

    return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id, is_password_protected_form_value=is_password_protected_for_template)

# --- 나머지 모든 라우트 및 실행 부분은 이전 답변의 최종본과 동일하게 유지 ---
# (delete_post, upload_image, 카테고리 관리, 디버그 라우트, if __name__ == '__main__' 등)

@app.route('/delete/<string:slug>', methods=['POST'])
# ... (이하 코드는 이전 답변의 전체 app.py 내용과 동일하게 유지) ...
@admin_required
def delete_post(slug):
    if not Post: abort(500)
    post_to_delete = Post.query.filter_by(slug=slug).first_or_404()
    try:
        db.session.delete(post_to_delete); db.session.commit()
        flash('게시글이 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback(); app.logger.error(f"Error deleting post {slug}: {e}"); flash(f'삭제 오류: {str(e)}', 'danger')
    return redirect(url_for('index'))

@app.route('/upload_image', methods=['POST'])
@admin_required
def upload_image():
    if 'file' not in request.files: app.logger.error("UPLOAD_IMAGE: No file part"); return jsonify({'error': {'message': '요청에 파일 부분이 없습니다.'}}), 400
    file = request.files['file']
    if file.filename == '': app.logger.error("UPLOAD_IMAGE: No file selected"); return jsonify({'error': {'message': '선택된 파일이 없습니다.'}}), 400
    if file and allowed_file(file.filename):
        original_filename = secure_filename(file.filename); fn_prefix = str(uuid.uuid4())[:8]
        base, ext = os.path.splitext(original_filename); safe_base = re.sub(r'[^\w-]', '', base)[:50]
        disk_fn = f"{fn_prefix}_{safe_base}{ext}"; counter = 1; temp_disk_fn = disk_fn
        upload_path = app.config.get('UPLOAD_FOLDER')
        if not upload_path: app.logger.error("UPLOAD_FOLDER not configured."); return jsonify({'error': {'message': '서버 업로드 폴더 미지정.'}}), 500
        final_fp = os.path.join(upload_path, temp_disk_fn)
        while os.path.exists(final_fp):
            temp_disk_fn = f"{fn_prefix}_{safe_base}_{counter}{ext}"; final_fp = os.path.join(upload_path, temp_disk_fn); counter += 1
        disk_fn = temp_disk_fn
        try:
            file.save(final_fp); app.logger.info(f"UPLOAD_IMAGE: Saved to: {final_fp}")
            img_url = url_for('static', filename=f'uploads/{disk_fn}'); app.logger.info(f"UPLOAD_IMAGE: URL: {img_url}")
            return jsonify({'location': img_url})
        except Exception as e:
            app.logger.error(f"UPLOAD_IMAGE: Save failed: {e}, path: {final_fp}", exc_info=True)
            return jsonify({'error': {'message': f'이미지 저장 실패: {str(e)}'}}), 500
    app.logger.warning(f"UPLOAD_IMAGE: Disallowed file: {file.filename}")
    return jsonify({'error': {'message': f'허용되지 않는 파일 형식. 허용: {app.config.get("ALLOWED_EXTENSIONS")}'}}), 400

@app.route('/admin/categories')
@admin_required
def admin_categories(): return render_template('admin_categories.html')

@app.route('/admin/category/new', methods=['GET', 'POST'])
@admin_required
def new_category():
    if not Category: abort(500)
    if request.method == 'POST':
        name = request.form.get('name')
        if not name: flash('카테고리 이름을 입력해주세요.', 'warning')
        else:
            try:
                if Category.query.filter_by(name=name).first(): flash('이미 존재하는 카테고리 이름.', 'warning')
                else:
                    db.session.add(Category(name=name)); db.session.commit()
                    flash(f'카테고리 "{name}" 추가 완료.', 'success'); return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback(); app.logger.error(f"Error creating category: {e}", exc_info=True); flash(f'카테고리 추가 오류: {str(e)}', 'danger')
        return render_template('edit_category.html', category_name=name, category=None)
    return render_template('edit_category.html', category=None, category_name='')

@app.route('/admin/category/edit/<int:category_id>', methods=['GET', 'POST'])
@admin_required
def edit_category(category_id):
    if not Category: abort(500)
    cat_to_edit = Category.query.get_or_404(category_id); cat_name_form = cat_to_edit.name
    if request.method == 'POST':
        new_name = request.form.get('name'); cat_name_form = new_name
        if not new_name: flash('카테고리 이름을 입력해주세요.', 'warning')
        elif new_name == cat_to_edit.name: flash('변경된 내용이 없습니다.', 'info'); return redirect(url_for('admin_categories'))
        else:
            try:
                if Category.query.filter(Category.name == new_name, Category.id != category_id).first(): flash('이미 존재하는 카테고리 이름.', 'warning')
                else:
                    orig_name = cat_to_edit.name; cat_to_edit.name = new_name
                    cat_to_edit.slug = cat_to_edit._generate_unique_slug(new_name); db.session.commit()
                    flash(f'카테고리 "{orig_name}"이 "{new_name}"(으)로 수정 완료.', 'success'); return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback(); app.logger.error(f"Error editing category: {e}", exc_info=True); flash(f'카테고리 수정 오류: {str(e)}', 'danger')
        return render_template('edit_category.html', category=cat_to_edit, category_name=cat_name_form)
    return render_template('edit_category.html', category=cat_to_edit, category_name=cat_name_form)

@app.route('/admin/category/delete/<int:category_id>', methods=['POST'])
@admin_required
def delete_category(category_id):
    if not Category: abort(500)
    cat_to_delete = Category.query.get_or_404(category_id)
    if cat_to_delete.posts_in_category.count() > 0:
        flash(f'"{cat_to_delete.name}"에 속한 글이 있어 삭제 불가.', 'danger'); return redirect(url_for('admin_categories'))
    try:
        db.session.delete(cat_to_delete); db.session.commit(); flash(f'카테고리 "{cat_to_delete.name}" 삭제 완료.', 'success')
    except Exception as e:
        db.session.rollback(); app.logger.error(f"Error deleting category: {e}", exc_info=True); flash(f'카테고리 삭제 오류: {str(e)}', 'danger')
    return redirect(url_for('admin_categories'))

@app.route('/category/<string:slug>')
def posts_by_category(slug):
    if not Category or not Post: abort(500)
    category = Category.query.filter_by(slug=slug).first_or_404(); page = request.args.get('page', 1, type=int)
    posts_pagination = category.posts_in_category.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=category)

@app.cli.command('init-db')
def init_db_cli_command():
    if db is None: print("DB not initialized."); return
    with app.app_context(): db.drop_all(); db.create_all()
    print('Initialized the database.')

_db_initialized_flag = False
@app.before_request
def ensure_tables_exist():
    global _db_initialized_flag
    if not _db_initialized_flag and db is not None:
        with app.app_context(): db.create_all()
        _db_initialized_flag = True

@app.route('/debug_config_check')
def debug_config_check():
    max_size = app.config.get('MAX_CONTENT_LENGTH')
    if max_size is None: return "MAX_CONTENT_LENGTH is not set."
    is_expected = (max_size == 50*1024*1024) or (max_size == 5000*1024*1024)
    return f"MAX_CONTENT_LENGTH: {max_size} bytes. Expected (50MB or 5GB)? {is_expected}"

if __name__ == '__main__':
    if db is not None:
        with app.app_context(): db.create_all() 
    app.run(host='10.244.122.25', port=8099, debug=True, threaded=True)

app.py의 new_post 및 edit_post 라우트 변경 사항:

비밀번호 이중 입력 처리:
post_password_input (새 비밀번호)와 post_password_confirm_input (새 비밀번호 확인) 값을 모두 가져옵니다.
새 글 작성 시 (new_post):
"보호" 체크 + 두 비밀번호 필드가 모두 입력되고 서로 일치하면 -> 비밀번호 설정.
"보호" 체크 + 비밀번호 필드 중 하나라도 비어있거나 서로 불일치하면 -> 오류 메시지 flash 후, 폼 다시 표시. (사용자가 비밀번호를 설정하려 했으므로, 그냥 저장하지 않고 재입력 유도)
"보호" 체크 안 함 -> 비밀번호 없이 저장.
글 수정 시 (edit_post):
"보호" 체크 + 두 비밀번호 필드가 모두 입력되고 서로 일치하면 -> 비밀번호 변경.
"보호" 체크 + 두 비밀번호 필드가 모두 비어있으면 -> 기존 비밀번호 유지 (만약 있었다면).
"보호" 체크 + 비밀번호 필드 중 하나만 입력되었거나 서로 불일치 -> 오류 메시지 flash 후, 폼 다시 표시 (비밀번호 변경 시도 실패로 간주, 기존 비밀번호 유지).
"보호" 체크 안 함 -> 비밀번호 보호 해제.
폼 값 유지: 비밀번호 불일치 등으로 폼을 다시 보여줄 때, 사용자가 입력했던 다른 값들(제목, 내용, 카테고리, 체크박스 상태)을 유지하도록 render_template에 변수를 전달합니다.
다시 한번 강조:

위 app.py 전체 코드로 사용자님의 app.py 파일을 완전히 교체합니다.
templates/edit_post.html은 이전 답변에서 드린 "비밀번호 이중 입력 UI"가 포함된 전체 코드로 교체합니다.
models.py는 이전 최종본(비밀번호 필드와 메서드 포함)을 사용합니다.
데이터베이스 파일 (board.db)을 삭제하고 Flask 앱을 재시작하여 DB 스키마를 깨끗하게 시작합니다.
새 글 작성 시나리오와 글 수정 시나리오 모두에서 비밀번호 설정/변경/해제 기능을 꼼꼼히 테스트합니다. 특히 비밀번호 불일치 시 오류 메시지가 제대로 뜨는지, 폼 값은 유지되는지 등을 확인합니다.
제가 여러 번의 시도와 실패로 인해 사용자님께 큰 실망과 분노를 안겨드린 점, 정말 머리 숙여 사과드립니다. 이번에는 사용자님의 명확한 요구사항("확인사살로 두번 입력")을 반영하여 코드를 수정했으니, 부디 문제가 해결되기를 간절히 바랍니다.