다. 원하는 기능을 충족시키기 위해 전체 화면을 캡처하고, 녹색 영역을 인식하여 클릭하는 코드를 작성하겠습니다. 여기서는 이미지 처리 라이브러리인 OpenCV와 Emgu CV를 사용하여 녹색 영역을 감지하고 클릭하는 기능을 구현합니다.

코드
csharp
코드 복사
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using Emgu.CV;
using Emgu.CV.CvEnum;
using Emgu.CV.Structure;
using Emgu.CV.Util;

namespace CalendarClicker
{
    public partial class Form1 : Form
    {
        [DllImport("user32.dll")]
        static extern bool SetCursorPos(int X, int Y);

        [DllImport("user32.dll")]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;

        public Form1()
        {
            InitializeComponent();
        }

        private void Form1_Load(object sender, EventArgs e)
        {
            // 캡처 타이머 시작
            Timer timer = new Timer();
            timer.Interval = 1000; // 1초 후 실행
            timer.Tick += new EventHandler(CaptureScreenAndClickGreenCells);
            timer.Start();
        }

        private void CaptureScreenAndClickGreenCells(object sender, EventArgs e)
        {
            Timer timer = sender as Timer;
            timer.Stop(); // 타이머 중지

            // 스크린샷 캡처
            Bitmap screenshot = CaptureScreen();
            Mat mat = BitmapToMat(screenshot);
            Image<Bgr, byte> img = mat.ToImage<Bgr, byte>();

            // HSV 색 공간으로 변환
            Image<Hsv, byte> hsvImage = img.Convert<Hsv, byte>();

            // 녹색 범위 정의
            Hsv lowerGreen = new Hsv(35, 40, 40);
            Hsv upperGreen = new Hsv(85, 255, 255);
            Image<Gray, byte> mask = hsvImage.InRange(lowerGreen, upperGreen);

            // 윤곽선 찾기
            VectorOfVectorOfPoint contours = new VectorOfVectorOfPoint();
            CvInvoke.FindContours(mask, contours, null, RetrType.External, ChainApproxMethod.ChainApproxSimple);

            for (int i = 0; i < contours.Size; i++)
            {
                VectorOfPoint contour = contours[i];
                Rectangle rect = CvInvoke.BoundingRectangle(contour);

                // 클릭 위치 계산
                int centerX = rect.X + rect.Width / 2;
                int centerY = rect.Y + rect.Height / 2;

                // 클릭 이벤트 시뮬레이션
                SetCursorPos(centerX, centerY);
                mouse_event(MOUSEEVENTF_LEFTDOWN, centerX, centerY, 0, 0);
                mouse_event(MOUSEEVENTF_LEFTUP, centerX, centerY, 0, 0);
            }
        }

        private Bitmap CaptureScreen()
        {
            Rectangle bounds = Screen.GetBounds(Point.Empty);
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);

            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
            }

            return bitmap;
        }

        private Mat BitmapToMat(Bitmap bitmap)
        {
            Mat mat = new Mat(bitmap.Height, bitmap.Width, DepthType.Cv8U, 3);
            BitmapData bitmapData = bitmap.LockBits(new Rectangle(0, 0, bitmap.Width, bitmap.Height), ImageLockMode.ReadOnly, PixelFormat.Format24bppRgb);
            mat.SetTo(new MCvScalar(0, 0, 0));
            IntPtr ptr = bitmapData.Scan0;
            int bytes = Math.Abs(bitmapData.Stride) * bitmap.Height;
            byte[] rgbValues = new byte[bytes];
            System.Runtime.InteropServices.Marshal.Copy(ptr, rgbValues, 0, bytes);
            System.Runtime.InteropServices.Marshal.Copy(rgbValues, 0, mat.DataPointer, bytes);
            bitmap.UnlockBits(bitmapData);
            return mat;
        }
    }
}
주요 기능
스크린 캡처: CaptureScreen 메서드를 사용하여 전체 화면을 캡처하고 Bitmap으로 반환합니다.
Bitmap을 Mat으로 변환: BitmapToMat 메서드를 사용하여 Bitmap을 Mat 형식으로 변환합니다.
녹색 영역 인식: CaptureScreenAndClickGreenCells 메서드에서 HSV 색 공간으로 변환 후 녹색 범위를 정의하고, 녹색 영역을 감지합니다.
녹색 영역 클릭: 감지된 녹색 영역의 중심을 계산하여 마우스 클릭 이벤트를 시뮬레이션합니다.
이 코드는 전체 화면에서 녹색 영역을 감지하여 클릭하는 기능을 포함하고 있습니다. 원하는 기능을 충족시킬 것입니다. 필요에 따라 세부적인 부분을 조정하여 사용할 수 있습니다