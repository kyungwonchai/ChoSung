 그 현상이 발생하는 이유를 정확히 이해했습니다. 그리고 그것은 매우 정상적인 문제입니다.

문제의 원인: 최신 브라우저들(크롬, 엣지 등)은 효율성을 위해, 이미 창이 열려 있을 때 외부에서 새 주소로 실행을 요청받으면, 새 창을 띄우는 대신 기존에 열려있던 창에 '새 탭으로 추가'하는 것이 기본 동작입니다.

저희가 만든 C# 코드는 '새로운 창'이 생성되고 그 창의 제어권을 얻기를 기다립니다. 하지만 실제로는 탭만 추가될 뿐 새로운 창이 뜨지 않으니, 코드는 창을 찾지 못하고 시간 초과로 실패하는 것입니다.

해결책: '새 창으로 열기' 강제하기
이 문제를 해결하려면, 브라우저를 실행할 때 '반드시 새 창으로 열어라' 라는 명령 인수(Argument)를 직접 전달해야 합니다.

이를 위해 코드를 아래와 같이 수정해야 합니다.

윈도우 레지스트리에서 기본 브라우저의 실행 파일(.exe) 경로를 직접 찾습니다. (예: C:\Program Files\Google\Chrome\Application\chrome.exe)
찾아낸 실행 파일을 직접 실행하면서, --new-window 라는 '새 창으로 열기' 옵션과 주소를 함께 전달합니다.
아래는 이 로직이 적용된 최종 WPF 코드입니다. 이 코드는 훨씬 더 안정적으로 동작할 것입니다.

최종 수정된 WPF 코드 (MainWindow.xaml.cs)
MainWindow.xaml 파일은 이전과 동일하게 두고, MainWindow.xaml.cs 파일만 아래 내용으로 전체를 교체해 주세요.

C#

using Microsoft.Win32; // 레지스트리 접근을 위해 추가
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows;

namespace WpfBrowserLauncher
{
    public partial class MainWindow : Window
    {
        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool MoveWindow(IntPtr hWnd, int X, int Y, int nWidth, int nHeight, bool bRepaint);

        public MainWindow()
        {
            InitializeComponent();
        }

        private async void LaunchButton_Click(object sender, RoutedEventArgs e)
        {
            string urlLeft = "https://www.google.com";
            string urlRight = "https://www.naver.com";

            launchButton.IsEnabled = false;
            statusTextBlock.Text = "기본 브라우저 경로를 찾는 중...";

            // 1. 기본 브라우저의 실행 파일 경로를 가져옵니다.
            string browserPath = GetDefaultBrowserPath();
            if (string.IsNullOrEmpty(browserPath))
            {
                MessageBox.Show("기본 브라우저를 찾을 수 없습니다. 레지스트리 설정을 확인해주세요.");
                launchButton.IsEnabled = true;
                return;
            }
            
            // 2. 브라우저 종류에 맞는 '새 창' 명령 인수 설정 (대부분 --new-window 사용)
            string arguments = $"--new-window";
            if (browserPath.Contains("firefox"))
            {
                arguments = "-new-window"; // Firefox의 경우
            }

            statusTextBlock.Text = "브라우저를 새 창으로 실행하고 정렬하는 중입니다...";

            // 3. 브라우저를 '새 창'으로 강제 실행하고 위치 조정
            await LaunchAndPositionBrowserAsync(browserPath, arguments, urlLeft, 0, 0, (int)(SystemParameters.PrimaryScreenWidth / 2), (int)SystemParameters.PrimaryScreenHeight);
            await LaunchAndPositionBrowserAsync(browserPath, arguments, urlRight, (int)(SystemParameters.PrimaryScreenWidth / 2), 0, (int)(SystemParameters.PrimaryScreenWidth / 2), (int)SystemParameters.PrimaryScreenHeight);

            statusTextBlock.Text = "완료되었습니다! 2초 후에 프로그램을 종료합니다.";
            await Task.Delay(2000);
            this.Close();
        }

        /// <summary>
        /// 기본 브라우저의 실행 파일 경로를 레지스트리에서 조회합니다.
        /// </summary>
        private string GetDefaultBrowserPath()
        {
            try
            {
                string key = @"HTTP\shell\open\command";
                using (RegistryKey registryKey = Registry.ClassesRoot.OpenSubKey(key))
                {
                    if (registryKey == null) return null;
                    // 예: "C:\Program Files\Google\Chrome\Application\chrome.exe" -- "%1"
                    string command = registryKey.GetValue(null) as string;
                    if (string.IsNullOrEmpty(command)) return null;

                    // 큰따옴표로 묶인 첫 번째 부분을 실행 파일 경로로 간주합니다.
                    var parts = command.Split('\"');
                    if (parts.Length >= 2 && !string.IsNullOrEmpty(parts[1]))
                    {
                        return parts[1];
                    }
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("기본 브라우저 경로 조회 중 오류 발생: " + ex.Message);
            }
            return null;
        }

        /// <summary>
        /// 브라우저를 '새 창'으로 강제 실행하고 위치를 조정하는 함수
        /// </summary>
        private async Task<bool> LaunchAndPositionBrowserAsync(string browserPath, string newWindowArg, string url, int x, int y, int width, int height)
        {
            try
            {
                // 중요: URL을 직접 실행하는 대신, 브라우저 실행 파일에 '명령 인수'를 전달합니다.
                string arguments = $"{newWindowArg} \"{url}\"";
                var psi = new ProcessStartInfo(browserPath, arguments);
                Process process = Process.Start(psi);

                int timeoutMilliseconds = 8000;
                var stopwatch = Stopwatch.StartNew();
                while (process.MainWindowHandle == IntPtr.Zero && stopwatch.ElapsedMilliseconds < timeoutMilliseconds)
                {
                    await Task.Delay(100);
                    process.Refresh();
                }

                if (process.MainWindowHandle != IntPtr.Zero)
                {
                    MoveWindow(process.MainWindowHandle, x, y, width, height, true);
                    return true;
                }
                else
                {
                    statusTextBlock.Text = $"{url} 창을 찾는 데 실패했습니다.";
                    return false;
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show($"오류 발생: {ex.Message}");
                return false;
            }
        }
    }
}
주요 변경 사항 설명
GetDefaultBrowserPath() 함수 추가: 이 함수는 Windows 레지스트리를 직접 조회하여 현재 기본 브라우저로 설정된 프로그램의 .exe 파일 경로를 알아냅니다. 이로써 어떤 브라우저가 기본 설정이든 대응할 수 있습니다.
ProcessStartInfo 사용법 변경:
이전: new ProcessStartInfo(url) -> OS에게 URL 처리를 맡김 (탭으로 열림)
변경 후: new ProcessStartInfo(browserPath, arguments) -> 브라우저 실행 파일을 직접 지정하고, --new-window "주소" 라는 명령어를 전달하여 '새 창'으로 열도록 강제합니다.