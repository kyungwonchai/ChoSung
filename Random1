문가 수준의 C# 코드로, 최신 .bom 파일 하나만, 조건을 만족하는 모든 PPP 위치에서 탐색하여,
병렬 처리를 통해 초고속으로 .bom 파일 경로를 수집하고,
수집된 결과를 ListBox에 UI 쓰레드 안전하게 바인딩하도록 구성해드립니다.

[구성 목표]
Parallel.ForEach 로 디렉터리 병렬 탐색

.bom 파일이 여러 개인 경우 가장 최신 파일만

ObservableCollection<string> 에 결과 저장 (UI 바인딩 용)

WPF ListBox와 바인딩 가능하게 Dispatcher 사용

[1] ViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Threading;

public class BomFinderViewModel
{
    public ObservableCollection<string> BomFilePaths { get; } = new ObservableCollection<string>();

    private Dispatcher _dispatcher;

    public BomFinderViewModel(Dispatcher dispatcher)
    {
        _dispatcher = dispatcher;
    }

    public void StartScan(string rootPath)
    {
        Task.Run(() =>
        {
            var resultList = new List<string>();
            var firstLevelDirs = Directory.GetDirectories(rootPath);

            Parallel.ForEach(firstLevelDirs, level1 =>
            {
                try
                {
                    foreach (var level2 in Directory.GetDirectories(level1))
                    {
                        if (!Path.GetFileName(level2).Contains("SM-"))
                            continue;

                        foreach (var ppp in Directory.GetDirectories(level2))
                        {
                            var hasPatternFolder = Directory.EnumerateDirectories(ppp, "*", SearchOption.AllDirectories)
                                .Any(sub => Regex.IsMatch(Path.GetFileName(sub), @"^[A-Z]{2}-[A-Z0-9]$", RegexOptions.IgnoreCase));

                            if (!hasPatternFolder)
                            {
                                var bomFile = Directory.GetFiles(ppp, "*.bom", SearchOption.TopDirectoryOnly)
                                    .Select(path => new FileInfo(path))
                                    .OrderByDescending(f => f.LastWriteTime)
                                    .FirstOrDefault();

                                if (bomFile != null)
                                {
                                    lock (resultList)
                                    {
                                        resultList.Add(bomFile.FullName);
                                    }
                                }
                            }
                        }
                    }
                }
                catch (Exception ex)
                {
                    // 예외 로깅 필요 시 여기에
                }
            });

            // UI 쓰레드에 안전하게 결과 반영
            _dispatcher.Invoke(() =>
            {
                BomFilePaths.Clear();
                foreach (var path in resultList)
                    BomFilePaths.Add(path);
            });
        });
    }
}
[2] MainWindow.xaml
xml
코드 복사
<Window x:Class="BomScanner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="BOM Finder" Height="450" Width="800">
    <Grid>
        <ListBox ItemsSource="{Binding BomFilePaths}" FontSize="14" />
    </Grid>
</Window>
[3] MainWindow.xaml.cs
csharp
코드 복사
using System.Windows;

namespace BomScanner
{
    public partial class MainWindow : Window
    {
        private BomFinderViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new BomFinderViewModel(Dispatcher);
            DataContext = _viewModel;

            string rootPath = @"D:\경로\smd-pgm-server";
            _viewModel.StartScan(rootPath);
        }
    }
}
[추가 옵션]
.bom 파일의 수정일 기준 정렬됨 (LastWriteTime)

Dispatcher.Invoke로 WPF ListBox에 바인딩 안전

ObservableCollection은 ListBox 자동 갱신됨

Parallel.ForEach는 CPU 코어 수에 맞게 병렬 처리

lock으로 다중 쓰레드 충돌 방지

필요 시:

로그 남기기

리스트 더블클릭 시 .bom 열기

파일 크기나 내용 조건 추가