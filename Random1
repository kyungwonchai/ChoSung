ndroid 13(API 33) 이상에서는 알림을 표시하려면 런타임 권한을 요청해야 합니다. Android 13 이전에는 알림 권한을 자동으로 부여받았지만, 이제는 사용자가 명시적으로 허용해야 합니다. 아래에 Android 13 이상에서도 알림을 표시할 수 있도록 권한 요청을 추가한 코드를 수정하여 제공하겠습니다.

권한 요청 추가
MainActivity.kt에서 NotificationManager를 사용하기 전에 권한을 요청하는 부분을 추가해야 합니다. Android 13 이상에서는 POST_NOTIFICATIONS 권한을 요청하도록 설정합니다.

수정된 MainActivity.kt 코드
kotlin
코드 복사
package com.dxmxsmd.routeracralarm

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.PowerManager
import android.util.Log
import android.widget.Button
import android.widget.CheckBox
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.lifecycle.lifecycleScope
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity() {

    private lateinit var hubConnection: HubConnection
    private lateinit var notificationManager: NotificationManager
    private lateinit var vibrationCheckBox: CheckBox
    private lateinit var viewMessagesButton: Button

    // 런타임 권한 요청을 위한 launcher 정의
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            Log.d("Permission", "Notification permission granted")
        } else {
            Log.d("Permission", "Notification permission denied")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 진동 체크박스 초기화
        vibrationCheckBox = findViewById(R.id.vibrationCheckBox)

        // 최근 메시지 보기 버튼 초기화 및 클릭 리스너 설정
        viewMessagesButton = findViewById(R.id.viewMessagesButton)
        viewMessagesButton.setOnClickListener {
            val intent = Intent(this, DataActivity::class.java)
            startActivity(intent)
        }

        // 알림 채널 생성
        createNotificationChannel()

        // Android 13 이상에서 알림 권한 요청
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requestNotificationPermission()
        }

        // SignalR 서버 연결 설정
        hubConnection = HubConnectionBuilder.create("https://your-signalr-server-address")
            .build()

        // SignalR 메시지 수신 대기
        hubConnection.on("ReceiveMessage", { message: String ->
            showNotification(message) // 메시지 수신 시 알림
            wakeUpScreen() // 화면 켜기
        }, String::class.java)

        lifecycleScope.launch {
            try {
                hubConnection.start().blockingAwait()
                Log.d("SignalR", "Connected to SignalR server.")
            } catch (e: Exception) {
                Log.e("SignalR", "SignalR connection failed", e)
            }
        }
    }

    private fun showNotification(message: String) {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent: PendingIntent =
            PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)

        val builder = NotificationCompat.Builder(this, "SIGNALR_CHANNEL")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("New SignalR Message")
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)

        if (vibrationCheckBox.isChecked) {
            builder.setVibrate(longArrayOf(0, 500, 1000))
        }

        notificationManager.notify(1, builder.build())
    }

    private fun wakeUpScreen() {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        val isScreenOn = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH) {
            powerManager.isInteractive
        } else {
            @Suppress("DEPRECATION")
            powerManager.isScreenOn
        }

        if (!isScreenOn) {
            val wakeLock = powerManager.newWakeLock(
                PowerManager.SCREEN_BRIGHT_WAKE_LOCK or PowerManager.ACQUIRE_CAUSES_WAKEUP,
                "RouterACRAlarm::WakeLockTag"
            )
            wakeLock.acquire(3000) // 3초 동안 화면 켜짐 유지
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "SignalR Channel"
            val descriptionText = "Channel for SignalR notifications"
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel("SIGNALR_CHANNEL", name, importance).apply {
                description = descriptionText
            }
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        } else {
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        }
    }

    private fun requestNotificationPermission() {
        when {
            // 이미 권한이 부여된 경우
            ActivityCompat.checkSelfPermission(
                this, Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED -> {
                Log.d("Permission", "Notification permission already granted")
            }

            // 권한이 부여되지 않은 경우, 요청
            else -> {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }
}
설명
Android 13 이상에서 권한 요청:

requestNotificationPermission 메서드는 Android 13(API 33) 이상에서 알림 권한을 요청합니다.
권한이 이미 부여된 경우 아무 작업도 하지 않고, 그렇지 않은 경우 requestPermissionLauncher를 사용하여 런타임 권한을 요청합니다.
ActivityResultLauncher를 사용한 권한 요청:

ActivityResultContracts.RequestPermission()을 사용하여 권한 요청 결과를 처리합니다.
사용자가 권한을 허용하거나 거부할 때 로그로 확인할 수 있습니다.
Android 13 이하:

Android 13 이하의 경우 알림 권한을 요청할 필요가 없으므로 이 코드에서는 POST_NOTIFICATIONS 권한을 요청하지 않습니다.