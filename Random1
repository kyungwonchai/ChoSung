습니다. 다음과 같은 요구사항으로 전체 설계를 진행하겠습니다:

DevExpress 22.2 + WPF 기반 실시간 보관함 관리 시스템

사용자 목록 좌측 표시 (이름, KnoxID, 항목 미선택 시 색상 강조)

우측 상단: 사물함/신발장/락커 3가지 항목 표시 및 수정/삭제/추가 (로그인 사용자만 가능)

우측 하단: 도형 기반 DiagramControl로 레이아웃 구성 (사물함/신발장/락커마다 다른 배치, 사용자 커스터마이징)

사용자별 권한 기반 로그인 시스템: 로그인 없을 경우 읽기 전용 조회만 가능

모든 배치 및 변경 사항은 MSSQL에 저장되어 다음 실행 시 복원됨

이제 다음 단계로 전체 설계와 구현을 위한 구조와 코드 예제를 수집하고 정리하겠습니다. 완료되면 알려드리겠습니다.

Research completed in 7m· 출처 28개
DevExpress 22.2 + WPF 기반 사물함 관리 시스템 설계
프로젝트 구조 (MVVM 패턴)
이 시스템은 MVVM (Model-View-ViewModel) 패턴으로 구현하며, 프로젝트는 모델(Model), 뷰모델(ViewModel), 뷰(View) 세 영역으로 구성됩니다. 데이터 관리와 비즈니스 로직은 뷰모델과 모델에서 처리되고, UI는 XAML 뷰에서 DevExpress 컨트롤을 통해 표현합니다. 주요 UI 화면은 좌측의 사용자 목록 패널과 우측의 상세 패널로 구분됩니다:
좌측 패널: DevExpress GridControl을 사용하여 **사용자 목록(이름, KnoxID 등)**을 표시합니다. MVVM 바인딩으로 사용자 리스트 컬렉션에 연결되며, 사용자 중 관리 항목(사물함/신발장/락커)을 모두 배정받지 않은 경우 해당 행 배경색을 별도로 표시하여 식별합니다 (예: 배정 미완료 사용자는 회색 하이라이트).
우측 상단 패널: 선택된 사용자의 상세 정보 및 관리 항목 3가지(사물함, 신발장, 락커) 배정 현황을 표시합니다. 각각의 항목에 대해 배정된 사물함/신발장/락커의 표시 이름, 위치(층/구역), 소속 파트, 담당 관리자 등의 정보를 보여주며, 권한이 있는 사용자(로그인된 관리자)는 이 정보를 **편집/삭제/추가(배정)**할 수 있습니다.
우측 하단 패널: DevExpress DiagramControl 기반의 도형 레이아웃 뷰로, 전체 사물함/신발장/락커의 배치도를 시각화합니다. 여기에는 모든 사물함/신발장/락커를 도형으로 표시하고, 색상으로 상태를 구분합니다. 선택된 사용자의 소속 파트에 속한 사용 중인 공간들은 특정 색으로, 빈 사물함(배정되지 않은 항목)은 다른 색으로, 현재 선택 사용자에게 배정된 항목은 눈에 띄는 강조 색으로 표시됩니다. 사용자는 이 다이어그램 상에서 도형의 위치나 모양을 드래그하여 원하는 대로 커스터마이징할 수 있으며, 변경된 레이아웃은 데이터베이스에 저장 및 복원됩니다.
이러한 구조는 레이어간 분리와 유지보수성을 높입니다. 예를 들어, 데이터베이스나 UI 기술이 바뀌더라도 뷰모델과 모델 간 인터페이스를 유지하면 로직을 재사용할 수 있습니다. 또한 MVVM으로 데이터 바인딩을 활용하기 때문에, ObservableCollection과 INotifyPropertyChanged를 사용하여 실시간 데이터 변경 사항이 UI에 자동 반영되도록 합니다​
STACKOVERFLOW.COM
. (DevExpress GridControl도 ObservableCollection에 바인딩하면 컬렉션 변경 시 자동으로 갱신됩니다.) 프로젝트의 솔루션 구조 예시:
Models 폴더: User, Locker 등 데이터 모델 클래스 정의
ViewModels 폴더: MainViewModel, LoginViewModel 등 뷰모델 클래스 정의
Views 폴더: MainWindow.xaml (주요 UI), LoginWindow.xaml (로그인 창) 등의 뷰(XAML) 정의
Services/DataAccess: DB와 통신하는 Repository 또는 DAO 클래스 (Entity Framework 또는 ADO.NET 사용)
Utilities: UUID 생성, 권한 체크, 이벤트 메신저 등 유틸리티 클래스
데이터베이스 설계 (MSSQL)
데이터는 Microsoft SQL Server에 저장되며, 테이블 설계는 사용자와 보관함(사물함/신발장/락커) 정보를 효과적으로 관리하도록 구성합니다. Users 테이블과 각 보관함 유형별 테이블(예: Lockers, Shoes, LargeLockers)로 구분하고 외래 키로 연관시킵니다. 각 사용자와 각 보관함 항목을 고유 식별자로 연결하여, 이름이나 KnoxID 등의 정보가 변경되더라도 참조 무결성이 유지되도록 합니다​
BLOG.DEVART.COM
.
Users (사용자 테이블):
UserId (UNIQUEIDENTIFIER, Primary Key, 기본값 NEWID()): 내부 관리용 UUID 고유키. 사용자 레코드를 식별하며, 변경되지 않습니다 (자연 키인 이름이나 KnoxID는 변경 가능하지만 이 surrogate key는 항상 고유하고 불변입니다​
BLOG.DEVART.COM
).
Name (NVARCHAR(100)): 사용자 성명.
KnoxId (NVARCHAR(50)): KnoxID(예: 사원번호 또는 사물함 시스템 외부 연동 ID). 고유 제약 조건을 걸어 중복을 방지합니다.
Department (NVARCHAR(100)): 사용자 소속 파트(부서). (선택 사항이지만, 소속 파트별 색상 표시 기능을 위해 저장)
기타: Role 또는 IsAdmin (BIT) 필드를 두어 권한 여부 저장 가능 (예: 관리자 여부). 로그인 계정으로도 활용한다면 비밀번호 해시 필드 등을 둘 수 있습니다.
Lockers (사물함 테이블) – 사물함(서랍함 등)을 나타냅니다. 신발장, 락커 등 다른 유형도 비슷한 구조의 별도 테이블로 설계하거나, 하나의 StorageItems 테이블에 Type 컬럼으로 구분할 수 있습니다. 여기서는 이해를 돕기 위해 개별 테이블로 예시합니다:
LockerId (INT, Primary Key, IDENTITY): 사물함 항목의 고유 ID (번호).
DisplayName (NVARCHAR(50)): 사물함의 표시 이름 또는 번호 (예: "A-101").
Floor (INT): 위치 층 정보.
Zone (NVARCHAR(50)): 구역 (예: 동/서/남/북 구역 등)
Department (NVARCHAR(100)): 이 사물함이 속한 파트/부서 (해당 부서 배정 용도 혹은 위치 구분).
Manager (NVARCHAR(100)): 담당 관리자 이름 (예: 시설 담당자).
UserId (UNIQUEIDENTIFIER, Foreign Key references Users(UserId) NULL 허용): 현재 이 사물함을 사용 중인 사용자의 ID. 배정되지 않은 경우 NULL.
제약: UserId에 고유 인덱스를 걸어 하나의 사용자(UserId)가 두 개 이상의 사물함을 배정받지 않도록 합니다 (UserId UNIQUE, 조건: UserId IS NOT NULL).
(필요시) PosX, PosY (FLOAT): Diagram 레이아웃에서 이 사물함 도형의 X, Y 좌표. (사용자 커스터마이징된 위치 저장)
(필요시) ShapeType, Color 등: Diagram에서 모양 커스터마이징을 저장 (예: 사각형/원 형태, 색상 등).
Shoes (신발장 테이블) – Lockers와 구조 동일, 신발장 항목 목록을 저장.
LargeLockers (락커 테이블) – 구조 동일, 대형 락커 혹은 다른 종류의 보관함 목록.
노트: 위처럼 유형별 테이블을 분리하면 각 항목 유형별로 세부 필드를 달리 정의할 수 있고 관리가 단순합니다. 만약 세 가지 보관함 유형이 완전히 동일한 속성을 가진다면, StorageItem 이라는 단일 테이블로 묶고 Type 필드로 구분할 수도 있습니다. 이 경우 사용자와 보관함의 매핑은 UserAssignments 등의 별도 테이블( UserId, ItemId, Type )로 관리하거나, Users 테이블에 LockerItemId, ShoeItemId 등의 컬럼을 둘 수도 있습니다. 다양한 방법이 있지만, 기존 연결 유지한 채 항목 정보를 수정하기 위해서는 서로 참조하는 키는 변경되지 않고 별도 식별자를 사용하는 설계가 중요합니다.
예를 들어, Users와 Lockers 테이블 생성 SQL 스키마는 다음과 같습니다 (다른 두 테이블도 유사하게 정의):
sql
코드 복사
CREATE TABLE Users (
    UserId UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    Name NVARCHAR(100) NOT NULL,
    KnoxId NVARCHAR(50) NOT NULL UNIQUE,
    Department NVARCHAR(100) NULL,
    IsAdmin BIT NOT NULL DEFAULT 0
    -- PasswordHash VARBINARY(...) 등 추가 가능
);

CREATE TABLE Lockers (
    LockerId INT PRIMARY KEY IDENTITY(1,1),
    DisplayName NVARCHAR(50) NOT NULL,
    Floor INT NOT NULL,
    Zone NVARCHAR(50) NULL,
    Department NVARCHAR(100) NULL,
    Manager NVARCHAR(100) NULL,
    UserId UNIQUEIDENTIFIER NULL,
    CONSTRAINT FK_Lockers_User FOREIGN KEY (UserId) REFERENCES Users(UserId)
);
-- 사용자 하나당 하나의 사물함만 갖도록 유니크 인덱스
CREATE UNIQUE INDEX UX_Locker_User ON Lockers(UserId) WHERE UserId IS NOT NULL;
다른 Shoes, LargeLockers 테이블도 Lockers와 동일한 패턴으로 설계하고, 각 테ーブル에 대해 UserId에 고유 인덱스를 부여합니다. 이러한 구조로 User ↔ Item이 일대일(Optional) 관계로 연결되며, 사용자나 항목의 주요 정보(이름, 위치 등)는 자유롭게 변경되어도 UserId와 Item의 기본키로 맺어진 연결은 유지됩니다.
데이터 모델 클래스 (C#)
위 데이터베이스 구조를 반영하여 C# 모델 클래스를 정의합니다. Entity Framework를 사용한다면 DbContext와 DbSet으로 매핑할 수 있고, 또는 ADO.NET을 쓴다면 수동으로 클래스와 SQL을 매핑합니다. 여기서는 간단히 모델 클래스를 정의해보겠습니다. 모든 모델에는 INotifyPropertyChanged를 구현하여 프로퍼티 변경 시 UI에 통보되도록 합니다 (MVVM 바인딩 용이):
csharp
코드 복사
using System;
using System.ComponentModel;

namespace LockerManagement.Models {
    // 사용자 모델 클래스 (INotifyPropertyChanged 구현)
    public class User : INotifyPropertyChanged {
        public Guid UserId { get; set; }  // 내부 고유 식별자 (UUID)
        public string Name { get; set; }  // 사용자 이름
        public string KnoxId { get; set; }  // Knox ID (사번 등)
        public string Department { get; set; }  // 소속 부서/파트
        public bool IsAdmin { get; set; }  // 관리자 권한 여부

        // 편집 가능 속성 - Name, KnoxId 등은 UI를 통해 변경 가능
        // UserId는 식별자이므로 변경 불가 (신규 추가시에만 발급)

        // INotifyPropertyChanged 구현
        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propName) {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));
        }
    }

    // 사물함 항목 모델 클래스
    public class LockerItem : INotifyPropertyChanged {
        public int LockerId { get; set; }  // PK
        public string DisplayName { get; set; }  // 표시 이름 (예: "A-101")
        public int Floor { get; set; }
        public string Zone { get; set; }
        public string Department { get; set; }
        public string Manager { get; set; }
        public Guid? UserId { get; set; }  // 현재 사용자 (없으면 null)

        // (옵션) Diagram 레이아웃 관련 속성:
        public double PositionX { get; set; }  // Diagram 상 X좌표
        public double PositionY { get; set; }  // Diagram 상 Y좌표
        public string ShapeType { get; set; }  // Diagram 도형 종류 (예: "Rectangle")
        public string Color { get; set; }  // Diagram 도형 색 (예: "#FF0000")

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propName) {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propName));
        }
    }

    // 신발장, 락커 등도 LockerItem과 동일 구조라고 가정
    public class ShoeItem : LockerItem { }
    public class LargeLockerItem : LockerItem { }
}
위 모델들은 DB의 각 테이블에 対応하는 속성을 갖습니다. User.UserId는 GUID로 Primary Key이며, LockerItem.UserId는 해당 사물함에 배정된 사용자 Guid를 저장합니다. 만약 ORMs를 사용한다면 public virtual User User 같은 navigation property를 둘 수도 있지만, 여기서는 단순화를 위해 식별자만 연결했습니다. (EF Core 사용 시 User와 LockerItem 사이에 1:0..1 관계를 매핑하고, LockerItem.User 내비게이션 속성을 통해 연결 가능) 또한 LockerItem에는 PositionX/Y, ShapeType 등의 Diagram 속성을 포함시켰습니다. 이로써 사용자 다이어그램 레이아웃 커스터마이징 내용을 개별 항목에 저장할 수 있습니다. (예: 사용자가 Diagram에서 사물함 위치를 옮기면 해당 LockerItem.PositionX/Y 값을 갱신하고 DB에 저장)
주의: 데이터 모델 클래스에는 종종 비즈니스 로직을 넣지 않고 순수 속성만 정의합니다. 비즈니스 로직(예: 배정/해제 메소드, 데이터 검증 등)은 뷰모델이나 별도 서비스 클래스에서 처리합니다. 또한 PropertyChanged 이벤트를 호출하여 UI 갱신을 보장합니다.
ViewModel 설계 및 핵심 기능 로직
MainViewModel은 메인 화면의 뷰모델로서, 좌측 사용자 리스트와 우측 상세 패널, 다이어그램을 모두 관장합니다. 주요 속성과 동작은 다음과 같습니다:
ObservableCollection<User> Users: 사용자 목록 데이터. 시작 시 DB에서 모든 사용자 정보를 불러와 채웁니다. ObservableCollection으로 정의하여 컬렉션 변경 시 UI(GridControl)에 자동 반영되도록 합니다​
STACKOVERFLOW.COM
.
User SelectedUser: 현재 선택된 사용자 (Users 리스트에서 선택한 항목). TwoWay 바인딩되어 GridControl의 선택과 연결됩니다.
LockerItem SelectedUserLocker, ShoeItem SelectedUserShoe, LargeLockerItem SelectedUserLargeLocker: 선택 사용자에 배정된 각 항목 객체. 사용자가 리스트에서 선택될 때마다 해당 사용자의 UserId로 DB를 조회하여 세 속성을 채웁니다 (또는 Users를 불러올 때 Include 해서 가져왔다면 Users 모델에 내비게이션/참조로 있을 수도 있습니다). 예를 들어 SelectedUser가 변경되면,
csharp
코드 복사
SelectedUserLocker = lockerRepository.GetByUserId(SelectedUser.UserId);
와 같이 가져오며 PropertyChanged로 UI에 표시합니다.
bool IsLoggedIn: 현재 로그인 상태를 나타냅니다. 로그인한 사용자인지 여부를 저장 (또는 현재 로그인 사용자 객체 자체를 저장해도 됨). 이 값에 따라 편집 가능 여부가 결정됩니다.
RelayCommand AddUserCommand: "신규 등록" 버튼용 커맨드. 실행 시 새로운 User 객체를 생성하여 Users 컬렉션에 추가하고, DB에도 저장합니다. 추가된 사용자는 기본적으로 아직 사물함/신발장/락커 배정이 없으므로 목록에서 특정 색상으로 표시됩니다 (예: 노란 배경).
RelayCommand SaveUserDetailsCommand: 선택된 사용자의 상세 정보(이름, KnoxID 등)가 수정된 경우 저장하는 커맨드. 이 커맨드에서는 변경된 사용자 객체를 DB에 업데이트 합니다. 이때 UserId (GUID)는 변경하지 않고, Name/KnoxId 등만 갱신하여 식별자 유지 원칙을 지킵니다.
RelayCommand AssignLockerCommand, RemoveLockerCommand 등: 사용자의 사물함/신발장/락커 배정을 추가하거나 해제하는 명령. 예를 들어 AssignLockerCommand 실행 시: 현재 SelectedUser에 사물함이 없다면, 사용 가능한 사물함 목록에서 하나를 선택하도록 (UI에서 콤보박스나 다이얼로그) 하고, 해당 사물함의 UserId를 SelectedUser.UserId로 설정하여 DB 업데이트합니다. RemoveLockerCommand는 반대로 사물함의 UserId를 NULL로 만들어 해제 처리합니다. 이러한 변경 후에는 Users 컬렉션과 SelectedUserLocker 속성도 갱신해서 UI에 즉시 반영합니다.
ObservableCollection<DiagramShape> DiagramShapes 또는 ObservableCollection<LockerItem> AllItems: DiagramControl에 표시할 모든 도형/항목 목록. 예를 들어, 모든 사물함, 신발장, 락커 항목을 합친 리스트를 유지합니다. 또는 개별적으로 Diagram에 표시할 Shape 객체 컬렉션을 둘 수도 있습니다. MVVM으로 DiagramControl에 바인딩하기 위해 DiagramDataBindingBehavior를 이용할 것이므로, ItemsSource로 사용할 컬렉션입니다. AllItems에는 LockerItem/ShoeItem/LargeLockerItem을 통합하여 담거나, 간단히 Object로 받고 DataTemplate로 모양을 나눌 수도 있습니다.
Diagram Layout 관련 이벤트 처리: 사용자가 Diagram (우측 하단 레이아웃)에서 도형을 움직이거나 편집한 경우 그 변화를 모델에 반영하기 위한 로직. DevExpress DiagramControl은 도형 배치 변경 이벤트 (예: ItemPositionChanged 등)를 제공하거나, DiagramControl의 Document를 통째로 저장하는 방법을 제공합니다. 여기서는 두 가지 접근을 모두 고려합니다:
데이터 바인딩 접근: DiagramControl에 DiagramDataBindingBehavior를 적용해 AllItems 컬렉션의 데이터를 기반으로 자동으로 도형을 생성합니다​
DOCS.DEVEXPRESS.COM
. 그리고 각 항목의 PositionX/PositionY를 Diagram 도형의 좌표와 양방향 바인딩하여, 사용자가 도형을 옮기면 해당 모델의 PositionX/Y 속성이 갱신되도록 합니다. (DevExpress 문서에 따르면 CustomLayoutItems 이벤트를 사용해 기본 레이아웃을 비활성화하고 수동 배치를 적용할 수 있습니다.) 이렇게 하면 뷰모델의 AllItems 데이터가 항상 최신 위치를 가지고 있게 되고, SaveLayoutCommand 등을 통해 DB에 모든 항목의 PositionX/Y를 업데이트하여 저장할 수 있습니다.
문서 직렬화 접근: DiagramControl의 내장 문서 저장 기능을 이용해 전체 다이어그램을 직렬화하여 DB에 저장합니다. DevExpress DiagramControl은 DiagramControl.SaveDocument(Stream) 메서드를 제공하여 현재 다이어그램을 XML 형식으로 스트림에 저장할 수 있고, LoadDocument(Stream)으로 로드도 가능합니다. 이 방식을 사용하면 사용자가 도형 모양(예: 색상, 추가 텍스트 등)을 임의로 바꾼 내용까지 모두 저장할 수 있습니다. CustomSaveDocument 이벤트를 핸들링하여 Save 동작 시 DB에 바이너리 데이터를 저장하도록 구현할 수 있습니다​
DOCS.DEVEXPRESS.COM
. 아래는 DiagramControl 내용을 데이터베이스에 저장하는 예시 코드입니다:
csharp
코드 복사
// DiagramControl CustomSaveDocument 이벤트 핸들러 (예: MainViewModel 또는 Code-behind에서)
private void OnCustomSaveDocument(object sender, DiagramCustomSaveDocumentEventArgs e) {
    using(var stream = new MemoryStream()) {
        diagramControl.SaveDocument(stream);
        byte[] diagramBytes = stream.ToArray();
        // 예: DB의 DiagramLayouts 테이블에 {LayoutName, Data}로 저장
        database.SaveDiagram("MainLayout", diagramBytes);
    }
    e.Handled = true;  // 기본 저장 로직 중단
}
DOCS.DEVEXPRESS.COM
 이처럼 DiagramControl의 SaveDocument 메서드로 다이어그램을 스트림(byte[])으로 뽑아내어 데이터베이스에 저장/갱신할 수 있습니다. 나중에 프로그램 시작 시 DB에서 이 데이터를 불러와 diagramControl.LoadDocument(stream)을 호출하면 사용자가 커스터마이즈한 배치와 모양을 복원할 수 있습니다. MainViewModel에서는 사용자가 로그인한 경우에만 수정 기능이 동작하도록, 모든 커맨드의 CanExecute나 UI 바인딩에 로그인 여부를 반영합니다. 예를 들어, IsLoggedIn == false이면 AddUserCommand, SaveUserDetailsCommand 등의 CanExecute를 false로 하거나, XAML에서 버튼의 IsEnabled="{Binding IsLoggedIn}" 식으로 제어합니다. DiagramControl도 읽기 전용 모드로 전환할 수 있는데, DevExpress WPF DiagramControl은 IsReadOnly 속성을 지원하여 다이어그램 전체를 편집 불가 상태로 만들 수 있습니다​
SUPPORTCENTER.DEVEXPRESS.COM
. 따라서 로그인하지 않은 사용자에게는 DiagramControl.IsReadOnly=true로 설정하여 드래그나 편집을 막고, 로그인 시 false로 풀어주면 됩니다. 실시간 동기화 로직: 이 시스템은 여러 사용자가 동시에 사용할 경우 데이터를 실시간 동기화하는 시나리오도 고려합니다. 기본적으로 MVVM 바인딩과 ObservableCollection으로 단일 클라이언트 내에서는 즉각적인 UI 반영이 이루어집니다. 예를 들어 한 사용자의 사물함 배정을 해제하면:
해당 LockerItem.UserId가 null로 변경되고 DB 업데이트
ViewModel의 SelectedUserLocker를 null로 설정 (OnPropertyChanged 발생)
Users 리스트의 해당 사용자에 대한 상태도 "미배정"으로 간주되어 IsIncomplete 속성이 true로 바뀜 (예: SelectedUser의 속성이나 Users 리스트의 아이템 속성 업데이트)
이러한 변경들은 모두 PropertyChanged 이벤트로 UI(Grid, TextBlock 등)에 실시간 반영됩니다.
다중 클라이언트 환경에서 실시간 동기화를 구현하려면 추가적인 메커니즘이 필요합니다. 한 방법으로, SQL Server의 Query Notification(SqlDependency) 기능을 이용하여 테이블 변경을 감지하고 WPF 애플리케이션에서 이벤트를 받아 데이터를 리프레시하는 방법이 있습니다. 또는 더 간단히, 일정 주기마다 DB를 폴링하여 변경 사항을 갱신하거나, SignalR 같은 실시간 통신을 통해 브로드캐스트하는 방법도 있습니다. 예를 들어, 새로운 배정이 이루어지면 서버에서 해당 정보를 브로드캐스트하여 다른 클라이언트의 ViewModel이 RefreshData()를 호출하게 할 수 있습니다. 이 구현은 인프라에 따라 다를 수 있으므로 설계로만 언급하면, Repository 계층에서 데이터를 읽을 때 마지막 업데이트 시각을 관리하거나, Event Aggregator 패턴으로 글로벌 이벤트(예: "LockerAssigned")를 발행하고 다른 뷰모델이 구독하여 처리하게 할 수 있습니다. 실시간 동기의 핵심은 동일한 데이터를 참조하는 여러 뷰모델/클라이언트의 상태 일관성입니다. 이를 위해:
각 데이터 변경 직후 DB 저장 -> 성공 시 관련 ObservableCollection이나 객체를 최신 데이터로 갱신.
다른 클라이언트에는 변경 이벤트를 통지 -> 해당 클라이언트는 자신의 데이터를 다시 로드 or 부분 갱신.
또는 애플리케이션이 하나의 인스턴스 내 여러 View를 갖는 경우 (예: 2개의 서로 다른 Grid에 같은 데이터 표시), ObservableCollection으로 공유하면 한쪽 변경 시 다른 쪽도 즉시 UI에 반영됩니다 (컬렉션이 INotifyCollectionChanged를 구현하므로)​
STACKOVERFLOW.COM
.
정리하면, MainViewModel은 로그인 검증, 사용자 및 항목 데이터 로드/갱신, 명령 실행 로직, Diagram 저장/복원 로직 등을 모두 포함하는 중심 역할을 합니다. 필요에 따라 뷰모델을 더 세분화할 수도 있습니다 (예: UserListViewModel, UserDetailViewModel, DiagramViewModel로 분리하고 MainViewModel이 이들을 조합). 하지만 여기서는 규모가 크지 않으므로 하나의 MainViewModel에서 관리합니다. 아래는 MainViewModel의 일부 주요 속성과 메서드 예제 (개념을 보여주기 위한 코드로, 실제 구현에서는 서비스 주입 등 고려):
csharp
코드 복사
public class MainViewModel : INotifyPropertyChanged {
    private IDataRepository dataRepo;  // DB 접근용 서비스 (주입 받는다고 가정)

    public ObservableCollection<User> Users { get; set; }
    public User SelectedUser { get; set; }

    public LockerItem SelectedUserLocker { get; set; }
    public ShoeItem SelectedUserShoe { get; set; }
    public LargeLockerItem SelectedUserLargeLocker { get; set; }

    public ObservableCollection<object> AllItems { get; set; }  // 모든 항목 (사물함+신발장+락커) - Diagram 바인딩용

    public bool IsLoggedIn { get; private set; }
    public event PropertyChangedEventHandler PropertyChanged;

    // 생성자
    public MainViewModel(IDataRepository repo) {
        this.dataRepo = repo;
        Users = new ObservableCollection<User>(dataRepo.GetAllUsers());
        AllItems = new ObservableCollection<object>();
        // 모든 항목 로드하여 AllItems 채우기
        foreach(var locker in dataRepo.GetAllLockers()) AllItems.Add(locker);
        foreach(var shoe in dataRepo.GetAllShoes()) AllItems.Add(shoe);
        foreach(var large in dataRepo.GetAllLargeLockers()) AllItems.Add(large);
        // PropertyChanged 이벤트 송신 간략 구현 생략...
    }

    // SelectedUser가 변경되었을 때 호출 (XAML에서 SelectedItem 바인딩 또는 PropertyChanged 트리거)
    private void OnSelectedUserChanged() {
        if (SelectedUser != null) {
            SelectedUserLocker = dataRepo.GetLockerByUser(SelectedUser.UserId);
            SelectedUserShoe = dataRepo.GetShoeByUser(SelectedUser.UserId);
            SelectedUserLargeLocker = dataRepo.GetLargeLockerByUser(SelectedUser.UserId);
            // 속성 변경 통지
            OnPropertyChanged(nameof(SelectedUserLocker));
            OnPropertyChanged(nameof(SelectedUserShoe));
            OnPropertyChanged(nameof(SelectedUserLargeLocker));
        }
    }

    // 명령 예: 신규 사용자 추가
    public ICommand AddUserCommand => new RelayCommand(AddUser, CanEdit);
    private void AddUser() {
        var newUser = new User {
            UserId = Guid.NewGuid(),
            Name = "(이름 없음)",
            KnoxId = "(임시)",
            Department = "",
            IsAdmin = false
        };
        dataRepo.AddUser(newUser);
        Users.Add(newUser);
    }
    private bool CanEdit() => IsLoggedIn;  // 로그인된 경우에만 실행 가능

    // 명령 예: 사물함 배정/변경
    public ICommand AssignLockerCommand => new RelayCommand(AssignLocker, CanEdit);
    private void AssignLocker() {
        if (SelectedUser == null) return;
        // 사용 가능한 사물함 중 하나 선택 (실제에선 UI로 선택받거나, 여기선 첫번째 사용가능 항목 예시)
        var freeLocker = dataRepo.GetAllLockers().FirstOrDefault(l => l.UserId == null);
        if (freeLocker != null) {
            freeLocker.UserId = SelectedUser.UserId;
            dataRepo.UpdateLocker(freeLocker);
            // ViewModel 데이터 갱신
            SelectedUserLocker = freeLocker;
            OnPropertyChanged(nameof(SelectedUserLocker));
            // Users 리스트에서 해당 사용자의 상태 색상도 업데이트 (IsIncomplete 속성 등 업데이트 후 OnPropertyChanged)
            SelectedUser.HasAllAssignments = CheckUserAssignments(SelectedUser);
            OnPropertyChanged(nameof(SelectedUser));
        }
    }

    // ... 기타 명령: RemoveLockerCommand, AssignShoeCommand 등 유사하게 구현 ...

    // Diagram 저장 명령 (사용자가 '레이아웃 저장' 버튼을 누른다고 가정)
    public ICommand SaveLayoutCommand => new RelayCommand(SaveDiagramLayout, CanEdit);
    private void SaveDiagramLayout() {
        // Approach 1: 개별 항목 좌표 업데이트
        foreach (var item in AllItems) {
            if (item is LockerItem locker) dataRepo.UpdateLocker(locker);
            if (item is ShoeItem shoe) dataRepo.UpdateShoe(shoe);
            // ...
        }
        // Approach 2: 다이어그램 전체 직렬화 (예시: DiagramControl 인스턴스를 코드비하인드 통해 접근 가능하다고 가정)
        // byte[] diagramData = diagramControl.SaveDocumentToBytes();
        // dataRepo.SaveDiagramBytes("MainLayout", diagramData);
    }

    // 로그인 관련 함수
    public bool Login(string username, string password) {
        var user = dataRepo.GetUserByCredentials(username, password);
        if (user != null && user.IsAdmin) {
            IsLoggedIn = true;
            OnPropertyChanged(nameof(IsLoggedIn));
            return true;
        }
        return false;
    }

    // INotifyPropertyChanged 구현 메서드
    protected void OnPropertyChanged(string name) {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
위 코드에서, RelayCommand는 간단한 ICommand 구현체로서 CanExecute와 Execute를 람다로 받아 동작하는 커맨드 클래스입니다 (예: CommunityToolkit.Mvvm의 RelayCommand 또는 DevExpress.Mvvm의 DelegateCommand 등을 사용할 수 있습니다). CanEdit 메소드는 현재 사용자가 편집 권한이 있는지(IsLoggedIn) 판단하여, 로그인 여부에 따라 대부분의 쓰기 명령을 활성/비활성 시킵니다. 또한 Login 메소드는 username/password를 받아 데이터베이스에서 검증 후 IsLoggedIn을 true로 설정합니다. 보안상 비밀번호는 해시 검증해야 하나 여기서는 단순화했습니다. Login 성공 시 OnPropertyChanged(nameof(IsLoggedIn))가 발생하므로, UI 바인딩을 통해 편집 버튼 등이 활성화됩니다. 로그인 처리 흐름은 아래 로그인 및 권한 처리 흐름 섹션에서 자세히 설명합니다.
XAML UI 구현 (DevExpress Controls)
MainWindow.xaml은 위에서 설명한 레이아웃을 구현합니다. DevExpress WPF 라이브러리를 사용하므로, XAML에 필요한 XML 네임스페이스를 선언합니다 (주요 네임스페이스: xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core" (기본), xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid" (GridControl), xmlns:dxdiag="http://schemas.devexpress.com/winfx/2008/xaml/diagram" (DiagramControl), xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors" (편집 컨트롤) 등). 전체 레이아웃은 Grid 또는 DockPanel로 좌/우 분할하고, 우측은 다시 상단(세부정보 폼)과 하단(다이어그램)으로 분할합니다. 1. 좌측 사용자 목록 (GridControl):
xml
코드 복사
<!-- MainWindow.xaml의 일부 -->
<dxg:GridControl x:Name="userGrid" Grid.Column="0" AutoGenerateColumns="False" 
                 ItemsSource="{Binding Users}" SelectedItem="{Binding SelectedUser, Mode=TwoWay}" 
                 SelectionMode="Row">
    <dxg:GridControl.Columns>
        <dxg:GridColumn FieldName="Name" Header="성명" Width="*"/>
        <dxg:GridColumn FieldName="KnoxId" Header="Knox ID" Width="2*"/>
        <dxg:GridColumn FieldName="Department" Header="소속파트" Width="*"/>
        <!-- 사용자가 모든 항목 배정받았는지 여부를 나타내는 가상 컬럼 -->
        <dxg:GridColumn FieldName="HasAllAssignments" Header="완료" UnboundType="Boolean" Visible="False"/>
    </dxg:GridControl.Columns>
    <dxg:GridControl.View>
        <dxg:TableView Name="tableView"
                       ShowGroupPanel="False" AutoWidth="True" 
                       NavigationStyle="Row" AllowEditing="False"/>
    </dxg:GridControl.View>
    <!-- 행 스타일: 배정 미완료 사용자는 강조색 배경 -->
    <dxg:GridControl.RowStyle>
        <Style TargetType="dxg:RowControl">
            <Style.Triggers>
                <DataTrigger Binding="{Binding Row.HasAllAssignments}" Value="False">
                    <Setter Property="Background" Value="#FFFFE0" /> <!-- 연한 노랑 배경 -->
                </DataTrigger>
            </Style.Triggers>
        </Style>
    </dxg:GridControl.RowStyle>
</dxg:GridControl>
위 XAML에서는 GridControl에 Users 컬렉션을 바인딩하고, 선택된 행을 ViewModel의 SelectedUser와 연동했습니다. AutoGenerateColumns="False"로 수동 컬럼 정의를 했으며, Name, KnoxId, Department 등을 표시합니다. Conditional Formatting(조건부 서식) 대신 RowStyle + DataTrigger를 사용하여 특정 조건 시 행 배경색을 변경했습니다. 여기서는 User 모델에 HasAllAssignments (모든 항목 배정 완료 여부, bool 타입) 속성이 있다고 가정하고, 그것이 False일 때 (즉, 하나라도 미배정) 노란색 배경을 주도록 DataTrigger를 설정했습니다. DevExpress GridControl에서는 이처럼 데이터 바인딩을 통해 행의 속성에 따라 스타일을 지정할 수 있습니다​
DOCS.DEVEXPRESS.COM
. (DevExpress에서는 Conditional Formatting 기능으로도 구현 가능하며, MVVM 속성 기반으로 행 색을 바꾸는 것을 권장합니다​
SUPPORTCENTER.DEVEXPRESS.COM
.)
설명: 위 RowStyle에서 Row.HasAllAssignments 경로를 사용했는데, 이는 Row.DataContext가 User 객체임을 이용한 바인딩입니다. 또한 DevExpress가 제공하는 ColorToBrushConverter 등을 사용하면 ViewModel에서 Color 속성을 직접 제공하고 Brush로 변환하여 사용하는 방법도 있습니다​
DOCS.DEVEXPRESS.COM
. 본 구현에서는 단순히 배경을 고정 색으로 주었습니다.
미배정 사용자는 HasAllAssignments == False이므로 노란색으로 표시되어 관리자가 한눈에 식별할 수 있습니다. (완료 사용자는 기본 배경, 포커스/선택 시 DevExpress 테마 기본색) 2. 우측 상단 사용자 상세/배정 패널: 우측 상단에는 선택된 사용자 (SelectedUser)의 상세 정보와 보관함 배정 상태를 표시합니다. XAML로는 StackPanel이나 Grid를 이용해 필드를 배치합니다. 아래 예시는 간단히 StackPanel로 나열한 형태입니다:
xml
코드 복사
<Grid Grid.Column="1" Grid.Row="0" Margin="10" DataContext="{Binding SelectedUser}">
    <Grid.RowDefinitions>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
        <RowDefinition Height="Auto"/>
    </Grid.RowDefinitions>
    <!-- 사용자 기본 정보 -->
    <StackPanel Orientation="Horizontal" Grid.Row="0" Margin="0 0 0 10">
        <TextBlock Text="성명:" VerticalAlignment="Center"/>
        <dxe:TextEdit Text="{Binding Name, Mode=TwoWay}" Width="120" Margin="5,0" 
                      IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}"
                      NullText="이름 입력" />
        <TextBlock Text="  KnoxID:" VerticalAlignment="Center"/>
        <dxe:TextEdit Text="{Binding KnoxId, Mode=TwoWay}" Width="100" Margin="5,0"
                      IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}" />
        <!-- 저장 버튼 -->
        <dx:SimpleButton Content="저장" Margin="10,0,0,0" Command="{Binding DataContext.SaveUserDetailsCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                         IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}"/>
    </StackPanel>

    <!-- 사물함 배정 정보 -->
    <StackPanel Orientation="Horizontal" Grid.Row="1" VerticalAlignment="Center">
        <TextBlock Text="사물함:" VerticalAlignment="Center"/>
        <TextBlock Text="{Binding Path=DataContext.SelectedUserLocker.DisplayName, RelativeSource={RelativeSource AncestorType=Window}}" 
                   Width="60" Margin="5,0" />
        <TextBlock Text="{Binding Path=DataContext.SelectedUserLocker.Floor, RelativeSource={RelativeSource AncestorType=Window}, StringFormat=\{0\}층}" Margin="5,0"/>
        <TextBlock Text="{Binding Path=DataContext.SelectedUserLocker.Zone, RelativeSource={RelativeSource AncestorType=Window}, StringFormat=구역 \{0\}}" Margin="5,0"/>
        <dx:SimpleButton Content="변경" Command="{Binding DataContext.AssignLockerCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                         IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}" Margin="10,0,0,0"/>
        <dx:SimpleButton Content="해제" Command="{Binding DataContext.RemoveLockerCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                         IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}"
                         Margin="5,0,0,0"/>
    </StackPanel>

    <!-- 신발장 배정 정보 (유사 구조) -->
    <StackPanel Orientation="Horizontal" Grid.Row="2" VerticalAlignment="Center">
        <TextBlock Text="신발장:" VerticalAlignment="Center"/>
        <TextBlock Text="{Binding Path=DataContext.SelectedUserShoe.DisplayName, RelativeSource={RelativeSource AncestorType=Window}}" Width="60" Margin="5,0"/>
        <!-- ... Floor, Zone 등 표시 생략 ... -->
        <dx:SimpleButton Content="변경" Command="{Binding DataContext.AssignShoeCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                         IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}" Margin="10,0,0,0"/>
        <dx:SimpleButton Content="해제" Command="{Binding DataContext.RemoveShoeCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                         IsEnabled="{Binding DataContext.IsLoggedIn, RelativeSource={RelativeSource AncestorType=Window}}" Margin="5,0,0,0"/>
    </StackPanel>
    <!-- 락커 배정 정보도 같은 패턴으로 이어서 작성 -->
</Grid>
위 UI 조각에서는:
사용자 기본 정보: 선택된 사용자의 Name, KnoxId를 TextEdit으로 표시하고 Mode=TwoWay로 바인딩하여 편집 가능하게 했습니다. 다만 IsEnabled 바인딩을 통해 로그인한 경우에만 편집할 수 있게 했습니다. Save 버튼은 ViewModel의 SaveUserDetailsCommand에 연결되어, 누르면 변경 내용을 DB에 반영합니다.
사물함 배정 정보: 현재 배정된 사물함의 DisplayName, Floor, Zone 등을 TextBlock으로 보여줍니다. (만약 SelectedUserLocker가 null이면 바인딩 결과 빈 문자열이 나올 것입니다.) "변경" 버튼은 AssignLockerCommand와 연결되어, 새로운 사물함을 배정하는 로직을 실행합니다. "해제" 버튼은 RemoveLockerCommand와 연결되어, 현재 사물함 배정을 해제합니다. 이들 버튼도 로그인된 경우만 활성화됩니다. 신발장, 락커 항목도 동일한 패턴으로 배치합니다.
배정 변경 시 일반적으로 사용자에게 선택 UI가 필요합니다 (예: 변경 버튼 누르면 사용 가능한 사물함 목록을 보여주는 Dialog). DevExpress MVVM에서는 DXDialogService를 이용해 MVVM 방식으로 Dialog를 띄울 수 있습니다. 여기서는 지면상 생략하고, 간단히 Command에서 데이터 변경하는 것으로 가정했습니다. 3. 우측 하단 DiagramControl (배치도 다이어그램): DiagramControl은 DevExpress의 다이어그램 컴포넌트로, 시각적으로 도형을 배치하고 관계를 그릴 수 있습니다. 본 시스템에서는 전체 사물함/신발장/락커를 하나의 다이어그램에 표시하고, 색상으로 상태를 구분합니다. MVVM 패턴으로 DiagramControl을 사용하기 위해 DiagramDataBindingBehavior를 활용해 데이터 컬렉션으로부터 도형을 자동 생성합니다​
DOCS.DEVEXPRESS.COM
. 예를 들어, MainViewModel의 AllItems (모든 보관함 아이템의 리스트) 컬렉션을 ItemsSource로 지정하고, 각 항목의 속성을 도형의 표시 내용과 위치 등에 바인딩할 수 있습니다.
xml
코드 복사
<dxdiag:DiagramControl x:Name="lockerDiagram" Grid.Column="1" Grid.Row="1"
                       Height="300" Background="#FFF" 
                       SelectedStencils="BasicShapes" 
                       IsReadOnly="{Binding IsLoggedIn, Converter={StaticResource NegateBoolConverter}}">
    <!-- ItemsSource를 뷰모델의 AllItems에 바인딩하고, Node 템플릿 정의 -->
    <dxdiag:DiagramControl.Behaviors>
        <dxdiag:DiagramDataBindingBehavior ItemsSource="{Binding AllItems}" 
                                          KeyMember="LockerId"  <!-- 각 도형을 식별할 키 (고유) -->
                                          LayoutKind="Off"      <!-- 자동 레이아웃 끄기 (수동 배치) -->
                                          ConnectorFromMember="" ConnectorToMember="">
            <dxdiag:DiagramDataBindingBehavior.NodeTemplate>
                <DataTemplate>
                    <!-- 각 항목을 표현할 도형 템플릿 -->
                    <dxdiag:DiagramShape Width="40" Height="30"
                                          StrokeId="Black" StrokeThickness="1">
                        <dxdiag:DiagramShape.Bindings>
                            <!-- 도형 내용: 항목 이름 표시 -->
                            <dxdiag:DiagramBinding PropertyName="Content" 
                                                   Expression="DisplayName" />
                            <!-- 도형 위치: 데이터의 PositionX/PositionY 사용 -->
                            <dxdiag:DiagramBinding PropertyName="X" Expression="PositionX" />
                            <dxdiag:DiagramBinding PropertyName="Y" Expression="PositionY" />
                            <!-- 도형 배경색: 항목 상태에 따라 색상 문자열을 모델에서 제공 -->
                            <dxdiag:DiagramBinding PropertyName="Background" Expression="Color" />
                        </dxdiag:DiagramShape.Bindings>
                    </dxdiag:DiagramShape>
                </DataTemplate>
            </dxdiag:DiagramDataBindingBehavior.NodeTemplate>
        </dxdiag:DiagramDataBindingBehavior>
    </dxdiag:DiagramControl.Behaviors>
</dxdiag:DiagramControl>
위 XAML에서, DiagramDataBindingBehavior를 설정하여 ItemsSource를 {Binding AllItems}로 지정했습니다. KeyMember는 각 아이템을 유일하게 식별할 속성명을 지정하는데, 사물함과 신발장, 락커 아이디 체계가 다를 수 있으므로 공통으로 쓸 수 있는 식별자가 있다면 쓰고, 없으면 단일 테이블일 때처럼 처리하거나, 여기서는 LockerId를 임의로 썼습니다. (각 타입별로 키가 다르다면, AllItems를 object로 받을 경우 KeyMember를 일관되게 쓰기 어렵습니다. 이럴 땐 모든 항목 모델에 공통 인터페이스 (예: IItem with Id 프로퍼티) 구현하거나, 통합 ID를 할당하는 방법도 고려합니다.) NodeTemplate DataTemplate 내에서 <dxdiag:DiagramShape>를 정의했습니다. DiagramShape의 Bindings 섹션을 통해:
Content 속성을 데이터의 DisplayName으로 설정​
GITHUB.COM
.
X, Y 속성을 데이터의 PositionX, PositionY로 바인딩하여 초기 위치를 설정합니다.
Background 속성을 데이터의 Color 속성값으로 바인딩하여 색상을 지정합니다. (예: Color 문자열을 "#RRGGBB" 형태로 저장해두고 바인딩하거나, DevExpress의 ColorToBrushConverter를 이용)
이렇게 설정하면 프로그램 실행 시 AllItems의 각 항목마다 하나의 도형이 DiagramControl에 생성됩니다. **LayoutKind="Off"**와 CustomLayoutItems 등을 통해 DevExpress의 자동 레이아웃을 끄고, 우리가 제공한 X,Y 위치를 사용하게 합니다. 사용자가 Diagram 상에서 도형을 드래그로 옮기면, DiagramControl은 내부적으로 그 Shape의 X,Y 값을 변경합니다. 그러나 이 변경이 자동으로 데이터 소스(AllItems)의 PositionX/Y에 반영되지는 않습니다. DiagramDataBindingBehavior는 현재 one-way로 초기 바인딩만 한 상태입니다. 이를 two-way로 반영하려면, DevExpress에서 제공하는 Diagram 이벤트를 이용해야 합니다. 한 가지 방법은 DiagramControl.ItemPositionChanged 이벤트를 이용하는 것입니다. 사용자가 도형을 옮길 때마다 해당 이벤트에서:
이동된 DiagramShape 객체와 연결된 데이터 항목(e.Item.DataContext 또는 e.Item.Tag 등으로 접근 가능)을 얻습니다.
그 데이터 항목의 PositionX, PositionY 속성을 DiagramShape의 새 위치로 업데이트하고, DB에도 바로 반영하거나 SaveLayout시 반영하도록 표시합니다.
Pseudo-code (이벤트 핸들러, code-behind 혹은 MVVM Behavior 활용):
csharp
코드 복사
private void Diagram_ItemPositionChanged(object sender, DiagramItemPositionChangedEventArgs e) {
    if(e.Item is DiagramShape shape && shape.DataContext is LockerItem item) {
        item.PositionX = shape.Position.X;
        item.PositionY = shape.Position.Y;
        // item.OnPropertyChanged("PositionX"), OnPropertyChanged("PositionY") 호출하여 binding에 알림
        // (INotifyPropertyChanged 구현으로 자동 통지됨)
    }
}
이렇게 하면 사용자가 임의 배치 변경한 좌표가 즉시 해당 Item 객체에 반영됩니다. IsLoggedIn이 false일 경우 DiagramControl 자체를 IsReadOnly로 설정했으므로 이런 이벤트는 발생하지 않고, ReadOnly 모드에서는 사용자가 드래그할 수 없습니다​
SUPPORTCENTER.DEVEXPRESS.COM
. DiagramControl의 색상 표기에 대해서는, 미리 각 항목의 Color 속성을 계산해두어 바인딩하는 방법을 썼습니다. 예를 들어, ViewModel에서 SelectedUser가 바뀔 때 AllItems의 각 객체에 대해:
if(item.UserId == null) item.Color = "#CCCCCC"; (빈 항목은 회색)
else if(selectedUser != null && item.UserId == selectedUser.UserId) item.Color = "#FF0000"; (선택 사용자 자신의 사물함이면 빨강)
else if(selectedUser != null && item.Department == selectedUser.Department) item.Color = "#87CEFA"; (선택 사용자와 같은 부서의 다른 사람이 쓰는 항목이면 파랑 등)
else item.Color = "#FFFFFF"; (그 외는 흰색 등 기본)
이런 로직으로 색상을 정해주면 DiagramShape.Background에 바인딩된 Color 값이 자동 적용됩니다. DevExpress DiagramControl은 Content나 Background 등을 데이터 바인딩으로 지정할 수 있음을 문서에서 밝히고 있습니다​
GITHUB.COM
. 권한에 따른 동작: DiagramControl의 IsReadOnly 속성을 바인딩한 부분을 보면, {Binding IsLoggedIn, Converter={StaticResource NegateBoolConverter}}로 설정했습니다. 즉, 로그인되어 있으면 IsReadOnly=false, 로그인 안 되었으면 true로 만들어 전체 다이어그램을 읽기 전용으로 만듭니다. (NegateBoolConverter는 bool 값을 반전시키는 간단한 컨버터) 이렇게 하면 비로그인 사용자는 도형을 클릭/이동/편집할 수 없고 오직 조회만 가능하게 됩니다​
SUPPORTCENTER.DEVEXPRESS.COM
. 또, TableView.AllowEditing 등을 false로 설정해 이미 Grid나 TextEdit 등도 읽기 전용으로 처리했습니다. 마지막으로, UI에 로그인 대화창 및 신규 사용자 추가 버튼 등을 추가해야 합니다:
로그인 창 (LoginWindow.xaml)은 간단한 Window로 Username/Password 입력 필드와 로그인 버튼, 그리고 MainViewModel.Login(command) 호출을 수행합니다. 로그인 성공 시 MainWindow의 ViewModel.IsLoggedIn이 true로 바뀌고, LoginWindow는 닫힙니다. (LoginWindow는 App 시작 시 Modal로 띄우거나, MainWindow에서 IsLoggedIn이 false이면 반투명 오버레이+로그인 패널을 띄우는 식으로 UI 구성 가능)
MainWindow 상단이나 적절한 위치에 "신규 사용자 등록" 버튼을 배치하고 Command=AddUserCommand로 연결합니다. 이 버튼도 IsLoggedIn=false이면 비활성화되어야 합니다. 예:
xml
코드 복사
<dx:SimpleButton Content="신규 사용자 추가" Command="{Binding AddUserCommand}" 
                 IsEnabled="{Binding IsLoggedIn}" HorizontalAlignment="Right" Margin="5"/>
클릭 시 새 User를 만들어 리스트에 추가하고 DB에 저장하며, GridControl은 ObservableCollection 바인딩을 통해 자동 갱신됩니다.
로그인 및 권한 처리 흐름
이 시스템에는 로그인 기능과 사용자별 권한이 적용됩니다. 구현 흐름은 다음과 같습니다:
앱 시작 시 로그인 요구: 앱이 실행되면 LoginWindow를 띄워 관리자로부터 아이디/비밀번호 입력을 받습니다. (만약 뷰와 로직을 분리하려면 LoginViewModel을 사용하여 검증 로직을 넣습니다.) 성공적으로 인증되면 IsLoggedIn 플래그를 true로 설정하고 LoginWindow를 닫은 뒤 MainWindow를 표시합니다. 실패하면 오류 메시지를 표시하고 재시도하게 합니다.
인증 방법은 간단히 Users 테이블의 IsAdmin 사용자를 대상으로 아이디/패스워드를 검사하거나, 별도의 Admins 테이블을 둘 수도 있습니다. 여기서는 Users 자체를 계정으로 간주하고 KnoxID를 username처럼, 별도 Password 필드로 비밀번호를 관리한다고 가정할 수 있습니다.
비밀번호는 반드시 해시로 저장하고 검사해야 하지만, 설명 간략화를 위해 논외로 합니다.
MainWindow 표시 및 권한에 따른 UI 초기화: MainWindow가 로드될 때, ViewModel.IsLoggedIn 값을 확인하여 편집 기능 UI 요소를 설정합니다. 만약 비로그인 모드로 MainWindow를 표시해야 한다면 (예: 읽기 전용 조회 허용), 로그인하지 않은 상태에서도 MainWindow를 열 수 있습니다. 그런 경우 IsLoggedIn=false로 ViewModel이 초기화되며, UI에서 편집 관련 컨트롤이 전부 비활성화됩니다.
예를 들어, GridControl은 AllowEditing=false로 되어 있어 행을 직접 편집 못 하고, Name/KnoxId TextEdit은 IsEnabled 바인딩으로 false, "저장", "변경", "해제", "신규 추가" 버튼들도 IsEnabled=false가 됩니다.
DiagramControl도 IsReadOnly=true로 설정되어 도형을 클릭해도 선택만 되고 움직이지 않으며, 편집 핸들이 나타나지 않습니다.
로그인 사용자 권한 부여: 로그인에 성공한 사용자는 (IsLoggedIn=true) 모든 편집/관리 기능 사용 가능으로 UI가 활성화됩니다. 이 때 MainViewModel은 선택적으로 로그인한 사용자의 정보를 따로 보관할 수 있습니다 (예: CurrentUser 프로퍼티). CurrentUser의 Role이나 IsAdmin을 확인하여 추가 세분화도 가능합니다.
만약 일반 사용자도 로그인하여 자기 정보만 보게 할 경우라면, 권한 레벨을 구분해야 합니다. 여기서는 시나리오 상 관리자만 로그인한다고 보고, 로그인=관리자 권한으로 가정했습니다. 만일 여러 등급이 필요하면 ViewModel에 권한 등급 필드를 두고, 각 명령의 CanExecute에서 해당 등급인지 확인하면 됩니다.
로그아웃 흐름: 필요하다면 로그아웃 버튼을 제공하여 사용자가 언제든 권한을 해제할 수 있습니다. 로그아웃 시 IsLoggedIn=false로 하고 편집중이던 내용은 취소하거나 저장을 유도한 뒤, 다시 LoginWindow를 띄웁니다. (혹은 MainWindow를 닫고 새로 여는 방식도 가능)
내부 구현 예시: LoginViewModel에서 LoginCommand가 실행되면 MainViewModel (혹은 중앙 AuthService)에 credential을 전달해 검증하고, 결과로 IsLoggedIn 설정 및 이벤트를 발생시킵니다. 예를 들어 StackOverflow의 한 MVVM 로그인 예시에서는 LoginViewModel이 모델(LoginModel)의 LoggedIn 상태를 true로 세팅하고 이벤트를 발생, MainViewModel이 이를 구독하여 뷰를 전환하는 방식으로 구현했습니다​
STACKOVERFLOW.COM
. 우리의 경우 단순하게 MainViewModel.Login 메소드를 호출하는 것으로 충분합니다. Login 성공 후 MainWindow가 사용자에게 보여질 때, 현재 로그인 사용자만 수정 가능하므로 UI가 그것을 반영합니다. 이 접근은 클라이언트 측 보호이므로, 추가로 서버/DB 측에서도 수정 명령에 대한 권한 검사를 해야 완전합니다. 예를 들어 dataRepo.UpdateLocker나 AddUser 등을 호출할 때 현재 사용자가 Admin인지 체크하거나, DB에 트리거/저장프로시저로 권한을 통제할 수 있습니다.
실시간 동기화 및 마무리
실시간 동기화를 위해, 만약 여러 사용자가 동시에 이 프로그램을 실행한다면, 한 사용자가 데이터 변경 시 다른 사용자 화면에 즉각 반영되도록 하는 추가 구현이 필요합니다. 간단한 방법으로, 특정 테이블에 변경이 생기면 신호를 보내는 메커니즘입니다. 예를 들어 .NET에서 SqlDependency를 사용하면 데이터베이스 테이블에 변경(Notification)이 발생할 때 애플리케이션에서 이벤트를 받는 것이 가능합니다. 이를 이용해, 하나의 클라이언트에서 변경을 커밋하면 DB에서 다른 구독중인 클라이언트들에게 알림을 보내 각자 Users나 AllItems 컬렉션을 재쿼리하도록 만들 수 있습니다. 이 과정은 다소 복잡하므로, 또 다른 대안으로는 SignalR 허브를 두어 서버 중앙에서 관리하고 각 클라이언트에 메시지를 브로드캐스트하는 것입니다. 예를 들어, 사물함 배정/해제가 발생하면 해당 SignalR 메시지를 수신한 클라이언트는 dataRepo.GetLockerByUser 등을 다시 호출하거나, 해당 LockerItem 객체만 업데이트합니다. MVVM 구조에서는 Observer 패턴을 활용해 ViewModel끼리도 메시지를 전달할 수 있습니다. DevExpress의 MVVM 프레임워크는 Messenger 서비스를 제공하며, Prism 같은 프레임워크도 EventAggregator를 제공합니다. 이런 것을 사용해도 무방합니다. 그러나 단일 사용자가 주로 쓴다면, 앞서 구현한 대로 ObservableCollection과 PropertyChanged 통지로 충분합니다. ObservableCollection은 컬렉션 변경 시 UI가 즉시 업데이트되고, DevExpress GridControl도 별도의 Refresh 호출 없이 UI를 갱신합니다​
STACKOVERFLOW.COM
. 마지막으로, 이 설계는 전문가 수준의 확장성을 고려했습니다. 데이터 무결성을 위해 트랜잭션 처리나 예외 상황 (예: 동시에 두 사람이 같은 사물함 배정 시도 -> 낙관적 락 혹은 비관적 락 전략)도 고려해야 합니다. 또한 Diagram 레이아웃 데이터는 용량이 커질 수 있으므로 별도 테이블로 관리하거나 BLOB 필드로 저장했고, 이진 데이터의 백업/복원도 신경써야 합니다. 지금까지 설명한 구조와 코드는 하나의 완성형 예시이며, 실제 구현에서는 보안, 성능 튜닝(예: 필요한 부분만 갱신), UI 디자인 등이 추가로 필요합니다. 하지만 기본 뼈대는:
MVVM을 통한 UI와 로직 분리
DevExpress GridControl & DiagramControl 활용
색상 및 조건부 서식으로 가시성 향상
DB 설계 원칙으로 변경에도 안정적인 키 유지
로그인/권한 체계 반영