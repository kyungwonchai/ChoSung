지를 누르면 실행 중이던 함수까지만 하고 멈추는 동작을 구현하려면, 현재 실행 중인 작업이 완료된 후에 작업이 더 이상 진행되지 않도록 하는 작업 취소와 유사한 구조를 추가해야 합니다.

구체적으로:

일시정지 버튼을 누르면, 현재 실행 중인 작업이 끝날 때까지 기다린 후, 다음 작업이 실행되지 않도록 설정합니다.
Resume 버튼을 누르면, 일시정지 상태를 해제하고 다음 작업을 이어서 실행합니다.
수정해야 할 부분:
TaskQueue.cs에서 Pause 메서드를 수정하여 현재 실행 중인 작업까지만 진행되도록 합니다.
TaskModel.cs에서 작업 상태가 일시정지되었을 때 다음 작업이 실행되지 않도록 하는 논리를 추가합니다.
1. TaskQueue.cs 수정
csharp
코드 복사
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;  // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;   // 작업이 일시정지 상태인지 여부

    public bool IsRunning => _isRunning;
    public bool IsPaused => _isPaused;

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        if (!_isRunning && !_isPaused)
        {
            RunNextTask();  // 현재 실행 중이 아니면 즉시 실행
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused)  // 큐에 작업이 없거나 일시정지 상태면 리턴
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;

        var task = _tasks.Dequeue();  // 작업 가져오기
        await task();  // 작업 실행

        _isRunning = false;

        // 다음 작업 실행 (일시정지 상태가 아니라면)
        if (!_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// 현재 작업이 완료된 후 다음 작업을 멈추도록 합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;  // 작업 일시정지 상태로 변경
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;  // 일시정지 해제
            if (!_isRunning)
            {
                RunNextTask();  // 작업이 실행 중이 아니면 다음 작업 실행
            }
        }
    }
}
2. TaskModel.cs 수정
TaskModel 클래스에서는 일시정지 후 작업을 다시 시작할 때 큐에 새로운 작업을 넣을 수 있도록 Resume 기능을 구현합니다.

csharp
코드 복사
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }
    public string Status { get; set; }
    public ICommand ResumeCommand { get; }  // 리쥼 커맨드

    private TaskQueue _taskQueue;

    public TaskModel(TaskQueue taskQueue)
    {
        _taskQueue = taskQueue;

        FunctionStatusList = new ObservableCollection<FunctionStatus>();
        Status = "Pending";

        // 각 함수 추가
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);

        ResumeCommand = new RelayCommand(StartTask);
    }

    /// <summary>
    /// 작업을 실행합니다. 
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        _taskQueue.EnqueueTask(ExecuteTaskSequence);  // 작업을 큐에 추가
    }

    /// <summary>
    /// 시퀀스 작업을 실행합니다.
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            if (_taskQueue.IsPaused)  // 작업 도중에 일시정지가 된 경우 멈춤
            {
                Status = "Paused";
                return;
            }

            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);
        }

        Status = "Completed";
    }

    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 진행 중 색상 변경
        });

        await task();  // 비동기 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 색상 변경
        });
    }

    private async Task ExecuteTaskA() { await Task.Delay(1000); }
    private async Task ExecuteTaskB() { await Task.Delay(1000); }
    private async Task ExecuteTaskC() { await Task.Delay(1000); }

    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);
    }
}
어디를 수정해야 할지 요약:
**TaskQueue.cs**에서 **RunNextTask()**가 일시정지 중에는 다음 작업을 실행하지 않도록 수정되었습니다. 즉, 현재 작업이 완료된 후에만 멈춥니다.
**TaskModel.cs**에서 ExecuteTaskSequence() 내에서 작업을 실행하는 동안 **_taskQueue.IsPaused**를 체크하여 중간에 멈출 수 있게 하였습니다.
이 코드를 사용하면 일시정지를 눌렀을 때 실행 중인 작업만 완료되고 그 이후 작업은 실행되지 않습니다. Resume을 누르면 다시 중단된 작업 이후로 이어서 실행됩니다.