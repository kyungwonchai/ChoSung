알겠습니다. "A second operation started on this context..." 또는 "열린 연결을 먼저 닫아야 합니다" 오류가 MARS 옵션 추가 후에도 계속 발생하고, RollbackChanges 관련 컴파일 오류도 여전하다면, ViewModel 간에 DbContext를 공유하면서 발생하는 비동기 작업 충돌 문제일 가능성이 매우 높습니다.

가장 확실한 해결 방법은 각 ViewModel이 독립적인 DbContext 인스턴스를 사용하도록 변경하는 것입니다. 이렇게 하면 한 ViewModel의 작업이 다른 ViewModel의 DbContext 사용에 영향을 주지 않아 연결 충돌 오류를 근본적으로 방지할 수 있습니다.

또한, RollbackChanges 메서드의 매개변수 타입을 다시 IEnumerable<DbEntityEntry>로 되돌리고, 호출하는 부분에서 .ToList()를 사용하는 원래의 방식으로 시도해 보겠습니다. 컴파일러 오류가 지속된다면 다른 문제가 있을 수 있지만, 이 방식이 타입상으로는 더 정확합니다.

수정해야 할 파일 목록:

ViewModels/MainViewModel.cs
ViewModels/MasterDataViewModel.cs
ViewModels/LogViewModel.cs
Views/MainWindow.xaml.cs (ViewModel Dispose 호출 확인)
아래에 이 파일들의 수정된 전체 코드를 작성합니다.

1. ViewModels/MainViewModel.cs (수정)

MasterDataViewModel, LogViewModel 생성 시 DbContext를 전달하지 않습니다.
IDisposable은 자신의 _context만 관리합니다.
RollbackChanges 호출 시 .ToList() 사용을 다시 확인합니다.
C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (.NET Framework 4.8 - DbContext 분리)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        // MainViewModel이 직접 사용하는 DbContext
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";

        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;

        // 콤보박스용 마스터 데이터 목록 (MainViewModel이 직접 로드 및 관리)
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;

        // 자식 ViewModel 인스턴스 (이제 DbContext를 공유하지 않음)
        public MasterDataViewModel MasterDataVM { get; private set; }
        public LogViewModel LogVM { get; private set; }

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } // 자신의 DbContext 생성
            catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>();
            _allFloors = new ObservableCollection<Floor>();
            _allZones = new ObservableCollection<Zone>();
            _allSubParts = new ObservableCollection<SubPart>();
            _allAdministrators = new ObservableCollection<Administrator>();

            // 자식 ViewModel 생성 (DbContext 전달 안 함)
            MasterDataVM = new MasterDataViewModel(); // 이제 각자 DbContext 생성
            LogVM = new LogViewModel();             // 이제 각자 DbContext 생성

            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync()); // 콤보박스용 목록 새로고침

            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private async Task LoadInitialDataAsync() { await LoadMasterDataAsync(); await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync()
        {
            if (_context == null) return; StatusBarText = "사물함 목록 로딩 중..."; try { var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(); LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; } catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); }
        }
        private async Task LoadMasterDataAsync()
        {
            // 이 메서드는 이제 MainViewModel의 콤보박스에 필요한 목록만 로드합니다.
            if (_context == null) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; try { AllLockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync()); AllFloors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync()); AllZones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync()); AllSubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync()); AllAdministrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync()); StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); }
        }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; StatusBarText = "마스터 모드 활성화."; MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync()
        {
             if (_context == null) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); }
        }

        /// <summary>
        /// EF6에서 변경 사항 롤백 (간단 버전)
        /// </summary>
        /// <param name="changedEntries">롤백할 엔티티 목록 (IEnumerable<DbEntityEntry> 타입)</param>
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) // *** 매개변수 타입을 다시 IEnumerable<DbEntityEntry>로 ***
        {
            if (_context == null || changedEntries == null) return;
            // ToList()를 호출하여 안전하게 반복 처리
            foreach (var entry in changedEntries.ToList())
            {
                switch (entry.State)
                {
                    case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break;
                    case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break;
                    case EntityState.Deleted: entry.State = EntityState.Unchanged; break;
                }
            }
             StatusBarText = "변경 사항이 롤백되었습니다.";
        }

        private void AddNewLocker(object parameter) { if (_context == null) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Helper Methods
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (자신의 DbContext 해제)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
 1 2. ViewModels/MasterDataViewModel.cs (수정)   
1.
github.com
github.com

생성자에서 DbContext를 전달받는 대신 직접 생성합니다.
IDisposable 인터페이스를 구현하여 자신의 DbContext를 해제합니다.
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (DbContext 자체 생성 및 관리)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable // IDisposable 구현
    {
        private readonly LockerDbContext _context; // 이 ViewModel 전용 DbContext

        #region Observable Collections & Properties (이전과 동일)
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) ((RelayCommand)DeleteItemCommand).RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        #endregion

        #region Commands (이전과 동일)
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        /// <summary>
        /// MasterDataViewModel 생성자 (DbContext 직접 생성)
        /// </summary>
        public MasterDataViewModel() // DbContext 매개변수 제거
        {
            try
            {
                _context = new LockerDbContext(); // 자신의 DbContext 생성
            }
            catch (Exception ex)
            {
                 MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 StatusMessage = "[MasterData] DB 연결 오류!";
                 // 오류 발생 시 컬렉션 초기화만 수행
                 LockerTypes = new ObservableCollection<LockerType>();
                 Floors = new ObservableCollection<Floor>();
                 Zones = new ObservableCollection<Zone>();
                 SubParts = new ObservableCollection<SubPart>();
                 Administrators = new ObservableCollection<Administrator>();
                 // Command는 비활성화되거나 오류 처리 로직 추가 필요
                 LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); // 예: 비활성화
                 AddItemCommand = new RelayCommand(_ => { }, _ => false);
                 DeleteItemCommand = new RelayCommand(_ => { }, _ => false);
                 SaveChangesCommand = new RelayCommand(_ => { }, _ => false);
                 return; // 초기화 중단
            }


            LockerTypes = new ObservableCollection<LockerType>();
            Floors = new ObservableCollection<Floor>();
            Zones = new ObservableCollection<Zone>();
            SubParts = new ObservableCollection<SubPart>();
            Administrators = new ObservableCollection<Administrator>();

            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItem);
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItem);
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync());

            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods (내부 _context 사용)
        public async Task LoadAllMasterDataAsync() { if (_context == null) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private bool CanAddItem(object parameter) => _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private void AddItem(object parameter) { if (_context == null) return; if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private bool CanDeleteItem(object parameter) => _context != null && SelectedItem != null;
        private void DeleteItem(object parameter) { if (_context == null || SelectedItem == null) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { if (SelectedItem is LockerType lt) { _context.Entry(lt).State = EntityState.Deleted; LockerTypes.Remove(lt); } else if (SelectedItem is Floor f) { _context.Entry(f).State = EntityState.Deleted; Floors.Remove(f); } else if (SelectedItem is Zone z) { _context.Entry(z).State = EntityState.Deleted; Zones.Remove(z); } else if (SelectedItem is SubPart sp) { _context.Entry(sp).State = EntityState.Deleted; SubParts.Remove(sp); } else if (SelectedItem is Administrator ad) { _context.Entry(ad).State = EntityState.Deleted; Administrators.Remove(ad); } else { return; } SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { System.Diagnostics.Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }
        private async Task SaveMasterDataChangesAsync() { if (_context == null) return; StatusMessage = "마스터 데이터 저장 중..."; using (var transaction = _context.Database.BeginTransaction()) { try { var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList(); foreach (var modified in modifiedNameEntries) { StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.Entry.Entity is LockerType) targetColumn = "LockerType"; else if (modified.Entry.Entity is Floor) targetColumn = "Floor"; else if (modified.Entry.Entity is Zone) targetColumn = "Zone"; else if (modified.Entry.Entity is SubPart) targetColumn = "SubPart"; else if (modified.Entry.Entity is Administrator) targetColumn = "Administrator"; if (!string.IsNullOrEmpty(targetColumn)) { updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}"; updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; System.Diagnostics.Debug.WriteLine($"Executed: {updateSql} with params '{modified.CurrentName}', '{modified.OriginalName}'. Rows: {updatedCount}"); } } int masterDataChanges = await _context.SaveChangesAsync(); transaction.Commit(); StatusMessage = $"마스터 데이터 저장 완료 ({masterDataChanges}건)."; } catch (Exception ex) { transaction.Rollback(); StatusMessage = $"마스터 데이터 저장 오류: {ex.Message}"; MessageBox.Show($"{StatusMessage}\n\n{ex.ToString()}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error); var errorEntries = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged && e.State != EntityState.Detached); foreach (var entry in errorEntries.ToList()) { try { entry.Reload(); } catch { entry.State = EntityState.Detached; } } } } await LoadAllMasterDataAsync(); }
        #endregion

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } } // 자신의 DbContext 해제
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. ViewModels/LogViewModel.cs (수정)

생성자에서 DbContext를 전달받는 대신 직접 생성합니다.
IDisposable 인터페이스를 구현하여 자신의 DbContext를 해제합니다.
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 감사 로그 조회 ViewModel (DbContext 자체 생성 및 관리)
    /// </summary>
    public class LogViewModel : ViewModelBase, IDisposable // IDisposable 구현
    {
        private readonly LockerDbContext _context; // 이 ViewModel 전용 DbContext
        public ObservableCollection<AuditLog> AuditLogs { get; set; }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        /// <summary>
        /// LogViewModel 생성자 (DbContext 직접 생성)
        /// </summary>
        public LogViewModel() // DbContext 매개변수 제거
        {
            try
            {
                _context = new LockerDbContext(); // 자신의 DbContext 생성
            }
            catch (Exception ex)
            {
                 MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 StatusMessage = "[Log] DB 연결 오류!";
                 AuditLogs = new ObservableCollection<AuditLog>(); // 빈 컬렉션
                 LoadLogsCommand = new RelayCommand(_ => { }, _ => false); // 비활성화
                 return; // 초기화 중단
            }

            AuditLogs = new ObservableCollection<AuditLog>();
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync());

            if (_context != null) { _ = LoadLogsAsync(); }
        }

        /// <summary>
        /// 감사 로그를 비동기적으로 로드합니다. (내부 _context 사용)
        /// </summary>
        public async Task LoadLogsAsync()
        {
            if (_context == null) return;
            StatusMessage = "로그 로딩 중...";
            try
            {
                var logs = await _context.AuditLogs
                                         .OrderByDescending(log => log.Timestamp)
                                         .Take(1000) // 성능 위해 제한
                                         .AsNoTracking() // 읽기 전용이므로 추적 불필요
                                         .ToListAsync();
                AuditLogs.Clear();
                logs.ForEach(AuditLogs.Add);
                StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
            }
            catch (Exception ex)
            {
                StatusMessage = $"로그 로딩 오류: {ex.Message}";
                MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } } // 자신의 DbContext 해제
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
4. Views/MainWindow.xaml.cs (수정)

Closing 이벤트에서 MainViewModel의 Dispose만 호출하도록 유지합니다. (각 자식 ViewModel은 스스로 Dispose를 관리)
C#

using DevExpress.Xpf.Core;
using LockerManagementApp.ViewModels;
using System;
using System.ComponentModel;
using System.Windows;

namespace LockerManagementApp.Views
{
    public partial class MainWindow : ThemedWindow
    {
        public MainWindow()
        {
            InitializeComponent();
            // ApplicationThemeHelper.ApplicationThemeName = Theme.Office2019ColorfulName;
        }

        // DataContext를 MainViewModel 타입으로 캐스팅
        private MainViewModel ViewModel => DataContext as MainViewModel;

        private void MainWindow_Loaded(object sender, RoutedEventArgs e) { }

        // 창이 닫힐 때 MainViewModel의 Dispose를 호출하여 해당 ViewModel의 DbContext 정리
        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            // MasterDataViewModel과 LogViewModel은 이제 스스로 Dispose를 관리합니다.
            // MainViewModel의 Dispose만 호출하여 MainViewModel이 사용하는 리소스를 정리합니다.
            if (ViewModel is IDisposable disposableViewModel)
            {
                disposableViewModel.Dispose();
            }
        }
    }
}
핵심 변경 사항:

각 주요 ViewModel (MainViewModel, MasterDataViewModel, LogViewModel)이 자신만의 LockerDbContext 인스턴스를 생성하고 IDisposable을 통해 관리합니다.
MainViewModel은 더 이상 자식 ViewModel에게 DbContext를 전달하지 않습니다.
MainViewModel의 LoadMasterDataAsync는 이제 메인 화면의 콤보박스에 필요한 목록만 로드합니다.
RollbackChanges 메서드의 매개변수 타입을 다시 IEnumerable<DbEntityEntry>로 변경하고, 호출하는 쪽에서 .ToList()를 사용하도록 수정했습니다 (CS1503 오류 해결 재시도).
중요 확인 사항:

App.config 연결 문자열: MultipleActiveResultSets=True; 옵션이 여전히 있는지 확인하세요. 비록 컨텍스트를 분리했지만, 만약 한 ViewModel 내에서라도 복잡한 동시 작업이 발생할 경우 도움이 될 수 있습니다.
이제 각 ViewModel이 독립적인 DbContext를 사용하므로, "second operation started" 또는 "열린 연결..." 과 같은 동시성 오류는 발생하지 않아야 합니다. 이 변경으로 인해 콤보박스 문제도 해결될 가능성이 높습니다.