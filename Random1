/ 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views; // MasterDataWindow 참조 위해 추가
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (마스터 데이터 관리 창 열기 기능 추가)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context; // MainViewModel에서 직접 사용하는 DbContext (사물함 관리용)
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";

        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false; // 마스터 데이터 관리 버튼 표시 여부

        // 콤보박스용 마스터 데이터 목록
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;

        // 자식 ViewModel 제거 (LogViewModel도 제거 - 필요 시 다시 추가)
        // public MasterDataViewModel MasterDataVM { get; private set; }
        // public LogViewModel LogVM { get; private set; }

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); } // 버튼 Visibility 바인딩용
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; } // 사물함 목록 저장용
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; } // 콤보박스 목록 새로고침용
        public ICommand OpenMasterDataWindowCommand { get; } // *** 신규 커맨드 ***
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>();
            _allFloors = new ObservableCollection<Floor>();
            _allZones = new ObservableCollection<Zone>();
            _allSubParts = new ObservableCollection<SubPart>();
            _allAdministrators = new ObservableCollection<Administrator>();

            // 자식 ViewModel 생성 제거
            // MasterDataVM = new MasterDataViewModel();
            // LogVM = new LogViewModel();

            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync());
            // *** 신규 커맨드 초기화 ***
            OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow);

            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        // --- 데이터 로딩 메서드 (이전과 동일) ---
        private async Task LoadInitialDataAsync() { await LoadMasterDataAsync(); await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null) return; StatusBarText = "사물함 목록 로딩 중..."; try { var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(); LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; } catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (_context == null) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; try { AllLockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync()); AllFloors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync()); AllZones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync()); AllSubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync()); AllAdministrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync()); StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); } }

        /// <summary>
        /// 마스터 키 비밀번호 확인 로직 (IsMasterModeEnabled 설정)
        /// </summary>
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; /* 상태 변경 */ MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; /* 상태 변경 */ MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        /// <summary>
        /// 마스터 데이터 관리 창을 여는 메서드
        /// </summary>
        private void OpenMasterDataWindow(object parameter)
        {
            try
            {
                // 새 MasterDataViewModel 인스턴스 생성 (자체 DbContext 사용)
                var masterDataVM = new MasterDataViewModel();

                // 새 MasterDataWindow 생성
                var masterDataWindow = new MasterDataWindow
                {
                    DataContext = masterDataVM, // ViewModel을 DataContext로 설정
                    Owner = Application.Current.MainWindow // 부모 창 설정 (선택 사항)
                };

                // 모달 대화 상자로 창 표시
                masterDataWindow.ShowDialog();

                // 마스터 데이터 창이 닫힌 후, 메인 윈도우의 콤보박스 목록 새로고침
                // (마스터 데이터가 변경되었을 수 있으므로)
                _ = LoadMasterDataAsync();

                // MasterDataViewModel 리소스 정리 (IDisposable 구현 시)
                masterDataVM.Dispose(); // 명시적 호출 또는 Window의 Closing 이벤트에서 처리
            }
            catch (Exception ex)
            {
                MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }


        #region CRUD 및 기타 메서드 (이전과 동일 - 자신의 _context 사용)
        private async Task SaveChangesAsync() { if (_context == null) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Helper Methods
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (자신의 DbContext 해제)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); /* 자식 VM Dispose 제거 */ } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. Views/MasterDataWindow.xaml (신규 파일)

이 파일은 Views 폴더에 새로 만들어야 합니다. 내용은 이전에 MainWindow.xaml의 "마스터 데이터 관리" 탭에 있던 UI 요소들을 가져옵니다. 버튼 등의 IsEnabled 바인딩은 제거합니다 (이 창은 마스터 모드일 때만 열리므로 항상 활성화).

XML

<dx:ThemedWindow
    x:Class="LockerManagementApp.Views.MasterDataWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
    xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
    xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
    xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
    xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
    xmlns:dxlc="http://schemas.devexpress.com/winfx/2008/xaml/layoutcontrol"
    xmlns:viewmodels="clr-namespace:LockerManagementApp.ViewModels"
    xmlns:models="clr-namespace:LockerManagementApp.Models"
    mc:Ignorable="d"
    Title="마스터 데이터 관리" Height="600" Width="800"
    WindowStartupLocation="CenterOwner" ShowInTaskbar="False"
    Closing="MasterDataWindow_Closing">
    <Grid Margin="5">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,5">
            <Button Content="💾 변경 사항 저장" Command="{Binding SaveChangesCommand}" Margin="3"/>
            <Button Content="🔄 목록 새로고침" Command="{Binding LoadAllMasterDataCommand}" Margin="3"/>
            <TextBlock Text="{Binding StatusMessage}" Margin="10,0,0,0" VerticalAlignment="Center" Foreground="Gray"/>
        </StackPanel>

        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
            <dxlc:LayoutControl Orientation="Vertical">
                <dxlc:LayoutGroup Header="사물함 종류" View="GroupBox" Orientation="Vertical" IsCollapsible="True" IsCollapsed="False">
                    <StackPanel Orientation="Horizontal" Margin="0,0,0,5">
                        <Button Content="종류 추가" Command="{Binding AddItemCommand}" CommandParameter="LockerType" Margin="0,0,5,0"/>
                        <Button Content="선택 삭제" Command="{Binding DeleteItemCommand}"/>
                    </StackPanel>
                    <dxg:GridControl ItemsSource="{Binding LockerTypes}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}" Height="150" MaxHeight="200">
                        <dxg:GridControl.View>
                            <dxg:TableView AllowEditing="True" NewItemRowPosition="None"/>
                        </dxg:GridControl.View>
                        <dxg:GridControl.Columns> <dxg:GridColumn FieldName="Name" Header="종류 이름"/> </dxg:GridControl.Columns>
                    </dxg:GridControl>
                </dxlc:LayoutGroup>

                <dxlc:LayoutGroup Header="층" View="GroupBox" Orientation="Vertical" IsCollapsible="True" IsCollapsed="True">
                     <StackPanel Orientation="Horizontal" Margin="0,0,0,5"> <Button Content="층 추가" Command="{Binding AddItemCommand}" CommandParameter="Floor" Margin="0,0,5,0"/> <Button Content="선택 삭제" Command="{Binding DeleteItemCommand}" /> </StackPanel>
                     <dxg:GridControl ItemsSource="{Binding Floors}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}" Height="150" MaxHeight="200"> <dxg:GridControl.View><dxg:TableView AllowEditing="True" NewItemRowPosition="None"/></dxg:GridControl.View> <dxg:GridControl.Columns> <dxg:GridColumn FieldName="Name" Header="층 이름"/> </dxg:GridControl.Columns> </dxg:GridControl>
                </dxlc:LayoutGroup>

                <dxlc:LayoutGroup Header="구역" View="GroupBox" Orientation="Vertical" IsCollapsible="True" IsCollapsed="True">
                     <StackPanel Orientation="Horizontal" Margin="0,0,0,5"> <Button Content="구역 추가" Command="{Binding AddItemCommand}" CommandParameter="Zone" Margin="0,0,5,0"/> <Button Content="선택 삭제" Command="{Binding DeleteItemCommand}" /> </StackPanel>
                     <dxg:GridControl ItemsSource="{Binding Zones}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}" Height="150" MaxHeight="200"> <dxg:GridControl.View><dxg:TableView AllowEditing="True" NewItemRowPosition="None"/></dxg:GridControl.View> <dxg:GridControl.Columns> <dxg:GridColumn FieldName="Name" Header="구역 이름"/> </dxg:GridControl.Columns> </dxg:GridControl>
                </dxlc:LayoutGroup>

                <dxlc:LayoutGroup Header="소파트" View="GroupBox" Orientation="Vertical" IsCollapsible="True" IsCollapsed="True">
                     <StackPanel Orientation="Horizontal" Margin="0,0,0,5"> <Button Content="소파트 추가" Command="{Binding AddItemCommand}" CommandParameter="SubPart" Margin="0,0,5,0"/> <Button Content="선택 삭제" Command="{Binding DeleteItemCommand}" /> </StackPanel>
                     <dxg:GridControl ItemsSource="{Binding SubParts}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}" Height="150" MaxHeight="200"> <dxg:GridControl.View><dxg:TableView AllowEditing="True" NewItemRowPosition="None"/></dxg:GridControl.View> <dxg:GridControl.Columns> <dxg:GridColumn FieldName="Name" Header="소파트 이름"/> </dxg:GridControl.Columns> </dxg:GridControl>
                </dxlc:LayoutGroup>

                <dxlc:LayoutGroup Header="관리자" View="GroupBox" Orientation="Vertical" IsCollapsible="True" IsCollapsed="True">
                     <StackPanel Orientation="Horizontal" Margin="0,0,0,5"> <Button Content="관리자 추가" Command="{Binding AddItemCommand}" CommandParameter="Administrator" Margin="0,0,5,0"/> <Button Content="선택 삭제" Command="{Binding DeleteItemCommand}" /> </StackPanel>
                     <dxg:GridControl ItemsSource="{Binding Administrators}" SelectedItem="{Binding SelectedItem, Mode=TwoWay}" Height="150" MaxHeight="200"> <dxg:GridControl.View><dxg:TableView AllowEditing="True" NewItemRowPosition="None"/></dxg:GridControl.View> <dxg:GridControl.Columns> <dxg:GridColumn FieldName="Name" Header="관리자 이름"/> </dxg:GridControl.Columns> </dxg:GridControl>
                </dxlc:LayoutGroup>

            </dxlc:LayoutControl>
        </ScrollViewer>

        <Button Grid.Row="2" Content="닫기" Width="80" HorizontalAlignment="Right" Margin="0,10,0,0" Click="CloseButton_Click"/>

    </Grid>
</dx:ThemedWindow>
핵심 변경 사항 요약:

ViewModel 분리: 각 ViewModel(MainViewModel, MasterDataViewModel, LogViewModel)이 독립적인 DbContext 인스턴스를 생성하고 관리합니다.
MainViewModel:
MasterDataViewModel, LogViewModel 인스턴스를 속성으로 가지지만 DbContext를 전달하지 않습니다.
OpenMasterDataWindowCommand를 추가하여 MasterDataWindow를 생성하고 ShowDialog()로 엽니다. 창이 닫히면 콤보박스 목록을 새로고침합니다.
Dispose 메서드는 자신의 DbContext만 해제합니다.
MasterDataViewModel, LogViewModel:
생성자에서 DbContext를 직접 생성합니다.
IDisposable을 구현하여 자신의 DbContext를 해제합니다.
MasterDataViewModel에서 IsMasterModeEnabled 속성 및 관련 확인 로직을 제거했습니다 (창 자체가 권한 확인 후 열리므로).
MainWindow.xaml:
TabControl을 제거하고 "마스터 데이터 관리" 버튼을 추가했습니다.
버튼의 Visibility를 MainViewModel.IsMasterModeEnabled에 바인딩했습니다.
MasterDataWindow.xaml (신규):
마스터 데이터 관리를 위한 UI 요소들을 포함하는 새 창입니다.
내부 컨트롤들은 항상 활성화 상태입니다 (IsEnabled, AllowEditing 바인딩 제거).
다음 단계로 MasterDataWindow.xaml.cs 파일을 생성하고, MasterDataWindow.xaml에 추가한 "닫기" 버튼(CloseButton_Click)에 대한 이벤트 핸들러 등을 구현해야 합니다.

이제 4,5,6번 파일주십시오^^




생각하는 과정 표시
네, 요청하신 대로 4, 5, 6번째 파일에 해당하는 코드를 드리겠습니다.

수정/추가될 파일 목록:

Views/MainWindow.xaml (이전 단계에서 제공)
ViewModels/MainViewModel.cs (이전 단계에서 제공)
Views/MasterDataWindow.xaml (이전 단계에서 제공)
Views/MasterDataWindow.xaml.cs (신규) <--- 지금 제공
ViewModels/MasterDataViewModel.cs (수정) <--- 지금 제공
Infrastructure/BooleanToVisibilityConverter.cs (신규/필수) <--- 지금 제공
4. Views/MasterDataWindow.xaml.cs (신규)

새로 추가한 MasterDataWindow.xaml 파일에 대한 코드 비하인드 파일입니다. 창을 닫는 버튼 로직과, 창이 닫힐 때 MasterDataViewModel의 리소스(DbContext)를 정리하는 로직을 포함합니다.

C#

using DevExpress.Xpf.Core; // ThemedWindow 사용
using LockerManagementApp.ViewModels; // MasterDataViewModel 참조
using System;
using System.ComponentModel; // CancelEventArgs 사용
using System.Windows;

namespace LockerManagementApp.Views
{
    /// <summary>
    /// MasterDataWindow.xaml에 대한 상호 작용 논리
    /// </summary>
    public partial class MasterDataWindow : ThemedWindow
    {
        public MasterDataWindow()
        {
            InitializeComponent();
            // 테마 설정 등 필요 시 추가
            // ApplicationThemeHelper.ApplicationThemeName = Theme.Office2019ColorfulName;
        }

        // DataContext를 MasterDataViewModel 타입으로 캐스팅하는 편의 속성
        private MasterDataViewModel ViewModel => DataContext as MasterDataViewModel;

        /// <summary>
        /// "닫기" 버튼 클릭 이벤트 핸들러
        /// </summary>
        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close(); // 현재 창을 닫습니다.
        }

        /// <summary>
        /// 창이 닫히기 전에 호출되는 이벤트 핸들러
        /// </summary>
        private void MasterDataWindow_Closing(object sender, CancelEventArgs e)
        {
            // DataContext로 설정된 ViewModel이 IDisposable을 구현했다면 Dispose 호출
            if (ViewModel is IDisposable disposableViewModel)
            {
                try
                {
                    disposableViewModel.Dispose(); // ViewModel의 리소스(DbContext) 정리
                }
                catch (Exception ex)
                {
                    // Dispose 중 오류 발생 시 로그 기록 등 (선택 사항)
                    System.Diagnostics.Debug.WriteLine($"MasterDataViewModel Dispose 오류: {ex.Message}");
                }
            }
        }
    }
}
5. ViewModels/MasterDataViewModel.cs (수정)

IsMasterModeEnabled 속성 및 관련 로직(CanExecute 등에서의 확인)을 제거합니다. 이 창은 마스터 키 확인 후에만 열리므로 내부는 항상 활성화 상태로 간주합니다.
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (IsMasterModeEnabled 관련 로직 제거)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) RaiseCanExecuteChanged(); } } // CanExecute 갱신
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }

        // *** IsMasterModeEnabled 속성 제거됨 ***
        // private bool _isMasterModeEnabled = false;
        // public bool IsMasterModeEnabled { ... }

        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }

            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();

            // Command 초기화 (CanExecute에서 IsMasterModeEnabled 조건 제거)
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItemExecute);
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItemExecute);
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync(), CanSaveChangesExecute); // 저장 가능 조건은 변경 여부만 확인

            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        // *** 수정된 부분: CanExecute 메서드에서 IsMasterModeEnabled 조건 제거 ***
        private bool CanAddItemExecute(object parameter) => _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private bool CanDeleteItemExecute(object parameter) => _context != null && SelectedItem != null; // 선택된 항목이 있을 때만 삭제 가능
        private bool CanSaveChangesExecute(object parameter) => _context != null && _context.ChangeTracker.HasChanges(); // 변경 사항이 있을 때만 저장 가능

        private void AddItem(object parameter)
        {
            // IsMasterModeEnabled 확인 제거
            if (_context == null) return;
            if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        }

        private void DeleteItem(object parameter)
        {
            // IsMasterModeEnabled 확인 제거
            if (_context == null || SelectedItem == null) return;
            string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = null; if (SelectedItem is LockerType lt) entityToDelete = lt; else if (SelectedItem is Floor f) entityToDelete = f; else if (SelectedItem is Zone z) entityToDelete = z; else if (SelectedItem is SubPart sp) entityToDelete = sp; else if (SelectedItem is Administrator ad) entityToDelete = ad; else return; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } }
        }

        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }

        /// <summary>
        /// 마스터 데이터 변경 사항 저장 (연쇄 업데이트 포함) - 마스터 모드 확인 제거
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            // IsMasterModeEnabled 확인 제거
            if (_context == null || !CanSaveChangesExecute(null)) // 변경 사항이 있는지 확인
            {
                StatusMessage = "저장할 변경 사항이 없습니다.";
                return;
            }
            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList();

            using (var transaction = _context.Database.BeginTransaction()) { try { Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨."); var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, EntityType = e.Entity.GetType(), OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList(); Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}"); foreach (var modified in modifiedNameEntries) { StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'"); int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType"; else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor"; else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone"; else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart"; else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator"; if (!string.IsNullOrEmpty(targetColumn)) { updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}"; try { updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}"); } catch (Exception sqlEx) { Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}"); StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!"; throw; } } else { Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다."); } } Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)..."); int masterDataChanges = await _context.SaveChangesAsync(); Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}"); transaction.Commit(); Debug.WriteLine("트랜잭션 커밋 완료."); StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다."; } catch (Exception ex) { Debug.WriteLine($"*** 마스터 데이터 저장 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rollbackEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rollbackEx.ToString()}"); } StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}"; MessageBox.Show($"{StatusMessage}\n\n자세한 내용은 출력 창을 확인하세요.", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error); RollbackMasterDataChanges(changesForRollback); } } await LoadAllMasterDataAsync(); RaiseCanExecuteChanged(); // 저장 후 CanExecute 상태 갱신
        }
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusMessage = "마스터 데이터 변경 롤백됨."; _ = LoadAllMasterDataAsync(); }
        #endregion

        /// <summary>
        /// 모든 Command의 CanExecute 상태를 갱신합니다.
        /// </summary>
        private void RaiseCanExecuteChanged()
        {
            (AddItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (DeleteItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
6. Infrastructure/BooleanToVisibilityConverter.cs (신규/필수)   

MainWindow.xaml에서 마스터 데이터 관리 버튼의 Visibility를 제어하기 위해 이 컨버터가 필요합니다. Infrastructure 폴더에 이 파일을 추가하세요.

C#

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// bool 값을 Visibility 값으로 변환하는 WPF IValueConverter 입니다.
    /// true -> Visibility.Visible
    /// false -> Visibility.Collapsed
    /// </summary>
    [ValueConversion(typeof(bool), typeof(Visibility))]
    public class BooleanToVisibilityConverter : IValueConverter
    {
        public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
        {
            if (value is bool boolValue)
            {
                return boolValue ? Visibility.Visible : Visibility.Collapsed;
            }
            return Visibility.Collapsed;
        }

        public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
        {
            throw new NotImplementedException();
        }
    }
}
이제 이 파일들을 프로젝트에 적용하고 다시 빌드하여 실행해 보시기 바랍니다. 마스터 키를 확인하면 "마스터 데이터 관리" 버튼이 나타나고, 이 버튼을 클릭하면 새 창이 열리며, 해당 창 내부의 컨트롤들은 항상 활성화된 상태일 것입니다.


소스 및 관련 콘텐츠
github.com
github.com
stackoverflow.com
stackoverflow.com
www.gokhan-gokalp.com
www.gokhan-gokalp.com
github.com
github.com
stackoverflow.com
stackoverflow.com

내가 이과제 중간점검을 해보려고해요 모든파일구조.이름만 적어주세요




생각하는 과정 표시
네, 알겠습니다. 현재까지 작업한 .NET Framework 4.8 기반 WPF 사물함 관리 프로그램의 전체 파일 구조 및 이름 목록을 정리해 드리겠습니다.
프로젝트 파일 구조 목록
4월 8, 7:27 PM

열기

MasterDataWindow.xaml 이거 전체코드 다시줘보세요




생각하는 과정 표시
네, 마스터 데이터 관리를 위한 별도 창의 XAML 코드인 MasterDataWindow.xaml 파일 전체를 다시 드리겠습니다.

이 창은 마스터 키 확인 후에만 열리므로, 내부의 컨트롤(버튼, 그리드 편집 등)은 항상 활성화된 상태를 가정하고 IsEnabled 이나 AllowEditing 관련 바인딩은 제거했습니다. (Command의 CanExecute 로직에서 실제 실행 가능 여부를 판단합니다.)
Views/MasterDataWindow.xaml (최종)
4월 9, 7:41 AM

열기






Canvas

Gemini는 인물 등에 관한 정보 제공 시 실수를 할 수 있으니 다시 한번 확인하세요. 개인 정보 보호 및 Gemini