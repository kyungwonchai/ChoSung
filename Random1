. SSMS에서 바로 실행하는 SQL (sp_MSforeachdb 활용)
이 쿼리는 MSSQL의 비공식 시스템 프로시저인 sp_MSforeachdb를 사용하여 모든 DB를 순회하며 검색합니다. TARGET_TABLE_NAME 부분에 찾고자 하는 테이블 이름을 넣으세요.

SQL

-- 검색할 테이블 이름을 아래 변수에 입력하세요
DECLARE @SearchText NVARCHAR(100) = '검색할_테이블명';

-- 결과를 담을 임시 테이블 생성
IF OBJECT_ID('tempdb..#SearchResults') IS NOT NULL DROP TABLE #SearchResults;
CREATE TABLE #SearchResults (
    DBName NVARCHAR(128),
    ObjectName NVARCHAR(128),
    ObjectType NVARCHAR(50),
    ObjectDefinition NVARCHAR(MAX) -- 내용이 길 경우를 대비
);

-- 모든 DB를 순회하며 검색 (동적 쿼리)
DECLARE @Command NVARCHAR(MAX);
SET @Command = '
    USE [?];
    INSERT INTO #SearchResults (DBName, ObjectName, ObjectType, ObjectDefinition)
    SELECT
        ''?'' AS DBName,
        o.name AS ObjectName,
        o.type_desc AS ObjectType,
        LEFT(m.definition, 500) -- 내용 앞부분만 일부 저장 (필요시 제거)
    FROM sys.sql_modules m
    INNER JOIN sys.objects o ON m.object_id = o.object_id
    WHERE (o.type = ''P'' OR o.type = ''V'') -- P: 프로시저, V: 뷰
      AND m.definition LIKE ''%' + @SearchText + '%'';
';

-- 실행
EXEC sp_MSforeachdb @Command;

-- 결과 조회
SELECT * FROM #SearchResults ORDER BY DBName, ObjectType, ObjectName;
방법 2. Python 원샷 스크립트 (추천)
여러 DB에서 쿼리 결과를 취합하여 CSV 파일로 저장해 주는 스크립트입니다. 텍스트가 긴 프로시저 내용도 잘리지 않고 안전하게 확인할 수 있습니다.

준비: pip install pyodbc

설정: DB_CONFIG와 TARGET_TABLE_NAME을 수정 후 실행하세요.

Python

import pyodbc
import csv

# ---------------------------------------------------------
# [설정] MSSQL 접속 정보 및 검색 대상
# ---------------------------------------------------------
DB_CONFIG = {
    'server': 'localhost\\SQLEXPRESS',  # 예: 192.168.0.10 또는 localhost
    'username': 'sa',                   # DB 아이디
    'password': 'your_password'         # DB 비밀번호
}

TARGET_TABLE_NAME = "TB_USER"  # [중요] 여기에 찾고 싶은 테이블명을 입력하세요
OUTPUT_FILE = "table_usage_report.csv"

# ---------------------------------------------------------
# [로직] 전체 DB 순회 및 검색
# ---------------------------------------------------------
def main():
    conn_str = (
        f"DRIVER={{ODBC Driver 17 for SQL Server}};"
        f"SERVER={DB_CONFIG['server']};"
        f"UID={DB_CONFIG['username']};"
        f"PWD={DB_CONFIG['password']};"
        "DATABASE=master;" # 초기 접속은 master로
    )

    try:
        print(f"[*] 서버에 접속하여 '{TARGET_TABLE_NAME}' 검색을 시작합니다...")
        
        with pyodbc.connect(conn_str) as conn:
            cursor = conn.cursor()

            # 1. 시스템 DB를 제외한 사용자 DB 목록 가져오기
            cursor.execute("SELECT name FROM sys.databases WHERE database_id > 4 AND state = 0")
            databases = [row[0] for row in cursor.fetchall()]
            
            all_results = []

            # 2. 각 DB를 순회하며 검색
            for db in databases:
                print(f"    - 검색 중: [{db}]...")
                
                # 해당 DB 내에서 뷰(V)와 프로시저(P)의 정의(Definition) 검색
                # SQL 2014 호환 쿼리
                sql = f"""
                SELECT 
                    '{db}' AS DBName,
                    o.name AS ObjectName,
                    o.type_desc AS ObjectType
                FROM [{db}].sys.sql_modules m
                INNER JOIN [{db}].sys.objects o ON m.object_id = o.object_id
                WHERE (o.type = 'P' OR o.type = 'V')
                  AND m.definition LIKE ?
                """
                
                try:
                    cursor.execute(sql, (f'%{TARGET_TABLE_NAME}%',))
                    rows = cursor.fetchall()
                    for row in rows:
                        all_results.append(row)
                except pyodbc.Error:
                    # 권한 문제 등으로 특정 DB 접근 불가 시 건너뜀
                    print(f"      [!] {db} 접근 불가, 건너뜁니다.")
                    continue

            # 3. 결과 저장
            if not all_results:
                print(f"\n[결과] '{TARGET_TABLE_NAME}'이(가) 포함된 뷰나 프로시저가 없습니다.")
                return

            with open(OUTPUT_FILE, 'w', newline='', encoding='utf-8-sig') as f:
                writer = csv.writer(f)
                writer.writerow(['Database', 'Object Name', 'Type']) # 헤더
                writer.writerows(all_results)

            print(f"\n[완료] 총 {len(all_results)}건 발견.")
            print(f"       결과가 '{OUTPUT_FILE}'에 저장되었습니다.")

    except Exception as e:
        print(f"\n[오류] 실행 중 문제가 발생했습니다: {e}")

if __name__ == "__main__":
    main()
참고 사항
LIKE 검색의 특성: LIKE '%테이블명%' 방식을 사용하므로, 만약 찾는 이름이 User인데 UserLog라는 테이블이 쿼리에 있다면 같이 검색될 수 있습니다. (정확히 단어 단위로 끊어서 찾으려면 정규식이 필요하지만, MSSQL 기본 기능으로는 이 방식이 가장 확실하고 빠릅니다.)

성능: 텍스트 검색(sys.sql_modules)은 아주 빠르진 않지만, 프로시저나 뷰 개수가 수천 개 단위라면 몇 초 안에 끝납니다.

두 방법 중 편한 것을 골라 사용하시면