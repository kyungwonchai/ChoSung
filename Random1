using LockerManagementApp.Data; // DbContext 네임스페이스
using LockerManagementApp.Models; // Model 네임스페이스
using LockerManagementApp.Infrastructure; // ViewModelBase, RelayCommand 네임스페이스
using System;
using System.Collections.ObjectModel; // ObservableCollection 사용
using System.ComponentModel; // INotifyPropertyChanged (ViewModelBase에 구현됨)
using System.Data.Entity; // EntityState, ToListAsync 등 EF6 네임스페이스
using System.Data.Entity.Infrastructure; // DbEntityEntry 사용
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // MessageBox 사용
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터(층, 구역, 소파트, 관리자, 사물함 종류)를 관리하는 ViewModel 클래스입니다.
    /// CRUD 작업 및 이름 변경 시 연쇄 업데이트 기능을 포함합니다.
    /// </summary>
    public class MasterDataViewModel : ViewModelBase
    {
        private readonly LockerDbContext _context; // 데이터베이스 컨텍스트

        #region Observable Collections (UI 바인딩용)
        // 각 마스터 데이터 목록을 담는 ObservableCollection
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        #endregion

        #region Selected Item Properties
        // 사용자가 각 그리드/리스트에서 선택한 항목을 저장하는 속성
        private object _selectedItem;
        public object SelectedItem
        {
            get => _selectedItem;
            // 선택된 항목이 변경될 때 삭제 가능 여부(CanDeleteItem)를 갱신하도록 알림
            set { if (SetProperty(ref _selectedItem, value)) ((RelayCommand)DeleteItemCommand).RaiseCanExecuteChanged(); }
        }
        #endregion

        #region Status Message Property
        // 작업 상태를 표시하기 위한 메시지 속성
        private string _statusMessage;
        public string StatusMessage
        {
            get => _statusMessage;
            set => SetProperty(ref _statusMessage, value);
        }
        #endregion

        #region Commands
        // UI와 바인딩될 Command 속성들
        public ICommand LoadAllMasterDataCommand { get; } // 모든 마스터 데이터 새로고침
        public ICommand AddItemCommand { get; }          // 새 항목 추가
        public ICommand DeleteItemCommand { get; }       // 선택 항목 삭제
        public ICommand SaveChangesCommand { get; }     // 변경 사항 저장 (연쇄 업데이트 포함)
        #endregion

        /// <summary>
        /// MasterDataViewModel 생성자
        /// </summary>
        /// <param name="context">주입받거나 생성된 LockerDbContext 인스턴스</param>
        public MasterDataViewModel(LockerDbContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));

            // ObservableCollection 초기화
            LockerTypes = new ObservableCollection<LockerType>();
            Floors = new ObservableCollection<Floor>();
            Zones = new ObservableCollection<Zone>();
            SubParts = new ObservableCollection<SubPart>();
            Administrators = new ObservableCollection<Administrator>();

            // Command 초기화
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItem);
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItem); // CanExecute 조건 추가
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync());

            // 생성 시 데이터 로드
            _ = LoadAllMasterDataAsync();
        }

        /// <summary>
        /// 모든 마스터 데이터를 데이터베이스에서 비동기적으로 로드합니다.
        /// </summary>
        public async Task LoadAllMasterDataAsync()
        {
            StatusMessage = "마스터 데이터 로딩 중...";
            try
            {
                // 각 마스터 데이터 목록을 DB에서 가져와 ObservableCollection에 채웁니다.
                var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).ToListAsync();
                LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add);

                var floors = await _context.Floors.OrderBy(x => x.Name).ToListAsync();
                Floors.Clear(); floors.ForEach(Floors.Add);

                var zones = await _context.Zones.OrderBy(x => x.Name).ToListAsync();
                Zones.Clear(); zones.ForEach(Zones.Add);

                var subParts = await _context.SubParts.OrderBy(x => x.Name).ToListAsync();
                SubParts.Clear(); subParts.ForEach(SubParts.Add);

                var administrators = await _context.Administrators.OrderBy(x => x.Name).ToListAsync();
                Administrators.Clear(); administrators.ForEach(Administrators.Add);

                StatusMessage = "마스터 데이터 로드 완료.";
            }
            catch (Exception ex)
            {
                StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}";
                MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #region Add/Delete Logic

        /// <summary>
        /// 새 항목 추가 가능 여부 (CommandParameter로 카테고리 문자열을 받는다고 가정)
        /// </summary>
        private bool CanAddItem(object parameter) => parameter is string category && !string.IsNullOrEmpty(category);

        /// <summary>
        /// 지정된 카테고리에 새 항목을 추가합니다 (UI 및 DbContext에).
        /// </summary>
        private void AddItem(object parameter)
        {
            if (parameter is string category)
            {
                try
                {
                    object newItem = null;
                    switch (category.ToLower())
                    {
                        case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break;
                        case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break;
                        case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break;
                        case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break;
                        case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break;
                        default: MessageBox.Show("알 수 없는 카테고리입니다.", "오류"); return;
                    }
                    SelectedItem = newItem; // 새로 추가된 항목 선택
                    StatusMessage = "새 항목이 추가되었습니다. 이름 수정 후 저장하세요.";
                }
                catch (Exception ex)
                {
                    StatusMessage = $"항목 추가 중 오류: {ex.Message}";
                    MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        /// <summary>
        /// 선택된 항목 삭제 가능 여부
        /// </summary>
        private bool CanDeleteItem(object parameter) => SelectedItem != null;

        /// <summary>
        /// 선택된 항목을 삭제합니다 (UI 및 DbContext에서).
        /// </summary>
        private void DeleteItem(object parameter)
        {
            if (SelectedItem == null) return;

            // 중요: 삭제 전 연관 데이터 확인 로직 추가 권장
            string itemName = GetItemName(SelectedItem); // 삭제 확인 메시지에 이름 표시용
            if (itemName == null) return; // 이름 속성이 없는 타입이면 처리 불가

            string confirmMessage = $"'{itemName}' 항목을 삭제하시겠습니까?";
            if (HasAssociatedAssignments(SelectedItem, itemName))
            {
                confirmMessage += "\n\n경고: 이 항목을 사용하는 사물함 정보가 있습니다.\n삭제 시 해당 사물함 정보에 문제가 발생할 수 있습니다!\n(연쇄 삭제 기능은 구현되지 않았습니다.)";
            }


            if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                try
                {
                    // DbContext에서 엔티티를 제거 대상으로 표시하고, ObservableCollection에서도 제거합니다.
                    if (SelectedItem is LockerType lt) { _context.Entry(lt).State = EntityState.Deleted; LockerTypes.Remove(lt); }
                    else if (SelectedItem is Floor f) { _context.Entry(f).State = EntityState.Deleted; Floors.Remove(f); }
                    else if (SelectedItem is Zone z) { _context.Entry(z).State = EntityState.Deleted; Zones.Remove(z); }
                    else if (SelectedItem is SubPart sp) { _context.Entry(sp).State = EntityState.Deleted; SubParts.Remove(sp); }
                    else if (SelectedItem is Administrator ad) { _context.Entry(ad).State = EntityState.Deleted; Administrators.Remove(ad); }
                    else { return; }

                    SelectedItem = null; // 선택 해제
                    StatusMessage = "항목이 삭제 대기 상태입니다. '마스터 데이터 저장' 시 최종 반영됩니다.";
                }
                catch (Exception ex)
                {
                    StatusMessage = $"항목 삭제 중 오류: {ex.Message}";
                    MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    _ = LoadAllMasterDataAsync(); // 오류 시 목록 복구
                }
            }
        }

        /// <summary>
        /// 선택된 항목의 Name 속성 값을 가져옵니다.
        /// </summary>
        private string GetItemName(object item)
        {
            if (item == null) return null;
            var nameProp = item.GetType().GetProperty("Name");
            return nameProp?.GetValue(item)?.ToString();
        }

        /// <summary>
        /// 주어진 마스터 데이터 항목을 사용하는 LockerAssignment가 있는지 확인합니다.
        /// </summary>
        private bool HasAssociatedAssignments(object item, string itemName)
        {
            if (item == null || string.IsNullOrEmpty(itemName)) return false;

            try
            {
                if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName);
                if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName);
                if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName);
                if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName);
                if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName);
            }
            catch (Exception ex)
            {
                // DB 조회 오류 시 안전하게 true 반환하여 삭제 방지
                System.Diagnostics.Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}");
                return true;
            }
            return false;
        }


        #endregion

        #region Save Changes Logic (Including Cascade Update)

        /// <summary>
        /// 마스터 데이터의 변경 사항(추가, 수정, 삭제)을 데이터베이스에 저장합니다.
        /// 이름(Name)이 변경된 경우, 관련된 LockerAssignment 레코드도 연쇄적으로 업데이트합니다.
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            StatusMessage = "마스터 데이터 저장 중...";

            using (var transaction = _context.Database.BeginTransaction())
            {
                try
                {
                    // 1. 이름이 변경된 마스터 데이터 항목들을 찾습니다.
                    var modifiedNameEntries = _context.ChangeTracker.Entries()
                        .Where(e => e.State == EntityState.Modified &&
                                    (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator))
                        .Select(e => new
                        {
                            Entry = e,
                            OriginalName = e.OriginalValues["Name"]?.ToString(),
                            CurrentName = e.CurrentValues["Name"]?.ToString()
                        })
                        .Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName)
                        .ToList();

                    // 2. 각 이름 변경 건에 대해 연쇄 업데이트 SQL을 실행합니다.
                    foreach (var modified in modifiedNameEntries)
                    {
                        StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중...";
                        int updatedCount = 0;
                        string updateSql = "";
                        string targetColumn = "";

                        if (modified.Entry.Entity is LockerType) targetColumn = "LockerType";
                        else if (modified.Entry.Entity is Floor) targetColumn = "Floor";
                        else if (modified.Entry.Entity is Zone) targetColumn = "Zone";
                        else if (modified.Entry.Entity is SubPart) targetColumn = "SubPart";
                        else if (modified.Entry.Entity is Administrator) targetColumn = "Administrator";

                        if (!string.IsNullOrEmpty(targetColumn))
                        {
                            // SQL Injection 방지를 위해 파라미터화된 쿼리 사용
                            updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}";
                            // ExecuteSqlCommandAsync는 EF6에도 존재합니다.
                            updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName);
                            StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 사물함 정보 업데이트 완료).";
                            System.Diagnostics.Debug.WriteLine($"Executed: {updateSql} with params '{modified.CurrentName}', '{modified.OriginalName}'. Rows affected: {updatedCount}");
                        }
                    }

                    // 3. 모든 변경 사항(마스터 데이터 추가/수정/삭제)을 DB에 저장합니다.
                    int masterDataChanges = await _context.SaveChangesAsync(); // 로그는 DbContext에서 자동 기록

                    // 4. 트랜잭션을 커밋합니다.
                    transaction.Commit();
                    StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다.";

                    // 5. 메인 ViewModel의 콤보박스용 마스터 데이터 목록도 갱신해야 함 (이벤트 방식 권장)
                }
                catch (Exception ex)
                {
                    // 6. 오류 발생 시 트랜잭션을 롤백합니다.
                    transaction.Rollback();
                    StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}";
                    MessageBox.Show($"{StatusMessage}\n\n{ex.ToString()}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);

                    // 오류 발생 시 컨텍스트의 변경 내용을 되돌리는 것이 좋습니다.
                    var errorEntries = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged && e.State != EntityState.Detached);
                    foreach (var entry in errorEntries.ToList())
                    {
                        try { entry.Reload(); } catch { entry.State = EntityState.Detached; } // Reload 실패 시 Detach 시도
                    }
                }
            }

            // 7. 작업 완료 후 마스터 데이터 목록을 다시 로드하여 UI를 최신 상태로 유지합니다.
            await LoadAllMasterDataAsync();
        }

        #endregion
    }