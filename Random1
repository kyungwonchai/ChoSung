알겠습니다. MainViewModel.cs 파일에서 여전히 CanUserManageAgents 관련 오류가 발생한다니 죄송합니다. 좀 더 면밀하게 검토하여 해당 오류를 해결할 수 있도록 수정된 전체 코드를 드리겠습니다.

오류의 주된 원인은 RelayCommand의 CanExecute 조건으로 사용되는 bool 타입의 권한 속성이 MainViewModel 내에 명확하게 정의되지 않았거나, 다른 이름으로 정의된 속성을 잘못 참조하고 있기 때문일 가능성이 높습니다.

수정 방향:

MainViewModel에 bool 타입의 CanManageAgents와 CanControlPower라는 이름의 읽기 전용 속성을 명시적으로 정의합니다. 이 속성들은 생성자에서 _currentUserSession 객체를 통해 초기화됩니다.
XAML에서 버튼 등의 Visibility를 제어할 때는 이 bool 속성들을 BooleanToVisibilityConverter와 함께 사용합니다 (이전 ManageAgentsButtonVisibility 같은 별도 Visibility 속성 대신).
각 RelayCommand의 CanExecute 델리게이트에서는 새로 정의된 bool 타입의 CanManageAgents와 CanControlPower 속성을 직접 참조합니다.
이렇게 하면 C# 코드 내에서 권한 관련 속성 이름이 일관되게 사용되어 오류를 줄일 수 있습니다.

수정된 MGSPMonitorControl/ViewModels/MainViewModel.cs (전체 코드):

C#

// MGSPMonitorControl/ViewModels/MainViewModel.cs
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // Dispatcher, MessageBox
using System.Windows.Input;
using MGSPMonitorControl.Models;
using MGSPMonitorControl.Services;
using MGSPMonitorControl.Views; // AgentConfigWindow (네임스페이스 주의)
using MonitorControl.SharedModels; // BrokerMessage, LiveAgentInfoForUi 등
using Newtonsoft.Json; // JsonConvert

namespace MGSPMonitorControl.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly UserSession _currentUserSession;
        private readonly IDatabaseService _databaseService;
        private readonly IBrokerClientService _brokerClientService;
        // private readonly ILoggingService _uiLocalLogger; // 필요시 추가

        public ObservableCollection<ManagedAgentDisplay> Agents { get; }
        public ObservableCollection<string> UiActionLogs { get; }
        // BrokerServerLogs는 BrokerStatus.RecentServerLogs에 바인딩되므로 별도 컬렉션 불필요

        private ManagedAgentDisplay _selectedAgent;
        public ManagedAgentDisplay SelectedAgent
        {
            get => _selectedAgent;
            set 
            { 
                if (SetProperty(ref _selectedAgent, value))
                {
                    // 선택 변경 시 관련된 모든 Command들의 CanExecute 상태 업데이트
                    RefreshCommandStates();
                }
            }
        }

        private BrokerStatusDisplay _brokerStatus = new BrokerStatusDisplay();
        public BrokerStatusDisplay BrokerStatus
        {
            get => _brokerStatus;
            set => SetProperty(ref _brokerStatus, value);
        }
        
        private string _brokerConnectionStatus = "Disconnected";
        public string BrokerConnectionStatus 
        {
            get => _brokerConnectionStatus;
            set 
            { 
                if (SetProperty(ref _brokerConnectionStatus, value))
                {
                    RefreshCommandStates(); // 연결 상태 변경 시 Command 상태 업데이트
                }
            }
        }

        // 사용자 권한을 위한 bool 속성 (XAML 및 Command CanExecute에서 사용)
        public bool CanManageAgents => _currentUserSession?.CanManageAgents ?? false;
        public bool CanControlPower => _currentUserSession?.CanControlPower ?? false;
        public string CurrentUsername => _currentUserSession?.Username ?? "N/A";


        // Commands
        public ICommand LoadAgentsCommand { get; }
        public ICommand AddAgentCommand { get; }
        public ICommand EditAgentCommand { get; }
        public ICommand DeleteAgentCommand { get; }
        public ICommand MonitorOnCommand { get; }
        public ICommand MonitorOffCommand { get; }
        public ICommand PingAgentCommand { get; }
        public ICommand RequestBrokerStatusCommand { get; }
        public ICommand ConnectToBrokerCommand { get; }
        public ICommand DisconnectFromBrokerCommand { get; }
        public ICommand ClearUiLogsCommand { get; }


        public MainViewModel(UserSession userSession, IDatabaseService databaseService, IBrokerClientService brokerClientService)
        {
            _currentUserSession = userSession ?? throw new ArgumentNullException(nameof(userSession));
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _brokerClientService = brokerClientService ?? throw new ArgumentNullException(nameof(brokerClientService));

            Agents = new ObservableCollection<ManagedAgentDisplay>();
            UiActionLogs = new ObservableCollection<string>();
            // BrokerServerLogs는 BrokerStatus.RecentServerLogs를 통해 XAML에 직접 바인딩

            AddUiLog($"User '{CurrentUsername}' logged in. ManageAgents: {CanManageAgents}, ControlPower: {CanControlPower}");

            _brokerClientService.Connected += OnBrokerConnected;
            _brokerClientService.Disconnected += OnBrokerDisconnected;
            _brokerClientService.MessageReceived += OnBrokerMessageReceived;

            // Commands 초기화
            LoadAgentsCommand = new RelayCommand(async () => await ExecuteLoadAgentsAsync()); // CanExecute는 항상 true 또는 연결 상태 기반
            AddAgentCommand = new RelayCommand(ExecuteAddAgent, () => CanManageAgents);
            EditAgentCommand = new RelayCommand(ExecuteEditAgent, () => SelectedAgent != null && CanManageAgents);
            DeleteAgentCommand = new RelayCommand(async () => await ExecuteDeleteAgentAsync(), () => SelectedAgent != null && CanManageAgents);
            
            MonitorOnCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOn"), 
                                              () => SelectedAgent != null && SelectedAgent.IsOnline && CanControlPower);
            MonitorOffCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOff"), 
                                               () => SelectedAgent != null && SelectedAgent.IsOnline && CanControlPower);
            PingAgentCommand = new RelayCommand(async () => await ExecutePingAgentAsync(), 
                                              () => SelectedAgent != null && SelectedAgent.IsOnline); // Ping은 권한 무관하게 가능

            RequestBrokerStatusCommand = new RelayCommand(async () => await ExecuteRequestBrokerStatusAsync(), () => _brokerClientService.IsConnected);
            ConnectToBrokerCommand = new RelayCommand(async () => await _brokerClientService.ConnectAsync(), () => !_brokerClientService.IsConnected);
            DisconnectFromBrokerCommand = new RelayCommand(async () => await _brokerClientService.DisconnectAsync(), () => _brokerClientService.IsConnected);
            ClearUiLogsCommand = new RelayCommand(() => UiActionLogs.Clear());

            // 초기 데이터 로드 및 Broker 연결 시도
            Task.Run(async () => {
                await ExecuteLoadAgentsAsync(); 
                if (!_brokerClientService.IsConnected)
                {
                    await _brokerClientService.ConnectAsync();
                }
            });
        }

        private void RefreshCommandStates()
        {
            // UI 스레드에서 실행 보장 (CommandManager.RequerySuggested는 UI 스레드에서 발생)
            Application.Current.Dispatcher.Invoke(() =>
            {
                (LoadAgentsCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (AddAgentCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (EditAgentCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (DeleteAgentCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (MonitorOnCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (MonitorOffCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (PingAgentCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (RequestBrokerStatusCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (ConnectToBrokerCommand as RelayCommand)?.RaiseCanExecuteChanged();
                (DisconnectFromBrokerCommand as RelayCommand)?.RaiseCanExecuteChanged();
            });
        }

        private void AddUiLog(string message)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                string logEntry = $"[{DateTime.Now:HH:mm:ss.fff}] {message}";
                UiActionLogs.Insert(0, logEntry);
                if (UiActionLogs.Count > 200) UiActionLogs.RemoveAt(UiActionLogs.Count - 1);
            });
        }

        private async Task ExecuteLoadAgentsAsync()
        {
            AddUiLog("Loading managed agents from database...");
            try
            {
                var dbAgents = await _databaseService.GetManagedAgentsAsync();
                Application.Current.Dispatcher.Invoke(() =>
                {
                    Agents.Clear();
                    foreach (var agent in dbAgents.OrderBy(a=>a.AgentName))
                    {
                        Agents.Add(agent);
                    }
                    SelectedAgent = null; // 목록 새로고침 후 선택 해제
                });
                AddUiLog($"Loaded {dbAgents.Count} agent configurations from DB.");
                
                if(_brokerClientService.IsConnected)
                {
                    await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetInitialAgentList, SourceId = CurrentUsername });
                }
                RefreshCommandStates();
            }
            catch (Exception ex)
            {
                AddUiLog($"[ERROR] Error loading agents from DB: {ex.Message}");
                MessageBox.Show($"Error loading agents: {ex.Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void ExecuteAddAgent()
        {
            AddUiLog("Opening 'Add New Agent' window...");
            var agentConfigVm = new AgentConfigViewModel(_databaseService, _currentUserSession.UserId);
            var agentConfigWindow = new AgentConfigWindow(agentConfigVm); 
            
            if (agentConfigWindow.ShowDialog() == true)
            {
                AddUiLog($"Agent '{agentConfigVm.Agent.AgentName}' configuration saved. Refreshing list.");
                Task.Run(async () => await ExecuteLoadAgentsAsync()); 
            }
            else
            {
                AddUiLog("'Add New Agent' window cancelled.");
            }
        }

        private void ExecuteEditAgent()
        {
            if (SelectedAgent == null) return;
            AddUiLog($"Opening 'Edit Agent' window for: {SelectedAgent.AgentName} (AppID: {SelectedAgent.AgentIdProvidedByApp})");
            
            ManagedAgentDisplay agentToEditInDb = null;
            try
            {
                // 비동기 호출 결과를 동기적으로 기다릴 때는 주의 (UI 스레드에서 호출 시 Deadlock 가능성)
                // 여기서는 RelayCommand의 Execute가 백그라운드 스레드에서 호출되지 않으므로 Task.Result 사용.
                // 더 안전한 방법은 이 메서드 전체를 async Task로 만들고 await 사용.
                // 여기서는 생성자에서 이미 Task.Run으로 초기 로드를 호출하므로, 다른 버튼들도 async Task로 변경.
                agentToEditInDb = Task.Run(async () => await _databaseService.GetManagedAgentByGuidAsync(SelectedAgent.AgentGuid)).Result;
            }
            catch (Exception ex)
            {
                 AddUiLog($"[ERROR] Error fetching agent details for editing: {ex.GetBaseException().Message}");
                 MessageBox.Show($"Error fetching agent details: {ex.GetBaseException().Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 return;
            }
            
            if(agentToEditInDb == null) {
                AddUiLog($"Agent {SelectedAgent.AgentName} not found in DB for editing. Refreshing list.");
                MessageBox.Show("Selected agent not found in database. It might have been deleted.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Task.Run(async () => await ExecuteLoadAgentsAsync());
                return;
            }

            var agentConfigVm = new AgentConfigViewModel(_databaseService, _currentUserSession.UserId, agentToEditInDb);
            var agentConfigWindow = new AgentConfigWindow(agentConfigVm);
            
            if (agentConfigWindow.ShowDialog() == true)
            {
                AddUiLog($"Agent '{agentConfigVm.Agent.AgentName}' configuration updated. Refreshing list.");
                Task.Run(async () => await ExecuteLoadAgentsAsync());
            }
            else
            {
                AddUiLog("'Edit Agent' window cancelled.");
            }
        }

        private async Task ExecuteDeleteAgentAsync()
        {
            if (SelectedAgent == null) return;
            if (MessageBox.Show($"Are you sure you want to delete agent '{SelectedAgent.AgentName}' (ID: {SelectedAgent.AgentIdProvidedByApp}) from the database?\nThis will also delete associated control logs.",
                                "Confirm Delete Agent Configuration", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                AddUiLog($"Attempting to delete agent configuration: {SelectedAgent.AgentName}");
                try
                {
                    bool success = await _databaseService.DeleteManagedAgentAsync(SelectedAgent.AgentGuid);
                    if (success)
                    {
                        AddUiLog($"Agent configuration '{SelectedAgent.AgentName}' deleted successfully. Refreshing list.");
                        await ExecuteLoadAgentsAsync(); // 목록 새로고침
                    }
                    else
                    {
                        AddUiLog($"[ERROR] Failed to delete agent configuration '{SelectedAgent.AgentName}'.");
                        MessageBox.Show("Failed to delete agent configuration.", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    }
                }
                catch (Exception ex)
                {
                    AddUiLog($"[ERROR] Error deleting agent configuration '{SelectedAgent.AgentName}': {ex.Message}");
                    MessageBox.Show($"Error deleting agent: {ex.Message}", "Database Error", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        private async Task ExecuteMonitorControlAsync(string actionType)
        {
            if (SelectedAgent == null) return;

            string correlationId = Guid.NewGuid().ToString();
            AddUiLog($"Sending '{actionType}' command (CorrID: {correlationId}) to agent: {SelectedAgent.AgentName} (AppID: {SelectedAgent.AgentIdProvidedByApp})");

            ManagedAgentDisplay currentAgentConfig = null;
            try
            {
                 currentAgentConfig = await _databaseService.GetManagedAgentByGuidAsync(SelectedAgent.AgentGuid);
            }
            catch (Exception ex)
            {
                 AddUiLog($"[DB ERROR] Failed to get agent config for command: {ex.Message}");
                 MessageBox.Show($"Database error: {ex.Message}", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 return;
            }

            if (currentAgentConfig == null)
            {
                AddUiLog($"[ERROR] Agent configuration for {SelectedAgent.AgentName} not found in DB. Cannot send command.");
                MessageBox.Show("Agent configuration not found. Please refresh the list.", "Error", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            var payload = new UiControlAgentPayload 
            {
                TargetAgentIdProvidedByApp = currentAgentConfig.AgentIdProvidedByApp,
                ControlAction = actionType,
                ControlType = currentAgentConfig.ControlType,
                PrimaryIpAddress = currentAgentConfig.PrimaryIpAddress,
                PrimaryPort = currentAgentConfig.PrimaryPort,
                GatewayAgentIdToUse = currentAgentConfig.ControlType == "Gatewayed" ? currentAgentConfig.GatewayAgentIpAddress : null,
                OriginalParameters = null
            };

            var message = new BrokerMessage 
            {
                Type = MessageType.UiRequest_ControlAgent,
                CorrelationId = correlationId, 
                Payload = JsonConvert.SerializeObject(payload),
                SourceId = CurrentUsername 
            };

            var logEntry = new ControlActionLogEntry
            {
                AgentGuid = currentAgentConfig.AgentGuid,
                ActionType = actionType,
                RequestedByUserId = _currentUserSession.UserId,
                RequestTimestamp = DateTime.UtcNow,
                FinalStatus = "SentToBroker",
                ResultMessage = $"Command sent to broker. Waiting for response. CorrID: {correlationId}"
            };
            try { await _databaseService.LogControlActionAsync(logEntry); }
            catch (Exception ex) { AddUiLog($"[DB ERROR] Failed to log initial command send: {ex.Message}"); }

            await _brokerClientService.SendMessageAsync(message);
        }
        
        private async Task ExecutePingAgentAsync()
        {
            if (SelectedAgent == null) return;
            string correlationId = Guid.NewGuid().ToString();
            AddUiLog($"Sending 'PingAgent' command (CorrID: {correlationId}) to agent: {SelectedAgent.AgentName} (AppID: {SelectedAgent.AgentIdProvidedByApp})");
            
            var currentAgentConfig = await _databaseService.GetManagedAgentByGuidAsync(SelectedAgent.AgentGuid);
            if (currentAgentConfig == null) { AddUiLog($"[ERROR] Agent config for {SelectedAgent.AgentName} not found for Ping."); return; }

            var payload = new UiControlAgentPayload
            {
                TargetAgentIdProvidedByApp = currentAgentConfig.AgentIdProvidedByApp,
                ControlAction = "PingAgent", 
                ControlType = currentAgentConfig.ControlType, 
                PrimaryIpAddress = currentAgentConfig.PrimaryIpAddress,
                PrimaryPort = currentAgentConfig.PrimaryPort,
                GatewayAgentIdToUse = currentAgentConfig.ControlType == "Gatewayed" ? currentAgentConfig.GatewayAgentIpAddress : null
            };
            var message = new BrokerMessage
            {
                Type = MessageType.UiRequest_ControlAgent, 
                CorrelationId = correlationId,
                Payload = JsonConvert.SerializeObject(payload),
                SourceId = CurrentUsername
            };
            await _brokerClientService.SendMessageAsync(message);
        }

        private async Task ExecuteRequestBrokerStatusAsync()
        {
            AddUiLog("Requesting broker status and logs...");
            var message = new BrokerMessage { Type = MessageType.UiRequest_GetBrokerStatus, SourceId = CurrentUsername };
            await _brokerClientService.SendMessageAsync(message);
        }

        #region Broker Event Handlers
        private void OnBrokerConnected()
        {
            Application.Current.Dispatcher.Invoke(() => {
                BrokerConnectionStatus = "Connected"; // 더 간결하게
                AddUiLog("Successfully connected to Broker Service.");
                RefreshCommandStates();
            });
            Task.Run(async () => {
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiClientHello, SourceId = CurrentUsername });
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetInitialAgentList, SourceId = CurrentUsername });
                await _brokerClientService.SendMessageAsync(new BrokerMessage { Type = MessageType.UiRequest_GetBrokerStatus, SourceId = CurrentUsername });
                // await ExecuteLoadAgentsAsync(); // DB 목록은 이미 로드되어 있을 수 있음, Broker 상태와 병합
            });
        }

        private void OnBrokerDisconnected()
        {
             Application.Current.Dispatcher.Invoke(() => {
                BrokerConnectionStatus = "Disconnected";
                AddUiLog("Disconnected from Broker Service. Attempting to reconnect if BrokerClientService is designed to do so.");
                foreach(var agent in Agents) { agent.IsOnline = false; agent.CurrentMonitorStatus = "Offline (Broker D/C)"; }
                RefreshCommandStates();
             });
        }

        private void OnBrokerMessageReceived(BrokerMessage message) 
        {
             Application.Current.Dispatcher.Invoke(() =>
            {
                // AddUiLog($"Broker Msg Rcvd: Type={message.Type}, Src={message.SourceId}, CorrId={message.CorrelationId}");
                try
                {
                    switch (message.Type)
                    {
                        case MessageType.BrokerToUi_InitialAgentList:
                            var agentListPayload = JsonConvert.DeserializeObject<List<LiveAgentInfoForUi>>(message.Payload);
                            if (agentListPayload != null)
                            {
                                UpdateAgentListFromBroker(agentListPayload, true);
                                AddUiLog($"Received initial list of {agentListPayload.Count} live agents from Broker.");
                            }
                            break;
                        case MessageType.BrokerToUi_BroadcastAgentRegisteredOrUpdated:
                        case MessageType.BrokerToUi_BroadcastAgentStatus:
                            var liveAgentInfo = JsonConvert.DeserializeObject<LiveAgentInfoForUi>(message.Payload);
                            if (liveAgentInfo != null)
                            {
                                UpdateSingleAgentStatus(liveAgentInfo);
                                if(message.Type == MessageType.BrokerToUi_BroadcastAgentRegisteredOrUpdated)
                                    AddUiLog($"Agent '{liveAgentInfo.AgentIdProvidedByApp}' registered/updated on Broker.");
                            }
                            break;
                        case MessageType.BrokerToUi_BroadcastAgentDisconnected:
                            string disconnectedAgentId = message.SourceId; 
                            var agentToMarkOffline = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == disconnectedAgentId);
                            if (agentToMarkOffline != null)
                            {
                                agentToMarkOffline.IsOnline = false;
                                agentToMarkOffline.CurrentMonitorStatus = "Offline";
                                agentToMarkOffline.LastStatusMessageFromAgent = "Disconnected from Broker";
                                AddUiLog($"Agent disconnected from Broker: {disconnectedAgentId}");
                                RefreshCommandStates(); // Agent 상태 변경 시 Command 상태 업데이트
                            }
                            break;
                        case MessageType.BrokerToUi_ForwardAgentCommandResult:
                            var cmdResultPayload = JsonConvert.DeserializeObject<AgentCommandResultPayload>(message.Payload);
                            if (cmdResultPayload != null)
                            {
                                AddUiLog($"Result for CmdID [{message.CorrelationId}] from Agent [{message.SourceId}]: {(cmdResultPayload.Success ? "OK" : "NG")} - {cmdResultPayload.Message}");
                                var agentForResult = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == message.SourceId);
                                if(agentForResult != null)
                                {
                                    agentForResult.CurrentMonitorStatus = cmdResultPayload.CurrentMonitorStatus;
                                    agentForResult.LastStatusMessageFromAgent = $"Cmd: {cmdResultPayload.Message.Substring(0, Math.Min(cmdResultPayload.Message.Length,100))}";
                                    agentForResult.IsOnline = true; 
                                    RefreshCommandStates();
                                }
                                UpdateControlActionLogAsync(message.CorrelationId, message.SourceId, cmdResultPayload.Success, cmdResultPayload.Message, cmdResultPayload.CurrentMonitorStatus, DateTime.UtcNow).ConfigureAwait(false);
                            }
                            break;
                        case MessageType.BrokerToUi_CommandDispatchFailed:
                             var dispatchFailPayload = JsonConvert.DeserializeObject<dynamic>(message.Payload);
                             string reason = dispatchFailPayload?.Message ?? "Unknown dispatch error";
                             string failedTargetAgentId = message.TargetId ?? message.SourceId; // Broker가 TargetId를 채워줬다면 그것 사용
                             AddUiLog($"[ERROR] Broker failed to dispatch command [{message.CorrelationId}] for Agent [{failedTargetAgentId}]: {reason}");
                             UpdateControlActionLogAsync(message.CorrelationId, failedTargetAgentId, false, $"Broker Dispatch Failed: {reason}", null, DateTime.UtcNow, "FailureAtBroker").ConfigureAwait(false);
                            break;
                        case MessageType.BrokerToUi_SendBrokerStatus:
                            var brokerStatusPayload = JsonConvert.DeserializeObject<BrokerStatusInfoPayload>(message.Payload);
                            if (brokerStatusPayload != null)
                            {
                                BrokerStatus.UpdateFromServerPayload(brokerStatusPayload);
                                AddUiLog("Broker status and logs updated from server.");
                            }
                            break;
                    }
                }
                catch (JsonException jsonEx) { AddUiLog($"[ERROR] Failed to parse payload for message type {message.Type} from Broker: {jsonEx.Message}"); }
                catch (Exception ex) { AddUiLog($"[ERROR] Error processing message type {message.Type} from Broker: {ex.Message}"); }
            });
        }
        
        private void UpdateAgentListFromBroker(List<LiveAgentInfoForUi> liveAgents, bool isInitialLoad)
        {
            foreach (var liveAgent in liveAgents)
            {
                UpdateSingleAgentStatus(liveAgent);
            }
            if(isInitialLoad) {
                foreach(var dbAgent in Agents) {
                    if(!liveAgents.Any(la => la.AgentIdProvidedByApp == dbAgent.AgentIdProvidedByApp && la.IsOnline)) {
                        dbAgent.IsOnline = false;
                        dbAgent.CurrentMonitorStatus = "Offline";
                    }
                }
            }
            RefreshCommandStates();
        }

        private void UpdateSingleAgentStatus(LiveAgentInfoForUi liveInfo)
        {
            var agent = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == liveInfo.AgentIdProvidedByApp);
            if (agent != null)
            {
                agent.UpdateLiveStatus(liveInfo);
                if(SelectedAgent == agent) // 선택된 Agent의 상태가 변경되면 Command 상태 갱신
                {
                    RefreshCommandStates();
                }
            }
            else
            {
                 AddUiLog($"Live agent '{liveInfo.AgentIdProvidedByApp}' from Broker not found in local DB list. Please add via 'Add Agent' if it's a new valid agent.");
            }
        }
        
        private async Task UpdateControlActionLogAsync(string correlationId, string agentIdProvidedByApp, bool success, string message, string monitorStatus, DateTime completedTime, string statusOverride = null)
        {
            // TODO: CorrelationId로 기존 로그를 '찾아서 업데이트'하는 로직 필요.
            // 현재는 ExecuteMonitorControlAsync에서 'SentToBroker' 로그를 남기고, 여기서 최종 결과를 '별도의 로그'로 남기거나,
            // 아니면 'SentToBroker' 로그를 찾아 업데이트해야 함.
            // 단순화를 위해, 여기서는 새 로그를 기록한다고 가정 (중복 가능성, 또는 CorrelationId로 Update 쿼리)
            // 여기서는 CorrelationId가 없다고 가정하고 새 로그를 만듬 (이전 ExecuteMonitorControlAsync에서 correlationId를 포함한 로그를 남겼어야함)

            var agent = Agents.FirstOrDefault(a => a.AgentIdProvidedByApp == agentIdProvidedByApp);
            if (agent == null)
            {
                AddUiLog($"[DB LOG ERROR] Cannot log final status: Agent with AppID {agentIdProvidedByApp} not found for CorrId {correlationId}.");
                return;
            }

            // 실제로는 CorrelationId로 어떤 ActionType이었는지 찾아야 함.
            // 혹은 UI가 명령 보낼때 CorrelationId와 ActionType을 어딘가에 매핑해둬야 함.
            // 지금은 그냥 "ControlActionResult" 같은 타입으로 기록.
            var logEntry = new ControlActionLogEntry
            {
                AgentGuid = agent.AgentGuid,
                ActionType = $"ResultFor_{correlationId}", // 임시
                RequestTimestamp = DateTime.UtcNow, // 이것은 결과 수신 시간이므로, 원래 요청시간을 찾아야함.
                ExecutionCompletedTimestamp = completedTime,
                FinalStatus = statusOverride ?? (success ? "Success" : "FailureAtAgent"),
                ResultMessage = message,
                RequestedByUserId = _currentUserSession.UserId,
            };
             AddUiLog($"Logging final status for {agent.AgentName} (CorrId: {correlationId}) to DB.");
            try
            {
                await _databaseService.LogControlActionAsync(logEntry);
            }
            catch (Exception ex)
            {
                AddUiLog($"[DB ERROR] Failed to log final command status for {agent.AgentName} to DB: {ex.Message}");
            }
        }
        
        #endregion

        public void Cleanup() 
        {
            AddUiLog("MainViewModel cleaning up broker connection...");
            if (_brokerClientService != null)
            {
                _brokerClientService.Connected -= OnBrokerConnected;
                _brokerClientService.Disconnected -= OnBrokerDisconnected;
                _brokerClientService.MessageReceived -= OnBrokerMessageReceived;
                
                // DisconnectAsync가 Task를 반환하므로, 동기적으로 기다리려면 Wait() 사용 (UI 스레드에서 직접 호출 시 주의)
                // 여기서는 ViewModel의 Cleanup이므로 애플리케이션 종료 시 호출된다고 가정.
                try
                {
                    Task.Run(async () => await _brokerClientService.DisconnectAsync()).Wait(TimeSpan.FromSeconds(2)); 
                }
                catch (Exception ex) { AddUiLog($"Error during broker disconnect on cleanup: {ex.Message}");}

                (_brokerClientService as IDisposable)?.Dispose();
            }
        }
    }
}
MainViewModel.cs 주요 변경점:

CanUserManageAgentsProperty와 CanUserControlPowerProperty를 각각 CanManageAgents와 CanControlPower라는 이름의 읽기 전용 bool 속성으로 변경하고, 생성자에서 _currentUserSession을 통해 값을 받아 초기화합니다. XAML에서는 이 bool 속성에 BooleanToVisibilityConverter를 사용하게 됩니다.
각 RelayCommand의 CanExecute 조건에서 이 새로운 bool 속성 (CanManageAgents, CanControlPower)을 정확히 참조하도록 수정했습니다.
SelectedAgent 속성 변경 시 및 BrokerConnectionStatus 변경 시 관련된 커맨드들의 CanExecuteChanged를 호출하여 버튼 활성화 상태를 동적으로 업데이트하기 위해 RefreshCommandStates() 메서드를 추가하고 호출하는 부분을 넣었습니다.
로그 메시지 처리 및 DB 로깅 관련 로직을 좀 더 상세화했습니다. (특히 UpdateControlActionLogAsync는 CorrelationID를 사용하여 기존 로그를 업데이트하는 방식으로 개선이 필요합니다. 현재는 새 로그를 생성할 수 있습니다.)