수정된 MainViewModelPop1 코드에서 Dispatcher.Invoke를 사용해 모든 UI 업데이트를 UI 스레드에서 처리하도록 합니다.

수정된 MainViewModelPop1 코드
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media;
using System.Timers;

namespace YourNamespace
{
    public class MainViewModelPop1 : INotifyPropertyChanged
    {
        public event Action<string, bool> ErrorTriggeredPop1; // 에러 발생/해결 이벤트 (메시지, 추가 여부)

        private System.Timers.Timer _delayTimerPop1; // 3초 지연 타이머
        private WarningWindowPop1 _warningWindowPop1; // 경고창 인스턴스 저장
        private ObservableCollection<ErrorMessagePop1> _errorMessagesPop1; // 에러 메시지 목록

        public MainViewModelPop1()
        {
            _delayTimerPop1 = new System.Timers.Timer(3000);
            _delayTimerPop1.Elapsed += DelayTimerElapsedPop1;
            _delayTimerPop1.AutoReset = false;

            _errorMessagesPop1 = new ObservableCollection<ErrorMessagePop1>();

            // 에러 발생/해결 이벤트 구독
            ErrorTriggeredPop1 += HandleErrorEventPop1;
        }

        // 에러 이벤트 처리 (추가 또는 제거)
        private void HandleErrorEventPop1(string message, bool isAdd)
        {
            if (isAdd)
            {
                Application.Current.Dispatcher.Invoke(() => AddErrorMessagePop1(message));
            }
            else
            {
                Application.Current.Dispatcher.Invoke(() => RemoveErrorMessagePop1(message));
            }
        }

        private void AddErrorMessagePop1(string message)
        {
            if (_errorMessagesPop1.Any(m => m.ContentPop1 == message)) return;

            Color color = _errorMessagesPop1.Count % 2 == 0 ? Colors.Yellow : Colors.Aqua;
            _errorMessagesPop1.Add(new ErrorMessagePop1(message, new SolidColorBrush(color)));

            if (_errorMessagesPop1.Count == 1)
            {
                ShowWarningWindowPop1(); // 첫 메시지 추가 시 창 표시
            }
            else
            {
                UpdateWarningWindowPop1(); // 메시지 추가 시 창 업데이트
            }

            Debug.WriteLine($"[DEBUG] Error added: {message}");
        }

        private void RemoveErrorMessagePop1(string message)
        {
            var errorMessagePop1 = _errorMessagesPop1.FirstOrDefault(m => m.ContentPop1 == message);
            if (errorMessagePop1 != null)
            {
                _errorMessagesPop1.Remove(errorMessagePop1);
                Debug.WriteLine($"[DEBUG] Error removed: {message}");

                if (_errorMessagesPop1.Count == 0)
                {
                    CloseWarningWindowPop1(); // 메시지가 없으면 창 닫기
                }
                else
                {
                    UpdateWarningWindowPop1(); // 메시지 제거 시 창 업데이트
                }
            }
        }

        private void ShowWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _warningWindowPop1 = new WarningWindowPop1(_errorMessagesPop1);
                _warningWindowPop1.Topmost = true;
                _warningWindowPop1.Show();

                _warningWindowPop1.Closed += (sender, e) =>
                {
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed");
                };

                Debug.WriteLine("[DEBUG] Warning window shown");
            });
        }

        private void UpdateWarningWindowPop1()
        {
            if (_warningWindowPop1 != null)
            {
                Application.Current.Dispatcher.Invoke(() =>
                {
                    _warningWindowPop1.UpdateMessagesPop1(_errorMessagesPop1);
                    Debug.WriteLine("[DEBUG] Warning window updated");
                });
            }
        }

        private void CloseWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_warningWindowPop1 != null)
                {
                    _warningWindowPop1.Close();
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed and messages cleared");
                }
            });
        }

        private void DelayTimerElapsedPop1(object sender, ElapsedEventArgs e)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessagesPop1.Count > 0)
                {
                    ShowWarningWindowPop1();
                }
            });
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ErrorMessagePop1
    {
        public string ContentPop1 { get; }
        public SolidColorBrush ColorPop1 { get; }

        public ErrorMessagePop1(string content, SolidColorBrush color)
        {
            ContentPop1 = content;
            ColorPop1 = color;
        }
    }
}
변경 사항
UI 관련 모든 업데이트: AddErrorMessagePop1, RemoveErrorMessagePop1, ShowWarningWindowPop1, UpdateWarningWindowPop1, CloseWarningWindowPop1 메서드 내에서 Application.Current.Dispatcher.Invoke를 사용하여 UI 스레드에서 실행되도록 보장했습니다.
타이머 콜백 수정: DelayTimerElapsedPop1 메서드에서도 Application.Current.Dispatcher.Invoke를 사용하여 창을 UI 스레드에서 표시합니다.
이제 모든 UI 관련 작업이 UI 스레드에서 실행되므로 DependencyObject 관련 예외가 발생하지 않을 것입니다. 이 수정이 문제를 해결하는 데 도움이 될 것으로 기대됩니다.










