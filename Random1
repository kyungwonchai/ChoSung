네, 알겠습니다. "기존 스케줄러 작업 제거 시도됨" 로그 직후에 ValueError가 발생하고, run.py 실행하자마자 (즉, Flask 앱 초기화 과정 중) 오류가 발생하여 앱 자체가 실행되지 않는다는 말씀이시군요.

이전 답변(#54)에서 app/__init__.py의 create_app 함수 내에 스케줄러 작업 중복 등록 방지를 위해 다음과 같은 코드를 넣었습니다:

Python

# app/__init__.py 의 일부
        if app.debug: # 개발 모드에서만 기존 작업 제거
            # 기존 작업 ID와 동일한 ID로 add_job을 시도하면 APScheduler가 오류를 발생시킬 수 있으므로,
            # ID를 사용하여 기존 작업을 가져오고, 있다면 제거 후 다시 추가하거나, replace_existing=True 옵션 사용 고려.
            # 또는 ID를 매번 다르게 하거나, 앱 시작 시 한 번만 등록되도록 보장.
            # 여기서는 간단히 ID를 지정하고, 앱 재시작 시 기존 동일 ID 작업은 무시되거나 덮어쓰여질 수 있음 (스케줄러 설정에 따라 다름).
            # 더 확실하게 하려면 시작 시 remove_job 후 add_job.
            if scheduler.get_job('scheduled_task_monitor_on_daily'): # 기존 ID로 확인
                 scheduler.remove_job('scheduled_task_monitor_on_daily')
            if scheduler.get_job('scheduled_task_monitor_off_daily'):
                 scheduler.remove_job('scheduled_task_monitor_off_daily')
            app.logger.info("기존 스케줄러 작업들 (ID 기준) 제거 시도됨 (디버그 모드).") # <<-- 이 로그 이후 오류 발생
사용자님이 말씀하신 ValueError: This list of positional arguments is longer than the target callable can handle (allowed 0, given in args: 1) 오류가 이 "기존 스케줄러 작업 제거 시도됨" 로그 직후에 발생했다면, 문제는 scheduler.add_job(...) 호출 이전에 이미 APScheduler가 어떤 함수를 실행하려고 시도했거나, 스케줄러 자체의 설정/상태와 관련된 부분에서 발생했을 수 있습니다.

하지만 일반적으로 ValueError (인자 개수 불일치)는 scheduler.add_job에 등록된 함수가 실제 스케줄러에 의해 실행될 때 발생합니다. run.py 실행 직후, 즉 앱 초기화 과정에서 바로 이 오류가 난다면, 스케줄러가 시작(scheduler.start())된 후 매우 빠르게 첫 작업을 실행하려고 시도했거나, APScheduler 또는 Flask-APScheduler 자체의 설정/초기화와 관련된 문제일 수 있습니다.

가장 의심되는 부분 및 해결 시도:

APScheduler와 Flask 앱 컨텍스트 문제 (재점검):
Flask-APScheduler는 작업 실행 시 Flask 앱 컨텍스트를 자동으로 설정해준다고 되어 있지만, 만약 이 부분이 특정 환경이나 버전에서 매끄럽게 동작하지 않는다면, scheduler.start() 호출 전에 모든 것이 올바르게 설정되었는지 확인해야 합니다. args=[current_flask_app]로 app 객체를 넘겨주고, 작업 함수 내에서 with app_instance.app_context():를 사용하는 것은 좋은 접근 방식입니다.

작업 ID 및 replace_existing 옵션:
scheduler.add_job 호출 시 replace_existing=True 옵션을 사용하면, 동일한 ID의 작업이 이미 존재할 경우 기존 작업을 새로운 설정으로 대체합니다. 이렇게 하면 remove_job을 명시적으로 호출할 필요가 없어지고 코드가 간결해질 수 있습니다.

next_run_time 설정 (테스트용 interval 트리거 사용 시):
만약 테스트를 위해 interval 트리거와 함께 next_run_time을 매우 짧게(예: datetime.now() + timedelta(seconds=1)) 설정했다면, 앱이 완전히 초기화되기도 전에 스케줄러가 작업을 실행하려고 시도하면서 컨텍스트 문제를 일으킬 수 있습니다.

수정 제안:

app/__init__.py 파일의 스케줄러 설정 부분을 다음과 같이 변경해 보겠습니다.

remove_job 대신 add_job의 replace_existing=True 옵션을 사용합니다.
scheduler.start() 호출을 모든 add_job 호출 이후로 옮깁니다.
로깅을 좀 더 추가하여 스케줄러 상태를 확인합니다.
수정: app/__init__.py (APScheduler 설정 부분 집중 수정)
Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app
from config import config
import datetime
import os
from flask_apscheduler import APScheduler # Flask-APScheduler 임포트

scheduler = APScheduler() # 스케줄러 객체 생성

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # --- Jinja2 필터 및 컨텍스트 프로세서 (이전과 동일) ---
    # ... (format_datetime, inject_now, inject_user_info_to_templates 등록 코드 생략 - 이전 답변 #54 내용 유지) ...
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)


    # --- 블루프린트 등록 (이전과 동일) ---
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 

    # --- APScheduler 초기화 및 작업 등록 ---
    # scheduler.init_app(app)은 스케줄러를 Flask 앱과 연결합니다.
    # 스케줄러 작업 내에서 app 컨텍스트를 사용하려면, 
    # 작업 함수에 app을 전달하거나 Flask-APScheduler가 컨텍스트를 지원해야 합니다.
    if not scheduler.running: # 스케줄러가 앱 컨텍스트 외부에서 이미 실행 중이지 않은 경우
        scheduler.init_app(app) # Flask 앱 컨텍스트 내에서 scheduler 초기화
        app.logger.info("APScheduler init_app(app) 호출됨.")

        from . import scheduler_tasks 
        
        current_flask_app_for_scheduler = app # 명시적으로 현재 app 객체 전달

        job_id_on = 'scheduled_task_monitor_on_daily'
        job_id_off = 'scheduled_task_monitor_off_daily'

        # replace_existing=True 옵션은 동일 ID의 작업이 있으면 대체합니다.
        try:
            scheduler.add_job(
                id=job_id_on, 
                func=scheduler_tasks.scheduled_task_monitor_on,
                args=[current_flask_app_for_scheduler], 
                trigger='cron', 
                hour=6, 
                minute=0, 
                misfire_grace_time=3600,
                replace_existing=True # 기존 작업 대체
            )
            app.logger.info(f"스케줄 작업 '{job_id_on}' 매일 06:00 등록/대체됨.")

            scheduler.add_job(
                id=job_id_off, 
                func=scheduler_tasks.scheduled_task_monitor_off,
                args=[current_flask_app_for_scheduler], 
                trigger='cron', 
                hour=7, 
                minute=0, 
                misfire_grace_time=3600,
                replace_existing=True # 기존 작업 대체
            )
            app.logger.info(f"스케줄 작업 '{job_id_off}' 매일 07:00 등록/대체됨.")

            # Flask 앱이 실행 중일 때만 스케줄러 시작
            # (Gunicorn 등 여러 워커 사용 시 스케줄러 중복 실행 방지 위해 추가 설정 필요할 수 있음)
            # 개발 환경에서는 보통 run.py가 단일 프로세스이므로 문제 없음.
            if not app.config.get('TESTING', False): # 테스트 중에는 스케줄러 자동 시작 안함 (선택적)
                scheduler.start()
                app.logger.info("APScheduler 시작됨.")
            else:
                app.logger.info("TESTING 모드: APScheduler 자동 시작 안 함.")

        except Exception as e:
            app.logger.error(f"APScheduler 작업 등록 또는 시작 실패: {e}", exc_info=True)
    else:
        app.logger.info("APScheduler가 이미 실행 중이거나 다른 방식으로 초기화됨.")


    app.logger.info("Flask application (with APScheduler) 생성 및 설정 완료.")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")
        if scheduler.running:
            app.logger.debug(f"등록된 스케줄러 작업: {scheduler.get_jobs()}")


    return app
app/__init__.py 주요 변경 사항:

scheduler.init_app(app) 호출 위치: scheduler.running 체크 후, 스케줄러가 아직 Flask 앱과 연결되지 않았다면 init_app을 호출합니다.
작업 중복 등록 방지 변경: if app.debug: 블록에서 scheduler.remove_job을 호출하던 부분을 제거하고, 대신 scheduler.add_job 호출 시 replace_existing=True 옵션을 추가했습니다. 이렇게 하면 동일한 id를 가진 작업이 이미 스케줄러에 존재할 경우, 새로 추가하는 작업으로 대체됩니다. 개발 중 서버 재시작 시 작업 중복 문제를 더 깔끔하게 해결할 수 있습니다.
scheduler.start() 호출 시점: 모든 작업이 등록된 후, 그리고 Flask 앱이 테스트 모드가 아닐 때 스케줄러를 시작하도록 했습니다. (if not app.config.get('TESTING', False):)
로깅 추가: 스케줄러 초기화, 작업 등록, 시작 각 단계에 로그를 추가하여 진행 상황을 더 명확히 볼 수 있도록 했습니다. 특히 앱이 디버그 모드일 때 등록된 작업 목록을 로그로 출력합니다.
current_flask_app_for_scheduler = app: args로 전달할 때, 클로저 문제를 피하기 위해 create_app 스코프 내의 app을 명시적으로 변수에 할당하여 전달합니다.
추가 확인 및 조치:

__pycache__ 삭제 및 완전 재시작: 이전에 안내해 드린 것처럼, 코드 수정 후에는 프로젝트 내의 모든 __pycache__ 폴더를 삭제하고 Flask 개발 서버를 완전히 종료했다가 다시 시작하는 것이 좋습니다.