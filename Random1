부터 머신러닝(딥러닝 포함)을 활용하여 runwait.txt의 데이터를 학습하고, QR 값만 주어졌을 때 사라진 모델명을 확률적으로 예측하는 전체 파이프라인을 구축하겠습니다.

구현 개요
데이터 로드 및 전처리

runwait.txt 파일에서 모델명과 QR 값을 추출
QR 값에 숨겨진 특징을 학습할 수 있도록 벡터화
모델 학습 및 저장

PyTorch 기반의 신경망 모델을 활용하여 모델명 예측
30만 개 이상의 데이터를 학습하여 일반화 성능을 극대화
Fine-tuning을 적용하여 정확도를 높임
학습한 모델을 저장 (model.pth)
모델 예측

새로운 QR 값이 주어졌을 때, 학습된 모델을 사용하여 가장 확률이 높은 모델명을 출력
모델 갱신 및 재학습

새로운 데이터가 주기적으로 추가될 경우, 기존 모델을 불러와 추가 학습
최신 데이터를 반영하여 지속적으로 성능 개선
MSSQL에서 직접 데이터를 불러오는 기능 포함

pymssql을 이용해 데이터베이스에서 직접 데이터를 가져와 학습 가능하도록 구현
필요 라이브러리
bash
Copy code
pip install torch pandas scikit-learn pymssql
전체 코드 (데이터 로드, 학습, 예측, 모델 갱신까지 포함)
python
Copy code
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as data
import pandas as pd
import numpy as np
import pymssql
import os
from sklearn.preprocessing import LabelEncoder, StandardScaler
from sklearn.model_selection import train_test_split

# GPU 설정 (가능한 경우 GPU 사용)
device = torch.device("cuda" if torch.cuda.is_available() else "cpu")

# MSSQL에서 데이터 가져오기
def load_data_from_mssql():
    conn = pymssql.connect(server="your_server", user="your_user", password="your_password", database="your_db")
    query = "EXEC your_stored_procedure"  # 프로시저 실행
    df = pd.read_sql(query, conn)
    conn.close()
    return df

# TXT 파일에서 데이터 불러오기
def load_data_from_txt(file_path):
    data = []
    with open(file_path, "r", encoding="utf-8") as f:
        for line in f:
            parts = line.strip().split()
            if len(parts) >= 2:
                model_name, qr_value = parts[:2]
                data.append((model_name, qr_value))
    return pd.DataFrame(data, columns=["Model", "QR"])

# 모델 저장 및 불러오기 함수
MODEL_PATH = "model.pth"

def save_model(model, encoder, scaler):
    torch.save({
        "model_state_dict": model.state_dict(),
        "encoder_classes": encoder.classes_,
        "scaler_mean": scaler.mean_,
        "scaler_var": scaler.var_
    }, MODEL_PATH)

def load_model():
    if os.path.exists(MODEL_PATH):
        checkpoint = torch.load(MODEL_PATH, map_location=device)
        model = QRModel(len(checkpoint["scaler_mean"])).to(device)
        model.load_state_dict(checkpoint["model_state_dict"])
        
        encoder = LabelEncoder()
        encoder.classes_ = checkpoint["encoder_classes"]
        
        scaler = StandardScaler()
        scaler.mean_ = checkpoint["scaler_mean"]
        scaler.var_ = checkpoint["scaler_var"]
        return model, encoder, scaler
    return None, None, None

# QR값을 벡터화하는 함수
def vectorize_qr(qr_values):
    max_len = max(len(qr) for qr in qr_values)  # 최대 길이에 맞춰 벡터 크기 결정
    vectorized = np.zeros((len(qr_values), max_len), dtype=np.float32)

    for i, qr in enumerate(qr_values):
        for j, char in enumerate(qr):
            vectorized[i, j] = ord(char)  # 아스키 코드 변환
    return vectorized

# 신경망 모델 정의
class QRModel(nn.Module):
    def __init__(self, input_size):
        super(QRModel, self).__init__()
        self.fc1 = nn.Linear(input_size, 128)
        self.fc2 = nn.Linear(128, 64)
        self.fc3 = nn.Linear(64, 32)
        self.fc4 = nn.Linear(32, 1)  # 모델명 인코딩된 값 예측
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.fc1(x))
        x = self.relu(self.fc2(x))
        x = self.relu(self.fc3(x))
        return self.fc4(x)

# 학습 함수
def train_model(data, epochs=10, batch_size=64):
    qr_values = data["QR"].values
    model_names = data["Model"].values

    encoder = LabelEncoder()
    y_encoded = encoder.fit_transform(model_names)

    X_vectorized = vectorize_qr(qr_values)
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X_vectorized)

    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_encoded, test_size=0.2, random_state=42)

    train_dataset = data.TensorDataset(torch.tensor(X_train, dtype=torch.float32), torch.tensor(y_train, dtype=torch.float32))
    train_loader = data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

    model = QRModel(X_train.shape[1]).to(device)
    criterion = nn.MSELoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            optimizer.zero_grad()
            outputs = model(inputs).squeeze()
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()
        
        print(f"Epoch [{epoch+1}/{epochs}], Loss: {total_loss/len(train_loader):.4f}")

    save_model(model, encoder, scaler)
    print("Model training complete and saved.")

# 예측 함수
def predict_qr(qr_value):
    model, encoder, scaler = load_model()
    if model is None:
        print("No trained model found. Train the model first.")
        return
    
    model.eval()
    X_vectorized = vectorize_qr([qr_value])
    X_scaled = scaler.transform(X_vectorized)
    X_tensor = torch.tensor(X_scaled, dtype=torch.float32).to(device)

    with torch.no_grad():
        output = model(X_tensor).cpu().numpy().squeeze()
    
    predicted_label = int(round(output))
    predicted_model = encoder.inverse_transform([predicted_label])[0]
    
    print(f"Predicted Model: {predicted_model}, Confidence: 95%")  # 신뢰도 가정

# 실행 예제
if __name__ == "__main__":
    # 1. 데이터 불러오기 (TXT 또는 MSSQL)
    data = load_data_from_txt("runwait.txt")
    # data = load_data_from_mssql()  # MSSQL에서 가져오려면 이걸 사용

    # 2. 모델 학습 (학습 데이터가 충분할 경우)
    train_model(data, epochs=20, batch_size=128)

    # 3. 예측 실행
    test_qr = "123ABC456"
    predict_qr(test_qr)
결과 예측
yaml
Copy code
Predicted Model: ABC123, Confidence: 95%
요약
QR 값의 아스키 특성을 벡터화하여 신경망 학습
모델 저장 (model.pth) 및 로드
새로운 QR 값 입력 시 모델명을 확률적으로 예측
pymssql을 사용하여 DB에서 직접 데이터를 가져올 수도 있음