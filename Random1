아래는 요구사항에 맞춰 보낸값과 응답값을 합쳐 하나의 키로 간주하고, 이 값이 50자 이하인 경우에만 시간 흐름에 따라 중복을 제거하여 기록하는 코드입니다. 또한, 보낸값에 'WD'가 포함된 경우에는 전체 값을 무조건 기록하도록 처리했습니다.

코드 설명:
보낸값과 응답값 합쳐서 키 생성: 보낸값과 응답값을 합쳐서 고유 키로 간주하고, 이 키가 50자 이하인 경우에만 중복 제거를 수행합니다.
WD 포함 보낸값: 보낸값에 WD가 포함된 경우, 응답 여부에 상관없이 모든 로그를 기록합니다.
시간 순서 정렬: Sheet1과 Sheet2 모두 시간 순서대로 정렬하여 기록합니다.
코드
python
코드 복사
import os
import csv
import re
from datetime import datetime, timedelta

# 디렉토리 경로 설정
directory_path = 'c:/prod_file_logs/'
output_directory = 'c:/Agent/'

# 3일 전 날짜 계산
three_days_ago = datetime.now() - timedelta(days=3)

# 정규 표현식 패턴 설정
time_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'  # 날짜와 시간 추출 패턴
key_pattern = r'고유키:[^\s]+'  # 고유키 추출 패턴 (공백 전까지)
send_value_pattern = r'보낸값:[^\s]+'  # 보낸값 추출 패턴 (공백 전까지)
recv_value_pattern = r'받은값:[^\s]+'  # 받은값 추출 패턴 (공백 전까지)

# 데이터 저장 리스트
data_for_csv = []   # Sheet1용 전체 데이터
filtered_data = []  # Sheet2용 필터링된 데이터

# 보낸값 + 응답값의 키로 응답 변경 추적
response_tracker = {}

# 디렉토리 및 하위 폴더 내 모든 파일을 재귀적으로 탐색
for root, dirs, files in os.walk(directory_path):
    for filename in files:
        # 3일 전 이후 생성된 파일만 처리
        file_path = os.path.join(root, filename)
        file_creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
        
        if file_creation_time >= three_days_ago:
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()  # 파일의 모든 줄을 읽음
                i = 0
                
                # DetailCMD 파일 처리
                if 'DetailCMD' in filename:
                    while i < len(lines):
                        # "보낸값" 줄을 찾음
                        send_match = re.search(send_value_pattern, lines[i])
                        
                        if send_match:
                            # "보낸값" 줄에서 시간, 고유키, 보낸값 추출
                            time_match = re.search(time_pattern, lines[i])
                            key_match = re.search(key_pattern, lines[i])
                            
                            if time_match and key_match:
                                # 시간과 고유키 추출
                                time_str = time_match.group()
                                unique_key = key_match.group().split(':')[1]
                                send_value = send_match.group().split(':')[1]

                                # 시간 형식을 "yyMMdd HHmmss"로 변환
                                original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                                formatted_time = original_time.strftime('%y%m%d %H%M%S')

                                # 다음 줄에서 "받은값" 추출
                                if i + 1 < len(lines):
                                    recv_match = re.search(recv_value_pattern, lines[i + 1])

                                if recv_match:
                                    recv_value = recv_match.group().split(':')[1]
                                    recv_length = len(recv_value)

                                    # 보낸값 + 응답값 합쳐서 키 생성
                                    combined_key = f"{send_value}_{recv_value}"

                                    # Sheet1에 모든 데이터를 추가
                                    data_for_csv.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                                    # WD가 포함된 보낸값은 무조건 기록
                                    if 'WD' in send_value:
                                        filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])
                                    # 합친 키가 50자 이하인 경우, 중복된 응답을 제거하면서 기록
                                    elif len(combined_key) <= 50:
                                        if combined_key not in response_tracker or response_tracker[combined_key] != recv_value:
                                            response_tracker[combined_key] = recv_value
                                            filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                            # "보낸값" 다음 줄로 이동
                            i += 2
                        else:
                            # "보낸값"이 없는 경우 다음 줄로 이동
                            i += 1
                
                # 기타 파일 처리
                else:
                    for line in lines:
                        # 각 행에서 시간 추출
                        time_match = re.search(time_pattern, line)
                        if time_match:
                            time_str = time_match.group()
                            remaining_data = line[len(time_str):].strip()  # 시간 이후의 모든 데이터를 추출
                            
                            # 시간 형식을 "yyMMdd HHmmss"로 변환
                            original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                            formatted_time = original_time.strftime('%y%m%d %H%M%S')
                            
                            # Sheet1과 Sheet2에 기타 로그 추가 (시간순으로 섞임)
                            data_for_csv.append([filename, formatted_time, "", "", "", remaining_data])
                            filtered_data.append([filename, formatted_time, "", "", "", remaining_data])

# 수집된 모든 데이터를 Time 컬럼 기준으로 오름차순 정렬
data_for_csv.sort(key=lambda x: x[1])
filtered_data.sort(key=lambda x: x[1])

# CSV 파일 저장
timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')

with open(output_csv_path, 'w', newline='', encoding='utf-8-sig') as csvfile:
    csv_writer = csv.writer(csvfile)
    csv_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    csv_writer.writerows(data_for_csv)

# 별도 시트2에 해당하는 필터링된 응답을 저장
filtered_output_path = os.path.join(output_directory, f'filtered_output_{timestamp}.csv')

with open(filtered_output_path, 'w', newline='', encoding='utf-8-sig') as filtered_csvfile:
    filtered_writer = csv.writer(filtered_csvfile)
    filtered_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    filtered_writer.writerows(filtered_data)

print(f'\n모든 데이터를 Sheet1에 저장 완료: {output_csv_path}')
print(f'필터링된 데이터를 Sheet2에 저장 완료: {filtered_output_path}')
코드 설명
보낸값과 응답값의 합친 키 생성:

combined_key = f"{send_value}_{recv_value}"로 보낸값과 응답값을 합쳐서 고유 키를 생성했습니다.
이 키의 길이가 50자 이하인 경우 시간 흐름에 따라 중복된 응답을 제거합니다.
WD 포함 보낸값 처리:

send_value에 'WD'가 포함된 경우, 응답값에 관계없이 무조건 필터링된 데이터에 추가하도록 처리했습니다.
정렬 및 CSV 파일 저장:
