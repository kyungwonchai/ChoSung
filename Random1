 이해했어! 이번엔 논리 흐름부터 정확하게 짚고, MSSQL 2014 쿼리를 초정밀하게 주석과 함께 설계해줄게.

[1. 데이터 구조 정리]
컬럼명	설명
line1~edition1	고유 모델 기준 키
time1	10분 간격 측정 시간
ACT2_1~8	CycleTime 측정값 (float)
ACT2BEST_1~8	다른 CT 측정값 (float)
[2. 목표]
Step 1. 최근 5시간의 데이터만 사용
Step 2. 각 고유 모델별 (line1, model1, type1, ecn1, edition1) 기준으로:
ACT2_1~8:

0 이상만 사용

Q1~Q3 범위만 유지 (이상치 제거)

→ 그 중 최댓값 1개 추출

→ → 다시 그 최댓값들 중에서 가장 작은 값 1개만

ACT2BEST_1~8:

위와 동일한 방식으로 다시 따로 처리

Step 3. 최종 결과:
고유 모델키 +
MAX_ACT2, MAX_ACT2BEST, CTDIFF = MAX_ACT2 - MAX_ACT2BEST

[3. 핵심 요점 주의]
ACT2와 ACT2BEST는 따로 최솟값 계산됨

둘 다 time1이 다를 수 있음

즉, 같은 행의 데이터가 아님!!

[4. 최종 출력 예시]
line1	model1	type1	ecn1	edition1	MAX_ACT2	MAX_ACT2BEST	CTDIFF
SMD12	A100	PKG1	E101	Rev1	0.53	0.49	0.04
[5. MSSQL 2014 쿼리 (주석 완전 상세)]
sql
코드 복사
-- Step 1: 최근 5시간 이내의 원본 데이터 필터링
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- Step 2: ACT2 그룹만 펼쳐서 이상치 제거 준비
ACT2Unpivoted AS (
    SELECT line1, model1, type1, ecn1, edition1, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2_1, ACT2_2, ACT2_3, ACT2_4,
            ACT2_5, ACT2_6, ACT2_7, ACT2_8
        )
    ) AS u
    WHERE Value > 0
),

-- Step 3: ACT2 컬럼별 Q1~Q3 기반 이상치 제거
ACT2Filtered AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3
    FROM (
        SELECT line1, model1, type1, ecn1, edition1, ColName, Value
        FROM RawData
        UNPIVOT (
            Value FOR ColName IN (
                ACT2_1, ACT2_2, ACT2_3, ACT2_4,
                ACT2_5, ACT2_6, ACT2_7, ACT2_8
            )
        ) AS u
        WHERE Value > 0
    ) AS Pre
),

-- Step 4: ACT2 → 컬럼별 이상치 제거된 값 중 최대값 → 다시 전체 중 최소
ACT2Final AS (
    SELECT
        line1, model1, type1, ecn1, edition1,
        MIN(MaxVal) AS Max_ACT2
    FROM (
        SELECT
            line1, model1, type1, ecn1, edition1, ColName,
            MAX(Value) AS MaxVal
        FROM ACT2Filtered
        WHERE Value BETWEEN Q1 AND Q3
        GROUP BY line1, model1, type1, ecn1, edition1, ColName
    ) AS MaxPerCol
    GROUP BY line1, model1, type1, ecn1, edition1
),

-- Step 5: ACT2BEST도 동일 처리
ACT2BESTFiltered AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3
    FROM (
        SELECT line1, model1, type1, ecn1, edition1, ColName, Value
        FROM RawData
        UNPIVOT (
            Value FOR ColName IN (
                ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
                ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
            )
        ) AS u
        WHERE Value > 0
    ) AS Pre
),

ACT2BESTFinal AS (
    SELECT
        line1, model1, type1, ecn1, edition1,
        MIN(MaxVal) AS Max_ACT2BEST
    FROM (
        SELECT
            line1, model1, type1, ecn1, edition1, ColName,
            MAX(Value) AS MaxVal
        FROM ACT2BESTFiltered
        WHERE Value BETWEEN Q1 AND Q3
        GROUP BY line1, model1, type1, ecn1, edition1, ColName
    ) AS MaxPerCol
    GROUP BY line1, model1, type1, ecn1, edition1
)

-- Step 6: 두 결과를 조인해서 Diff 계산
SELECT
    A.line1, A.model1, A.type1, A.ecn1, A.edition1,
    A.Max_ACT2,
    B.Max_ACT2BEST,
    (A.Max_ACT2 - B.Max_ACT2BEST) AS CTDIFF
FROM ACT2Final A
JOIN ACT2BESTFinal B
    ON A.line1 = B.line1 AND A.model1 = B.model1 AND
       A.type1 = B.type1 AND A.ecn1 = B.ecn1 AND A.edition1 = B.edition1
ORDER BY line1, model1, type1, ecn1, edition1;
요약
Max_ACT2 = ACT2_18 중 Q1Q3 내의 최대값들 중 최솟값

Max_ACT2BEST = ACT2BEST_18 중 Q1Q3 내 최대값들 중 최솟값

CTDIFF = 두 값의 차이

각 모델 키별로 한 줄씩 결과

이제 계산은 정말 정확해.