네, 알겠습니다. Agent들을 제어하고 모니터링하기 위한 UI 프로그램, 솔루션명 MGSPMonitorControl의 전체 코드를 구성해 드리겠습니다.

이 프로그램은 다음과 같은 주요 기능을 목표로 합니다:

SignalR Hub 호스팅: Agent(MonitorAgent)들이 연결할 수 있는 SignalR 서버 역할을 합니다.
Agent 관리: 연결된 Agent들의 목록과 상태(ID, 역할, 모니터 상태, IP 주소, 마지막 하트비트 등)를 UI에 표시합니다.
명령 전송: 선택한 Agent 또는 전체 Agent에게 모니터 켜기/끄기 등의 명령을 전송합니다.
실시간 업데이트: Agent의 상태 변경이나 연결 상태를 UI에 실시간으로 반영합니다.
기술적으로는 WPF 애플리케이션으로 UI를 구성하고, OWIN을 사용한 Self-Hosting 방식으로 SignalR Hub를 애플리케이션 내에서 직접 실행하겠습니다. 데이터 저장은 초기 버전에서는 인메모리 방식으로 간단하게 처리하고, 필요시 추후 데이터베이스 연동으로 확장할 수 있습니다.

프로젝트 구성 단계:

새로운 WPF 애플리케이션 프로젝트 생성 (MGSPMonitorControl, .NET Framework 4.5)
필요한 NuGet 패키지 설치
SignalR Hub 클래스 구현 (MonitorControlHub.cs)
OWIN Startup 클래스 구현 (Startup.cs)
Agent 정보 모델 클래스 구현 (AgentClient.cs)
메인 윈도우 UI 디자인 (MainWindow.xaml)
메인 윈도우 로직 및 Hub 연동 (MainWindow.xaml.cs)
애플리케이션 시작/종료 로직 (App.xaml.cs)
단계 1: 새 WPF 애플리케이션 프로젝트 생성

Visual Studio를 엽니다.
"새 프로젝트 만들기"를 선택합니다.
"WPF 앱(.NET Framework)" 템플릿을 선택하고 "다음"을 누릅니다.
프로젝트 이름: MGSPMonitorControl
솔루션 이름: MGSPMonitorControl (또는 원하는 이름)
프레임워크: ".NET Framework 4.5" (Agent와 동일하게)
"만들기"를 클릭합니다.
단계 2: 필요한 NuGet 패키지 설치

프로젝트에 다음 NuGet 패키지들을 설치해야 합니다.
솔루션 탐색기에서 프로젝트 이름을 마우스 오른쪽 버튼으로 클릭 -> "NuGet 패키지 관리..." 선택 -> "찾아보기" 탭에서 다음 패키지들을 검색하여 설치합니다.

Microsoft.AspNet.SignalR.SelfHost (OWIN Self-Host 관련 패키지들을 자동으로 가져옴)
Microsoft.Owin.Cors (크로스 도메인 허용을 위함, 필요시)
Newtonsoft.Json (이미 SignalR의 의존성으로 설치될 수 있음, Agent와 데이터 교환 시 사용)
설치 명령어 (패키지 관리자 콘솔):

PowerShell

Install-Package Microsoft.AspNet.SignalR.SelfHost
Install-Package Microsoft.Owin.Cors
Install-Package Newtonsoft.Json
이제 각 파일의 코드를 작성해 나가겠습니다. 먼저 모델과 Hub부터 시작하겠습니다.

2.1. Models/AgentClient.cs (Agent 정보 모델)

UI에 표시하고 관리할 Agent의 정보를 담는 클래스입니다. INotifyPropertyChanged를 구현하여 UI가 변경 사항을 자동으로 감지하도록 합니다.

C#

// MGSPMonitorControl/Models/AgentClient.cs
using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace MGSPMonitorControl.Models
{
    public class AgentClient : INotifyPropertyChanged
    {
        private string _agentId;
        public string AgentId
        {
            get => _agentId;
            set { _agentId = value; OnPropertyChanged(); }
        }

        private string _connectionId; // SignalR Connection ID
        public string ConnectionId
        {
            get => _connectionId;
            set { _connectionId = value; OnPropertyChanged(); }
        }

        private string _agentRole;
        public string AgentRole
        {
            get => _agentRole;
            set { _agentRole = value; OnPropertyChanged(); }
        }

        private string _statusMessage;
        public string StatusMessage
        {
            get => _statusMessage;
            set { _statusMessage = value; OnPropertyChanged(); }
        }

        private string _monitorStatus;
        public string MonitorStatus
        {
            get => _monitorStatus;
            set { _monitorStatus = value; OnPropertyChanged(); }
        }

        private List<string> _ipAddresses;
        public List<string> IpAddresses
        {
            get => _ipAddresses;
            set { _ipAddresses = value; OnPropertyChanged(); OnPropertyChanged(nameof(IpAddressesString)); }
        }

        public string IpAddressesString => IpAddresses != null ? string.Join(", ", IpAddresses) : string.Empty;


        private DateTime _lastHeartbeat;
        public DateTime LastHeartbeat
        {
            get => _lastHeartbeat;
            set { _lastHeartbeat = value; OnPropertyChanged(); }
        }

        private bool _isConnected;
        public bool IsConnected // 실제 SignalR 연결 상태와는 별개로, 서버에서 관리하는 활성 상태
        {
            get => _isConnected;
            set { _isConnected = value; OnPropertyChanged(); }
        }

        // AgentRegistrationInfo 모델 (Agent에서 사용하는 것과 동일하게 정의 또는 참조)
        // Agent가 RegisterAgent 호출 시 전달하는 정보
        public class AgentRegistrationInfo
        {
            public string AgentId { get; set; }
            public string MachineName { get; set; }
            public string UserName { get; set; }
            public string AgentVersion { get; set; }
            public List<string> IpAddresses { get; set; }
            public string OsVersion { get; set; }
            public string AgentRole { get; set; } // Direct, Gateway, Proxied
            public string InitialMonitorStatus { get; set; } // 예: "On", "Off", "Unknown"
        }
        
        // ServerCommand 모델 (Agent에서 사용하는 것과 동일하게 정의 또는 참조)
        public class ServerCommand
        {
            public string CommandId { get; set; }
            public string CommandType { get; set; } // 예: "SET_MONITOR_ON", "SET_MONITOR_OFF", "UPDATE_CONFIG"
            public string TargetAgentId { get; set; } // "ALL" 또는 특정 AgentId
            public string GatewayAgentId { get; set; } // Proxied Agent인 경우 경유할 Gateway AgentId
            public string Payload { get; set; } // JSON 직렬화된 추가 데이터 (예: 설정 객체)
            public DateTime Timestamp { get; set; }
        }


        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
참고: AgentRegistrationInfo와 ServerCommand는 MonitorAgent 프로젝트의 Models 폴더에 있던 클래스들입니다. 이 프로젝트에서도 동일한 구조의 데이터가 필요하므로, 해당 정의를 가져오거나 공유 라이브러리로 분리하는 것이 좋습니다. 여기서는 편의상 AgentClient.cs 내부에 포함시켰지만, 별도 파일로 분리하는 것을 권장합니다.

2.2. Hubs/MonitorControlHub.cs (SignalR Hub)

Agent들과 직접 통신하는 SignalR Hub입니다.

C#

// MGSPMonitorControl/Hubs/MonitorControlHub.cs
using Microsoft.AspNet.SignalR;
using Microsoft.AspNet.SignalR.Hubs;
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using MGSPMonitorControl.Models; // AgentClient 포함
using Newtonsoft.Json; // JsonSerializerSettings

namespace MGSPMonitorControl.Hubs
{
    [HubName("MonitorControlHub")]
    public class MonitorControlHub : Hub
    {
        // 연결된 Agent들을 관리 (AgentId를 Key로 사용)
        // 값으로는 AgentClient 객체를 저장하여 상세 정보 관리
        private static readonly ConcurrentDictionary<string, AgentClient> ConnectedAgents = new ConcurrentDictionary<string, AgentClient>();

        // UI (MainWindowViewModel 또는 MainWindow)와 Hub 간의 통신을 위한 이벤트들
        public static event Action<AgentClient> AgentConnected;
        public static event Action<string> AgentDisconnected; // agentId
        public static event Action<AgentClient> AgentStatusUpdated; // agentId, statusMessage, monitorStatus
        public static event Action<string, bool, string, string> CommandResultReceived; // commandId, success, message, agentId

        // Agent -> Server 메서드

        public void RegisterAgent(AgentClient.AgentRegistrationInfo regInfo)
        {
            string agentId = regInfo.AgentId;
            string connectionId = Context.ConnectionId;

            var agent = ConnectedAgents.GetOrAdd(agentId, id => new AgentClient { AgentId = id });

            agent.ConnectionId = connectionId;
            agent.AgentRole = regInfo.AgentRole;
            agent.IpAddresses = regInfo.IpAddresses;
            agent.StatusMessage = $"Registered. Machine: {regInfo.MachineName}, User: {regInfo.UserName}, Ver: {regInfo.AgentVersion}";
            agent.MonitorStatus = regInfo.InitialMonitorStatus ?? "Unknown";
            agent.LastHeartbeat = DateTime.UtcNow;
            agent.IsConnected = true;

            Console.WriteLine($"Agent registered: {agentId} ({regInfo.MachineName}) with ConnectionId: {connectionId}");
            AgentConnected?.Invoke(agent); // UI에 알림
            AgentStatusUpdated?.Invoke(agent);

            // 등록 성공 응답 (선택적)
            // Clients.Client(connectionId).SendAsync("RegistrationSuccessful", "Agent registered successfully.");
        }

        public void AgentHeartbeat(string agentId, string agentRole, string statusMessage, string monitorStatus, List<string> ipAddresses)
        {
            if (ConnectedAgents.TryGetValue(agentId, out AgentClient agent))
            {
                agent.ConnectionId = Context.ConnectionId; // 연결이 재수립되었을 수 있으므로 업데이트
                agent.AgentRole = agentRole;
                agent.StatusMessage = statusMessage;
                agent.MonitorStatus = monitorStatus;
                agent.IpAddresses = ipAddresses;
                agent.LastHeartbeat = DateTime.UtcNow;
                agent.IsConnected = true; // 하트비트 수신은 연결된 것으로 간주

                // Console.WriteLine($"Heartbeat from Agent: {agentId}, Status: {monitorStatus}"); // 너무 잦은 로그일 수 있음
                AgentStatusUpdated?.Invoke(agent); // UI에 알림
            }
            else
            {
                Console.WriteLine($"Heartbeat from unknown or disconnected agent: {agentId}. Requesting re-registration.");
                // 알 수 없는 Agent의 하트비트 -> 재등록 요청 또는 무시
                Clients.Client(Context.ConnectionId).InvokeAsync("RequestReRegistration");
            }
        }

        public void ReportCommandResult(string commandId, string sourceAgentId, bool success, string message, string currentMonitorStatus)
        {
            Console.WriteLine($"Command result from {sourceAgentId} (CmdID: {commandId}): Success={success}, Message='{message}', Monitor='{currentMonitorStatus}'");
            CommandResultReceived?.Invoke(commandId, success, message, sourceAgentId); // UI에 알림

            // 해당 Agent의 모니터 상태 업데이트
            if (ConnectedAgents.TryGetValue(sourceAgentId, out AgentClient agent))
            {
                agent.MonitorStatus = currentMonitorStatus;
                agent.StatusMessage = $"Cmd '{commandId}' result: {message}"; // 간단한 상태 메시지 업데이트
                AgentStatusUpdated?.Invoke(agent);
            }
        }

        public void PongFromAgent(string agentId)
        {
            if (ConnectedAgents.TryGetValue(agentId, out AgentClient agent))
            {
                agent.LastHeartbeat = DateTime.UtcNow; // Pong도 하트비트로 간주 가능
                agent.StatusMessage = "Pong received.";
                Console.WriteLine($"Pong received from Agent: {agentId}");
                AgentStatusUpdated?.Invoke(agent);
            }
        }

        // Server -> Agent 메서드 (UI에서 호출하여 특정 Agent에게 명령 전송)

        public static Task SendCommandToAgent(string targetAgentId, AgentClient.ServerCommand command)
        {
            if (ConnectedAgents.TryGetValue(targetAgentId, out AgentClient agent))
            {
                if (agent.IsConnected && !string.IsNullOrEmpty(agent.ConnectionId))
                {
                    var hubContext = GlobalHost.ConnectionManager.GetHubContext<MonitorControlHub>();
                    Console.WriteLine($"Sending command '{command.CommandType}' to Agent {targetAgentId} (ConnId: {agent.ConnectionId})");
                    return hubContext.Clients.Client(agent.ConnectionId).ExecuteCommand(command);
                }
                else
                {
                    Console.WriteLine($"Cannot send command to {targetAgentId}: Agent not connected or ConnectionId is missing.");
                    return Task.FromResult(false);
                }
            }
            Console.WriteLine($"Cannot send command: Agent {targetAgentId} not found.");
            return Task.FromResult(false);
        }
        
        public static Task SendCommandToAllAgents(AgentClient.ServerCommand command)
        {
            var hubContext = GlobalHost.ConnectionManager.GetHubContext<MonitorControlHub>();
            List<Task> tasks = new List<Task>();
            Console.WriteLine($"Sending command '{command.CommandType}' to ALL connected agents.");
            foreach (var agent in ConnectedAgents.Values.Where(a => a.IsConnected && !string.IsNullOrEmpty(a.ConnectionId)))
            {
                // 각 Agent에게 보낼 명령은 TargetAgentId를 해당 Agent의 ID로 설정하는 것이 좋음
                var agentSpecificCommand = JsonConvert.DeserializeObject<AgentClient.ServerCommand>(JsonConvert.SerializeObject(command)); // Deep copy
                agentSpecificCommand.TargetAgentId = agent.AgentId; 
                
                tasks.Add(hubContext.Clients.Client(agent.ConnectionId).ExecuteCommand(agentSpecificCommand));
            }
            return Task.WhenAll(tasks);
        }

        public static Task PingAgent(string targetAgentId)
        {
             if (ConnectedAgents.TryGetValue(targetAgentId, out AgentClient agent))
            {
                if (agent.IsConnected && !string.IsNullOrEmpty(agent.ConnectionId))
                {
                    var hubContext = GlobalHost.ConnectionManager.GetHubContext<MonitorControlHub>();
                    Console.WriteLine($"Pinging Agent {targetAgentId} (ConnId: {agent.ConnectionId})");
                    return hubContext.Clients.Client(agent.ConnectionId).PingAgent();
                }
            }
            return Task.FromResult(false);
        }


        // 연결 관리
        public override Task OnConnected()
        {
            Console.WriteLine($"Client connected: {Context.ConnectionId}. Waiting for agent registration.");
            // Agent가 RegisterAgent를 호출해야 AgentId를 알 수 있음.
            // 필요시, 특정 시간 내에 RegisterAgent 안 하면 연결 종료 로직 추가 가능.
            return base.OnConnected();
        }

        public override Task OnDisconnected(bool stopCalled)
        {
            // 연결이 종료된 ConnectionId를 사용하는 Agent를 찾아서 제거
            var agent = ConnectedAgents.FirstOrDefault(pair => pair.Value.ConnectionId == Context.ConnectionId).Value;
            if (agent != null)
            {
                agent.IsConnected = false; // 연결 끊김 상태로 표시
                // ConnectedAgents.TryRemove(agent.AgentId, out _); // 바로 제거하거나, 일정 시간 후 제거
                Console.WriteLine($"Agent disconnected: {agent.AgentId} (ConnectionId: {Context.ConnectionId})");
                AgentDisconnected?.Invoke(agent.AgentId); // UI에 알림
                AgentStatusUpdated?.Invoke(agent); // UI에 상태 업데이트 (IsConnected = false 반영)
            }
            else
            {
                Console.WriteLine($"Client disconnected: {Context.ConnectionId} (No associated agent found or already removed).");
            }
            return base.OnDisconnected(stopCalled);
        }

        // 현재 연결된 Agent 목록을 가져오는 static 메서드 (UI에서 사용)
        public static IEnumerable<AgentClient> GetConnectedAgents()
        {
            return ConnectedAgents.Values.ToList(); // ToList로 복사본 반환
        }
    }
}
2.3. Startup.cs (OWIN Startup 클래스)

OWIN 파이프라인을 설정하고 SignalR을 매핑합니다.

C#

// MGSPMonitorControl/Startup.cs
using Microsoft.Owin;
using Microsoft.Owin.Cors; // Cors 사용 시
using Owin;

// 아래 어셈블리 특성은 Startup 클래스가 OWIN 시작 클래스임을 지정합니다.
// 프로젝트의 AssemblyInfo.cs에 추가하거나, 여기에 직접 명시할 수 있습니다.
// [assembly: OwinStartup(typeof(MGSPMonitorControl.Startup))] 
// 위 줄은 보통 AssemblyInfo.cs 에 추가하거나, 네임스페이스가 정확해야 합니다.
// 또는 WebActivatorEx 같은 패키지를 사용하기도 합니다.
// 여기서는 App.xaml.cs에서 직접 WebApp.Start를 호출할 것이므로, 이 특성이 필수적이진 않을 수 있습니다.

namespace MGSPMonitorControl
{
    public class Startup
    {
        public void Configuration(IAppBuilder app)
        {
            // CORS 설정 (필요한 경우, 모든 도메인 허용 예시)
            // 보안상 실제 운영 환경에서는 특정 도메인만 허용하는 것이 좋습니다.
            app.UseCors(CorsOptions.AllowAll);

            // SignalR Hub 경로 매핑
            // 기본 경로 /signalr 사용
            app.MapSignalR(); 
            // 또는 특정 경로 지정: app.MapSignalR("/myhubpath", new HubConfiguration());

            // 추가적인 OWIN 미들웨어 설정이 있다면 여기에 추가
            // 예: app.UseWebApi(config);
            
            System.Console.WriteLine("OWIN Configuration complete. SignalR Mapped.");
        }
    }
}
AssemblyInfo.cs 수정:
MGSPMonitorControl 프로젝트의 Properties 폴더 아래 AssemblyInfo.cs 파일에 다음 줄을 추가합니다.

C#

[assembly: Microsoft.Owin.OwinStartup(typeof(MGSPMonitorControl.Startup))]
이렇게 하면 WebApp.Start 호출 시 Startup 클래스를 자동으로 찾습니다.