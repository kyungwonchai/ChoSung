죄송합니다. 이해를 돕기 위해 읽기, 덮어쓰기, 단순 전달 세 가지 기능을 각각 UI에 명확하게 분리하고, 기본 함수를 분리해서 조합할 수 있도록 전체 코드를 다시 작성해 드리겠습니다.

각각의 기능에 대해 다시 정리하고, UI와 함수가 그에 맞게 작동하도록 할게요.

목표:
읽기: 특정 메모리 번지에서 값을 읽습니다.
덮어쓰기: 특정 메모리 번지에 값을 덮어씁니다.
단순 전달: 응답을 기다리지 않고 단순히 값을 PLC로 전송합니다.
전체 코드
1. MainWindow.xaml (UI 구성)
xml
코드 복사
<Window x:Class="PlcApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Mutocol 통신" Height="400" Width="600">
    <Grid>
        <StackPanel>
            <TextBlock Text="PLC 통신 테스트" FontSize="18" HorizontalAlignment="Center" Margin="10" />

            <!-- 읽기 -->
            <Button Content="읽기" Click="BtnRead_Click" Width="200" Height="40" Margin="5"/>

            <!-- 덮어쓰기 -->
            <Button Content="덮어쓰기" Click="BtnOverwrite_Click" Width="200" Height="40" Margin="5"/>

            <!-- 단순 전달 -->
            <Button Content="단순 전달" Click="BtnSendSimple_Click" Width="200" Height="40" Margin="5"/>

            <TextBlock x:Name="OutputText" Text="결과 출력:" FontSize="14" Margin="10" TextWrapping="Wrap"/>
        </StackPanel>
    </Grid>
</Window>
2. MainWindow.xaml.cs (C# 코드 - MainWindow 클래스)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows;

namespace PlcApp
{
    public partial class MainWindow : Window
    {
        private PlcMutocolCommunication _plc;

        public MainWindow()
        {
            InitializeComponent();
            _plc = new PlcMutocolCommunication("COM3", 9600); // 포트와 보드레이트 설정
        }

        // 읽기
        private async void BtnRead_Click(object sender, RoutedEventArgs e)
        {
            await ExecutePlcFunctionAsync(() => _plc.ReadAsync("0010"), "읽기");
        }

        // 덮어쓰기
        private async void BtnOverwrite_Click(object sender, RoutedEventArgs e)
        {
            await ExecutePlcFunctionAsync(() => _plc.OverwriteAsync("0010", "1234"), "덮어쓰기");
        }

        // 단순 전달
        private async void BtnSendSimple_Click(object sender, RoutedEventArgs e)
        {
            await ExecutePlcFunctionAsync(() => _plc.SendSimpleAsync("0010", "5678"), "단순 전달");
        }

        // 공통적으로 사용할 비동기 함수 실행 로직
        private async Task ExecutePlcFunctionAsync(Func<Task<string>> plcFunc, string actionDescription)
        {
            try
            {
                _plc.OpenPort();
                string result = await plcFunc.Invoke();
                OutputText.Text = $"{actionDescription} 결과: {result}";
            }
            catch (Exception ex)
            {
                OutputText.Text = $"에러: {ex.Message}";
            }
            finally
            {
                _plc.ClosePort();
            }
        }
    }
}
3. PlcMutocolCommunication.cs (PLC 통신 클래스)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

public class PlcMutocolCommunication
{
    private SerialPort _serialPort;
    private const int _timeout = 30000; // 30초 타임아웃

    public PlcMutocolCommunication(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate);
        _serialPort.DataBits = 8;
        _serialPort.Parity = Parity.None;
        _serialPort.StopBits = StopBits.One;
        _serialPort.ReadTimeout = _timeout;
        _serialPort.WriteTimeout = _timeout;
    }

    public void OpenPort()
    {
        if (!_serialPort.IsOpen)
        {
            _serialPort.Open();
        }
    }

    public void ClosePort()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }

    // 1. 읽기 함수
    public async Task<string> ReadAsync(string address)
    {
        string command = $"@00RD{address}\r\n"; // 읽기 명령어
        await WriteCommandAsync(command);

        return await ReadResponseAsync();
    }

    // 2. 덮어쓰기 함수
    public async Task<string> OverwriteAsync(string address, string value)
    {
        string command = $"@00WD{address}{FormatValue(value)}\r\n"; // 쓰기 명령어
        await WriteCommandAsync(command);

        string response = await ReadResponseAsync();
        return response.Contains("OK") ? "덮어쓰기 성공" : "덮어쓰기 실패";
    }

    // 3. 단순 전달 함수
    public async Task<string> SendSimpleAsync(string address, string value)
    {
        string command = $"@00WD{address}{FormatValue(value)}\r\n"; // 쓰기 명령어
        await WriteCommandAsync(command);

        return "단순 전달 완료";
    }

    // 명령어 전송
    private async Task WriteCommandAsync(string command)
    {
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        await _serialPort.BaseStream.WriteAsync(commandBytes, 0, commandBytes.Length);
    }

    // 응답 읽기
    private async Task<string> ReadResponseAsync()
    {
        byte[] buffer = new byte[256];
        int bytesRead = await _serialPort.BaseStream.ReadAsync(buffer, 0, buffer.Length);
        return Encoding.ASCII.GetString(buffer, 0, bytesRead);
    }

    // 값 변환 함수 (숫자와 문자열 구분)
    private string FormatValue(string value)
    {
        // 값이 숫자인지 문자열인지 확인 후 Mutocol 형식에 맞게 변환
        if (int.TryParse(value, out int numericValue))
        {
            return numericValue.ToString("D4"); // 숫자인 경우 4자리로 변환
        }
        else
        {
            return value; // 문자열 그대로 전달
        }
    }
}
주요 기능 설명
읽기 (ReadAsync): PLC에서 특정 주소의 값을 읽어옵니다. PLC에 있는 데이터가 맞는지 확인할 때 사용됩니다.
덮어쓰기 (OverwriteAsync): PLC의 특정 주소에 값을 덮어쓰고, 응답을 통해 제대로 덮어썼는지 확인합니다.
단순 전달 (SendSimpleAsync): 값을 PLC에 전송하고, 응답을 기다리지 않고 다음 작업으로 넘어갑니다.
이 코드를 통해 PLC와의 통신을 단일 동작 함수로 쪼개서 구현한 후, 각각의 동작을 UI 버튼 클릭에 따라 실행할 수 있습니다.