일 삭제 작업을 취소할 수 있도록 하겠습니다.

수정된 FileCleaner.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MinimumFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB
        private const long MaxFolderSize = 8L * 1024 * 1024 * 1024; // 8 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;
        private readonly Logger logger;
        private readonly Action<long, string> updateFolderStatistics;

        public FileCleaner(string logDirectory, MLModelBuilder mlModelBuilder, Dispatcher dispatcher, Logger logger, Action<long, string> updateFolderStatistics)
        {
            this.logDirectory = logDirectory;
            this.mlModelBuilder = mlModelBuilder;
            this.dispatcher = dispatcher;
            this.logger = logger;
            this.updateFolderStatistics = updateFolderStatistics;
        }

        public long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get drive free space: " + ex.Message);
                return 0;
            }
        }

        public List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension, bool forceDelete = false)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                var filesToDelete = files.Where(file => forceDelete || file.CreationTime < DateTime.Now.AddDays(-35)).OrderBy(file => file.CreationTime).ToList();

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(files.Sum(f => f.Length), folderPath);
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get files to delete: " + ex.Message);
                return new List<FileInfo>();
            }
        }

        private IEnumerable<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                logger.LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        public async Task DeleteFilesAsync(List<FileInfo> files, string folderPath, bool forceDelete = false, CancellationToken cancellationToken = default)
        {
            long currentFolderSize = files.Sum(f => f.Length);
            long freeSpace = GetDriveFreeSpace(folderPath.Split('\\')[0] + "\\");

            var startTime = DateTime.Now;

            foreach (var file in files)
            {
                if (cancellationToken.IsCancellationRequested)
                {
                    logger.LogRecentActivity("파일 삭제 중지됨.");
                    break;
                }

                if (currentFolderSize <= MaxFolderSize && !forceDelete)
                {
                    logger.LogRecentActivity("현재 폴더 크기가 8GB 이하입니다.");
                    break;
                }

                if (freeSpace > MinimumFreeSpace && !forceDelete)
                {
                    logger.LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 삭제를 하지 않습니다.");
                    break;
                }

                try
                {
                    file.Delete();
                    currentFolderSize -= file.Length;
                    logger.LogDeletionActivity($"파일 삭제됨: {file.FullName}");
                    
                    var elapsed = DateTime.Now - startTime;
                    if (elapsed.TotalMinutes < 3)
                    {
                        await Task.Delay(5000, cancellationToken); // 처음 3분 동안 5초 간격으로 파일 삭제
                    }
                    else
                    {
                        await Task.Delay(100, cancellationToken); // 3분 이후에는 100ms 간격으로 파일 삭제
                    }
                }
                catch (Exception ex)
                {
                    logger.LogError("Failed to delete file: " + ex.Message);
                }
            }

            updateFolderStatistics(currentFolderSize, folderPath);
        }

        public void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(totalSize, folderPath);
                });
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to update folder statistics: " + ex.Message);
            }
        }
    }
}
수정된 MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Forms;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private NotifyIcon notifyIcon;
        private SettingsManager _settingsManager;
        private Logger _logger;
        private MLModelBuilder _mlModelBuilder;
        private FileCleaner _fileCleaner;
        private const long MinimumSampleSize = 21; // 최소 샘플 수를 21개로 설정
        private const long MinimumFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB
        private const long MaxFolderSize = 8L * 1024 * 1024 * 1024; // 8 GB
        private List<FileRecord> _trainingData;
        private bool isCleaning;
        private CancellationTokenSource cancellationTokenSource;

        public MainWindow()
        {
            InitializeComponent();
            InitializeTrayIcon();
            _settingsManager = new SettingsManager("C:\\Agent\\SMDClean");
            _logger = new Logger("C:\\Agent\\SMDClean\\Logs", Dispatcher);
            _mlModelBuilder = new MLModelBuilder();
            _fileCleaner = new FileCleaner("C:\\Agent\\SMDClean\\Logs", _mlModelBuilder, Dispatcher, _logger, UpdateFolderStatistics);
            LoadSettings();
            AttachEventHandlers();
        }

        private void InitializeTrayIcon()
        {
            notifyIcon = new NotifyIcon
            {
                Icon = System.Drawing.SystemIcons.Application,
                Visible = true,
                ContextMenuStrip = new ContextMenuStrip()
            };

            notifyIcon.ContextMenuStrip.Items.Add("열기", null, Open_Click);
            notifyIcon.ContextMenuStrip.Items.Add("닫기", null, Close_Click);
            notifyIcon.DoubleClick += Open_Click;
        }

        private void Open_Click(object sender, EventArgs e)
        {
            Show();
            WindowState = WindowState.Normal;
        }

        private void Close_Click(object sender, EventArgs e)
        {
            if (System.Windows.MessageBox.Show("프로그램을 종료하시겠습니까?", "종료 확인", MessageBoxButton.YesNo) == MessageBoxResult.Yes)
            {
                notifyIcon.Dispose();
                Application.Current.Shutdown();
            }
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            e.Cancel = true;
            Hide();
            notifyIcon.BalloonTipText = "프로그램이 트레이로 최소화되었습니다.";
            notifyIcon.ShowBalloonTip(3000);
        }

        private void btnExit_Click(object sender, RoutedEventArgs e)
        {
            Close_Click(sender, e);
        }

        private void btnSelectFolder_Click(object sender, RoutedEventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                dialog.SelectedPath = txtFolderPath.Text;
                if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    txtFolderPath.Text = dialog.SelectedPath;
                    SaveSettings(); // 폴더 선택 시 설정 저장
                    ResetAndRetrain();
                }
            }
        }

        private void cmbFileExtension_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            SaveSettings();
            ResetAndRetrain();
        }

        private void SaveSettings()
        {
            try
            {
                string fileExtension = GetFileExtension(cmbFileExtension.SelectedItem?.ToString());

                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = fileExtension,
                    DriveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError("SaveSettings", ex.Message);
            }
        }

        private string GetFileExtension(string selectedItem)
        {
            if (string.IsNullOrEmpty(selectedItem) || selectedItem.Length < 4)
            {
                return ".jpg"; // 기본값으로 설정
            }
            return selectedItem.Substring(selectedItem.Length - 4);
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "D:\\";
                    cmbFileExtension.SelectedItem = settings.FileExtension ?? ".jpg";
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("LoadSettings", ex.Message);
            }
        }

        private void AttachEventHandlers()
        {
            txtFolderPath.TextChanged += (s, e) => ResetAndRetrain();
            cmbFileExtension.SelectionChanged += cmbFileExtension_SelectionChanged;
        }

        private async void ResetAndRetrain()
        {
            lstRecentLogs.Items.Clear();
            lstDeletionLogs.Items.Clear();
            lstPriorityFiles.Items.Clear();
            dataGridTrainingData.ItemsSource = null;
            txtTrainingStatus.Text = string.Empty;

            string folderPath = txtFolderPath.Text;
            string fileExtension = GetFileExtension(cmbFileExtension.SelectedItem?.ToString());

            if (string.IsNullOrEmpty(folderPath) || string.IsNullOrEmpty(fileExtension))
            {
                System.Windows.MessageBox.Show("모든 입력값을 제공해주세요.");
                return;
            }

            try
            {
                LogRecentActivity("학습 중...");

                _trainingData = await Task.Run(() => CollectInitialFileData(folderPath, fileExtension));
                if (_trainingData.Count < MinimumSampleSize)
                {
                    System.Windows.MessageBox.Show($"학습 모델을 훈련시키기에 샘플이 충분하지 않습니다. 최소 샘플 수: {MinimumSampleSize}");
                    LogRecentActivity("학습 실패: 샘플 부족");
                    return;
                }

                if (_trainingData.Count == 0)
                {
                    System.Windows.MessageBox.Show($"해당 확장자를 가진 파일이 없습니다: {fileExtension}");
                    LogRecentActivity("학습 실패: 해당 확장자를 가진 파일이 없습니다.");
                    return;
                }

                _mlModelBuilder.TrainModel(_trainingData);

                LogRecentActivity("학습 완료");
                LogRecentActivity(string.Join(", ", _mlModelBuilder.GetRegexPatterns().Select(p => p.ToString())));

                // 학습된 패턴 설명을 UI에 표시
                var patternDescription = _mlModelBuilder.GetPatternDescription();
                txtTrainingStatus.Text = "학습된 패턴 설명:\n" + patternDescription;

                Dispatcher.Invoke(() =>
                {
                    dataGridTrainingData.ItemsSource = _trainingData.Select(f => new
                    {
                        f.FilePath,
                        f.Extension,
                        f.Size,
                        f.FolderPath,
                        Pattern = _mlModelBuilder.GetPattern(f.FilePath)
                    }).ToList();

                    HighlightTrainingData();
                });

                cancellationTokenSource = new CancellationTokenSource();
                await MonitorAndDisplayFilesToDelete(folderPath, fileExtension, txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\", cancellationTokenSource.Token);
            }
            catch (Exception ex)
            {
                _logger.LogError("모델 훈련 실패: " + ex.Message);
                LogRecentActivity("학습 실패: " + ex.Message);
            }
        }

        private List<FileRecord> CollectInitialFileData(string folderPath, string fileExtension)
        {
            var fileDataList = new List<FileRecord>();
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                if (files != null && files.Count >= MinimumSampleSize)
                {
                    fileDataList = files.Select(f => new FileRecord
                    {
                        FilePath = f.FullName,
                        Extension = f.Extension,
                        Size = (float)f.Length,
                        FolderPath = f.DirectoryName
                    }).ToList();

                    LogRecentActivity($"학습 중인 파일 수: {files.Count}개");
                }
                else
                {
                    LogRecentActivity("학습할 파일이 없습니다.");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("파일 데이터 수집 실패: " + ex.Message);
                LogRecentActivity("파일 데이터 수집 오류.");
            }
            return fileDataList;
        }

        private List<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                _logger.LogError("폴더 접근 거부됨: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName, CancellationToken cancellationToken)
        {
            while (isCleaning)
            {
                try
                {
                    long freeSpace = await Task.Run(() => _fileCleaner.GetDriveFreeSpace(driveName));
                    List<FileInfo> filesToDelete;

                    if (freeSpace <= MinimumFreeSpace)
                    {
                        filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension, forceDelete: true));
                        LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 강제 삭제를 진행합니다.");
                    }
                    else
                    {
                        filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension));
                        if (filesToDelete.Count > 0)
                        {
                            LogRecentActivity("삭제를 진행합니다.");
                        }
                    }

                    Dispatcher.Invoke(() => DisplayFilesToDelete(filesToDelete));
                    await _fileCleaner.DeleteFilesAsync(filesToDelete, folderPath, forceDelete: freeSpace <= MinimumFreeSpace, cancellationToken);

                    await UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10), cancellationToken); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    if (ex is TaskCanceledException)
                    {
                        LogRecentActivity("파일 삭제 작업이 취소되었습니다.");
                    }
                    else
                    {
                        LogError("모니터링 중 오류 발생: " + ex.Message);
                    }
                }
            }
        }

        private async Task UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = _fileCleaner.GetFiles(folderPath, fileExtension);
                long totalSize = files.Sum(f => f.Length);

                if (totalSize > 0 && totalSize != _fileCleaner.lastLoggedSize) // 총 크기가 0인 경우와 중복 크기 로그 생성을 피함
                {
                    _fileCleaner.lastLoggedSize = totalSize;
                    LogRecentActivity($"폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB - 폴더의 총 크기 업데이트");
                }
            }
            catch (Exception ex)
            {
                LogError("폴더 통계 업데이트 실패: " + ex.Message);
            }
        }

        private void LogRecentActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                lstRecentLogs.Items.Add(logMessage);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogDeletionActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                lstDeletionLogs.Items.Add(logMessage);
                if (lstDeletionLogs.Items.Count > 200)
                {
                    lstDeletionLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogError(string message)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: [ERROR] {message}";
                lstRecentLogs.Items.Add(logMessage);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void DisplayFilesToDelete(List<FileInfo> filesToDelete)
        {
            Dispatcher.Invoke(() =>
            {
                lstPriorityFiles.Items.Clear();
                foreach (var file in filesToDelete)
                {
                    lstPriorityFiles.Items.Add($"{file.FullName} (생성 시간: {file.CreationTime})");
                }

                if (filesToDelete.Count == 0)
                {
                    var allFiles = GetFiles(txtFolderPath.Text, cmbFileExtension.SelectedItem.ToString());
                    var prioritizedFiles = allFiles.OrderByDescending(f => f.CreationTime).ToList();
                    lstPriorityFiles.Items.Add("현재 삭제할 파일이 없지만, 우선순위에 따른 목록을 표시합니다:");
                    foreach (var file in prioritizedFiles)
                    {
                        lstPriorityFiles.Items.Add($"{file.FullName} (생성 시간: {file.CreationTime})");
                    }
                }
            });
        }

        private void HighlightTrainingData()
        {
            var data = dataGridTrainingData.ItemsSource as List<dynamic>;
            if (data == null) return;

            foreach (var item in dataGridTrainingData.Items)
            {
                var row = (DataGridRow)dataGridTrainingData.ItemContainerGenerator.ContainerFromItem(item);
                if (row == null) continue;

                var cell = (DataGridCell)dataGridTrainingData.Columns[0].GetCellContent(row).Parent;
                cell.Background = System.Windows.Media.Brushes.LightYellow; // 학습 데이터 셀 강조 색상 설정
            }
        }

        private void UpdateFolderStatistics(long totalSize, string folderPath)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: 폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB - 폴더의 총 크기 업데이트";
                lstRecentLogs.Items.Add(logMessage);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (isCleaning)
            {
                isCleaning = false;
                cancellationTokenSource?.Cancel();
                btnStart.Content = "시작";
                LogRecentActivity("파일 삭제 중지됨.");
            }
            else
            {
                isCleaning = true;
                btnStart.Content = "중지";
                LogRecentActivity("파일 삭제 시작됨.");
                cancellationTokenSource = new CancellationTokenSource();
                MonitorAndDisplayFilesToDelete(txtFolderPath.Text, GetFileExtension(cmbFileExtension.SelectedItem?.ToString()), txtFolderPath.Text.Split('\\')[0] + "\\", cancellationTokenSource.Token);
            }
        }
    }
}
수정된 기능 설명
cancellationTokenSource를 사용하여 파일 삭제 작업을 취소할 수 있도록 수정했습니다.
DeleteFilesAsync 메서드에 CancellationToken을 추가하여 