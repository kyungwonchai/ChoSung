네, 물론입니다. 사용자가 직접 마우스로 캡처할 영역을 지정하고, 그 설정이 프로그램 종료 후에도 유지되며, 선택한 영역의 이미지를 미리 볼 수 있도록 기능을 대폭 개선해 보겠습니다.

이전과 동일하게 WPF와 Tesseract.Net.SDK를 기반으로 기능을 추가하겠습니다.

주요 개선 사항
영역 설정 버튼 추가: 사용자가 마우스로 직접 캡처 영역을 그리도록 하는 '영역 설정' 기능을 추가합니다.
설정 값 저장 및 복원: 지정한 '대상 창 제목'과 '캡처 영역 좌표'를 프로그램 종료 시 저장하고, 다시 시작할 때 자동으로 불러옵니다.
영역 이미지 미리보기: 설정된 영역이 어떤 이미지인지 보여주는 미리보기 기능을 추가하고, 이 이미지 또한 저장하여 유지합니다.
1단계: 설정(Settings) 기능 활성화
먼저, 프로그램이 설정 값을 저장하고 불러올 수 있도록 Settings 파일을 설정합니다.

솔루션 탐색기에서 프로젝트 이름(funcenvget)을 마우스 오른쪽 버튼으로 클릭하고 **'속성'**을 선택합니다.
왼쪽 탭에서 **'설정(Settings)'**으로 이동합니다. "이 프로젝트는 기본 설정 파일을 포함하고 있지 않습니다..." 라는 메시지가 보이면 클릭하여 만듭니다.
아래 표와 같이 설정 항목들을 추가합니다. **범위(Scope)**는 모두 User로 설정해야 사용 중 변경 및 저장이 가능합니다.
이름 (Name)	형식 (Type)	범위 (Scope)	값 (Value)
WindowTitle	string	User	
CaptureX	int	User	0
CaptureY	int	User	0
CaptureWidth	int	User	0
CaptureHeight	int	User	0
PreviewImagePath	string	User	
Ctrl+S를 눌러 설정을 저장하고 속성 창을 닫습니다.
2단계: 영역 선택을 위한 새 창 추가
마우스로 영역을 선택하는 기능을 담당할 새 창(SelectionWindow)을 만듭니다.

솔루션 탐색기에서 프로젝트 이름(funcenvget)을 마우스 오른쪽 버튼으로 클릭하고 **'추가(Add)' > '창(Window, WPF)...'**을 선택합니다.
창의 이름을 SelectionWindow.xaml로 지정하고 '추가'를 클릭합니다.
2-1. SelectionWindow.xaml 코드
SelectionWindow.xaml 파일을 열고 아래 코드로 교체합니다. 화면 전체를 덮는 투명한 창을 만듭니다.

XML

<Window x:Class="funcenvget.SelectionWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="SelectionWindow" WindowStyle="None" AllowsTransparency="True" Background="#33000000" WindowState="Maximized" Cursor="Cross" KeyUp="Window_KeyUp">
    <Canvas x:Name="SelectionCanvas" MouseDown="SelectionCanvas_MouseDown" MouseMove="SelectionCanvas_MouseMove" MouseUp="SelectionCanvas_MouseUp"/>
</Window>
2-2. SelectionWindow.xaml.cs 코드
SelectionWindow.xaml.cs 파일을 열고 아래 코드로 교체합니다. 마우스 드래그를 감지하여 사각형을 그리고, 선택된 영역의 좌표를 저장하는 로직입니다.

C#

using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Shapes;

namespace funcenvget
{
    public partial class SelectionWindow : Window
    {
        private Point startPoint;
        private Rectangle selectionRect;

        public Rect SelectedArea { get; private set; } // 결과를 저장할 속성

        public SelectionWindow()
        {
            InitializeComponent();
            selectionRect = new Rectangle
            {
                Stroke = Brushes.Red,
                StrokeThickness = 2,
                Fill = new SolidColorBrush(Color.FromArgb(50, 255, 0, 0))
            };
            SelectionCanvas.Children.Add(selectionRect);
        }

        private void Window_KeyUp(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                DialogResult = false; // Esc 키로 취소
                Close();
            }
        }

        private void SelectionCanvas_MouseDown(object sender, MouseButtonEventArgs e)
        {
            startPoint = e.GetPosition(this);
            Canvas.SetLeft(selectionRect, startPoint.X);
            Canvas.SetTop(selectionRect, startPoint.Y);
            selectionRect.Width = 0;
            selectionRect.Height = 0;
        }

        private void SelectionCanvas_MouseMove(object sender, MouseEventArgs e)
        {
            if (e.LeftButton == MouseButtonState.Pressed)
            {
                Point currentPoint = e.GetPosition(this);
                double x = Math.Min(startPoint.X, currentPoint.X);
                double y = Math.Min(startPoint.Y, currentPoint.Y);
                double width = Math.Abs(startPoint.X - currentPoint.X);
                double height = Math.Abs(startPoint.Y - currentPoint.Y);
                Canvas.SetLeft(selectionRect, x);
                Canvas.SetTop(selectionRect, y);
                selectionRect.Width = width;
                selectionRect.Height = height;
            }
        }

        private void SelectionCanvas_MouseUp(object sender, MouseButtonEventArgs e)
        {
            Point endPoint = e.GetPosition(this);
            double x = Math.Min(startPoint.X, endPoint.X);
            double y = Math.Min(startPoint.Y, endPoint.Y);
            double width = Math.Abs(startPoint.X - endPoint.X);
            double height = Math.Abs(startPoint.Y - endPoint.Y);

            // 드래그가 아닌 단순 클릭은 무시
            if (width > 5 && height > 5)
            {
                SelectedArea = new Rect(x, y, width, height);
                DialogResult = true; // 성공적으로 선택 완료
            }
            else
            {
                DialogResult = false; // 선택 취소
            }
            Close();
        }
    }
}
3단계: 메인 창(MainWindow) 코드 수정
3-1. MainWindow.xaml 코드
기존 MainWindow.xaml의 UI를 수정하여 '영역 설정' 버튼과 이미지 미리보기 컨트롤을 추가합니다.

XML

<Window x:Class="funcenvget.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:funcenvget"
        mc:Ignorable="d"
        Title="실시간 데이터 로거 (funcenvget)" Height="480" Width="480" ResizeMode="CanMinimize"
        Loaded="Window_Loaded" Closing="Window_Closing">
    <Grid Margin="15">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        <Grid.ColumnDefinitions>
            <ColumnDefinition Width="Auto"/>
            <ColumnDefinition Width="*"/>
        </Grid.ColumnDefinitions>

        <Label Content="대상 창 제목:" Grid.Row="0" Grid.Column="0" VerticalAlignment="Center"/>
        <TextBox x:Name="txtWindowTitle" Grid.Row="0" Grid.Column="1" Margin="5"/>

        <Label Content="캡처 영역 (X, Y):" Grid.Row="1" Grid.Column="0" VerticalAlignment="Center"/>
        <StackPanel Grid.Row="1" Grid.Column="1" Orientation="Horizontal">
            <TextBox x:Name="txtX" Width="80" Margin="5" IsReadOnly="True"/>
            <TextBox x:Name="txtY" Width="80" Margin="5" IsReadOnly="True"/>
        </StackPanel>

        <Label Content="캡처 크기 (W, H):" Grid.Row="2" Grid.Column="0" VerticalAlignment="Center"/>
        <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal">
            <TextBox x:Name="txtWidth" Width="80" Margin="5" IsReadOnly="True"/>
            <TextBox x:Name="txtHeight" Width="80" Margin="5" IsReadOnly="True"/>
        </StackPanel>

        <Button x:Name="btnSelectArea" Content="영역 설정" Grid.Row="3" Grid.Column="0" Grid.ColumnSpan="2" Margin="5" Padding="5" Click="btnSelectArea_Click"/>
        <Button x:Name="btnStart" Content="로깅 시작" Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="2" Margin="5,10,5,5" Padding="5" FontWeight="Bold" Click="btnStart_Click"/>

        <Border Grid.Row="5" Grid.Column="0" Grid.ColumnSpan="2" BorderBrush="Gray" BorderThickness="1" Margin="5">
            <Image x:Name="imgPreview" Stretch="Uniform" ToolTip="설정된 영역의 미리보기입니다."/>
        </Border>

        <StatusBar Grid.Row="6" Grid.Column="0" Grid.ColumnSpan="2">
            <StatusBarItem>
                <TextBlock x:Name="lblStatus" Text="상태: 대기 중" TextWrapping="Wrap"/>
            </StatusBarItem>
        </StatusBar>

    </Grid>
</Window>
3-2. MainWindow.xaml.cs 코드
메인 창의 로직을 대폭 수정합니다. 설정 로드/저장, 영역 선택 창 호출, 이미지 미리보기 생성 등의 기능이 추가됩니다.

C#

using System;
using System.Drawing; // System.Drawing.Common NuGet 패키지 필요할 수 있음
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Media.Imaging;
using System.Windows.Threading;
using Tesseract;
using funcenvget.Properties; // Settings 사용을 위해 추가

namespace funcenvget
{
    public partial class MainWindow : Window
    {
        // WinAPI 함수 선언
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private DispatcherTimer timer;
        private TesseractEngine ocrEngine;

        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
        }

        private void InitializeApp()
        {
            ocrEngine = new TesseractEngine("./tessdata", "eng", EngineMode.Default);
            ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");

            timer = new DispatcherTimer();
            timer.Interval = TimeSpan.FromSeconds(10);
            timer.Tick += Timer_Tick;
        }

        // 영역 설정 버튼 클릭 이벤트
        private void btnSelectArea_Click(object sender, RoutedEventArgs e)
        {
            IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
            if (hWnd == IntPtr.Zero)
            {
                MessageBox.Show("먼저 유효한 '대상 창 제목'을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            this.WindowState = WindowState.Minimized; // 메인창 최소화

            var selectionWindow = new SelectionWindow();
            if (selectionWindow.ShowDialog() == true)
            {
                Rect screenRect = selectionWindow.SelectedArea;
                
                // 스크린 좌표를 대상 창의 클라이언트 좌표로 변환
                GetWindowRect(hWnd, out RECT windowRect);
                int relativeX = (int)screenRect.X - windowRect.Left;
                int relativeY = (int)screenRect.Y - windowRect.Top;

                // 음수 좌표 방지
                relativeX = Math.Max(0, relativeX);
                relativeY = Math.Max(0, relativeY);

                txtX.Text = relativeX.ToString();
                txtY.Text = relativeY.ToString();
                txtWidth.Text = ((int)screenRect.Width).ToString();
                txtHeight.Text = ((int)screenRect.Height).ToString();

                UpdatePreviewImage(); // 좌표 설정 후 미리보기 업데이트
            }

            this.WindowState = WindowState.Normal; // 메인창 복원
        }

        private void UpdatePreviewImage()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero) return;

                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                    }

                    var cropArea = new Rectangle(
                        int.Parse(txtX.Text), int.Parse(txtY.Text),
                        int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    
                    if (cropArea.Width <= 0 || cropArea.Height <= 0 || cropArea.Right > bmp.Width || cropArea.Bottom > bmp.Height)
                    {
                        imgPreview.Source = null; // 유효하지 않은 영역은 미리보기 없음
                        return;
                    }

                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        // 미리보기 이미지 표시
                        imgPreview.Source = BitmapToImageSource(croppedBmp);
                        
                        // 미리보기 이미지 파일로 저장
                        string previewPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "preview_capture.png");
                        croppedBmp.Save(previewPath, ImageFormat.Png);
                        Settings.Default.PreviewImagePath = previewPath; // 파일 경로 저장
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"미리보기 생성 오류: {ex.Message}";
                imgPreview.Source = null;
            }
        }

        // Bitmap을 WPF Image 컨트롤에서 사용할 수 있는 ImageSource로 변환하는 헬퍼 함수
        BitmapImage BitmapToImageSource(Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, ImageFormat.Png);
                memory.Position = 0;
                BitmapImage bitmapimage = new BitmapImage();
                bitmapimage.BeginInit();
                bitmapimage.StreamSource = memory;
                bitmapimage.CacheOption = BitmapCacheOption.OnLoad;
                bitmapimage.EndInit();
                return bitmapimage;
            }
        }

        // 이전 코드는 여기에 유지 (btnStart_Click, Timer_Tick, PerformLogging, LogData 등)
        // ... (이전 답변의 C# 코드에서 해당 함수들을 복사하여 붙여넣으세요)

        #region --- 이전 코드 붙여넣기 ---
        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled)
            {
                timer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 로깅이 중지되었습니다.";
            }
            else
            {
                if (string.IsNullOrWhiteSpace(txtWindowTitle.Text) || int.Parse(txtWidth.Text) <= 0 || int.Parse(txtHeight.Text) <= 0)
                {
                    MessageBox.Show("대상 창 제목과 유효한 캡처 영역을 먼저 설정해주세요.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            PerformLogging();
        }

        private void PerformLogging()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상 창을 찾을 수 없습니다.";
                    return;
                }

                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        bool result = PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                        if (!result)
                        {
                            lblStatus.Text = "상태: 오류! 창을 캡처할 수 없습니다.";
                            return;
                        }
                    }

                    var cropArea = new Rectangle(
                        int.Parse(txtX.Text), int.Parse(txtY.Text),
                        int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));

                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        using (var page = ocrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            if (!string.IsNullOrWhiteSpace(rawText))
                            {
                                LogData(rawText);
                                lblStatus.Text = $"상태: {DateTime.Now} - 로그 기록 완료.";
                            }
                            else
                            {
                                lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다.";
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"상태: 심각한 오류 발생! {ex.Message}";
                LogData($"[ERROR] {ex.Message}");
            }
        }

        private void LogData(string data)
        {
            try
            {
                string sanitizedData = Regex.Replace(data, @"\s+", " ").Trim();
                string logFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "datalog.txt");
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}\t{sanitizedData}\n";
                File.AppendAllText(logFilePath, logMessage, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"로그 파일 쓰기 오류: {ex.Message}", "파일 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #endregion

        #region --- 설정 로드 및 저장 ---
        // 프로그램 시작 시 설정 값 로드
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            txtWindowTitle.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();

            if (!string.IsNullOrEmpty(Settings.Default.PreviewImagePath) && File.Exists(Settings.Default.PreviewImagePath))
            {
                try
                {
                    BitmapImage preview = new BitmapImage();
                    preview.BeginInit();
                    preview.UriSource = new Uri(Settings.Default.PreviewImagePath);
                    preview.CacheOption = BitmapCacheOption.OnLoad; // 파일 잠금 방지
                    preview.EndInit();
                    imgPreview.Source = preview;
                }
                catch (Exception) { /* 이미지 로드 실패 시 무시 */ }
            }
        }

        // 프로그램 종료 시 설정 값 저장
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            if (ocrEngine != null) ocrEngine.Dispose();
            if (timer != null) timer.Stop();

            Settings.Default.WindowTitle = txtWindowTitle.Text;
            Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
            Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
            Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
            Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
            
            Settings.Default.Save();
        }
        #endregion
    }
}
4단계: 사용 방법
F5를 눌러 프로그램을 실행합니다.
대상 창 제목 입력: 감시할 프로그램의 창 제목을 정확히 입력합니다.
영역 설정:
[영역 설정] 버튼을 클릭합니다.
프로그램이 잠시 최소화되고 화면 전체가 반투명하게 변하며 마우스 커서가 십자 모양으로 바뀝니다.
캡처를 원하는 영역을 마우스로 드래그하여 선택합니다. (선택 시 빨간 사각형으로 표시됨)
마우스 버튼을 놓으면 선택이 완료되고, 좌표와 크기 값이 자동으로 입력됩니다.
동시에 메인 창에 선택한 영역의 이미지가 미리보기로 표시됩니다. (선택을 취소하려면 Esc 키를 누르세요.)