 정말 죄송합니다. 디버그 로그는 정상적으로 보이는데 실제 로그 저장이 안 되고, 이제는 저장 시 "변경 엔티티 감지됨" 로그가 무한으로 출력된다면, SaveChanges 재정의 로직 자체에 문제가 있는 것이 확실해 보입니다.

문제 원인 재분석:

SaveChanges 메서드 안에서 로그를 생성(CreateAuditEntries)하고 컨텍스트에 추가(AuditLogs.AddRange)한 뒤 base.SaveChanges()를 호출하는 현재 구조는, base.SaveChanges()가 호출될 때 원본 데이터 변경과 로그 데이터 추가를 모두 처리하게 됩니다. 이때 AuditLog 엔티티가 Added 상태로 추가되는 것 자체가 DbContext에게는 또 다른 '변경 사항'으로 인식될 수 있습니다. 만약 어떤 이유로든 base.SaveChanges() 호출 이후에도 DbContext가 여전히 변경 사항이 있다고 판단하거나, SaveChanges 메서드가 비정상적으로 다시 호출되는 상황이 발생하면, 로그 추가 -> 저장 -> 변경 감지 -> 로그 추가 -> 저장... 의 무한 루프가 발생할 수 있습니다.

해결 방법 (로직 변경):

로그 저장을 원본 데이터 저장과 분리하는 방식으로 변경합니다.

SaveChanges 재정의 메서드에서 원본 데이터 변경만 먼저 저장 (base.SaveChanges() 호출).
원본 데이터 저장이 성공했을 경우(result > 0), 그 후에 로그를 생성(CreateAuditEntries)하고 별도로 로그만 저장합니다. 로그 저장 시에는 오류가 발생해도 원본 데이터 저장 결과에 영향을 주지 않도록 try-catch로 감쌉니다.
수정해야 할 파일 목록:

Data/LockerDbContext.cs
아래는 이 수정 사항을 반영한 LockerDbContext.cs 파일 전체 코드(주석 제외)입니다.

C#

using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        private const string ConnectionStringName = "LockerDbConnection";

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();
            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (로그 저장 분리)

        public override int SaveChanges()
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 시작...");
            // 1. 로그 생성을 위해 변경 전 상태 캡처
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(false); Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}"); }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            int result = 0;
            try
            {
                // 2. 원본 데이터 변경 사항만 먼저 저장
                Debug.WriteLine($"  -> base.SaveChanges() 호출 시도 (원본 데이터)...");
                result = base.SaveChanges();
                Debug.WriteLine($"  -> base.SaveChanges() 완료 (원본 데이터). 결과 = {result}");
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }

            // 3. 원본 저장이 성공했고 생성된 로그가 있으면 로그만 별도로 저장
            if (result > 0 && auditEntries != null && auditEntries.Any())
            {
                try
                {
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 및 SaveChanges 시도...");
                    this.AuditLogs.AddRange(auditEntries);
                    base.SaveChanges(); // 로그만 저장 (별도 트랜잭션 또는 컨텍스트 관리 필요 시 수정)
                    Debug.WriteLine($"  -> 로그 저장 완료.");
                }
                catch (Exception ex)
                {
                    // 로그 저장 실패는 기록만 하고 무시 (원본 작업은 이미 커밋됨)
                    Debug.WriteLine($"!!! 감사 로그 저장 실패 (동기): {ex.ToString()}");
                }
            }
            else if (result <= 0) { Debug.WriteLine("  -> 원본 데이터 변경 없음. 로그 저장 안 함."); }
            else { Debug.WriteLine("  -> 추가할 로그 없음."); }

            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 종료.");
            return result; // 원본 데이터 저장 결과 반환
        }

        public override async Task<int> SaveChangesAsync()
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기) Override 시작...");
             List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(false); Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}"); }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            int result = 0;
            try
            {
                Debug.WriteLine($"  -> base.SaveChangesAsync() 호출 시도 (원본 데이터)...");
                result = await base.SaveChangesAsync(); // 원본 데이터 변경 사항만 먼저 저장
                Debug.WriteLine($"  -> base.SaveChangesAsync() 완료 (원본 데이터). 결과 = {result}");
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }

            if (result > 0 && auditEntries != null && auditEntries.Any())
            {
                try
                {
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 및 SaveChangesAsync 시도...");
                    this.AuditLogs.AddRange(auditEntries);
                    await base.SaveChangesAsync(); // 로그만 저장
                    Debug.WriteLine($"  -> 로그 저장 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (비동기): {ex.ToString()}"); }
            }
             else if (result <= 0) { Debug.WriteLine("  -> 원본 데이터 변경 없음. 로그 저장 안 함."); }
             else { Debug.WriteLine("  -> 추가할 로그 없음."); }

            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(비동기) Override 종료.");
            return result; // 원본 데이터 저장 결과 반환
        }

        // isMaster 파라미터를 받는 SaveChanges 오버로드는 제거하거나, 위 로직을 반영하여 수정해야 합니다.
        // ViewModel에서는 이제 기본 SaveChanges/SaveChangesAsync만 호출하면 됩니다.
        // public int SaveChanges(bool isMaster) { ... }
        // public Task<int> SaveChangesAsync(bool isMaster) { ... }

        // CancellationToken을 받는 SaveChangesAsync 오버라이드
        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken)
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(CancellationToken) Override 시작...");
             List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(false); Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}"); } // isMaster 기본값 false
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            int result = 0;
            try
            {
                Debug.WriteLine($"  -> base.SaveChangesAsync(cancellationToken) 호출 시도 (원본 데이터)...");
                result = await base.SaveChangesAsync(cancellationToken); // 원본 데이터 저장 + CancellationToken 전달
                Debug.WriteLine($"  -> base.SaveChangesAsync(cancellationToken) 완료 (원본 데이터). 결과 = {result}");
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync(CancellationToken) 작업 취소됨."); throw; } // 취소 예외는 다시 던짐
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync(CancellationToken) 중 일반 오류 (비동기): {ex.ToString()}"); throw; }

            if (result > 0 && auditEntries != null && auditEntries.Any())
            {
                if (cancellationToken.IsCancellationRequested) { Debug.WriteLine("  -> 작업 취소 요청으로 로그 저장 건너뜀."); return result; }
                try
                {
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 및 SaveChangesAsync 시도...");
                    this.AuditLogs.AddRange(auditEntries);
                    // 로그 저장 시에는 CancellationToken을 전달하지 않거나, 별도 관리 필요
                    await base.SaveChangesAsync(); // 로그만 저장
                    Debug.WriteLine($"  -> 로그 저장 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (비동기): {ex.ToString()}"); }
            }
             else if (result <= 0) { Debug.WriteLine("  -> 원본 데이터 변경 없음. 로그 저장 안 함."); }
             else { Debug.WriteLine("  -> 추가할 로그 없음."); }

            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(CancellationToken) Override 종료.");
            return result;
        }


        private List<AuditLog> CreateAuditEntries(bool isMaster)
        {
            Debug.WriteLine("  CreateAuditEntries 시작...");
            string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
            string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
            var auditEntries = new List<AuditLog>();
            // 중요: 로그를 추가하기 전에 변경된 엔티티 목록을 가져옵니다.
            var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

            if (!changedEntries.Any()) { Debug.WriteLine("  CreateAuditEntries: 감지된 변경 엔티티 없음."); return auditEntries; }

            Debug.WriteLine($"  CreateAuditEntries: 감지된 변경 엔티티 수 = {changedEntries.Count}");
            var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) { Debug.WriteLine("    - AuditLog 엔티티 변경 감지됨 (로깅 건너뜀)."); continue; }

                var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() };
                try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();
                if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Modified) { bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }
                auditEntries.Add(auditEntry);
                Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}");
            }
            // 타임스탬프 업데이트는 원본 저장 전에 수행되어야 함
            UpdateLockerAssignmentTimestamps(changedEntries);
            Debug.WriteLine("  CreateAuditEntries 종료.");
            return auditEntries;
        }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps: {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        #endregion

        #region Error Logging Helpers
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
핵심 변경 사항:

SaveChanges/SaveChangesAsync 로직 변경:
메서드 시작 시 CreateAuditEntries를 호출하여 로그 목록(auditEntries)을 미리 생성합니다.
base.SaveChanges() 또는 base.SaveChangesAsync()를 호출하여 원본 데이터 변경 사항만 먼저 저장합니다.
원본 저장이 성공하면 (result > 0), 생성해 두었던 auditEntries를 this.AuditLogs.AddRange()로 컨텍스트에 추가하고, 다시 base.SaveChanges() 또는 base.SaveChangesAsync()를 호출하여 로그만 저장합니다.