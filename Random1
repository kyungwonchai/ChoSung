네, 우분투 Nginx를 사용해 여러 내부 서비스를 하나로 묶는 인트라넷 포털을 구축하는 방법에 대해 상세히 설명해 드리겠습니다.

기존에 외부주소:포트로 접속하던 방식에서 Nginx 리버스 프록시를 사용해 내부로 돌리는 것은 매우 일반적이고 효율적인 방법입니다. 가장 큰 장점은 사용자가 포트 번호를 외울 필요 없이 깔끔한 주소로 각 서비스에 접근할 수 있다는 것입니다.

다만, 이때 가장 흔하게 발생하는 문제가 바로 CSS/JS/이미지 파일의 경로 깨짐 현상입니다. 이 부분에 대한 해결책까지 포함하여 전체 시나리오를 안내해 드리겠습니다.

1. 메인 화면(포털) 꾸미기: 어떤 기술을 선택할까?
메인 화면은 단순히 여러 서비스를 연결해주는 '대문' 역할만 하면 되므로, 복잡한 기술 없이 가볍고 빠르게 만드는 것이 가장 좋습니다.

추천 1: 순수 HTML + CSS (가장 간단하고 좋음)
별도의 서버 기술 없이 정적인 파일만으로 메뉴를 구성하는 방식입니다.

장점: 매우 가볍고 빠릅니다. 서버 부하가 전혀 없고, 유지보수가 가장 쉽습니다.

단점: 동적인 컨텐츠(예: 각 서비스의 현재 상태 표시)를 보여주려면 JavaScript를 좀 더 사용해야 합니다.

결론: 단순 링크 메뉴를 제공하는 목적이라면 이 방법이 가장 이상적입니다.

추천 2: 기성 대시보드 프레임워크 사용
Homepage, Dashy, Heimdall 같은 오픈소스 대시보드 프로젝트를 사용하는 방법입니다.

장점: 설치가 간단하고(주로 Docker 사용), 기본적으로 미려한 UI를 제공합니다. 설정 파일(YAML)에 서비스 목록만 적어주면 자동으로 예쁜 메뉴가 만들어집니다.

단점: 커스터마이징에 한계가 있을 수 있고, 가벼운 Docker 컨테이너가 하나 더 실행되어야 합니다.

결론적으로, 직접 간단한 메뉴 페이지를 만들고 싶으시다면 순수 HTML/CSS를, 설치형으로 멋진 대시보드를 원하시면 'Homepage' 같은 프레임워크를 추천합니다.

2. 기존 서비스를 Nginx로 통합 시 문제점 및 해결책
http://10.222.111.222:8101로 접속하던 Flask 앱을 http://10.222.111.222/programs로 바꾸면 왜 스타일이 깨질까요?

근본적인 원인은 웹 애플리케이션(Flask, React 등)이 자신의 CSS나 JS 파일을 요청할 때 사용하는 경로 때문입니다.

앱은 보통 /static/style.css 와 같이 절대 경로로 리소스를 요청합니다.

http://10.222.111.222:8101 에서는 이 경로가 http://10.222.111.222:8101/static/style.css로 올바르게 해석됩니다.

하지만 http://10.222.111.222/programs 로 접속하면, 브라우저는 이 경로를 http://10.222.111.222/static/style.css 로 해석합니다. Nginx 설정상 이 주소에 해당하는 파일이 없으므로 404 Not Found 오류가 발생하고 스타일이 깨지는 것입니다. 올바른 요청 주소는 http://10.222.111.222/programs/static/style.css 여야 합니다.

해결책 1: (가장 권장) 서브도메인 사용
가장 깔끔하고 근본적인 해결책입니다. 각 서비스를 서브디렉토리(.../programs)가 아닌 서브도메인(programs.내부도메인)으로 분리하는 것입니다.

programs.my-intranet.com -> localhost:8101 (Flask 앱)

monitor.my-intranet.com -> localhost:8921 (Streamlit 앱)

react.my-intranet.com -> localhost:3000 (React 앱)

이 방식은 각 앱이 독립적인 도메인에서 실행되므로 경로 문제가 원천적으로 발생하지 않습니다. 내부망이라면 /etc/hosts 파일을 수정하거나 내부 DNS 서버를 구축하여 간단히 구현할 수 있습니다.

해결책 2: (차선책) Nginx의 proxy_pass 기능 활용
서브디렉토리 방식(.../programs)을 꼭 써야 한다면, Nginx 설정으로 어느 정도 해결할 수 있습니다. proxy_pass 지시어 뒤에 /를 붙이는 것이 핵심입니다.

location /programs/ 로 설정하고 proxy_pass http://127.0.0.1:8101/; 처럼 뒤에 /를 붙이면, Nginx는 /programs/ 부분을 제거하고 나머지 경로만 백엔드 서버로 넘겨줍니다.

http://서버/programs/some/path -> http://127.0.0.1:8101/some/path 로 전달

주의: 이 방법으로도 앱 내부 HTML에 /static/style.css 처럼 경로가 하드코딩된 부분은 해결되지 않을 수 있습니다. 이 경우 앱 코드를 수정하거나, Nginx의 sub_filter 기능으로 응답 내용을 직접 수정해야 해서 복잡해집니다.

3. 전체 통합 시나리오 (예제)
http://10.244.222.222 로 접속 시 메인 포털이 보이고, 여기서 /programs 와 /monitor 로 각 서비스에 접근하는 구성 예제입니다.

1단계: 메인 포털용 HTML 파일 생성
Nginx가 웹 루트로 사용할 디렉토리를 정하고, 그 안에 index.html 파일을 만듭니다.
예를 들어 /var/www/html/portal 디렉토리를 사용하겠습니다.

Bash

# 디렉토리 생성 및 권한 설정
sudo mkdir -p /var/www/html/portal
sudo chown -R www-data:www-data /var/www/html/portal

# index.html 파일 생성
sudo nano /var/www/html/portal/index.html
/var/www/html/portal/index.html 파일 내용

HTML

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>인트라넷 포털</title>
    <style>
        body { font-family: sans-serif; display: flex; justify-content: center; align-items: center; height: 100vh; background-color: #f0f2f5; }
        .container { text-align: center; }
        .service-link { display: inline-block; margin: 20px; padding: 30px; background-color: white; border-radius: 10px; box-shadow: 0 4px 8px rgba(0,0,0,0.1); text-decoration: none; color: #333; font-size: 24px; transition: transform 0.2s; }
        .service-link:hover { transform: scale(1.05); }
    </style>
</head>
<body>
    <div class="container">
        <h1>내부 서비스 포털</h1>
        <div>
            <a href="/programs/" class="service-link">프로그램 다운로드</a>
            <a href="/monitor/" class="service-link">모니터링 시스템</a>
            </div>
    </div>
</body>
</html>
2단계: Nginx 설정 파일 작성
/etc/nginx/sites-available/ 안에 새 설정 파일을 만듭니다.

Bash

sudo nano /etc/nginx/sites-available/my-portal
my-portal 파일 내용

Nginx

server {
    # 80번 포트로 들어오는 요청을 처리
    listen 80;
    server_name 10.244.222.222; # 여기에 서버 IP 주소 또는 도메인 입력

    # 기본 접속(/) 시 메인 포털 페이지를 보여줌
    location / {
        root /var/www/html/portal; # 1단계에서 만든 HTML 파일이 있는 경로
        index index.html;
        try_files $uri $uri/ =404;
    }

    # '/programs/' 경로로 오는 요청은 8101 포트로 전달 (Flask 앱)
    location /programs/ {
        # proxy_pass 뒤에 IP와 포트, 그리고 맨 끝에 '/' 를 붙이는 것이 매우 중요합니다!
        # 이렇게 해야 Nginx가 /programs/ 부분을 떼고 백엔드로 전달합니다.
        proxy_pass http://127.0.0.1:8101/;

        # 클라이언트의 원래 IP와 프로토콜 등의 정보를 백엔드 서버로 전달하기 위한 설정
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
    }

    # '/monitor/' 경로로 오는 요청은 8921 포트로 전달 (Streamlit 앱 등)
    location /monitor/ {
        # 마찬가지로 맨 끝에 '/' 를 붙여줍니다.
        proxy_pass http://127.0.0.1:8921/;

        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        
        # Streamlit, React 등 Websocket을 사용하는 앱을 위한 설정
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "Upgrade";
    }

    # React 앱과 연결된 API 서버가 여러 개일 경우
    # 예: React 앱은 3000번, API 서버1은 9001번, API 서버2는 9002번일 때
    # React 앱에서 API 호출 주소를 /api1/, /api2/ 와 같이 설정했다고 가정

    # location /react-app/ { ... React 앱 proxy_pass ... }

    # location /api1/ {
    #    proxy_pass http://127.0.0.1:9001/;
    # }
    # location /api2/ {
    #    proxy_pass http://127.0.0.1:9002/;
    # }
}
3단계: Nginx 설정 활성화 및 재시작
Bash

# 기존 default 설정을 비활성화 (필요 시)
sudo rm /etc/nginx/sites-enabled/default

# 새로 만든 설정을 활성화
sudo ln -s /etc/nginx/sites-available/my-portal /etc/nginx/sites-enabled/

# Nginx 설정 파일에 문법 오류가 없는지 테스트
sudo nginx -t

# 테스트 결과가 정상이면 Nginx 재시작