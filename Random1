 문제 정리 및 해결 방향
데이터 조회 후 즉시 비동기 처리 필요 → async Task 사용하여 await로 비동기 실행
매크로 동작이 여러 개이므로 필요한 동작 세트 관리 필요 → 패키지 단위로 구성
각 패키지는 독립된 파일로 두고 메인에서 실행 → 유지보수성과 가독성 향상
각 데이터 행을 특정 패키지에서 매크로 동작으로 변환 가능해야 함
📂 1. 새로운 프로젝트 구조 (패키지 기반 설계)
pgsql
코드 복사
📦 AutoHandleSolution
 ┣ 📂 AAutoHandle
 ┃ ┣ 📂 Commands
 ┃ ┃ ┣ 📜 IMacroCommand.cs
 ┃ ┃ ┣ 📜 KeyboardCommand.cs
 ┃ ┃ ┣ 📜 MouseClickCommand.cs
 ┃ ┃ ┣ 📜 DelayCommand.cs
 ┃ ┃ ┣ 📜 ScreenCaptureCommand.cs
 ┃ ┃ ┗ 📜 CVCommand.cs
 ┃ ┣ 📂 Core
 ┃ ┃ ┣ 📜 MacroExecutor.cs
 ┃ ┃ ┣ 📜 MacroManager.cs
 ┃ ┃ ┗ 📜 MacroLogger.cs
 ┃ ┣ 📂 Database
 ┃ ┃ ┣ 📜 MySqlHelper.cs
 ┃ ┃ ┣ 📜 MsSqlHelper.cs
 ┃ ┃ ┗ 📜 DatabaseReader.cs
 ┃ ┣ 📂 MacroPackages  ★ 매크로 동작 패키지 모음
 ┃ ┃ ┣ 📜 MacroPackageA.cs
 ┃ ┃ ┣ 📜 MacroPackageB.cs
 ┃ ┃ ┗ 📜 MacroPackageC.cs
 ┃ ┣ 📂 Forms
 ┃ ┃ ┗ 📜 MainForm.cs
 ┃ ┣ 📜 Program.cs
 ┃ ┗ 📜 AAutoHandle.csproj
 ┗ 📜 AutoHandleSolution.sln
📜 2. 비동기 데이터 조회 및 패키지 기반 처리
🔹 1️⃣ DatabaseReader.cs (비동기 데이터 조회 및 처리)
csharp
코드 복사
namespace AAutoHandle.Database
{
    using System;
    using System.Data;
    using System.Threading.Tasks;
    using MySql.Data.MySqlClient;
    using System.Data.SqlClient;

    public class DatabaseReader
    {
        private readonly MySqlHelper _mySqlHelper;
        private readonly MsSqlHelper _msSqlHelper;

        public DatabaseReader(string mysqlConnString, string mssqlConnString)
        {
            _mySqlHelper = new MySqlHelper(mysqlConnString);
            _msSqlHelper = new MsSqlHelper(mssqlConnString);
        }

        public async Task ReadMySqlDataAsync(string procedureName, Func<DataRow, Task> processRow, params MySqlParameter[] parameters)
        {
            var table = _mySqlHelper.ExecuteStoredProcedure(procedureName, parameters);
            foreach (DataRow row in table.Rows)
            {
                await processRow(row);
            }
        }

        public async Task ReadMsSqlDataAsync(string procedureName, Func<DataRow, Task> processRow, params SqlParameter[] parameters)
        {
            var table = _msSqlHelper.ExecuteStoredProcedure(procedureName, parameters);
            foreach (DataRow row in table.Rows)
            {
                await processRow(row);
            }
        }
    }
}
✅ Func<DataRow, Task> 사용하여 메인 함수에서 비동기 처리 가능!
✅ 반복 처리를 await로 실행하여 동작 순서가 보장됨

🔹 2️⃣ MacroPackageA.cs (매크로 동작 패키지 A)
csharp
코드 복사
namespace AAutoHandle.MacroPackages
{
    using System;
    using System.Data;
    using System.Threading.Tasks;
    using AAutoHandle.Core;
    using AAutoHandle.Commands;

    public class MacroPackageA
    {
        public async Task ExecuteAsync(DataRow row)
        {
            var macroManager = MacroManager.Instance;

            int x = Convert.ToInt32(row["x"]);
            int y = Convert.ToInt32(row["y"]);
            string capturePath = row["capturePath"].ToString();

            macroManager.AddCommand(new MouseClickCommand(x, y));
            macroManager.AddCommand(new DelayCommand(500));
            macroManager.AddCommand(new ScreenCaptureCommand(capturePath));

            await macroManager.StartExecutionAsync();
        }
    }
}
✅ 데이터 기반으로 동작을 정의하는 패키지 A
✅ 데이터 행 값에 따라 매크로 동작이 달라질 수 있음

🔹 3️⃣ MainForm.cs (UI에서 동작 실행)
csharp
코드 복사
using System;
using System.Data;
using System.Threading.Tasks;
using System.Windows.Forms;
using AAutoHandle.Database;
using AAutoHandle.MacroPackages;
using MySql.Data.MySqlClient;
using System.Data.SqlClient;

namespace AAutoHandle
{
    public partial class MainForm : Form
    {
        private DatabaseReader _dbReader;
        private MacroPackageA _macroPackageA;

        public MainForm()
        {
            InitializeComponent();

            string mysqlConn = "Server=localhost;Database=mydb;User=root;Password=1234;";
            string mssqlConn = "Server=myserver;Database=mydb;User Id=myuser;Password=mypassword;";

            _dbReader = new DatabaseReader(mysqlConn, mssqlConn);
            _macroPackageA = new MacroPackageA();
        }

        private async void btnLoadMySqlData_Click(object sender, EventArgs e)
        {
            listBoxLogs.Items.Clear();
            await _dbReader.ReadMySqlDataAsync("sp_GetData",
                async row =>
                {
                    listBoxLogs.Items.Add($"{row["id"]}: {row["name"]}");
                    await _macroPackageA.ExecuteAsync(row);
                });
        }

        private async void btnLoadMsSqlData_Click(object sender, EventArgs e)
        {
            listBoxLogs.Items.Clear();
            await _dbReader.ReadMsSqlDataAsync("sp_GetData",
                async row =>
                {
                    listBoxLogs.Items.Add($"{row["id"]}: {row["name"]}");
                    await _macroPackageA.ExecuteAsync(row);
                });
        }
    }
}
✅ DatabaseReader에서 데이터를 가져오면 MacroPackageA에서 자동 실행!
✅ UI ListBox에도 바로 데이터가 업데이트됨

📜 3. 실행 흐름
✅ btnLoadMySqlData_Click() 실행 →
MySQL sp_GetData 프로시저 실행 → DataRow 가져오기
MacroPackageA.ExecuteAsync(row) 비동기 실행
마우스 클릭 → 0.5초 딜레이 → 화면 캡처 실행
ListBox에 데이터도 추가됨
📜 4. 확장 가능성
✅ 필요한 동작 세트(패키지)만 골라 실행 가능!
✅ 패키지 추가 시 MacroPackageB.cs, MacroPackageC.cs 등 생성하면 끝
✅ 데이터 기반으로 자동 실행이므로 유연성이 극대화됨
✅ UI에서 버튼 하나만 눌러도 여러 매크로 동작이 순차 실행됨

📌 결론
데이터 조회 → 즉시 비동기 처리 (async Task)
패키지 단위로 매크로 동작을 정의 (MacroPackages)
UI에서 필요한 패키지만 골라 실행
매크로 동작이 복잡해져도 패키지별 파일 분리로 가독성 유지