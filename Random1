알겠습니다. 이전 설명들로 인해 혼란을 드린 점 다시 한번 사과드립니다. 처음부터 다시 정리해서 MonitorAgent 프로그램의 전체 코드를 제공해 드리겠습니다. 이 코드는 사용자님의 최근 요구사항(IP 기반 ID, 명령줄 인자로 중계기 주소 수신, 날짜별 로그 및 자동 삭제)을 모두 반영한 버전입니다.

MonitorAgent 프로그램의 최종 목표 기능:

설정 최소화: 실행 시 중계 프로그램의 주소와 포트를 명령줄 인자로 전달받습니다. 자신의 고유 ID는 IP 주소를 기반으로 자동 식별합니다.
로그 관리: Logs 폴더에 날짜별(yyyy-MM-dd.log)로 로그를 기록하며, 3일이 지난 로그 파일은 자동으로 삭제합니다.
중계 프로그램과 TCP 통신:
중계 프로그램(MGSPBrokerService)에 TCP 클라이언트로 접속하여 연결을 유지합니다.
접속 성공 시 자신의 정보(AgentIdProvidedByApp는 IP 기반 ID, 머신 이름, IP 목록, 버전, 초기 모니터 상태 등)를 AgentHello 메시지로 전송합니다.
주기적으로 현재 모니터 상태를 AgentStatusUpdate 메시지로 보고합니다.
중계 프로그램으로부터 Ping을 받으면 Pong으로 응답합니다.
명령 수신 및 처리:
중계 프로그램으로부터 BrokerToAgent_ExecuteControl 메시지를 받습니다.
페이로드의 IsGatewayRelayRequired 값에 따라 동작합니다:
false (자신이 최종 대상): ActionToPerform(예: "TurnMonitorOn", "TurnMonitorOff")을 로컬에서 실행하고, 결과를 AgentCommandResult 메시지로 중계 프로그램에 보고합니다.
true (자신이 게이트웨이 역할): 페이로드의 FinalTargetAgentIp 및 FinalTargetAgentPort로 새로운 TCP 연결을 시도하여, 최종 대상 Agent에게 실제 명령을 전달하고 그 결과를 받아 중계 프로그램에 보고합니다.
실행 형태: WPF 애플리케이션이지만, 주 UI 창 없이 트레이 아이콘으로만 실행됩니다.
프로젝트 설정 (MonitorAgent.csproj):

출력 형식: Windows 애플리케이션
대상 프레임워크: .NET Framework 4.5
참조 추가: System.Windows.Forms, System.Drawing (트레이 아이콘 사용 시)
필요한 NuGet 패키지:

Newtonsoft.Json: (버전 12.x 또는 13.x 등 .NET Framework 4.5 호환)
패키지 관리자 콘솔: Install-Package Newtonsoft.Json
전체 코드 (MonitorAgent 프로젝트):

1. Models/MessageContract.cs (공통 파일)

이 파일은 MGSPBrokerService 프로젝트와 완전히 동일한 내용이어야 합니다. 이전에 제공해 드린 MonitorControl.SharedModels 네임스페이스를 사용하는 MessageContract.cs 코드를 이 프로젝트의 Models 폴더에 그대로 복사해 넣어주십시오. (여기서는 해당 파일의 내용을 다시 반복하지 않겠습니다. 이전 답변을 참조해주세요.)

반드시 네임스페이스는 MonitorControl.SharedModels로, 내용은 다른 프로젝트와 동일하게 유지해야 합니다.

2. Config/AppConstants.cs

C#

// MonitorAgent/Config/AppConstants.cs
namespace MonitorAgent.Config
{
    public static class AppConstants
    {
        // Agent ID는 이제 IP 기반으로 동적 생성되므로, ID 저장 파일은 사용하지 않음.
        // 중계 서버 주소는 명령줄 인자로 받으므로, 주소 파일도 사용하지 않음.
        
        public const string LogDirectoryName = "Logs";
        public const string LogFileNameDateFormat = "yyyy-MM-dd"; // 예: 2025-05-16.log
        public const string AppName = "MonitorAgent"; // 시작 프로그램 등록 등에 사용
        public const int DaysToKeepLogs = 3; // 로그 보관 일수
    }
}
3. Config/AgentIdentifier.cs (수정됨)

C#

// MonitorAgent/Config/AgentIdentifier.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using MonitorAgent.Services; // ILoggingService 네임스페이스

namespace MonitorAgent.Config
{
    public class AgentIdentifier
    {
        private readonly ILoggingService _logger;
        
        /// <summary>
        /// 이 Agent를 식별하는 주 IP 주소. 중계기에 AgentIdProvidedByApp의 기반이 됩니다.
        /// </summary>
        public string PrimaryIpAddress { get; private set; }

        /// <summary>
        /// Agent가 가진 모든 사용 가능한 로컬 IPv4 주소 목록입니다.
        /// </summary>
        public List<string> AllIpAddresses { get; private set; }

        /// <summary>
        /// Agent의 고유 식별자 (PrimaryIpAddress 또는 IP를 못찾을 시 대체 ID).
        /// 이 값이 AgentHelloPayload의 AgentIdProvidedByApp에 사용됩니다.
        /// </summary>
        public string UniqueId { get; private set; }

        public AgentIdentifier(ILoggingService logger)
        {
            _logger = logger;
            DetermineIdentifiers();
        }

        private void DetermineIdentifiers()
        {
            AllIpAddresses = GetLocalIpAddressesStatic(_logger);

            if (AllIpAddresses.Any())
            {
                // 여러 IP 중 대표 IP 선택 로직 (더 정교하게 만들 수 있음)
                // 여기서는 유효한 첫 번째 IP를 사용. 외부 통신 가능한 IP를 우선하는 로직 필요.
                PrimaryIpAddress = AllIpAddresses.FirstOrDefault(ip => !string.IsNullOrEmpty(ip) && ip != "127.0.0.1");
                if (string.IsNullOrEmpty(PrimaryIpAddress)) // 127.0.0.1만 있다면 그것이라도 사용
                {
                    PrimaryIpAddress = AllIpAddresses.FirstOrDefault(ip => !string.IsNullOrEmpty(ip));
                }
                
                if (string.IsNullOrEmpty(PrimaryIpAddress))
                {
                    PrimaryIpAddress = "IP_Not_Found";
                }
                UniqueId = PrimaryIpAddress; // IP 주소 자체를 고유 ID로 사용
                _logger.LogInfo($"Agent Primary IP determined: {PrimaryIpAddress}. All IPs: {string.Join(", ", AllIpAddresses)}. Unique ID set to: {UniqueId}");
            }
            else
            {
                _logger.LogWarning("No valid local IP addresses found for Agent identification.");
                PrimaryIpAddress = "UnknownIP";
                AllIpAddresses = new List<string> { PrimaryIpAddress };
                string fallbackIdBase = $"{Environment.MachineName.Replace(" ", "_").Replace(".", "_")}-{Guid.NewGuid().ToString("N").Substring(0, 8)}";
                UniqueId = $"NO_IP_FALLBACK_{fallbackIdBase}";
                 _logger.LogError($"CRITICAL: Agent could not determine a primary IP address. Using fallback ID: {UniqueId}. This agent might not be controllable if UI relies on IP for targeting.");
            }
        }

        public static List<string> GetLocalIpAddressesStatic(ILoggingService loggerForStatic)
        {
            var ipAddressList = new List<string>();
            try
            {
                if (!NetworkInterface.GetIsNetworkAvailable())
                {
                    loggerForStatic?.LogWarning("No network connection is available.");
                    return ipAddressList;
                }

                var upInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up &&
                                 ni.NetworkInterfaceType != NetworkInterfaceType.Loopback &&
                                 ni.NetworkInterfaceType != NetworkInterfaceType.Tunnel)
                    .OrderByDescending(ni => ni.GetIPProperties().GatewayAddresses.Any()) // 게이트웨이 있는 인터페이스 우선
                    .ThenByDescending(ni => ni.Speed); // 그 다음 속도 높은 인터페이스 우선

                foreach (NetworkInterface item in upInterfaces)
                {
                    foreach (UnicastIPAddressInformation ipInfo in item.GetIPProperties().UnicastAddresses)
                    {
                        if (ipInfo.Address.AddressFamily == AddressFamily.InterNetwork) // IPv4만
                        {
                            // 블랙리스트 IP (예: APIPA 주소 169.254.x.x) 제외 가능
                            if (ipInfo.Address.ToString().StartsWith("169.254.")) continue;
                            ipAddressList.Add(ipInfo.Address.ToString());
                        }
                    }
                }
                
                if (!ipAddressList.Any())
                {
                    loggerForStatic?.LogWarning("No suitable IPv4 addresses found on active, non-loopback/tunnel interfaces.");
                }
            }
            catch (Exception ex)
            {
                loggerForStatic?.LogError("Error getting local IP addresses", ex);
            }
            return ipAddressList.Distinct().ToList();
        }
    }
}
4. Services/LoggingService.cs (수정됨 - 이전 답변과 동일)

이전 답변에서 제공한 날짜별 로그 및 오래된 로그 삭제 기능이 포함된 MonitorAgent/Services/LoggingService.cs 코드를 그대로 사용합니다. (이전 답변의 "2. MonitorAgent/Services/LoggingService.cs (수정된 최종본)" 부분을 참조하십시오.)

5. Services/MonitorControlService.cs (이전 답변과 동일)

모니터 제어 로직은 변경되지 않았습니다. 이전 답변의 MonitorAgent/Services/MonitorControlService.cs 코드를 그대로 사용합니다.

6. Network/BrokerTcpClient.cs (수정됨)

중계 서버(MGSPBrokerService)와 통신하는 TCP 클라이언트입니다. AgentHelloPayload 구성 시 AgentIdentifier에서 가져온 IP 정보를 사용합니다.

C#

// MonitorAgent/Network/BrokerTcpClient.cs
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Generic; // List<string>
using System.Reflection;    // Assembly
using MonitorAgent.Config;    // AgentIdentifier
using MonitorAgent.Models;    // BrokerMessage, AgentHelloPayload 등 (네임스페이스 주의!)
using MonitorAgent.Services;  // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // <<< 공용 MessageContract 사용!

namespace MonitorAgent.Network
{
    public class BrokerTcpClient : IDisposable
    {
        private readonly string _brokerIp;
        private readonly int _brokerPort;
        private readonly AgentIdentifier _agentIdentifier; // Agent의 고유 ID 및 IP 정보 제공
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly TimeSpan _retryConnectDelay = TimeSpan.FromSeconds(10);
        private readonly TimeSpan _statusReportInterval = TimeSpan.FromSeconds(30);
        private Timer _statusReportTimer;
        private readonly Func<string> _getCurrentMonitorStatusFunc;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;
        private string _osVersion;

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null;

        public event Action<BrokerMessage> OnBrokerMessageReceived;
        public event Action OnDisconnectedFromBroker;
        public event Action OnIdentifiedToBroker; // Broker에게 성공적으로 Hello 메시지 보낸 후

        public BrokerTcpClient(string brokerIp, int brokerPort, AgentIdentifier agentIdentifier, ILoggingService logger, Func<string> getCurrentMonitorStatusFunc)
        {
            _brokerIp = brokerIp;
            _brokerPort = brokerPort;
            _agentIdentifier = agentIdentifier;
            _logger = logger;
            _getCurrentMonitorStatusFunc = getCurrentMonitorStatusFunc;
            try { _osVersion = Environment.OSVersion.VersionString; } catch { _osVersion = "N/A"; }
        }

        public async Task StartAsync(CancellationTokenSource parentCts)
        {
            if (string.IsNullOrEmpty(_brokerIp) || _brokerPort <= 0)
            {
                _logger.LogError("Broker IP or Port is invalid. Cannot start BrokerTcpClient.");
                return;
            }
            _cts = CancellationTokenSource.CreateLinkedTokenSource(parentCts.Token);
            _ = Task.Run(ConnectAndReceiveLoopAsync, _cts.Token); // 백그라운드에서 실행
        }
        
        private async Task ConnectAndReceiveLoopAsync()
        {
            while (!_cts.IsCancellationRequested && !_isDisposed)
            {
                if (!IsConnected)
                {
                    try
                    {
                        _logger.LogInfo($"Attempting to connect to Broker: {_brokerIp}:{_brokerPort}");
                        _tcpClient = new TcpClient();
                        // TcpClient.ConnectAsync는 CancellationToken을 직접 받지 않으므로, Task.WhenAny로 타임아웃 처리
                        var connectTask = _tcpClient.ConnectAsync(_brokerIp, _brokerPort);
                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5), _cts.Token); // 5초 연결 타임아웃

                        if (await Task.WhenAny(connectTask, timeoutTask).ConfigureAwait(false) == connectTask && 
                            connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                        {
                            _networkStream = _tcpClient.GetStream();
                            _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                            _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                            _logger.LogInfo("Successfully connected to Broker.");

                            await SendAgentHelloAsync(); // 연결 성공 후 AgentHello 전송

                            // 상태 보고 타이머 시작 (연결 성공 후)
                            _statusReportTimer?.Dispose();
                            _statusReportTimer = new Timer(ReportStatusTimerCallback, null, TimeSpan.FromSeconds(5), _statusReportInterval); // 첫 보고는 5초 후

                            await ReceiveMessagesAsync(); // 이 메서드는 연결이 끊기면 종료됨
                        }
                        else
                        {
                            _tcpClient.Close(); // 연결 실패 또는 타임아웃 시 정리
                            if (_cts.IsCancellationRequested) { _logger.LogInfo("Connection loop cancelled during connect attempt."); break; }
                            _logger.LogWarning($"Failed to connect to Broker or timed out. Retrying in {_retryConnectDelay.TotalSeconds}s...");
                        }
                    }
                    catch (OperationCanceledException) when (_cts.IsCancellationRequested) {
                        _logger.LogInfo("Connection/Receive loop cancelled.");
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError($"Error during connection attempt to Broker: {ex.Message}. Retrying in {_retryConnectDelay.TotalSeconds}s...");
                         _tcpClient?.Close();
                    }
                }
                
                if (_cts.IsCancellationRequested) break;
                
                try
                {
                    await Task.Delay(_retryConnectDelay, _cts.Token);
                }
                catch (OperationCanceledException) { _logger.LogInfo("Retry delay cancelled."); break; }
            }
            _logger.LogInfo("BrokerTcpClient ConnectAndReceiveLoopAsync ended.");
            CleanupConnectionResources();
            OnDisconnectedFromBroker?.Invoke();
        }

        private async Task SendAgentHelloAsync()
        {
            var helloPayload = new AgentHelloPayload // MonitorControl.SharedModels.AgentHelloPayload 사용
            {
                AgentIdProvidedByApp = _agentIdentifier.UniqueId, // IP 기반 ID
                MachineName = Environment.MachineName,
                PrimaryReportedIpAddress = _agentIdentifier.PrimaryIpAddress,
                AllIpAddresses = _agentIdentifier.AllIpAddresses,
                AgentVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString(),
                OsVersion = _osVersion,
                InitialMonitorStatus = _getCurrentMonitorStatusFunc?.Invoke() ?? "Unknown"
            };
            var helloMessage = new BrokerMessage // MonitorControl.SharedModels.BrokerMessage 사용
            {
                Type = MessageType.AgentHello,
                SourceId = _agentIdentifier.UniqueId,
                Payload = JsonConvert.SerializeObject(helloPayload)
            };
            await SendMessageAsync(helloMessage);
            _logger.LogInfo($"AgentHello message sent to Broker (ID: {_agentIdentifier.UniqueId}).");
        }

        private async void ReportStatusTimerCallback(object state)
        {
            if (_isDisposed || _cts.IsCancellationRequested) return;
            await ReportCurrentStatusAsync();
        }

        public async Task ReportCurrentStatusAsync()
        {
            if (!IsConnected || _isDisposed) return;
            string monitorStatus = _getCurrentMonitorStatusFunc?.Invoke() ?? "Unknown";
            var statusPayload = new AgentStatusUpdatePayload { CurrentMonitorStatus = monitorStatus }; // MonitorControl.SharedModels
            var statusMessage = new BrokerMessage // MonitorControl.SharedModels
            {
                Type = MessageType.AgentStatusUpdate, // Enum도 MonitorControl.SharedModels
                SourceId = _agentIdentifier.UniqueId,
                Payload = JsonConvert.SerializeObject(statusPayload)
            };
            await SendMessageAsync(statusMessage);
        }

        public async Task ReportCommandResultAsync(string correlationId, bool success, string message, string currentMonitorStatus)
        {
             if (!IsConnected || _isDisposed) {
                _logger.LogWarning("Cannot report command result, not connected to Broker.");
                return;
             }
            var resultPayload = new AgentCommandResultPayload { Success = success, Message = message, CurrentMonitorStatus = currentMonitorStatus }; // MonitorControl.SharedModels
            var resultMessage = new BrokerMessage // MonitorControl.SharedModels
            {
                Type = MessageType.AgentCommandResult,
                SourceId = _agentIdentifier.UniqueId,
                CorrelationId = correlationId,
                Payload = JsonConvert.SerializeObject(resultPayload)
            };
            await SendMessageAsync(resultMessage);
            _logger.LogInfo($"Command result (CorrId: {correlationId}, Success: {success}) sent to Broker.");
        }

        private async Task ReceiveMessagesAsync()
        {
            if (_isDisposed) return;
            _logger.LogInfo($"Starting to receive messages from Broker for {_agentIdentifier.UniqueId}");
            try
            {
                while (!_cts.IsCancellationRequested && IsConnected && _streamReader != null)
                {
                    string messageJson = await _streamReader.ReadLineAsync().ConfigureAwait(false);
                    if (messageJson == null) {
                        _logger.LogInfo($"Broker disconnected or stream closed for {_agentIdentifier.UniqueId}.");
                        break; 
                    }
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson); // MonitorControl.SharedModels
                        if (message != null)
                        {
                            if(message.Type == MessageType.BrokerAck_AgentHello)
                            {
                                OnIdentifiedToBroker?.Invoke();
                            }
                            OnBrokerMessageReceived?.Invoke(message);
                        }
                        else { _logger.LogWarning($"Failed to deserialize message from Broker: {messageJson}"); }
                    }
                    catch (JsonException jsonEx) { _logger.LogError($"JSON deserialization error from Broker: {jsonEx.Message}. Received: {messageJson}", jsonEx); }
                }
            }
            catch (IOException ioEx) when (_cts.IsCancellationRequested || !IsConnected)
            { _logger.LogInfo($"IOException in receive loop from Broker for {_agentIdentifier.UniqueId} (likely connection closed or cancelled): {ioEx.Message}"); }
            catch (ObjectDisposedException)
            { _logger.LogInfo($"Receive loop for {_agentIdentifier.UniqueId} from Broker terminated due to object disposal."); }
            catch (OperationCanceledException)
            { _logger.LogInfo($"Receive loop for {_agentIdentifier.UniqueId} from Broker cancelled."); }
            catch (Exception ex)
            { if(!_cts.IsCancellationRequested && !_isDisposed) _logger.LogError($"Unexpected error in receive loop from Broker for {_agentIdentifier.UniqueId}: {ex.Message}", ex); }
            finally
            {
                _logger.LogInfo($"Receive loop from Broker for {_agentIdentifier.UniqueId} ended.");
                // 연결이 여기서 끊겼음을 인지하면, ConnectAndReceiveLoopAsync가 재연결 시도함.
                // 따라서 여기서 직접 CleanupConnectionResources()를 강하게 호출하기보다,
                // 루프 종료 시 자연스럽게 ConnectAndReceiveLoopAsync의 다음 반복에서 재연결 시도하도록 함.
                // 만약 _cts.IsCancellationRequested로 종료된 거라면 ConnectAndReceiveLoopAsync도 종료됨.
            }
        }
        
        public Task SendMessageAsync(BrokerMessage message) // MonitorControl.SharedModels
        {
            if (!IsConnected || _streamWriter == null || _isDisposed || (_cts != null && _cts.IsCancellationRequested))
            {
                _logger.LogWarning($"Cannot send message to Broker. Not connected, writer is null, disposed, or sending cancelled. MessageType: {message.Type}");
                return Task.FromResult(false);
            }

            string messageJson = "";
            try
            {
                messageJson = JsonConvert.SerializeObject(message);
                // lock을 사용하여 _streamWriter에 대한 동시 접근을 막음
                lock(_sendLock)
                {
                    if (IsConnected && _streamWriter != null && !_isDisposed && (_cts == null || !_cts.IsCancellationRequested))
                    {
                        _streamWriter.WriteLine(messageJson); // 동기적 쓰기
                        // _logger.LogDebug($"Message sent to Broker: {message.Type}"); // 너무 잦은 로그
                        return Task.FromResult(true); // .NET 4.5에는 Task.CompletedTask 없음
                    }
                    else
                    {
                         _logger.LogWarning($"Send cancelled or not possible for {message.Type} inside lock.");
                         return Task.FromResult(false);
                    }
                }
            }
            catch (ObjectDisposedException) { _logger.LogWarning($"Attempted to send {message.Type} to Broker on a disposed stream/writer."); }
            catch (IOException ioEx) { _logger.LogError($"IOException sending {message.Type} to Broker (connection may be lost): {ioEx.Message}", ioEx); }
            catch (JsonException jsonEx) { _logger.LogError($"Error serializing message {message.Type} to send to Broker: {jsonEx.Message}. Payload: {message.Payload}", jsonEx); }
            catch (Exception ex) { _logger.LogError($"Error sending {message.Type} to Broker: {ex.Message}", ex); }

            // 실패 시 연결 정리 및 재연결 유도 (ConnectAndReceiveLoopAsync에서 처리)
            if (!_isDisposed)
            {
                 CleanupConnectionResources(); // 여기서 정리하면 ConnectAndReceiveLoopAsync가 다시 연결 시도
                 OnDisconnectedFromBroker?.Invoke(); // 이벤트 발생
            }
            return Task.FromResult(false);
        }

        private void CleanupConnectionResources()
        {
            _logger.LogInfo($"Cleaning up connection resources for BrokerTcpClient (AgentId: {_agentIdentifier.UniqueId}).");
            _statusReportTimer?.Dispose();
            _statusReportTimer = null;

            lock(_sendLock) // SendMessageAsync와 동기화
            {
                try { _streamWriter?.Dispose(); } catch { /* ignore */ }
                _streamWriter = null;
            }
            try { _streamReader?.Dispose(); } catch { /* ignore */ }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { /* ignore */ }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { /* ignore */ }
            _tcpClient = null;
        }
        
        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            _logger.LogInfo($"Disposing BrokerTcpClient for AgentId: {_agentIdentifier.UniqueId}.");
            _cts?.Cancel(); 
            
            // _receiveLoopTask가 완료될 때까지 잠시 기다릴 수 있음 (선택적)
            // if (_receiveLoopTask != null && !_receiveLoopTask.IsCompleted)
            // {
            // try { _receiveLoopTask.Wait(TimeSpan.FromSeconds(1)); } catch { /* ignore */ }
            // }

            _cts?.Dispose(); // CancellationTokenSource도 Dispose
            _cts = null;

            CleanupConnectionResources();
            _logger.LogInfo($"BrokerTcpClient for AgentId: {_agentIdentifier.UniqueId} disposed.");
            GC.SuppressFinalize(this);
        }
    }
}
7. Network/DownstreamAgentClient.cs (수정됨)

이 클래스는 게이트웨이 Agent가 최종 대상 Agent와 통신할 때 사용합니다. MessageContract.cs의 타입을 사용하도록 수정합니다.

C#

// MonitorAgent/Network/DownstreamAgentClient.cs
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Services; // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // <<< 공용 MessageContract 사용!

namespace MonitorAgent.Network
{
    public class DownstreamAgentClient : IDisposable
    {
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null;

        public DownstreamAgentClient(ILoggingService logger)
        {
            _logger = logger;
        }

        public async Task<bool> ConnectAsync(string targetIp, int targetPort, CancellationToken token)
        {
            if (IsConnected) Disconnect(); 
            if (_isDisposed) throw new ObjectDisposedException(nameof(DownstreamAgentClient));

            _logger.LogInfo($"Downstream: Attempting to connect to final target Agent: {targetIp}:{targetPort}");
            _tcpClient = new TcpClient();
            try
            {
                var connectTask = _tcpClient.ConnectAsync(targetIp, targetPort);
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5), token); 

                if (await Task.WhenAny(connectTask, timeoutTask).ConfigureAwait(false) == connectTask && 
                    connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    _logger.LogInfo($"Downstream: Successfully connected to final target Agent {targetIp}:{targetPort}.");
                    return true;
                }
                else
                {
                    _tcpClient.Close();
                    if (token.IsCancellationRequested)
                        _logger.LogInfo("Downstream: Connection attempt to final target Agent cancelled.");
                    else
                        _logger.LogWarning($"Downstream: Timeout or error connecting to final target Agent {targetIp}:{targetPort}.");
                    return false;
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                 _logger.LogInfo("Downstream: Connection attempt to final target Agent cancelled by token.");
                 _tcpClient?.Close(); // 이미 닫혔거나 null일 수 있지만, 안전하게.
                 return false;
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error connecting to final target Agent {targetIp}:{targetPort}: {ex.Message}", ex);
                _tcpClient?.Close();
                return false;
            }
        }

        public async Task<AgentCommandResultPayload> SendCommandAndGetResponseAsync(
            BrokerExecuteControlPayload commandToRelayToFinalAgent, // 이 페이로드는 이미 IsGatewayRelay=false 로 설정되어 있어야 함
            string originalCorrelationId, 
            string gatewayAgentId, // 이 게이트웨이 Agent의 ID (SourceId로 사용)
            string finalTargetAgentActualId, // 최종 Agent의 ID (TargetId로 사용)
            CancellationToken token)
        {
            if (!IsConnected || _isDisposed)
            {
                _logger.LogError("Downstream: Not connected or disposed. Cannot send command.");
                return new AgentCommandResultPayload { Success = false, Message = "Gateway not connected to final agent." };
            }

            try
            {
                var messageToFinalAgent = new BrokerMessage // MonitorControl.SharedModels
                {
                    Type = MessageType.BrokerToAgent_ExecuteControl, // 최종 Agent는 이 타입의 메시지를 받음
                    CorrelationId = originalCorrelationId,
                    SourceId = gatewayAgentId, // 명령을 전달하는 주체는 이 게이트웨이 Agent
                    TargetId = finalTargetAgentActualId, // 이 명령의 최종 수신자
                    Payload = JsonConvert.SerializeObject(commandToRelayToFinalAgent)
                };

                string requestJson = JsonConvert.SerializeObject(messageToFinalAgent);
                _logger.LogDebug($"Downstream: Sending to final agent ({finalTargetAgentActualId}): {requestJson}");
                
                lock (_sendLock)
                {
                    if (IsConnected && _streamWriter != null && !_isDisposed) _writer.WriteLine(requestJson);
                    else throw new IOException("Downstream connection lost or writer disposed before send.");
                }

                // 응답 수신 (타임아웃 포함)
                var readTask = _streamReader.ReadLineAsync();
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), token); // 응답 대기 타임아웃 30초

                if (await Task.WhenAny(readTask, timeoutTask).ConfigureAwait(false) == readTask && readTask.Result != null)
                {
                    string responseJson = readTask.Result;
                    _logger.LogDebug($"Downstream: Received from final agent ({finalTargetAgentActualId}): {responseJson}");
                    var responseMessage = JsonConvert.DeserializeObject<BrokerMessage>(responseJson); // MonitorControl.SharedModels
                    if (responseMessage != null && responseMessage.Type == MessageType.AgentCommandResult) // MonitorControl.SharedModels
                    {
                        return JsonConvert.DeserializeObject<AgentCommandResultPayload>(responseMessage.Payload); // MonitorControl.SharedModels
                    }
                    else
                    {
                        _logger.LogWarning($"Downstream: Unexpected or invalid response from final agent ({finalTargetAgentActualId}): {responseJson}");
                        return new AgentCommandResultPayload { Success = false, Message = "Invalid response from final agent." };
                    }
                }
                else
                {
                    if (token.IsCancellationRequested)
                        _logger.LogWarning($"Downstream: Response wait cancelled for final agent ({finalTargetAgentActualId}).");
                    else
                        _logger.LogWarning($"Downstream: Timeout waiting for response from final agent ({finalTargetAgentActualId}).");
                    return new AgentCommandResultPayload { Success = false, Message = "Timeout or cancelled waiting for final agent response." };
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                _logger.LogWarning($"Downstream: Operation cancelled while communicating with final agent ({finalTargetAgentActualId}).");
                return new AgentCommandResultPayload { Success = false, Message = "Operation cancelled."};
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error during command relay to final agent ({finalTargetAgentActualId}): {ex.Message}", ex);
                return new AgentCommandResultPayload { Success = false, Message = $"Error relaying to final agent: {ex.Message}" };
            }
            finally
            {
                Disconnect(); // 각 명령 후 연결 종료 (단발성 사용 가정)
            }
        }

        public void Disconnect()
        {
            if (_isDisposed) return;
            // _logger.LogInfo("Downstream: Disconnecting from final target Agent."); // 너무 잦은 로그일 수 있음
            try { _streamWriter?.Dispose(); } catch { }
            _streamWriter = null;
            try { _streamReader?.Dispose(); } catch { }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { }
            _tcpClient = null;
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Disconnect();
            GC.SuppressFinalize(this);
        }
    }
}
9. Core/AgentCore.cs (수정됨)

명령줄 인자로 받은 Broker IP/Port 사용, AgentIdentifier에서 IP 기반 ID 사용, MessageContract의 타입 사용 등을 반영합니다.

C#

// MonitorAgent/Core/AgentCore.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Config;
using MonitorAgent.Network;
using MonitorAgent.Services;
using Newtonsoft.Json;
using MonitorControl.SharedModels; // <<< 공용 MessageContract 사용!

namespace MonitorAgent.Core
{
    public enum AgentOperationalStatus 
    {
        Initializing,
        BrokerAddressInvalid,
        ConnectingToBroker,
        ConnectedToBroker, 
        IdentifiedToBroker, 
        Running,            
        RelayingCommand,    
        DisconnectedFromBroker,
        Error,
        Stopping
    }

    public class AgentCore : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly AgentIdentifier _agentIdentifier;
        private readonly IMonitorControlService _monitorControl;
        private readonly string _brokerIp; // 생성 시 주입
        private readonly int _brokerPort; // 생성 시 주입
        
        private BrokerTcpClient _brokerClient;
        private CancellationTokenSource _mainCts;
        private AgentOperationalStatus _currentStatus;
        private bool _isDisposed = false;

        public event Action<AgentOperationalStatus, string> OnStatusChanged;

        public AgentCore(ILoggingService logger, AgentIdentifier agentIdentifier, 
                         string brokerIp, int brokerPort, // Broker 주소 직접 받음
                         IMonitorControlService monitorControl)
        {
            _logger = logger;
            _agentIdentifier = agentIdentifier;
            _brokerIp = brokerIp;
            _brokerPort = brokerPort;
            _monitorControl = monitorControl;
            UpdateStatus(AgentOperationalStatus.Initializing, "Agent core created.");
        }

        public async Task StartAsync()
        {
            if (_mainCts != null && !_mainCts.IsCancellationRequested)
            {
                _logger.LogWarning("AgentCore is already running or starting.");
                return;
            }
            if (_isDisposed) throw new ObjectDisposedException(nameof(AgentCore));

            _mainCts = new CancellationTokenSource();
            UpdateStatus(AgentOperationalStatus.Initializing, "Agent core starting...");

            if (string.IsNullOrEmpty(_brokerIp) || _brokerPort <= 0)
            {
                UpdateStatus(AgentOperationalStatus.BrokerAddressInvalid, "Broker IP or Port from command line is invalid. Agent cannot connect.");
                return;
            }

            _brokerClient = new BrokerTcpClient(_brokerIp, _brokerPort, _agentIdentifier, _logger, _monitorControl.GetCurrentMonitorStateApproximation);
            _brokerClient.OnBrokerMessageReceived += HandleBrokerMessage;
            _brokerClient.OnDisconnectedFromBroker += HandleBrokerDisconnection;
            _brokerClient.OnIdentifiedToBroker += HandleBrokerIdentification;


            // BrokerTcpClient의 StartAsync는 내부적으로 연결 및 재연결 루프를 돌림
            _ = _brokerClient.StartAsync(_mainCts); 

            UpdateStatus(AgentOperationalStatus.ConnectingToBroker, $"Attempting to connect to Broker at {_brokerIp}:{_brokerPort}");
        }

        private void HandleBrokerIdentification()
        {
            UpdateStatus(AgentOperationalStatus.IdentifiedToBroker, "Successfully identified to Broker.");
            UpdateStatus(AgentOperationalStatus.Running, "Agent is running and operational.");
        }

        private void HandleBrokerMessage(BrokerMessage message) // MonitorControl.SharedModels.BrokerMessage
        {
            if (_isDisposed || (_mainCts != null && _mainCts.IsCancellationRequested)) return;

            _logger.LogInfo($"Message received from Broker: {message.Type}, CorrId: {message.CorrelationId}");
            switch (message.Type)
            {
                case MessageType.BrokerToAgent_ExecuteControl:
                    HandleExecuteControlCommandAsync(message).ConfigureAwait(false); // async void로 호출
                    break;
                // BrokerAck_AgentHello는 BrokerTcpClient 내부 OnIdentifiedToBroker 이벤트로 처리됨
                case MessageType.BrokerPingToAgent: // Broker가 Agent에게 Ping
                    HandlePingFromBroker(message);
                    break;
                case MessageType.BrokerRequestReRegistration:
                    _logger.LogInfo("Broker requested re-registration. Will send AgentHello on next opportunity or connection.");
                    // 재연결 시 자동으로 Hello를 보내므로 특별한 조치 필요 없을 수 있음.
                    // 또는 즉시 Hello 다시 보내기:
                    // if (_brokerClient.IsConnected)
                    // {
                    //     Task.Run(async () => await _brokerClient.SendAgentHelloAsync()); // SendAgentHelloAsync가 BrokerTcpClient에 있다면
                    // }
                    break;
                default:
                    _logger.LogWarning($"Unhandled message type '{message.Type}' from Broker.");
                    break;
            }
        }

        private async Task HandleExecuteControlCommandAsync(BrokerMessage commandMessage) // 비동기 처리
        {
            BrokerExecuteControlPayload controlPayload = null; // MonitorControl.SharedModels
            try
            {
                controlPayload = JsonConvert.DeserializeObject<BrokerExecuteControlPayload>(commandMessage.Payload);
            }
            catch (JsonException jsonEx)
            {
                _logger.LogError($"Failed to parse BrokerExecuteControlPayload: {jsonEx.Message}. Payload: {commandMessage.Payload}", jsonEx);
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, false, "Invalid command payload.", _monitorControl.GetCurrentMonitorStateApproximation());
                return;
            }

            if (controlPayload == null)
            {
                _logger.LogError("BrokerExecuteControlPayload is null after deserialization.");
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, false, "Null command payload.", _monitorControl.GetCurrentMonitorStateApproximation());
                return;
            }

            bool result = false;
            string resultMessage = "Execution failed by Agent.";
            string monitorStatusAfterCommand = _monitorControl.GetCurrentMonitorStateApproximation();

            if (!controlPayload.IsGatewayRelayRequired) // 이 Agent가 최종 실행 대상
            {
                _logger.LogInfo($"Executing direct command: {controlPayload.ActionToPerform}");
                switch (controlPayload.ActionToPerform)
                {
                    case "TurnMonitorOn":
                        result = _monitorControl.TurnMonitorOn();
                        resultMessage = result ? "Monitor turned ON." : "Failed to turn monitor ON.";
                        break;
                    case "TurnMonitorOff":
                        result = _monitorControl.TurnMonitorOff();
                        resultMessage = result ? "Monitor turned OFF." : "Failed to turn monitor OFF.";
                        break;
                    default:
                        resultMessage = $"Unknown direct action: {controlPayload.ActionToPerform}";
                        _logger.LogWarning(resultMessage);
                        break;
                }
                monitorStatusAfterCommand = _monitorControl.GetCurrentMonitorStateApproximation();
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, result, resultMessage, monitorStatusAfterCommand);
            }
            else // 이 Agent가 Gateway로서 다른 최종 Agent에게 전달해야 함
            {
                UpdateStatus(AgentOperationalStatus.RelayingCommand, $"Relaying command '{controlPayload.ActionToPerform}' to {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");
                _logger.LogInfo($"Acting as Gateway: Relaying command '{controlPayload.ActionToPerform}' to final target {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");

                AgentCommandResultPayload finalAgentResult; // MonitorControl.SharedModels
                using (var downstreamClient = new DownstreamAgentClient(_logger)) // DownstreamAgentClient 생성
                {
                    // ConnectAsync에 CancellationToken 전달
                    if (await downstreamClient.ConnectAsync(controlPayload.FinalTargetAgentIp, controlPayload.FinalTargetAgentPort, _mainCts.Token))
                    {
                        // 최종 Agent에게 전달할 페이로드는 IsGatewayRelayRequired = false 여야 함
                        var payloadForFinalAgent = new BrokerExecuteControlPayload // MonitorControl.SharedModels
                        {
                            ActionToPerform = controlPayload.ActionToPerform,
                            Parameters = controlPayload.Parameters,
                            IsGatewayRelayRequired = false // 중요!
                        };
                        finalAgentResult = await downstreamClient.SendCommandAndGetResponseAsync(
                            payloadForFinalAgent, 
                            commandMessage.CorrelationId, 
                            _agentIdentifier.UniqueId, // 이 게이트웨이 에이전트의 ID
                            controlPayload.FinalTargetAgentId, // 최종 대상 Agent의 ID (정보용)
                            _mainCts.Token);
                    }
                    else
                    {
                        finalAgentResult = new AgentCommandResultPayload { Success = false, Message = $"Gateway failed to connect to final agent {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}." };
                    }
                } // using 블록 종료 시 downstreamClient.Dispose() 자동 호출

                result = finalAgentResult.Success;
                resultMessage = $"Relayed by {_agentIdentifier.UniqueId}: {finalAgentResult.Message}";
                monitorStatusAfterCommand = finalAgentResult.CurrentMonitorStatus;

                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, result, resultMessage, monitorStatusAfterCommand);
                UpdateStatus(AgentOperationalStatus.Running, "Command relay finished.");
            }
        }
        
        private void HandlePingFromBroker(BrokerMessage pingMessage)
        {
            _logger.LogDebug("Ping received from Broker. Sending Pong.");
            var pongMessage = new BrokerMessage { Type = MessageType.Pong, SourceId = _agentIdentifier.UniqueId, CorrelationId = pingMessage.CorrelationId }; // MonitorControl.SharedModels
            _brokerClient.SendMessageAsync(pongMessage).ConfigureAwait(false); 
        }

        private void HandleBrokerDisconnection()
        {
            UpdateStatus(AgentOperationalStatus.DisconnectedFromBroker, "Disconnected from Broker. Will attempt to reconnect via BrokerTcpClient.");
        }

        private void UpdateStatus(AgentOperationalStatus newStatus, string message)
        {
            // RelayingCommand 상태는 여러 번 발생할 수 있으므로, 상태 변경 시 중복 체크에서 제외
            if (_currentStatus == newStatus && newStatus != AgentOperationalStatus.RelayingCommand) return; 

            _currentStatus = newStatus;
            string logMessage = $"Agent Status: {_currentStatus} - {message}";
             if (newStatus == AgentOperationalStatus.Error || newStatus == AgentOperationalStatus.BrokerAddressInvalid) _logger.LogError(logMessage);
             else _logger.LogInfo(logMessage);
            OnStatusChanged?.Invoke(_currentStatus, message);
        }

        public void Stop()
        {
            if (_isDisposed) return;
            UpdateStatus(AgentOperationalStatus.Stopping, "Agent core stopping...");
            _mainCts?.Cancel(); 
            
            _brokerClient?.Dispose(); 
            _brokerClient = null;
            
            _mainCts?.Dispose();
            _mainCts = null;
            _logger.LogInfo("Agent core stopped.");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Stop();
            GC.SuppressFinalize(this);
        }
    }
}
10. UI/TrayIconManager.cs (수정 없음 - 이전 답변과 동일)
이전 답변의 MonitorAgent/UI/TrayIconManager.cs 코드를 그대로 사용합니다.

11. App.xaml.cs (수정됨 - 명령줄 인자 파싱, 로그 정리 트리거)

C#

// MonitorAgent/App.xaml.cs
using System;
using System.Windows;
using System.Windows.Forms; // NotifyIcon
using System.Drawing;       // SystemIcons
using MonitorAgent.Config;
using MonitorAgent.Core;
using MonitorAgent.Services;
using MonitorAgent.UI;
using Microsoft.Win32;      // Registry (StartupRegistryService)
using System.Diagnostics;   // Process (StartupRegistryService)
using System.Linq;          // FirstOrDefault

namespace MonitorAgent
{
    public partial class App : Application
    {
        private AgentCore _agentCore;
        private AgentLoggingService _loggingService;
        private TrayIconManager _trayIconManager;
        private AgentIdentifier _agentIdentifier;
        // private BrokerAddressProvider _brokerAddressProvider; // 삭제됨
        private MonitorControlService _monitorControlService;
        private StartupRegistryService _startupRegistryService;

        private string _brokerIpFromArgs = null;
        private int _brokerPortFromArgs = 0;


        protected override async void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // App.xaml에서 StartupUri="MainWindow.xaml" 제거 또는 주석 처리 필수

            // 1. 명령줄 인자 파싱 (Broker IP, Port)
            if (e.Args.Length >= 2)
            {
                _brokerIpFromArgs = e.Args[0];
                if (!int.TryParse(e.Args[1], out _brokerPortFromArgs) || _brokerPortFromArgs <=0 || _brokerPortFromArgs > 65535)
                {
                    _brokerPortFromArgs = 0; // 잘못된 포트
                    // 로그 서비스 초기화 전이므로 콘솔 또는 이벤트 로그에 기록 고려
                    Console.WriteLine("[ERROR] Invalid Broker Port specified in command line arguments.");
                }
            }
            else
            {
                // 로그 서비스 초기화 전
                Console.WriteLine("[ERROR] Broker IP and Port must be provided as command line arguments.");
                // 이 경우 사용자에게 알리고 종료
                MessageBox.Show("Broker IP address and Port number must be provided as command line arguments.\nUsage: MonitorAgent.exe <BrokerIP> <BrokerPort>", 
                                "Missing Arguments", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown(-1); // 오류 코드로 종료
                return;
            }

            // 로그 레벨은 기본값 사용, 추후 설정 파일 등에서 읽어올 수 있음
            _loggingService = new AgentLoggingService("Info"); 

            if (string.IsNullOrEmpty(_brokerIpFromArgs) || _brokerPortFromArgs == 0)
            {
                _loggingService.LogFatal("Broker IP or Port from command line is invalid. Agent cannot start.");
                 MessageBox.Show("Broker IP or Port from command line is invalid. Agent cannot start.", 
                                "Configuration Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown(-1);
                return;
            }

            _agentIdentifier = new AgentIdentifier(_loggingService);
            _monitorControlService = new MonitorControlService(_loggingService);
            _startupRegistryService = new StartupRegistryService(Config.AppConstants.AppName, _loggingService);

            // AgentCore 생성 시 명령줄에서 받은 IP와 포트 전달
            _agentCore = new AgentCore(_loggingService, _agentIdentifier, _brokerIpFromArgs, _brokerPortFromArgs, _monitorControlService);
            _agentCore.OnStatusChanged += AgentCore_OnStatusChanged;

            _trayIconManager = new TrayIconManager(_agentIdentifier.UniqueId, HandleExitRequest);
            _trayIconManager.UpdateStatus(AgentOperationalStatus.Initializing, "Starting up...");

            // 시작 프로그램 등록 시도 (AppConstants.AppName 사용)
             _startupRegistryService.EnsureRegistered();


            await _agentCore.StartAsync();
        }

        private void AgentCore_OnStatusChanged(AgentOperationalStatus status, string message)
        {
            Dispatcher.Invoke(() =>
            {
                _trayIconManager?.UpdateStatus(status, message);
            });
        }

        private void HandleExitRequest()
        {
            _loggingService.LogInfo("Exit requested from tray icon. Shutting down agent...");
            ShutdownAgentCoreAndExit();
        }

        private async void ShutdownAgentCoreAndExit()
        {
            // 중복 종료 방지 (간단한 방식)
            if (Application.Current == null || Application.Current.Dispatcher.HasShutdownStarted || Application.Current.Dispatcher.HasShutdownFinished)
            {
                return;
            }

            if (_agentCore != null)
            {
                _agentCore.Stop(); 
                _agentCore.Dispose(); 
                _agentCore = null;
            }
            _trayIconManager?.Dispose(); 
            _trayIconManager = null;
            _loggingService?.LogInfo("Agent shutdown complete. Exiting application.");
            
            // WPF 애플리케이션 정상 종료
            if (Application.Current != null)
            {
                Application.Current.Shutdown();
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            _loggingService?.LogInfo("Application OnExit called.");
            // 종료 시 필요한 최종 정리 작업 (이미 ShutdownAgentCoreAndExit에서 대부분 처리)
            // 예를 들어, _agentCore가 null이 아니면 한 번 더 호출 시도 (안전장치)
            if (_agentCore != null)
            {
                _agentCore.Stop();
                _agentCore.Dispose();
            }
            if (_trayIconManager != null)
            {
                _trayIconManager.Dispose();
            }
            _loggingService?.LogInfo("Monitor Agent application exited fully.");
            base.OnExit(e);
        }
    }
    
    // 간단한 시작 프로그램 등록 유틸리티 (Services 폴더로 옮겨도 됨)
    public class StartupRegistryService
    {
        private readonly string _appName;
        private readonly ILoggingService _logger;
        private readonly string _appPath;

        public StartupRegistryService(string appName, ILoggingService logger)
        {
            _appName = appName ?? throw new ArgumentNullException(nameof(appName));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            try
            {
                _appPath = Process.GetCurrentProcess().MainModule.FileName;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to get current process path for startup registration.", ex);
                _appPath = string.Empty; // 경로를 얻지 못하면 등록 불가
            }
        }

        public void EnsureRegistered()
        {
            if (string.IsNullOrEmpty(_appPath))
            {
                _logger.LogWarning("Application path is unknown, cannot register for startup.");
                return;
            }

            try
            {
                // HKEY_CURRENT_USER에 등록 (관리자 권한 불필요)
                using (RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true))
                {
                    if (rkApp == null)
                    {
                        _logger.LogError("Could not open registry key for startup programs (Current User).");
                        return;
                    }

                    object currentValue = rkApp.GetValue(_appName);
                    if (currentValue == null || currentValue.ToString() != _appPath)
                    {
                        rkApp.SetValue(_appName, _appPath);
                        _logger.LogInfo($"Application registered to run at startup: '{_appPath}'");
                    }
                    // else { _logger.LogDebug("Application already registered for startup with correct path."); }
                }
            }
            catch (UnauthorizedAccessException uaEx)
            {
                 _logger.LogError("Unauthorized access while trying to register startup program. Try running as administrator if using HKLM, or check permissions for HKCU.", uaEx);
            }
            catch (Exception ex)
            {
                _logger.LogError("Error accessing registry for startup registration.", ex);
            }
        }
        // Unregister 메서드는 필요시 추가
    }
}
12. App.xaml (수정 - StartupUri 제거)

XML

<Application x:Class="MonitorAgent.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:MonitorAgent">
    <Application.Resources>
         
    </Application.Resources>
</Application>
MonitorAgent 실행 방법 (명령줄 인자 사용):

위 코드들로 MonitorAgent 프로젝트를 빌드합니다.
Newtonsoft.Json NuGet 패키지가 설치되었는지 확인합니다.
명령 프롬프트(cmd) 또는 PowerShell에서 다음과 같이 실행합니다:
Bash

MonitorAgent.exe <Broker_IP_Address> <Broker_Agent_Port>
예시:
Bash

MonitorAgent.exe 192.168.0.100 9002
또는 로컬 테스트 시:
Bash

MonitorAgent.exe 127.0.0.1 9002
<Broker_IP_Address>: MGSPBrokerService가 실행 중인 PC의 IP 주소.
<Broker_Agent_Port>: MGSPBrokerService가 Agent 연결을 위해 리슨하는 포트 번호 (예: 9002).
이제 이 MonitorAgent 프로그램은 명령줄로 전달받은 주소의 중계 프로그램으로 접속을 시도하고, IP 기반 ID를 사용하며, 로그를 날짜별로 관리하고 오래된 로그를 자동 삭제합니다.