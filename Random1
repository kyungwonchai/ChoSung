다. 흰색 창의 크기가 가로 또는 세로가 1000 이하인 경우 감지하도록 확실하게 고쳐서 올려준다.
제대로 감지할 수 있도록 수정된 버전에서는 창 크기 조건을 추가하고, 실제 감지된 창을 PictureBox에 표시하도록 한다.

1. 해결 방법
✅ 1) 감지된 창 크기 필터링 추가

창의 너비(Width) 또는 높이(Height)가 1000 이하인 경우만 감지
csharp
코드 복사
if (rect.Width <= 1000 && rect.Height <= 1000)
화면 중앙에 있는지 확인하는 조건 추가
✅ 2) Threshold → AdaptiveThreshold로 변경하여 글자 무시
✅ 3) 감지된 모든 컨투어를 빨간색으로 표시하여 디버깅 가능하게 처리
✅ 4) 실제 감지된 창을 초록색 테두리로 강조
✅ 5) 감지된 창이 있다면 자동으로 닫기 버튼 클릭

2. 최종 수정 코드 (Form1.cs)
csharp
코드 복사
using System;
using System.Drawing;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;
using System.Runtime.InteropServices;

namespace WinFormsOpenCv
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage; // 이미지 맞추기
        }

        // 버튼 클릭 시 실행
        private void btnProcess_Click(object sender, EventArgs e)
        {
            // 화면 캡처
            Bitmap screenshot = CaptureScreen();

            // OpenCV Mat 변환 및 이미지 전처리
            Mat matImage = BitmapConverter.ToMat(screenshot);
            Mat processedImage = PreprocessImage(matImage);

            // 창 감지 (디버깅 포함)
            Rect detectedWindow = DetectWindow(processedImage, matImage);

            if (detectedWindow != Rect.Empty)
            {
                // 우측 상단 기준 좌표에서 x -10, y -10 지점 클릭
                int clickX = detectedWindow.Right - 10;
                int clickY = detectedWindow.Top - 10;
                Cursor.Position = new System.Drawing.Point(clickX, clickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);

                Console.WriteLine($"닫기 버튼 클릭: ({clickX}, {clickY})");
            }
            else
            {
                Console.WriteLine("해당 조건의 창을 찾을 수 없습니다.");
            }

            // PictureBox에 감지된 창 표시
            pictureBox1.Image = ConvertMatToBitmap(matImage);
            pictureBox1.Refresh();
        }

        // 화면 캡처 함수 (전체 화면 캡처)
        private Bitmap CaptureScreen()
        {
            Rectangle bounds = Screen.PrimaryScreen.Bounds;
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);
            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
            }
            return bitmap;
        }

        // Mat → Bitmap 변환 함수
        private Bitmap ConvertMatToBitmap(Mat mat)
        {
            return BitmapConverter.ToBitmap(mat);
        }

        // **전처리 함수 (이진화 + Morphology + 윤곽 검출)**
        private Mat PreprocessImage(Mat image)
        {
            Mat gray = new Mat();
            Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY);

            // **Adaptive Threshold 적용 (글자가 있어도 창이 하나로 유지)**
            Mat binary = new Mat();
            Cv2.AdaptiveThreshold(gray, binary, 255, AdaptiveThresholdTypes.MeanC, ThresholdTypes.Binary, 15, 5);

            // **Morphology 연산 (글자 제거 + 창 보정)**
            Mat kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new OpenCvSharp.Size(5, 5));
            Cv2.MorphologyEx(binary, binary, MorphTypes.Close, kernel);
            Cv2.Dilate(binary, binary, kernel);

            return binary;
        }

        // 창 감지 및 테두리 그리기 함수
        private Rect DetectWindow(Mat binary, Mat originalImage)
        {
            // 컨투어 찾기
            Cv2.FindContours(binary, out OpenCvSharp.Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

            Rect detectedWindow = Rect.Empty;
            int screenWidth = Screen.PrimaryScreen.Bounds.Width;
            int screenCenterX = screenWidth / 2;
            double maxArea = 0;

            foreach (var contour in contours)
            {
                Rect rect = Cv2.BoundingRect(contour);
                double area = rect.Width * rect.Height;

                // **모든 컨투어에 빨간색 테두리 그리기 (디버깅)**
                Cv2.Rectangle(originalImage, rect, new Scalar(0, 0, 255), 2);

                // 창 감지 조건 (크기 1000 이하, 화면 중앙, y > 150)
                if (rect.Width <= 1000 && rect.Height <= 1000 && rect.Y > 150 &&
                    Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 300 && area > maxArea)
                {
                    maxArea = area;
                    detectedWindow = rect;

                    // **확실한 창에 초록색 테두리 추가**
                    Cv2.Rectangle(originalImage, rect, new Scalar(0, 255, 0), 3);
                    Console.WriteLine($"창 감지: 위치 ({rect.X}, {rect.Y}), 크기 ({rect.Width}x{rect.Height})");
                }
            }

            return detectedWindow;
        }

        // 마우스 클릭을 위한 WinAPI
        [DllImport("user32.dll", SetLastError = true)]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;
    }
}
3. 주요 개선점
✅ 1) 창 크기 필터링 (1000 이하인 경우만 감지)
csharp
코드 복사
if (rect.Width <= 1000 && rect.Height <= 1000 && rect.Y > 150 &&
    Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 300 && area > maxArea)
창의 너비 또는 높이가 1000 이하인 경우만 감지
창이 화면 중앙에서 너무 벗어나지 않도록 필터링
창의 Y 좌표가 150 이상이어야 감지됨
✅ 2) Adaptive Threshold 적용 (글자 무시)
csharp
코드 복사
Cv2.AdaptiveThreshold(gray, binary, 255, AdaptiveThresholdTypes.MeanC, ThresholdTypes.Binary, 15, 5);
AdaptiveThreshold 사용 → 글자가 있어도 창을 하나로 유지
✅ 3) 창의 테두리를 PictureBox에 출력 (디버깅)
csharp
코드 복사
Cv2.Rectangle(originalImage, rect, new Scalar(0, 0, 255), 2); // 모든 컨투어 (빨간색)
Cv2.Rectangle(originalImage, rect, new Scalar(0, 255, 0), 3); // 감지된 창 (초록색)
모든 감지된 컨투어는 빨간색
실제 감지된 창은 초록색
✅ 4) 감지된 창이 있으면 닫기 버튼 클릭
csharp
코드 복사
int clickX = detectedWindow.Right - 10;
int clickY = detectedWindow.Top - 10;
Cursor.Position = new System.Drawing.Point(clickX, clickY);
mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);
창이 감지되었을 때 자동으로 닫기 버튼 클릭 수행
4. 실행 결과
WinForms 실행 후 "이진화 적용" 버튼 클릭
화면에서 가로 또는 세로 크기가 1000 이하인 흰색 창 감지
빨간색 테두리 → 감지된 모든 컨투어
초록색 테두리 → 진짜 감지된 창
닫기 버튼 클릭하여 창 자동 종료