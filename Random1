송합니다. 이전에 제공된 LockerDbContext.cs 코드의 로그 기록 로직에 문제가 있었습니다. 특히 SaveChanges 메서드 내에서 로그를 저장하기 위해 base.SaveChanges()를 불필요하게 두 번 호출하는 구조였고, 기본 키(Id)를 가져오는 부분도 모든 엔티티에 적용하기에는 불안정했습니다.

오류를 수정한 LockerDbContext.cs 파일 전체 코드를 다시 드리겠습니다.

수정 내용:

SaveChanges / SaveChangesAsync 수정:
변경 사항을 감지하고 로그 엔트리를 생성하는(CreateAuditEntries) 로직은 유지합니다.
생성된 로그 엔트리(AuditLog)를 AuditLogs DbSet에 추가(AddRange) 합니다.
단 한 번의 base.SaveChanges() 또는 base.SaveChangesAsync() 호출을 통해 원래의 변경 사항과 새로 추가된 로그 항목이 동시에 데이터베이스 트랜잭션으로 저장되도록 구조를 변경합니다.
별도의 SaveAuditLogs / SaveAuditLogsAsync 메서드를 제거합니다.
기본 키(RecordId) 가져오기 개선: entry.Property("Id") 대신 Entity Framework 메타데이터를 사용하여 엔티티의 기본 키 값을 더 안정적으로 가져오도록 수정합니다.
C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure; // DbEntityEntry, ObjectContext 사용
using System.Data.Entity.Core.Objects; // ObjectContext 사용
using System.Linq;
using System.Threading.Tasks;
using System.Web.Script.Serialization; // 또는 Newtonsoft.Json
using System.Diagnostics; // Debug.WriteLine 사용

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (로그 저장 로직 수정)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- 테이블 매핑을 위한 DbSet 속성들 ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        /// <summary>
        /// 기본 생성자. App.config의 "LockerDbConnection" 연결 문자열을 사용합니다.
        /// </summary>
        public LockerDbContext() : base("name=LockerDbConnection")
        {
            // 데이터베이스 초기화 전략 설정 (선택 사항)
            // Database.SetInitializer<LockerDbContext>(null);
        }

        /// <summary>
        /// 모델(테이블) 생성 시 추가 구성을 위한 메서드입니다 (Fluent API).
        /// </summary>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);
        }

        #region SaveChanges Overrides for Audit Logging (Revised Logic)

        /// <summary>
        /// 동기 방식 변경 사항 저장 시 감사 로그를 기록합니다. (수정된 로직)
        /// </summary>
        public override int SaveChanges()
        {
            // 1. 로그 엔트리 생성
            List<AuditLog> auditEntries = CreateAuditEntries();

            // 2. 생성된 로그 엔트리를 컨텍스트에 추가 (아직 DB 저장 전)
            if (auditEntries != null && auditEntries.Any())
            {
                this.AuditLogs.AddRange(auditEntries);
            }

            // 3. 단 한 번의 SaveChanges 호출로 원본 변경 + 로그 추가를 함께 저장
            try
            {
                return base.SaveChanges();
            }
            catch (DbUpdateException dbEx)
            {
                // 저장 실패 시 로그 (필요 시 추가 처리)
                Debug.WriteLine($"!!! SaveChanges 실패 (동기): {dbEx.ToString()}");
                throw; // 예외를 다시 던져 상위에서 처리하도록 함
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}");
                throw;
            }
        }

        /// <summary>
        /// 비동기 방식 변경 사항 저장 시 감사 로그를 기록합니다. (수정된 로직)
        /// </summary>
        public override async Task<int> SaveChangesAsync()
        {
            // 1. 로그 엔트리 생성
            List<AuditLog> auditEntries = CreateAuditEntries();

            // 2. 생성된 로그 엔트리를 컨텍스트에 추가 (아직 DB 저장 전)
            if (auditEntries != null && auditEntries.Any())
            {
                this.AuditLogs.AddRange(auditEntries);
            }

            // 3. 단 한 번의 SaveChangesAsync 호출로 원본 변경 + 로그 추가를 함께 저장
            try
            {
                return await base.SaveChangesAsync();
            }
            catch (DbUpdateException dbEx)
            {
                Debug.WriteLine($"!!! SaveChangesAsync 실패 (비동기): {dbEx.ToString()}");
                throw;
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}");
                throw;
            }
        }

        /// <summary>
        /// 현재 변경 추적 중인 엔티티를 기반으로 감사 로그 엔트리 목록을 생성합니다.
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                .ToList();
            var serializer = new JavaScriptSerializer { MaxJsonLength = int.MaxValue };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) continue; // 로그 자체는 로깅 안 함

                var auditEntry = new AuditLog
                {
                    Timestamp = DateTime.Now,
                    UserName = currentUserName,
                    TableName = entry.Entity.GetType().Name,
                    Action = entry.State.ToString()
                };

                // *** 수정된 부분: 기본 키 값을 더 안정적으로 가져오기 ***
                try
                {
                    // EF 메타데이터를 통해 기본 키 값 가져오기
                    var objectContext = ((IObjectContextAdapter)this).ObjectContext;
                    var objectSet = objectContext.CreateObjectSet(entry.Entity.GetType());
                    var entityKey = objectContext.CreateEntityKey(objectSet.EntitySet.Name, entry.Entity);
                    auditEntry.RecordId = string.Join(",", entityKey.EntityKeyValues.Select(kv => kv.Value)); // 복합키 고려
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"감사 로그: 기본 키 값 가져오기 실패 ({auditEntry.TableName}) - {ex.Message}");
                    auditEntry.RecordId = "PK Error";
                }


                var oldValues = new Dictionary<string, object>();
                var newValues = new Dictionary<string, object>();
                var affectedColumns = new List<string>();

                if (entry.State == EntityState.Added)
                {
                    foreach (var propertyName in entry.CurrentValues.PropertyNames) newValues[propertyName] = entry.CurrentValues[propertyName];
                    try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Deleted)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames) oldValues[propertyName] = entry.OriginalValues[propertyName];
                    try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Modified)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames)
                    {
                        var originalValue = entry.OriginalValues[propertyName];
                        var currentValue = entry.CurrentValues[propertyName];
                        if (!Equals(originalValue, currentValue)) { affectedColumns.Add(propertyName); oldValues[propertyName] = originalValue; newValues[propertyName] = currentValue; }
                    }
                    if (affectedColumns.Any())
                    {
                        auditEntry.AffectedColumns = string.Join(",", affectedColumns);
                        try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                        try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                    }
                    else continue; // 실제 변경된 속성 없으면 로그 건너뜀
                }
                auditEntries.Add(auditEntry);
            }
            // LockerAssignment의 LastUpdated 업데이트는 여기서 호출 유지
            UpdateLockerAssignmentTimestamps(changedEntries);
            return auditEntries;
        }

        // SaveAuditLogs, SaveAuditLogsAsync 메서드는 제거됨

        /// <summary>
        /// 변경된 LockerAssignment 엔티티의 LastUpdated 타임스탬프를 업데이트합니다.
        /// </summary>
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries)
        {
            var lockerEntries = changedEntries
                .Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified));
            foreach (var entry in lockerEntries)
            {
                ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now;
            }
        }

        #endregion
    }
}
핵심 변경 사항:

SaveChanges/SaveChangesAsync 로직 변경:
CreateAuditEntries()를 호출하여 로그 목록을 먼저 만듭니다.
만들어진 로그 목록(auditEntries)을 this.AuditLogs.AddRange()를 사용하여 컨텍스트에 추가합니다.
base.SaveChanges() 또는 base.SaveChangesAsync()를 한 번만 호출하여 원본 데이터 변경과 로그 추가를 하나의 트랜잭션으로 처리합니다.
별도의 SaveAuditLogs/SaveAuditLogsAsync 메서드를 제거했습니다.