네, 설명(Description) 부분을 사용자가 직접 편집할 수 있게 하고, 수정 시 내용에 따라 자동으로 행 높이가 조절되도록 기능을 추가할 수 있습니다. 편집 중에도 실시간으로 높이가 조절되도록 구현해 보겠습니다.

핵심 변경 사항:

HTML 수정: 설명(Description)을 표시하는 <td>에 contenteditable="true" 속성을 추가하여 직접 편집이 가능하도록 합니다.
JavaScript 수정:
편집 가능한 셀에 input 이벤트 리스너를 추가합니다. 이 리스너는 내용이 변경될 때마다 실행되어 해당 셀과 행의 높이를 실시간으로 조절합니다.
기존의 adjustRowHeights 함수를 약간 수정하거나, 특정 행만 조절하는 헬퍼 함수를 만들어 사용합니다.
1. app.py (변경 없음)

이 기능은 클라이언트 측(브라우저)에서 JavaScript로 처리되므로, app.py 파일은 이전 단계와 동일하게 유지됩니다. 데이터 저장 로직은 이번 요청에 포함되지 않았으므로 추가하지 않습니다.

Python

from flask import Flask, render_template, url_for

app = Flask(__name__)

@app.route('/')
def index():
    items_data = [
        {
            "id": 1,
            "name": "John Doe",
            "description": "This is a short description.",
            "image_filename": "img1.jpg"
        },
        {
            "id": 2,
            "name": "Jane Smith",
            "description": "This is a medium-length description. It might span multiple lines if the content is long enough to wrap.",
            "image_filename": "img2.jpg"
        },
        {
            "id": 3,
            "name": "Peter Jones",
            "description": "This item requires a very long description. If the text is extensive, it should automatically wrap to fit within the cell, and explicitly entered\nnew lines\nlike this one\nshould also be respected.\nThe content will be displayed across multiple lines.\nThis is the last line.",
            "image_filename": "img3.jpg"
        },
        {
            "id": 4,
            "name": "Alice Brown",
            "description": "First line.\nSecond line.\nThird line.\n\nFifth line (includes an empty line).",
            "image_filename": "img4.jpg"
        },
        {
            "id": 5,
            "name": "Robert Wilson",
            "description": "All cells in the same row will adjust to the height of the cell with the most content.",
            "image_filename": "img5.jpg"
        }
    ]

    processed_data = []
    for item in items_data:
        if item.get("image_filename"):
            item["image_url"] = url_for('static', filename=f'image1/{item["image_filename"]}')
        else:
            item["image_url"] = None
        processed_data.append(item)

    return render_template('index.html', table_data=processed_data)

if __name__ == '__main__':
    app.run(debug=True)

2. templates/index.html (HTML, CSS 및 JavaScript 수정)

HTML

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Editable Table with Auto Row Height</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed;
        }
        th, td {
            border: 1px solid #ccc;
            padding: 5px;
            text-align: left;
            vertical-align: top;
            word-wrap: break-word;
            overflow-wrap: break-word;
        }
        th {
            background-color: #f2f2f2;
        }
        td.description-cell {
            white-space: pre-wrap; /* Essential for respecting newlines and wrapping */
        }
        td.description-cell[contenteditable="true"] {
            background-color: #e8f5e9; /* Light green to indicate editable */
            outline: none; /* Remove default outline on focus, or style it */
        }
        td.description-cell[contenteditable="true"]:focus {
            border: 1px solid #4CAF50; /* Highlight when focused */
            box-shadow: 0 0 3px #4CAF50;
        }

        .thumbnail-image {
            max-width: 80px;
            max-height: 80px;
            height: auto;
            cursor: pointer;
            display: block;
            background-color: #f0f0f0;
            object-fit: cover;
        }

        /* Modal Styles (same as before) */
        .modal { display: none; position: fixed; z-index: 1000; padding-top: 50px; left: 0; top: 0; width: 100%; height: 100%; overflow: auto; background-color: rgba(0,0,0,0.85); }
        .modal-content { margin: auto; display: block; max-width: 80%; max-height: 80vh; }
        .modal-caption { margin: 15px auto; display: block; width: 80%; max-width: 700px; text-align: center; color: #ccc; padding: 10px 0; height: 50px; }
        .close-button { position: absolute; top: 15px; right: 35px; color: #f1f1f1; font-size: 40px; font-weight: bold; transition: 0.3s; }
        .close-button:hover, .close-button:focus { color: #bbb; text-decoration: none; cursor: pointer; }
    </style>
</head>
<body>

    <h1>Flask Table (Editable Description, Auto Row Height)</h1>

    <table id="myTable">
        <thead>
            <tr>
                <th style="width: 5%;">ID</th>
                <th style="width: 15%;">Name</th>
                <th style="width: 15%;">Image</th>
                <th style="width: 65%;">Description</th>
            </tr>
        </thead>
        <tbody>
            {% for row_data in table_data %} {/* Changed 'row' to 'row_data' to avoid conflict with JS 'row' variable */}
            <tr>
                <td>{{ row_data.id }}</td>
                <td>{{ row_data.name }}</td>
                <td>
                    {% if row_data.image_url %}
                    <img src="{{ row_data.image_url }}" alt="Image for {{ row_data.name }}" class="thumbnail-image" data-title="{{ row_data.name }}">
                    {% else %}
                    <span>No image</span>
                    {% endif %}
                </td>
                <td class="description-cell" contenteditable="true" data-id="{{ row_data.id }}">{{ row_data.description }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <div id="imageModal" class="modal">
        <span class="close-button">&times;</span>
        <img class="modal-content" id="modalImage">
        <div id="modalCaption" class="modal-caption"></div>
    </div>

    <script>
        // Helper function to adjust the height of a single row
        function adjustSingleRowHeight(rowElement) {
            if (!rowElement) return;
            rowElement.style.height = 'auto'; // Reset row height to allow shrinking

            let maxHeightInRow = 0;
            const cellsInRow = rowElement.getElementsByTagName('td');

            for (let j = 0; j < cellsInRow.length; j++) {
                const cell = cellsInRow[j];
                cell.style.height = 'auto'; // Reset cell height to get natural scrollHeight
                if (cell.scrollHeight > maxHeightInRow) {
                    maxHeightInRow = cell.scrollHeight;
                }
            }

            if (maxHeightInRow > 0) {
                for (let j = 0; j < cellsInRow.length; j++) {
                    // Apply the max height to all cells in that row for uniform appearance
                    cellsInRow[j].style.height = maxHeightInRow + 'px';
                }
                // Optionally set the row height explicitly, though cells define it.
                // rowElement.style.height = maxHeightInRow + 'px';
            }
        }

        // Function to adjust all rows in the table
        function adjustAllTableHeights() {
            const table = document.getElementById('myTable');
            if (!table) return;
            const tbody = table.getElementsByTagName('tbody')[0];
            if (!tbody) return;
            const rows = tbody.getElementsByTagName('tr');
            for (let i = 0; i < rows.length; i++) {
                adjustSingleRowHeight(rows[i]);
            }
        }

        // --- Modal Logic (same as before) ---
        const modal = document.getElementById("imageModal");
        const modalImg = document.getElementById("modalImage");
        const captionText = document.getElementById("modalCaption");
        const closeButton = document.getElementsByClassName("close-button")[0];

        function openModal(element) {
            modal.style.display = "block";
            modalImg.src = element.src; 
            captionText.innerHTML = element.dataset.title || element.alt; 
        }

        const thumbnails = document.querySelectorAll(".thumbnail-image");
        thumbnails.forEach(thumb => {
            thumb.addEventListener('click', function() {
                openModal(this);
            });
        });

        if(closeButton) {
            closeButton.onclick = function() { modal.style.display = "none"; }
        }
        window.onclick = function(event) {
            if (event.target == modal) { modal.style.display = "none"; }
        }
        // --- End Modal Logic ---


        // --- Editable Cell Logic ---
        const editableCells = document.querySelectorAll('td.description-cell[contenteditable="true"]');

        editableCells.forEach(cell => {
            cell.addEventListener('input', function() {
                // 1. Allow the current cell to naturally adjust its height
                this.style.height = 'auto';
                this.style.height = this.scrollHeight + 'px';

                // 2. Adjust the entire row based on this cell's new height
                const row = this.closest('tr');
                if (row) {
                    adjustSingleRowHeight(row);
                }
                // Note: Data persistence (saving changes) is not implemented here.
                // To save, you would typically capture 'this.innerText' or 'this.innerHTML'
                // and send it to a server endpoint, e.g., on 'blur' event.
            });

            // Optional: Final adjustment on blur (when user clicks away)
            cell.addEventListener('blur', function() {
                const row = this.closest('tr');
                if (row) {
                    adjustSingleRowHeight(row);
                }
                // console.log(`Content for ID ${this.dataset.id} changed to: ${this.innerText}`); // Example for saving
            });
        });


        // Initial setup and listeners
        window.addEventListener('load', function() {
            adjustAllTableHeights();

            // Re-query and attach listeners if content could be dynamic (though not in this static example)
            const currentThumbnails = document.querySelectorAll(".thumbnail-image");
            currentThumbnails.forEach(thumb => {
                if (!thumb.dataset.listenerAttached) {
                    thumb.addEventListener('click', function() { openModal(this); });
                    thumb.dataset.listenerAttached = 'true';
                }
            });

            const currentEditableCells = document.querySelectorAll('td.description-cell[contenteditable="true"]');
            currentEditableCells.forEach(cell => {
                if (!cell.dataset.editListenerAttached) { // Avoid re-attaching for static content
                    cell.addEventListener('input', function() {
                        this.style.height = 'auto';
                        this.style.height = this.scrollHeight + 'px';
                        const row = this.closest('tr');
                        if (row) adjustSingleRowHeight(row);
                    });
                    cell.addEventListener('blur', function() {
                        const row = this.closest('tr');
                        if (row) adjustSingleRowHeight(row);
                        // console.log(`Content for ID ${this.dataset.id} changed to: ${this.innerText}`);
                    });
                    cell.dataset.editListenerAttached = 'true';
                }
            });
        });
        
        let resizeTimeout;
        window.addEventListener('resize', function() {
            clearTimeout(resizeTimeout);
            resizeTimeout = setTimeout(function() {
                adjustAllTableHeights();
            }, 150);
        });
    </script>

</body>
</html>
주요 변경 사항 및 설명:

HTML (<td> 수정):

설명 셀에 contenteditable="true" 속성을 추가했습니다:
HTML

<td class="description-cell" contenteditable="true" data-id="{{ row_data.id }}">{{ row_data.description }}</td>
data-id="{{ row_data.id }}"는 나중에 변경된 내용을 서버에 저장할 때 어떤 항목의 내용이 변경되었는지 식별하기 위해 추가했습니다 (이번 요청에서는 저장 로직은 구현하지 않음).
Jinja2 템플릿 변수 row를 row_data로 변경하여 JavaScript의 row 변수와의 혼동을 피했습니다.
CSS (편집 가능한 셀 스타일 추가):

편집 가능한 셀(td.description-cell[contenteditable="true"])에 배경색을 약간 다르게 주어 시각적으로 편집 가능함을 나타냈습니다.
포커스 시 테두리 스타일을 추가하여 현재 편집 중인 셀을 명확히 했습니다.
JavaScript 로직 추가/수정:

adjustSingleRowHeight(rowElement) 함수: 이 함수는 전달받은 특정 rowElement의 높이를 조절합니다. 해당 행의 모든 셀을 순회하며 가장 큰 scrollHeight를 찾아 모든 셀의 높이를 그 값으로 통일시킵니다.
adjustAllTableHeights() 함수: 기존의 전체 테이블 높이 조절 함수입니다. 이제 내부에서 adjustSingleRowHeight를 각 행에 대해 호출합니다.
편집 가능한 셀 이벤트 리스너:
td.description-cell[contenteditable="true"] 속성을 가진 모든 셀을 선택합니다.
각 셀에 input 이벤트 리스너를 추가합니다:
사용자가 내용을 입력하거나 삭제할 때마다(input 이벤트) 실행됩니다.
먼저, 현재 편집 중인 셀의 높이를 auto로 설정한 뒤, scrollHeight (실제 내용 높이)로 다시 설정합니다. 이렇게 하면 셀 자체가 내용에 맞게 즉시 늘어나거나 줄어듭니다.
그 다음, this.closest('tr')로 현재 셀이 속한 행(<tr>)을 찾아 adjustSingleRowHeight 함수를 호출하여 해당 행 전체의 높이를 재조정합니다. 이렇게 하면 같은 행의 다른 셀들도 높이가 통일됩니다.
각 셀에 blur 이벤트 리스너를 추가합니다 (선택 사항):
사용자가 셀 편집을 마치고 다른 곳을 클릭했을 때(blur 이벤트) 실행됩니다.
마찬가지로 해당 행의 높이를 최종적으로 한 번 더 정리해줍니다.
주석 처리된 console.log 부분은 변경된 내용을 가져오는 예시입니다. 실제 저장 로직은 이 부분에서 AJAX 요청 등을 통해 서버로 데이터를 전송해야 합니다.