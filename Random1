네, 알겠습니다. 두 가지 요청 사항을 해결해 보겠습니다.

"릴레이 모니터 끄기" 기능 추가
"모니터 끄기" 동작 시 로그아웃 문제 및 응답 미수신 문제 해결 시도
1. "릴레이 모니터 끄기" 기능 추가
SControlM 프로젝트에 "릴레이 모니터 끄기" 기능을 추가하겠습니다.

SControlM/ViewModels/MainControlViewModel.cs 수정:

ICommand SendRelayMonitorOffCommand { get; } 속성을 추가하고, 생성자에서 초기화하며, IsBusy 속성 setter에서 RaiseCanExecuteChanged() 호출을 추가합니다.

C#

// SControlM/ViewModels/MainControlViewModel.cs
// ... 기존 using 문들 ...

namespace SControlM.ViewModels
{
    public class MainControlViewModel : ObservableObject
    {
        // ... 기존 속성들 ...

        public ICommand SendRelayMonitorOffCommand { get; } // Relay Monitor Off 명령 추가

        public MainControlViewModel(ILoggingService loggingService, ICommandSendService commandSendService)
        {
            // ... 기존 초기화 코드 ...

            SendCommandMonitorOnCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.On),
                CanExecuteDirectCommands
            );
            SendCommandMonitorOffCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.Off),
                CanExecuteDirectCommands
            );
            SendCommandMonitorStandbyCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.Standby),
                CanExecuteDirectCommands
            );

            SendRelayMonitorOnCommand = new AsyncRelayCommand(
                async () => await ExecuteRelayMonitorControlCommand(MonitorAction.On),
                CanExecuteRelayCommands
            );
            // SendRelayMonitorOffCommand 초기화 추가
            SendRelayMonitorOffCommand = new AsyncRelayCommand(
                async () => await ExecuteRelayMonitorControlCommand(MonitorAction.Off),
                CanExecuteRelayCommands
            );

            _loggingService.Info("MainControlViewModel 초기화 완료 (AsyncRelayCommand 사용).");
        }

        public bool IsBusy
        {
            get => _isBusy;
            set
            {
                if (SetProperty(ref _isBusy, value))
                {
                    (SendCommandMonitorOnCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendCommandMonitorOffCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendCommandMonitorStandbyCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendRelayMonitorOnCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendRelayMonitorOffCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged(); // 추가
                }
            }
        }

        // ... ExecuteMonitorControlCommand, ExecuteRelayMonitorControlCommand, SendCommandAsync, Cleanup 메서드는 이전과 동일 ...
        // CanExecuteDirectCommands, CanExecuteRelayCommands 메서드도 이전과 동일
    }
}
SControlM/MainWindow.xaml 수정:

"릴레이 명령" 그룹박스 안에 "릴레이: 모니터 끄기" 버튼을 추가합니다.

XML

<GroupBox Header="릴레이 명령 (Relay Commands)" Padding="5" Margin="0,5,0,0">
                <StackPanel Orientation="Horizontal">
                    <Button Content="릴레이: 모니터 켜기" Command="{Binding SendRelayMonitorOnCommand}" Width="150" Margin="0,0,5,0"
                            ToolTip="릴레이 대상 PC의 모니터를 켭니다."/>
                    <Button Content="릴레이: 모니터 끄기" Command="{Binding SendRelayMonitorOffCommand}" Width="150" Margin="5,0,0,0"
                            ToolTip="릴레이 대상 PC의 모니터를 끕니다."/>
                </StackPanel>
            </GroupBox>
            ```

---

## 2. "모니터 끄기" 동작 시 문제 해결 시도

### 2.1. 로그아웃 문제

`SC_MONITORPOWER`를 사용한 모니터 끄기(`LocalDeviceControl.SetMonitorState(MonitorAction.Off)`)는 표준 Windows API 호출이며, **일반적으로 시스템 로그아웃을 유발하지 않습니다.** 화면만 꺼지는 것이 정상입니다.

만약 실제로 로그아웃이 발생한다면, 이는 다음과 같은 외부 요인 때문일 가능성이 큽니다:
* **대상 PC의 특정 전원 관리 설정:** Windows 전원 옵션에서 디스플레이 꺼짐과 특정 시스템 상태(예: 절전 모드 진입 후 잠금, 최대 절전 모드 등)가 연계되어 있을 수 있습니다.
* **그룹 정책(GPO) 또는 보안 소프트웨어:** 특정 조직 환경에서는 보안상의 이유로 디스플레이가 꺼지면 세션을 잠그거나 로그아웃시키는 정책이 적용될 수 있습니다.
* **타사 유틸리티:** 화면 보호기나 특정 시스템 관리 유틸리티가 유사한 동작을 유발할 수 있습니다.

**코드 레벨에서 직접적으로 이 "로그아웃" 현상을 제어하기는 어렵습니다.** 대상 PC의 설정을 확인해보시는 것이 좋습니다.

### 2.2. "끄기 완료" 응답 미수신 문제

모니터가 꺼진 후 `SAgentM.App`으로부터 "끄기 완료" 응답을 받지 못하는 것은, 모니터 전원이 차단되면서 대상 PC의 네트워크 어댑터가 일시적으로 절전 모드로 들어가거나 연결이 불안정해져서 발생할 수 있습니다.

이를 해결하기 위해, `SAgentM.App`이 **모니터를 실제로 끄기 직전에 "성공적으로 처리될 것"이라는 응답을 `SControlM`에 미리 보내는 방식**을 시도해 보겠습니다. `LocalDeviceControl.SetMonitorState` 호출 자체는 대부분 성공하며, 실패 시 `Win32Exception`을 발생시키므로, 호출 전에 응답을 보내도 큰 무리는 없을 것입니다.

**`SAgentM.App/Services/AgentCoreService.cs`의 `ExecuteDirectCommandAsync` 메서드 수정:**

`CommandNames.MonitorControl` 케이스 내부에서 `payload.Action == MonitorAction.Off`인 경우에만 응답을 먼저 생성하고, 실제 모니터 끄기 동작은 그 후에 수행하도록 변경합니다.

```csharp
// SAgentM.App/Services/AgentCoreService.cs
// ... 기존 using 문들 ...
// using SControl.Common; // MonitorAction 열거형 사용을 위해 추가 (이미 있다면 OK)

namespace SAgentM.App.Services
{
    // ... AgentCoreService 클래스 상단 ...

    private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
    {
        _loggingService.Info(<span class="math-inline">"\[\{clientIp\}\] 직접 실행 명령\: \{requestPacket\.CommandName\}"\);
bool success \= false;
string message \= "Command execution failed or not implemented\.";
CommandPacket responsePacket \= null; // 미리 응답 패킷 변수 선언
try
\{
token\.ThrowIfCancellationRequested\(\);
switch \(requestPacket\.CommandName\)
\{
case CommandNames\.MonitorControl\:
if \(string\.IsNullOrEmpty\(requestPacket\.PayloadJson\)\)
\{
message \= "MonitorControl\: PayloadJson is missing\.";
\_loggingService\.Warn\(</span>"[{clientIp}] {message}");
                        responsePacket = CreateExecutionResponse(requestPacket, false, message); // 오류 응답 생성
                        break; // switch 문 탈출
                    }
                    
                    MonitorControlPayload monitorPayload = null;
                    try
                    {
                        monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
                    }
                    catch (JsonException jsonEx)
                    {
                        message = <span class="math-inline">"MonitorControl\: Payload JSON deserialization error \- \{jsonEx\.Message\}";
\_loggingService\.Error\(</span>"[{clientIp}] {message}", jsonEx);
                        success = false;
                        responsePacket = CreateExecutionResponse(requestPacket, success, message);
                        break; // switch 문 탈출
                    }
                    
                    if (monitorPayload == null)
                    {
                        message = "MonitorControl: Failed to deserialize payload (resulted in null).";
                        _loggingService.Warn(<span class="math-inline">"\[\{clientIp\}\] \{message\}"\);
responsePacket \= CreateExecutionResponse\(requestPacket, false, message\);
break; // switch 문 탈출
\}
\_loggingService\.Info\(</span>"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");

                    if (monitorPayload.Action == MonitorAction.Off)
                    {
                        // 모니터 끄기 명령의 경우: 먼저 성공 응답을 준비하고, 그 다음에 모니터를 끈다.
                        success = true;
                        message = <span class="math-inline">"Monitor state will be set to \{monitorPayload\.Action\}\. Sending early confirmation\.";
\_loggingService\.Info\(</span>"[{clientIp}] {message}");
                        responsePacket = CreateExecutionResponse(requestPacket, success, message);
                        
                        // 응답을 먼저 보내고 모니터를 끄도록 ClientHandler에게 응답 패킷을 반환한 후,
                        // 백그라운드에서 모니터 끄기를 시도할 수도 있지만,
                        // 여기서는 일단 응답 '준비' 후 즉시 모니터를 끄고, 그 응답을 반환한다.
                        // ClientHandler가 이 응답을 보내고 나서 실제 모니터가 꺼질 것이다.
                        try
                        {
                            LocalDeviceControl.SetMonitorState(MonitorAction.Off);
                            _loggingService.Info(<span class="math-inline">"\[\{clientIp\}\] Monitor Off P/Invoke call initiated\."\);
// 실제 모니터가 꺼지는 데는 약간의 시간이 걸릴 수 있음
\}
catch \(Exception pInvokeEx\)
\{
// 만약 P/Invoke 호출 자체가 실패하면, 이미 보낼 응답은 '성공'이므로 로그만 남긴다\.
// 또는, 이 경우를 대비해 응답을 수정할 수도 있지만 복잡해짐\.
\_loggingService\.Error\(</span>"[{clientIp}] Monitor Off P/Invoke call FAILED after preparing success response.", pInvokeEx);
                            // 이미 생성된 responsePacket은 '성공' 메시지를 담고 있을 수 있으므로 주의.
                            // 여기서 responsePacket을 오류로 덮어쓸 수 있음.
                            // responsePacket = CreateExecutionResponse(requestPacket, false, $"P/Invoke call for Monitor Off failed: {pInvokeEx.Message}");
                        }
                    }
                    else // 모니터 켜기 또는 대기 상태
                    {
                        LocalDeviceControl.SetMonitorState(monitorPayload.Action);
                        success = true;
                        message = <span class="math-inline">"Monitor state set to \{monitorPayload\.Action\} successfully\.";
\_loggingService\.Info\(</span>"[{clientIp}] {message}");
                        responsePacket = CreateExecutionResponse(requestPacket, success, message);
                    }
                    break;

                // --- 다른 직접 실행 명령들 ---
                default:
                    message = <span class="math-inline">"Unknown direct command\: \{requestPacket\.CommandName\}";
\_loggingService\.Warn\(</span>"[{clientIp}] {message}");
                    responsePacket = CreateExecutionResponse(requestPacket, false, message);
                    break;
            }
        }
        catch (OperationCanceledException)
        {
            message = <span class="math-inline">"Direct command \{requestPacket\.CommandName\} execution canceled\.";
\_loggingService\.Info\(</span>"[{clientIp}] {message}");
            success = false; 
            responsePacket = CreateExecutionResponse(requestPacket, success, message);
        }
        catch (Exception ex) // 이 catch는 switch 내부에서 발생한 예외를 잡지 않음 (각 case에서 처리해야 함)
        {
            message = <span class="math-inline">"Error executing \{requestPacket\.CommandName\}\: \{ex\.Message\}"; // 일반적인 오류 처리
\_loggingService\.Error\(</span>"[{clientIp}] {message}", ex);
            success = false;
            responsePacket = CreateExecutionResponse(requestPacket, success, message);
        }
        
        return responsePacket; // 생성된 응답 패킷 반환
    }

    // ... RelayCommandAsync 및 응답 생성 헬퍼 메서드들은 이전과 동일 ...
    // CreateExecutionResponse, CreateErrorResponse 메서드는 이전과 동일하게 유지
}
ExecuteDirectCommandAsync의 MonitorControl 부분 변경 설명:

MonitorAction.Off인 경우:
success = true와 함께 관련 메시지로 responsePacket을 먼저 생성합니다.
그 후에 LocalDeviceControl.SetMonitorState(MonitorAction.Off)를 호출하여 모니터를 끕니다.
만약 SetMonitorState 호출 자체가 실패하면 (P/Invoke 오류), 해당 오류는 로그로 기록됩니다. 이 경우 이미 "성공"으로 간주된 응답이 SControlM으로 전송될 수 있다는 점을 인지해야 합니다. (주석으로 표시된 것처럼, 여기서 응답을 다시 오류로 덮어쓰는 로직을 추가할 수도 있습니다.)
다른 MonitorAction (On, Standby)의 경우: 이전과 동일하게 모니터 상태 변경 후 응답을 생성합니다.
이렇게 변경하면:

SAgentM.App은 모니터 끄기 명령을 받으면, 화면을 실제로 끄는 동작을 하기 직전에 SControlM으로 "처리 중" 또는 "성공 예정"이라는 응답을 보낼 수 있게 됩니다.