import streamlit as st
import pandas as pd
import mysql.connector
from datetime import datetime, timedelta

# --- Database Connection Configuration ---
# !!! REPLACE WITH YOUR ACTUAL DATABASE CREDENTIALS !!!
# For production, consider using Streamlit Secrets or environment variables.
DB_HOST = "localhost"  # Or your MySQL server IP/hostname
DB_USER = "your_mysql_user"
DB_PASSWORD = "your_mysql_password"
DB_NAME = "smd"  # Database where 'repair_func_now' table resides

# --- Caching for Performance ---
@st.cache_resource(ttl=3600) # Cache the database connection for 1 hour
def get_connection():
    """Establishes a connection to the MySQL database."""
    try:
        conn = mysql.connector.connect(
            host=DB_HOST,
            user=DB_USER,
            password=DB_PASSWORD,
            database=DB_NAME,
            auth_plugin='mysql_native_password' # For MySQL 5.7, this might be needed
        )
        return conn
    except mysql.connector.Error as err:
        st.error(f"Error connecting to MySQL: {err}")
        return None

@st.cache_data(ttl=60) # Cache the fetched data for 60 seconds
def fetch_and_process_data():
    """Fetches data from the database and processes it."""
    conn = get_connection()
    if conn is None:
        return pd.DataFrame() # Return empty DataFrame on connection error

    query = """
    SELECT
        *,
        CAST(stdtime AS DATETIME) AS stdtime_dt -- Ensure stdtime is treated as datetime for accurate comparison
    FROM
        repair_func_now
    WHERE
        line LIKE '%-%'
    ORDER BY
        line ASC;
    """
    try:
        df = pd.read_sql(query, conn)
        # Ensure stdtime_dt is properly converted to datetime objects
        if 'stdtime_dt' in df.columns:
            df['stdtime_dt'] = pd.to_datetime(df['stdtime_dt'], errors='coerce')
        else:
            st.warning("Column 'stdtime' (or its alias 'stdtime_dt') was not found or could not be converted.")
            # Create an empty datetime column if it's missing, to prevent errors later
            df['stdtime_dt'] = pd.NaT
        return df
    except Exception as e:
        st.error(f"Error fetching or processing data: {e}")
        return pd.DataFrame()
    finally:
        if conn and conn.is_connected():
            conn.close()

# --- Styling Function ---
def highlight_old_records(row):
    """Applies yellow background to rows where stdtime is older than 1 hour."""
    style = [''] * len(row) # Default: no style
    # Check if 'stdtime_dt' column exists and the value is a valid datetime
    if 'stdtime_dt' in row and pd.notnull(row['stdtime_dt']):
        # Ensure 'now' is timezone-naive if 'stdtime_dt' is timezone-naive
        # MySQL DATETIME is typically timezone-naive.
        now = datetime.now()
        # If your stdtime is stored in UTC and your server is in a different timezone,
        # you'll need to handle timezone conversions. For this example, we assume
        # stdtime is in the same effective timezone as the server running Streamlit.
        if (now - row['stdtime_dt']) > timedelta(hours=1):
            style = ['background-color: yellow'] * len(row)
    return style

# --- Streamlit App Layout ---
st.set_page_config(layout="wide", page_title="Repair Function Status")
st.title("🛠️ SMD Repair Function Status Viewer")

st.markdown("""
This application displays records from the `smd.repair_func_now` table where the `line` column contains a hyphen (e.g., '1-1').
Records are sorted by the `line` column in ascending order.
Rows with an `stdtime` older than 1 hour from the current time are highlighted in **yellow**.
""")

# --- Sidebar for Configuration (Optional but good practice) ---
st.sidebar.header("⚙️ Database Settings")
st.sidebar.info(f"""
**Host:** `{DB_HOST}`
**User:** `{DB_USER}`
**Database:** `{DB_NAME}`
*To change these, modify the script and restart Streamlit.*
""")
st.sidebar.markdown("---")
st.sidebar.info(f"🕒 Current Server Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")


# --- Main Application Logic ---
if st.button("🔄 Refresh Data", key="refresh_button"):
    st.cache_data.clear() # Clear data cache
    st.cache_resource.clear() # Clear connection cache (optional, for full refresh)
    st.rerun()

df_data = fetch_and_process_data()

if not df_data.empty:
    st.subheader(f"Filtered and Sorted Records (Total: {len(df_data)})")

    # Apply styling if 'stdtime_dt' is present and valid
    if 'stdtime_dt' in df_data.columns:
        styled_df = df_data.style.apply(highlight_old_records, axis=1)
        # Display all columns; you can select specific columns if needed
        st.dataframe(styled_df, use_container_width=True, hide_index=True)
    else:
        st.warning("Could not apply time-based styling because the 'stdtime_dt' column is missing or invalid.")
        st.dataframe(df_data, use_container_width=True, hide_index=True)

    # Optional: Show raw data in an expander
    with st.expander("🔍 Show Raw Data (Unstyled)"):
        st.dataframe(df_data, use_container_width=True, hide_index=True)

elif get_connection() is None: # Check if connection failed
    st.error("Failed to connect to the database. Please check your credentials and server status in the terminal or logs.")
else:
    st.info("No data matching the criteria (line contains '-') found in `smd.repair_func_now`, or an error occurred during data fetching.")
