네, 죄송합니다. 코드에 오류가 있었던 것 같습니다. 하나씩 해결해 보겠습니다.

1. DownstreamAgentClient.cs의 _writer 오류 수정

지적해주신 대로 DownstreamAgentClient.cs 파일 내에서 _streamWriter로 선언된 멤버 변수를 일부 메서드에서 _writer로 잘못 참조하고 있었을 수 있습니다. 일관되게 _streamWriter를 사용하도록 수정하겠습니다.

다음은 DownstreamAgentClient.cs 파일의 수정된 전체 코드입니다. _streamWriter 사용 부분을 주의 깊게 봐주십시오.

C#

// MonitorAgent/Network/DownstreamAgentClient.cs
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Services; // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // 공용 MessageContract 사용

namespace MonitorAgent.Network
{
    public class DownstreamAgentClient : IDisposable
    {
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter; // 멤버 변수 이름을 _streamWriter로 통일
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null && !_isDisposed;

        public DownstreamAgentClient(ILoggingService logger)
        {
            _logger = logger;
        }

        public async Task<bool> ConnectAsync(string targetIp, int targetPort, CancellationToken token)
        {
            if (IsConnected) Disconnect(); 
            if (_isDisposed) throw new ObjectDisposedException(nameof(DownstreamAgentClient));

            _logger.LogInfo($"Downstream: Attempting to connect to final target Agent: {targetIp}:{targetPort}");
            _tcpClient = new TcpClient();
            try
            {
                var connectTask = _tcpClient.ConnectAsync(targetIp, targetPort);
                var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(5), token); 

                if (await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false) == connectTask && 
                    connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true }; // 여기서 _streamWriter 초기화
                    _logger.LogInfo($"Downstream: Successfully connected to final target Agent {targetIp}:{targetPort}.");
                    return true;
                }
                else
                {
                    _tcpClient.Close(); // 사용한 TcpClient 정리
                    if (token.IsCancellationRequested)
                        _logger.LogInfo("Downstream: Connection attempt to final target Agent cancelled.");
                    else
                        _logger.LogWarning($"Downstream: Timeout or error connecting to final target Agent {targetIp}:{targetPort}.");
                    return false;
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                 _logger.LogInfo("Downstream: Connection attempt to final target Agent cancelled by token.");
                 _tcpClient?.Close();
                 return false;
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error connecting to final target Agent {targetIp}:{targetPort}: {ex.Message}", ex);
                _tcpClient?.Close();
                return false;
            }
        }

        public async Task<AgentCommandResultPayload> SendCommandAndGetResponseAsync(
            BrokerExecuteControlPayload commandToRelayToFinalAgent, 
            string originalCorrelationId, 
            string gatewayAgentId, 
            string finalTargetAgentActualId, 
            CancellationToken token)
        {
            if (!IsConnected || _isDisposed) // IsConnected는 _streamWriter null 체크도 포함해야 함 (초기화 전 사용 방지)
            {
                _logger.LogError("Downstream: Not connected, disposed, or stream writer not initialized. Cannot send command.");
                return new AgentCommandResultPayload { Success = false, Message = "Gateway not properly connected to final agent." };
            }

            try
            {
                var messageToFinalAgent = new BrokerMessage
                {
                    Type = MessageType.BrokerToAgent_ExecuteControl,
                    CorrelationId = originalCorrelationId,
                    SourceId = gatewayAgentId, 
                    TargetId = finalTargetAgentActualId, 
                    Payload = JsonConvert.SerializeObject(commandToRelayToFinalAgent)
                };

                string requestJson = JsonConvert.SerializeObject(messageToFinalAgent);
                _logger.LogDebug($"Downstream: Sending to final agent ({finalTargetAgentActualId}): {requestJson}");
                
                lock (_sendLock)
                {
                    // _writer 대신 _streamWriter 사용
                    if (IsConnected && _streamWriter != null && !_isDisposed) _streamWriter.WriteLine(requestJson);
                    else throw new IOException("Downstream connection lost or writer disposed before send.");
                }

                var readTask = _streamReader.ReadLineAsync();
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), token); 

                if (await Task.WhenAny(readTask, timeoutTask).ConfigureAwait(false) == readTask && readTask.Result != null)
                {
                    string responseJson = readTask.Result;
                    _logger.LogDebug($"Downstream: Received from final agent ({finalTargetAgentActualId}): {responseJson}");
                    var responseMessage = JsonConvert.DeserializeObject<BrokerMessage>(responseJson);
                    if (responseMessage != null && responseMessage.Type == MessageType.AgentCommandResult)
                    {
                        return JsonConvert.DeserializeObject<AgentCommandResultPayload>(responseMessage.Payload);
                    }
                    else
                    {
                        _logger.LogWarning($"Downstream: Unexpected or invalid response from final agent ({finalTargetAgentActualId}): {responseJson}");
                        return new AgentCommandResultPayload { Success = false, Message = "Invalid response from final agent." };
                    }
                }
                else
                {
                    if (token.IsCancellationRequested)
                        _logger.LogWarning($"Downstream: Response wait cancelled for final agent ({finalTargetAgentActualId}).");
                    else
                        _logger.LogWarning($"Downstream: Timeout waiting for response from final agent ({finalTargetAgentActualId}).");
                    return new AgentCommandResultPayload { Success = false, Message = "Timeout or cancelled waiting for final agent response." };
                }
            }
            catch (OperationCanceledException) when (token.IsCancellationRequested)
            {
                _logger.LogWarning($"Downstream: Operation cancelled while communicating with final agent ({finalTargetAgentActualId}).");
                return new AgentCommandResultPayload { Success = false, Message = "Operation cancelled."};
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error during command relay to final agent ({finalTargetAgentActualId}): {ex.Message}", ex);
                return new AgentCommandResultPayload { Success = false, Message = $"Error relaying to final agent: {ex.Message}" };
            }
            finally
            {
                Disconnect(); 
            }
        }

        public void Disconnect()
        {
            if (_isDisposed) return;
            // _logger.LogInfo("Downstream: Disconnecting from final target Agent.");
            try { _streamWriter?.Dispose(); } catch { /* 무시 */ } // _writer 대신 _streamWriter
            _streamWriter = null;
            try { _streamReader?.Dispose(); } catch { /* 무시 */ }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { /* 무시 */ }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { /* 무시 */ }
            _tcpClient = null;
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Disconnect();
            GC.SuppressFinalize(this);
        }
    }
}
DownstreamAgentClient.cs 수정된 부분:

모든 _writer 참조를 _streamWriter로 변경했습니다.
ConnectAsync에서 _streamWriter가 성공적으로 초기화된 후에만 IsConnected가 true로 간주될 수 있도록 (간접적으로) SendMessageAndGetResponseAsync의 IsConnected 체크가 의미를 가지도록 했습니다. (실제 IsConnected 프로퍼티는 _networkStream != null도 체크합니다.)
SendMessageAndGetResponseAsync의 IsConnected 체크 부분에 _streamWriter != null 조건은 이미 IsConnected 프로퍼티에 포함되어 있을 것이므로, 해당 프로퍼티를 신뢰합니다.
2. BrokerAddressProvider.cs 및 BrokerAddressFileName 오류 해결

이전에 설명드린 대로, MonitorAgent는 이제 중계 서버 주소를 명령줄 인자로 받습니다. 따라서 BrokerAddressProvider.cs 파일과 AppConstants.BrokerAddressFileName 상수는 더 이상 필요하지 않습니다.

조치 사항:

MonitorAgent 프로젝트에서 Config/BrokerAddressProvider.cs 파일이 있다면 삭제하십시오.
MonitorAgent/Config/AppConstants.cs 파일에서 BrokerAddressFileName 관련 상수가 있다면 삭제하십시오. (이전 답변에서 이미 제거된 버전을 드렸습니다.)
MonitorAgent/App.xaml.cs 파일의 OnStartup 메서드가 명령줄 인자(e.Args)를 올바르게 파싱하여 AgentCore 생성자에 IP와 포트를 전달하는지 다시 한번 확인해주십시오. (이전 답변에서 이 로직이 포함된 App.xaml.cs 코드를 드렸습니다.)
이전 답변에서 제공된 App.xaml.cs의 관련 부분:

C#

// MonitorAgent/App.xaml.cs
// ...
        private string _brokerIpFromArgs = null;
        private int _brokerPortFromArgs = 0;

        protected override async void OnStartup(StartupEventArgs e)
        {
            // ... (로그 서비스 등 초기화) ...

            // 1. 명령줄 인자 파싱 (Broker IP, Port)
            if (e.Args.Length >= 2)
            {
                _brokerIpFromArgs = e.Args[0];
                if (!int.TryParse(e.Args[1], out _brokerPortFromArgs) || _brokerPortFromArgs <=0 || _brokerPortFromArgs > 65535)
                {
                    _brokerPortFromArgs = 0; // 잘못된 포트
                    Console.WriteLine("[ERROR] Invalid Broker Port specified in command line arguments.");
                }
            }
            else
            {
                Console.WriteLine("[ERROR] Broker IP and Port must be provided as command line arguments.");
                MessageBox.Show("Broker IP address and Port number must be provided as command line arguments.\nUsage: MonitorAgent.exe <BrokerIP> <BrokerPort>", 
                                "Missing Arguments", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown(-1); 
                return;
            }
            // ... (로거 초기화 이후) ...
            if (string.IsNullOrEmpty(_brokerIpFromArgs) || _brokerPortFromArgs == 0)
            {
                // _loggingService가 초기화된 이후라면 로거 사용 가능
                _loggingService?.LogFatal("Broker IP or Port from command line is invalid. Agent cannot start.");
                 MessageBox.Show("Broker IP or Port from command line is invalid. Agent cannot start.", 
                                "Configuration Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown(-1);
                return;
            }

            // ... (다른 서비스 초기화) ...

            // AgentCore 생성 시 명령줄에서 받은 IP와 포트 전달
            _agentCore = new AgentCore(_loggingService, _agentIdentifier, _brokerIpFromArgs, _brokerPortFromArgs, _monitorControlService);
            // ...
        }
// ...
확인 및 다음 단계:

위 수정된 DownstreamAgentClient.cs 코드를 적용해 보시고, BrokerAddressProvider.cs 관련 파일을 프로젝트에서 완전히 제거하신 후 다시 빌드해 보십시오.