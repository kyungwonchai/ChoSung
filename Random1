료 후에 오류 창이 뜨는 것은 정말 답답한 상황입니다. 원인을 명확히 파악하기 위해 몇 가지 추가적인 조치와 디버깅 방법을 시도해 보겠습니다.

오류 원인 재분석:

창이 닫힌 후에 "DB 컨텍스트 생성 오류"가 발생한다면, 이는 애플리케이션 종료 프로세스가 진행되는 동안 예상치 못한 코드(아마도 백그라운드 스레드나 완료되지 않은 비동기 작업의 후속 처리)가 new LockerDbContext()를 다시 호출하려고 시도하고, 이때 필요한 환경(예: 설정 파일 접근)이 이미 정리되었거나 불안정하여 발생하는 것일 수 있습니다. 또는, Dispose 과정 자체에서 발생하는 예외가 처리되지 않아 시스템 오류 창으로 나타날 수도 있습니다.

해결 및 진단 방향:

전역 예외 처리기 확인 (App.xaml.cs): DispatcherUnhandledException 핸들러에서 e.Handled = true; 설정이 누락되면 UI 스레드에서 발생하는 처리되지 않은 예외가 앱을 강제 종료시키고 시스템 오류 창을 띄울 수 있습니다. 이 부분을 확실히 설정합니다.
Dispose 메서드 안정성 강화 (MainViewModel.cs, LogViewModel.cs): Dispose 메서드 내에서 다른 객체(특히 DbContext)를 Dispose 할 때 발생하는 예외를 잡아서 최소한 앱 크래시는 막도록 합니다.
DbContext 생성 시점 추적: LockerDbContext 생성자에 디버그 출력문을 추가하여, 종료 과정에서 의도치 않게 생성자가 호출되는지 확인합니다.
디버깅 중단점 설정 (중요):
App.xaml.cs: App_DispatcherUnhandledException, TaskScheduler_UnobservedTaskException, CurrentDomain_UnhandledException 메서드 내부에 중단점을 설정합니다. 종료 시 오류가 발생할 때 이 중 하나에서 멈춘다면, 전달되는 Exception 객체의 ToString() 내용 전체(특히 InnerException) 를 확인하는 것이 결정적입니다.
LockerDbContext.cs: LockerDbContext() 생성자 내부에 중단점을 설정합니다. 만약 프로그램 종료 후에 여기서 멈춘다면, Visual Studio의 호출 스택(Call Stack) 창을 통해 어떤 코드 경로에서 이 생성자를 호출하는지 확인해야 합니다.
수정해야 할 파일 목록:

App.xaml.cs (전역 예외 처리기 확인 및 강화)
ViewModels/MainViewModel.cs (Dispose 안정성 강화)
Data/LockerDbContext.cs (생성자 추적 코드 추가)
(ViewModels/LogViewModel.cs의 Dispose 수정은 MainViewModel과 유사하므로 생략)
아래에 이 3개 파일의 수정된 전체 코드(주석 제외)를 작성합니다.

1. App.xaml.cs (수정)

C#

using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace LockerManagementApp
{
    public partial class App : Application
    {
        public static bool IsShuttingDown { get; private set; } = false;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            SetupGlobalExceptionHandling();
            Debug.WriteLine("애플리케이션 시작됨.");
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Debug.WriteLine("애플리케이션 종료 시작됨.");
            IsShuttingDown = true;
            base.OnExit(e);
            Debug.WriteLine("애플리케이션 종료 완료.");
        }

        #region 전역 예외 처리 (Global Exception Handling)

        private void SetupGlobalExceptionHandling()
        {
            DispatcherUnhandledException += App_DispatcherUnhandledException;
            TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            Debug.WriteLine("전역 예외 처리기 설정 완료.");
        }

        private void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            Debug.WriteLine("--- DispatcherUnhandledException 발생 ---");
            LogAndShowException(e.Exception, "UI Thread Exception");
            e.Handled = true; // *** 중요: 앱 크래시 방지 ***
        }

        private void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e)
        {
            Debug.WriteLine("--- TaskScheduler_UnobservedTaskException 발생 ---");
            LogAndShowException(e.Exception, "Background Task Exception");
            e.SetObserved();
        }

        private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        {
            Debug.WriteLine("--- CurrentDomain_UnhandledException 발생 ---");
            LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception", !e.IsTerminating);
        }

        private void LogAndShowException(Exception exception, string source, bool showMessageBox = true)
        {
            string errorMessage = $"예기치 않은 오류 발생 ({source}):\n\n{exception.ToString()}";
            Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}");

            if (showMessageBox && !IsShuttingDown)
            {
                try { MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
                catch (Exception msgEx) { Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}"); }
            }
        }

        #endregion
    }
}
2. ViewModels/MainViewModel.cs (수정)

Dispose 메서드 내부 호출을 try-catch로 감쌉니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;
        private object _selectedCellValue;
        private string _selectedCellColumnFieldName;

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set => SetProperty(ref _selectedAssignment, value); }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        public object SelectedCellValue { get => _selectedCellValue; private set => SetProperty(ref _selectedCellValue, value); }
        public string SelectedCellColumnFieldName { get => _selectedCellColumnFieldName; private set => SetProperty(ref _selectedCellColumnFieldName, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { if (!App.IsShuttingDown) MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 DB 컨텍스트 생성 오류 무시됨: {ex.Message}"); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync(), CanExecuteCommand); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync(), CanSaveChangesExecute); AddNewCommand = new RelayCommand(AddNewLocker, CanExecuteCommand); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), CanDeleteExecute); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, CanClearAssignmentExecute); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword, CanExecuteCommand); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync(), CanExecuteCommand); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow, CanExecuteCommand);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private bool CanExecuteCommand(object parameter) => !_disposed;
        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private bool CanDeleteExecute(object parameter) => !_disposed && SelectedAssignment != null;
        private bool CanClearAssignmentExecute(object parameter) => !_disposed && SelectedAssignment != null && SelectedAssignment.IsAssigned;

        private async Task LoadInitialDataAsync() { if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; await LoadMasterDataAsync(); if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (!CanExecuteCommand(null) || _context == null || _cts.IsCancellationRequested) return; StatusBarText = "사물함 목록 로딩 중..."; List<LockerAssignment> assignments = null; try { var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList(); if (trackedAssignments.Any()) { foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; } if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨 (await 이후)."); return; } Application.Current.Dispatcher.Invoke(() => { if (_cts.IsCancellationRequested || _disposed || Application.Current == null) return; LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; (DeleteCommand as RelayCommand)?.RaiseCanExecuteChanged(); (ClearAssignmentCommand as RelayCommand)?.RaiseCanExecuteChanged(); }); } catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadAssignmentsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (!CanExecuteCommand(null) || _cts.IsCancellationRequested) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { var types = await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var floors = await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var zones = await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var subParts = await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var administrators = await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; Application.Current.Dispatcher.Invoke(() => { if (_cts.IsCancellationRequested || _disposed || Application.Current == null) return; AllLockerTypes = new ObservableCollection<LockerType>(types); AllFloors = new ObservableCollection<Floor>(floors); AllZones = new ObservableCollection<Zone>(zones); AllSubParts = new ObservableCollection<SubPart>(subParts); AllAdministrators = new ObservableCollection<Administrator>(administrators); if (!_cts.IsCancellationRequested && !_disposed) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; }); } } catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadMasterDataAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { if (!CanExecuteCommand(parameter)) return; try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!CanExecuteCommand(parameter)) return; if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { if (!App.IsShuttingDown && !_disposed) MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); else Debug.WriteLine($"종료 중 마스터 데이터 관리 창 열기 오류 무시됨: {ex.Message}"); } }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync() { if (!CanSaveChangesExecute(null)) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (!CanExecuteCommand(parameter)) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        private async Task DeleteSelectedAsync() { if (!CanDeleteExecute(null)) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (CanExecuteCommand(null) && !_cts.IsCancellationRequested) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (!CanClearAssignmentExecute(parameter)) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; if (!_disposed && !App.IsShuttingDown) MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; if (!_disposed && !App.IsShuttingDown) MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Highlight Logic (이전과 동일)
        public void UpdateHighlightInfo(string fieldName, LockerAssignment currentItem) { var targetColumns = new List<string> { "LockerType", "Floor", "Zone", "SubPart", "Administrator" }; if (currentItem != null && fieldName != null && targetColumns.Contains(fieldName)) { var propertyInfo = typeof(LockerAssignment).GetProperty(fieldName); if (propertyInfo != null) { SelectedCellValue = propertyInfo.GetValue(currentItem); SelectedCellColumnFieldName = fieldName; } else { ClearHighlightInfo(); } } else { ClearHighlightInfo(); } }
        private void ClearHighlightInfo() { SelectedCellValue = null; SelectedCellColumnFieldName = null; }
        #endregion

        #region Helper Methods (오류 메시지 표시 전 App.IsShuttingDown 확인)
        private void HandleGenericException(string operation, Exception ex) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 {operation} 오류 무시됨: {ex.Message}"); return; } StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 DB 업데이트 오류 무시됨: {dbEx.Message}"); return; } Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { if (App.IsShuttingDown || _disposed) { Debug.WriteLine($"종료 중 유효성 검사 오류 무시됨: {vex.Message}"); return; } var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (Dispose 내부 try-catch 추가)
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                _disposed = true;
                if (disposing)
                {
                    Debug.WriteLine("MainViewModel Dispose 시작...");
                    try { _cts?.Cancel(); } catch (Exception ex) { Debug.WriteLine($"!!! MainVM CancellationTokenSource Cancel 오류: {ex.Message}"); }
                    try { _cts?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! MainVM CancellationTokenSource Dispose 오류: {ex.Message}"); }
                    try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! MainViewModel DbContext Dispose 오류: {ex.Message}"); }
                    try { LogVM?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogViewModel Dispose 오류: {ex.Message}"); }
                    Debug.WriteLine("MainViewModel 리소스 해제 완료.");
                }
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. ViewModels/LogViewModel.cs (수정)

Dispose 메서드 내부의 _context.Dispose() 호출을 try-catch로 감쌉니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Collections.Generic;

namespace LockerManagementApp.ViewModels
{
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private ObservableCollection<AuditLog> _auditLogs;
        private string _statusMessage;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;

        public ObservableCollection<AuditLog> AuditLogs { get => _auditLogs; set => SetProperty(ref _auditLogs, value); }
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        public LogViewModel()
        {
            AuditLogs = new ObservableCollection<AuditLog>();
            try { _context = new LockerDbContext(); }
            catch (Exception ex)
            {
                if (!App.IsShuttingDown) MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                else Debug.WriteLine($"종료 중 [Log] DB 컨텍스트 생성 오류 무시됨: {ex.Message}");
                StatusMessage = "[Log] DB 연결 오류!"; LoadLogsCommand = new RelayCommand(_ => { }, _ => !_disposed); return;
            }
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync(), CanExecuteLoadLogs);
            if (_context != null) { _ = LoadLogsAsync(); }
        }

        public async Task LoadLogsAsync()
        {
            if (!CanExecuteLoadLogs()) return;
            StatusMessage = "로그 로딩 중...";
            (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged();
            List<AuditLog> logs = null;
            try
            {
                if (!CanExecuteLoadLogs()) return;
                logs = await _context.AuditLogs.OrderByDescending(log => log.Timestamp).Take(1000).AsNoTracking().ToListAsync(_cts.Token);
                if (_disposed || _cts.IsCancellationRequested) { Debug.WriteLine("LoadLogsAsync 작업 취소됨 (await 이후)."); return; }
                Application.Current.Dispatcher.Invoke(() =>
                {
                    if (_disposed || _cts.IsCancellationRequested || Application.Current == null) return;
                    AuditLogs = new ObservableCollection<AuditLog>(logs);
                    StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
                });
            }
            catch (OperationCanceledException) { Debug.WriteLine("LoadLogsAsync 작업 취소됨."); if (!_disposed) StatusMessage = "로그 로딩 취소됨."; }
            catch (ObjectDisposedException) { Debug.WriteLine("LoadLogsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusMessage = "로그 로딩 중 오류 발생 (컨텍스트 해제됨)."; }
            catch (SqlException sqlEx) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 DB 오류: {sqlEx.Message}"; MessageBox.Show(StatusMessage, "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (EntityException entityEx) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 EF 오류: {entityEx.Message}"; MessageBox.Show(StatusMessage, "EF 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (Exception ex) { if (CanExecuteLoadLogs() && !App.IsShuttingDown) { StatusMessage = $"로그 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            finally { /* finally에서는 UI 업데이트 제거됨 */ }
        }

        private bool CanExecuteLoadLogs(object parameter = null) => !_disposed && _context != null && !_cts.IsCancellationRequested;

        #region IDisposable 구현 (Dispose 내부 try-catch 추가)
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                 _disposed = true;
                if (disposing)
                {
                    Debug.WriteLine("LogViewModel Dispose 시작...");
                    try { _cts?.Cancel(); } catch (Exception ex) { Debug.WriteLine($"!!! LogVM CancellationTokenSource Cancel 오류: {ex.Message}"); }
                    try { _cts?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogVM CancellationTokenSource Dispose 오류: {ex.Message}"); }
                    // *** 수정: DbContext Dispose 호출을 try-catch로 감쌈 ***
                    try { _context?.Dispose(); } catch (Exception ex) { Debug.WriteLine($"!!! LogViewModel DbContext Dispose 오류: {ex.Message}"); }
                    Debug.WriteLine("LogViewModel 리소스 해제 완료.");
                }
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
핵심 변경 사항:

App.xaml.cs: SetupGlobalExceptionHandling 호출이 OnStartup에 있는지, DispatcherUnhandledException 핸들러에 e.Handled = true가 있는지 확인합니다. LogAndShowException에서 !App.IsShuttingDown 조건으로 종료 시 메시지 박스를 막습니다.
MainViewModel.cs / LogViewModel.cs: Dispose 메서드 내부에서 _context.Dispose() 및 다른 Dispose 호출(예: LogVM.Dispose())을 각각 try-catch 블록으로 감쌌습니다. 이를 통해 Dispose 과정 자체에서 예외가 발생하더라도 상위로 전파되어 앱이 비정상 종료되는 것을 방지하고, 대신 오류를 디버그 출력 창에 기록합니다.
LockerDbContext.cs: 생성자에서 연결 문자열을 명시적으로 읽어오도록 수정했습니다 (GetConnectionString 메서드 사용). 이는 특정 ViewModel에서만 연결 문자열을 찾지 못하는 문제를 해결하는 데 도움이 될 수 있습니다.
디버깅 강조:

만약 이 코드를 적용한 후에도 종료 시 "초기화 오류" 창이 계속 나타난다면, 이는 App.xaml.cs의 전역 예외 처리기가 제대로 동작하지 않거나(e.Handled = true 누락 등), 예상치 못한 스레드에서 예외가 발생하여 처리기를 우회하는 등 더 깊은 문제가 있을 수 있습니다.