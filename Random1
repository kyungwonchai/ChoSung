, LocalDeviceControl.cs 파일의 (uint)WM_SYSCOMMAND 부분에서 "System.IntPtr 형식으로 바꿀 수 없다"는 오류가 발생하신다는 말씀이시군요.

이 오류는 일반적으로 SendMessageTimeout 함수의 P/Invoke 선언부에서 Msg 파라미터의 타입이 uint가 아닌 다른 타입(아마도 IntPtr)으로 잘못 선언되었을 때 발생합니다.

WM_SYSCOMMAND 자체는 uint 타입의 상수 값(0x0112)입니다. SendMessageTimeout 함수는 두 번째 파라미터로 uint 타입의 메시지 ID를 기대합니다. 만약 P/Invoke 선언부에서 이 두 번째 파라미터가 IntPtr Msg와 같이 IntPtr로 선언되어 있다면, uint 타입인 WM_SYSCOMMAND 값을 전달하려고 할 때 "IntPtr로 변환할 수 없음" 오류가 발생합니다.

올바른 P/Invoke 선언과 사용법을 다시 한번 확인해 보시고, 사용자님의 LocalDeviceControl.cs 파일과 비교해 보십시오.

아래에 SControl.Common 프로젝트의 LocalDeviceControl.cs 파일 전체 최종 코드를 다시 제공해 드립니다. 이 코드로 파일을 완전히 교체하시거나, 특히 SendMessageTimeout 함수의 선언부와 호출 부분을 주의 깊게 비교 수정해 보시기 바랍니다.

수정: SControl.Common/LocalDeviceControl.cs (전체 코드)
C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 클래스 사용

namespace SControl.Common
{
    /// <summary>
    /// P/Invoke를 사용하여 로컬 장치의 상태를 제어하는 유틸리티 클래스입니다.
    /// 현재는 모니터 전원 제어 기능을 제공합니다.
    /// </summary>
    public static class LocalDeviceControl
    {
        // 모니터 전원 제어를 위한 Windows API 상수 정의
        private const int HWND_BROADCAST = 0xFFFF;
        private const uint WM_SYSCOMMAND = 0x0112;    // <<--- 이 값은 uint 입니다.
        private const uint SC_MONITORPOWER = 0xF170;

        // user32.dll의 SendMessageTimeout 함수 원형 선언 (P/Invoke)
        // SetLastError = true 로 설정하여 Marshal.GetLastWin32Error() 호출 가능하게 함
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,                     // 메시지를 받을 윈도우 핸들.
            uint Msg,                        // <<--- 중요: 이 파라미터는 uint 여야 합니다.
            UIntPtr wParam,                  // 메시지의 첫 번째 파라미터.
            IntPtr lParam,                   // 메시지의 두 번째 파라미터. MonitorAction 열거형 값을 IntPtr로 변환하여 사용.
            SendMessageTimeoutFlags fuFlags, // 메시지 전송 방법 플래그.
            uint uTimeout,                   // 타임아웃 시간 (밀리초 단위).
            out UIntPtr lpdwResult);         // 메시지 처리 결과.

        /// <summary>
        /// SendMessageTimeout 함수의 동작 방식을 지정하는 플래그 열거형입니다.
        /// </summary>
        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,
            SMTO_BLOCK = 0x1,
            SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8,
            SMTO_ERRORONEXIT = 0x20
        }

        /// <summary>
        /// 로컬 PC의 모니터 전원 상태를 변경합니다.
        /// </summary>
        /// <param name="action">수행할 모니터 동작 (On, Off, Standby).</param>
        /// <exception cref="Win32Exception">Windows API 호출 실패 시 발생합니다 (오류 코드 포함).</exception>
        /// <exception cref="ArgumentOutOfRangeException">제공된 action이 유효한 MonitorAction 값이 아닐 때 발생합니다.</exception>
        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }

            IntPtr lParam = (IntPtr)action; // MonitorAction enum 값을 lParam으로 직접 사용
            UIntPtr commandResultPlaceholder;

            // SendMessageTimeout API 호출
            IntPtr apiCallResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,      // hWnd 파라미터 (IntPtr)
                WM_SYSCOMMAND,               // Msg 파라미터 (uint). WM_SYSCOMMAND 자체가 uint이므로 (uint) 캐스팅은 사실상 불필요.
                (UIntPtr)SC_MONITORPOWER,    // wParam 파라미터 (UIntPtr)
                lParam,                      // lParam 파라미터 (IntPtr)
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT, // fuFlags
                1000, // uTimeout (uint)
                out commandResultPlaceholder); // lpdwResult (out UIntPtr)

            if (apiCallResult == IntPtr.Zero)
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0)
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (요청 동작: {action}). Win32 오류 코드: {errorCode}");
                }
            }
        }
    }
}
확인하실 핵심 부분:

SendMessageTimeout 함수 선언부의 두 번째 파라미터:

C#

uint Msg, // <<--- 이 부분이 반드시 uint 타입이어야 합니다. IntPtr Msg, 로 되어있지 않은지 확인하세요.
SendMessageTimeout 함수 호출부의 두 번째 인자:

C#

WM_SYSCOMMAND, // <<--- WM_SYSCOMMAND (uint 타입)를 직접 전달합니다.
WM_SYSCOMMAND는 이미 uint 타입이므로, (uint)WM_SYSCOMMAND로 명시적 캐스팅을 해도 되고 안 해도 동일합니다. 중요한 것은 SendMessageTimeout 선언부의 Msg 파라미터 타입이 uint라는 점입니다.

사용자님의 코드에서 SendMessageTimeout 함수의 P/Invoke 선언 부분, 특히 두 번째 파라미터의 타입이 uint로 되어 있는지 다시 한번 꼼꼼히 확인해 주십시오. 만약 IntPtr로 되어 있다면 uint로 수정하시면 오류가 해결될 것입니다.

위 코드로 LocalDeviceControl.cs 파일을 완전히 대체하시는 것도 좋은 방법입니다.