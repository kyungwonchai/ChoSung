이해했습니다. 이제 서비스 프로젝트 (RouterMiddleACRService)를 제거한 후, 메인 UI 프로젝트 (RouterMiddleACR)에 모든 기능을 통합한 구조와 코드를 제공합니다.

RouterMiddleACR 프로젝트의 솔루션 트리 (서비스 통합 후)
RouterMiddleACR (메인 프로젝트)
MainWindow.xaml

UI를 정의하는 XAML 파일입니다.
사용자 인터페이스에는 버튼, 텍스트박스, 리스트박스 등이 포함됩니다.
MainWindow.xaml.cs

MainWindow의 코드 비하인드 파일입니다.
이벤트 핸들러와 초기화 로직이 포함되어 있으며, MainViewModel과 바인딩하여 UI 이벤트를 처리합니다.
PLC 상태를 주기적으로 확인하기 위한 타이머 초기화 및 관리 기능을 수행합니다.
App.xaml

응용 프로그램의 리소스, 스타일, 테마 등을 정의하는 파일입니다.
App.xaml.cs

App.xaml의 코드 비하인드 파일입니다.
응용 프로그램의 시작과 종료에 대한 이벤트 핸들러를 포함합니다.
ViewModels

MainViewModel.cs
MVVM 패턴에서 ViewModel 역할을 수행하는 클래스입니다.
UI와 PLC 간의 데이터를 중재하며, 커맨드 패턴을 사용하여 UI 이벤트를 처리합니다.
PLC와의 통신을 위한 로직과 PLC 상태를 주기적으로 확인하고 UI를 업데이트하는 기능을 포함합니다.
Models

ComPortManager.cs
시리얼 포트를 관리하는 클래스입니다.
시리얼 포트를 설정하고 열거나 닫는 기능을 제공하며, PLC로 명령을 전송하고 응답을 읽어옵니다.
비동기 방식으로 데이터를 송수신하여 UI가 멈추지 않도록 합니다.
PLCCommand.cs
PLC로 전송할 명령을 정의하고, 이를 처리하는 로직을 포함하는 클래스입니다.
PLCResponse.cs
PLC로부터 받은 응답을 처리하고 분석하는 클래스입니다.
Commands

RelayCommand.cs
ICommand 인터페이스를 구현하여 MVVM 패턴에서 사용되는 커맨드입니다.
명령이 실행될 수 있는지 여부를 확인하고, 명령을 실행합니다.
Helpers

MewtocolHelper.cs
Mewtocol 프로토콜을 사용하는 PLC 통신 관련 유틸리티 함수를 제공하는 클래스입니다.
명령어 생성, 응답 파싱 등 Mewtocol 프로토콜과 관련된 작업을 처리합니다.
Resources

Styles.xaml
WPF 응용 프로그램에서 사용하는 스타일, 리소스 등을 정의하는 파일입니다.
각 파일의 역할 및 주요 함수 소개
MainWindow.xaml.cs

주요 함수:
InitializeComponent(): XAML 요소를 초기화합니다.
InitializeTimers(): PLC 상태를 주기적으로 확인하기 위한 타이머를 초기화합니다.
Window_Closing(): 윈도우가 닫힐 때 포트를 닫아 리소스를 정리합니다.
MainViewModel.cs

주요 함수:
WriteToPLCAndCheckResponse(int number): PLC에 데이터를 전송하고, 응답을 확인하며, 응답이 올바른지 확인합니다.
SendTextBoxValueToPLC(string value): 텍스트박스에 입력된 값을 PLC에 전송합니다.
ReadAndClearDT2330Data(): PLC의 레지스터에서 값을 읽고, 값을 초기화합니다.
UpdatePLCStatusAsync(): 주기적으로 PLC의 상태를 확인하고 UI를 업데이트합니다.
ComPortManager.cs

주요 함수:
ConfigurePort(string portName, int baudRate, ...) : 시리얼 포트의 설정을 구성합니다.
SendDataToPLCAsync(string command): PLC에 데이터를 전송하고 응답을 비동기적으로 받습니다.
ReadFromPLCAsync(string address): PLC로부터 데이터를 비동기적으로 읽어옵니다.
ClearPLCValueAsync(string address): PLC의 레지스터 값을 초기화합니다.
OpenPort(): 시리얼 포트를 엽니다.
ClosePort(): 시리얼 포트를 닫습니다.
RelayCommand.cs

주요 함수:
CanExecute(object parameter): 명령을 실행할 수 있는지 여부를 확인합니다.
Execute(object parameter): 명령을 실행합니다.
MewtocolHelper.cs

주요 함수:
GenerateCommand(string address, int value): Mewtocol 프로토콜을 사용하여 PLC 명령을 생성합니다.
ParseResponse(string response): PLC의 응답을 파싱하여 처리합니다.
전체 코드 (각 파일에 주석 포함)
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();  // XAML 요소 초기화
            _viewModel = new MainViewModel();  // ViewModel 초기화
            DataContext = _viewModel;  // DataContext를 ViewModel로 설정

            InitializeTimers();  // 타이머 초기화
        }

        private void InitializeTimers()
        {
            // 타이머를 설정하여 주기적으로 PLC 상태를 확인합니다.
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            // 윈도우가 닫힐 때 시리얼 포트를 닫아 리소스를 정리합니다.
            _viewModel.Cleanup();
        }
    }
}
MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using RouterMiddleACR.Models;
using RouterMiddleACR.Commands;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;  // 시리얼 포트 관리를 위한 객체
        private string _r520Status;  // R520 상태 문자열
        private string _r521Status;  // R521 상태 문자열

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();

            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 1; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value))));
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";
            string response = await _comPortManager.SendDataToPLCAsync(writeCommand);

            if (!CheckMewtocolResponse(response))
            {
                LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                return;
            }

            LogMessage($"Sent {number} to DT2300, waiting for response...");

            await Task.Delay(3000);

            bool success = false;
            DateTime startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalSeconds < 30)
            {
                string dt2330Response = await _comPortManager.ReadFromPLCAsync("023300");

                if (dt2330Response.Contains(number.ToString()))
                {
                    LogMessage($"Operation completed successfully. Value {number} correctly received from DT2330.");
                    success = true;
                    await _comPortManager.ClearPLCValueAsync("023300");
                    break;
                }
                else if (dt2330Response != "0000")
                {
                    LogMessage($"ERROR: Unexpected value {dt2330Response} found in DT2330. Expected {number}.");
                    break;
                }

                await Task.Delay(1000);
            }

            if (!success)
            {
                LogMessage($"ERROR: Operation failed. Expected value {number} not received from DT2330 within 30 seconds.");
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                string response = await _comPortManager.SendDataToPLCAsync(command);

                if (!CheckMewtocolResponse(response))
                {
                    LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                    return;
                }

                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        private bool CheckMewtocolResponse(string response)
        {
            return response.Contains("%01");
        }

        public void Cleanup()
        {
            _comPortManager.ClosePort();
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

namespace RouterMiddleACR.Models
{
    public class ComPortManager
    {
        private SerialPort _port;

        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);
        }

        public async Task<string> SendDataToPLCAsync(string command)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);

                string response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending data to PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task<string> ReadFromPLCAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#RDD{address}**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);

                var response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading from PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task ClearPLCValueAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#WDD{address}0000**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                await Task.Run(() => _port.Write(commandBytes, 0, commandBytes.Length));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error clearing PLC value: {ex.Message}");
            }
        }

        public void OpenPort()
        {
            if (_port != null && !_port.IsOpen)
            {
                _port.Open();
            }
        }

        public void ClosePort()
        {
            if (_port != null && _port.IsOpen)
            {
                _port.Close();
            }
        }
    }
}
RelayCommand.cs
csharp
코드 복사
using System;
using System.Windows.Input;

namespace RouterMiddleACR.Commands
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Func<object, bool> _canExecute;

        public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public event EventHandler CanExecuteChanged;

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CanExecuteChanged?.Invoke(this, EventArgs.Empty);
        }
    }
}
MewtocolHelper.cs
csharp
코드 복사
namespace RouterMiddleACR.Helpers
{
    public static class MewtocolHelper
    {
        public static string GenerateCommand(string address, int value)
        {
            return $"%01#WDD{address}{value:D4}**\r";
        }

        public static string ParseResponse(string response)
        {
            return response;
        }
    }
}
설명:
이 최적화된 구조는 이전의 RouterMiddleACRService 프로젝트와의 분리를 없애고, 모든 기능을 단일 프로젝트인 RouterMiddleACR로 통합했습니다. 이렇게 함으로써 불필요한 서비스 설치와 소켓 통신 설정을 없애고, 코드의 단순성과 유지보수성을 향상시켰습니다. MainViewModel과 ComPortManager를 통해 PLC와의 통신을 관리하며, UI와의 상호작용도 쉽게 처리할 수 있게 되었습니다