알겠습니다. 말씀하신 기능을 정확하게 이해했습니다.

일시정지 상태일 때, 새로운 작업은 Pending 상태로 남아 있어야 하고,
Resume(재개) 버튼을 눌렀을 때는 해당 행부터 모든 작업이 리셋된 후 그 위치부터 다시 실행됩니다.
이 문제를 해결하려면 작업 상태 관리에서 일시정지 시 추가되는 작업들이 Running 상태로 바로 변하지 않고 Pending 상태로 유지되도록 해야 합니다. 또한, Resume을 눌렀을 때 모든 이전 작업을 리셋하고 해당 위치부터 다시 작업을 수행하게 해야 합니다.

이를 위해서 **작업 큐(TaskQueue)**가 실행 중인지 확인할 수 있도록 하고, 각 작업의 상태를 명확하게 관리하기 위해 IsRunning 및 IsPaused 플래그를 도입하는 방식을 복구하겠습니다.

수정된 코드
1. TaskQueue.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하며, 작업이 완료되면 다음 작업을 실행합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false; // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;  // 작업이 일시정지 상태인지 여부

    public bool IsRunning => _isRunning;  // 실행 여부 확인
    public bool IsPaused => _isPaused;  // 일시정지 상태 확인

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        // 현재 작업이 실행 중이 아니고 일시정지가 아니라면 즉시 실행
        if (!_isRunning && !_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused) // 큐에 작업이 없거나 일시정지 상태라면 리턴
        {
            _isRunning = false;  // 작업이 실행 중이지 않음
            return;
        }

        _isRunning = true; // 현재 작업 실행 중

        var task = _tasks.Dequeue(); // 큐에서 작업을 가져와 실행
        await task(); // 작업 실행 (비동기)

        _isRunning = false; // 작업이 완료되었으므로 실행 중 상태 해제
        RunNextTask(); // 다음 작업 실행 (재귀 호출)
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true; // 작업 일시정지 상태로 변경
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false; // 일시정지 해제
            if (!_isRunning)  // 작업이 실행 중이 아니면 다음 작업 실행
            {
                RunNextTask();
            }
        }
    }

    /// <summary>
    /// 작업 큐를 초기화하고 모든 작업을 삭제합니다.
    /// </summary>
    public void ClearQueue()
    {
        _tasks.Clear();  // 작업 큐를 비우고
        _isRunning = false;  // 실행 중 상태 해제
        _isPaused = false;  // 일시정지 상태 해제
    }
}
2. TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스에 따라 함수들을 실행합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수와 도형 상태를 관리하는 컬렉션
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }  // 리쥼 커맨드

    private TaskQueue _taskQueue;

    public TaskModel(TaskQueue taskQueue)
    {
        _taskQueue = taskQueue;

        // 작업 상태 초기화
        FunctionStatusList = new ObservableCollection<FunctionStatus>();

        Status = "Pending";  // 처음엔 대기 상태

        // 각 함수 및 도형 상태 추가
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);

        // 리쥼 커맨드 설정
        ResumeCommand = new RelayCommand(StartTask);
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행합니다.
    /// </summary>
    public void StartTask()
    {
        // 작업 상태 업데이트
        Status = "Running";

        // 작업 큐에 시퀀스 작업 추가
        _taskQueue.EnqueueTask(ExecuteTaskSequence);
    }

    /// <summary>
    /// 시퀀스 작업을 비동기적으로 실행합니다.
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);
        }

        Status = "Completed";  // 모든 작업 완료
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    public async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 진행 중 상태
        });

        await task();  // 비동기 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 상태
        });
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    /// <summary>
    /// 함수 이름, 작업, 도형 색상을 함께 관리합니다.
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);
    }
}
3. MainViewModel.cs (수정된 코드)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    public ICommand PauseAllCommand { get; }
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 전체 작업 정지와 재개 명령 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(_taskQueue);
            TaskList.Add(task);  // 작업 목록에 추가

            // 실행 중이면 바로 시작, 아니면 대기 상태 유지
            if (!_taskQueue.IsPaused)
            {
                task.StartTask();
            }
            else
            {
                task.Status = "Pending";  // 일시정지 상태라면 대기 상태 유지
            }
        });
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();  // 모든 작업을 일시정지
    }

    /// <summary>
    /// 모든 작업을 재개합니다. (큐 비우고 리셋)
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.ClearQueue();  // 작업 큐 비우기

        // 현재 대기 중인 모든 작업을 다시 시작
        foreach (var task in TaskList)
        {
            task.StartTask();  // 첫 번째 작업부터 다시 시작
        }
    }
}
요약:
일시정지 시:

작업이 추가되면 Pending 상태로 유지됩니다.
IsPaused 플래그가 활성화되어 있는 동안은 작업이 실행되지 않습니다.
Resume 시:

큐를 비우고 모든 대기 중인 작업을 재시작합니다.
특정 행에서 작업을 다시 시작할 때는 해당 행부터 작업을 재개할 수 있습니다.
작업 상태:

작업이 진행 중일 때는 Running, 일시정지 시에는 Pending 상태로 표시됩니다.
이 구조를 사용하면 작업 일시정지와 재개가 명확하게 구분되어 동작하고, 대기 중인 작업들이 Pending 상태로 남아 있다가 Resum