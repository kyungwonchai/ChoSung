여전히 갱신되지 않는다면 아래 문제와 해결 방법을 확인해야 합니다. 제대로 동작하도록 구체적으로 수정한 코드를 다시 제공합니다.

문제 원인
ObservableCollection과 UI 스레드 문제
ObservableCollection은 UI 스레드에서 변경이 발생해야 UI에 반영됩니다. 이벤트나 비동기 작업에서 UI 스레드를 사용하지 않을 경우 반영되지 않습니다.

뷰모델과 XAML 바인딩 확인
DataGrid가 LogEntries 컬렉션과 제대로 바인딩되지 않았거나, DataContext 설정이 잘못되었을 가능성이 있습니다.

컬렉션 변경 이벤트가 UI에 전달되지 않음
ObservableCollection이 아닌 다른 방식으로 데이터가 수정되었다면, 변경 알림이 전달되지 않았을 수 있습니다.

수정 코드
1. MergeOIErrLogManager 클래스
ObservableCollection은 UI 스레드에서만 수정되도록 Dispatcher.Invoke를 통해 안전하게 갱신합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly object _lock = new object();

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 이벤트로 전달된 로그 처리
    /// </summary>
    /// <param name="logLine">로그 라인</param>
    public void HandleLogEvent(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_lock)
                {
                    LogEntries.Add(newEntry);

                    // 오래된 로그 삭제 (최근 2일치까지만 유지)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. SocketClientMergeOI 클래스
OnLogReceived 이벤트를 통해 로그 메시지를 전달합니다.

csharp
코드 복사
using System;

public class SocketClientMergeOI
{
    public event Action<string> OnLogReceived;

    private void RaiseLogEvent(string logMessage)
    {
        OnLogReceived?.Invoke(logMessage);
    }

    public void ProcessSocketMessage(string receivedMessage)
    {
        if (receivedMessage.Contains("ERROR"))
        {
            string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] ERROR: {receivedMessage}";
            RaiseLogEvent(logMessage);
        }
    }
}
3. MainViewModel
MergeOIErrLogManager와 SocketClientMergeOI를 연결하여 로그를 처리합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    private readonly MergeOIErrLogManager _logManager;
    private readonly SocketClientMergeOI _socketClient;

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => _logManager.LogEntries;

    public MainViewModel()
    {
        _logManager = new MergeOIErrLogManager();
        _socketClient = new SocketClientMergeOI();

        // 이벤트 구독
        _socketClient.OnLogReceived += _logManager.HandleLogEvent;

        // 초기화
        Task.Run(async () => await _logManager.InitializeAsync());
    }
}
4. XAML
LogEntries를 DataGrid에 바인딩합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
테스트용 코드
아래 코드는 테스트용으로 SocketClientMergeOI가 이벤트를 발생시켜 로그를 추가합니다.

csharp
코드 복사
public class AppTest
{
    public void Test()
    {
        var socketClient = new SocketClientMergeOI();
        var logManager = new MergeOIErrLogManager();

        // 이벤트 연결
        socketClient.OnLogReceived += logManager.HandleLogEvent;

        // 테스트 메시지 처리
        socketClient.ProcessSocketMessage("ERROR: Connection lost");
        socketClient.ProcessSocketMessage("ERROR: Timeout occurred");
    }
}
주요 점검 사항
XAML 바인딩 확인

DataGrid의 ItemsSource가 LogEntries로 바인딩되어 있는지 확인합니다.
UI 스레드에서 데이터 수정

모든 ObservableCollection 수정 작업이 Dispatcher.Invoke 안에서 이루어지는지 확인합니다.
테스트 시뮬레이션

테스트 코드로 SocketClientMergeOI에서 이벤트를 발생시켜 로그가 추가되는지 확인합니다.
결과
SocketClientMergeOI에서 로그 메시지가 발생하면 MergeOIErrLogManager로 전달됩니다.