대로 된 감지가 안 되는 이유는 Threshold를 적용한 후 Contour를 검출하는 과정이 제대로 시각화되지 않았기 때문이다.
이제 다음과 같이 해결한다:

1. 해결 방향
✅ 1) 원본 이미지를 흑백 처리 (Threshold 적용)
✅ 2) 적용된 Threshold 이미지를 PictureBox에 띄움 (디버깅 가능하게)
✅ 3) 컨투어를 찾은 후, 모든 컨투어를 빨간색으로 표시하여 PictureBox에 띄움
✅ 4) 이후 창 크기 조건을 적용해 정확한 사각형을 찾음
✅ 5) PictureBox에서 흑백 이미지와 컨투어 이미지를 확인할 수 있도록 함

2. 최적화된 코드 (Form1.cs)
csharp
코드 복사
using System;
using System.Drawing;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;
using System.Runtime.InteropServices;

namespace WinFormsOpenCv
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage; // 이미지 맞추기
            pictureBox2.SizeMode = PictureBoxSizeMode.StretchImage; // 컨투어 확인용 추가
        }

        // 버튼 클릭 시 실행
        private void btnProcess_Click(object sender, EventArgs e)
        {
            // 화면 캡처
            Bitmap screenshot = CaptureScreen();
            Mat matImage = BitmapConverter.ToMat(screenshot);

            // **1) 이미지 흑백 변환**
            Mat processedImage = PreprocessImage(matImage);
            pictureBox1.Image = ConvertMatToBitmap(processedImage); // 변환된 이미지 확인

            // **2) 컨투어 찾기 및 표시**
            Mat contourImage = matImage.Clone(); // 원본 복사
            Rect detectedWindow = DetectContours(processedImage, contourImage);

            // **3) PictureBox에 컨투어 이미지 띄움**
            pictureBox2.Image = ConvertMatToBitmap(contourImage);

            if (detectedWindow != Rect.Empty)
            {
                // **닫기 버튼 위치 계산**
                int clickX = detectedWindow.Right - 10;
                int clickY = detectedWindow.Top - 10;
                Cursor.Position = new System.Drawing.Point(clickX, clickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);

                Console.WriteLine($"닫기 버튼 클릭: ({clickX}, {clickY})");
            }
            else
            {
                Console.WriteLine("해당 조건의 창을 찾을 수 없습니다.");
            }
        }

        // **화면 캡처 함수**
        private Bitmap CaptureScreen()
        {
            Rectangle bounds = Screen.PrimaryScreen.Bounds;
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);
            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
            }
            return bitmap;
        }

        // **Mat → Bitmap 변환 함수**
        private Bitmap ConvertMatToBitmap(Mat mat)
        {
            return BitmapConverter.ToBitmap(mat);
        }

        // **1) 이미지 전처리 (흑백 변환)**
        private Mat PreprocessImage(Mat image)
        {
            Mat gray = new Mat();
            Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY);

            // **Threshold 적용 (Otsu + BinaryInv)**
            Mat binary = new Mat();
            Cv2.Threshold(gray, binary, 0, 255, ThresholdTypes.BinaryInv | ThresholdTypes.Otsu);

            return binary;
        }

        // **2) 컨투어 찾고, 감지된 창에 테두리 그리기**
        private Rect DetectContours(Mat binary, Mat originalImage)
        {
            // **컨투어 찾기**
            Cv2.FindContours(binary, out OpenCvSharp.Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

            Rect detectedWindow = Rect.Empty;
            int screenWidth = Screen.PrimaryScreen.Bounds.Width;
            int screenCenterX = screenWidth / 2;
            double maxArea = 0;

            foreach (var contour in contours)
            {
                Rect rect = Cv2.BoundingRect(contour);
                double area = rect.Width * rect.Height;

                // **모든 컨투어를 빨간색으로 그림 (디버깅)**
                Cv2.Rectangle(originalImage, rect, new Scalar(0, 0, 255), 2);

                // **창 크기 필터링**
                if (rect.Width > 200 && rect.Height > 150 && rect.Width < 1000 && rect.Height < 1000 &&
                    rect.Y > 150 && Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 300 && area > maxArea)
                {
                    maxArea = area;
                    detectedWindow = rect;

                    // **감지된 창은 초록색 테두리**
                    Cv2.Rectangle(originalImage, rect, new Scalar(0, 255, 0), 3);
                    Console.WriteLine($"창 감지: 위치 ({rect.X}, {rect.Y}), 크기 ({rect.Width}x{rect.Height})");
                }
            }

            return detectedWindow;
        }

        // **마우스 클릭을 위한 WinAPI**
        [DllImport("user32.dll", SetLastError = true)]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;
    }
}
3. 주요 변경점
✅ 1) Threshold 적용 후 PictureBox에서 확인 가능
Threshold 결과를 pictureBox1에서 확인
csharp
코드 복사
pictureBox1.Image = ConvertMatToBitmap(processedImage);
여기에서 흰색 창이 제대로 감지되었는지 먼저 확인 가능!
✅ 2) 모든 컨투어를 PictureBox에서 확인 가능
컨투어를 빨간색으로 그리고, 감지된 창은 초록색으로 표시
csharp
코드 복사
Cv2.Rectangle(originalImage, rect, new Scalar(0, 0, 255), 2); // 모든 컨투어 (빨간색)
Cv2.Rectangle(originalImage, rect, new Scalar(0, 255, 0), 3); // 감지된 창 (초록색)
이제 PictureBox에서 컨투어를 확인하면서 왜 감지가 안 되는지 직접 볼 수 있음!
✅ 3) 크기 조건을 맞춘 창만 감지
csharp
코드 복사
if (rect.Width > 200 && rect.Height > 150 && rect.Width < 1000 && rect.Height < 1000 &&
    rect.Y > 150 && Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 300 && area > maxArea)
너무 작거나 너무 큰 창 무시
Y 좌표가 150 이상이어야 감지
화면 중앙 기준 300px 이내에 있는 창만 감지
✅ 4) PictureBox에서 두 개의 이미지 확인 가능
pictureBox1 → Threshold 변환된 이미지 (흑백)
pictureBox2 → 컨투어 검출된 이미지 (빨간색 & 초록색 테두리)
4. 실행 결과
WinForms 실행 후 "이진화 적용" 버튼 클릭
PictureBox1에서 흑백 Threshold 이미지 확인 가능
PictureBox2에서 모든 컨투어를 빨간색으로 표시
실제 창이 감지되었으면 초록색 테두리로 표시됨
닫기 버튼 클릭하여 창 자동 종료