 알겠습니다. 이제 "DB 컨텍스트 생성 오류" 하나만 남았군요. 이 오류는 보통 애플리케이션 시작 시 ViewModel이 new LockerDbContext()를 호출할 때 발생하며, 원인은 대부분 App.config 파일의 연결 문자열 설정 문제입니다. 다른 기능들이 작동하는 것처럼 보였더라도, 특정 시점이나 특정 ViewModel에서만 이 설정 파일을 읽는 데 실패할 수도 있습니다.

가능한 원인 및 해결 방향:

App.config 문제 재확인:
이름 정확성: LockerDbContext 생성자(base("name=LockerDbConnection"))와 App.config의 <add name="LockerDbConnection".../> 이름이 100% 일치하는지 다시 확인합니다.
파일 위치/복사: App.config 파일 속성이 "출력 디렉터리로 복사: 변경된 내용만 복사"로 되어 있는지, 빌드 후 실행 폴더(bin\Debug 등)에 [프로그램명].exe.config 파일이 생성되고 내용이 올바른지 확인합니다.
파일 구조: App.config 내 <connectionStrings> 섹션과 <configSections>, <entityFramework> 섹션의 위치와 내용이 올바른지 확인합니다.
연결 문자열 자체: connectionString="..." 부분의 서버 이름, 데이터베이스 이름, 인증 방식 등이 정확한지 확인합니다. MultipleActiveResultSets=True;가 포함되어 있는지 확인합니다.
DbContext 생성자 안정성 강화: LockerDbContext 생성자에서 ConfigurationManager를 사용하여 연결 문자열을 읽는 부분을 try-catch로 감싸서 오류 발생 시 좀 더 명확한 메시지를 제공하도록 합니다.
ViewModel 생성자 오류 처리: 각 ViewModel 생성자의 DbContext 생성 부분 catch 블록에서 ex.ToString()을 사용하여 InnerException 정보까지 모두 포함된 상세 오류 메시지를 표시하도록 합니다.
수정해야 할 파일 목록:

Data/LockerDbContext.cs (생성자 안정성 강화)
ViewModels/MainViewModel.cs (생성자 오류 처리 확인)
App.config (전체 구조 및 내용 확인용 재제공)
아래에 이 3개 파일의 수정된 전체 코드를 작성합니다.

1. Data/LockerDbContext.cs (수정)

생성자에서 연결 문자열 로드 부분을 try-catch로 감싸고, 테스트를 위해 연결 문자열을 직접 하드코딩하는 방법을 주석으로 추가합니다.

C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration; // ConfigurationManager 사용 위해 추가
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json; // Newtonsoft.Json 사용
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (생성자 안정성 강화)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- DbSets (이전과 동일) ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        // 연결 문자열 이름
        private const string ConnectionStringName = "LockerDbConnection";

        /// <summary>
        /// 기본 생성자. App.config에서 연결 문자열을 명시적으로 읽어 사용합니다.
        /// </summary>
        public LockerDbContext() : base(GetConnectionString()) // 수정: base() 호출 변경
        {
            // 데이터베이스 연결 테스트 (선택 사항, 디버깅용)
            // try
            // {
            //     this.Database.Connection.Open();
            //     this.Database.Connection.Close();
            //     Debug.WriteLine("DbContext 생성자: 데이터베이스 연결 테스트 성공.");
            // }
            // catch (Exception ex)
            // {
            //     Debug.WriteLine($"!!! DbContext 생성자: 데이터베이스 연결 테스트 실패: {ex.Message}");
            //     // 여기서 발생한 예외는 상위 호출자(ViewModel 생성자)에게 전달됩니다.
            //     throw;
            // }
        }

        /// <summary>
        /// App.config에서 연결 문자열을 안전하게 읽어오는 정적 메서드
        /// </summary>
        private static string GetConnectionString()
        {
            try
            {
                var connectionStringSetting = ConfigurationManager.ConnectionStrings[ConnectionStringName];

                if (connectionStringSetting == null || string.IsNullOrWhiteSpace(connectionStringSetting.ConnectionString))
                {
                    throw new ConfigurationErrorsException($"App.config 파일에서 '{ConnectionStringName}' 이름의 연결 문자열을 찾을 수 없거나 비어 있습니다.");
                }

                Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공: {connectionStringSetting.ConnectionString}");
                return connectionStringSetting.ConnectionString; // 실제 연결 문자열 반환
            }
            catch (ConfigurationErrorsException confEx)
            {
                 // 설정 파일 자체에 문제가 있을 경우
                 Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}");
                 throw; // 예외를 다시 던져 DbContext 생성 실패를 알림
            }
            catch (Exception ex)
            {
                 // 기타 예외 처리
                 Debug.WriteLine($"!!! 연결 문자열 로드 중 예외 발생: {ex.ToString()}");
                 throw new ConfigurationErrorsException($"App.config에서 연결 문자열 '{ConnectionStringName}'을(를) 읽는 중 오류 발생.", ex);
            }

            // --- 진단용 임시 코드 ---
            // 만약 App.config 읽기에 계속 문제가 있다면, 아래 주석을 해제하고
            // 실제 연결 문자열을 직접 입력하여 테스트해볼 수 있습니다.
            // string hardcodedConnectionString = @"Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;MultipleActiveResultSets=True;";
            // Debug.WriteLine($"경고: 하드코딩된 연결 문자열 사용 중: {hardcodedConnectionString}");
            // return hardcodedConnectionString;
            // --- 진단용 임시 코드 끝 ---
        }


        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // Fluent API 설정 (IsOptional 등)
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            // ... (다른 IsOptional 설정들) ...
            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            // LockerAssignment의 UserName 필수 오류 무시 로직
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류를 무시합니다."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (이전과 동일)
        public override int SaveChanges() { List<AuditLog> auditEntries = null; try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); } if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } } try { return base.SaveChanges(); } catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; } catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; } catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; } }
        public override async Task<int> SaveChangesAsync() { List<AuditLog> auditEntries = null; try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); } if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } } try { return await base.SaveChangesAsync(); } catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; } catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; } catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; } }
        private List<AuditLog> CreateAuditEntries() { string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser"; var auditEntries = new List<AuditLog>(); var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList(); var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None }; foreach (var entry in changedEntries) { if (entry.Entity is AuditLog) continue; var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() }; try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; } var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>(); if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } } else if (entry.State == EntityState.Modified) { foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (affectedColumns.Any()) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else continue; } auditEntries.Add(auditEntry); } UpdateLockerAssignmentTimestamps(changedEntries); return auditEntries; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; } }
        #endregion

        #region Error Logging Helpers (이전과 동일)
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.Message}"); var innerEx = dbEx.InnerException; while (innerEx != null) { Debug.WriteLine($"  InnerException: {innerEx.Message}"); innerEx = innerEx.InnerException; } foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
2. ViewModels/MainViewModel.cs (수정)

생성자의 DbContext 생성 catch 블록에서 ex.ToString()을 사용하여 상세 오류를 표시하도록 확인합니다.

C#

// 필요한 네임스페이스 (이전과 동일)
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (생성자 오류 처리 확인)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        // ... (멤버 변수, 속성, Command 정의는 이전과 동일) ...
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;
        private object _selectedCellValue;
        private string _selectedCellColumnFieldName;

        #region Public Properties (이전과 동일)
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set => SetProperty(ref _selectedAssignment, value); }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        public object SelectedCellValue { get => _selectedCellValue; private set => SetProperty(ref _selectedCellValue, value); }
        public string SelectedCellColumnFieldName { get => _selectedCellColumnFieldName; private set => SetProperty(ref _selectedCellColumnFieldName, value); }
        #endregion

        #region Commands (이전과 동일)
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            // *** 수정된 부분: 생성자 catch 블록에서 ex.ToString() 사용 확인 ***
            try
            {
                _context = new LockerDbContext(); // DbContext 생성
                StatusBarText = "데이터베이스 연결 준비 완료.";
            }
            catch (Exception ex)
            {
                // 생성 실패 시 상세 오류 메시지 표시
                MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                StatusBarText = "DB 연결 오류!";
                // ViewModel 초기화 중단
                return;
            }

            // 나머지 초기화 로직 (이전과 동일)
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync(), _ => !_disposed); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync(), CanSaveChangesExecute); AddNewCommand = new RelayCommand(AddNewLocker, _ => !_disposed); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), CanDeleteExecute); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, CanClearAssignmentExecute); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword, _ => !_disposed); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync(), _ => !_disposed); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow, _ => !_disposed);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        // CanExecute 메서드들 (이전과 동일)
        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private bool CanDeleteExecute(object parameter) => !_disposed && SelectedAssignment != null;
        private bool CanClearAssignmentExecute(object parameter) => !_disposed && SelectedAssignment != null && SelectedAssignment.IsAssigned;

        // 데이터 로딩 메서드들 (이전과 동일)
        private async Task LoadInitialDataAsync() { if (_disposed || _cts.IsCancellationRequested) return; await LoadMasterDataAsync(); if (_disposed || _cts.IsCancellationRequested) return; await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null || _disposed || _cts.IsCancellationRequested) return; StatusBarText = "사물함 목록 로딩 중..."; try { var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList(); if (trackedAssignments.Any()) { foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; } var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨 (await 이후)."); return; } Application.Current.Dispatcher.Invoke(() => { LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; (DeleteCommand as RelayCommand)?.RaiseCanExecuteChanged(); (ClearAssignmentCommand as RelayCommand)?.RaiseCanExecuteChanged(); }); } catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadAssignmentsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (_disposed || _cts.IsCancellationRequested) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { var types = await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var floors = await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var zones = await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var subParts = await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var administrators = await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; Application.Current.Dispatcher.Invoke(() => { AllLockerTypes = new ObservableCollection<LockerType>(types); AllFloors = new ObservableCollection<Floor>(floors); AllZones = new ObservableCollection<Zone>(zones); AllSubParts = new ObservableCollection<SubPart>(subParts); AllAdministrators = new ObservableCollection<Administrator>(administrators); if (!_cts.IsCancellationRequested && !_disposed) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; }); } } catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadMasterDataAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 오류 (컨텍스트 해제됨)."; } catch (SqlException sqlEx) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩 (DB 오류)", sqlEx); } catch (EntityException entityEx) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩 (EF 오류)", entityEx); } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { if (!_cts.IsCancellationRequested && !_disposed) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드 (이전과 동일)
        private async Task SaveChangesAsync() { if (_context == null || _disposed || !CanSaveChangesExecute(null)) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null || _disposed) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null || _disposed || _cts.IsCancellationRequested) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null || _disposed) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { /* ... */ return true; }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { /* ... */ }
        private string EscapeCsvValue(string value) { /* ... */ return value; }
        #endregion

        #region Helper Methods (오류 메시지 상세화)
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region Highlight Logic (이전과 동일)
        // ... (UpdateHighlightInfo, ClearHighlightInfo 메서드) ...
        public void UpdateHighlightInfo(string fieldName, LockerAssignment currentItem) { var targetColumns = new List<string> { "LockerType", "Floor", "Zone", "SubPart", "Administrator" }; if (currentItem != null && fieldName != null && targetColumns.Contains(fieldName)) { var propertyInfo = typeof(LockerAssignment).GetProperty(fieldName); if (propertyInfo != null) { SelectedCellValue = propertyInfo.GetValue(currentItem); SelectedCellColumnFieldName = fieldName; } else { ClearHighlightInfo(); } } else { ClearHighlightInfo(); } }
        private void ClearHighlightInfo() { SelectedCellValue = null; SelectedCellColumnFieldName = null; }
        #endregion

        #region IDisposable 구현 (이전과 동일)
        // private bool disposed = false; // 클래스 멤버 변수로 이동됨
        protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { Debug.WriteLine("MainViewModel Dispose 시작..."); _cts?.Cancel(); _cts?.Dispose(); _context?.Dispose(); LogVM?.Dispose(); Debug.WriteLine("MainViewModel 리소스 해제 완료."); } _disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. App.config (확인용)

연결 문자열 이름(LockerDbConnection)과 내용, 그리고 EF6 관련 섹션(configSections, entityFramework)이 올바르게 설정되어 있는지 최종 확인합니다.

XML

<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
  </configSections>

  <appSettings>
    <add key="MasterKey" value="admin123" />
  </appSettings>

  <connectionStrings>
    <add name="LockerDbConnection"
         connectionString="Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;MultipleActiveResultSets=True;"
         providerName="System.Data.SqlClient"/>
  </connectionStrings>

  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" />
  </startup>

  <entityFramework>
    <defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">
      <parameters> <parameter value="mssqllocaldb" /> </parameters>
    </defaultConnectionFactory>
    <providers>
      <provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" />
    </providers>
  </entityFramework>
</configuration>
 1 핵심 변경 사항:   
1.
learn.microsoft.com
learn.microsoft.com

LockerDbContext.cs: 생성자에서 ConfigurationManager를 사용하여 연결 문자열을 명시적으로 읽어 base() 생성자에 전달하도록 수정했습니다. 이를 통해 LogViewModel 등 다른 곳에서 DbContext를 생성할 때도 App.config를 안정적으로 참조하게 됩니다. 연결 문자열 로드 실패 시 ConfigurationErrorsException을 발생시켜 문제를 명확히 알립니다.
MainViewModel.cs, LogViewModel.cs: 생성자의 DbContext 생성 catch 블록에서 ex.ToString()을 사용하여 더 상세한 오류(InnerException 포함)를 MessageBox에 표시하도록 수정했습니다.
다음 단계:

App.config 재확인: 제공된 App.config 구조와 내용을 다시 한번 비교하고, 특히 <connectionStrings> 섹션의 name과 connectionString 값이 정확한지 확인합니다. YOUR_SERVER_NAME 을 실제 서버 이름으로 변경했는지 확인합니다.
파일 속성 확인: App.config 파일의 "출력 디렉터리로 복사" 속성이 "변경된 내용만 복사" 또는 "항상 복사"로 설정되어 있는지 확인합니다.
빌드 및 실행: 코드를 적용하고 솔루션 정리 및 다시 빌드 후 실행합니다.