청에 맞게 Flask 애플리케이션을 수정하여 DB에서 데이터를 그대로 가져오는 방식을 유지하면서, 로컬에 저장된 Chart.js와 jQuery 파일을 사용해 오프라인 환경에서도 동작하도록 구현하겠습니다.

Flask 애플리케이션 코드 (app.py)
python
코드 복사
from flask import Flask, render_template, request, jsonify
import pymssql
import pandas as pd

app = Flask(__name__)

# MSSQL 데이터베이스 연결 정보
DB_CONFIG = {
    "server": "YOUR_SERVER",
    "database": "YOUR_DATABASE",
    "username": "YOUR_USERNAME",
    "password": "YOUR_PASSWORD"
}

# MSSQL 연결 함수
def get_db_connection():
    return pymssql.connect(
        server=DB_CONFIG['server'],
        user=DB_CONFIG['username'],
        password=DB_CONFIG['password'],
        database=DB_CONFIG['database']
    )

@app.route('/PLCErr', methods=['GET', 'POST'])
def plcerr():
    conn = get_db_connection()
    query = """
        SELECT 
            linename AS '라인명',
            errN AS '에러번호',
            errValue AS '에러값',
            CONVERT(VARCHAR, Time1, 121) AS '시간'
        FROM View_PLCErrjoin
    """
    df = pd.read_sql(query, conn)
    conn.close()

    # 라인별 발생 수 데이터 준비
    line_counts = df['라인명'].value_counts().reset_index()
    line_counts.columns = ['라인명', '발생수']

    # 에러번호별 발생 수 데이터 준비
    error_counts = df['에러번호'].value_counts().reset_index()
    error_counts.columns = ['에러번호', '발생수']

    # 페이지네이션 처리
    page = int(request.args.get("page", 1))
    per_page = 100
    total_pages = -(-len(df) // per_page)  # 총 페이지 수
    df_page = df.iloc[(page - 1) * per_page : page * per_page]

    return render_template(
        'plcerr.html',
        data=df_page.to_dict(orient='records'),
        line_counts=line_counts.to_dict(orient='records'),
        error_counts=error_counts.to_dict(orient='records'),
        current_page=page,
        total_pages=total_pages
    )

@app.route('/PLCErr/filter', methods=['POST'])
def filter_plcerr():
    conn = get_db_connection()
    query = """
        SELECT 
            linename AS '라인명',
            errN AS '에러번호',
            errValue AS '에러값',
            CONVERT(VARCHAR, Time1, 121) AS '시간'
        FROM View_PLCErrjoin
    """
    df = pd.read_sql(query, conn)
    conn.close()

    # 필터 값 받기
    filters = request.json
    if filters['line']:
        df = df[df['라인명'].str.contains(filters['line'], case=False, na=False)]
    if filters['error']:
        df = df[df['에러번호'].astype(str).str.contains(filters['error'], case=False, na=False)]
    if filters['value']:
        df = df[df['에러값'].astype(str).str.contains(filters['value'], case=False, na=False)]

    return jsonify(df.to_dict(orient='records'))


if __name__ == '__main__':
    app.run(debug=True)
HTML 템플릿 (templates/plcerr.html)
html
코드 복사
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>PLC Error Viewer</title>
    <!-- 로컬에 저장된 Chart.js 및 jQuery -->
    <script src="{{ url_for('static', filename='js/Chart.min.js') }}"></script>
    <script src="{{ url_for('static', filename='js/jquery.min.js') }}"></script>
    <style>
        body {
            background-color: #121212; /* 다크 배경 */
            color: #e0e0e0; /* 텍스트 색상 */
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 20px;
        }
        h1 {
            text-align: center;
            color: #00bcd4;
        }
        .charts {
            display: flex;
            justify-content: space-between;
            margin-bottom: 20px;
            height: 20%;
        }
        canvas {
            background-color: #1e1e1e; /* 차트 배경 */
            border-radius: 10px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            background-color: #1e1e1e;
        }
        thead {
            background-color: #004d66;
        }
        thead th, tbody td {
            padding: 8px;
            text-align: left;
        }
        tbody tr:nth-child(even) {
            background-color: #2a2a2a;
        }
        tbody tr:hover {
            background-color: #3d3d3d;
        }
        .pagination {
            text-align: center;
            margin: 20px 0;
        }
        .pagination button {
            padding: 8px 16px;
            margin: 0 5px;
            border: none;
            border-radius: 5px;
            background-color: #00bcd4;
            color: #fff;
            cursor: pointer;
        }
        .pagination button.disabled {
            background-color: #555;
            cursor: not-allowed;
        }
    </style>
</head>
<body>
    <h1>PLC Error Logs</h1>
    <div class="charts">
        <canvas id="lineChart" width="300" height="150"></canvas>
        <canvas id="errorChart" width="300" height="150"></canvas>
    </div>
    <input type="text" id="search" placeholder="라인명, 에러번호, 에러값으로 검색">
    <table>
        <thead>
            <tr>
                <th>라인명</th>
                <th>에러번호</th>
                <th>에러값</th>
                <th>시간</th>
            </tr>
        </thead>
        <tbody id="tableBody">
            {% for row in data %}
                <tr>
                    <td>{{ row['라인명'] }}</td>
                    <td>{{ row['에러번호'] }}</td>
                    <td>{{ row['에러값'] }}</td>
                    <td>{{ row['시간'] }}</td>
                </tr>
            {% endfor %}
        </tbody>
    </table>
    <div class="pagination">
        <button {% if current_page == 1 %}class="disabled"{% endif %} onclick="changePage({{ current_page - 1 }})">이전</button>
        <button {% if current_page == total_pages %}class="disabled"{% endif %} onclick="changePage({{ current_page + 1 }})">다음</button>
    </div>

    <script>
        const lineData = {{ line_counts | tojson }};
        const errorData = {{ error_counts | tojson }};
        const ctxLine = document.getElementById('lineChart').getContext('2d');
        const ctxError = document.getElementById('errorChart').getContext('2d');

        // 라인명별 발생수 차트
        new Chart(ctxLine, {
            type: 'bar',
            data: {
                labels: lineData.map(d => d['라인명']),
                datasets: [{
                    label: '라인별 발생수',
                    data: lineData.map(d => d['발생수']),
                    backgroundColor: '#007acc',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                }
            }
        });

        // 에러번호별 발생수 차트
        new Chart(ctxError, {
            type: 'bar',
            data: {
                labels: errorData.map(d => d['에러번호']),
                datasets: [{
                    label: '에러번호별 발생수',
                    data: errorData.map(d => d['발생수']),
                    backgroundColor: '#ff5722',
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false }
                }
            }
        });

        // 검색 기능
        $('#search').on('input', function () {
            const value = $(this).val();
            filterTable(value, value, value);
        });

        function changePage(page) {
            window.location.href = `/PLCErr?page=${page}`;
        }

        function filterTable(line, error, value) {
            $.ajax({
                url: '/PLCErr/filter',
                type: 'POST',
                contentType: 'application/json',
                data: JSON.stringify({ line, error, value }),
                success: function (data) {
                    const tableBody = $('#tableBody');
                    tableBody.empty();
                    data.forEach(row => {
                        tableBody.append(`
                            <tr>
                                <td>${row['라인명']}</td>
                                <td>${row['에러번호']}</td>
                                <td>${row['에러값']}</td>
                                <td>${row['시간']}</td>
                            </tr>
                        `);
                    });
                }
            });
        }
    </script>
</body>
</html>
주요 변경 사항
Chart.js와 jQuery 로컬 사용:

static/js/Chart.min.js와 static/js/jquery.min.js를 로컬에서 로드하여 인터넷 없이 동작 가능.
데이터는 여전히 DB에서 가져옴:

MSSQL에서 데이터를 조회(View_PLCErrjoin).
검색 및 필터링:
