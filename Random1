using System;
using System.Collections.Concurrent; // 병렬 처리를 위한 스레드 안전 컬렉션
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;       // 병렬 처리 (TPL)
using System.Windows.Forms;         // ListBox 사용 예시 (UI 프레임워크에 맞게 변경 필요)

public static class FolderFinderPro // static 클래스로 변경하여 인스턴스화 없이 사용
{
    // ??-? 패턴 정규식 (이전과 동일)
    private static readonly Regex PatternRegex = new Regex(@"^..-.$");

    /// <summary>
    /// 지정된 규칙에 따라 폴더 또는 파일을 초고속 병렬 검색합니다.
    /// .bom 파일이 여러 개일 경우 가장 최근 수정된 파일을 선택합니다.
    /// </summary>
    /// <param name="startPath">검색을 시작할 최상위 폴더 경로 (예: "C:\path\to\smd-pgm-server")</param>
    /// <returns>찾은 ??-? 폴더 또는 가장 최근 .bom 파일의 전체 경로 리스트 (비동기 작업)</returns>
    public static async Task<List<string>> FindTargetsParallelAsync(string startPath)
    {
        // 스레드 안전한 결과 저장 컬렉션
        var results = new ConcurrentBag<string>();

        // 1. 시작 경로 유효성 검사
        if (!Directory.Exists(startPath))
        {
            Console.WriteLine($"오류: 시작 경로를 찾을 수 없습니다 - {startPath}");
            return results.ToList(); // 빈 리스트 반환
        }

        // 2. PPP 깊이까지의 폴더 경로들을 먼저 순차적으로 수집 (이 부분은 상대적으로 빠름)
        List<string> pppDirectories = FindPppLevelDirectories(startPath);

        // 3. 수집된 PPP 폴더들을 병렬로 처리
        await Task.Run(() => // CPU 바운드 작업처럼 보이지만 실제로는 I/O 바운드이므로 Task.Run으로 스레드 풀에 위임
        {
            Parallel.ForEach(pppDirectories, pppDir =>
            {
                try // 개별 병렬 작업 내에서 예외 처리
                {
                    // 4. PPP 깊이 폴더 기준으로 하위 탐색 (재귀)
                    string foundPatternFolder = FindPatternFolderRecursive(pppDir);

                    if (!string.IsNullOrEmpty(foundPatternFolder))
                    {
                        // 5. ??-? 패턴 폴더를 찾았으면 결과에 추가 (ConcurrentBag은 스레드 안전)
                        results.Add(foundPatternFolder);
                        // Console.WriteLine($"패턴 폴더 찾음 (병렬): {foundPatternFolder}");
                    }
                    else
                    {
                        // 6. ??-? 패턴 폴더를 못 찾았으면 PPP 깊이 폴더에서 .bom 파일 찾기
                        try
                        {
                            var bomFiles = Directory.EnumerateFiles(pppDir, "*.bom")
                                                    .Select(f => new FileInfo(f)) // FileInfo로 변환하여 속성 접근
                                                    .OrderByDescending(fi => fi.LastWriteTime) // 최신 수정 순으로 정렬
                                                    .FirstOrDefault(); // 가장 최신 파일 하나만 가져오기

                            if (bomFiles != null)
                            {
                                // 가장 최신 .bom 파일 경로 추가
                                results.Add(bomFiles.FullName);
                                // Console.WriteLine($".bom 파일 찾음 (병렬, 최신): {bomFiles.FullName}");
                            }
                        }
                        catch (UnauthorizedAccessException)
                        {
                            // 접근 권한 없는 경우 해당 PPP 폴더의 .bom 검색 건너뜀
                            Console.WriteLine($"경고 (병렬): {pppDir} 내 파일 접근 권한 없음");
                        }
                        catch (IOException ex)
                        {
                             Console.WriteLine($"경고 (병렬): {pppDir} 내 파일 검색 중 IO 오류 - {ex.Message}");
                        }
                    }
                }
                catch (Exception ex) // 병렬 작업 중 예상치 못한 오류 처리
                {
                    Console.WriteLine($"오류 (병렬 작업 중): {pppDir} 처리 중 오류 - {ex.Message}");
                }
            });
        });

        // 7. 최종 결과를 List<string>으로 변환하여 반환
        return results.ToList();
    }

    /// <summary>
    /// 시작 경로로부터 PPP 깊이(Level 3)에 해당하는 모든 폴더 경로를 찾습니다.
    /// </summary>
    private static List<string> FindPppLevelDirectories(string startPath)
    {
        var pppDirs = new List<string>();
        try
        {
            // Level 1
            foreach (var level1Dir in Directory.EnumerateDirectories(startPath))
            {
                try
                {
                    // Level 2 (SM- 포함 필터링)
                    var level2Dirs = Directory.EnumerateDirectories(level1Dir)
                                              .Where(d => Path.GetFileName(d).Contains("SM-"));

                    foreach (var level2Dir in level2Dirs)
                    {
                        try
                        {
                            // Level 3 (PPP) - 모든 하위 폴더 추가
                            pppDirs.AddRange(Directory.EnumerateDirectories(level2Dir));
                        }
                        catch (UnauthorizedAccessException) { /* 접근 불가 폴더 건너뜀 */ }
                        catch (IOException ex) { Console.WriteLine($"경고: {level2Dir} 탐색 중 IO 오류 - {ex.Message}"); }
                    }
                }
                catch (UnauthorizedAccessException) { /* 접근 불가 폴더 건너뜀 */ }
                catch (IOException ex) { Console.WriteLine($"경고: {level1Dir} 탐색 중 IO 오류 - {ex.Message}"); }
            }
        }
        catch (UnauthorizedAccessException ex)
        {
            Console.WriteLine($"오류: 시작 경로 접근 권한 없음 - {ex.Message}");
        }
        catch (Exception ex) // 기타 예외
        {
             Console.WriteLine($"오류: PPP 경로 수집 중 오류 - {ex.Message}");
        }
        return pppDirs;
    }


    /// <summary>
    /// 지정된 폴더와 그 모든 하위 폴더에서 ??-? 패턴의 폴더를 재귀적으로 찾습니다.
    /// 첫 번째로 발견된 폴더의 경로를 반환합니다. (이전과 동일, 병렬 처리 X)
    /// </summary>
    /// <param name="directoryToSearch">검색을 시작할 폴더</param>
    /// <returns>찾은 ??-? 패턴 폴더의 전체 경로, 찾지 못하면 null</returns>
    private static string FindPatternFolderRecursive(string directoryToSearch)
    {
        // 이 함수 자체는 병렬로 돌지 않음. 각 PPP 경로에 대해 독립적으로 호출됨.
        try
        {
            // 1. 현재 폴더의 직접적인 하위 폴더 중 패턴 매칭 확인
            // GetDirectories 대신 EnumerateDirectories 사용 (메모리 효율적)
            foreach (string subDir in Directory.EnumerateDirectories(directoryToSearch))
            {
                string dirName = Path.GetFileName(subDir);
                if (PatternRegex.IsMatch(dirName))
                {
                    return subDir; // 첫 번째 매칭 발견 시 즉시 반환
                }
            }

            // 2. 현재 레벨에서 못 찾으면 하위 폴더 재귀 탐색
            foreach (string subDir in Directory.EnumerateDirectories(directoryToSearch))
            {
                string found = FindPatternFolderRecursive(subDir);
                if (!string.IsNullOrEmpty(found))
                {
                    return found; // 하위에서 찾으면 결과 전파
                }
            }
        }
        catch (UnauthorizedAccessException)
        {
            // 접근 권한 없는 폴더는 조용히 건너뜀 (콘솔 출력 최소화)
        }
        catch (IOException)
        {
             // IO 오류 발생 시 해당 경로 탐색 중단 (콘솔 출력 최소화)
        }
        catch (Exception) // 기타 예상치 못한 오류도 조용히 처리하여 전체 중단 방지
        {
            // Console.WriteLine($"경고: 재귀 탐색 중 오류 ({directoryToSearch})"); // 디버깅 시 주석 해제
        }

        return null; // 현재 및 하위에서 모두 못 찾음
    }

    // --- UI 연동 예시 (Windows Forms 기준) ---
    // 실제 사용 시에는 UI 프레임워크(WPF, MAUI 등)에 맞게 수정해야 합니다.
    public static async void SearchAndDisplay(string startPath, ListBox targetListBox)
    {
        if (targetListBox == null) return;

        targetListBox.Items.Clear();
        targetListBox.Items.Add("검색 중... (병렬 처리)");
        targetListBox.Enabled = false; // 검색 중 UI 비활성화

        try
        {
            // 비동기적으로 병렬 검색 실행 및 결과 기다리기
            List<string> results = await FindTargetsParallelAsync(startPath);

            targetListBox.Items.Clear(); // "검색 중..." 메시지 제거

            if (results.Any()) // 결과가 있는지 확인 (Linq 사용)
            {
                // ListBox에 효율적으로 항목 추가 (AddRange 사용)
                targetListBox.Items.AddRange(results.ToArray());
            }
            else
            {
                targetListBox.Items.Add("지정된 조건에 맞는 항목을 찾지 못했습니다.");
            }
        }
        catch (Exception ex) // 전체 프로세스에서 발생할 수 있는 예외 처리
        {
             targetListBox.Items.Clear();
             targetListBox.Items.Add($"오류 발생: {ex.Message}");
             MessageBox.Show($"검색 중 심각한 오류 발생: {ex.Message}", "오류", MessageBoxButtons.OK, MessageBoxIcon.Error);
        }
        finally
        {
            targetListBox.Enabled = true; // 검색 완료 후 UI 활성화
        }
    }
}

/*
// --- Windows Forms 애플리케이션에서 사용 예시 ---
public partial class MainForm : Form
{
    private ListBox listBoxResults; // 디자인 모드에서 ListBox 추가 필요

    public MainForm()
    {
        InitializeComponent(); // 디자이너 코드 실행
        InitializeListBox();   // ListBox 초기화 (코드에서 생성 시)
    }

    // 예시: 코드에서 ListBox 동적 생성
    private void InitializeListBox()
    {
        listBoxResults = new ListBox
        {
            Dock = DockStyle.Fill // 폼 채우도록 설정
        };
        this.Controls.Add(listBoxResults);
    }

    // 검색 버튼 클릭 이벤트 핸들러 (디자인 모드에서 버튼 추가 및 이벤트 연결 필요)
    private async void buttonSearch_Click(object sender, EventArgs e)
    {
        string rootPath = @"C:\temp\smd-pgm-server"; // 실제 경로로 변경

        // 테스트 구조 필요 시 생성 (실제 사용 시에는 주석 처리)
        // CreateTestStructure(rootPath);

        // 비동기 검색 및 결과 표시 함수 호출
        await FolderFinderPro.SearchAndDisplay(rootPath, listBoxResults);

        // 테스트 구조 사용 시 삭제 (실제 사용 시에는 주석 처리)
        // DeleteTestStructure(rootPath);
    }

    // 테스트 구조 생성/삭제 함수 (이전 코드와 동일)
    // private static void CreateTestStructure(string root) { ... }
    // private static void DeleteTestStructure(string root) { ... }
}
*/
주요 변경 및 개선 사항:

병렬 처리 (Parallel.ForEach):

FindPppLevelDirectories 함수를 추가하여 검색 대상이 되는 PPP 깊이(Level 3) 폴더들의 목록을 먼저 효율적으로 수집합니다.
Parallel.ForEach를 사용하여 수집된 PPP 폴더 목록을 병렬로 처리합니다. 각 PPP 폴더에 대한 검색(패턴 폴더 찾기 또는 .bom 파일 찾기)이 별도의 스레드에서 동시에 실행될 수 있어 I/O 작업이 많은 환경에서 성능 향상을 기대할 수 있습니다.
스레드 안전성 (ConcurrentBag):

병렬 처리 중 여러 스레드가 동시에 결과 목록에 접근하므로, 일반 List<string> 대신 스레드에 안전한 System.Collections.Concurrent.ConcurrentBag<string>을 사용하여 결과를 수집합니다. ConcurrentBag은 순서가 중요하지 않은 항목 추가에 적합합니다.
최신 .bom 파일 선택:

.bom 파일을 찾을 때 Directory.EnumerateFiles를 사용하여 파일을 열거합니다.
LINQ의 Select를 사용하여 각 파일 경로를 FileInfo 객체로 변환합니다.
OrderByDescending(fi => fi.LastWriteTime)를 사용하여 파일을 마지막 수정 시간을 기준으로 내림차순(최신순)으로 정렬합니다.
FirstOrDefault()를 사용하여 정렬된 목록에서 가장 첫 번째 항목(즉, 가장 최신 .bom 파일)을 가져옵니다. 파일이 없으면 null이 반환됩니다.
비동기 처리 (async/await, Task.Run):

FindTargetsParallelAsync 메서드를 async Task<List<string>>으로 선언하여 비동기 메서드로 만듭니다.
Parallel.ForEach를 포함한 CPU 집약적 또는 I/O 집약적 작업을 await Task.Run(...)으로 감싸서 UI 스레드가 차단되지 않도록 백그라운드 스레드 풀에서 실행합니다. 이렇게 하면 검색 중에도 애플리케이션 UI가 멈추지 않고 반응성을 유지합니다.
UI 연동 예시(SearchAndDisplay)에서도 await를 사용하여 비동기 작업 완료를 기다립니다.
효율성 개선 (EnumerateDirectories, EnumerateFiles):

Directory.GetDirectories 대신 Directory.EnumerateDirectories를, Directory.GetFiles 대신 Directory.EnumerateFiles를 사용하여 폴더/파일 목록을 한 번에 메모리에 모두 로드하지 않고 필요할 때마다 열거하므로, 매우 많은 수의 폴더/파일이 있는 경우 메모리 사용량이 줄어듭니다.
오류 처리 강화:

Parallel.ForEach 루프 내부와 각 단계별 디렉토리 탐색에서 try-catch 블록을 사용하여 개별 작업 실패(예: 접근 권한 없음)가 전체 병렬 처리를 중단시키지 않도록 합니다. 오류 발생 시 콘솔에 경고 메시지를 출력합니다.
SearchAndDisplay 메서드에서도 try-catch를 사용하여 최종 UI 업데이트 중 발생할 수 있는 예외를 처리합니다.
UI 연동 예시 (SearchAndDisplay, ListBox):

결과를 ListBox에 표시하는 SearchAndDisplay 도우미 메서드를 추가했습니다. (Windows Forms 기준)
이 메서드는 비동기로 작동하며, 검색 시작 시 ListBox에 "검색 중..." 메시지를 표시하고 UI를 비활성화했다가, 검색 완료 후 결과를 채우고 UI를 다시 활성화합니다.
results.Any() 및 listBox.Items.AddRange()를 사용하여 결과를 효율적으로 확인하고 ListBox에 추가합니다.
사용 방법:

FolderFinderPro 클래스를 프로젝트에 추가합니다.
UI가 있는 애플리케이션(예: Windows Forms, WPF, MAUI)에서 ListBox 컨트롤을 준비합니다.
검색을 시작하는 이벤트 핸들러(예: 버튼 클릭) 내에서 FolderFinderPro.SearchAndDisplay 메서드를 await와 함께 호출합니다. 이때 startPath와 대상 ListBox 컨트롤을 인자로 전달합니다.
startPath는 실제 smd-pgm-server 폴더의 경로로 설정해야 합니다.