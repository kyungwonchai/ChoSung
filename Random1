gnalR을 사용하여 에이전트가 살아있음을 표시하고, 에이전트가 트레이 아이콘으로 이동할 수 있도록 WPF 응용 프로그램을 수정하겠습니다.

아래는 SignalR 클라이언트를 사용하여 서버에 1분마다 상태를 전송하는 클래스를 추가하고, 트레이 아이콘 기능을 추가하는 코드입니다.

SignalRClient.cs
먼저, SignalR 클라이언트를 추가합니다.

csharp
코드 복사
using Microsoft.AspNetCore.SignalR.Client;
using System;
using System.Threading.Tasks;

public class SignalRClient
{
    private HubConnection connection;

    public SignalRClient(string hubUrl)
    {
        connection = new HubConnectionBuilder()
            .WithUrl(hubUrl)
            .Build();
    }

    public async Task StartAsync()
    {
        await connection.StartAsync();
    }

    public async Task SendStatusAsync(string status)
    {
        if (connection.State == HubConnectionState.Connected)
        {
            await connection.InvokeAsync("SendStatus", status);
        }
    }

    public async Task StopAsync()
    {
        await connection.StopAsync();
    }
}
MainWindow.xaml.cs
다음으로, MainWindow.xaml.cs를 수정하여 SignalR 클라이언트를 사용하고 트레이 아이콘 기능을 추가합니다.

csharp
코드 복사
using System;
using System.Data;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using System.Windows.Forms;
using Application = System.Windows.Application;

namespace DataSyncApp
{
    public partial class MainWindow : Window
    {
        private DataSync dataSync;
        private EsdCheckMiddleSync esdCheckMiddleSync;
        private SignalRClient signalRClient;
        private NotifyIcon notifyIcon;

        public MainWindow()
        {
            InitializeComponent();
            dataSync = new DataSync();
            esdCheckMiddleSync = new EsdCheckMiddleSync();
            signalRClient = new SignalRClient("https://your-signalr-server-url/hub");

            Task.Run(() => dataSync.StartDataSyncAsync(LogAction1));
            Task.Run(() => esdCheckMiddleSync.StartDataSyncAsync(LogAction2));
            Task.Run(() => StartSignalRClientAsync());

            SetupTrayIcon();
        }

        private async Task StartSignalRClientAsync()
        {
            await signalRClient.StartAsync();
            while (true)
            {
                await signalRClient.SendStatusAsync("Agent is alive");
                await Task.Delay(TimeSpan.FromMinutes(1));
            }
        }

        private async void LoadDataButton_Click(object sender, RoutedEventArgs e)
        {
            await LoadGridControlAsync();
        }

        private async Task LoadGridControlAsync()
        {
            DataTable targetData = await dataSync.GetTargetDataAsync();

            var unmatchedRows = from target in targetData.AsEnumerable()
                                where string.IsNullOrEmpty(target.Field<string>("USER_CARD_ID"))
                                select new
                                {
                                    USER_NAME = target.Field<string>("USER_NAME"),
                                    USER_CARD_ID = "Not Matched",
                                    E_NUM = target.Field<string>("E_NUM"),
                                    PROCESS = target.Field<string>("PROCESS"),
                                    GROUP_NAME = target.Field<string>("GROUP_NAME")
                                };

            dataGrid.ItemsSource = unmatchedRows.ToList();

            foreach (var item in dataGrid.Items)
            {
                DataGridRow row = (DataGridRow)dataGrid.ItemContainerGenerator.ContainerFromItem(item);
                if (row != null && ((dynamic)row.Item).USER_CARD_ID == "Not Matched")
                {
                    row.Background = new SolidColorBrush(Colors.Red);
                }
            }
        }

        private void DataGrid_CellEditEnding(object sender, DataGridCellEditEndingEventArgs e)
        {
            if (e.Column.Header.ToString() == "USER_CARD_ID")
            {
                string userName = ((TextBox)e.EditingElement).Text;
                string userCardId = ((TextBox)e.EditingElement).Text;

                // Handle manual input for USER_CARD_ID
                // For example, you might update a local list or another table in the database.
            }
        }

        private void LogAction1(string message)
        {
            Dispatcher.Invoke(() =>
            {
                if (logListBox1.Items.Count >= 500)
                {
                    logListBox1.Items.Clear();
                }
                logListBox1.Items.Add(message);
            });
        }

        private void LogAction2(string message)
        {
            Dispatcher.Invoke(() =>
            {
                if (logListBox2.Items.Count >= 500)
                {
                    logListBox2.Items.Clear();
                }
                logListBox2.Items.Add(message);
            });
        }

        private void SetupTrayIcon()
        {
            notifyIcon = new NotifyIcon();
            notifyIcon.Icon = new System.Drawing.Icon("path_to_your_icon.ico");
            notifyIcon.Visible = true;
            notifyIcon.DoubleClick += (s, e) => ShowMainWindow();

            var contextMenu = new ContextMenuStrip();
            contextMenu.Items.Add("Exit", null, (s, e) => ExitApplication());

            notifyIcon.ContextMenuStrip = contextMenu;
        }

        private void ShowMainWindow()
        {
            this.Show();
            this.WindowState = WindowState.Normal;
        }

        private void ExitApplication()
        {
            notifyIcon.Visible = false;
            Application.Current.Shutdown();
        }

        protected override void OnStateChanged(EventArgs e)
        {
            if (WindowState == WindowState.Minimized)
            {
                this.Hide();
                notifyIcon.Visible = true;
            }
            base.OnStateChanged(e);
        }

        protected override void OnClosing(System.ComponentModel.CancelEventArgs e)
        {
            e.Cancel = true; // Cancel the close and just hide the window
            this.Hide();
            notifyIcon.Visible = true;
        }
    }
}
이 코드는 다음과 같은 기능을 추가합니다:

SignalR 클라이언트를 통해 에이전트의 상태를 1분마다 서버에 전송합니다.
트레이 아이콘을 추가하고, 에이전트가 최소화될 때 트레이 아이콘으로 이동합니다.
"Exit" 메뉴 항목을 통해 트레이 아이콘에서 애플리케이션을 종료할 수 있습니다.
이제 트레이 아이콘을 사용할 수 있으며, 에이전트의 상태가 1분마다 서버로 전송됩