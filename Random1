실히 개념을 이해하는 것이 중요합니다. 지금 프로젝트에서 로그를 처리하는 방식에 대한 개념을 정리하고, 각 로그의 출처와 처리 방법에 대해 설명드리겠습니다.

프로젝트의 로그 처리 개념
서비스로부터의 로그 (네임드 파이프 사용):

서비스 (RouterMiddleACRService)는 파일 감시와 같은 작업을 수행하며 발생하는 로그를 네임드 파이프를 통해 메인 애플리케이션에 전송합니다.
네임드 파이프는 프로세스 간 통신(IPC) 방법 중 하나로, 서비스와 메인 애플리케이션 간에 텍스트 데이터를 전송하는 데 사용됩니다.
메인 애플리케이션은 네임드 파이프 클라이언트를 사용하여 서비스로부터 로그를 수신합니다.
서비스 제어와 관련된 로그 (ServiceControllerHelper 클래스 사용):

ServiceControllerHelper 클래스는 Windows 서비스의 상태를 제어하고 모니터링하는 기능을 담당합니다.
이 클래스에서 발생하는 로그는 서비스의 상태를 주기적으로 체크하면서 로그로 기록되며, 이 로그는 메인 애플리케이션의 ViewModel로 이벤트를 통해 전송됩니다.
이러한 이벤트를 통해 ViewModel은 로그 메시지를 UI에 추가합니다.
다른 클래스에서 오는 로그:

예를 들어, 파일 처리와 관련된 로그 또는 시스템 관련 로그 등도 있을 수 있습니다.
각 로그를 별도의 이벤트로 처리하여 ViewModel에 전송할 수 있습니다. 이는 로그가 발생하는 위치와 그 처리 방법을 더 명확히 하고, UI에서 이를 구분하여 표시할 수 있도록 합니다.
코드 이해
이제 각각의 부분이 어떻게 연결되고 작동하는지 설명하겠습니다.

1. 서비스로부터의 로그 (네임드 파이프 사용)
서비스는 네임드 파이프 서버를 통해 로그 메시지를 보냅니다.
메인 애플리케이션의 MainWindow는 네임드 파이프 클라이언트를 사용하여 이 로그를 수신하고, ViewModel에 로그 메시지를 전달합니다.
예시: 서비스 로그 전송 (서비스 코드)
서비스는 파일 감시 또는 기타 작업 중에 로그를 네임드 파이프로 보냅니다.

csharp
코드 복사
// 서비스 코드 내에서 네임드 파이프를 통해 로그를 전송하는 예시
private void SendLogToUI(string message)
{
    using (var pipeServer = new NamedPipeServerStream("RouterMiddleACRLogPipe", PipeDirection.Out))
    {
        pipeServer.WaitForConnection();
        using (var writer = new StreamWriter(pipeServer))
        {
            writer.WriteLine(message);
        }
    }
}
예시: 메인 애플리케이션에서 로그 수신 (MainWindow.xaml.cs)
메인 애플리케이션은 네임드 파이프 클라이언트를 사용하여 서비스로부터의 로그를 수신합니다.

csharp
코드 복사
// 메인 윈도우 초기화에서 로그 수신을 시작
public MainWindow()
{
    InitializeComponent();
    StartListeningToServiceLogs();
}

// 네임드 파이프 클라이언트를 통해 서비스 로그 수신
private void StartListeningToServiceLogs()
{
    Task.Run(() =>
    {
        using (var pipeClient = new NamedPipeClientStream(".", "RouterMiddleACRLogPipe", PipeDirection.In))
        {
            pipeClient.Connect();
            using (var reader = new StreamReader(pipeClient))
            {
                while (!reader.EndOfStream)
                {
                    string message = reader.ReadLine();
                    Dispatcher.Invoke(() => ViewModel.LogMessage(message, LogType.Service));
                }
            }
        }
    });
}
2. 서비스 제어와 관련된 로그 (ServiceControllerHelper 사용)
ServiceControllerHelper 클래스는 이벤트를 통해 서비스 상태를 확인하고 변경 사항을 로그로 기록합니다.

예시: ServiceControllerHelper에서 로그 전송
ServiceControllerHelper는 이벤트를 통해 로그 메시지를 ViewModel로 전송합니다.

csharp
코드 복사
public class ServiceControllerHelper
{
    public event Action<string> OnLogMessage; // 로그 메시지를 전달하는 이벤트

    public void CheckServiceStatus()
    {
        try
        {
            _serviceController.Refresh();
            string status = _serviceController.Status.ToString();
            OnLogMessage?.Invoke($"서비스 상태: {status}"); // 로그 이벤트 트리거

            if (_serviceController.Status == ServiceControllerStatus.Stopped)
            {
                OnLogMessage?.Invoke("서비스가 중지되었습니다. 재시작합니다...");
                RestartService();
            }
        }
        catch (Exception ex)
        {
            OnLogMessage?.Invoke($"서비스 상태 확인 중 오류 발생: {ex.Message}");
        }
    }
}
예시: MainViewModel에서 이벤트 처리
MainViewModel은 ServiceControllerHelper에서 발생하는 로그 이벤트를 처리하고, 로그를 UI에 추가합니다.

csharp
코드 복사
public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<string> ServiceLogs { get; } = new ObservableCollection<string>();

    public MainViewModel()
    {
        var serviceControllerHelper = new ServiceControllerHelper();
        serviceControllerHelper.OnLogMessage += message => LogMessage(message, LogType.Service); // 로그 이벤트 핸들러 등록
    }

    private void LogMessage(string message, LogType logType)
    {
        App.Current.Dispatcher.Invoke(() =>
        {
            if (logType == LogType.Service)
            {
                ServiceLogs.Add(message);
            }
            // 다른 로그 유형에 따라 다른 컬렉션에 추가 가능
        });
    }
}
3. 로그 이벤트 처리 개념
모든 로그는 ViewModel에서 관리되며, 이벤트를 통해 적절한 로그 컬렉션에 추가됩니다. 이 방식으로, 로그 발생 위치에 상관없이 모든 로그는 중앙에서 관리되고, 필요한 경우 UI에 업데이트됩니다.

로그 이벤트 처리 흐름
로그 발생: 로그는 네임드 파이프나 직접 호출을 통해 발생합니다.
로그 전달: 발생한 로그는 이벤트를 통해 ViewModel로 전달됩니다.
UI 업데이트: ViewModel은 로그를 수신하고, 적절한 컬렉션에 추가하여 UI를 업데이트합니다.
요약
네임드 파이프는 서비스와 메인 애플리케이션 간의 로그 메시지 전송에 사용됩니다.
**ServiceControllerHelper**는 서비스 상태 변경 및 제어와 관련된 로그를 관리하며, 이벤트를 통해 로그 메시지를 ViewModel로 전달합니다.
**MainViewModel**은 모든 로그 메시지를 수신하고, 이를 UI에 표시하는 역할을 합니다.
이 구조를 통해 모든 로그가 적절하게 수집되고 UI에 표시될 수 있습니다.