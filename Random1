전부 반영한 MSSQL 2014 쿼리 전체와 함께 아주 상세한 설명도 포함해서 줄게.

1. 요구사항 핵심 요약 (최종 정리)
테이블 구조
테이블 이름: ExcelData

주요 컬럼:

id1, line1, model1, type1, ecn1, edition1, time1

ACT1_1 ~ ACT1_8 (float)

ACT2BEST1_1 ~ ACT2BEST1_8 (float)

의미
10분 단위 주기로 CT(CycleTime) 16개 값이 측정됨

CT는 생산속도를 의미하며, 0은 잘못된 값(미측정, 정지 등) 으로 간주 → 제외해야 함

line1, model1, type1, ecn1, edition1 이 고유 키 역할 (모델 변경 시만 새로 생김)

목표
최근 5시간 데이터만 분석

각 고유 키 + time1 단위마다:

ACT1_1~8 중에서 이상치(1Q~3Q) 제거 후 최대값

ACT2BEST1_1~8 중에서 이상치(1Q~3Q) 제거 후 최대값

위에서 계산된 두 값의 차이 (ACT1_MAX - ACT2BEST_MAX) 를 DiffCT 로 저장

고유 키 조합별로 DiffCT가 가장 작은 time1 하나만 조회

2. 최종 MSSQL 2014 쿼리 (전체 주석 포함)
sql
코드 복사
-- 1. 최근 5시간 이내의 원본 데이터 필터링
WITH RawData AS (
    SELECT
        id1, line1, model1, type1, ecn1, edition1, time1,
        ACT1_1, ACT1_2, ACT1_3, ACT1_4,
        ACT1_5, ACT1_6, ACT1_7, ACT1_8,
        ACT2BEST1_1, ACT2BEST1_2, ACT2BEST1_3, ACT2BEST1_4,
        ACT2BEST1_5, ACT2BEST1_6, ACT2BEST1_7, ACT2BEST1_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- 2. UNPIVOT: 16개 CT 컬럼을 행(Row) 형태로 전개
Unpivoted AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT1_1, ACT1_2, ACT1_3, ACT1_4,
            ACT1_5, ACT1_6, ACT1_7, ACT1_8,
            ACT2BEST1_1, ACT2BEST1_2, ACT2BEST1_3, ACT2BEST1_4,
            ACT2BEST1_5, ACT2BEST1_6, ACT2BEST1_7, ACT2BEST1_8
        )
    ) AS u
    WHERE Value > 0  -- 0은 잘못된 측정값이므로 제외
),

-- 3. 분위수 계산: 각 컬럼별 Q1, Q3 구함
WithQuantiles AS (
    SELECT
        ColName,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3,
        line1, model1, type1, ecn1, edition1, time1, Value
    FROM Unpivoted
),

-- 4. 이상치 제거: Q1 ~ Q3 범위 내 값만 유지
FilteredCT AS (
    SELECT *
    FROM WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

-- 5. 그룹 타입 부여: ACT1 / ACT2BEST 구분
WithGroup AS (
    SELECT *,
        CASE 
            WHEN ColName LIKE 'ACT1[_]%' THEN 'ACT1'
            WHEN ColName LIKE 'ACT2BEST1[_]%' THEN 'ACT2BEST'
        END AS GroupType
    FROM FilteredCT
),

-- 6. 각 Key + 시간(time1) 단위로 군별 최대값 계산
MaxPerRow AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(CASE WHEN GroupType = 'ACT1' THEN Value END) AS Max_ACT1,
        MAX(CASE WHEN GroupType = 'ACT2BEST' THEN Value END) AS Max_ACT2BEST
    FROM WithGroup
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- 7. 각 row마다 차이 계산 (DiffCT = ACT1_MAX - ACT2BEST_MAX)
WithDiff AS (
    SELECT *,
        (Max_ACT1 - Max_ACT2BEST) AS DiffCT
    FROM MaxPerRow
    WHERE Max_ACT1 IS NOT NULL AND Max_ACT2BEST IS NOT NULL  -- NULL 제거
),

-- 8. 고유 키별로 DiffCT가 가장 작은 1건만 선택
Ranked AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY line1, model1, type1, ecn1, edition1
            ORDER BY DiffCT ASC
        ) AS RN
    FROM WithDiff
)

-- 9. 최종 출력
SELECT
    line1, model1, type1, ecn1, edition1, time1,
    Max_ACT1, Max_ACT2BEST, DiffCT
FROM Ranked
WHERE RN = 1
ORDER BY line1, model1, type1, ecn1, edition1;
3. 결과 예시
line1	model1	type1	ecn1	edition1	time1	Max_ACT1	Max_ACT2BEST	DiffCT
SMD_12	ABC123	PKG1	E101	R1	2025-03-28 13:00	0.52	0.48	0.04
SMD_12	XYZ456	PKG2	E102	R2	2025-03-28 12:40	0.59	0.55	0.04
4. 추가 팁
DiffCT가 너무 큰 경우 경고 처리하려면 WHERE DiffCT > 0.1 같은 조건 추가 가능

상위 3개 시간대를 보고 싶다면 ROW_NUMBER() 대신 RANK()로 바꾸고 WHERE RN <= 3 등으로 조절

피벗 테이블처럼 가로 출력하고 싶다면 PIVOT도 가능