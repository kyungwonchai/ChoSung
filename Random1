아래는 MainViewModel과 ComPortManager 클래스의 각 줄에 상세한 주석을 추가한 수정된 코드입니다.

1. 수정된 MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager; // 시리얼 포트 관리를 위한 ComPortManager 객체
        private string _r520Status; // R520 상태를 저장하는 문자열
        private string _r521Status; // R521 상태를 저장하는 문자열

        public string R520Status
        {
            get => _r520Status; // R520 상태를 반환
            set
            {
                _r520Status = value; // R520 상태를 설정
                OnPropertyChanged(nameof(R520Status)); // 속성 변경 알림
            }
        }

        public string R521Status
        {
            get => _r521Status; // R521 상태를 반환
            set
            {
                _r521Status = value; // R521 상태를 설정
                OnPropertyChanged(nameof(R521Status)); // 속성 변경 알림
            }
        }

        // 1부터 4까지의 버튼 명령들을 저장하는 컬렉션
        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        // 명령 생성
        public ICommand SendTextBoxValueCommand { get; } // 텍스트박스 값을 PLC로 보내는 명령
        public ICommand ProcessDT2330Command { get; } // DT2330을 처리하는 명령

        public MainViewModel()
        {
            _comPortManager = new ComPortManager(); // ComPortManager 객체 생성
            _comPortManager.ConfigurePort("COM1"); // COM1 포트를 사용하도록 설정

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>(); // 버튼 명령 초기화
            InitializeCommands(); // 버튼 명령 초기화 메서드 호출

            // 명령 초기화
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value)); // 텍스트박스 값을 보내는 명령 초기화
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data()); // DT2330을 처리하는 명령 초기화

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync); // PLC 상태 업데이트 작업 시작
        }

        private void InitializeCommands()
        {
            // 1부터 4까지의 값을 가지는 버튼 명령 생성
            for (int i = 1; i <= 4; i++)
            {
                int value = i; // 현재 버튼 값
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC", // 버튼 텍스트
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value)))); // 버튼 명령
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            // Step 1: Write value to DT2300
            // DT2300에 값을 쓰기 위한 명령어 생성
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";

            // PLC로 데이터 전송 및 응답 받기
            string response = await _comPortManager.SendDataToPLCAsync(writeCommand);

            // Mewtocol 응답 확인
            if (!CheckMewtocolResponse(response))
            {
                LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}"); // 오류 로그 기록
                return; // 메서드 종료
            }

            LogMessage($"Sent {number} to DT2300, waiting for response..."); // 명령 전송 로그 기록

            // Step 2: Wait for 3 seconds
            await Task.Delay(3000); // 3초 대기

            // Step 3: Check if DT2330 has the correct value within 30 seconds
            bool success = false; // 작업 성공 여부 플래그
            DateTime startTime = DateTime.Now; // 작업 시작 시간 기록

            // 30초 동안 DT2330 값을 확인
            while ((DateTime.Now - startTime).TotalSeconds < 30)
            {
                // DT2330 값 읽기
                string dt2330Response = await _comPortManager.ReadFromPLCAsync("023300");

                // 기대한 값이 수신된 경우
                if (dt2330Response.Contains(number.ToString()))
                {
                    LogMessage($"Operation completed successfully. Value {number} correctly received from DT2330."); // 성공 로그 기록
                    success = true; // 성공 플래그 설정
                    await _comPortManager.ClearPLCValueAsync("023300"); // DT2330 값 초기화
                    break; // 루프 종료
                }
                // 다른 값이 쓰여진 경우
                else if (dt2330Response != "0000")
                {
                    LogMessage($"ERROR: Unexpected value {dt2330Response} found in DT2330. Expected {number}."); // 오류 로그 기록
                    break; // 루프 종료
                }

                await Task.Delay(1000); // 1초 대기 후 다시 확인
            }

            // 30초 내에 값이 수신되지 않은 경우
            if (!success)
            {
                LogMessage($"ERROR: Operation failed. Expected value {number} not received from DT2330 within 30 seconds."); // 오류 로그 기록
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            // 텍스트박스의 값을 정수로 변환 시도
            if (int.TryParse(value, out int intValue))
            {
                // DT2300에 값을 쓰기 위한 명령어 생성
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                
                // PLC로 데이터 전송 및 응답 받기
                string response = await _comPortManager.SendDataToPLCAsync(command);

                // Mewtocol 응답 확인
                if (!CheckMewtocolResponse(response))
                {
                    LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}"); // 오류 로그 기록
                    return; // 메서드 종료
                }

                LogMessage($"Sent {value} from TextBox to PLC"); // 명령 전송 로그 기록
            }
            else
            {
                LogMessage("Invalid value."); // 잘못된 값 로그 기록
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            // DT2330 값을 읽어옴
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value); // 값 처리
            await _comPortManager.ClearPLCValueAsync("023300"); // 값 초기화
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}"); // 처리 로그 기록
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                // R520과 R521의 상태를 PLC로부터 읽어옴
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                // 상태에 따라 UI를 업데이트
                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000); // 1초마다 상태 업데이트
            }
        }

        private void LogMessage(string message)
        {
            // 콘솔에 로그 메시지를 기록
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        private bool CheckMewtocolResponse(string response)
        {
            // Mewtocol의 기본 응답을 확인하여 올바른지 확인
            return response.Contains("%01"); // "%01"이 포함되어 있으면 올바른 응답
        }

        public event PropertyChangedEventHandler PropertyChanged; // 속성 변경 이벤트

        protected virtual void OnPropertyChanged(string propertyName)
        {
            // 속성 변경 이벤트를 발생시킴
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
2. 수정된 ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class ComPortManager
    {
        private SerialPort _port; // 시리얼 포트 객체

        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits); // 시리얼 포트 설정
        }

        public async Task<string> SendDataToPLCAsync(string command)
        {
            if (_port == null || !_port.IsOpen) // 포트가 열려있는지 확인
            {
                throw new InvalidOperationException("The serial port is not open."); // 포트가 열려있지 않으면 예외 발생
            }

            try
            {
                byte[] commandBytes = Encoding.ASCII.GetBytes(command); // 명령어를 ASCII 바이트 배열로 변환
                _port.Write(commandBytes, 0, commandBytes.Length); // 명령어를 시리얼 포트를 통해 전송

                // PLC의 응답을 비동기적으로 읽음
                string response = await Task.Run(() => _port.ReadLine());
                return response; // 응답 반환
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending data to PLC: {ex.Message}"); // 오류 로그 기록
                return string.Empty; // 빈 문자열 반환
            }
        }

        public async Task<string> ReadFromPLCAsync(string address)
        {
            if (_port == null || !_port.IsOpen) // 포트가 열려있는지 확인
            {
                throw new InvalidOperationException("The serial port is not open."); // 포트가 열려있지 않으면 예외 발생
            }

            try
            {
                string command = $"%01#RDD{address}**\r"; // PLC로부터 데이터를 읽어오기 위한 명령어 생성
                byte[] commandBytes = Encoding.ASCII.GetBytes(command); // 명령어를 ASCII 바이트 배열로 변환
                _port.Write(commandBytes, 0, commandBytes.Length); // 명령어를 시리얼 포트를 통해 전송
                
                var response = await Task.Run(() => _port.ReadLine()); // 응답을 비동기적으로 읽음
                return response; // 응답 반환
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading from PLC: {ex.Message}"); // 오류 로그 기록
                return string.Empty; // 빈 문자열 반환
            }
        }

        public async Task ClearPLCValueAsync(string address)
        {
            if (_port == null || !_port.IsOpen) // 포트가 열려있는지 확인
            {
                throw new InvalidOperationException("The serial port is not open."); // 포트가 열려있지 않으면 예외 발생
            }

            try
            {
                string command = $"%01#WDD{address}0000**\r"; // PLC의 값을 초기화하기 위한 명령어 생성
                byte[] commandBytes = Encoding.ASCII.GetBytes(command); // 명령어를 ASCII 바이트 배열로 변환
                await Task.Run(() => _port.Write(commandBytes, 0, commandBytes.Length)); // 명령어를 비동기적으로 시리얼 포트를 통해 전송
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error clearing PLC value: {ex.Message}"); // 오류 로그 기록
            }
        }

        public void OpenPort()
        {
            if (_port != null && !_port.IsOpen) // 포트가 설정되어 있고 열려있지 않은 경우
            {
                _port.Open(); // 포트 열기
            }
        }

        public void ClosePort()
        {
            if (_port != null && _port.IsOpen) // 포트가 설정되어 있고 열려있는 경우
            {
                _port.Close(); // 포트 닫기
            }
        }
    }
}
요약 설명
PLC로 데이터 전송 및 응답 확인 (SendDataToPLCAsync 메서드):

PLC로 데이터를 전송하고 응답을 비동기적으로 읽어오는 메서드입니다.
응답을 확인하여 Mewtocol의 기본 응답이 올바르게 수신되었는지 확인합니다.
DT2330 값 확인 및 초기화 (WriteToPLCAndCheckResponse 메서드):

DT2300에 값을 쓴 후, 3초 뒤부터 최대 30초 동안 DT2330의 값을 확인합니다.
예상 값이 쓰여져 있지 않거나 다른 값이 있는 경우, 오류 로그를 기록하고 작업을 종료합니다.
로깅:

각 단계마다 로그를 남겨 작업의 흐름과 오류 발생 시점을 명확히 파악할 수 있습니다.
위의 코드와 주석을 통해 각 메서드와 코드 블록의 목적을 명확히 이해할 수 있으며, 이를 기반으로 더욱 안정적인 PLC 통신 로직을 구현할 