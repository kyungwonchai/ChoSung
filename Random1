알겠습니다. 요청하신 사항을 반영한 전체 코드를 제공하겠습니다. 이번 코드는 다음 기능들을 포함합니다:

COM 포트가 지정되지 않았을 경우 설정창을 표시: 설정창에서 COM 포트를 지정하면 자동으로 포트를 열어주는 로직을 추가합니다.
msgvs.Instance.LogT5() 함수로 로그 기록: 통신 및 오류 로그를 LogT5() 함수를 통해 기록합니다.
미처리된 명령 상태 추적: ListBox 또는 다른 UI 컨트롤에 미처리된 명령들을 표시하고, 명령의 상태를 "이전 명령 대기 중", "송신 완료" 등으로 표시합니다.
MVVM 구조를 유지: WPF에서 ViewModel과 View의 연동을 유지하면서 각 요소가 동작하도록 설계합니다.
MainWindow.xaml (UI)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- COM 포트 설정 여부에 따라 보이는 설정창 버튼 -->
        <Button Content="COM 포트 설정" HorizontalAlignment="Left" VerticalAlignment="Top" Width="150" Height="30" Command="{Binding OpenConfigCommand}" />

        <!-- 미처리된 명령을 보여주는 ListBox -->
        <ListBox ItemsSource="{Binding UnprocessedCommands}" HorizontalAlignment="Left" VerticalAlignment="Center" Width="300" Height="150">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel>
                        <TextBlock Text="{Binding CommandText}" />
                        <TextBlock Text="{Binding Status}" />
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </Grid>
</Window>
MainViewModel.cs (뷰모델)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    private ComPortMergeOI _comPort;
    private bool _isComPortConfigured = false;

    public ObservableCollection<CommandModel> UnprocessedCommands { get; set; } // 미처리 명령 목록
    public ICommand OpenConfigCommand { get; set; } // 설정창 열기 명령

    public MainViewModel()
    {
        UnprocessedCommands = new ObservableCollection<CommandModel>();
        OpenConfigCommand = new RelayCommand(OpenConfigWindow);

        // 시작 시 COM 포트가 설정되지 않았다면 설정창을 띄움
        if (!_isComPortConfigured)
        {
            OpenConfigWindow();
        }
    }

    // 설정창을 열고, 설정이 완료되면 COM 포트를 열어줌
    private void OpenConfigWindow()
    {
        var configWindow = new ComPortConfigWindow(); // 설정창 인스턴스
        if (configWindow.ShowDialog() == true)
        {
            // 설정에서 포트와 보드레이트를 받아옴
            string portName = configWindow.SelectedPortName;
            int baudRate = configWindow.SelectedBaudRate;

            _comPort = new ComPortMergeOI(portName, baudRate);
            _comPort.OpenPort();
            _isComPortConfigured = true;

            msgvs.Instance.LogT5($"COM 포트 {portName}이(가) 설정되고 열렸습니다.");
        }
    }

    // 명령을 큐에 추가
    public async Task AddCommandAsync(string commandText)
    {
        var command = new CommandModel
        {
            CommandText = commandText,
            Status = "이전 명령 대기 중"
        };

        UnprocessedCommands.Add(command);
        msgvs.Instance.LogT5($"명령 추가: {commandText}");

        bool success = await _comPort.SendDataWithRetryAsync(commandText);
        command.Status = success ? "송신 완료" : "송신 실패";
    }
}
CommandModel.cs (명령 상태 모델)
csharp
코드 복사
public class CommandModel
{
    public string CommandText { get; set; } // 명령 텍스트
    public string Status { get; set; } // 명령 상태 (대기 중, 송신 완료 등)
}
ComPortMergeOI.cs (통신 클래스)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Collections.Concurrent;

public class ComPortMergeOI
{
    private SerialPort _serialPort;
    private readonly byte _stx = 0x02;  // STX (Start of Text)
    private readonly byte _etx = 0x03;  // ETX (End of Text)
    private readonly byte _ack = 0x06;  // ACK (Acknowledge)
    private readonly byte _nack = 0x15; // NACK (Negative Acknowledge)
    private readonly int _timeoutMilliseconds = 5000; // 응답 대기 시간 (ms)
    private readonly int _maxRetries = 3; // 최대 재전송 횟수

    private ConcurrentQueue<string> _messageQueue;
    private bool _isSending;

    public ComPortMergeOI(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate);
        _serialPort.DataReceived += OnDataReceived;
        _serialPort.Encoding = Encoding.ASCII;
        _messageQueue = new ConcurrentQueue<string>();
    }

    // 시리얼 포트 열기
    public void OpenPort()
    {
        if (!_serialPort.IsOpen)
        {
            try
            {
                _serialPort.Open();
                msgvs.Instance.LogT5("포트가 성공적으로 열렸습니다.");
            }
            catch (Exception ex)
            {
                msgvs.Instance.LogT5($"포트 열기 실패: {ex.Message}");
            }
        }
    }

    // 메시지 전송 (재시도 포함)
    public async Task<bool> SendDataWithRetryAsync(string data)
    {
        int retries = 0;
        while (retries < _maxRetries)
        {
            bool success = await SendDataAsync(data);
            if (success)
            {
                return true;
            }
            retries++;
            msgvs.Instance.LogT5($"재시도 중... 시도 {retries}/{_maxRetries}");
        }

        msgvs.Instance.LogT5("재시도 후 전송 실패");
        return false;
    }

    // 데이터를 STX/ETX로 감싸 전송 후 ACK/NACK 대기
    private async Task<bool> SendDataAsync(string data)
    {
        if (!_serialPort.IsOpen) return false;

        string message = ((char)_stx) + data + ((char)_etx);
        byte[] messageBytes = Encoding.ASCII.GetBytes(message);

        try
        {
            await _serialPort.BaseStream.WriteAsync(messageBytes, 0, messageBytes.Length);
            msgvs.Instance.LogT5($"송신: {data}");

            return await WaitForAckAsync();
        }
        catch (Exception ex)
        {
            msgvs.Instance.LogT5($"송신 오류: {ex.Message}");
            return false;
        }
    }

    // ACK/NACK 응답 대기
    private async Task<bool> WaitForAckAsync()
    {
        var tokenSource = new CancellationTokenSource();
        var token = tokenSource.Token;

        try
        {
            Task<bool> ackTask = Task.Run(() =>
            {
                while (!token.IsCancellationRequested)
                {
                    if (_serialPort.BytesToRead > 0)
                    {
                        string response = _serialPort.ReadExisting();
                        if (response.Contains(((char)_ack).ToString()))
                        {
                            msgvs.Instance.LogT5("ACK 수신");
                            return true;
                        }
                        else if (response.Contains(((char)_nack).ToString()))
                        {
                            msgvs.Instance.LogT5("NACK 수신");
                            return false;
                        }
                    }
                }
                return false;
            }, token);

            if (await Task.WhenAny(ackTask, Task.Delay(_timeoutMilliseconds)) == ackTask)
            {
                return ackTask.Result;
            }
            else
            {
                msgvs.Instance.LogT5("ACK 대기 중 타임아웃 발생");
                return false;
            }
        }
        finally
        {
            tokenSource.Cancel();
        }
    }

    // 데이터 수신 처리
    private void OnDataReceived(object sender, SerialDataReceivedEventArgs e)
    {
        try
        {
            string data = _serialPort.ReadExisting();
            if (data.Contains(((char)_stx).ToString()) && data.Contains(((char)_etx).ToString()))
            {
                int start = data.IndexOf((char)_stx) + 1;
                int end = data.IndexOf((char)_etx);
                if (end > start)
                {
                    string actualData = data.Substring(start, end - start);
                    ProcessReceivedData(actualData);
                }
            }
            else if (data.Contains(((char)_ack).ToString()))
            {
                msgvs.Instance.LogT5("ACK 수신");
            }
            else if (data.Contains(((char)_nack).ToString()))
            {
                msgvs.Instance.LogT5("NACK 수신");
            }
        }
        catch (Exception ex)
        {
            msgvs.Instance.LogT5($"데이터





나의 말:
이어라
ChatGPT의 말:
ChatGPT
csharp
코드 복사
수신 오류: {ex.Message}");
        }
    }

    // 수신된 데이터를 처리하는 함수
    private void ProcessReceivedData(string data)
    {
        msgvs.Instance.LogT5($"수신된 데이터: {data}");
        // 추가적으로 수신된 데이터를 처리할 수 있는 로직을 여기에 작성
        // 예: UI 업데이트, 파일 저장 등
    }
}
ComPortConfigWindow.xaml (설정 창 UI)
xml
코드 복사
<Window x:Class="YourNamespace.ComPortConfigWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="COM 포트 설정" Height="200" Width="400">
    <Grid>
        <ComboBox x:Name="PortComboBox" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Margin="10" />
        <ComboBox x:Name="BaudRateComboBox" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Margin="10,50,0,0" />
        <Button Content="설정" HorizontalAlignment="Right" VerticalAlignment="Bottom" Width="100" Height="30" Click="OnSetButtonClick"/>
    </Grid>
</Window>
ComPortConfigWindow.xaml.cs (설정 창 로직)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Linq;
using System.Windows;

public partial class ComPortConfigWindow : Window
{
    public string SelectedPortName { get; private set; }
    public int SelectedBaudRate { get; private set; }

    public ComPortConfigWindow()
    {
        InitializeComponent();
        LoadAvailablePorts();
        LoadBaudRates();
    }

    // 사용 가능한 COM 포트를 불러오는 함수
    private void LoadAvailablePorts()
    {
        var ports = SerialPort.GetPortNames();
        PortComboBox.ItemsSource = ports;
        if (ports.Length > 0)
        {
            PortComboBox.SelectedIndex = 0; // 기본값 설정
        }
    }

    // 사용 가능한 BaudRate 목록을 불러오는 함수
    private void LoadBaudRates()
    {
        int[] baudRates = { 9600, 19200, 38400, 57600, 115200 };
        BaudRateComboBox.ItemsSource = baudRates;
        BaudRateComboBox.SelectedIndex = 0; // 기본값 설정
    }

    // 설정 버튼 클릭 시 처리
    private void OnSetButtonClick(object sender, RoutedEventArgs e)
    {
        if (PortComboBox.SelectedItem != null && BaudRateComboBox.SelectedItem != null)
        {
            SelectedPortName = PortComboBox.SelectedItem.ToString();
            SelectedBaudRate = (int)BaudRateComboBox.SelectedItem;

            // 설정이 완료되면 창을 닫고 DialogResult를 true로 설정
            this.DialogResult = true;
            this.Close();
        }
        else
        {
            MessageBox.Show("포트와 BaudRate를 선택해주세요.");
        }
    }
}
설명:
메인 UI: COM 포트가 지정되지 않았을 경우 설정창을 열어 사용자가 포트와 BaudRate를 선택할 수 있도록 하며, 설정이 완료되면 포트가 자동으로 열립니다.
msgvs.Instance.LogT5(): 모든 중요한 동작(포트 열기, 송신, 수신, 오류 등)은 msgvs.Instance.LogT5() 함수를 통해 기록됩니다.
미처리 명령: UnprocessedCommands 리스트는 UI에서 ListBox에 바인딩되어 있으며, 명령의 상태(대기 중, 송신 완료, 송신 실패 등)를 실시간으로 업데이트합니다.
설정창: COM 포트와 BaudRate를 설정하는 별도의 창을 만들어 사용자가 쉽게 설정을 변경할 수 있도록 했습니다. 설정이 완료되면 자동으로 포트가 열립니다.
통신 클래스: ComPortMergeOI는 송신 후 ACK/NACK 응답을 처리하며, 재전송 로직과 타임아웃을 지원합니다.
이 코드로 실제 통신 환경에서 COM 포트 설정, 명령 상태 추적, 통신 로그 기록을 전문가 수준으로 관리할 수 있습니