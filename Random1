이제부터 최적화된 RouterFlowSync 솔루션의 전체 코드를 WPF 애플리케이션의 구조와 기능을 고려하여 작성하겠습니다. 각 파일은 최적화된 클래스 구조를 유지하면서 필요한 경우 클래스를 분리하였으며, 모든 코드에는 매 줄마다 주석을 추가하고 주요 함수 호출 부분에 응용 예제를 명시하였습니다.

1. MainWindow.xaml
MainWindow.xaml
xml
코드 복사
<Window x:Class="RouterFlowSync.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="RouterFlowSync" Height="600" Width="800">
    <Grid>
        <!-- 헤더 영역 -->
        <StackPanel Orientation="Vertical" Height="100" Background="Lavender">
            <!-- 제목 영역 -->
            <TextBlock Text="라우터병합OI미들웨어" FontSize="24" FontWeight="Bold" HorizontalAlignment="Center" Margin="10"/>

            <!-- 정보 표시 영역 -->
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                    <ColumnDefinition Width="*" />
                </Grid.ColumnDefinitions>

                <!-- 시스템 동작 상태 표시 -->
                <StackPanel Grid.Column="0" Margin="10">
                    <!-- 상태를 나타내는 원형 도형 -->
                    <Ellipse Fill="{Binding IsRunning, Converter={StaticResource BoolToBrushConverter}}" Width="30" Height="30" />
                    <TextBlock Text="동작 상태" FontWeight="Bold"/>
                </StackPanel>

                <!-- PLC 연결 상태 표시 -->
                <StackPanel Grid.Column="1" Margin="10">
                    <!-- 상태를 나타내는 원형 도형 -->
                    <Ellipse Fill="{Binding IsPLCConnected, Converter={StaticResource BoolToBrushConverter}}" Width="30" Height="30" />
                    <TextBlock Text="PLC 상태" FontWeight="Bold"/>
                </StackPanel>

                <!-- OI 연결 상태 표시 -->
                <StackPanel Grid.Column="2" Margin="10">
                    <!-- 상태를 나타내는 원형 도형 -->
                    <Ellipse Fill="{Binding IsOIConnected, Converter={StaticResource BoolToBrushConverter}}" Width="30" Height="30" />
                    <TextBlock Text="OI 상태" FontWeight="Bold"/>
                </StackPanel>
            </Grid>
        </StackPanel>

        <!-- 탭 컨트롤 영역 -->
        <TabControl Margin="10" VerticalAlignment="Top">
            <!-- 라우터 설비 로그 수집 탭 -->
            <TabItem Header="라우터 설비 로그 수집">
                <StackPanel Margin="10">
                    <TextBlock Text="네트워크 경로:" FontWeight="Bold"/>
                    <!-- 네트워크 경로를 표시 -->
                    <TextBlock Text="{Binding NetworkPath}" Margin="0,0,0,10"/>

                    <TextBlock Text="파일 규칙 (정규식):" FontWeight="Bold"/>
                    <!-- 파일 규칙을 표시 -->
                    <TextBlock Text="{Binding FilePattern}" Margin="0,0,0,10"/>

                    <TextBlock Text="로그 저장 경로:" FontWeight="Bold"/>
                    <!-- 로그 저장 경로를 표시 -->
                    <TextBlock Text="C:\Agent\RouterFlowSync\Log\RouterFiles" Margin="0,0,0,10"/>

                    <!-- 파일 처리 로그를 표시 -->
                    <ListBox ItemsSource="{Binding FileProcessingLogs}" MaxHeight="200"/>

                    <TextBlock Text="점검 목록:" FontWeight="Bold" Margin="10,10,0,0"/>
                    <!-- 점검 목록을 표시 -->
                    <ListBox ItemsSource="{Binding CheckList}" MaxHeight="100"/>
                </StackPanel>
            </TabItem>

            <!-- PLC 중계 탭 -->
            <TabItem Header="PLC 중계">
                <!-- PLC 관련 설정 내용 -->
                <!-- 사용 가능한 포트를 표시하고, 포트 설정을 저장할 수 있는 UI 구성 -->
            </TabItem>

            <!-- 병합 OI 중계 탭 -->
            <TabItem Header="병합 OI 중계">
                <!-- OI 관련 설정 내용 -->
                <!-- 사용 가능한 포트를 표시하고, 포트 설정을 저장할 수 있는 UI 구성 -->
            </TabItem>

            <!-- 설정 탭 -->
            <TabItem Header="설정">
                <!-- 설정과 관련된 UI 요소 구성 -->
            </TabItem>
        </TabControl>
    </Grid>
</Window>
주요 설명:
Ellipse와 TextBlock: 시스템의 동작 상태를 나타내기 위해 세 가지 원형 도형을 사용했습니다. BoolToBrushConverter는 Boolean 값을 Brush로 변환하여 상태를 시각적으로 표시합니다.
TabControl: 다양한 기능을 위해 네 개의 탭이 정의되어 있습니다. 각 탭은 다양한 설정 및 로그 정보를 표시합니다.
2. MainWindow.xaml.cs
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Data.SqlClient;  // MSSQL 연결을 위한 네임스페이스
using System.IO;
using System.IO.Ports;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms;  // 트레이 아이콘을 위한 네임스페이스
using RouterFlowSync.Services;
using RouterFlowSync.ViewModels;
using Microsoft.AspNet.SignalR.Client;  // SignalR 클라이언트를 위한 네임스페이스
using System.Windows.Media;

namespace RouterFlowSync.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;  // ViewModel 인스턴스
        private NotifyIcon _notifyIcon;  // 트레이 아이콘 관리 객체
        private string _connectionString = "Data Source=YOUR_SERVER_NAME;Initial Catalog=YOUR_DATABASE_NAME;Integrated Security=True";  // 데이터베이스 연결 문자열
        private HubConnection _signalRConnection;  // SignalR 서버 연결 객체
        private IHubProxy _hubProxy;  // SignalR 허브 프록시 객체

        public MainWindow()
        {
            InitializeComponent();  // XAML 요소 초기화
            _viewModel = new MainViewModel();  // ViewModel 초기화
            DataContext = _viewModel;  // ViewModel을 DataContext로 설정
            SetupTrayIcon();  // 트레이 아이콘 설정
            LoadSettings();  // 설정 불러오기

            // 프로그램 시작 시 상태를 "Running"으로 설정하고 데이터베이스에 기록
            UpdateDatabaseStatus("Running", "Application started successfully");
            StartStatusCheckTimer();  // 상태 확인 타이머 시작
        }

        // 트레이 아이콘 설정 메서드
        private void SetupTrayIcon()
        {
            _notifyIcon = new NotifyIcon
            {
                Icon = new System.Drawing.Icon("appicon.ico"),  // 아이콘 설정
                Visible = true  // 트레이 아이콘 표시
            };
            _notifyIcon.DoubleClick += (s, e) => ShowWindow();  // 더블 클릭 시 메인 윈도우 표시

            // 트레이 아이콘의 컨텍스트 메뉴 설정
            var contextMenu = new ContextMenu();
            contextMenu.MenuItems.Add("Open", (s, e) => ShowWindow());
            contextMenu.MenuItems.Add("Exit", (s, e) => CloseApplication());
            _notifyIcon.ContextMenu = contextMenu;
        }

        // 메인 윈도우를 표시하는 메서드
        private void ShowWindow()
        {
            this.Show();
            this.WindowState = WindowState.Normal;  // 윈도우 상태를 정상으로 변경
        }

        // 프로그램 종료 메서드
        private void CloseApplication()
        {
            UpdateDatabaseStatus("Stopped", "Application closed by user");  // 데이터베이스에 종료 기록
            _notifyIcon.Dispose();  // 트레이 아이콘 해제
            Application.Current.Shutdown();  // 애플리케이션 종료
        }

        // 데이터베이스 상태 업데이트 메서드
        private void UpdateDatabaseStatus(string status, string message)
        {
            try
            {
                using (SqlConnection conn = new SqlConnection(_connectionString))  // 데이터베이스 연결
                {
                    conn.Open();  // 연결 열기
                    string query = "INSERT INTO RouterFlowSyncStatus (Status, Message) VALUES (@Status, @Message)";
                    using (SqlCommand cmd = new SqlCommand(query, conn))  // SQL 명령 설정
                    {
                        cmd.Parameters.AddWithValue("@Status", status);  // 상태 매개변수 추가
                        cmd.Parameters.AddWithValue("@Message", message);  // 메시지 매개변수 추가
                        cmd.ExecuteNonQuery();  // 쿼리 실행
                    }
                }
            }
            catch (Exception ex)
            {
                HandleError($"Database update failed: {ex.Message}");  // 예외 처리
            }
        }

        // 설정을 불러오는 메서드
        private void LoadSettings()
        {
            // SignalR 설정 로드
            if (SettingsManager.Instance.GetSetting("UseSignalR") == "true")
            {
                InitializeSignalR(SettingsManager.Instance.GetSetting("SignalRServerUrl"));  // SignalR 초기화
            }

            // 에러 로그를 데이터베이스에 기록할지 여부 설정
            if (SettingsManager.Instance.GetSetting("LogErrorsToDatabase") == "true")
            {
                _viewModel.LogErrorsToDatabase = true;  // 설정 반영
            }
        }

        // SignalR 서버 초기화 메서드
        private void InitializeSignalR(string serverUrl)
        {
            try
            {
                _signalRConnection = new HubConnection(serverUrl);  // SignalR 서버 연결 설정
                _hubProxy = _signalRConnection.CreateHubProxy("ErrorHub");  // 허브 프록시 생성
                _signalRConnection.Start().Wait();  // SignalR 서버 시작

                LogService.Instance.LogOperation("Connected to SignalR server successfully");  // 연결 성공 로그 기록
            }
            catch (Exception ex)
            {
                HandleError($"Failed to connect to SignalR server: {ex.Message}");  // 연결 실패 예외 처리
            }
        }

        // 에러 처리 메서드
        private void HandleError(string errorMessage)
        {
            LogService.Instance.LogError(errorMessage);  // 에러 로그 기록
            SetUIErrorState(true);  // UI를 에러 상태로 변경

            // 에러 로그를 데이터베이스에 기록할지 여부 확인
            if (_viewModel.LogErrorsToDatabase)
            {
                UpdateDatabaseStatus("Error", errorMessage);  // 데이터베이스에 에러 로그 기록
            }

            // SignalR 연결이 활성화된 경우 에러 전송
            if (_signalRConnection != null && _signalRConnection.State == ConnectionState.Connected)
            {
                _hubProxy.Invoke("SendError", errorMessage);  // SignalR 서버로 에러 전송
            }
        }

        // UI 에러 상태 설정 메서드
        private void SetUIErrorState(bool isError)
        {
            if (isError)
            {
                this.BorderBrush = Brushes.Red;  // UI 테두리를 빨간색으로 변경
                LogListBox.Foreground = Brushes.Red;  // 로그 리스트박스의 글씨를 빨간색으로 변경
            }
            else
            {
                this.BorderBrush = Brushes.Gray;  // UI 테두리를 기본 색상으로 변경
                LogListBox.Foreground = Brushes.Black;  // 로그 리스트박스의 글씨를 기본 색상으로 변경
            }
        }

        // 포트 갱신 버튼 클릭 이벤트 핸들러
        private void RefreshPorts_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.RefreshAvailablePorts();  // 사용 가능한 포트 갱신
        }

        // PLC 설정 저장 버튼 클릭 이벤트 핸들러
        private void SavePLCSettings_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.SavePLCSettings();  // PLC 설정 저장
        }

        // OI 설정 저장 버튼 클릭 이벤트 핸들러
        private void SaveOISettings_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.SaveOISettings();  // OI 설정 저장
        }

        // 로그 폴더 열기 버튼 클릭 이벤트 핸들러
        private void OpenLogFolder_Click(object sender, RoutedEventArgs e)
        {
            string logFolderPath = "C:\\Agent\\RouterFlowSync\\Log";  // 로그 폴더 경로 설정
            if (Directory.Exists(logFolderPath))  // 로그 폴더가 존재하는지 확인
            {
                System.Diagnostics.Process.Start("explorer.exe", logFolderPath);  // 탐색기에서 로그 폴더 열기
            }
            else
            {
                MessageBox.Show("로그 폴더가 존재하지 않습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);  // 오류 메시지 표시
            }
        }

        // 윈도우 닫기 버튼 클릭 이벤트 핸들러
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            e.Cancel = true;  // 닫기 동작 취소
            this.Hide();  // 윈도우 숨기기
        }

        // 상태 확인 타이머 시작
        private void StartStatusCheckTimer()
        {
            var timer = new System.Windows.Threading.DispatcherTimer();
            timer.Interval = TimeSpan.FromSeconds(5);  // 5초마다 상태 체크
            timer.Tick += (s, e) => CheckSystemStatus();
            timer.Start();
        }

        // 시스템 상태 확인 메서드
        private void CheckSystemStatus()
        {
            _viewModel.IsRunning = true;  // 시스템이 정상적으로 실행 중임을 가정

            // PLC 또는 OI 연결 상태가 비정상인 경우
            if (!_viewModel.IsPLCConnected || !_viewModel.IsOIConnected)
            {
                _viewModel.CheckList.Clear();  // 기존 점검 목록 초기화

                // PLC 연결 상태가 비정상인 경우 점검 항목 추가
                if (!_viewModel.IsPLCConnected)
                {
                    _viewModel.CheckList.Add("PLC 연결 상태를 확인하세요.");
                }

                // OI 연결 상태가 비정상인 경우 점검 항목 추가
                if (!_viewModel.IsOIConnected)
                {
                    _viewModel.CheckList.Add("OI 연결 상태를 확인하세요.");
                }

                _viewModel.IsRunning = false;  // 동작 상태를 비정상으로 표시
                HandleError("PLC 또는 OI 연결이 끊어졌습니다.");  // 에러 처리
            }
        }
    }
}
주요 설명:
SetupTrayIcon 메서드: 트레이 아이콘을 설정하고 사용자가 애플리케이션을 쉽게 제어할 수 있도록 합니다.
UpdateDatabaseStatus 메서드: 애플리케이션 상태를 MSSQL 데이터베이스에 기록합니다.
HandleError 메서드: 에러 발생 시 UI 업데이트, 로그 기록, SignalR 서버 알림 등을 수행합니다.
CheckSystemStatus 메서드: 5초마다 시스템 상태를 확인하여 연결 상태에 문제가 있을 경우 자동으로 에러를 처리합니다.
3. MainViewModel.cs
MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;  // INotifyPropertyChanged를 사용하기 위한 네임스페이스
using System.IO.Ports;
using RouterFlowSync.Services;

namespace RouterFlowSync.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        // 파일 처리 로그 컬렉션
        public ObservableCollection<string> FileProcessingLogs { get; private set; }

        // 사용 가능한 포트 목록
        public ObservableCollection<string> AvailablePorts { get; private set; }

        // PLC 포트 설정
        private string _selectedPLCComPort;
        public string SelectedPLCComPort
        {
            get => _selectedPLCComPort;
            set
            {
                _selectedPLCComPort = value;
                OnPropertyChanged(nameof(SelectedPLCComPort));
            }
        }

        // OI 포트 설정
        private string _selectedOIComPort;
        public string SelectedOIComPort
        {
            get => _selectedOIComPort;
            set
            {
                _selectedOIComPort = value;
                OnPropertyChanged(nameof(SelectedOIComPort));
            }
        }

        // PLC 설정 옵션
        public ObservableCollection<string> PLCSettingsOptions { get; private set; }

        // 선택된 PLC 설정
        private string _selectedPLCSetting;
        public string SelectedPLCSetting
        {
            get => _selectedPLCSetting;
            set
            {
                _selectedPLCSetting = value;
                OnPropertyChanged(nameof(SelectedPLCSetting));
            }
        }

        // OI 설정 옵션
        public ObservableCollection<string> OISettingsOptions { get; private set; }

        // 선택된 OI 설정
        private string _selectedOISetting;
        public string SelectedOISetting
        {
            get => _selectedOISetting;
            set
            {
                _selectedOISetting = value;
                OnPropertyChanged(nameof(SelectedOISetting));
            }
        }

        // 에러 로그를 데이터베이스에 기록할지 여부
        public bool LogErrorsToDatabase { get; set; }

        // 시스템 동작 상태
        private bool _isRunning;
        public bool IsRunning
        {
            get => _isRunning;
            set
            {
                _isRunning = value;
                OnPropertyChanged(nameof(IsRunning));
            }
        }

        // PLC 연결 상태
        private bool _isPLCConnected;
        public bool IsPLCConnected
        {
            get => _isPLCConnected;
            set
            {
                _isPLCConnected = value;
                OnPropertyChanged(nameof(IsPLCConnected));
            }
        }

        // OI 연결 상태
        private bool _isOIConnected;
        public bool IsOIConnected
        {
            get => _isOIConnected;
            set
            {
                _isOIConnected = value;
                OnPropertyChanged(nameof(IsOIConnected));
            }
        }

        // 점검 목록
        public ObservableCollection<string> CheckList { get; private set; }

        // 마지막 파일 체크 시간
        public DateTime LastFileCheckTime { get; set; }

        // 마지막 PLC 전송 시간
        public DateTime LastPLCTransmissionTime { get; set; }

        // 마지막 OI 전송 시간
        public DateTime LastOITransmissionTime { get; set; }

        // 파일 처리 후 PLC 전송까지의 시간 차이
        public TimeSpan TimeSinceLastPLCTransmission { get; set; }

        // 파일 처리와 PLC 전송의 차이 시간
        public TimeSpan FileToPLCTransmissionDifference { get; set; }

        // 파일 처리와 OI 전송의 차이 시간
        public TimeSpan FileToOITransmissionDifference { get; set; }

        // 설정 관리자 인스턴스
        private SettingsManager _settingsManager;

        // COM 포트 관리자 인스턴스
        private ComPortManager _comPortManager;

        // 생성자
        public MainViewModel()
        {
            // 초기화 작업
            FileProcessingLogs = new ObservableCollection<string>();
            AvailablePorts = new ObservableCollection<string>(SerialPort.GetPortNames());
            PLCSettingsOptions = new ObservableCollection<string> { "9600", "19200", "38400", "57600", "115200" };
            OISettingsOptions = new ObservableCollection<string> { "9600", "19200", "38400", "57600", "115200" };
            CheckList = new ObservableCollection<string>();

            _settingsManager = SettingsManager.Instance;  // 설정 관리자 초기화
            _comPortManager = new ComPortManager();  // COM 포트 관리자 초기화

            LoadSettings();  // 설정 로드
        }

        // 사용 가능한 포트를 갱신하는 메서드
        public void RefreshAvailablePorts()
        {
            AvailablePorts.Clear();  // 기존 포트 목록 지우기
            foreach (var port in SerialPort.GetPortNames())  // 새 포트 목록 추가
            {
                AvailablePorts.Add(port);
            }
        }

        // PLC 설정을 저장하는 메서드
        public void SavePLCSettings()
        {
            _settingsManager.SaveSetting("PLCComPort", SelectedPLCComPort);  // PLC COM 포트 저장
            _settingsManager.SaveSetting("PLCSetting", SelectedPLCSetting);  // PLC 설정 저장
        }

        // OI 설정을 저장하는 메서드
        public void SaveOISettings()
        {
            _settingsManager.SaveSetting("OIComPort", SelectedOIComPort);  // OI COM 포트 저장
            _settingsManager.SaveSetting("OISetting", SelectedOISetting);  // OI 설정 저장
        }

        // 설정을 로드하는 메서드
        private void LoadSettings()
        {
            SelectedPLCComPort = _settingsManager.GetSetting("PLCComPort");  // 저장된 PLC COM 포트 로드
            SelectedPLCSetting = _settingsManager.GetSetting("PLCSetting");  // 저장된 PLC 설정 로드
            SelectedOIComPort = _settingsManager.GetSetting("OIComPort");  // 저장된 OI COM 포트 로드
            SelectedOISetting = _settingsManager.GetSetting("OISetting");  // 저장된 OI 설정 로드
        }

        // INotifyPropertyChanged 구현
        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 설명:
MainViewModel 클래스: 애플리케이션의 핵심 비즈니스 로직을 관리합니다.
CheckList 속성: 사용자가 점검해야 할 항목을 동적으로 추가하고 제거할 수 있습니다.
INotifyPropertyChanged 인터페이스: 속성 변경 시 UI를 자동으로 업데이트하기 위해 구현되었습니다.
4. ComPortManager.cs
ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Threading.Tasks;
using RouterFlowSync.Services;

namespace RouterFlowSync.Services
{
    public class ComPortManager
    {
        private SerialPort _port;  // SerialPort 객체
        private string _currentPortName;  // 현재 사용 중인 포트 이름

        // 포트를 설정하는 메서드
        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _currentPortName = portName;  // 현재 포트 이름 저장

            if (_port != null && _port.IsOpen)  // 이미 포트가 열려 있는 경우
            {
                _port.Close();  // 포트 닫기
            }

            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);  // 새 포트 설정
        }

        // 데이터를 비동기적으로 전송하는 메서드
        public async Task<bool> SendDataAsync(string data)
        {
            try
            {
                if (_port == null || !_port.IsOpen)  // 포트가 설정되지 않았거나 열려 있지 않은 경우
                {
                    _port.Open();  // 포트 열기
                }

                _port.WriteLine(data);  // 데이터 전송
                await Task.Delay(100);  // 통신 대기 시간

                string response = _port.ReadLine();  // 응답 수신
                LogService.Instance.LogOperation($"전송 데이터: {data}, 응답: {response}");  // 로그 기록

                return response.Contains("OK");  // 응답 확인
            }
            catch (Exception ex)
            {
                LogService.Instance.LogError($"COM 포트 전송 중 오류 발생: {ex.Message}");  // 오류 로그 기록
                return false;  // 실패 반환
            }
            finally
            {
                if (_port != null && _port.IsOpen)
                {
                    _port.Close();  // 포트 닫기
                }
            }
        }

        // 포트 설정을 저장하는 메서드
        public void SavePortSettings(string key, string portName)
        {
            SettingsManager.Instance.SaveSetting(key, portName);  // 설정 저장
        }

        // 포트 설정을 불러오는 메서드
        public string LoadPortSettings(string key)
        {
            return SettingsManager.Instance.GetSetting(key);  // 설정 불러오기
        }
    }
}
주요 설명:
ConfigurePort 메서드: 포트를 설정하고 필요시 닫고 다시 엽니다.
SendDataAsync 메서드: 데이터를 비동기적으로 전송하고 응답을 처리합니다. 응답이 "OK"인 경우 true를 반환합니다.
5. SettingsManager.cs
SettingsManager.cs
csharp
코드 복사
using System.Collections.Generic;
using System.IO;
using System.Linq;

namespace RouterFlowSync.Services
{
    public class SettingsManager
    {
        private static SettingsManager _instance;  // 싱글톤 인스턴스
        private Dictionary<string, string> _settings;  // 설정을 저장하는 딕셔너리

        public static SettingsManager Instance
        {
            get
            {
                if (_instance == null)  // 인스턴스가 null인 경우
                {
                    _instance = new SettingsManager();  // 인스턴스 생성
                }
                return _instance;  // 인스턴스 반환
            }
        }

        private SettingsManager()
        {
            _settings = new Dictionary<string, string>();  // 설정 딕셔너리 초기화
            LoadSettings();  // 설정 로드
        }

        private void LoadSettings()
        {
            if (File.Exists("settings.ini"))  // 설정 파일이 존재하는지 확인
            {
                var lines = File.ReadAllLines("settings.ini");  // 설정 파일 읽기
                foreach (var line in lines)
                {
                    var parts = line.Split('=');  // 설정 파일의 각 줄을 '='로 나누기
                    if (parts.Length == 2)
                    {
                        _settings[parts[0]] = parts[1];  // 설정 딕셔너리에 키-값 쌍 저장
                    }
                }
            }
        }

        public void SaveSetting(string key, string value)
        {
            _settings[key] = value;  // 설정 딕셔너리에 키-값 쌍 저장
            File.WriteAllLines("settings.ini", _settings.Select(s => $"{s.Key}={s.Value}"));  // 설정 파일에 저장
        }

        public string GetSetting(string key)
        {
            return _settings.ContainsKey(key) ? _settings[key] : string.Empty;  // 설정 딕셔너리에서 값 반환
        }
    }
}
주요 설명:
SettingsManager 클래스: 애플리케이션 설정을 관리하는 싱글톤 클래스입니다.
LoadSettings 메서드: 설정 파일에서 설정을 읽어옵니다.
SaveSetting 메서드: 설정 파일에 설정을 저장합니다.
6. LogService.cs
LogService.cs
csharp
코드 복사
using System;
using System.IO;

namespace RouterFlowSync.Services
{
    public class LogService
    {
        private static LogService _instance;  // 싱글톤 인스턴스
        private readonly string _logDirectory;  // 로그 디렉터리 경로

        public static LogService Instance
        {
            get
            {
                if (_instance == null)  // 인스턴스가 null인 경우
                {
                    _instance = new LogService();  // 인스턴스 생성
                }
                return _instance;  // 인스턴스 반환
            }
        }

        private LogService()
        {
            _logDirectory = Path.Combine("C:\\Agent\\RouterFlowSync\\Log", DateTime.Now.ToString("yyyyMM"));  // 로그 디렉터리 경로 설정
            Directory.CreateDirectory(_logDirectory);  // 로그 디렉터리 생성
        }

        public void LogOperation(string message)
        {
            string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_OperatorLog.txt");  // 로그 파일 경로 설정
            WriteLog(logFilePath, message);  // 로그 파일에 기록
        }

        public void LogError(string message)
        {
            string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ErrorLog.txt");  // 에러 로그 파일 경로 설정
            WriteLog(logFilePath, message);  // 에러 로그 파일에 기록
        }

        private void WriteLog(string logFilePath, string message)
        {
            string logMessage = $"{DateTime.Now:HH:mm:ss} - {message}";  // 로그 메시지 생성
            File.AppendAllText(logFilePath, logMessage + Environment.NewLine);  // 로그 파일에 메시지 추가
        }
    }
}
주요 설명:
LogService 클래스: 로그 파일을 관리하는 싱글톤 클래스입니다.
LogOperation 메서드: 일반 로그를 기록합니다.
LogError 메서드: 에러 로그를 기록합니다.
7. FileWatcherService.cs
FileWatcherService.cs
csharp
코드 복사
using System;
using System.IO;
using System.Threading.Tasks;

namespace RouterFlowSync.Services
{
    public class FileWatcherService
    {
        private readonly FileSystemWatcher _watcher;  // FileSystemWatcher 객체
        private readonly string _sourceDirectory;  // 원본 디렉토리 경로
        private readonly string _backupDirectory;  // 백업 디렉토리 경로

        public FileWatcherService(string sourceDirectory, string backupDirectory)
        {
            _sourceDirectory = sourceDirectory;  // 원본 디렉토리 경로 설정
            _backupDirectory = backupDirectory;  // 백업 디렉토리 경로 설정

            _watcher = new FileSystemWatcher(_sourceDirectory)  // FileSystemWatcher 초기화
            {
                NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,  // 감시할 변경 유형 설정
                Filter = "*.*"  // 모든 파일을 감시
            };

            _watcher.Created += OnFileCreated;  // 파일 생성 이벤트 핸들러 설정
            _watcher.EnableRaisingEvents = true;  // 이벤트 발생을 활성화
        }

        private void OnFileCreated(object sender, FileSystemEventArgs e)
        {
            Task.Run(() => ProcessFile(e.FullPath));  // 파일 처리를 비동기적으로 실행
        }

        private async Task ProcessFile(string filePath)
        {
            try
            {
                string dateFolder = DateTime.Now.ToString("yyyyMM");  // 현재 날짜로 폴더 이름 설정
                string backupSubFolder = Path.Combine(_backupDirectory, dateFolder, DateTime.Now.ToString("yyyyMMdd"));  // 백업 폴더 경로 설정
                Directory.CreateDirectory(backupSubFolder);  // 백업 폴더 생성

                string backupFileName = $"{DateTime.Now:yyyyMMddHHmmss}_{Path.GetFileName(filePath)}";  // 백업 파일 이름 설정
                string backupFilePath = Path.Combine(backupSubFolder, backupFileName);  // 백업 파일 경로 설정

                // 파일 백업
                File.Copy(filePath, backupFilePath, true);

                // 원본 파일 삭제
                File.Delete(filePath);

                // 파일 처리 후 이름 변경
                await Task.Delay(500);  // 파일 처리 시간 대기
                File.Move(backupFilePath, backupFilePath.Replace(Path.GetExtension(backupFilePath), ".complete"));  // 파일 이름 변경

                LogService.Instance.LogOperation($"파일 {backupFilePath} 처리 완료");  // 로그 기록
            }
            catch (Exception ex)
            {
                LogService.Instance.LogError($"파일 처리 중 오류 발생: {ex.Message}");  // 오류 로그 기록
            }
        }
    }
}
주요 설명:
FileWatcherService 클래스: 파일 시스템을 감시하고, 새로 생성된 파일을 처리합니다.
ProcessFile 메서드: 파일을 백업하고 이름을 변경하며, 로그를 기록합니다.
8. RelayCommand.cs
RelayCommand.cs
csharp
코드 복사
using System;
using System.Windows.Input;

namespace RouterFlowSync.ViewModels
{
    public class RelayCommand : ICommand
    {
        private readonly Action _execute;  // 실행할 액션
        private readonly Func<bool> _canExecute;  // 실행 가능 여부를 결정하는 함수

        public event EventHandler CanExecuteChanged;

        public RelayCommand(Action execute, Func<bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));  // 실행할 액션 설정
            _canExecute = canExecute;  // 실행 가능 여부를 결정하는 함수 설정
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute();  // canExecute 함수가 없으면 true 반환, 있으면 함수 실행 결과 반환
        }

        public void Execute(object parameter)
        {
            _execute();  // 액션 실행
        }

        public void RaiseCanExecuteChanged()
        {
            CanExecuteChanged?.Invoke(this, EventArgs.Empty);  // 이벤트 발생
        }
    }
}
주요 설명:
RelayCommand 클래스: MVVM 패턴에서 ICommand를 구현하는 데 사용되는 클래스입니다.
Execute 메서드: 액션을 실행합니다.
CanExecute 메서드: 명령이 실행될 수 있는지 여부를 결정합니다.
이 전체 코드 구조는 WPF 애플리케이션에서 안정적이고 확장 가능한 방식으로 동작하도록 설계되었습니다. 각 클래스와 메서드는 가능한 한 간결하게 유지되었으며, 필요한 경우 주석이 추가되어 코드의 목적과 기능을 명확히 하였습니다.

이 솔루션을 실제 환경에서 사용할 준비가 되었다고 판단되며, 추가적인 요구 사항이나 개선 사항이 있는 경우 이를 반영하여 최적화할 수 있습니다. 추가적인 질문이나 요청이 있으면 언제든지 말씀해 주세요