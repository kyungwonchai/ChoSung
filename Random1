네, 원하시는 기능은 Windows Forms(윈폼)과 C#을 사용하여 충분히 구현할 수 있습니다. 다른 프로그램 창이 가려져 있어도 특정 위치의 이미지를 읽고, 그 안의 텍스트(숫자)를 인식하여 파일로 기록하는 안정적인 프로그램을 만드는 방법을 단계별로 상세히 안내해 드리겠습니다.

핵심 원리는 다음과 같습니다.

백그라운드 창 캡처: 일반적인 화면 캡처 방식으로는 가려진 창을 찍을 수 없습니다. 따라서 Windows API 함수인 PrintWindow를 사용하여 대상 프로그램이 다른 창에 가려져 있거나 최소화되어 있어도 해당 창의 이미지를 비트맵(Bitmap) 객체로 가져옵니다.
광학 문자 인식(OCR): 가져온 비트맵 이미지에서 원하는 특정 영역을 잘라낸 후, Windows 10에 내장된 OCR 기능을 사용하여 이미지 속의 숫자 텍스트를 추출합니다. 별도의 외부 라이브러리 설치가 필요 없어 안정적입니다.
타이머와 파일 로깅: Timer 컴포넌트를 사용하여 10초마다 위 과정을 반복하고, 인식된 숫자 데이터를 타임스탬프와 함께 로그 파일에 순차적으로 기록합니다.
아래 가이드에 따라 WinForms 프로젝트를 만들고 코드를 추가해 보세요.

윈폼(WinForms)으로 실시간 숫자 로깅 프로그램 만들기
1단계: 프로젝트 생성 및 UI 디자인
Visual Studio를 실행하고 '새 프로젝트 만들기'를 선택합니다.

'Windows Forms 앱(.NET Framework)'을 선택하고 프로젝트 이름을 지정합니다. (예: DataLogger)

디자이너 화면에서 아래와 같이 도구들을 추가하고 속성을 설정합니다.

Label 4개: 각각 "대상 창 제목", "캡처 X 좌표", "캡처 Y 좌표", "캡처 크기" 텍스트를 표시합니다.
TextBox 4개:
txtWindowTitle: 감시할 프로그램의 창 제목을 입력받습니다.
txtX, txtY: 숫자를 읽어올 이미지의 창 내 좌상단 좌표(X, Y)를 입력받습니다.
txtWidth, txtHeight: 읽어올 이미지의 가로, 세로 크기를 입력받습니다.
Button 2개:
btnStart: 로깅 시작/중지 토글 버튼 (텍스트: "시작")
btnSetArea: (선택 사항) 캡처 영역을 쉽게 지정하기 위한 버튼
Label 1개:
lblStatus: 현재 상태를 표시합니다. (예: "대기 중", "로깅 중...")
Timer 1개:
tmrLog: 도구 상자에서 Timer를 폼으로 드래그 앤 드롭합니다.
Interval 속성을 10000 (10초)으로 설정합니다.
Enabled 속성은 False로 둡니다.
[예시 UI 디자인]

2단계: Windows 10 OCR 기능 참조 추가
Windows 10 내장 OCR을 사용하기 위해 Windows.Media.Ocr 네임스페이스를 참조해야 합니다.

솔루션 탐색기에서 참조를 마우스 오른쪽 버튼으로 클릭하고 참조 추가를 선택합니다.
왼쪽에서 **찾아보기(Browse)**를 선택하고 찾아보기(B)... 버튼을 클릭합니다.
아래 경로로 이동하여 Windows.winmd 파일을 찾아 추가합니다. C:\Program Files (x86)\Windows Kits\10\UnionMetadata\10.0.xxxx.0\ (버전명 10.0.xxxx.0은 시스템에 따라 다를 수 있습니다. 가장 최신 버전 폴더를 선택하세요.)
마지막으로 System.Runtime.WindowsRuntime.dll도 참조 추가해야 할 수 있습니다. NuGet 패키지 관리자에서 System.Runtime.WindowsRuntime을 검색하여 설치하는 것이 가장 간편합니다.
3단계: C# 코드 작성 (Form1.cs)
이제 실제 동작을 담당하는 코드를 작성합니다. Form1.cs 파일을 열고 아래 코드를 입력하세요. 기존 코드를 덮어쓰거나 필요한 부분을 복사하여 붙여넣으세요.

C#

using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Runtime.InteropServices;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Forms;
using Windows.Graphics.Imaging;
using Windows.Media.Ocr;

namespace DataLogger
{
    public partial class Form1 : Form
    {
        // WinAPI 함수 선언
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left;
            public int Top;
            public int Right;
            public int Bottom;
        }

        private OcrEngine ocrEngine;

        public Form1()
        {
            InitializeComponent();
            // 시스템 언어에 맞는 OCR 엔진 초기화
            ocrEngine = OcrEngine.TryCreateFromUserProfileLanguages();
        }

        private void btnStart_Click(object sender, EventArgs e)
        {
            if (tmrLog.Enabled)
            {
                tmrLog.Stop();
                btnStart.Text = "시작";
                lblStatus.Text = "로깅이 중지되었습니다.";
            }
            else
            {
                if (string.IsNullOrWhiteSpace(txtWindowTitle.Text) ||
                    string.IsNullOrWhiteSpace(txtX.Text) ||
                    string.IsNullOrWhiteSpace(txtY.Text) ||
                    string.IsNullOrWhiteSpace(txtWidth.Text) ||
                    string.IsNullOrWhiteSpace(txtHeight.Text))
                {
                    MessageBox.Show("모든 입력 필드를 채워주세요.", "오류", MessageBoxButtons.OK, MessageBoxIcon.Error);
                    return;
                }
                tmrLog.Start();
                btnStart.Text = "중지";
                lblStatus.Text = "로깅 중...";
            }
        }

        private async void tmrLog_Tick(object sender, EventArgs e)
        {
            try
            {
                // 1. 대상 창 핸들 찾기
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero)
                {
                    lblStatus.Text = "오류: 대상 창을 찾을 수 없습니다.";
                    return;
                }

                // 2. 창 크기 구하고 비트맵 생성
                GetWindowRect(hWnd, out RECT rect);
                using (Bitmap bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, PixelFormat.Format32bppArgb))
                {
                    using (Graphics g = Graphics.FromImage(bmp))
                    {
                        IntPtr hdc = g.GetHdc();
                        // 3. PrintWindow로 창 이미지 캡처 (백그라운드에서도 동작)
                        PrintWindow(hWnd, hdc, 0);
                        g.ReleaseHdc(hdc);
                    }

                    // 4. 지정된 좌표와 크기로 이미지 자르기
                    Rectangle cropArea = new Rectangle(
                        int.Parse(txtX.Text),
                        int.Parse(txtY.Text),
                        int.Parse(txtWidth.Text),
                        int.Parse(txtHeight.Text));

                    using (Bitmap croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        // 5. OCR로 텍스트 인식
                        string ocrText = await RecognizeTextAsync(croppedBmp);
                        if (!string.IsNullOrWhiteSpace(ocrText))
                        {
                            // 6. 파일에 로그 기록
                            LogData(ocrText.Trim());
                            lblStatus.Text = $"로그 기록 완료: {DateTime.Now}";
                        }
                        else
                        {
                           lblStatus.Text = "텍스트를 인식하지 못했습니다.";
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"오류 발생: {ex.Message}";
                LogData($"[ERROR] {ex.Message}");
            }
        }

        private async Task<string> RecognizeTextAsync(Bitmap bmp)
        {
            // Bitmap을 OCR 엔진이 요구하는 SoftwareBitmap으로 변환
            using (var stream = new MemoryStream())
            {
                bmp.Save(stream, ImageFormat.Bmp);
                stream.Position = 0;

                BitmapDecoder decoder = await BitmapDecoder.CreateAsync(stream.AsRandomAccessStream());
                SoftwareBitmap softwareBitmap = await decoder.GetSoftwareBitmapAsync();

                // OCR 실행
                OcrResult result = await ocrEngine.RecognizeAsync(softwareBitmap);
                return result.Text;
            }
        }

        private void LogData(string data)
        {
            try
            {
                string logFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "datalog.txt");
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss}\t{data.Replace("\n", " ").Replace("\r", "")}\n";
                File.AppendAllText(logFilePath, logMessage, Encoding.UTF8);
            }
            catch (Exception ex)
            {
                // 파일 접근 오류가 발생할 경우를 대비
                MessageBox.Show($"로그 파일 쓰기 오류: {ex.Message}");
            }
        }
    }
}
4단계: 프로그램 실행 및 사용법
빌드: F5 키를 눌러 프로그램을 디버그 모드로 실행하거나, 메뉴에서 빌드 > 솔루션 빌드를 선택하여 실행 파일을 만듭니다.
대상 창 제목 입력: 온도/습도가 표시되는 프로그램의 전체 창 제목을 '대상 창 제목'란에 정확히 입력합니다. (예: "실시간 모니터링 툴 v1.2")
캡처 영역 좌표 입력:
숫자가 표시되는 영역의 창 내부 좌상단 X, Y 좌표와 **가로, 세로 크기(Width, Height)**를 픽셀 단위로 입력해야 합니다.
이 좌표는 그림판이나 다른 화면 캡처 도구를 사용하여 미리 알아두는 것이 좋습니다.
로깅 시작: '시작' 버튼을 클릭합니다.
버튼이 '중지'로 바뀌고, 10초마다 지정된 프로그램의 해당 영역을 읽어 OCR을 수행합니다.
인식된 텍스트는 프로그램 실행 파일(exe)이 있는 폴더에 datalog.txt라는 이름의 파일로 자동 저장됩니다.
안정성을 위한 추가 제안
정확한 창 제목: FindWindow 함수는 창 제목이 정확히 일치해야 합니다. 일부 프로그램은 상태에 따라 창 제목이 약간씩 바뀔 수 있으니, 고정적인 부분만 입력하거나 다른 방식으로 창을 찾는 방법을 고려해야 할 수 있습니다.
OCR 정확도 높이기:
캡처 영역을 숫자 부분만 타이트하게 잡을수록 인식률이 올라갑니다.
만약 배경색과 글자색의 대비가 낮다면, 이미지 처리(예: 흑백 변환, 대비 조절)를 OCR 수행 전에 추가하면 정확도를 높일 수 있습니다.