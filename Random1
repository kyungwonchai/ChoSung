++에서 해시 테이블을 구현할 때 충돌 해결 방법에는 여러 가지가 있습니다. 가장 많이 사용되는 방법은 **체이닝(Chaining)**과 **개방 주소법(Open Addressing)**입니다.

1. 체이닝(Chaining, 링크드 리스트 사용)
방법: 같은 해시 인덱스(버킷)에 충돌이 발생하면, 해당 인덱스에 **링크드 리스트(혹은 동적 컨테이너 like std::vector)**를 사용하여 여러 개의 데이터를 저장합니다.
장점:
테이블 크기에 크게 의존하지 않으며, 다양한 크기의 데이터를 유연하게 저장 가능.
삭제가 간단하며, 공간 효율성이 높음.
단점:
링크드 리스트를 사용하면 **캐시 효율(cache efficiency)**이 낮아질 수 있음.
메모리 오버헤드가 있음(포인터 저장 공간 필요).
cpp
코드 복사
#include <iostream>
#include <list>
#include <vector>

class HashTable {
private:
    static const int TABLE_SIZE = 10;
    std::vector<std::list<int>> table; // 체이닝 방식 (링크드 리스트)

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    HashTable() : table(TABLE_SIZE) {}

    void insert(int key) {
        int index = hashFunction(key);
        table[index].push_back(key);
    }

    bool search(int key) {
        int index = hashFunction(key);
        for (int value : table[index]) {
            if (value == key) return true;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);
    std::cout << ht.search(20); // 1 (true)
}
2. 개방 주소법(Open Addressing)
방법: 충돌이 발생하면 다른 빈 슬롯을 찾아서 저장하는 방식.

대표적인 방법:

선형 탐색(Linear Probing): 충돌 발생 시 다음 빈 슬롯을 찾음.
이차 탐색(Quadratic Probing): 충돌 발생 시 
𝑖
2
i 
2
  만큼 점프.
이중 해싱(Double Hashing): 2개의 해시 함수를 사용하여 새로운 인덱스를 계산.
장점:

별도의 리스트를 사용하지 않아 캐시 효율이 좋음.
작은 크기의 테이블에서도 충돌 처리가 가능.
단점:

테이블이 꽉 차면 성능이 급격히 저하됨.
삭제 시 탐색 성능이 저하될 가능성이 있음.
cpp
코드 복사
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0};

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    void insert(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) {
            index = (index + 1) % TABLE_SIZE; // Linear Probing
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) {
            if (table[index] == key) return true;
            index = (index + 1) % TABLE_SIZE;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);
    std::cout << ht.search(20); // 1 (true)
}
3. 어떤 방법이 더 좋은가?
방법	장점	단점	적절한 상황
체이닝(Chaining)	삭제가 쉬움, 테이블 크기에 제한 없음	메모리 오버헤드, 캐시 비효율적	동적 크기가 필요한 경우
선형 탐색(Linear Probing)	캐시 효율 높음, 구현 쉬움	클러스터링 문제(한 곳에 몰리는 현상)	충돌이 적은 경우
이차 탐색(Quadratic Probing)	클러스터링 줄어듦	충돌이 많으면 성능 저하	테이블이 충분히 클 때
이중 해싱(Double Hashing)	충돌 분산 효과 좋음	해시 함수 2개 필요	강력한 충돌 방지 필요할 때
결론:

일반적으로 충돌이 적으면 **개방 주소법(Open Addressing)**이 빠르고 효율적.
충돌이 많으면 체이닝(Chaining)이 안정적이며 삭제도 용이.
동적 크기 확장이 필요하면 체이닝을 고려.
추가 팁

C++에서는 std::unordered_map이 기본적으로 체이닝을 사용하므로 직접 구현할 필요가 없는 경우가 많음.
테이블이 가득 찰 가능성이 크다면 체이닝이 유리함.
해시 함수 성능이 중요하며, 좋은 해시 함수가 있다면 개방 주소법도 충분히 효과적.
✅ 추천
공간이 충분하다면? → 개방 주소법
동적 크기 확장이 필요하면? → 체이닝