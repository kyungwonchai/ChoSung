했습니다. 기존 코드를 바탕으로 커스텀 프로그래스바를 추가하고, 파일 삭제 시 프로그래스바를 갱신하도록 수정하겠습니다. 또한, UI 업데이트 시 쓰레드와 바인딩을 고려하겠습니다.

1. CustomProgressBar.xaml
커스텀 프로그래스바 XAML
xml
코드 복사
<UserControl x:Class="SMDFileCleaner.CustomProgressBar"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             Height="50" Width="400">
    <Grid>
        <ProgressBar x:Name="ProgressBar" Height="30" VerticalAlignment="Center" HorizontalAlignment="Stretch"/>
        <TextBlock x:Name="TextBlock" VerticalAlignment="Center" HorizontalAlignment="Center" Foreground="White" FontWeight="Bold"/>
        <Rectangle x:Name="SafeLine" Stroke="Red" StrokeThickness="2" VerticalAlignment="Stretch" Width="2"/>
    </Grid>
</UserControl>
2. CustomProgressBar.xaml.cs
커스텀 프로그래스바 코드 비하인드
csharp
코드 복사
using System.Windows;
using System.Windows.Controls;

namespace SMDFileCleaner
{
    public partial class CustomProgressBar : UserControl
    {
        public CustomProgressBar()
        {
            InitializeComponent();
        }

        public void UpdateProgress(double usedPercentage, double safePercentage)
        {
            ProgressBar.Value = usedPercentage;
            TextBlock.Text = $"{usedPercentage:0.##}%";

            double safePosition = safePercentage * ProgressBar.ActualWidth / 100;
            SafeLine.Margin = new Thickness(safePosition, 0, 0, 0);
        }
    }
}
3. MainWindow.xaml
MainWindow에 커스텀 프로그래스바 추가
xml
코드 복사
<Window x:Class="SMDFileCleaner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:SMDFileCleaner"
        Title="SMD File Cleaner" Height="500" Width="525">
    <Grid>
        <ComboBox x:Name="cbFolderPaths" HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" Width="400" Height="100" IsEditable="True" TextWrapping="Wrap" AcceptsReturn="True"/>
        <Button x:Name="btnApplyFolders" Content="Apply Folders" HorizontalAlignment="Left" Margin="420,10,0,0" VerticalAlignment="Top" Width="75" Click="btnApplyFolders_Click"/>
        
        <TextBox x:Name="txtRegexPatterns" HorizontalAlignment="Left" Height="50" Margin="10,120,0,0" VerticalAlignment="Top" Width="400" TextWrapping="Wrap" AcceptsReturn="True"/>
        <Button x:Name="btnApplyRegexPatterns" Content="Apply Regex" HorizontalAlignment="Left" Margin="420,120,0,0" VerticalAlignment="Top" Width="75" Click="btnApplyRegexPatterns_Click"/>
        
        <Button x:Name="btnStart" Content="Start" HorizontalAlignment="Left" Margin="10,180,0,0" VerticalAlignment="Top" Width="75" Click="btnStart_Click"/>

        <local:CustomProgressBar x:Name="ProgressBar" HorizontalAlignment="Left" Margin="10,220,0,0" VerticalAlignment="Top"/>
    </Grid>
</Window>
4. MainWindow.xaml.cs
MainWindow에 프로그래스바 갱신 로직 추가
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private FileCleaner _fileCleaner;
        private List<string> _folderPaths = new List<string>();
        private List<Regex> _regexPatterns = new List<Regex>();
        private const string ConfigFilePath = "config.txt";
        private const long SafeFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB
        private long _totalDiskSpace;
        private long _freeDiskSpace;

        public MainWindow()
        {
            InitializeComponent();
            _fileCleaner = new FileCleaner();
            LoadConfig();
            CheckFolderPaths();
            InitializeDiskSpace();
        }

        private void InitializeDiskSpace()
        {
            _totalDiskSpace = GetTotalDiskSpace("D:\\"); // 예시로 D 드라이브 사용
            _freeDiskSpace = GetFreeDiskSpace("D:\\");
            UpdateProgressBar();
        }

        private long GetTotalDiskSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.TotalSize;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Failed to get total disk space: " + ex.Message);
                return 0;
            }
        }

        private long GetFreeDiskSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Failed to get free disk space: " + ex.Message);
                return 0;
            }
        }

        private void btnApplyFolders_Click(object sender, RoutedEventArgs e)
        {
            _folderPaths = cbFolderPaths.Text.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries).Take(5).ToList();
            CheckFolderPaths();
            SaveConfig();
            MessageBox.Show("폴더 경로가 저장되었습니다.", "정보", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void btnApplyRegexPatterns_Click(object sender, RoutedEventArgs e)
        {
            var patterns = txtRegexPatterns.Text.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries).Take(2).ToList();
            _regexPatterns = patterns.Select(p => new Regex(p)).ToList();
            SaveConfig();
            MessageBox.Show("정규식 패턴이 저장되었습니다.", "정보", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (_folderPaths.Count == 0 || _regexPatterns.Count == 0)
            {
                MessageBox.Show("폴더와 정규식을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            StartFileDeletion();
        }

        private void StartFileDeletion()
        {
            try
            {
                foreach (var folderPath in _folderPaths)
                {
                    foreach (var regex in _regexPatterns)
                    {
                        var filesToDelete = _fileCleaner.GetFilesToDelete(folderPath, regex);
                        if (filesToDelete.Count >= 10)
                        {
                            _fileCleaner.DeleteFilesAsync(filesToDelete, folderPath).Wait();
                            _freeDiskSpace = GetFreeDiskSpace("D:\\");
                            UpdateProgressBar();
                        }
                    }
                }
                MessageBox.Show("파일 삭제 완료.", "완료", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show("파일 삭제 중 오류 발생: " + ex.Message, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void CheckFolderPaths()
        {
            var validPaths = _folderPaths.Where(Directory.Exists).ToList();
            _folderPaths = validPaths;
            cbFolderPaths.ItemsSource = validPaths;
        }

        private void SaveConfig()
        {
            var lines = _folderPaths.Concat(_regexPatterns.Select(r => r.ToString())).ToList();
            File.WriteAllLines(ConfigFilePath, lines);
        }

        private void LoadConfig()
        {
            if (File.Exists(ConfigFilePath))
            {
                var lines = File.ReadAllLines(ConfigFilePath).ToList();
                if (lines.Count > 0)
                {
                    _folderPaths = lines.Take(5).ToList();
                    _regexPatterns = lines.Skip(5).Take(2).Select(p => new Regex(p)).ToList();

                    cbFolderPaths.ItemsSource = _folderPaths;
                    txtRegexPatterns.Text = string.join(Environment.NewLine, _regexPatterns.Select(r => r.ToString()));
                }
            }
        }

        private void UpdateProgressBar()
        {
            double usedPercentage = (double)(_totalDiskSpace - _freeDiskSpace) / _totalDiskSpace * 100;
            double safePercentage = (double)(_totalDiskSpace - SafeFreeSpace) / _totalDiskSpace * 100;
            ProgressBar.UpdateProgress(usedPercentage, safePercentage);
        }
    }
}
5. FileCleaner.cs
파일 삭제 시 프로그래스바 갱신 로직 추가
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MinimumFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB
        private const long MaxFolderSize = 8L * 1024 * 1024 * 1024; // 8 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;
        private readonly Logger logger;
        private readonly Action<long, string> updateFolderStatistics;
        private readonly Action updateProgressBar;

        public FileCleaner(string logDirectory, MLModelBuilder mlModelBuilder, Dispatcher dispatcher, Logger logger, Action<long, string> updateFolderStatistics, Action updateProgressBar)
        {
            this.logDirectory = logDirectory;
            this.mlModelBuilder = mlModelBuilder;
            this.dispatcher = dispatcher;
            this.logger = logger;
            this.updateFolderStatistics = updateFolderStatistics;
            this.updateProgressBar = updateProgressBar;
        }

        public long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get drive free space: " + ex.Message);
                return 0;
            }
        }

        public List<FileInfo> GetFilesToDelete(string folderPath, Regex regex, bool forceDelete = false)
        {
            try
            {
                var files = GetFiles(folderPath, regex);
                var filesToDelete = files.Where(file => forceDelete || file.CreationTime < DateTime.Now.AddDays(-35)).OrderBy(file => file.CreationTime).ToList();

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(files.Sum(f => f.Length), folderPath);
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get files to delete: " + ex.Message);
                return new List<FileInfo>();
            }
        }

        private IEnumerable<FileInfo> GetFiles(string folderPath, Regex regex)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles("*", SearchOption.AllDirectories)
                    .Where(f => f.Length > 500 * 1024 && regex.IsMatch(f.FullName))); // 500KB 이상의 파일 중 정규식과 일치하는 파일

            }
            catch (UnauthorizedAccessException ex)
            {
                logger.LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        public async Task DeleteFilesAsync(List<FileInfo> files, string folderPath, bool forceDelete = false)
        {
            long currentFolderSize = files.Sum(f => f.Length);
            long freeSpace = GetDriveFreeSpace(folderPath.Split('\\')[0] + "\\");

            foreach (var file in files)
            {
                if (currentFolderSize <= MaxFolderSize && !forceDelete)
                {
                    logger.LogRecentActivity("현재 폴더 크기가 8GB 이하입니다.");
                    break;
                }

                if (freeSpace > MinimumFreeSpace && !forceDelete)
                {
                    logger.LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 삭제를 하지 않습니다.");
                    break;
                }

                try
                {
                    file.Delete();
                    currentFolderSize -= file.Length;
                    logger.LogDeletionActivity($"파일 삭제됨: {file.FullName}");
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                    dispatcher.Invoke(() => updateProgressBar());
                }
                catch (Exception ex)
                {
                    logger.LogError("Failed to delete file: " + ex.Message);
                }
            }

            updateFolderStatistics(currentFolderSize, folderPath);
        }

        public void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, new Regex($".*\\.{fileExtension}$"));
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(totalSize, folderPath);
                });
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to update folder statistics: " + ex.Message);
            }
        }
    }
}
설명
CustomProgressBar.xaml: 커스텀 프로그래스바를 정의합니다. 프로그래스바와 텍스트블록, 그리고 안전 용량 선을 포함합니다.
CustomProgressBar.xaml.cs: 프로그래스바를 갱신하는 메서드를 정의합니다. 사용된 퍼센티지와 안전 퍼센티지를 받아 프로그래스바와 선을 업데이트합니다.
MainWindow.xaml: MainWindow에 커스텀 프로그래스바를 추가합니다.
MainWindow.xaml.cs: MainWindow에 프로그래스바 갱신 로직을 추가하고, 파일 삭제 시 프로그래스바를 갱신합니다.
FileCleaner.cs: 파일 삭제 시 프로그래스바를 갱신하는 로직을 추가합니다.
이제 프로그램은 선택한 폴더가 차지하는 전체 용량과 HDD의 전체 용량 대비 잔량을 표시하고, 안전 용량 수준까지 선으로 표시하며, 파일 삭제 시 프로그래스바가 갱신됩니다.