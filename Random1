한 지적 감사합니다. 중단점을 통해 LogViewModel의 LoadLogsAsync 메서드 내 finally 블록에서 RaiseCanExecuteChanged()가 호출되면서 문제가 발생하는 것을 확인하셨군요.

문제 원인:

finally 블록은 try 블록의 성공/실패/취소 여부와 관계없이 항상 실행됩니다. 프로그램 종료 시 Dispose 메서드가 호출되어 _disposed 플래그가 설정되고 CancellationToken이 취소되더라도, 만약 LoadLogsAsync의 await 부분이 Dispose 호출 직후에 완료되면 finally 블록이 실행될 수 있습니다. 이때 RaiseCanExecuteChanged()는 내부적으로 WPF의 CommandManager를 사용하는데, 애플리케이션 종료 중에는 이 CommandManager나 관련 UI 디스패처가 이미 종료되었거나 불안정한 상태일 수 있어 오류가 발생할 수 있습니다. 또한, 종료 시점에는 UI 업데이트가 더 이상 의미가 없습니다.

해결 방법:

LoadLogsAsync 메서드의 finally 블록에서 RaiseCanExecuteChanged() 호출을 제거합니다. 종료 시점에는 Command의 실행 가능 상태를 갱신할 필요가 없습니다.

수정해야 할 파일 목록:

ViewModels/LogViewModel.cs
아래에 수정된 LogViewModel.cs 파일의 전체 코드를 주석 없이 작성합니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Data.SqlClient;
using System.Data.Entity.Core;

namespace LockerManagementApp.ViewModels
{
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private ObservableCollection<AuditLog> _auditLogs;
        private string _statusMessage;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;

        public ObservableCollection<AuditLog> AuditLogs { get => _auditLogs; set => SetProperty(ref _auditLogs, value); }
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        public LogViewModel()
        {
            AuditLogs = new ObservableCollection<AuditLog>();
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[Log] DB 연결 오류!"; LoadLogsCommand = new RelayCommand(_ => { }, _ => !_disposed); return; }
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync(), CanExecuteLoadLogs); // CanExecute 메서드 사용
            if (_context != null) { _ = LoadLogsAsync(); }
        }

        public async Task LoadLogsAsync()
        {
            if (!CanExecuteLoadLogs()) return;
            StatusMessage = "로그 로딩 중...";
            (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged();

            List<AuditLog> logs = null;
            try
            {
                if (!CanExecuteLoadLogs()) return;

                logs = await _context.AuditLogs
                                     .OrderByDescending(log => log.Timestamp)
                                     .Take(1000)
                                     .AsNoTracking()
                                     .ToListAsync(_cts.Token);

                if (_disposed || _cts.IsCancellationRequested) { Debug.WriteLine("LoadLogsAsync 작업 취소됨 (await 이후)."); return; }

                Application.Current.Dispatcher.Invoke(() =>
                {
                    if (_disposed || _cts.IsCancellationRequested) return;
                    AuditLogs = new ObservableCollection<AuditLog>(logs);
                    StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
                });
            }
            catch (OperationCanceledException) { Debug.WriteLine("LoadLogsAsync 작업 취소됨."); if (!_disposed) StatusMessage = "로그 로딩 취소됨."; }
            catch (ObjectDisposedException) { Debug.WriteLine("LoadLogsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusMessage = "로그 로딩 중 오류 발생 (컨텍스트 해제됨)."; }
            catch (SqlException sqlEx) { if (CanExecuteLoadLogs()) { StatusMessage = $"로그 로딩 DB 오류: {sqlEx.Message}"; MessageBox.Show(StatusMessage, "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (EntityException entityEx) { if (CanExecuteLoadLogs()) { StatusMessage = $"로그 로딩 EF 오류: {entityEx.Message}"; MessageBox.Show(StatusMessage, "EF 오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            catch (Exception ex) { if (CanExecuteLoadLogs()) { StatusMessage = $"로그 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
            finally
            {
                // *** 수정된 부분: finally 블록에서 RaiseCanExecuteChanged 제거 ***
                // 종료 시 여기서 오류가 발생할 수 있으므로 제거합니다.
                // if (!_disposed) (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged();
            }
        }

        private bool CanExecuteLoadLogs(object parameter = null) => !_disposed && _context != null;

        #region IDisposable 구현
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                 _disposed = true;
                if (disposing)
                {
                    Debug.WriteLine("LogViewModel Dispose 시작...");
                    _cts?.Cancel();
                    _cts?.Dispose();
                    _context?.Dispose();
                    Debug.WriteLine("LogViewModel 리소스 해제 완료.");
                }
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}

핵심 변경 사항:
