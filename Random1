래는 전체 WPF 애플리케이션의 C# 및 XAML 코드를 포함한 예제입니다. 이 코드는 요구 사항에 맞춰 D 드라이브의 여유 공간을 확인하고, 지정된 폴더의 jpg 파일을 삭제하며, 용량 정보를 표시하고, 로그를 기록하는 기능을 포함합니다.

MainWindow.xaml
xml
코드 복사
<Window x:Class="FileCleanupApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="File Cleanup App" Height="350" Width="525">
    <Grid>
        <StackPanel>
            <TextBlock Text="Total Used Size:" FontWeight="Bold" Margin="10"/>
            <TextBlock x:Name="lblTotalUsedSize" Margin="10"/>
            
            <TextBlock Text="Available Free Space:" FontWeight="Bold" Margin="10"/>
            <TextBlock x:Name="lblAvailableFreeSpace" Margin="10"/>
            
            <TextBlock Text="Additional Usable Space:" FontWeight="Bold" Margin="10"/>
            <TextBlock x:Name="lblAdditionalUsableSpace" Margin="10"/>
        </StackPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Threading;

namespace FileCleanupApp
{
    public partial class MainWindow : Window
    {
        private const string LogDirectory = @"C:\Agent\SMDFileAgent";
        private const long MinimumFreeSpaceInBytes = 20L * 1024 * 1024 * 1024; // 20GB
        private List<string> MonitoredFolders = new List<string> { @"D:\YourFolder1", @"D:\YourFolder2" };

        public MainWindow()
        {
            InitializeComponent();
            StartMonitoring();
        }

        private void StartMonitoring()
        {
            DispatcherTimer timer = new DispatcherTimer();
            timer.Interval = TimeSpan.FromMinutes(1);
            timer.Tick += (sender, args) =>
            {
                CheckAndFreeSpace();
                DisplayDiskUsage();
            };
            timer.Start();
        }

        private void CheckAndFreeSpace()
        {
            DriveInfo driveInfo = new DriveInfo(@"D:\");
            long availableFreeSpace = driveInfo.AvailableFreeSpace;

            if (availableFreeSpace < MinimumFreeSpaceInBytes)
            {
                foreach (var folder in MonitoredFolders)
                {
                    DeleteOldFiles(folder);
                }
            }
        }

        private void DeleteOldFiles(string folderPath)
        {
            try
            {
                DirectoryInfo dirInfo = new DirectoryInfo(folderPath);
                var files = dirInfo.GetFiles("*.jpg", SearchOption.AllDirectories)
                                   .OrderBy(f => f.CreationTime)
                                   .ToList();

                foreach (var file in files)
                {
                    if (new DriveInfo(@"D:\").AvailableFreeSpace >= MinimumFreeSpaceInBytes)
                    {
                        break;
                    }
                    file.Delete();
                    LogInfo($"Deleted file: {file.FullName}");
                }
            }
            catch (Exception ex)
            {
                LogError($"Error deleting files: {ex.Message}");
            }
        }

        private long GetDirectorySize(string folderPath)
        {
            long size = 0;
            try
            {
                DirectoryInfo dirInfo = new DirectoryInfo(folderPath);
                foreach (FileInfo fileInfo in dirInfo.GetFiles("*", SearchOption.AllDirectories))
                {
                    size += fileInfo.Length;
                }
            }
            catch (Exception ex)
            {
                LogError($"Error calculating directory size: {ex.Message}");
            }
            return size;
        }

        private void DisplayDiskUsage()
        {
            long totalUsedSize = MonitoredFolders.Sum(folder => GetDirectorySize(folder));
            long availableFreeSpace = new DriveInfo(@"D:\").AvailableFreeSpace;
            long additionalUsableSpace = availableFreeSpace - MinimumFreeSpaceInBytes;

            lblTotalUsedSize.Text = FormatBytes(totalUsedSize);
            lblAvailableFreeSpace.Text = FormatBytes(availableFreeSpace);
            lblAdditionalUsableSpace.Text = FormatBytes(additionalUsableSpace);
        }

        private string FormatBytes(long bytes)
        {
            if (bytes >= 1024 * 1024 * 1024)
                return $"{bytes / (1024 * 1024 * 1024)} GB";
            else if (bytes >= 1024 * 1024)
                return $"{bytes / (1024 * 1024)} MB";
            else if (bytes >= 1024)
                return $"{bytes / 1024} KB";
            else
                return $"{bytes} B";
        }

        private void LogInfo(string message)
        {
            Log(message, "INFO");
        }

        private void LogError(string message)
        {
            Log(message, "ERROR");
        }

        private void Log(string message, string level)
        {
            try
            {
                if (!Directory.Exists(LogDirectory))
                {
                    Directory.CreateDirectory(LogDirectory);
                }

                string logFilePath = Path.Combine(LogDirectory, $"{DateTime.Now:yyMMdd}.txt");
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} [{level}] {message}";

                File.AppendAllText(logFilePath, logMessage + Environment.NewLine);

                // Clean up old log files
                DeleteOldLogFiles();
            }
            catch
            {
                // Handle logging failure if needed
            }
        }

        private void DeleteOldLogFiles()
        {
            try
            {
                var logFiles = new DirectoryInfo(LogDirectory).GetFiles("*.txt")
                                  .OrderByDescending(f => f.CreationTime)
                                  .Skip(30)
                                  .ToList();

                foreach (var file in logFiles)
                {
                    file.Delete();
                }
            }
            catch (Exception ex)
            {
                // Handle cleanup failure if needed
            }
        }
    }
}
이 코드는 모든 요구 사항을 충족시키기 위해 설계되었습니다. 주기적으로 폴더의 용량을 확인하고, 용량 정보와 여유 공간을 표시하며, 로그를 작성하고 오래된 로그 파일을 삭제합니다. 이 프로젝트를 더 확장하거나 사용자 정의할 수 있습니다. 프로젝트에 포함된 폴더 경로나 기타 설정은 필요에 따라 조정할 수 있습니다