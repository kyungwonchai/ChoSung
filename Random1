수정 요청에 따라, 센서의 마우스 오버 상태가 변경될 때, PLC 시뮬레이터 내부의 값(R520, R521, R522)이 실제로 변경되도록 반영하여 상대방이 읽을 때 그 값이 제대로 반영되도록 구현하겠습니다. 즉, 마우스 오버로 램프 색상이 변경될 뿐만 아니라, PLC 시뮬레이터 내부 상태도 실제로 변경되도록 코드를 수정합니다.

MainWindow.xaml.cs (수정된 파일)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Windows;
using System.Windows.Media; // 색상 처리를 위해 필요
using System.Windows.Threading;
using System.Collections.Generic;

namespace PlcSimulation
{
    public partial class MainWindow : Window
    {
        private PlcSimulator _plcSimulator;  // PLC 시뮬레이터 객체
        private SerialPort _serialPort;      // 시리얼 통신 객체
        private DispatcherTimer _timer;      // 상태 업데이트 타이머
        private List<string> _logList;       // 로그 리스트 (최대 50개)

        public MainWindow()
        {
            InitializeComponent();

            // PLC 시뮬레이터 초기화
            _plcSimulator = new PlcSimulator();

            // 로그 리스트 초기화 (최대 50개 유지)
            _logList = new List<string>();

            // 시리얼 포트 설정 (COM19, 9600 Baudrate, 기본 통신 설정)
            _serialPort = new SerialPort("COM19", 9600)
            {
                DataBits = 8,
                Parity = Parity.None,
                StopBits = StopBits.One,
                Handshake = Handshake.None
            };

            // 시리얼 포트 데이터 수신 이벤트 핸들러 등록
            _serialPort.DataReceived += SerialPort_DataReceived;

            // 시리얼 포트 열기
            OpenSerialPort();

            // 타이머 설정 (1초마다 상태 업데이트)
            _timer = new DispatcherTimer();
            _timer.Interval = TimeSpan.FromSeconds(1);
            _timer.Tick += Timer_Tick;
            _timer.Start();
        }

        // 시리얼 포트 열기 메서드
        private void OpenSerialPort()
        {
            try
            {
                if (!_serialPort.IsOpen)
                {
                    _serialPort.Open();
                    AddLog("PLC Simulator connected to COM19.");
                }
            }
            catch (Exception ex)
            {
                AddLog("Error opening COM port: " + ex.Message);
            }
        }

        // 시리얼 포트 데이터 수신 처리
        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            try
            {
                string receivedData = _serialPort.ReadLine();  // 데이터 수신
                Dispatcher.Invoke(() => ProcessCommand(receivedData));  // UI 스레드에서 명령 처리
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => AddLog("Error reading from serial port: " + ex.Message));
            }
        }

        // 명령을 처리하고 응답하는 메서드
        private void ProcessCommand(string command)
        {
            string response = _plcSimulator.ProcessCommand(command);

            // 응답을 시리얼 포트로 전송
            if (_serialPort.IsOpen)
            {
                _serialPort.WriteLine(response);
            }

            // 로그에 기록
            AddLog($"Received: {command}, Response: {response}");
        }

        // 주기적으로 실행되는 타이머 이벤트 (UI 업데이트)
        private void Timer_Tick(object sender, EventArgs e)
        {
            // 센서 상태는 로그로 기록하지 않음. 상태가 변경되면 시각적으로만 처리.
        }

        // 센서 1 마우스 오버로 감지 (R520)
        private void Sensor1_MouseEnter(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 1);  // 감지됨
            SensorLamp1.Fill = Brushes.Green;  // 녹색 램프
        }

        // 센서 1 마우스 오버 해제 시 (R520 감지 안 됨)
        private void Sensor1_MouseLeave(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 0);  // 감지 안 됨
            SensorLamp1.Fill = Brushes.Gray;  // 회색 램프
        }

        // 센서 2 마우스 오버로 감지 (R521)
        private void Sensor2_MouseEnter(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R521", 1);  // 감지됨
            SensorLamp2.Fill = Brushes.Green;  // 녹색 램프
        }

        // 센서 2 마우스 오버 해제 시 (R521 감지 안 됨)
        private void Sensor2_MouseLeave(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R521", 0);  // 감지 안 됨
            SensorLamp2.Fill = Brushes.Gray;  // 회색 램프
        }

        // 센서 3 마우스 오버로 감지 (R522)
        private void Sensor3_MouseEnter(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R522", 1);  // 감지됨
            SensorLamp3.Fill = Brushes.Green;  // 녹색 램프
        }

        // 센서 3 마우스 오버 해제 시 (R522 감지 안 됨)
        private void Sensor3_MouseLeave(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R522", 0);  // 감지 안 됨
            SensorLamp3.Fill = Brushes.Gray;  // 회색 램프
        }

        // 로그 추가 메서드 (최대 50개 유지, 시간 정보 포함)
        private void AddLog(string message)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            string logEntry = $"{timestamp} - {message}";

            // 로그가 50개를 초과하면 가장 오래된 로그를 삭제
            if (_logList.Count >= 50)
            {
                _logList.RemoveAt(0);
            }

            // 로그 리스트에 추가하고 UI에 업데이트
            _logList.Insert(0, logEntry);  // 최근 로그가 맨 위에 위치
            LogListBox.ItemsSource = null; // UI 업데이트를 위해 먼저 null로 설정
            LogListBox.ItemsSource = _logList;
        }
    }
}
PlcSimulator.cs (수정된 PLC 시뮬레이터 동작 처리)
csharp
코드 복사
using System.Collections.Generic;

namespace PlcSimulation
{
    // PLC 시뮬레이터 클래스
    public class PlcSimulator
    {
        // PLC 메모리 시뮬레이션 (주소와 값 저장)
        private Dictionary<string, int> _plcMemory;

        // 생성자에서 메모리 초기화
        public PlcSimulator()
        {
            _plcMemory = new Dictionary<string, int>();

            // 초기 센서 값 설정 (0 = 감지 안 됨)
            _plcMemory["R520"] = 0;
            _plcMemory["R521"] = 0;
            _plcMemory["R522"] = 0;
        }

        // 명령어 처리
        public string ProcessCommand(string command)
        {
            // 쓰기 명령어 처리
            if (command.StartsWith("%01#WDD"))
            {
                return HandleWriteCommand(command);
            }
            // 읽기 명령어 처리
            else if (command.StartsWith("%01#RD"))
            {
                return HandleReadCommand(command);
            }

            return "Invalid Command";
        }

        // 쓰기 명령어 처리 메서드
        private string HandleWriteCommand(string command)
        {
            // 예: %01#WDD02300023000100** 에서 주소 2300과 값 0100을 추출
            string addressStr = command.Substring(7, 4); // 2300 주소
            string valueStr = command.Substring(15, 4);  // 0100 값

            // 주소와 값을 정수로 변환
            if (int.TryParse(addressStr, out int address) && int.TryParse(valueStr, out int value))
            {
                // 주소에 값을 저장
                _plcMemory[addressStr] = value;

                // 기본 응답 메시지
                return "$01SWD13";
            }

            return "Write Command Error";
        }

        // 읽기 명령어 처리 메서드
        private string HandleReadCommand(string command)
        {
            // 예: %01#RD0230** 에서 주소를 추출
            string addressStr = command.Substring(7, 4); // 읽을 주소

            // 주소에 해당하는 값을 반환
            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Value Not Found";
        }

        // PLC 메모리에서 주소 읽기
        public string ReadAddress(string addressStr)
        {
            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Invalid Address or Value Not Found";
        }

        // 센서 값을 설정하는 메서드 (예: R520, R521, R522 주소)
        public void SetSensorValue(string address, int value)
        {
            if (_plcMemory.ContainsKey(address))
            {
                _plcMemory[address] = value;
            }
        }

        // 센서 값을 읽는 메서드
        public int ReadSensorValue(string address)
        {
            if (_plcMemory.TryGetValue(address, out int value))
            {
                return value;
            }

            return 0;  // 기본값은 감지 안 됨
        }
    }
}
변경 사항 요약
PLC 내부 메모리 상태 업데이트:

센서의 상태를 마우스 오버 이벤트에 따라 변경할 때, 내부 메모리(R520, R521, R522)의 값을 실제로 변경합니다.
마우스가 센서 위에 있을 때는 해당 메모리에 1을, 마우스가 떠나면 0을 저장합니다.
시각적 피드백:

녹색으로 변경되면 감지 상태(1), 회색으로 변경되면 감지되지 않은 상태(0)를 나타냅니다.
시각적 변화와 함께, 내부 메모리 값도 실제로 업데이트되어 상대방이 읽을 때 올바른 값이 반환됩니다.
이제 이 코드를 통해, 센서 상태가 실제로 반영되고, 상