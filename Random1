의 지우개 기능을 제대로 구현하기 위해서는 지우개 모드를 활성화한 상태에서 그린 부분을 지우도록 처리해야 합니다. 이를 위해 pointerInteropFilter와 Canvas를 사용하여 올바르게 구현하겠습니다. 펜의 버튼을 감지하고, 버튼이 눌린 상태에서는 그린 부분을 지우도록 코드를 수정하겠습니다.

수정된 ImageDisplayScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.Canvas
import android.os.Build
import android.view.MotionEvent
import android.view.View
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.Path
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.input.pointer.pointerInteropFilter
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalView
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*
import kotlin.math.sqrt

data class DrawingPath(
    val points: List<Offset>,
    val color: Color,
    val isErasing: Boolean = false
)

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(true) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }
    var eraseMode by remember { mutableStateOf(false) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val view = LocalView.current
    val window = (context as? ComponentActivity)?.window
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier
        .fillMaxSize()
        .pointerInteropFilter { event ->
            when (event.action) {
                MotionEvent.ACTION_DOWN, MotionEvent.ACTION_MOVE -> {
                    eraseMode = event.buttonState == MotionEvent.BUTTON_SECONDARY
                }
                MotionEvent.ACTION_UP -> {
                    eraseMode = false
                }
            }
            false
        }
    ) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(Unit) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!eraseMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        Canvas(modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragStart = { offset ->
                        currentPathPoints = listOf(offset)
                    },
                    onDragEnd = {
                        if (currentPathPoints.isNotEmpty()) {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color, eraseMode)
                        }
                        currentPathPoints = listOf()
                    },
                    onDrag = { change, _ ->
                        currentPathPoints = currentPathPoints + change.position
                        change.consume()
                    }
                )
            }
        ) {
            // Draw all paths
            for (path in drawingPaths) {
                val drawPath = Path().apply {
                    moveTo(path.points.first().x, path.points.first().y)
                    for (point in path.points) {
                        lineTo(point.x, point.y)
                    }
                }
                drawPath(
                    path = drawPath,
                    color = if (path.isErasing) Color.Transparent else path.color,
                    style = Stroke(width = if (path.isErasing) 50f else 5f)
                )
            }

            // Draw current path
            if (currentPathPoints.isNotEmpty()) {
                val currentPath = Path().apply {
                    moveTo(currentPathPoints.first().x, currentPathPoints.first().y)
                    for (point in currentPathPoints) {
                        lineTo(point.x, point.y)
                    }
                }
                drawPath(
                    path = currentPath,
                    color = if (eraseMode) Color.Transparent else color,
                    style = Stroke(width = if (eraseMode) 50f else 5f)
                )
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(horizontal = 20.dp, vertical = 0.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    window?.let { captureAndUploadBitmap(it, view, scope) }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

fun captureAndUploadBitmap(window: android.view.Window, view: View, scope: CoroutineScope) {
    val bitmap = Bitmap.createBitmap(view.width, view.height, Bitmap.Config.ARGB_8888)
    val location = IntArray(2)
    view.getLocationInWindow(location)
    try {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            PixelCopy.request(
                window, android.graphics.Rect(
                    location[0], location[1],
                    location[0] + view.width, location[1] + view.height
                ), bitmap, { copyResult ->
                    if (copyResult == PixelCopy.SUCCESS) {
                        scope.launch {
                            uploadBitmap(bitmap)
                        }
                    }
                }, view.handler
            )
        } else {
            view.draw(Canvas(bitmap))
            scope.launch {
                uploadBitmap(bitmap)
            }
        }
    } catch (e: Exception) {
        e.printStackTrace()
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
위 코드에서 변경된 주요 사항:

DrawingPath 데이터 클래스에 isErasing 속성을 추가하여 지우개 모드를 구분합니다.
Canvas에서 drawingPaths와 currentPathPoints를 그릴 때, isErasing이 true인 경우 투명한 색상으로 그립니다.
pointerInteropFilter를 사용하여 펜의 버튼을 감지하고, 버튼이 눌린 상태에서 eraseMode를 활성화합니다.
detectDragGestures 콜백에서 onDragEnd 시점에 경로를 저장할 때 eraseMode 상태를 반영합니다.
이제 펜의 버튼을 누른 상태에서 그린 부분이 지워지며, 펜을 사용하여 정상적으로 그릴 수 있습니다.