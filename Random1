무한 루프를 사용해 10분마다 새로운 파일을 생성하면서 녹화를 지속합니다.
파일 생성 및 녹화 작업을 분리하여 10분 단위로 파일을 생성하는 구조로 수정합니다.
아래는 수정된 최종 코드입니다.

최종 수정 코드
csharp
코드 복사
using CefSharp.OffScreen;
using OpenCvSharp;
using System;
using System.Drawing;
using System.IO;
using System.Threading.Tasks;

public class ChromiumVideoCapture
{
    private CefSharp.OffScreen.ChromiumWebBrowser webView;
    private bool isRecording = false;
    private readonly int width = 1920;
    private readonly int height = 1080;
    private const int frameRate = 3; // 1초에 3프레임 설정
    private const int captureInterval = 333; // 1초를 3등분하여 333ms마다 캡처

    public async Task StartCaptureAsync(string url)
    {
        // 오프스크린 브라우저 초기화
        webView = new CefSharp.OffScreen.ChromiumWebBrowser(url);
        webView.Size = new System.Drawing.Size(width, height);

        // 브라우저 로드 대기
        await webView.WaitForInitialLoadAsync();
        isRecording = true;

        while (isRecording)
        {
            await RecordForTenMinutesAsync(); // 10분마다 새 파일 생성 및 녹화
            CleanupOldFolders(); // 최대 5일 보관된 폴더 삭제
        }
    }

    private async Task RecordForTenMinutesAsync()
    {
        string folderPath = GetFolderPath();
        string videoPath = Path.Combine(folderPath, $"ACR_{DateTime.Now:yyMMdd_HHmmss}.avi");

        // 비디오 라이팅 초기화 (프레임 레이트와 캡처 간격이 일치해야 함)
        using (var videoWriter = new VideoWriter(videoPath, VideoWriter.Fourcc('M', 'J', 'P', 'G'), frameRate, new OpenCvSharp.Size(width, height), true))
        {
            DateTime endTime = DateTime.Now.AddMinutes(10); // 10분 동안 녹화
            while (DateTime.Now < endTime && isRecording)
            {
                var bitmap = await TakeScreenshotAsync(); // 프레임 캡처
                var frame = BitmapToMat(bitmap); // 프레임을 Mat 형식으로 변환

                if (!frame.Empty())
                {
                    videoWriter.Write(frame); // 프레임을 비디오에 저장
                    frame.Dispose();
                }
                else
                {
                    Console.WriteLine("프레임이 비어 있습니다. 캡처 실패.");
                }

                // 다음 프레임 캡처까지 기다림 (333ms 간격)
                await Task.Delay(captureInterval);
            }
        }
    }

    private async Task<System.Drawing.Bitmap> TakeScreenshotAsync()
    {
        // 스크린샷을 비동기적으로 캡처합니다.
        var screenshot = await webView.CaptureScreenshotAsync();
        using (var memoryStream = new MemoryStream(screenshot))
        {
            return new System.Drawing.Bitmap(memoryStream);
        }
    }

    private Mat BitmapToMat(System.Drawing.Bitmap bitmap)
    {
        // Bitmap을 Mat으로 변환하는 방법을 직접 구현합니다.
        Mat mat = new Mat(bitmap.Height, bitmap.Width, MatType.CV_8UC3);
        for (int y = 0; y < bitmap.Height; y++)
        {
            for (int x = 0; x < bitmap.Width; x++)
            {
                System.Drawing.Color color = bitmap.GetPixel(x, y);
                mat.Set(y, x, new Vec3b(color.B, color.G, color.R));
            }
        }
        return mat;
    }

    private string GetFolderPath()
    {
        // 날짜별 폴더 경로를 생성합니다.
        string dateFolder = DateTime.Now.ToString("yyyyMMdd");
        string baseFolder = @"D:\VideoRecords";
        string fullPath = Path.Combine(baseFolder, dateFolder);

        // 폴더가 없으면 생성합니다.
        if (!Directory.Exists(fullPath))
        {
            Directory.CreateDirectory(fullPath);
        }

        return fullPath;
    }

    private void CleanupOldFolders()
    {
        string baseFolder = @"D:\VideoRecords";
        var directories = Directory.GetDirectories(baseFolder);

        foreach (var dir in directories)
        {
            DateTime dirDate;
            string folderName = new DirectoryInfo(dir).Name;

            // 폴더 이름을 날짜로 변환하여 5일 이상 경과한 폴더는 삭제
            if (DateTime.TryParseExact(folderName, "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out dirDate))
            {
                if ((DateTime.Now - dirDate).TotalDays > 5)
                {
                    Directory.Delete(dir, true);
                }
            }
        }
    }

    public void StopCapture()
    {
        isRecording = false;
        webView?.Dispose();
    }
}
수정된 사항 설명
10분마다 새 파일 생성:

StartCaptureAsync 메서드에서 while (isRecording) 루프를 사용해 계속 실행되도록 하고, 10분마다 RecordForTenMinutesAsync() 메서드를 호출하여 새 파일을 생성합니다.
RecordForTenMinutesAsync() 메서드가 호출될 때마다 새 파일을 생성하여 10분 동안 녹화한 후 종료됩니다.
비디오 파일 관리:

RecordForTenMinutesAsync()는 using 블록을 통해 videoWriter를 매번 새로 초기화하여 10분 녹화 후 자동으로 파일을 닫습니다.
폴더 정리:

매번 10분 녹화 후 CleanupOldFolders 메서드를 호출하여 5일이 지난 폴더는 삭제되도록 합니다.
캡처 간격 및 프레임 레이트 일치:

1초에 3프레임을 캡처하여 프레임 간격과 캡처 속도가 일치하도록 유지했습니다.
실행 예시
csharp
코드 복사
public async Task Main()
{
    var capture = new ChromiumVideoCapture();
    await capture.StartCaptureAsync("http://실제_웹_주소_여기에_입력");
    // 녹화를 중지하고 싶을 때는 capture.StopCapture();를 호출하세요.
}
추가 설명
이제 이 코드로 연속적인 10분 녹화가