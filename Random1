아래는 처음 실행 시 파일을 읽어 초기 데이터를 로드한 후, 이벤트가 발생하면 해당 데이터를 UI에 반영하도록 구현한 구조입니다. MergeOIErrLogManager는 파일 기반 초기화를 수행하고, 이후 이벤트 기반으로 데이터를 갱신합니다.

1. MergeOIErrLogManager (로그 관리 클래스)
이 클래스는 초기 데이터를 로드하며, 이벤트 기반으로 데이터를 갱신하도록 설계되었습니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly string _logDirectory = @"C:\prod_file_logs"; // 로그 폴더 경로
    private readonly object _lock = new object(); // 스레드 동기화용
    private DateTime _lastLogTime = DateTime.MinValue; // 마지막 처리된 로그 시간

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 초기화: 파일에서 초기 데이터 로드
    /// </summary>
    public async Task InitializeAsync()
    {
        await LoadLogsFromFilesAsync(); // 초기 데이터 로드
    }

    /// <summary>
    /// 외부 이벤트로 새로운 로그 추가
    /// </summary>
    /// <param name="logLine">새로운 로그 라인</param>
    public void AddLog(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            // UI 스레드에서 데이터 추가
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_lock)
                {
                    LogEntries.Add(newEntry);

                    // 오래된 로그 삭제 (최근 2일치만 유지)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 초기 데이터: 최근 2일치 로그 파일에서 읽기
    /// </summary>
    private async Task LoadLogsFromFilesAsync()
    {
        try
        {
            // 최근 2일치 폴더 검색
            var targetDates = Enumerable.Range(0, 2)
                                        .Select(offset => DateTime.Now.AddDays(-offset).ToString("yyyyMMdd"))
                                        .ToList();
            var files = targetDates.Select(date => Path.Combine(_logDirectory, $"{date}.txt"))
                                   .Where(File.Exists)
                                   .ToList();

            var allLines = new List<string>();
            foreach (var file in files)
            {
                // 파일의 모든 라인 읽기
                var lines = await Task.Run(() => File.ReadAllLines(file));
                allLines.AddRange(lines);
            }

            // 새로운 로그 필터링
            var parsedEntries = allLines
                .Where(line => !string.IsNullOrWhiteSpace(line))
                .Select(ParseLogLine)
                .Where(entry => entry != null)
                .OrderByDescending(entry => entry.Time) // 시간 내림차순
                .ToList();

            // UI 스레드에서 데이터 갱신
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_lock)
                {
                    LogEntries.Clear();
                    foreach (var entry in parsedEntries)
                    {
                        LogEntries.Add(entry);
                    }
                }
            });

            // 마지막 시간 업데이트
            if (parsedEntries.Any())
            {
                _lastLogTime = parsedEntries.Max(entry => entry.Time);
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"로그 처리 중 오류 발생: {ex.Message}");
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. MainViewModel
뷰모델은 MergeOIErrLogManager를 초기화하고, UI와 데이터 바인딩을 설정합니다. 이벤트로 로그를 추가하는 AddLogEvent도 구현했습니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    public MergeOIErrLogManager LogManager { get; private set; }

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => LogManager.LogEntries;

    public MainViewModel()
    {
        LogManager = new MergeOIErrLogManager();

        // 비동기 초기화
        Task.Run(async () => await LogManager.InitializeAsync());
    }

    /// <summary>
    /// 외부에서 로그 추가 이벤트 발생 시 호출
    /// </summary>
    /// <param name="logLine">추가할 로그 라인</param>
    public void AddLogEvent(string logLine)
    {
        LogManager.AddLog(logLine);
    }
}
3. XAML
LogEntries를 DataGrid에 바인딩하여 UI에서 로그를 표시합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- 시간 컬럼 -->
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <!-- 메시지 컬럼 -->
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <!-- 세부 내용 컬럼 -->
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
4. 코드 설명
초기 데이터 로드

InitializeAsync에서 최근 2일치 폴더를 검사해 초기 데이터를 LogEntries에 추가합니다.
이벤트 기반 추가

AddLog(string logLine) 메서드로 새 로그를 추가합니다.
외부에서 AddLogEvent 메서드를 호출하면 새로운 로그가 반영됩니다.
오래된 데이터 제거