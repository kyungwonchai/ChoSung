using LockerManagementApp.Data; // DbContext 네임스페이스
using LockerManagementApp.ViewModels; // ViewModel 네임스페이스
using LockerManagementApp.Views; // View 네임스페이스
using Microsoft.EntityFrameworkCore; // EF Core 관련 네임스페이스
using Microsoft.Extensions.Configuration; // 설정 관련 네임스페이스
using Microsoft.Extensions.DependencyInjection; // 의존성 주입 관련 네임스페이스
using Microsoft.Extensions.Hosting; // 호스트 관련 네임스페이스
using System;
using System.Diagnostics; // Debug.WriteLine 사용
using System.IO; // Path 사용
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading; // Dispatcher 관련 네임스페이스

namespace LockerManagementApp
{
    /// <summary>
    /// App.xaml에 대한 상호 작용 논리
    /// .NET 8 환경의 WPF 애플리케이션 진입점 역할을 하며,
    /// 호스트 설정, 의존성 주입 구성, 전역 예외 처리 등을 담당합니다.
    /// </summary>
    public partial class App : Application
    {
        private IHost? _host; // 애플리케이션 호스트 인스턴스

        /// <summary>
        /// App 클래스 생성자입니다.
        /// </summary>
        public App()
        {
            // 전역 예외 처리 핸들러를 설정합니다.
            SetupGlobalExceptionHandling();
        }

        /// <summary>
        /// 애플리케이션 시작 시 호출되는 이벤트 핸들러입니다.
        /// 호스트를 구성하고 시작하며, 메인 윈도우를 생성하고 표시합니다.
        /// </summary>
        private async void Application_Startup(object sender, StartupEventArgs e)
        {
            Debug.WriteLine("Application_Startup 시작"); // 디버그 출력

            // 호스트 빌더를 생성합니다.
            var hostBuilder = CreateHostBuilder(e.Args);
            try
            {
                // 호스트를 빌드하고 비동기적으로 시작합니다.
                _host = await hostBuilder.StartAsync();
                Debug.WriteLine("호스트 시작 완료.");
            }
            catch (Exception ex)
            {
                // 호스트 시작 중 예외 발생 시 처리
                LogAndShowException(ex, "Host Startup");
                Shutdown(); // 애플리케이션 종료
                return;
            }

            // MainWindow 인스턴스를 의존성 주입 컨테이너에서 가져옵니다.
            MainWindow? mainWindow = null; // Nullable 참조 형식 사용
            try
            {
                // GetService<T>는 등록되지 않은 경우 null을 반환합니다.
                mainWindow = _host.Services.GetService<MainWindow>();
                if (mainWindow == null)
                {
                    // MainWindow가 DI 컨테이너에 제대로 등록되지 않은 경우
                    Debug.WriteLine("MainWindow를 DI 컨테이너에서 가져오지 못했습니다.");
                    MessageBox.Show("메인 윈도우를 DI 컨테이너에서 찾을 수 없습니다. 서비스 등록을 확인하세요.", "시작 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    Shutdown();
                    return;
                }
                Debug.WriteLine("MainWindow 인스턴스 가져오기 성공.");
            }
            catch (Exception ex)
            {
                // MainWindow 생성 또는 의존성 주입 과정에서 예외 발생 시 처리
                // (예: MainViewModel 생성자에서 오류 발생 시)
                LogAndShowException(ex, "MainWindow Resolution/Creation");
                Shutdown();
                return;
            }

            // 메인 윈도우를 표시합니다.
            Debug.WriteLine("MainWindow.Show() 호출 시도.");
            try
            {
                 this.MainWindow = mainWindow; // 애플리케이션의 주 창으로 설정
                 mainWindow.Show();
                 Debug.WriteLine("MainWindow.Show() 호출 완료.");
            }
             catch (Exception ex)
            {
                // Show() 메서드 실행 중 예외 발생 시 처리 (매우 드묾)
                LogAndShowException(ex, "MainWindow.Show()");
                Shutdown();
            }
        }

        /// <summary>
        /// 애플리케이션 호스트 빌더를 생성하고 구성합니다.
        /// </summary>
        /// <param name="args">명령줄 인수</param>
        /// <returns>구성된 IHostBuilder 인스턴스</returns>
        public static IHostBuilder CreateHostBuilder(string[] args) =>
            Host.CreateDefaultBuilder(args) // 기본 호스트 설정을 사용합니다.
                // 애플리케이션 설정 파일을 구성합니다.
                .ConfigureAppConfiguration((context, config) =>
                {
                    // 설정 파일의 기본 경로를 애플리케이션 실행 디렉토리로 설정합니다.
                    config.SetBasePath(AppContext.BaseDirectory);
                    // appsettings.json 파일을 필수 설정 파일로 추가하고, 변경 시 다시 로드하도록 설정합니다.
                    config.AddJsonFile("appsettings.json", optional: false, reloadOnChange: true);
                    // 필요 시 환경별 설정 파일(예: appsettings.Development.json)을 추가할 수 있습니다.
                    // config.AddJsonFile($"appsettings.{context.HostingEnvironment.EnvironmentName}.json", optional: true, reloadOnChange: true);
                })
                // 의존성 주입을 위한 서비스를 구성합니다.
                .ConfigureServices((context, services) =>
                {
                    // 서비스 등록 로직을 별도 메서드로 분리하여 호출합니다.
                    ConfigureServices(context.Configuration, services);
                });

        /// <summary>
        /// 의존성 주입 컨테이너(IServiceCollection)에 서비스를 등록합니다.
        /// </summary>
        /// <param name="configuration">애플리케이션 설정 정보 (IConfiguration)</param>
        /// <param name="services">서비스 컬렉션 (IServiceCollection)</param>
        private static void ConfigureServices(IConfiguration configuration, IServiceCollection services)
        {
             try
            {
                // LockerDbContext를 서비스로 등록합니다.
                services.AddDbContext<LockerDbContext>(options =>
                    // appsettings.json에서 "LockerDbConnection" 이름의 연결 문자열을 사용하도록 설정합니다.
                    options.UseSqlServer(configuration.GetConnectionString("LockerDbConnection")),
                    // DbContext의 수명 주기를 Scoped로 설정합니다 (웹 요청 등 범위 내에서 동일 인스턴스 사용).
                    // 데스크톱 앱에서는 Transient와 유사하게 동작할 수 있으나 Scoped가 일반적입니다.
                    ServiceLifetime.Scoped);

                // MainViewModel을 Transient 서비스로 등록합니다 (요청 시마다 새 인스턴스 생성).
                services.AddTransient<MainViewModel>();

                // MainWindow를 Transient 서비스로 등록합니다 (요청 시마다 새 인스턴스 생성).
                services.AddTransient<MainWindow>();

                // 여기에 다른 필요한 서비스들을 등록할 수 있습니다.
                // 예: services.AddSingleton<IMySingletonService, MySingletonService>();
                // 예: services.AddScoped<IUserDataService, UserDataService>();

                Debug.WriteLine("서비스 등록 완료.");
            }
             catch (Exception ex)
            {
                 // 서비스 등록 과정에서 예외 발생 시 (예: 설정 파일 오류, 연결 문자열 이름 오류 등)
                 Debug.WriteLine($"서비스 등록 중 오류 발생: {ex.ToString()}");
                 // 이 단계의 오류는 잡기 어려울 수 있으므로, 예외를 다시 던져서
                 // Application_Startup에서 처리되도록 합니다.
                 throw;
            }
        }

        /// <summary>
        /// 애플리케이션 종료 시 호출되는 이벤트 핸들러입니다.
        /// 호스트를 정상적으로 중지하고 리소스를 해제합니다.
        /// </summary>
        private async void Application_Exit(object sender, ExitEventArgs e)
        {
            Debug.WriteLine("Application_Exit 시작");
            if (_host != null)
            {
                // using 블록을 사용하여 IHost의 Dispose 메서드 호출을 보장합니다.
                using (_host)
                {
                    // 호스트를 비동기적으로 중지합니다 (최대 5초 대기).
                    await _host.StopAsync(TimeSpan.FromSeconds(5));
                }
                _host = null; // 호스트 참조 제거
                Debug.WriteLine("호스트 중지 완료.");
            }
        }

        #region 전역 예외 처리 (Global Exception Handling)

        /// <summary>
        /// 처리되지 않은 예외를 처리하기 위한 전역 핸들러들을 설정합니다.
        /// </summary>
        private void SetupGlobalExceptionHandling()
        {
            // UI 스레드에서 발생하는 처리되지 않은 예외 처리
            DispatcherUnhandledException += (s, e) =>
            {
                LogAndShowException(e.Exception, "UI Thread Exception");
                // 예외를 처리했음을 시스템에 알립니다 (앱 비정상 종료 방지).
                // 단, 심각한 오류의 경우 앱을 종료하는 것이 더 안전할 수 있습니다.
                e.Handled = true;
            };

            // 백그라운드 스레드(Task)에서 발생하는 관찰되지 않은 예외 처리
            TaskScheduler.UnobservedTaskException += (s, e) =>
            {
                LogAndShowException(e.Exception, "Background Task Exception");
                // 예외가 관찰되었음을 표시하여 프로세스 종료를 방지합니다.
                e.SetObserved();
            };

            // 현재 애플리케이션 도메인에서 발생하는 처리되지 않은 예외 처리 (최후의 방어선)
            AppDomain.CurrentDomain.UnhandledException += (s, e) =>
            {
                // e.ExceptionObject는 object 타입이므로 Exception으로 캐스팅해야 합니다.
                LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception");
                // 이 단계에서는 앱 종료를 막기 어려울 수 있습니다.
            };
        }

        /// <summary>
        /// 예외 정보를 로그(디버그 출력)하고 사용자에게 메시지 박스로 알립니다.
        /// </summary>
        /// <param name="exception">발생한 예외 객체</param>
        /// <param name="source">예외 발생 출처 정보 문자열</param>
        private void LogAndShowException(Exception exception, string source)
        {
            // 예외의 상세 정보를 포함하여 문자열 생성 (ToString() 사용)
            string errorMessage = $"예기치 않은 오류가 발생했습니다 ({source}):\n\n{exception.ToString()}";

            // 디버그 출력 창에 오류 기록
            Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}");

            try
            {
                 // 사용자에게 오류 메시지 박스 표시
                 // 참고: 백그라운드 스레드에서 직접 MessageBox 호출 시 문제가 될 수 있으나,
                 //       간단한 로깅 목적 및 최후 수단으로 사용합니다.
                 //       안정적인 구현을 위해서는 UI 스레드로 전달하여 표시해야 합니다.
                 MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            catch (Exception msgEx)
            {
                 // 메시지 박스 표시 자체에서 오류 발생 시 디버그 출력
                 Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}");
            }
        }

        #endregion
    }