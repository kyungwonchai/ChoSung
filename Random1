using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using OpenCvSharp;
using OpenCvSharp.Extensions;

class Program
{
    // 마우스 클릭을 위한 WinAPI 호출
    [DllImport("user32.dll")]
    private static extern void SetCursorPos(int x, int y);

    [DllImport("user32.dll")]
    private static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);

    private const int MOUSEEVENTF_LEFTDOWN = 0x02;
    private const int MOUSEEVENTF_LEFTUP = 0x04;

    static async Task Main()
    {
        Bitmap screenshot = CaptureScreen();
        Mat image = BitmapConverter.ToMat(screenshot);

        await DetectAndClick(image);
    }

    /// <summary>
    /// 🖥️ 화면 캡처
    /// </summary>
    static Bitmap CaptureScreen()
    {
        Rectangle bounds = new Rectangle(817, 345, 1381 - 817, 545 - 345);
        Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);

        using (Graphics g = Graphics.FromImage(bitmap))
        {
            g.CopyFromScreen(bounds.X, bounds.Y, 0, 0, bounds.Size);
        }

        return bitmap;
    }

    /// <summary>
    /// 🔍 OpenCV로 숫자 감지 후 클릭
    /// </summary>
    static async Task DetectAndClick(Mat image)
    {
        Mat gray = new Mat();
        Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY); // 흑백 변환

        // 🛠 전처리 1: AdaptiveThreshold 적용 → 얇은 숫자 검출 강화
        Mat binary = new Mat();
        Cv2.AdaptiveThreshold(gray, binary, 255, AdaptiveThresholdTypes.GaussianC, ThresholdTypes.BinaryInv, 11, 2);

        // 🛠 전처리 2: 팽창 연산 → 작은 요소를 묶어서 숫자 인식 강화
        Mat kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new Size(2, 2));
        Cv2.MorphologyEx(binary, binary, MorphTypes.Dilate, kernel, new Point(-1, -1), 2);

        // 🛠 컨투어 검출 (윤곽선 찾기)
        Cv2.FindContours(binary, out Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

        List<Point> clickPositions = new List<Point>();

        // 표 좌표 범위
        int startX = 817, startY = 345, endX = 1381, endY = 545;
        int cellWidth = 80, cellHeight = 50;

        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);

            // 🔥 컨투어 필터링 (너무 작거나 밑줄 없는 것 제거)
            if (rect.Width > 15 && rect.Height > 20 && rect.Height < 50) // 밑줄이 포함된 크기 예상값
            {
                int centerX = startX + rect.X;
                int centerY = startY + rect.Y;
                clickPositions.Add(new Point(centerX, centerY));
            }
        }

        // ✅ 클릭 순서 정렬 (우측 → 좌측, 위에서 아래로 이동)
        clickPositions.Sort((a, b) =>
        {
            if (a.X == b.X) return a.Y.CompareTo(b.Y); // 같은 열이면 위에서 아래로 정렬
            return b.X.CompareTo(a.X); // 우측부터 클릭
        });

        // ✅ 클릭 실행
        foreach (var pos in clickPositions)
        {
            await ClickAsync(pos.X, pos.Y);
            await Task.Delay(50);
        }

        // ✅ 디버깅용 - 검출된 숫자 위치 초록 박스로 표시
        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);
            if (rect.Width > 15 && rect.Height > 20)
                Cv2.Rectangle(image, rect, new Scalar(0, 255, 0), 2);
        }

        Cv2.ImShow("Detected Numbers", image);
        Cv2.ImShow("Binary Mask", binary);
        Cv2.WaitKey(0);
        Cv2.DestroyAllWindows();
    }

    /// <summary>
    /// 🖱️ 비동기 마우스 클릭 (0.5초 이내 실행)
    /// </summary>
    static async Task ClickAsync(int x, int y)
    {
        await Task.Run(() =>
        {
            SetCursorPos(x, y);
            mouse_event(MOUSEEVENTF_LEFTDOWN, x, y, 0, 0);
            mouse_event(MOUSEEVENTF_LEFTUP, x, y, 0, 0);
        });

        Console.WriteLine($"클릭: X={x}, Y={y}");
    }