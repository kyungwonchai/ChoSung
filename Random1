하지만 일반적으로 C#에서는 하나의 파일에는 하나의 클래스(또는 인터페이스, 구조체 등)만 정의하는 것이 코드 구성 및 유지보수에 더 좋습니다. 특히 UserMemoInfo 클래스는 Memo 클래스처럼 클라이언트와 서버 양쪽 모두에서 사용될 수 있는 데이터 구조(DTO) 이므로, 이전에 만든 공유 모델 라이브러리 (MemoAppMGSP.SharedModels) 프로젝트 안에 별도의 파일(UserMemoInfo.cs)로 분리하는 것이 가장 이상적입니다.

**"별도 분리"**란 바로 이 UserMemoInfo 클래스 정의 부분을 IMemoService.cs 파일에서 떼어내어, MemoAppMGSP.SharedModels 프로젝트 안에 UserMemoInfo.cs라는 새 파일을 만들고 그 안에 옮겨 넣는 것을 의미합니다.

이제 분리된 UserMemoInfo.cs 파일과, UserMemoInfo 클래스 정의가 제거되고 using 문이 추가된 수정된 IMemoService.cs 파일의 전체 코드를 드리겠습니다.

1. MemoAppMGSP.SharedModels 프로젝트에 새로 만들 파일:

UserMemoInfo.cs (분리된 파일):

C#

// MemoAppMGSP.SharedModels/UserMemoInfo.cs
using System; // Guid 사용 시 필요할 수 있으나 현재는 Memo 모델만 사용

namespace MemoAppMGSP.SharedModels // *** 네임스페이스를 공유 모델 프로젝트로 변경 ***
{
    /// <summary>
    /// GetUserMemosWithStatusAsync 메서드의 반환 타입을 위한 클래스입니다.
    /// Memo 원본 정보와 사용자별 상태 정보를 함께 전달합니다.
    /// </summary>
    public class UserMemoInfo
    {
        /// <summary>
        /// 원본 메모 객체입니다.
        /// </summary>
        public Memo Memo { get; set; } // Memo 클래스도 동일 네임스페이스에 있어야 함

        /// <summary>
        /// 현재 사용자의 해당 메모 읽음 상태입니다.
        /// </summary>
        public bool IsRead { get; set; }

        /// <summary>
        /// 현재 사용자의 해당 메모 개인 보관 상태입니다.
        /// </summary>
        public bool IsPersonal { get; set; }

        // 필요 시 다른 UserMemo 상태 추가 가능 (예: IsDeletedByReceiver)
    }
}
설명:

이 파일은 MemoAppMGSP.SharedModels 프로젝트 안에 위치해야 합니다.
UserMemoInfo 클래스의 내용은 이전과 동일합니다.
네임스페이스가 MemoAppMGSP.SharedModels로 변경되었습니다.
이 클래스가 Memo 타입을 사용하므로, Memo.cs 파일도 MemoAppMGSP.SharedModels 프로젝트 안에 있어야 합니다.
2. 수정된 IMemoService.cs 파일:

파일 하단에 있던 UserMemoInfo 클래스 정의를 제거했습니다.
UserMemoInfo 타입을 사용하기 위해 using MemoAppMGSP.SharedModels; 문을 추가했습니다.
IMemoService.cs (수정된 원본):

C#

// MemoAppMGSP/Services/Interfaces/IMemoService.cs
using MemoAppMGSP.SharedModels; // *** 수정: UserMemoInfo가 있는 네임스페이스 using 추가 ***
using System; // Guid 등 기본 타입 사용
using System.Collections.Generic; // IEnumerable 사용
using System.Threading.Tasks; // Task 사용

namespace MemoAppMGSP.Services.Interfaces // 네임스페이스는 서비스 인터페이스 위치 그대로 유지
{
    /// <summary>
    /// 메모 데이터 및 관련 상태 관리를 위한 서비스 인터페이스입니다.
    /// </summary>
    public interface IMemoService
    {
        /// <summary>
        /// 특정 사용자가 받은 메모 목록과 각 메모에 대한 사용자별 상태 정보를 비동기적으로 가져옵니다.
        /// (구현 시: 사용자가 삭제 처리하지 않은 메모만 반환해야 함)
        /// </summary>
        /// <param name="userId">사용자 ID</param>
        /// <returns>메모 정보(Memo)와 상태(IsRead, IsPersonal)를 포함하는 UserMemoInfo 컬렉션 Task</returns>
        Task<IEnumerable<UserMemoInfo>> GetUserMemosWithStatusAsync(Guid userId); // UserMemoInfo 타입 사용

        /// <summary>
        /// ID를 기준으로 특정 메모의 원본 정보를 비동기적으로 가져옵니다.
        /// </summary>
        /// <param name="memoId">메모 ID</param>
        /// <returns>Memo 객체 Task, 없으면 null</returns>
        Task<Memo> GetMemoByIdAsync(Guid memoId); // Memo 타입 사용

        /// <summary>
        /// 새 메모를 비동기적으로 생성합니다.
        /// (구현 시 Memos 테이블과 UserMemos 테이블에 레코드 생성 필요)
        /// </summary>
        /// <param name="memo">생성할 메모 객체 (SenderId, ReceiverId 포함)</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> CreateMemoAsync(Memo memo); // Memo 타입 사용

        /// <summary>
        /// 기존 메모의 내용(제목, 본문 등)을 비동기적으로 업데이트합니다.
        /// (구현 시: Memos 테이블 업데이트)
        /// </summary>
        /// <param name="memo">업데이트할 메모 객체 (ID 포함)</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> UpdateMemoAsync(Memo memo); // Memo 타입 사용

        /// <summary>
        /// 특정 사용자의 특정 메모에 대한 읽음 상태를 비동기적으로 변경합니다.
        /// (구현 시: UserMemos 테이블 업데이트, ReadAtUtc 타임스탬프 기록 고려)
        /// </summary>
        /// <param name="userId">사용자 ID</param>
        /// <param name="memoId">메모 ID</param>
        /// <param name="isRead">설정할 읽음 상태</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> MarkMemoAsReadAsync(Guid userId, Guid memoId, bool isRead);

        /// <summary>
        /// 특정 사용자의 특정 메모에 대한 개인 보관 상태를 비동기적으로 변경합니다.
        /// (구현 시: UserMemos 테이블 업데이트, SavedAtUtc 타임스탬프 기록 고려)
        /// </summary>
        /// <param name="userId">사용자 ID</param>
        /// <param name="memoId">메모 ID</param>
        /// <param name="isPersonal">설정할 개인 보관 상태</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> SetPersonalStatusAsync(Guid userId, Guid memoId, bool isPersonal);

        /// <summary>
        /// 특정 사용자가 특정 메모를 삭제 처리(소프트 삭제)하도록 비동기적으로 요청합니다.
        /// (구현 시: UserMemos 테이블의 IsDeletedByReceiver 플래그 업데이트, DeletedAtUtc 타임스탬프 기록 고려)
        /// </summary>
        /// <param name="userId">사용자 ID (메모 수신자)</param>
        /// <param name="memoId">메모 ID</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> MarkMemoAsDeletedByReceiverAsync(Guid userId, Guid memoId);

        /// <summary>
        /// 보낸 사람이 특정 메모를 삭제 처리(소프트 삭제)하도록 비동기적으로 요청합니다.
        /// (구현 시: Memos 테이블의 IsDeletedBySender 플래그 업데이트)
        /// </summary>
        /// <param name="senderId">보낸 사람 ID (권한 확인용)</param>
        /// <param name="memoId">메모 ID</param>
        /// <returns>성공 여부 Task (True: 성공, False: 실패)</returns>
        Task<bool> MarkMemoAsDeletedBySenderAsync(Guid senderId, Guid memoId);
    }

    // --- !!! 파일 하단에 있던 UserMemoInfo 클래스 정의 제거됨 !!! ---

} // 네임스페이스 끝
이제 UserMemoInfo 클래스는 MemoAppMGSP.SharedModels 프로젝트의 UserMemoInfo.cs 파일에서 관리되고, IMemoService 인터페이스는 using 문을 통해 해당 클래스를 참조하여 사용하게 됩니다. 이렇게 구조를 잡는 것이 더 깔끔합니다.


소스 및 관련 콘텐츠
