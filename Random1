네, 아주 정확하게 현상을 파악하고 계십니다! VBA로 만든 사용자 정의 함수(UDF)의 코드를 수정한 후 파일을 저장해도, 해당 함수를 사용하고 있는 셀들의 값이 자동으로 바로 업데이트되지 않고, 셀을 다시 클릭해서 엔터를 치거나 수동으로 재계산을 해야 반영되는 것은 일반적인 현상입니다.

왜 이런 현상이 발생하나요?

기본적으로 VBA 사용자 정의 함수는 "비휘발성(Non-Volatile)"으로 취급됩니다. 이는 다음과 같은 의미입니다:

Excel은 해당 함수의 입력 값(인수)으로 사용된 셀의 값이 변경될 때만 함수를 재계산합니다.
함수의 코드 자체가 변경된 것을 Excel이 자동으로 감지하여 모든 관련 셀을 즉시 재계산하지는 않습니다.
자동으로 적용되게 하는 방법 (또는 유사한 효과를 내는 방법):

완벽하게 "코드 수정 즉시 모든 셀 자동 업데이트"는 어렵지만, 몇 가지 방법을 통해 이 문제를 해결하거나 개선할 수 있습니다.

수동 전체 재계산 (가장 확실한 방법 중 하나):

Ctrl + Alt + F9: 이 단축키는 모든 수식을 강제로 처음부터 다시 계산하도록 합니다. 의존성 트리를 다시 만들고 모든 계산을 수행하므로, 사용자 정의 함수의 코드가 변경되었을 때 가장 확실하게 업데이트하는 방법입니다.
Shift + F9: 현재 활성화된 시트만 재계산합니다.
F9: 열려 있는 모든 통합 문서에서 변경된 수식만 재계산합니다. (UDF 코드 변경 시 이것만으로는 부족할 수 있습니다.)
함수를 "휘발성(Volatile)"으로 만들기:
함수 코드의 시작 부분에 Application.Volatile을 추가하면, 해당 함수는 워크시트에서 어떤 계산이든 발생할 때마다 (예: 다른 셀 값이 변경될 때) 재계산됩니다.

VBA

Function YourFunctionName(argument1 As Range, argument2 As String) As String
    Application.Volatile ' 이 함수를 휘발성으로 선언

    ' ... 기존 함수 코드 ...
    YourFunctionName = "결과값"
End Function
장점: 코드 수정 후, 다른 셀을 수정하거나 간단한 재계산(F9)만으로도 사용자 정의 함수가 새 코드로 업데이트될 가능성이 높아집니다.
단점: 이 함수가 포함된 시트는 계산이 더 자주 발생하므로, 함수가 많거나 계산이 복잡하면 통합 문서의 성능이 저하될 수 있습니다. 꼭 필요한 경우에만 사용하는 것이 좋습니다. (코드 변경 후 즉시 반영을 위한 주된 해결책이라기보다는, 함수 자체가 자주 재계산되어야 할 필요가 있을 때 사용합니다.)
VBA 코드로 전체 재계산 실행:
UDF 코드 수정 작업을 마친 후, 직접 실행할 수 있는 간단한 매크로를 만들어두는 방법입니다.

VBA

Sub ForceRecalculateAllUDFs()
    Application.CalculateFullRebuild
    ' 또는 좀 더 간단하게는 Application.Calculate
    ' CalculateFullRebuild가 의존성까지 모두 새로고침하므로 UDF 코드 변경 시 더 확실합니다.
End Sub
이 매크로를 빠른 실행 도구 모음에 추가하거나 단축키를 지정해두면 편리합니다.

Workbook_Open 이벤트 활용:
파일을 열 때마다 항상 최신 코드로 계산되도록 하고 싶다면, ThisWorkbook 모듈의 Workbook_Open 이벤트에 재계산 코드를 넣을 수 있습니다.

VBA

Private Sub Workbook_Open()
    Application.CalculateFullRebuild ' 또는 Application.Calculate
End Sub
이는 파일이 열릴 때마다 전체 재계산을 수행하므로, 파일 크기나 복잡도에 따라 여는 시간이 길어질 수 있습니다.

가장 권장하는 방법:

일상적인 UDF 코드 수정 후: Ctrl + Alt + F9를 눌러 수동으로 전체 재계산을 하시는 것이 가장 확실하고 간단한 방법입니다.
함수 자체가 자주 업데이트되어야 하는 특별한 경우 (예: 현재 시간을 반환하거나, 특정 파일의 존재 유무를 확인하는 등 입력 인수에 직접적으로 의존하지 않는 값을 반환할 때): Application.Volatile을 고려해볼 수 있습니다.