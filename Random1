 문제는 ObservableCollection을 변경하는 동안 CollectionChanged 이벤트가 발생해서 에러가 발생하는 전형적인 경우입니다. **ObservableCollection**은 컬렉션이 변경될 때마다 자동으로 UI에 반영되기 때문에, CollectionChanged 이벤트 처리 중에 컬렉션을 직접 변경하면 충돌이 발생합니다.

해결 방법:
**ObservableCollection**을 직접 수정하지 않고, 대신 지연 처리 또는 별도의 메서드로 호출.
Dispatcher를 사용하여 UI 스레드에서 처리 후 컬렉션을 수정.
해결 방안 1: Dispatcher 사용
WPF의 Dispatcher를 이용하여 컬렉션이 변경된 후 처리되도록 설정할 수 있습니다.

수정된 RemoveOldItemsIfExceedingLimit 함수:
csharp
코드 복사
private void RemoveOldItemsIfExceedingLimit()
{
    Application.Current.Dispatcher.Invoke(() =>
    {
        while (TaskList.Count > MaxItems)
        {
            TaskList.RemoveAt(0); // 가장 오래된 항목(첫 번째 항목) 삭제
        }
    });
}
해결 방안 2: BeginInvoke 사용 (비동기 처리)
또 다른 방법은 Dispatcher.BeginInvoke를 사용하여 컬렉션 변경이 완료된 후에 지연 처리하는 방법입니다.

csharp
코드 복사
private void RemoveOldItemsIfExceedingLimit()
{
    Application.Current.Dispatcher.BeginInvoke(new Action(() =>
    {
        while (TaskList.Count > MaxItems)
        {
            TaskList.RemoveAt(0); // 가장 오래된 항목(첫 번째 항목) 삭제
        }
    }), System.Windows.Threading.DispatcherPriority.Background);
}
해결 방안 3: 별도 큐로 처리
다른 방법은 CollectionChanged 이벤트 중에 직접 컬렉션을 수정하지 않고, 별도의 큐에 작업을 쌓아둔 뒤, 이벤트가 완료된 후에 한꺼번에 처리하는 방법입니다.

csharp
코드 복사
private void RemoveOldItemsIfExceedingLimit()
{
    var itemsToRemove = new List<TaskModel>();

    while (TaskList.Count > MaxItems)
    {
        itemsToRemove.Add(TaskList[0]); // 삭제할 항목을 임시 저장
    }

    // 이벤트 완료 후 컬렉션에서 삭제
    Application.Current.Dispatcher.Invoke(() =>
    {
        foreach (var item in itemsToRemove)
        {
            TaskList.Remove(item);
        }
    });
}
해결 방안 4: CollectionChanged 이벤트 해제 후 작업 처리
또 다른 방법은 CollectionChanged 이벤트를 일시적으로 해제한 후, 작업을 처리한 다음 다시 이벤트를 구독하는 방식입니다.

csharp
코드 복사
private void RemoveOldItemsIfExceedingLimit()
{
    // CollectionChanged 이벤트 해제
    TaskList.CollectionChanged -= TaskList_CollectionChanged;

    while (TaskList.Count > MaxItems)
    {
        TaskList.RemoveAt(0); // 오래된 항목 삭제
    }

    // CollectionChanged 이벤트 다시 구독
    TaskList.CollectionChanged += TaskList_CollectionChanged;
}
요약:
위의 해결 방법 중, Dispatcher를 사용하는 방식이 가장 안전하고 직관적인 방법입니다. ObservableCollection은 UI 스레드에서만 변경할 수 있기 때문에, Dispatcher를 사용하여 UI 스레드에서 안전하게 컬렉션을