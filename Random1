그 값을 추가했는데 UI가 갱신되지 않는 이유는 ObservableCollection이 변경을 UI에 알리지 못했거나, DataGrid가 적절히 바인딩되지 않았기 때문입니다. 이를 해결하기 위해 몇 가지를 점검하고 수정해야 합니다.

문제 원인과 해결
1. ObservableCollection와 UI의 동기화
ObservableCollection은 항목이 추가되거나 삭제될 때 UI에 변경 사항을 자동으로 알립니다. 하지만, LogEntries 컬렉션이 DataGrid와 바인딩되지 않았거나 ObservableCollection가 제대로 초기화되지 않으면 UI 갱신이 이루어지지 않습니다.

2. Dispatcher.Invoke와 UI 스레드
UI 갱신 작업은 반드시 UI 스레드에서 이루어져야 합니다. 이벤트에서 데이터 변경이 UI 스레드에서 이루어지지 않으면 UI에 반영되지 않을 수 있습니다.

3. INotifyPropertyChanged 구현 확인
LogEntries 프로퍼티가 제대로 알림을 구현하지 않았을 수 있습니다. 뷰모델의 프로퍼티에 변경 알림을 설정해야 DataGrid가 바인딩 상태를 유지합니다.

수정된 코드
1. MergeOIErrLogManager
이벤트를 통해 로그 추가 시 UI 스레드에서 ObservableCollection이 갱신되도록 확실히 처리합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly object _lock = new object();
    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 이벤트로 전달된 로그 처리
    /// </summary>
    /// <param name="logLine">로그 라인</param>
    public void HandleLogEvent(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_lock)
                {
                    LogEntries.Add(newEntry);

                    // 오래된 로그 삭제 (최근 2일치까지만 유지)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. MainViewModel
뷰모델에서 LogEntries를 MergeOIErrLogManager의 컬렉션에 바인딩하고, OnPropertyChanged를 통해 UI와 동기화를 보장합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    private readonly MergeOIErrLogManager _logManager;
    public ObservableCollection<MergeOIErrLogEntry> LogEntries => _logManager.LogEntries;

    private SocketClientMergeOI _socketClient;

    public MainViewModel()
    {
        _logManager = new MergeOIErrLogManager();
        _socketClient = new SocketClientMergeOI();

        // 이벤트 구독
        _socketClient.OnLogReceived += _logManager.HandleLogEvent;

        // 초기화
        Task.Run(async () => await _logManager.InitializeAsync());
    }
}
3. SocketClientMergeOI
로그 이벤트를 통해 MergeOIErrLogManager로 메시지를 전달합니다.

csharp
코드 복사
using System;

public class SocketClientMergeOI
{
    public event Action<string> OnLogReceived;

    private void RaiseLogEvent(string logMessage)
    {
        OnLogReceived?.Invoke(logMessage);
    }

    public void ProcessSocketMessage(string receivedMessage)
    {
        if (receivedMessage.Contains("ERROR"))
        {
            string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] ERROR: {receivedMessage}";
            RaiseLogEvent(logMessage);
        }
    }
}
4. XAML
UI는 LogEntries를 DataGrid에 바인딩합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
추가 점검 사항
ObservableCollection 변경 이벤트

ObservableCollection은 요소의 추가/삭제 시 자동으로 UI를 갱신하지만, UI 스레드에서 작업해야 합니다.
Application.Current.Dispatcher.Invoke를 통해 UI 스레드에서 갱신 작업이 이루어지도록 수정했습니다.
뷰모델 바인딩 확인

LogEntries 프로퍼티가 뷰모델에 제대로 바인딩되었는지 확인합니다.
MainViewModel이 DataContext로 설정되었는지 확인합니다.