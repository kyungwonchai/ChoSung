네, app/__init__.py 파일에 오류가 있다고 하시니 해당 파일을 수정하여 다시 전체 코드를 제공해 드리겠습니다. Flask에서 __init__.py 파일은 애플리케이션의 초기 설정, 블루프린트 등록, 확장 기능 초기화 등 중요한 역할을 하므로 오류 없이 구성하는 것이 중요합니다.

일반적으로 __init__.py에서 발생할 수 있는 오류는 다음과 같습니다:

순환 참조 (Circular Imports): __init__.py에서 다른 모듈(예: 라우트 파일)을 임포트하고, 그 다른 모듈에서도 __init__.py의 app 객체 등을 다시 임포트하려고 할 때 발생합니다. 블루프린트를 사용하면 이런 문제를 많이 줄일 수 있습니다.
애플리케이션 컨텍스트 문제: Flask의 current_app이나 g 객체, 또는 데이터베이스 세션(db.session)을 애플리케이션 컨텍스트 외부에서 (예: 모듈 로드 시점) 사용하려고 할 때 발생할 수 있습니다.
설정 또는 초기화 순서 문제: 확장 기능(예: SQLAlchemy)이 앱 객체에 제대로 초기화되기 전에 사용하려고 할 때 문제가 생길 수 있습니다.
구조 개선 제안:
이전 __init__.py에 직접 정의했던 main_bp (메인 페이지 / 라우트)를 별도의 파일 app/routes_main.py로 분리하여 다른 블루프린트(admin, user)와 일관된 구조를 갖도록 하겠습니다. 이렇게 하면 __init__.py는 더욱 깔끔하게 애플리케이션 생성과 초기화에만 집중할 수 있습니다.

1. 신규: app/routes_main.py (메인 페이지 라우트)
app 폴더에 routes_main.py 파일을 새로 생성하고 다음 내용을 작성합니다.

Python

# scontrol_flask_web/app/routes_main.py
from flask import Blueprint, render_template, flash, redirect, url_for, g
from .auth import ip_auth_required, get_current_user_role # g는 auth 모듈에서 설정됨

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
@ip_auth_required() # 로그인된 사용자 (admin 또는 user)만 접근 가능
def index():
    # get_current_user_role() 호출 시 g.user_ip와 g.current_user_role이 설정됩니다.
    # auth.py의 inject_user_info_to_templates 컨텍스트 프로세서 덕분에
    # 템플릿에서는 이미 current_user_ip와 current_user_role 변수를 사용할 수 있습니다.
    # 여기서 flash 메시지는 사용자에게 추가 정보를 제공합니다.
    
    # 현재 역할을 한 번 더 명시적으로 가져와서 로깅이나 조건부 로직에 사용할 수 있습니다.
    current_role = get_current_user_role() 
    flash(f"환영합니다! IP: {g.user_ip}, 역할: {current_role}", "info")

    # 역할에 따른 리다이렉션 로직 (선택 사항)
    # if current_role == 'admin':
    #     # 관리자면 바로 PC 관리 페이지로 리다이렉트 할 수도 있습니다.
    #     # return redirect(url_for('admin.manage_target_pcs'))
    #     pass 
    # elif current_role == 'user':
    #     # 일반 사용자면 제어판으로 리다이렉트 할 수도 있습니다.
    #     # return redirect(url_for('user.control_panel')) # user_bp 등록 후 사용 가능
    #     pass
        
    return render_template('index.html') # 기본 index.html 템플릿 렌더링
2. 수정: app/__init__.py (애플리케이션 팩토리 및 초기화)
이제 app/__init__.py 파일을 수정하여 main_bp를 routes_main.py에서 임포트하고, 전체적인 구조를 정리합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from config import config # 프로젝트 루트의 config.py 임포트
import datetime # datetime 필터용

db = SQLAlchemy() # SQLAlchemy 객체 전역 선언

def create_app(config_name='default'):
    """
    Flask 애플리케이션 인스턴스를 생성하고 초기화하는 팩토리 함수입니다.
    """
    app = Flask(__name__)
    
    # 1. 설정 로드
    app.config.from_object(config[config_name])
    config[config_name].init_app(app) # Config 클래스의 init_app 호출 (현재는 비어있음)

    # 2. 확장 기능 초기화 (예: SQLAlchemy)
    db.init_app(app)

    # 3. Jinja2 커스텀 필터 및 컨텍스트 프로세서 등록
    # datetime 필터 등록
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'): # fmt로 파라미터 이름 변경
        if not value: # None이거나 빈 문자열이면 빈 문자열 반환
            return ""
        if isinstance(value, str): # 문자열인 경우 datetime 객체로 파싱 시도
            try: 
                # ISO 형식 (+00:00 같은 UTC 오프셋 제거 시도)
                if '.' in value and ('Z' in value.upper() or '+' in value or '-' in value[10:]): # 2023-10-27T10:30:00.123Z 또는 2023-10-27T10:30:00.123+09:00
                    value_no_offset = value.split('+')[0].split('-')[0:3] # YYYY-MM-DDTHH:MM:SS.ffffff부분만
                    value_no_offset_str = "".join(value_no_offset) if isinstance(value_no_offset, list) else value_no_offset
                    if 'Z' in value.upper(): value_no_offset_str = value.upper().split('Z')[0]

                    # 소수점 처리
                    if '.' in value_no_offset_str:
                         dt_part, ms_part = value_no_offset_str.split('.')
                         value = datetime.datetime.strptime(dt_part, "%Y-%m-%dT%H:%M:%S")
                    else: # 소수점 없는 경우
                         value = datetime.datetime.strptime(value_no_offset_str, "%Y-%m-%dT%H:%M:%S")
            except ValueError:
                try: # 기본 YYYY-MM-DD HH:MM:SS 형식 시도
                    value = datetime.datetime.strptime(value, "%Y-%m-%d %H:%M:%S")
                except ValueError:
                    return value # 파싱 실패 시 원본 값 반환
        
        if not isinstance(value, (datetime.datetime, datetime.date)): # datetime 객체가 아니면 변환 불가
             return value

        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    
    @app.context_processor
    def inject_now(): # 모든 템플릿에서 'now' 변수로 현재 UTC 시간 사용 가능
        return {'now': datetime.datetime.utcnow()}

    # IP 주소 및 사용자 역할 정보를 모든 템플릿에 주입하는 컨텍스트 프로세서 등록
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)


    # 4. 블루프린트(Blueprint) 등록
    # 각 기능별 라우트 모듈을 임포트하고 애플리케이션에 등록합니다.
    
    from .routes_main import main_bp # 메인 페이지 블루프린트
    app.register_blueprint(main_bp) # URL 접두사 없이 루트에 등록

    from .routes_admin import admin_bp # 관리자 기능 블루프린트
    app.register_blueprint(admin_bp, url_prefix='/admin') # '/admin' URL 접두사로 등록
    
    from .routes_user import user_bp # 사용자 기능 블루프린트
    app.register_blueprint(user_bp, url_prefix='/user') # '/user' URL 접두사로 등록
    # 만약 '/control_panel'을 루트 레벨로 하고 싶다면, url_prefix 없이 등록하고
    # routes_user.py 내의 @user_bp.route('/')를 @user_bp.route('/control_panel')로 변경


    # 5. 애플리케이션 컨텍스트가 필요한 기타 초기화 (예: DB 테이블 생성)
    # with app.app_context():
    #     db.create_all() # 모든 SQLAlchemy 모델에 해당하는 테이블 생성 (Flask-Migrate 사용 시에는 불필요)
    # 주의: db.create_all()은 개발 중에만 사용하고, 운영 환경에서는 Flask-Migrate 같은 도구로 관리하는 것이 좋습니다.

    current_app.logger.info("Flask application created successfully.")
    return app
__init__.py 주요 변경 사항 및 설명:

main_bp 분리 및 등록: routes_main.py에서 정의한 main_bp를 임포트하여 등록했습니다. URL 접두사 없이 등록하여 / 경로를 처리합니다.
user_bp 등록: 이전 응답에서 작성한 routes_user.py의 user_bp도 임포트하여 /user 접두사로 등록했습니다. (예: /user/control_panel)
datetimeformat 필터 개선: 문자열로 된 날짜/시간 값을 파싱할 때 ISO 형식 및 다양한 경우를 좀 더 너그럽게 처리하도록 수정하고, datetime 객체가 아닐 경우 원본을 반환하도록 방어 코드를 추가했습니다. fmt로 파라미터 이름을 변경했습니다.
주석 및 로깅 추가: 코드 이해를 돕기 위한 주석과 애플리케이션 생성 성공 로그를 추가했습니다.
db.create_all() 주석 처리: 이 코드는 개발 초기에는 편리하지만, 모델이 변경될 때마다 기존 테이블을 삭제하지 않고는 스키마를 업데이트하기 어렵습니다. 실제 운영 및 지속적인 개발에는 Flask-Migrate와 같은 데이터베이스 마이그레이션 도구를 사용하는 것이 좋습니다. 지금은 주석 처리해두었습니다. (테이블은 이전에 제공된 MSSQL DDL 스크립트로 이미 생성했다고 가정합니다.)
실행 전 확인:

app 폴더 내에 routes_main.py, routes_admin.py, routes_user.py, auth.py, models.py, forms.py, socket_client.py 파일들이 올바르게 위치해 있는지 확인합니다.
templates 폴더와 그 하위 폴더(admin, user)에 필요한 HTML 파일들(layout.html, index.html, manage_target_pcs.html 등)이 있는지 확인합니다.
위와 같이 수정한 app/__init__.py와 새로 추가된 app/routes_main.py 파일을 프로젝트에 적용해 보십시오. 이렇게 하면 라우트 관리가 좀 더 체계적으로 이루어지고, __init__.py 파일은 애플리케이션 설정 및 초기화에 집중할 수 있게 됩니다.