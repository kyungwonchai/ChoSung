네, 알겠습니다. 신규 행 추가 및 저장 시 발생하는 오류와 관련하여 수정된 MainViewModel.cs와 LockerDbContext.cs 파일의 전체 코드를 여기에 바로 작성해 드립니다.

수정 내용:

MainViewModel.cs:
AddNewLocker 메서드에 SpecificLocation 기본값 관련 주석 추가.
오류 발생 시 표시되는 MessageBox 내용을 조금 더 상세하게 수정 (InnerException 확인 강조).
LockerDbContext.cs:
CreateAuditEntries 메서드에서 Added 상태의 엔티티 처리 시:
RecordId (기본 키)는 DB 저장 전에는 값을 알 수 없음을 주석으로 명시.
NewValues 직렬화 부분을 try-catch로 감싸서 직렬화 오류 발생 가능성 처리.
1. ViewModels/MainViewModel.cs (수정)

C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (신규 행 추가 오류 처리 개선)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }

        #region Public Properties (이전과 동일)
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands (이전과 동일)
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();

            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync());
            OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow);

            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private async Task LoadInitialDataAsync() { await LoadMasterDataAsync(); await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null) return; StatusBarText = "사물함 목록 로딩 중..."; try { var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(); LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; } catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { AllLockerTypes = new ObservableCollection<LockerType>(await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync()); AllFloors = new ObservableCollection<Floor>(await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync()); AllZones = new ObservableCollection<Zone>(await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync()); AllSubParts = new ObservableCollection<SubPart>(await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync()); AllAdministrators = new ObservableCollection<Administrator>(await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync()); } StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; StatusBarText = "마스터 모드 활성화."; MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { var masterDataVM = new MasterDataViewModel(); var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync() { if (_context == null) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }

        /// <summary>
        /// 새 사물함 추가 (UI 및 Context)
        /// </summary>
        private void AddNewLocker(object parameter)
        {
            if (_context == null) return;
            var newAssignment = new LockerAssignment
            {
                // 필수 마스터 데이터 기본값 설정
                LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함",
                Floor = AllFloors.FirstOrDefault()?.Name ?? "1",
                Zone = AllZones.FirstOrDefault()?.Name ?? "A",
                // 세부 위치는 사용자가 직접 입력해야 함. 임시 값 제공.
                // 저장 시 이 값이 유효한지, 중복되지 않는지 확인하는 로직 추가 고려.
                SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4),
                Administrator = _currentAdmin, // 생성 시 관리자
                LastUpdated = DateTime.Now
                // 나머지 Nullable 필드는 기본값(null) 사용
            };
            LockerAssignments.Add(newAssignment);
            _context.LockerAssignments.Add(newAssignment); // 상태: Added
            SelectedAssignment = newAssignment;
            StatusBarText = "새 사물함 추가됨. 세부 정보 입력 후 저장 필요.";
        }

        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Helper Methods (오류 메시지 상세화)
        /// <summary>
        /// 일반 예외 처리 (상세 정보 포함)
        /// </summary>
        private void HandleGenericException(string operation, Exception ex)
        {
            StatusBarText = $"{operation} 중 오류 발생: {ex.Message}";
            // ToString()을 사용하여 InnerException 정보까지 포함
            MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
        }

        /// <summary>
        /// 데이터베이스 업데이트 예외 처리 (상세 정보 포함)
        /// </summary>
        private void HandleDbUpdateException(DbUpdateException dbEx)
        {
            // InnerException을 재귀적으로 탐색하여 가장 근본적인 원인 메시지 찾기 시도
            Exception innerMostException = dbEx;
            while (innerMostException.InnerException != null)
            {
                innerMostException = innerMostException.InnerException;
            }
            string innerExMsg = innerMostException.Message;

            StatusBarText = $"DB 업데이트 오류: {innerExMsg}";
            MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            try
            {
                // 오류 발생 엔티티 상태 되돌리기 시도
                foreach(var entry in dbEx.Entries) { entry.Reload(); }
            } catch { /* Reload 실패 무시 */ }
        }

        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); LogVM?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
2. Data/LockerDbContext.cs (수정)

CreateAuditEntries 메서드에서 Added 상태일 때 NewValues 직렬화 부분을 try-catch로 감싸고, RecordId 가져오는 부분의 주석을 명확히 합니다.

C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Web.Script.Serialization; // 또는 Newtonsoft.Json
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (로그 생성 오류 처리 개선)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        public LockerDbContext() : base("name=LockerDbConnection") { }

        protected override void OnModelCreating(DbModelBuilder modelBuilder) { base.OnModelCreating(modelBuilder); }

        #region SaveChanges Overrides for Audit Logging (Revised Logic)

        public override int SaveChanges()
        {
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { this.AuditLogs.AddRange(auditEntries); }
            try { return base.SaveChanges(); }
            catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! SaveChanges 실패 (동기): {dbEx.ToString()}"); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
        }

        public override async Task<int> SaveChangesAsync()
        {
            List<AuditLog> auditEntries = null;
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { this.AuditLogs.AddRange(auditEntries); }
            try { return await base.SaveChangesAsync(); }
            catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! SaveChangesAsync 실패 (비동기): {dbEx.ToString()}"); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
        }

        /// <summary>
        /// 현재 변경 추적 중인 엔티티를 기반으로 감사 로그 엔트리 목록을 생성합니다.
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                .ToList();
            var serializer = new JavaScriptSerializer { MaxJsonLength = int.MaxValue }; // Newtonsoft.Json 권장

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) continue;

                var auditEntry = new AuditLog
                {
                    Timestamp = DateTime.Now,
                    UserName = currentUserName,
                    TableName = entry.Entity.GetType().Name,
                    Action = entry.State.ToString()
                };

                // 기본 키(Id) 값 가져오기 (Added 상태에서는 DB 저장 전이므로 값이 없을 수 있음)
                try
                {
                    if (entry.State == EntityState.Deleted)
                    {
                        auditEntry.RecordId = entry.OriginalValues["Id"]?.ToString() ?? "N/A"; // 삭제 시 원본 값
                    }
                    else
                    {
                        // Added 또는 Modified 시 현재 값 시도 (Added는 보통 0 또는 null)
                        auditEntry.RecordId = entry.CurrentValues["Id"]?.ToString() ?? "N/A";
                    }
                }
                catch (Exception ex)
                {
                    Debug.WriteLine($"감사 로그: 'Id' 기본 키 값 가져오기 실패 ({auditEntry.TableName}) - {ex.Message}");
                    auditEntry.RecordId = "PK Error";
                }

                var oldValues = new Dictionary<string, object>();
                var newValues = new Dictionary<string, object>();
                var affectedColumns = new List<string>();

                if (entry.State == EntityState.Added)
                {
                    foreach (var propertyName in entry.CurrentValues.PropertyNames) newValues[propertyName] = entry.CurrentValues[propertyName];
                    // *** 수정된 부분: Added 상태의 NewValues 직렬화에 try-catch 추가 ***
                    try { auditEntry.NewValues = serializer.Serialize(newValues); }
                    catch (Exception serEx)
                    {
                        Debug.WriteLine($"!!! 감사 로그 Added 상태 직렬화 오류: {serEx.Message}");
                        auditEntry.NewValues = "Serialization Error";
                    }
                }
                else if (entry.State == EntityState.Deleted)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames) oldValues[propertyName] = entry.OriginalValues[propertyName];
                    try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Modified)
                {
                    foreach (var propertyName in entry.OriginalValues.PropertyNames) { var originalValue = entry.OriginalValues[propertyName]; var currentValue = entry.CurrentValues[propertyName]; if (!Equals(originalValue, currentValue)) { affectedColumns.Add(propertyName); oldValues[propertyName] = originalValue; newValues[propertyName] = currentValue; } }
                    if (affectedColumns.Any()) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; } }
                    else continue;
                }
                auditEntries.Add(auditEntry);
            }
            UpdateLockerAssignmentTimestamps(changedEntries);
            return auditEntries;
        }

        // SaveAuditLogs, SaveAuditLogsAsync 메서드는 제거됨

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; } }

        #endregion
    }
}
핵심 변경 사항:

MainViewModel.cs:
HandleGenericException, HandleDbUpdateException 메서드에서 오류 메시지 박스에 ex.ToString()을 포함하여 InnerException 정보까지 표시되도록 수정했습니다.
AddNewLocker 메서드에 SpecificLocation 기본값 관련 주석을 추가했습니다 (저장 시 유효성/중복 확인 필요 가능성 명시).
LockerDbContext.cs:
CreateAuditEntries 메서드에서 Added 상태의 엔티티에 대한 NewValues 직렬화(serializer.Serialize(newValues)) 부분을 try-catch 블록으로 감쌌습니다. 만약 직렬화 중 오류가 발생하면 "Serialization Error"로 기록됩니다.
Added 상태일 때 RecordId를 가져오는 부분에 대한 주석을 명확히 했습니다 (DB 저장 전에는 실제 ID 값이 없음).
다음 단계:

이 코드를 적용하고 다시 빌드합니다.
신규 행 추가 후 저장 시 또는 기존 행 수정 후 저장 시 오류가 발생하면, 표시되는 오류 메시지 박스의 전체 내용 (특히 InnerException 부분)을 자세히 알려주세요.