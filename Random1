ê±°ë‚˜ ê²€ì¦í•  ìˆ˜ ìˆëŠ” êµ¬ì¡°ê°€ í•„ìš”í•´.

ğŸ” í•µì‹¬ ìš”êµ¬ ì‚¬í•­ ìš”ì•½
PLC ê·œì¹™ ì¤€ìˆ˜:

ë³´ë‚¼ ë•ŒëŠ” ì ˆëŒ€ ìˆ˜ì • ì—†ì´ PLCì˜ ê·œì¹™ì„ ë”°ë¼ì•¼ í•¨. (REQ: ê°™ì€ ê±° ê¸ˆì§€)

ì‘ë‹µ ì²˜ë¦¬ ë°©ì‹:

ê¸°ì¡´ì—ëŠ” ì‘ë‹µì„ ë°›ìœ¼ë©´ ê·¸ ë‚´ìš©ì— ë”°ë¼ íŠ¹ì • ë¡œì§ì„ ì‹¤í–‰í•¨.

ì´ ê¸°ëŠ¥ì„ ìœ ì§€í•˜ë©´ì„œ ë¹„ë™ê¸° í†µì‹ ì„ ì•ˆì „í•˜ê²Œ í•´ì•¼ í•¨.

OP_CLEAR ì‹ í˜¸ ì²˜ë¦¬:

í•­ìƒ ë³„ë„ë¡œ ê°ì§€ë˜ì–´ì•¼ í•¨. (ë©”ì¸ ì‘ë‹µ ì²˜ë¦¬ ë¡œì§ê³¼ ë¶„ë¦¬)

ì‘ë‹µ ê²€ì¦ í•¨ìˆ˜ ì¶”ê°€:

ì‘ë‹µì´ ì™”ì„ ë•Œ ë‚´ìš©ì„ í™•ì¸í•˜ê³ , ê·¸ì— ë”°ë¼ ë‹¤ë¥¸ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•  ìˆ˜ ìˆì–´ì•¼ í•¨.

ì˜ˆë¥¼ ë“¤ì–´, STATUS_OKê°€ ì˜¤ë©´ íŠ¹ì • í•¨ìˆ˜ ì‹¤í–‰, ERRORê°€ ì˜¤ë©´ ì—ëŸ¬ ì²˜ë¦¬ í•¨ìˆ˜ ì‹¤í–‰.

ğŸ’¡ ì½”ë“œ ì„¤ê³„ ë°©ë²•
ì‘ë‹µ ê²€ì¦ ë° ì²˜ë¦¬ ê¸°ëŠ¥ ì¶”ê°€:

ì‘ë‹µì„ ë°›ìœ¼ë©´ ê·¸ ë‚´ìš©ì„ íŒŒì‹±í•˜ê³ , ì‘ë‹µ ë‚´ìš©ì— ë”°ë¼ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë„ë¡ ë³€ê²½.

TaskCompletionSourceë¡œ ë¹„ë™ê¸° ì²˜ë¦¬ ìœ ì§€:

ê¸°ì¡´ ë°©ì‹ì—ì„œ ì‘ë‹µì„ ì²˜ë¦¬í•˜ë˜, ì‘ë‹µ ë‚´ìš©ì„ íŒŒì‹±í•˜ì—¬ ì¡°ê±´ë¶€ë¡œ ë¡œì§ì„ ì‹¤í–‰í•  ìˆ˜ ìˆê²Œ ë§Œë“¦.

ëª¨ë“  ë¡œì§ì„ ì£¼ì„ìœ¼ë¡œ ì™„ë²½íˆ ì„¤ëª…:

ì§€ê¸ˆë¶€í„° ì‘ì„±í•˜ëŠ” ì½”ë“œëŠ” ì£¼ì„ì„ ê·¹ë„ë¡œ ìƒì„¸íˆ ì¶”ê°€í•  ê±°ì•¼.

ğŸ”¥ ì „ë¬¸ê°€ ì½”ë“œ (ì£¼ì„ ë§¤ìš° ìƒì„¸í•˜ê²Œ ì¶”ê°€)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ì˜ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„°ë¥¼ ì†¡ìˆ˜ì‹ í•˜ê¸° ìœ„í•œ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•  ë²„í¼ (1KB í¬ê¸°)
    private bool _isConnected = false; // ì„œë²„ì™€ ì—°ê²° ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸

    // ì‘ë‹µ ëŒ€ê¸°ë¥¼ ìœ„í•œ ë¹„ë™ê¸° ì²˜ë¦¬ë¥¼ ê´€ë¦¬í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ (FIFO ë°©ì‹)
    private BlockingCollection<TaskCompletionSource<string>> _responseQueue 
        = new BlockingCollection<TaskCompletionSource<string>>();

    /// <summary>
    /// ì„œë²„ì™€ ë¹„ë™ê¸°ë¡œ ì—°ê²°ì„ ìˆ˜ë¦½í•˜ê³ , ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient(); // TcpClient ê°ì²´ ìƒì„±
        await _client.ConnectAsync(ip, port); // ì„œë²„ì— ë¹„ë™ê¸°ë¡œ ì—°ê²°
        _stream = _client.GetStream(); // ì„œë²„ì™€ì˜ ë°ì´í„° ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜´
        _isConnected = true; // ì—°ê²° ìƒíƒœ í”Œë˜ê·¸ë¥¼ trueë¡œ ì„¤ì •

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // ìˆ˜ì‹  ë£¨í”„ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ (ë³„ë„ì˜ Taskë¡œ ì‹¤í–‰)
        _ = Task.Run(ReceiveLoopAsync);
    }

    /// <summary>
    /// PLCë¡œ ëª…ë ¹ì„ ë³´ë‚´ê³  í•´ë‹¹ ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ê¸°ë‹¤ë¦°ë‹¤.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected) return "[ERROR] Not connected."; // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° ì—ëŸ¬ ë°˜í™˜

        // PLC ê·œì¹™ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ STXì™€ ETXë¡œ ê°ì‹¼ë‹¤.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage); // ë©”ì‹œì§€ë¥¼ ë°”ì´íŠ¸ ë°°ì—´ë¡œ ë³€í™˜

        var tcs = new TaskCompletionSource<string>(); // ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ê¸° ìœ„í•œ ë¹„ë™ê¸° ì²˜ë¦¬ ê°ì²´ ìƒì„±

        _responseQueue.Add(tcs); // ì‘ë‹µ ëŒ€ê¸° ëª©ë¡ì— ì¶”ê°€ (FIFO ë°©ì‹ìœ¼ë¡œ ìˆœì„œ ìœ ì§€)

        // ì„œë²„ë¡œ ë©”ì‹œì§€ ì „ì†¡
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ê¸°ë‹¤ë¦¼ (ìˆ˜ì‹  ë£¨í”„ì—ì„œ ì‘ë‹µì„ ì²˜ë¦¬í•˜ì—¬ ì´ Taskë¥¼ ì™„ë£Œì‹œí‚´)
        string response = await tcs.Task;

        // ì‘ë‹µ ê²€ì¦ ë° í›„ì† ì²˜ë¦¬ í•¨ìˆ˜ í˜¸ì¶œ
        ProcessResponseContent(response);

        return response; // ì‘ë‹µì„ ìµœì¢… ë°˜í™˜
    }

    /// <summary>
    /// ì„œë²„ë¡œë¶€í„° ì˜¤ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ìˆ˜ì‹  ë£¨í”„.
    /// OP_CLEAR ë©”ì‹œì§€ë¥¼ ë³„ë„ë¡œ ì²˜ë¦¬í•˜ê³ , ë‚˜ë¨¸ì§€ëŠ” ì‘ë‹µ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ìœ¼ë¡œ ë„˜ê¹€.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ë¡œ ì½ìŒ (ë²„í¼ í¬ê¸°: 1KB)
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // ë°›ì€ ë°ì´í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê³  STXì™€ ETXë¥¼ ì œê±°
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                if (received == "OP_CLEAR")
                {
                    ProcessOpClear(); // OP_CLEAR ì‹ í˜¸ë¥¼ ë³„ë„ë¡œ ì²˜ë¦¬
                }
                else
                {
                    if (_responseQueue.TryTake(out var tcs))
                    {
                        tcs.SetResult(received); // ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ (ë¹„ë™ê¸°ë¡œ ë°˜í™˜)
                    }
                    else
                    {
                        Console.WriteLine("[ERROR] Received message with no waiting request.");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// ì‘ë‹µ ë‚´ìš©ì„ ê²€ì¦í•˜ê³  ê·¸ì— ë”°ë¥¸ ë¡œì§ì„ ì‹¤í–‰í•œë‹¤.
    /// </summary>
    private void ProcessResponseContent(string response)
    {
        if (response == "STATUS_OK")
        {
            Console.WriteLine("[INFO] ì¥ë¹„ ìƒíƒœ: ì •ìƒ");
            HandleStatusOk();
        }
        else if (response == "ERROR")
        {
            Console.WriteLine("[INFO] ì¥ë¹„ ìƒíƒœ: ì—ëŸ¬ ë°œìƒ");
            HandleError();
        }
        else
        {
            Console.WriteLine($"[INFO] ê¸°íƒ€ ì‘ë‹µ ì²˜ë¦¬: {response}");
        }
    }

    /// <summary>
    /// OP_CLEAR ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
    /// </summary>
    private void ProcessOpClear()
    {
        Console.WriteLine("[EVENT] OP_CLEAR received. Resetting state.");
        HandleOpClear();
    }

    /// <summary>
    /// ì‘ë‹µì´ STATUS_OKì¼ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    /// </summary>
    private void HandleStatusOk()
    {
        Console.WriteLine("[ACTION] ìƒíƒœ í™•ì¸: ì •ìƒ ì‘ë™ ì¤‘.");
    }

    /// <summary>
    /// ì‘ë‹µì´ ERRORì¼ ë•Œ ì‹¤í–‰ë˜ëŠ” í•¨ìˆ˜
    /// </summary>
    private void HandleError()
    {
        Console.WriteLine("[ACTION] ì—ëŸ¬ ë°œìƒ ì²˜ë¦¬ ì¤‘...");
    }

    /// <summary>
    /// OP_CLEAR ë©”ì‹œì§€ë¥¼ ì²˜ë¦¬í•˜ëŠ” í•¨ìˆ˜
    /// </summary>
    private void HandleOpClear()
    {
        Console.WriteLine("[ACTION] OP_CLEAR ë°œìƒ â†’ ì‹œìŠ¤í…œ ì´ˆê¸°í™”.");
    }
}
ğŸ“Œ ì£¼ìš” íŠ¹ì§•
ë¹„ë™ê¸° TaskCompletionSource ì‚¬ìš©:

ìš”ì²­ë§ˆë‹¤ ì‘ë‹µì„ ì•ˆì „í•˜ê²Œ ë¹„ë™ê¸°ë¡œ ë°›ìŒ.

PLCì˜ ì‘ë‹µ ê²€ì¦ ì²˜ë¦¬ í•¨ìˆ˜ í¬í•¨:

ProcessResponseContent() í•¨ìˆ˜ì—ì„œ ì‘ë‹µ ë‚´ìš©ì„ í™•ì¸í•˜ê³ , ëŒ€ì‘ í•¨ìˆ˜(HandleStatusOk, HandleError)ë¥¼ í˜¸ì¶œ.

PLC ê·œì¹™ ìœ ì§€ (REQ: ê°™ì€ ê±° ì—†ì´ ì›ë³¸ ê·¸ëŒ€ë¡œ ì „ì†¡):

ìš”ì²­ ë©”ì‹œì§€ë¥¼ STXì™€ ETXë¡œ ê°ì‹¸ì„œ ë³´ë‚´ë©°, PLC ê·œì¹™ì„ ì ˆëŒ€ ê¹¨ì§€ ì•ŠìŒ.