당신의 요구사항에 맞춰 MainViewModel에서 PLC에 값을 쓴 후, 3초 대기 후부터 해당 값이 PLC로부터 수신될 때까지 최대 30초간 기다리는 로직을 구현하겠습니다. 만약 30초 안에 기대한 값이 수신되지 않으면 오류 로그를 메인 UI에 전송하도록 하겠습니다.

1. MainViewModel.cs 수정
아래는 MainViewModel에서 변경된 코드입니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        // Zero부터 4까지 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        // 명령 생성
        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();

            // 명령 초기화
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 1; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value))));
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            // Step 1: Write value to DT2300
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(writeCommand);
            LogMessage($"Sent {number} to DT2300");

            // Step 2: Wait for 3 seconds
            await Task.Delay(3000);

            // Step 3: Read from DT2330 with a 30-second timeout
            bool success = false;
            DateTime startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalSeconds < 30)
            {
                string response = await _comPortManager.ReadFromPLCAsync("023300");

                if (response.Contains(number.ToString()))
                {
                    LogMessage($"Operation completed successfully. Value {number} received from DT2330.");
                    success = true;
                    await _comPortManager.ClearPLCValueAsync("023300");
                    break;
                }

                await Task.Delay(1000); // 1초마다 체크
            }

            if (!success)
            {
                LogMessage($"ERROR: Operation failed. Expected value {number} not received from DT2330 within 30 seconds.");
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                await _comPortManager.SendDataToPLCAsync(command);
                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항 및 설명
PLC에 값 쓰기 (WriteToPLCAndCheckResponse 메서드):

PLC의 DT2300 주소에 1부터 4까지의 값을 씁니다.
SendDataToPLCAsync를 통해 값을 PLC로 전송하고, 로그 메시지를 기록합니다.
3초 대기:

Task.Delay(3000)을 사용하여 3초간 대기합니다.
DT2330 값 확인 및 30초 타임아웃:

3초 대기 후, DT2330의 값을 읽기 시작합니다.
1초마다 DT2330의 값을 확인하고, 기대한 값이 도착하면 성공 로그를 기록하고 값을 0으로 초기화합니다.
DateTime.Now를 이용하여 30초 타임아웃을 설정하며, 30초 안에 기대한 값이 수신되지 않으면 오류 로그를 기록합니다.
로깅:

각 단계에서 로그를 기록하여 작업의 진행 상황을 파악할 수 있습니다. 오류가 발생할 경우에도 로그가 남도록 합니다.
이 코드 구조를 사용하면, PLC와의 통신이 안정적으로 수행되며, 작업 실패 시 오류 로그를 통해 디버깅이 가능합니다. 서비스 측에서 로그 메시지를 전송할 때는 소켓이나 다른 통신 방식을 사용할 수 있으며, 메인 UI에서 이를 수신하여 사용자에게 알릴 수 있습니다