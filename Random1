 are correct! The logic for adding a leading zero should only apply to single-character hours. We can simplify this by checking the condition directly. Here's the corrected query using FORMAT to handle this efficiently:

Updated Query
sql
코드 복사
WITH view1 AS (
    SELECT 
        Line,
        DATEADD(MINUTE, -10, datev) AS datev1,
        PartName,
        pickupcnt
    FROM table_lossdata
),
adjusted_view AS (
    SELECT 
        Line,
        PartName,
        pickupcnt,
        datev1,
        -- Adjust date if time is between 00:00 and 06:59
        CASE 
            WHEN DATEPART(HOUR, datev1) BETWEEN 0 AND 6 THEN DATEADD(DAY, -1, datev1)
            ELSE datev1
        END AS adjusted_datev1
    FROM view1
)
SELECT 
    Line,
    datev1 AS DateV,
    PartName,
    pickupcnt AS Pickup,
    -- Final formatted time: yyyy-MM-dd HH
    CONVERT(VARCHAR(10), adjusted_datev1, 120) + ' ' +
    CASE
        -- 21:00 ~ 22:20 is 21
        WHEN (DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) >= 0)
          OR (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) <= 20) THEN '21'
        -- 22:30 ~ 23:20 is 22
        WHEN (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) <= 20) THEN '22'
        -- 23:30 ~ 00:20 is 23
        WHEN (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) <= 20) THEN '23'
        -- 00:30 ~ 01:20 is 00
        WHEN (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) <= 20) THEN '00'
        -- 01:30 ~ 02:20 is 01
        WHEN (DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 2 AND DATEPART(MINUTE, datev1) <= 20) THEN '01'
        -- 02:30 ~ 03:20 is 02
        WHEN (DATEPART(HOUR, datev1) = 2 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 3 AND DATEPART(MINUTE, datev1) <= 20) THEN '02'
        -- 03:30 ~ 04:20 is 03
        WHEN (DATEPART(HOUR, datev1) = 3 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 4 AND DATEPART(MINUTE, datev1) <= 20) THEN '03'
        -- 04:30 ~ 05:20 is 04
        WHEN (DATEPART(HOUR, datev1) = 4 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) <= 20) THEN '04'
        -- 05:30 ~ 06:50 is 05
        WHEN (DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 6 AND DATEPART(MINUTE, datev1) <= 50) THEN '05'
        -- Default: handle single-digit hour with leading zero
        ELSE FORMAT(DATEPART(HOUR, datev1), '00')
    END AS LastTime
FROM adjusted_view
ORDER BY adjusted_datev1;
Explanation of the Fix:
FORMAT Usage for Leading Zero:

FORMAT(DATEPART(HOUR, datev1), '00') ensures that single-digit hours (e.g., 1, 2) are padded with a leading zero, while double-digit hours (e.g., 21, 22) remain unchanged.
Rest of the Logic:

The CASE structure determines the specific time slot and generates the hour (HH).
The adjusted date is combined with the hour to produce the final LastTime in yyyy-MM-dd HH format.
Example Output:
Line	DateV	PartName	Pickup	LastTime
A	2025-01-20 21:10:00	SensorA	10	2025-01-20 21
B	2025-01-20 22:40:00	SensorB	20	2025-01-20 22