 오류는 배열이 1차원인데 2차원처럼 인덱싱하려고 할 때 발생합니다. 주로 DB에서 데이터를 가져오는 과정에서 반환된 데이터 형식이 예상과 다를 경우에 발생할 수 있습니다.

아래는 문제를 해결하기 위한 단계별 조치입니다.

1. 문제 원인 확인
fetch_data_from_db 함수 반환 값 확인
fetch_data_from_db 함수가 반환한 데이터(data)가 1차원 배열인지 확인하세요.

아래 코드를 통해 데이터 형식을 출력합니다:

python
코드 복사
print(data)
print(f"Data shape: {data.shape}")
2. 해결 방법
Case 1: data가 1차원 배열인 경우
데이터가 1차원 배열로 반환되었을 경우, 다차원 배열로 변환해야 합니다.

수정된 코드는 다음과 같습니다:

python
코드 복사
# 데이터가 1차원인 경우, 2차원으로 변환
if len(data.shape) == 1:
    data = data.reshape(1, -1)
Case 2: DB 반환 데이터 확인
DB에서 반환된 데이터가 예상한 형식이 아니거나, 단일 행/열만 반환될 경우에도 오류가 발생할 수 있습니다.

해결 방법:
fetch_data_from_db 함수 수정: pd.read_sql이 반환하는 데이터프레임을 확인하고, 배열로 변환할 때 values 대신 데이터프레임 자체를 다룹니다.

python
코드 복사
def fetch_data_from_db(proc_name):
    try:
        conn = pymssql.connect(server=server, user=user, password=password, database=database)
        query = f"EXEC {proc_name}"  # 저장 프로시저 실행
        df = pd.read_sql(query, conn)  # 데이터프레임으로 변환
        
        # 반환 값 디버깅
        print(df)
        
        # 데이터프레임을 배열로 변환
        return df.to_numpy()  # .values 대신 .to_numpy() 사용 권장
    except Exception as e:
        print(f"Error fetching data: {e}")
        return np.array([])
Case 3: 데이터 형식 불일치
DB에서 반환된 데이터의 열이 하나뿐일 경우, 배열이 1차원으로 처리됩니다.
이 경우, 열 수를 명시적으로 확인하여 2차원 배열로 처리합니다:
python
코드 복사
# 데이터가 1차원인 경우
if data.ndim == 1:
    data = data.reshape(-1, len(data))
수정된 전체 예측 코드
아래는 위의 문제를 해결한 전체 코드입니다:

python
코드 복사
# 저장된 모델 로드
try:
    model = joblib.load("best_model.pkl")
    print("Best model loaded successfully.")
except Exception as e:
    print(f"Error loading model: {e}")
    exit()

# PRealAandB 데이터 불러오기
data = fetch_data_from_db("PRealAandB")  # PRealAandB 저장 프로시저 호출
if data.size == 0:
    print("Error: No data fetched from PRealAandB.")
    exit()

# 데이터 형식 확인 및 2차원 배열 변환
if data.ndim == 1:  # 1차원인 경우
    data = data.reshape(1, -1)

# 데이터 준비
features = data[:, 2:5]  # 3~5열 (입력값)
actual_value = data[0, 1]  # 2열 (실제값)

# 예측 수행
predicted_value = model.predict(features)[0]
print(f"Predicted value for column 2: {predicted_value}")
print(f"Actual value for column 2: {actual_value}")

# 시각화
plt.figure(figsize=(8, 6))
plt.bar(["Predicted", "Actual"], [predicted_value, actual_value], color=['blue', 'red'], alpha=0.7)
plt.title("Predicted vs Actual Value for Column 2")
plt.ylabel("Value")
plt.grid(axis='y')

error = np.abs(predicted_value - actual_value)
plt.text(0, predicted_value, f"Pred: {predicted_value:.2f}", ha='center', va='bottom')
plt.text(1, actual_value, f"Actual: {actual_value:.2f}", ha='center', va='bottom')
plt.text(0.5, max(predicted_value, actual_value) + 0.1, f"Error: {error:.2f}", ha='center', color='black')

plt.show()

# 정확도 계산
max_possible_value = max(predicted_value, actual_value)
error_score = 100 - (error / max_possible_value * 100)
print(f"Accuracy Score: {error_score:.2f}/100")
결론
fetch_data_from_db 함수의 반환 값을 디버깅하세요.