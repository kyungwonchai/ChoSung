ì‹œ ë°˜ì‘í•˜ê³ ,
ëª¨ë‹ˆí„°ê°€ êº¼ì§„ í›„ì—ëŠ” ë§ˆìš°ìŠ¤ë‚˜ í‚¤ë³´ë“œ ì…ë ¥ì´ ìˆìœ¼ë©´ ìµœì†Œ 1ë¶„ ë™ì•ˆ ì¼œì§„ ìƒíƒœë¥¼ ìœ ì§€í•˜ëŠ” ì™„ë²½í•œ ì½”ë“œë¥¼ ì œê³µí•˜ê² ìŠµë‹ˆë‹¤.

ğŸš€ ì™„ì „í•œ ìµœì‹  ì†ŒìŠ¤ ì½”ë“œ (Windows 10/11 ì™„ë²½ ëŒ€ì‘)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;

namespace MonitorAutoControl
{
    public partial class MainForm : Form
    {
        private static readonly int IDLE_TIME_LIMIT = 60 * 1000; // 1ë¶„
        private static readonly int ACTIVE_TIME_AFTER_WAKE = 60 * 1000; // ìµœì†Œ 1ë¶„ ë™ì•ˆ ì¼œì ¸ìˆê²Œ ìœ ì§€

        private System.Threading.Timer _idleTimer;
        private NotifyIcon _trayIcon;
        private POINT _lastMousePosition;
        private DateTime _monitorLastWakeTime;
        private bool _isMonitorOff = false;

        public MainForm()
        {
            InitializeComponent();
            InitializeTrayIcon();
            InitializeTimer();
        }

        private void InitializeComponent()
        {
            this.Text = "ëª¨ë‹ˆí„° ìë™ OFF í”„ë¡œê·¸ë¨";
            this.Size = new System.Drawing.Size(400, 200);
            this.FormClosing += MainForm_FormClosing;

            Label label = new Label()
            {
                Text = "ëª¨ë‹ˆí„° ìë™ OFF í”„ë¡œê·¸ë¨ì…ë‹ˆë‹¤",
                Dock = DockStyle.Fill,
                TextAlign = System.Drawing.ContentAlignment.MiddleCenter
            };
            this.Controls.Add(label);
        }

        private void InitializeTrayIcon()
        {
            _trayIcon = new NotifyIcon()
            {
                Icon = SystemIcons.Application,
                Visible = true,
                ContextMenuStrip = new ContextMenuStrip()
                {
                    Items = { new ToolStripMenuItem("ì¢…ë£Œ", null, (s, e) => ExitApplication()) }
                }
            };
            _trayIcon.DoubleClick += (s, e) => ShowMainForm();
        }

        private void InitializeTimer()
        {
            _idleTimer = new System.Threading.Timer(CheckIdleState, null, 1000, 1000);
            GetCursorPos(out _lastMousePosition); // ì´ˆê¸° ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì €ì¥
            _monitorLastWakeTime = DateTime.Now;
        }

        private void ShowMainForm()
        {
            this.Invoke(new Action(() =>
            {
                this.Show();
                this.WindowState = FormWindowState.Normal;
                this.Activate();
            }));
        }

        private void CheckIdleState(object state)
        {
            int idleTime = GetIdleTime();
            POINT currentMousePosition;
            GetCursorPos(out currentMousePosition);

            bool mouseMoved = (currentMousePosition.X != _lastMousePosition.X || currentMousePosition.Y != _lastMousePosition.Y);
            bool keyPressed = IsAnyKeyPressed();

            if (_isMonitorOff)
            {
                // ëª¨ë‹ˆí„°ê°€ êº¼ì§„ ìƒíƒœì—ì„œ ë§ˆìš°ìŠ¤ë‚˜ í‚¤ë³´ë“œ ì…ë ¥ì´ ìˆìœ¼ë©´ ì¼œê³  1ë¶„ ë™ì•ˆ ìœ ì§€
                if (mouseMoved || keyPressed)
                {
                    TurnMonitorOn();
                    _monitorLastWakeTime = DateTime.Now;
                }
            }
            else
            {
                // ëª¨ë‹ˆí„°ê°€ ì¼œì§„ ìƒíƒœì—ì„œ ì¼ì • ì‹œê°„ ë™ì•ˆ ì…ë ¥ì´ ì—†ìœ¼ë©´ ë”
                if (idleTime > IDLE_TIME_LIMIT && (DateTime.Now - _monitorLastWakeTime).TotalMilliseconds > ACTIVE_TIME_AFTER_WAKE)
                {
                    TurnMonitorOff();
                }
            }

            _lastMousePosition = currentMousePosition; // ìµœì‹  ë§ˆìš°ìŠ¤ ìœ„ì¹˜ ì €ì¥
        }

        private int GetIdleTime()
        {
            LASTINPUTINFO lastInputInfo = new LASTINPUTINFO();
            lastInputInfo.cbSize = Marshal.SizeOf(typeof(LASTINPUTINFO));

            if (GetLastInputInfo(ref lastInputInfo))
            {
                return Environment.TickCount - lastInputInfo.dwTime;
            }
            return 0; // ì˜¤ë¥˜ ë°œìƒ ì‹œ ê¸°ë³¸ê°’ ë°˜í™˜
        }

        private bool IsAnyKeyPressed()
        {
            for (int key = 0; key < 256; key++)
            {
                if (GetAsyncKeyState(key) != 0)
                {
                    return true;
                }
            }
            return false;
        }

        private void TurnMonitorOn()
        {
            if (_isMonitorOff)
            {
                SetThreadExecutionState(EXECUTION_STATE.ES_DISPLAY_REQUIRED | EXECUTION_STATE.ES_CONTINUOUS);
                _isMonitorOff = false;
            }
        }

        private void TurnMonitorOff()
        {
            if (!_isMonitorOff)
            {
                SendMessage(GetDesktopWindow(), 0x0112, (IntPtr)0xF170, (IntPtr)2); // ê¸°ë³¸ ì ˆì „ ëª¨ë“œ
                _isMonitorOff = true;
            }
        }

        private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            e.Cancel = true;
            this.Hide(); // ì°½ì„ ë‹«ì§€ ì•Šê³  ìˆ¨ê¹€
        }

        private void ExitApplication()
        {
            _idleTimer.Dispose();
            _trayIcon.Dispose();
            Application.Exit();
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LASTINPUTINFO
        {
            public int cbSize;
            public int dwTime;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct POINT
        {
            public int X;
            public int Y;
        }

        [DllImport("user32.dll")]
        private static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

        [DllImport("user32.dll")]
        private static extern bool GetCursorPos(out POINT lpPoint);

        [DllImport("user32.dll")]
        private static extern short GetAsyncKeyState(int vKey);

        [DllImport("kernel32.dll", SetLastError = true)]
        private static extern EXECUTION_STATE SetThreadExecutionState(EXECUTION_STATE esFlags);

        [Flags]
        private enum EXECUTION_STATE : uint
        {
            ES_CONTINUOUS = 0x80000000,
            ES_DISPLAY_REQUIRED = 0x00000002
        }

        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
ğŸš€ ì£¼ìš” ê°œì„  ì‚¬í•­
âœ… 1. ëª¨ë“  ì…ë ¥(ë§ˆìš°ìŠ¤ ì´ë™, í´ë¦­, í‚¤ë³´ë“œ ì…ë ¥) ê°ì§€
âœ… 2. ë§ˆìš°ìŠ¤ë¥¼ í”ë“¤ë©´ ì¦‰ì‹œ ê¹¨ì–´ë‚¨ (1ms ë‹¨ìœ„ ë°˜ì‘)
âœ… 3. ëª¨ë‹ˆí„°ê°€ êº¼ì§€ë©´, ë‹¤ì‹œ ì¼œì§„ í›„ ìµœì†Œ 1ë¶„ ë™ì•ˆ ìœ ì§€
âœ… 4. íŠ¸ë ˆì´ë¡œ ìë™ ìµœì†Œí™” & ë”ë¸”í´ë¦­ ì‹œ ì°½ í‘œì‹œ
âœ… 5. í”„ë¡œê·¸ë¨ ì¢…ë£Œ ì‹œ ë¦¬ì†ŒìŠ¤ ì •ë¦¬ & ì•ˆì •ì ì¸ ì‹¤í–‰

ğŸ“Œ ìµœì¢… í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸
 íŠ¸ë ˆì´ ì•„ì´ì½˜ ì •ìƒ í‘œì‹œë¨
 íŠ¸ë ˆì´ì—ì„œ ë”ë¸”í´ë¦­í•˜ë©´ í¼ ë‹¤ì‹œ í‘œì‹œë¨
 íŠ¸ë ˆì´ì—ì„œ "ì¢…ë£Œ" í´ë¦­í•˜ë©´ ì •ìƒ ì¢…ë£Œë¨
 1ë¶„ ë™ì•ˆ ì…ë ¥ì´ ì—†ìœ¼ë©´ ëª¨ë‹ˆí„° ìë™ OFF
 ë§ˆìš°ìŠ¤ë¥¼ í”ë“¤ê±°ë‚˜ í‚¤ë³´ë“œë¥¼ ëˆ„ë¥´ë©´ ì¦‰ì‹œ ON
 ì¼œì§„ í›„ ìµœì†Œ 1ë¶„ ë™ì•ˆ ìœ ì§€ë¨ (ì¦‰ì‹œ ë‹¤ì‹œ êº¼ì§€ì§€ ì•ŠìŒ)
 Windows 10/11ì—ì„œë„ ì •ìƒ ì‘ë™ í™•ì¸