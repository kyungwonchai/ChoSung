tworkOnMainThreadException 에러는 Android에서 네트워크 작업(예: HTTP 요청)을 메인 스레드(UI 스레드)에서 실행하려고 할 때 발생합니다. Android는 앱이 메인 스레드에서 네트워크 작업을 수행하는 것을 금지하여, UI가 응답하지 않게 되는 것을 방지합니다. 네트워크 작업은 반드시 별도의 스레드에서 수행해야 합니다.

이 문제를 해결하려면, 네트워크 작업을 AsyncTask, Thread, 또는 더 현대적인 방식으로는 Kotlin Coroutines를 사용하여 백그라운드 스레드에서 실행해야 합니다. 여기서는 Kotlin Coroutines를 사용하는 방법을 소개하겠습니다.

1. Kotlin Coroutines 설정
build.gradle 파일에 코루틴 라이브러리를 추가합니다.

gradle
코드 복사
dependencies {
    implementation 'org.jetbrains.kotlinx:kotlinx-coroutines-android:1.5.0'
}
2. MainActivity.kt에서 코루틴 사용하기
이제 MainActivity에서 코루틴을 사용하여 네트워크 요청을 백그라운드에서 수행하도록 수정하겠습니다.

수정된 MainActivity.kt 코드:
kotlin
코드 복사
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.FileProvider
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 코루틴을 사용하여 네트워크 작업을 백그라운드에서 수행합니다.
        CoroutineScope(Dispatchers.IO).launch {
            checkForUpdates(this@MainActivity, "apk1")
        }
    }

    // 서버에서 APK 버전을 확인하고, 필요 시 업데이트를 진행합니다.
    private suspend fun checkForUpdates(context: Context, apkName: String) {
        Log.d("TTTTT", "Starting checkForUpdates for $apkName")

        val client = OkHttpClient()
        val request = Request.Builder()
            .url("http://10.244.122.222:8116/api/$apkName/version") // 서버의 IP와 포트 사용
            .build()

        try {
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code: ${response.code}")
                throw IOException("Unexpected code $response")
            }

            val responseData = response.body?.string()
            Log.d("TTTTT", "Received response: $responseData")

            val jsonObject = JSONObject(responseData)
            val latestVersion = jsonObject.getString("version")
            val apkUrl = jsonObject.getString("apk_url")

            val currentVersion = BuildConfig.VERSION_NAME
            Log.d("TTTTT", "Current version: $currentVersion, Latest version: $latestVersion")

            if (latestVersion != currentVersion) {
                Log.d("TTTTT", "New version available. Initiating download.")
                downloadAndInstallApk(context, apkUrl, apkName)
            } else {
                Log.d("TTTTT", "App is up to date. No update needed.")
            }
        } catch (e: Exception) {
            Log.e("TTTTT", "Error during checkForUpdates: ${e.message}", e)
        }
    }

    // APK 파일을 다운로드하고 설치를 진행합니다.
    private suspend fun downloadAndInstallApk(context: Context, apkUrl: String, apkName: String) {
        Log.d("TTTTT", "Starting download for $apkName from $apkUrl")

        val client = OkHttpClient()
        val request = Request.Builder().url("http://10.244.122.222:8116$apkUrl").build()

        try {
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code during download: ${response.code}")
                throw IOException("Unexpected code $response")
            }

            val apkFile = File(context.getExternalFilesDir(null), "$apkName.apk")
            FileOutputStream(apkFile).use { fos ->
                fos.write(response.body?.bytes())
                Log.d("TTTTT", "APK file downloaded successfully to ${apkFile.absolutePath}")
            }

            val apkUri: Uri = FileProvider.getUriForFile(
                context,
                context.applicationContext.packageName + ".provider",
                apkFile
            )

            withContext(Dispatchers.Main) {
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
                    setDataAndType(apkUri, "application/vnd.android.package-archive")
                }
                context.startActivity(intent)
                Log.d("TTTTT", "APK installation initiated for $apkName")
            }

        } catch (e: Exception) {
            Log.e("TTTTT", "Error during downloadAndInstallApk: ${e.message}", e)
        }
    }
}
주요 변경 사항 설명:
코루틴 사용:

CoroutineScope(Dispatchers.IO).launch {}: 네트워크 작업을 백그라운드 스레드(입출력 작업에 최적화된 Dispatchers.IO)에서 실행합니다.
suspend fun: 네트워크 요청을 비동기적으로 실행할 수 있도록 suspend 함수를 사용합니다.
withContext(Dispatchers.Main):

다운로드 및 설치 후 UI 작업(예: Intent로 설치 화면 호출)을 위해 메인 스레드로 다시 전환합니다.
이제 이 코드로 NetworkOnMainThreadException을 피하면서 네트워크 작업을 비동기로 수행할 수 있습니다. Android 앱이 더 