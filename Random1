// 필요한 네임스페이스 추가
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration; // AppSettings 및 ConnectionStrings 사용 위해 추가
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices; // Marshal 사용

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 윈도우(MainWindow)와 연결되는 주 ViewModel 클래스입니다.
    /// 사물함 목록 관리, 마스터 키 확인, 다른 ViewModel(MasterData, Log) 관리 등을 담당합니다.
    /// (.NET Framework 4.8 버전)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context; // 데이터베이스 컨텍스트
        private ObservableCollection<LockerAssignment> _lockerAssignments; // 사물함 목록
        private LockerAssignment _selectedAssignment; // 선택된 사물함
        private string _statusBarText = "준비 완료"; // 상태 메시지
        private string _currentAdmin = "홍길동A"; // 현재 관리자 (예시 - 실제 구현 시 로그인 정보 사용)

        // --- 마스터 키 관련 속성 ---
        private SecureString _masterPasswordInput; // 마스터 키 입력값 (PasswordBox 바인딩용)
        private bool _isMasterModeEnabled = false; // 마스터 관리 탭 활성화 여부

        // --- 마스터 데이터 목록 (ComboBox 바인딩용) ---
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;

        // --- 자식 ViewModel 인스턴스 (탭 바인딩용) ---
        public MasterDataViewModel MasterDataVM { get; private set; }
        public LogViewModel LogVM { get; private set; }


        #region Public Properties (UI 바인딩용)

        /// <summary>
        /// 사물함 배정 목록 (메인 그리드 바인딩)
        /// </summary>
        public ObservableCollection<LockerAssignment> LockerAssignments
        {
            get => _lockerAssignments;
            set => SetProperty(ref _lockerAssignments, value);
        }

        /// <summary>
        /// 메인 그리드에서 선택된 사물함 항목
        /// </summary>
        public LockerAssignment SelectedAssignment
        {
            get => _selectedAssignment;
            set
            {
                if (SetProperty(ref _selectedAssignment, value))
                {
                    // 선택 변경 시 관련 Command의 CanExecute 상태 업데이트
                    ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged();
                }
            }
        }

        /// <summary>
        /// 하단 상태 표시줄 메시지
        /// </summary>
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }

        /// <summary>
        /// 마스터 키 입력 PasswordBox와 바인딩될 SecureString
        /// </summary>
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }

        /// <summary>
        /// 마스터 관리 탭의 표시 여부 (마스터 키 확인 후 true로 변경)
        /// </summary>
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }

        // --- 콤보박스 ItemsSource 바인딩용 마스터 데이터 목록 ---
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }

        #endregion

        #region Commands (UI 버튼 등과 바인딩)
        public ICommand LoadDataCommand { get; } // 전체 데이터 새로고침
        public ICommand SaveChangesCommand { get; } // 사물함 탭 변경 사항 저장
        public ICommand AddNewCommand { get; } // 새 사물함 추가
        public ICommand DeleteCommand { get; } // 선택 사물함 삭제
        public ICommand ClearAssignmentCommand { get; } // 선택 사물함 배정 해제
        public ICommand CheckMasterPasswordCommand { get; } // 마스터 키 확인
        public ICommand RefreshMasterDataCommand { get; } // 마스터 데이터 목록만 새로고침

        #endregion

        /// <summary>
        /// MainViewModel 생성자
        /// </summary>
        public MainViewModel()
        {
            // DbContext 생성 및 예외 처리
            try
            {
                _context = new LockerDbContext();
                // 데이터베이스 연결 테스트 (선택 사항)
                // _context.Database.Connection.Open();
                // _context.Database.Connection.Close();
            }
            catch (Exception ex)
            {
                 // DbContext 생성 또는 연결 실패 시 사용자에게 알리고 ViewModel 초기화 중단
                 MessageBox.Show($"데이터베이스 컨텍스트 생성 또는 연결 중 오류 발생:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 StatusBarText = "데이터베이스 연결 오류!";
                 // 자식 ViewModel 생성 및 데이터 로드 방지
                 return;
            }

            // ObservableCollection 초기화
            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>();
            _allFloors = new ObservableCollection<Floor>();
            _allZones = new ObservableCollection<Zone>();
            _allSubParts = new ObservableCollection<SubPart>();
            _allAdministrators = new ObservableCollection<Administrator>();

            // 자식 ViewModel 생성 (DbContext 전달)
            MasterDataVM = new MasterDataViewModel(_context);
            LogVM = new LogViewModel(_context);

            // Command 초기화
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync());

            // DbContext 생성 성공 시 데이터 로드 시작
            if (_context != null)
            {
                 _ = LoadInitialDataAsync();
            }
        }

        /// <summary>
        /// 초기 데이터 로드 (사물함 목록 + 마스터 데이터 목록)
        /// </summary>
        private async Task LoadInitialDataAsync()
        {
            await LoadAssignmentsAsync();
            await LoadMasterDataAsync();
        }

        /// <summary>
        /// 사물함 배정 목록 로드
        /// </summary>
        private async Task LoadAssignmentsAsync()
        {
            if (_context == null) return;
            StatusBarText = "사물함 목록 로딩 중...";
            try
            {
                // AsNoTracking()을 사용하면 성능은 향상되지만, 로드된 엔티티의 변경 추적이 안 됨.
                // 여기서는 편집 기능을 사용하므로 AsNoTracking() 없이 로드.
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation)
                                               .ToListAsync();
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"총 {LockerAssignments.Count}개의 사물함 정보를 로드했습니다.";
            }
            catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); }
        }

        /// <summary>
        /// 마스터 데이터 목록 로드 (콤보박스용)
        /// </summary>
        private async Task LoadMasterDataAsync()
        {
            if (_context == null) return;
            StatusBarText = "마스터 데이터 로딩 중...";
            try
            {
                // MainViewModel에서 사용하는 콤보박스용 목록만 로드
                // AsNoTracking()을 사용하면 마스터 데이터 편집 시 문제가 될 수 있으므로 주의
                AllLockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).ToListAsync());
                AllFloors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(f => f.Name).ToListAsync());
                AllZones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(z => z.Name).ToListAsync());
                AllSubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(p => p.Name).ToListAsync());
                AllAdministrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(a => a.Name).ToListAsync());
                StatusBarText = "마스터 데이터 로드 완료.";

                // MasterDataViewModel의 목록 갱신은 해당 ViewModel의 LoadAllMasterDataAsync 호출로 처리
                // (RefreshMasterDataCommand 또는 초기 로드 시 호출됨)
            }
            catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); }
        }


        /// <summary>
        /// 마스터 키 비밀번호 확인 로직
        /// </summary>
        private void CheckMasterPassword(object parameter)
        {
            try
            {
                // App.config에서 마스터 키 읽기 (using System.Configuration 필요)
                string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"];
                if (string.IsNullOrEmpty(storedMasterKey))
                {
                    MessageBox.Show("설정 파일(App.config)에 마스터 키(MasterKey)가 정의되지 않았습니다.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                    return;
                }

                // 입력된 SecureString을 일반 string으로 변환 (보안 주의)
                string plainPassword = ConvertToUnsecureString(MasterPasswordInput);

                // 비교
                if (plainPassword == storedMasterKey)
                {
                    IsMasterModeEnabled = true; // 마스터 관리 탭 활성화
                    StatusBarText = "마스터 관리자 모드가 활성화되었습니다.";
                    MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information);
                }
                else
                {
                    IsMasterModeEnabled = false; // 마스터 관리 탭 비활성화
                    MessageBox.Show("마스터 키가 일치하지 않습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
                // 입력 필드 초기화 (PasswordBox Helper에서 처리하거나, View에서 직접 처리 필요)
            }
            catch (ConfigurationErrorsException confEx) // 설정 파일 오류 처리
            {
                 MessageBox.Show($"설정 파일(App.config) 처리 중 오류 발생:\n{confEx.Message}\n\nApp.config 파일 구조를 확인하세요.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            catch (Exception ex) // 기타 예외 처리
            {
                MessageBox.Show($"마스터 키 확인 중 오류 발생: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #region CRUD 및 기타 메서드

        /// <summary>
        /// 사물함 관리 탭의 변경 사항 저장
        /// </summary>
        private async Task SaveChangesAsync()
        {
             if (_context == null) return;
            StatusBarText = "변경 사항 저장 중...";
            try
            {
                 // 변경된 LockerAssignment 엔티티만 찾기
                 var changedEntries = _context.ChangeTracker.Entries<LockerAssignment>()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); // ToList()로 복사

                 // 중복 위치 검사 (UI 컬렉션 기준)
                 var allItemsToCheck = LockerAssignments.ToList();
                 var duplicates = allItemsToCheck
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key);

                 if (duplicates.Any())
                 {
                     MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                     // 중복 발생 시 변경된 엔트리 롤백
                     RollbackChanges(changedEntries);
                     return;
                 }

                // 변경된 항목에 관리자 정보 업데이트
                foreach(var entry in changedEntries) // 이미 ToList()로 복사했으므로 안전
                {
                    entry.Entity.Administrator = _currentAdmin; // 현재 관리자 이름 설정
                }

                // 변경 사항 저장 (로그는 DbContext에서 자동으로 기록됨)
                int changedCount = await _context.SaveChangesAsync();
                StatusBarText = $"성공적으로 {changedCount}개의 변경 사항을 저장했습니다.";
            }
            catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList()); }
            catch (Exception ex) { HandleGenericException("저장", ex); RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList()); }
        }

        /// <summary>
        /// EF6에서 변경 사항 롤백 (간단 버전)
        /// </summary>
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries)
        {
            if (_context == null) return;
            // ToList()로 복사본을 만들어 반복 중 컬렉션 변경 오류 방지
            foreach (var entry in changedEntries.ToList())
            {
                switch (entry.State)
                {
                    case EntityState.Modified:
                        entry.CurrentValues.SetValues(entry.OriginalValues); // 원본 값으로 복원
                        entry.State = EntityState.Unchanged; // 상태 변경
                        break;
                    case EntityState.Added:
                        entry.State = EntityState.Detached; // 컨텍스트에서 분리
                        // UI 컬렉션에서도 제거
                        if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity))
                        {
                            LockerAssignments.Remove(addedEntity);
                        }
                        break;
                    case EntityState.Deleted:
                        entry.State = EntityState.Unchanged; // 삭제 취소 (DB 반영 전이므로)
                        break;
                }
            }
             StatusBarText = "변경 사항이 롤백되었습니다.";
        }

        /// <summary>
        /// 새 사물함 추가 (UI 및 Context)
        /// </summary>
        private void AddNewLocker(object parameter)
        {
            if (_context == null) return;
            var newAssignment = new LockerAssignment {
                LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", // 마스터 목록에서 기본값 가져오기
                Floor = AllFloors.FirstOrDefault()?.Name ?? "1",
                Zone = AllZones.FirstOrDefault()?.Name ?? "A",
                SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), // 임시 고유 이름
                Administrator = _currentAdmin,
                LastUpdated = DateTime.Now
            };
            LockerAssignments.Add(newAssignment); // UI에 추가
            _context.LockerAssignments.Add(newAssignment); // Context에 추가 (상태: Added)
            SelectedAssignment = newAssignment; // 새로 추가된 행 선택
            StatusBarText = "새 사물함 추가됨. 세부 정보 입력 후 저장 필요.";
        }

        /// <summary>
        /// 선택된 사물함 삭제
        /// </summary>
        private async Task DeleteSelectedAsync()
        {
             if (_context == null || SelectedAssignment == null) return;
            if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함 정보를 정말 삭제하시겠습니까?", "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "삭제 중...";
                try
                {
                    var assignmentToDelete = SelectedAssignment;
                    var entry = _context.Entry(assignmentToDelete);
                    if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } // Context에 없으면 Attach
                     _context.LockerAssignments.Remove(assignmentToDelete); // 삭제 상태로 변경
                    int changedCount = await _context.SaveChangesAsync(); // DB에 저장 (로그 기록됨)
                    LockerAssignments.Remove(assignmentToDelete); // UI에서 제거
                    SelectedAssignment = null; // 선택 해제
                    StatusBarText = $"성공적으로 {changedCount}개의 레코드를 삭제했습니다.";
                }
                catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); await LoadAssignmentsAsync(); } // 오류 시 목록 새로고침
                catch (Exception ex) { HandleGenericException("삭제", ex); await LoadAssignmentsAsync(); } // 오류 시 목록 새로고침
            }
        }

        /// <summary>
        /// 선택된 사물함의 사용자 배정 정보 해제
        /// </summary>
        private void ClearSelectedAssignment(object parameter)
        {
             if (_context == null || SelectedAssignment == null) return;
            SelectedAssignment.UserName = null;
            SelectedAssignment.KnoxId = null;
            SelectedAssignment.SubPart = null;
            // 상태를 Modified로 변경하여 저장 시 반영되도록 함
            _context.Entry(SelectedAssignment).State = EntityState.Modified;
            SelectedAssignment.Administrator = _currentAdmin; // 변경자 기록
            StatusBarText = "배정 해제됨. 변경 사항 저장 필요.";
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// 데이터 접근 중 발생하는 일반 예외 처리
        /// </summary>
        private void HandleGenericException(string operation, Exception ex)
        {
            StatusBarText = $"{operation} 중 오류 발생: {ex.Message}";
            MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
        }

         /// <summary>
        /// 데이터베이스 업데이트 예외 처리
        /// </summary>
        private void HandleDbUpdateException(DbUpdateException dbEx)
        {
            // InnerException 내용을 포함하여 더 자세한 오류 메시지 표시
            var innerExceptionMessage = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message;
            StatusBarText = $"데이터 저장/삭제 오류: {innerExceptionMessage}";
            MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExceptionMessage}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            // 오류 발생 엔티티 상태 복원 시도
            try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 시 무시 */ }
        }

        /// <summary>
        /// SecureString을 일반 string으로 변환 (메모리 보안 주의)
        /// </summary>
        private string ConvertToUnsecureString(SecureString securePassword)
        {
            if (securePassword == null) return string.Empty;
            IntPtr unmanagedString = IntPtr.Zero;
            try
            {
                // SecureString -> BSTR (COM 문자열) -> .NET string
                unmanagedString = Marshal.SecureStringToGlobalAllocUnicode(securePassword);
                return Marshal.PtrToStringUni(unmanagedString);
            }
            finally
            {
                // 할당된 비관리 메모리 해제
                Marshal.ZeroFreeGlobalAllocUnicode(unmanagedString);
            }
        }

        #endregion

        #region IDisposable 구현 (DbContext 해제)
        private bool disposed = false;

        /// <summary>
        /// 관리되는 리소스 및 관리되지 않는 리소스를 해제합니다.
        /// </summary>
        /// <param name="disposing">true이면 관리되는 리소스를 해제하고, false이면 관리되지 않는 리소스만 해제합니다.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    // 관리되는 리소스 해제 (DbContext 인스턴스)
                    _context?.Dispose();
                }
                // 관리되지 않는 리소스 해제 (이 클래스에는 없음)

                disposed = true;
            }
        }

        /// <summary>
        /// 이 인스턴스에서 사용하는 모든 리소스를 해제합니다.
        /// </summary>
        public void Dispose()
        {
            Dispose(true); // 관리되는 리소스와 관리되지 않는 리소스 모두 해제
            GC.SuppressFinalize(this); // 가비지 수집기가 Finalize 메서드를 호출하지 않도록 함
        }
        #endregion
    }