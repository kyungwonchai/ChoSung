네, 알겠습니다. 프리팹에 MaskIdentifier와 LampIdentifier 스크립트를 수동으로 추가하는 과정을 없애고, 씬 생성 스크립트가 이 모든 것을 자동으로 처리하도록 수정했습니다.

이제 정말로 씬 생성 버튼 한 번만 누르면, 프리팹 수정부터 랙 배치까지 모두 완료됩니다.

아래는 요청하신, 아주 상세한 한글 주석이 달린 최종 스크립트 2개입니다.

## 1. 최종 RackLayoutGenerator.cs (씬 자동 구성 + 프리팹 자동 수정 기능)
이 스크립트는 이제 랙을 배치하기 전에, 선택한 프리팹을 열어 Mask_와 Lamp_ 오브젝트에 필요한 식별 스크립트를 자동으로 붙여주는 기능이 추가되었습니다.

설치 위치: Project 창의 Editor 폴더

C#

// 유니티와 유니티 에디터의 기능을 사용하겠다고 선언합니다.
using UnityEngine;
using UnityEditor;

// 이 클래스는 유니티 에디터의 기능을 확장하는 스크립트입니다.
public class RackLayoutGenerator
{
    // --- 씬 배치 설정 ---
    private static readonly int RACK_COUNT_PER_ROW = 12;      // 한 줄에 배치될 랙의 개수
    private static readonly float RACK_GAP = 0.01f;           // 랙과 랙 사이의 간격
    private static readonly float AISLE_WIDTH = 4.0f;         // A열과 B열 사이의 복도 넓이

    // 유니티 상단 메뉴에 "Tools/SMD Rack/Generate Final Layout" 버튼을 생성합니다.
    [MenuItem("Tools/SMD Rack/Generate Final Layout")]
    private static void GenerateLayout()
    {
        // 사용자가 Project 창에서 선택한 오브젝트를 가져옵니다.
        GameObject rackPrefab = Selection.activeObject as GameObject;
        // 프리팹을 선택하지 않았다면, 오류 메시지를 띄우고 작업을 중단합니다.
        if (rackPrefab == null) { EditorUtility.DisplayDialog("오류", "Project 창에서 랙 '프리팹'을 먼저 선택해주세요.", "확인"); return; }

        // ★★★ 프리팹 자동 수정 기능 호출 ★★★
        // 씬을 생성하기 전에, 원본 프리팹에 식별 스크립트가 없으면 자동으로 추가합니다.
        AddIdentifierScriptsToPrefab(rackPrefab);

        // "Rack_Installations" 라는 이름의 부모 오브젝트를 찾거나 새로 생성합니다.
        GameObject parentObject = new GameObject("Rack_Installations");
        
        // 프리팹의 전체 너비를 정확하게 계산합니다.
        Bounds totalBounds = new Bounds();
        Renderer[] renderers = rackPrefab.GetComponentsInChildren<Renderer>();
        if(renderers.Length > 0)
        {
            totalBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers) { totalBounds.Encapsulate(renderer.bounds); }
        }
        float rackWidth = totalBounds.size.x;

        // 모델을 똑바로 세우기 위한 기본 회전 값을 미리 계산합니다.
        Quaternion standingRotation = Quaternion.Euler(-90, 0, 0);

        // 첫 번째 줄 (A열)을 생성합니다.
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            // 프리팹의 복사본을 씬에 생성하고 parentObject의 자식으로 만듭니다.
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            // 이름을 "A01", "A02" ... 형식으로 깨끗하게 짓습니다.
            rackInstance.name = "A" + (i + 1).ToString("D2");
            // 순번에 맞춰 위치를 계산하고 배치합니다.
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, 0);
            // 랙을 세우고 Z축으로 180도 회전시킵니다.
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 0, 180);
        }
        
        // 두 번째 줄 (B열)을 생성합니다.
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            // 이름을 "B01", "B02" ... 형식으로 깨끗하게 짓습니다.
            rackInstance.name = "B" + (i + 1).ToString("D2");
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, AISLE_WIDTH);
            // 랙을 세우고 Y축으로 180도 회전시켜 A열과 마주보게 합니다.
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 180, 0);
        }
        EditorUtility.DisplayDialog("완료", "프리팹 자동 수정 및 랙 배치가 완료되었습니다.", "확인");
    }

    // 프리팹 파일 자체를 열어 식별 스크립트를 추가하는 함수
    private static void AddIdentifierScriptsToPrefab(GameObject rackPrefab)
    {
        // 프리팹 파일의 경로를 얻습니다.
        string prefabPath = AssetDatabase.GetAssetPath(rackPrefab);
        // 프리팹 파일을 메모리에 로드하여 수정 가능한 상태로 만듭니다.
        GameObject prefabContents = PrefabUtility.LoadPrefabContents(prefabPath);

        // 프리팹 내부의 모든 자식 오브젝트를 확인합니다.
        foreach(var identifier in prefabContents.GetComponentsInChildren<MaskIdentifier>(true))
        {
            // 이미 MaskIdentifier가 있다면 올바른 상태이므로 함수를 종료합니다.
            PrefabUtility.UnloadPrefabContents(prefabContents);
            return; 
        }

        // MaskIdentifier가 하나도 없을 경우에만 아래 로직을 실행합니다.
        Debug.Log($"'{rackPrefab.name}' 프리팹에 식별 스크립트를 추가합니다...");
        foreach(Transform child in prefabContents.GetComponentsInChildren<Transform>(true))
        {
            // 이름이 "Mask_"로 시작하고, 아직 식별 스크립트가 없다면 추가합니다.
            if(child.name.StartsWith("Mask_") && child.GetComponent<MaskIdentifier>() == null)
            {
                child.gameObject.AddComponent<MaskIdentifier>();
            }
            // 이름이 "Lamp_"로 시작하고, 아직 식별 스크립트가 없다면 추가합니다.
            if(child.name.StartsWith("Lamp_") && child.GetComponent<LampIdentifier>() == null)
            {
                child.gameObject.AddComponent<LampIdentifier>();
            }
        }

        // 변경된 내용을 실제 프리팹 파일에 저장합니다.
        PrefabUtility.SaveAsPrefabAsset(prefabContents, prefabPath);
        // 메모리에서 임시로 열었던 프리팹을 닫습니다.
        PrefabUtility.UnloadPrefabContents(prefabContents);
    }
}
## 2. 최종 RackSystemManager.cs (기능 담당)
이 스크립트는 새로운 Mask_01 규칙이 아닌, 원래의 Mask_A01, Lamp_C05 규칙으로 완벽하게 작동하는 최종 버전입니다. 랙 이름은 깨끗하게, 프리팹 내부 부품 이름은 원래대로 사용하는 가장 안정적인 방식입니다.

설치 위치: Project 창의 Scripts 폴더

C#

// 유니티의 기본 기능 및 UI 기능을 사용하겠다고 선언합니다.
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

// 이 클래스는 게임 오브젝트에 붙여서 사용하는 '컴포넌트'입니다. 시뮬레이션의 두뇌 역할을 합니다.
public class RackSystemManager : MonoBehaviour
{
    // --- Inspector 창에서 유니티 에디터와 연결할 변수들 ---
    [Header("핵심 연결 대상")]
    public Transform rackContainer; // 씬에 배치된 모든 랙들의 최상위 부모 오브젝트("Rack_Installations")를 연결할 슬롯

    [Header("머티리얼")]
    public Material defaultLampMaterial; // 램프가 꺼져있을 때의 재질
    public Material litLampMaterial;     // 램프가 켜졌을 때의 재질 (Emission 설정 필요)

    [Header("애니메이션")]
    public float animationDuration = 0.5f; // 마스크가 움직이는 시간 (초)
    public float slideOutDistance = 0.4f;  // 마스크가 튀어나오는 거리

    // --- 스크립트 내부에서 사용할 데이터 저장소 (빠른 검색을 위한 데이터베이스) ---
    // Key: "A01_Mask_C05"와 같은 고유 전체 주소, Value: 해당 게임 오브젝트
    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    
    // --- 마지막으로 활성화된 오브젝트의 상태를 기억하기 위한 변수들 ---
    private Coroutine lastAnimationCoroutine; // 마지막 애니메이션을 중지시키기 위해 저장
    private GameObject lastMovedMask;         // 마지막으로 움직인 마스크를 원래 위치로 되돌리기 위해 저장
    private Renderer lastLitLamp;             // 마지막으로 켜진 램프를 끄기 위해 저장
    private Vector3 lastMaskOriginalLocalPosition; // 마지막 마스크의 원래 위치 저장

    // 게임이 시작될 때 단 한 번만 호출되는 유니티 기본 함수
    void Start()
    {
        InitializeAllRacks(); // 모든 랙 정보를 수집하고 정리하는 함수를 실행
    }

    // 씬에 배치된 모든 램프와 마스크를 찾아 데이터베이스(Dictionary)에 등록하는 함수
    void InitializeAllRacks()
    {
        // rackContainer가 Inspector에 연결되지 않았다면 에러 메시지를 출력하고 중단
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        // rackContainer 아래의 모든 랙(A01, B01 등)을 하나씩 순회
        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name; // "A01", "B12" 등 깨끗한 이름
            // 해당 랙 하위의 모든 렌더러(보이는 모든 부품)를 가져옴
            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name; // 프리팹 내부 이름 "Mask_A01", "Lamp_C12"
                // 최종 고유 주소(키)를 조합 (예: "A01_Mask_A01")
                string globalKey = $"{rackName}_{localName}"; 

                // 이름에 따라 램프와 마스크를 구분하여 각각의 데이터베이스에 등록
                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                        lampRenderers.Add(globalKey, rend);
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                        maskObjects.Add(globalKey, rend.gameObject);
                }
            }
        }
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    // InputField에 입력된 바코드를 받아 처리하는 메인 함수
    public void ProcessBarcode(string barcode)
    {
        ResetPreviousSlot(); // 먼저 이전에 선택됐던 슬롯을 초기화
        
        // 입력된 바코드의 유효성을 검사 (11자리가 아니거나, MMF10으로 시작하지 않으면 무시)
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10")) return;

        // 바코드 "MMF10A01C05"를 규칙에 따라 정확히 해석
        string rackID = barcode.Substring(5, 3);   // "A01"
        string floor = barcode.Substring(8, 1);     // "C"
        string slotNum = barcode.Substring(9, 2);   // "05"
        
        // 해석된 정보로 데이터베이스에서 검색할 내부 주소(키)를 다시 조립
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}"; // "A01_Lamp_C05"
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}"; // "A01_Mask_C05"
        
        // 조립된 주소로 램프 데이터베이스에서 검색하고, 찾으면 기능을 실행
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }
        // 조립된 주소로 마스크 데이터베이스에서 검색하고, 찾으면 기능을 실행
        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
    }
    
    #region 보조 함수들
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;
        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }
        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;
        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
    #endregion
}

// 프리팹 내부 오브젝트 식별을 위한 태그용 스크립트들 (내용은 비어있는 것이 정상)
public class MaskIdentifier : MonoBehaviour { }