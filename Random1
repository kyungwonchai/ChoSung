, 알겠습니다! 그때처럼 FunctionStatusList를 사용하여 작업을 관리하는 방식으로 주석과 함께 정리해서 다시 제공해드리겠습니다. 아래 코드는 **FunctionStatusList**를 이용해 작업을 추가할 때 함수 이름, 작업 로직, 색상을 함께 넘기는 방식으로 작성되었습니다.

1. FunctionStatus 클래스 (작업 상태 관리)
csharp
코드 복사
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }  // 함수 이름
    public Func<Task> Task { get; set; }      // 실행할 작업 (함수)
    public Brush StatusColor { get; set; }    // 현재 상태에 따른 색상
    public string ExecutionTime { get; set; } // 작업 실행 시간 (초 단위)

    public FunctionStatus(string functionName, Func<Task> task, Brush initialColor)
    {
        FunctionName = functionName;  // 함수 이름
        Task = task;                  // 실행할 작업 (비동기 함수)
        StatusColor = initialColor;   // 초기 색상 (회색으로 시작)
        ExecutionTime = "Not started";  // 기본값: 아직 실행되지 않음
    }

    // 상태 업데이트 메서드 (색상 변경)
    public void UpdateStatus(Brush newColor)
    {
        StatusColor = newColor;
        OnPropertyChanged(nameof(StatusColor));
    }
}
설명:
FunctionStatus 클래스는 각 작업의 이름, 실행할 함수, 현재 상태 색상, 실행 시간을 관리합니다.
FunctionStatusList라는 컬렉션에서 각 작업의 상태를 관리하고, 색상 변경, 실행 시간 업데이트 등을 할 수 있습니다.
2. TaskModel 클래스 (작업 모델)
csharp
코드 복사
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }   // 물류표 번호
    public string PO_NO { get; set; }    // 주문 번호

    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }  // 함수 상태 리스트
    public string Status { get; set; }   // 전체 작업 상태 (Pending, Running, Completed)

    private Stopwatch _stopwatch;  // 전체 작업 시간 측정용

    // 총 소요 시간을 표시할 컬럼
    private int _totalSeconds;
    public int TotalSeconds
    {
        get => _totalSeconds;
        set
        {
            _totalSeconds = value;
            OnPropertyChanged(nameof(TotalSeconds));
        }
    }

    public TaskModel()
    {
        FunctionStatusList = new ObservableCollection<FunctionStatus>();  // 함수 상태 리스트 초기화
        Status = "Pending";  // 기본 상태 (대기 중)
        _stopwatch = new Stopwatch();  // 총 작업 시간 측정을 위한 스톱워치 초기화

        // 시퀀스 플래그에 따라 작업 초기화
        InitializeFunctions(1);  // SequenceFlag = 1 (예시)
    }

    // 시퀀스 플래그에 따라 작업을 초기화하고, 함수 이름, 함수 로직, 초기 색상을 설정
    private void InitializeFunctions(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
                AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
                AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
                break;
            case 2:
                AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
                AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
                AddFunction("Task D", ExecuteTaskD, Brushes.Gray);
                break;
            case 3:
                AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
                AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
                AddFunction("Task E", ExecuteTaskE, Brushes.Gray);
                break;
        }
    }

    // 함수를 추가하는 메서드 (이름, 실행할 함수, 초기 색상)
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);  // 리스트에 추가
    }

    // 전체 작업을 순차적으로 실행
    public async Task StartTask()
    {
        _stopwatch.Restart();  // 작업 시작 시간 기록
        Status = "Running";    // 상태를 Running으로 변경
        await ExecuteTaskSequence();  // 작업 실행
        Status = "Completed";  // 작업 완료
        TotalSeconds = (int)_stopwatch.Elapsed.TotalSeconds;  // 총 소요 시간을 기록
        _stopwatch.Stop();     // 스톱워치 멈춤
    }

    // 각 작업을 순차적으로 실행하고, 상태 색상 및 실행 시간을 업데이트
    private async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            Stopwatch functionStopwatch = new Stopwatch();  // 각 함수의 시간 측정용 스톱워치
            functionStopwatch.Start();  // 함수 시작 시간 기록

            // 각 작업의 상태를 업데이트하며 실행
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);

            functionStopwatch.Stop();  // 함수 종료 시간 기록
            functionStatus.ExecutionTime = $"{functionStopwatch.Elapsed.TotalSeconds:F2} seconds";  // 실행 시간을 기록
        }
    }

    // 작업을 실행하면서 도형의 색상을 업데이트 (실행 중 -> 완료)
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        // 작업 시작 시 색상을 변경 (진행 중 색상)
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);
        });

        await task();  // 작업 실행

        // 작업 완료 시 색상을 변경 (완료 색상)
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);
        });
    }

    // 예시 함수들 (Task A, Task B, Task C)
    private async Task ExecuteTaskA() { await Task.Delay(1000); }
    private async Task ExecuteTaskB() { await Task.Delay(1500); }
    private async Task ExecuteTaskC() { await Task.Delay(2000); }
    private async Task ExecuteTaskD() { await Task.Delay(2500); }
    private async Task ExecuteTaskE() { await Task.Delay(3000); }
}
설명:
**FunctionStatusList**는 각 작업의 상태를 관리하는 리스트입니다. 이 리스트에 작업의 이름, 함수, 색상을 추가합니다.
**InitializeFunctions()**는 SequenceFlag 값에 따라 각 작업을 설정합니다. 각 함수는 이름, 함수 로직, 색상(회색)을 받습니다.
작업이 실행될 때는 해당 작업의 상태를 SkyBlue로 변경하고, 완료되면 Green으로 변경합니다.
작업의 실행 시간을 Stopwatch로 기록하고, 각 함수가 완료될 때 그 실행 시간을 기록합니다.
전체 작업이 완료되면 Status는 Completed로 설정되고, 총 실행 시간이 TotalSeconds에 기록됩니다.
3. TaskQueue 클래스
csharp
코드 복사
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;
    private bool _isPaused = false;

    public bool IsRunning => _isRunning;
    public bool IsPaused => _isPaused;

    // 작업을 큐에 추가하고, 실행 중이 아니면 즉시 실행
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);
        if (!_isRunning && !_isPaused)
        {
            RunNextTask();
        }
    }

    // 작업 큐의 다음 작업을 실행하는 메서드
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;
        var task = _tasks.Dequeue();
        await task();
        _isRunning = false;

        if (!_isPaused)
        {
            RunNextTask();  // 다음 작업 실행
        }
    }

    // 작업을 일시정지
    public void Pause()
    {
        _isPaused = true;
    }

    // 작업을 재개
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;
            if (!_isRunning)
            {
                RunNextTask();  // 재개 시 다음 작업 실행
            }
        }
    }
}
설명:
**TaskQueue**는 작업을 큐에 저장하고, 순차적으로 작업을 실행합니다.
작업이 끝나면 자동으로 다음 작업을 실행하며, 일시정지 시에는 작업을 멈추고 재개 시 다시 이어서 실행합니다.
4. MainViewModel에서 TaskModel과 연동
csharp
코드 복사
public class MainViewModel : ViewModelBase
{
    private TaskQueue _taskQueue;
    public ObservableCollection<TaskModel> TaskList { get; set; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        _taskQueue = new TaskQueue();
    }

    // 로그 파일이 감지되었을 때 작업 추가
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        var taskModel = new TaskModel(logEntry.SequenceFlag);  // SequenceFlag에 따라 작업 초기화
        TaskList.Add(taskModel);  // 작업 목록에 추가
        _taskQueue.EnqueueTask(taskModel.StartTask);  // 큐에 작업 추가
    }
}
설명:
**MainViewModel**에서는 로그 파일이 감지될 때마다 TaskModel을 생성하고, 작업을 TaskQueue에 추가합니다.
이렇게 추가된 작업은 큐에서 순차적으로 실행되며, 작업 상태가 UI에 반영됩니다.
5. XAML 연동 (FunctionStatus 도형 및 상태 표시)
xml
코드 복사
<DataGrid ItemsSource="{Binding TaskList}">
    <DataGrid.Columns>
        <!-- PO_NO 및 MAG_NO 컬럼 -->
        <DataGridTextColumn Header="PO NO" Binding="{Binding PO_NO}" />
        <DataGridTextColumn Header="MAG NO" Binding="{Binding MAG_NO}" />

        <!-- 함수 상태 도형을 표시하는 컬럼 -->
        <DataGridTemplateColumn Header="Function Status">
            <DataGridTemplateColumn.CellTemplate>
                <DataTemplate>
                    <ItemsControl ItemsSource="{Binding FunctionStatusList}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <!-- 함수 상태 도형 -->
                                    <Ellipse Width="30" Height="30" Fill="{Binding StatusColor}">
                                        <Ellipse.ToolTip>
                                            <TextBlock Text="{Binding FunctionName}" />
                                        </Ellipse.ToolTip>
                                    </Ellipse>
                                </StackPanel>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </DataTemplate>
            </DataGridTemplateColumn.CellTemplate>
        </DataGridTemplateColumn>

        <!-- 작업 상태 및 총 소요 시간 컬럼 -->
        <DataGridTextColumn Header="Status" Binding="{Binding Status}" />
        <DataGridTextColumn Header="Total Time (s)" Binding="{Binding TotalSeconds}" />
    </DataGrid.Columns>
</DataGrid>
설명:
각 작업 상태를 도형으로 표시하며, 도형의 색상은 작업의 상태에 따라 변경됩니다.
툴팁을 사용하여 각 도형에 해당하는 함수 이름을 표시합니다.
TotalSeconds 컬럼을 추가하여 작업이 완료되면 그 작업에 소요된 총 시간을 표시합니다.
이제 이 구조로 작업을 정의하고, FunctionStatusList를 통해 각 작업을 관리하며, UI에 반영할 수 있습니다. 각 함수의 이름, 실행 상태, 실행 시간을 관리하고, 이를 UI에서 시각적으로 도형과 함께 표시하는 방식입니다