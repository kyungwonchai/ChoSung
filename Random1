코드 모듈 간에 데이터를 전송하고 동작을 트리거하기 위한 매우 효율적인 방법입니다. 아래에서 제가 사용한 다양한 이벤트 전달 방식을 종류별로 설명하겠습니다. 이 설명은 각각의 이벤트가 어떻게 동작하는지, 그리고 어떤 상황에서 사용되는지를 이해하는 데 도움이 될 것입니다.

1. 네임드 파이프를 통한 로그 전달 (프로세스 간 통신)
개념: 네임드 파이프(named pipe)는 동일한 컴퓨터 내에서 서로 다른 프로세스 간에 데이터를 전송할 수 있는 메커니즘을 제공합니다. 이를 통해 하나의 프로세스(예: 서비스)가 다른 프로세스(예: 메인 애플리케이션)에 데이터를 전송할 수 있습니다.

사용 시나리오:

서비스에서 로그 메시지를 메인 애플리케이션으로 전송하는 경우. 서비스는 시스템에서 백그라운드로 실행되고 있으며, 네임드 파이프 서버(named pipe server)를 통해 로그 데이터를 메인 애플리케이션의 네임드 파이프 클라이언트(named pipe client)로 전송합니다.
이 방식은 프로세스 간 통신(IPC)을 구현할 때 유용합니다.
예시:

서비스 코드는 네임드 파이프 서버를 사용하여 로그를 전송합니다.
메인 애플리케이션 코드는 네임드 파이프 클라이언트를 사용하여 서비스를 통해 전송된 로그를 수신합니다.
csharp
코드 복사
// 서비스 코드 - 로그 메시지를 네임드 파이프로 전송
private void SendLogToUI(string message)
{
    using (var pipeServer = new NamedPipeServerStream("RouterMiddleACRLogPipe", PipeDirection.Out))
    {
        pipeServer.WaitForConnection();
        using (var writer = new StreamWriter(pipeServer))
        {
            writer.WriteLine(message);
        }
    }
}

// 메인 애플리케이션 코드 - 네임드 파이프 클라이언트로 로그 메시지를 수신
private void StartListeningToServiceLogs()
{
    Task.Run(() =>
    {
        using (var pipeClient = new NamedPipeClientStream(".", "RouterMiddleACRLogPipe", PipeDirection.In))
        {
            pipeClient.Connect();
            using (var reader = new StreamReader(pipeClient))
            {
                while (!reader.EndOfStream)
                {
                    string message = reader.ReadLine();
                    Dispatcher.Invoke(() => ViewModel.LogMessage(message, LogType.Service));
                }
            }
        }
    });
}
2. 이벤트를 통한 로그 전달 (동일 프로세스 내 클래스 간 통신)
개념: 이벤트(event)는 클래스가 외부에 특정 상태 변경이나 동작을 알릴 수 있는 방법을 제공합니다. 이벤트는 일반적으로 델리게이트(delegate)를 기반으로 하며, 다른 클래스에서 해당 이벤트에 구독(subscribe)하면 이벤트가 발생했을 때 자동으로 알림을 받을 수 있습니다.

사용 시나리오:

서비스 상태 변화와 같은 중요한 시스템 이벤트를 메인 애플리케이션에서 처리할 때.
ServiceControllerHelper 클래스가 서비스 상태를 모니터링하고, 상태 변화(예: 서비스 중지 또는 오류 발생)를 이벤트로 알려줍니다.
이벤트 핸들러는 해당 이벤트를 처리하여 로그를 업데이트하거나 UI를 변경합니다.
예시:

ServiceControllerHelper 클래스는 서비스 상태와 관련된 로그 메시지를 생성하고, 이를 이벤트를 통해 MainViewModel에 전달합니다.
MainViewModel 클래스는 이 이벤트를 구독하여, 로그 메시지를 UI에 추가합니다.
csharp
코드 복사
// ServiceControllerHelper - 로그 메시지를 전송하는 이벤트 정의 및 사용
public class ServiceControllerHelper
{
    public event Action<string> OnLogMessage; // 로그 메시지를 전달하는 이벤트

    public void CheckServiceStatus()
    {
        try
        {
            _serviceController.Refresh();
            string status = _serviceController.Status.ToString();
            OnLogMessage?.Invoke($"서비스 상태: {status}"); // 로그 이벤트 트리거

            if (_serviceController.Status == ServiceControllerStatus.Stopped)
            {
                OnLogMessage?.Invoke("서비스가 중지되었습니다. 재시작합니다...");
                RestartService();
            }
        }
        catch (Exception ex)
        {
            OnLogMessage?.Invoke($"서비스 상태 확인 중 오류 발생: {ex.Message}");
        }
    }
}

// MainViewModel - 로그 이벤트를 구독하고 처리
public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<string> ServiceLogs { get; } = new ObservableCollection<string>();

    public MainViewModel()
    {
        var serviceControllerHelper = new ServiceControllerHelper();
        serviceControllerHelper.OnLogMessage += message => LogMessage(message, LogType.Service); // 로그 이벤트 핸들러 등록
    }

    private void LogMessage(string message, LogType logType)
    {
        App.Current.Dispatcher.Invoke(() =>
        {
            if (logType == LogType.Service)
            {
                ServiceLogs.Add(message);
            }
            // 다른 로그 유형에 따라 다른 컬렉션에 추가 가능
        });
    }
}
3. UI 스레드에서의 이벤트 처리 (Dispatcher 사용)
개념: WPF 애플리케이션에서는 대부분의 UI 작업이 UI 스레드에서 수행되어야 합니다. 따라서 백그라운드 스레드에서 이벤트가 발생한 경우, UI 스레드에서 안전하게 작업을 수행하기 위해 Dispatcher를 사용하여 작업을 UI 스레드로 디스패치(dispatch)해야 합니다.

사용 시나리오:

백그라운드 작업에서 UI를 업데이트할 때 사용합니다. 예를 들어, 로그 메시지를 UI에 추가하거나, UI 컨트롤의 상태를 변경하는 경우.
ServiceControllerHelper에서 발생한 로그 이벤트를 MainViewModel이 처리할 때, 이 로그를 ListBox에 추가하려면 UI 스레드에서 실행되어야 합니다.
예시:

MainViewModel 클래스에서 Dispatcher.Invoke를 사용하여 백그라운드 스레드에서 발생한 이벤트를 UI 스레드에서 안전하게 처리합니다.
csharp
코드 복사
public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<string> ServiceLogs { get; } = new ObservableCollection<string>();

    public MainViewModel()
    {
        var serviceControllerHelper = new ServiceControllerHelper();
        serviceControllerHelper.OnLogMessage += message => LogMessage(message, LogType.Service); // 로그 이벤트 핸들러 등록
    }

    private void LogMessage(string message, LogType logType)
    {
        App.Current.Dispatcher.Invoke(() => // UI 스레드에서 안전하게 실행
        {
            if (logType == LogType.Service)
            {
                ServiceLogs.Add(message);
            }
            // 다른 로그 유형에 따라 다른 컬렉션에 추가 가능
        });
    }
}
요약
네임드 파이프 (프로세스 간 통신): 서비스에서 메인 애플리케이션으로 로그를 전송하는 데 사용되며, 서로 다른 프로세스 간의 통신을 처리합니다.
이벤트 (동일 프로세스 내 클래스 간 통신): 클래스가 상태 변화나 중요한 정보를 다른 클래스에 알릴 때 사용되며, ServiceControllerHelper와 MainViewModel 간의 통신을 관리합니다.
UI 스레드에서의 이벤트 처리 (Dispatcher 사용): UI 스레드에서 실행되어야 하는 작업을 백그라운드 스레드에서 안전하게 처리하기 위해 사용됩니다.
이런 구조를 통해, 각각의 로그 메시지는 올바른 방식으로 수집되고, 적절한 UI 요소에 표시될 수 있습니다. 이 방식은 모듈 간의 의존성을 최소화하면서도 효율적인 데이터 전송과 처리를 가능하게 합니다.