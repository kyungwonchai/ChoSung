네, 알겠습니다. SControlM 프로젝트의 ViewModels 폴더에 들어갈 MainControlViewModel.cs 파일의 코드를 제공해 드리겠습니다.

이 ViewModel은 SControlM의 주 UI 로직을 담당하며, 사용자의 입력을 받아 CommandSendService를 통해 SAgentM.App으로 명령을 전송하고 그 결과를 화면에 표시합니다.

ViewModels/MainControlViewModel.cs

C#

// SControlM/ViewModels/MainControlViewModel.cs
using Newtonsoft.Json;
using SControl.Common; // CommandPacket, Enums, Payloads
using SControlM.Models; // AgentTarget, LogEntry (SControlM용)
using SControlM.Services; // ILoggingService, ICommandSendService
using SControlM.Utils;    // ObservableObject, RelayCommand
using System;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;

namespace SControlM.ViewModels
{
    public class MainControlViewModel : ObservableObject
    {
        private readonly ILoggingService _loggingService;
        private readonly ICommandSendService _commandSendService;

        private AgentTarget _currentAgentTarget;
        public AgentTarget CurrentAgentTarget
        {
            get => _currentAgentTarget;
            set => SetProperty(ref _currentAgentTarget, value);
        }

        public ObservableCollection<LogEntry> LogEntries => _loggingService.LogEntries;

        private string _responseText;
        public string ResponseText
        {
            get => _responseText;
            set => SetProperty(ref _responseText, value);
        }

        private bool _isBusy;
        public bool IsBusy
        {
            get => _isBusy;
            set
            {
                if (SetProperty(ref _isBusy, value))
                {
                    // IsBusy 상태가 변경되면 관련 Command들의 CanExecute 상태 갱신
                    ((RelayCommand)SendCommandMonitorOnCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)SendCommandMonitorOffCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)SendCommandMonitorStandbyCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)SendRelayMonitorOnCommand).RaiseCanExecuteChanged();
                    // 다른 명령들도 추가...
                }
            }
        }

        // 명령 전송 타임아웃 (예: 10초)
        private readonly TimeSpan _commandTimeout = TimeSpan.FromSeconds(10);
        private CancellationTokenSource _cancellationTokenSource;


        public ICommand SendCommandMonitorOnCommand { get; }
        public ICommand SendCommandMonitorOffCommand { get; }
        public ICommand SendCommandMonitorStandbyCommand { get; }
        public ICommand SendRelayMonitorOnCommand { get; }
        // 추가적인 릴레이 명령 (Monitor Off, Standby 등)도 유사하게 정의 가능

        public MainControlViewModel(ILoggingService loggingService, ICommandSendService commandSendService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            _commandSendService = commandSendService ?? throw new ArgumentNullException(nameof(commandSendService));

            CurrentAgentTarget = new AgentTarget(); // 기본 대상 초기화

            SendCommandMonitorOnCommand = new RelayCommand(async () => await ExecuteMonitorControlCommand(MonitorAction.On), CanExecuteCommands);
            SendCommandMonitorOffCommand = new RelayCommand(async () => await ExecuteMonitorControlCommand(MonitorAction.Off), CanExecuteCommands);
            SendCommandMonitorStandbyCommand = new RelayCommand(async () => await ExecuteMonitorControlCommand(MonitorAction.Standby), CanExecuteCommands);
            
            SendRelayMonitorOnCommand = new RelayCommand(async () => await ExecuteRelayMonitorControlCommand(MonitorAction.On), CanExecuteRelayCommands);

            _loggingService.Info("MainControlViewModel 초기화 완료.");
        }

        private bool CanExecuteCommands(object parameter) => !IsBusy;
        private bool CanExecuteRelayCommands(object parameter)
        {
            return !IsBusy &&
                   !string.IsNullOrWhiteSpace(CurrentAgentTarget.RelayIpAddress) &&
                   CurrentAgentTarget.RelayPort.HasValue && CurrentAgentTarget.RelayPort > 0;
        }


        private async Task ExecuteMonitorControlCommand(MonitorAction action)
        {
            var payload = new MonitorControlPayload { Action = action };
            var commandPacket = new CommandPacket
            {
                Instruction = CommandInstruction.DirectExecute,
                CommandName = CommandNames.MonitorControl,
                PayloadJson = JsonConvert.SerializeObject(payload)
            };
            await SendCommandAsync(commandPacket, $"모니터 상태 '{action}' 직접 실행");
        }

        private async Task ExecuteRelayMonitorControlCommand(MonitorAction action)
        {
            if (!CanExecuteRelayCommands(null)) // Relay IP/Port 유효성 다시 한번 확인
            {
                _loggingService.Warn("릴레이 대상 IP 또는 포트가 유효하지 않습니다.");
                ResponseText = "릴레이 대상 IP 또는 포트를 올바르게 입력해주세요.";
                return;
            }

            var payload = new MonitorControlPayload { Action = action };
            var commandPacket = new CommandPacket
            {
                Instruction = CommandInstruction.RelayToTarget,
                CommandName = CommandNames.MonitorControl, // 릴레이할 실제 명령
                PayloadJson = JsonConvert.SerializeObject(payload),
                FinalTargetIpForRelayedCommand = CurrentAgentTarget.RelayIpAddress,
                FinalTargetPortForRelayedCommand = CurrentAgentTarget.RelayPort
            };
            await SendCommandAsync(commandPacket, $"모니터 상태 '{action}' 릴레이 실행 -> {CurrentAgentTarget.RelayIpAddress}:{CurrentAgentTarget.RelayPort}");
        }


        private async Task SendCommandAsync(CommandPacket commandPacket, string logPrefix)
        {
            if (IsBusy) return;

            IsBusy = true;
            ResponseText = string.Empty;
            _cancellationTokenSource = new CancellationTokenSource(); // 각 명령마다 새 CancellationTokenSource

            try
            {
                _loggingService.Sent($"{logPrefix} 명령 전송 시도 -> SAgentM: {CurrentAgentTarget.IpAddress}:{CurrentAgentTarget.Port}");
                _loggingService.Debug($"전송 패킷: {JsonConvert.SerializeObject(commandPacket, Formatting.Indented)}");

                CommandPacket response = await _commandSendService.SendCommandAsync(
                    CurrentAgentTarget, 
                    commandPacket, 
                    _commandTimeout, 
                    _cancellationTokenSource.Token);

                if (response != null)
                {
                    _loggingService.Received($"응답 수신 (ID: {response.PacketId}): {response.CommandName}");
                    _loggingService.Debug($"수신 패킷: {JsonConvert.SerializeObject(response, Formatting.Indented)}");

                    if (!string.IsNullOrEmpty(response.PayloadJson))
                    {
                        var genericResponse = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson);
                        if (genericResponse != null)
                        {
                            ResponseText = $"성공: {genericResponse.Success}, 메시지: {genericResponse.Message}";
                            if (genericResponse.Success)
                                _loggingService.Info($"명령 성공: {genericResponse.Message}");
                            else
                                _loggingService.Warn($"명령 실패: {genericResponse.Message}");
                        }
                        else
                        {
                            ResponseText = "수신된 페이로드를 해석할 수 없습니다.";
                            _loggingService.Warn(ResponseText);
                        }
                    }
                    else
                    {
                        ResponseText = "응답 페이로드가 비어있습니다.";
                        _loggingService.Warn(ResponseText);
                    }
                }
                else
                {
                    ResponseText = "SAgentM으로부터 응답이 없습니다 (null).";
                    _loggingService.Error(ResponseText);
                }
            }
            catch (OperationCanceledException)
            {
                ResponseText = "명령 전송이 취소되었습니다.";
                _loggingService.Warn(ResponseText);
            }
            catch (ApplicationException appEx) // CommandSendService에서 래핑된 예외
            {
                ResponseText = $"오류: {appEx.Message}";
                _loggingService.Error(ResponseText, appEx.InnerException ?? appEx);
            }
            catch (Exception ex)
            {
                ResponseText = $"예기치 않은 오류 발생: {ex.Message}";
                _loggingService.Error(ResponseText, ex);
            }
            finally
            {
                IsBusy = false;
                _cancellationTokenSource.Dispose();
                _cancellationTokenSource = null;
            }
        }

        // 애플리케이션 종료 또는 ViewModel 해제 시 리소스 정리 (필요시)
        public void Cleanup()
        {
            _loggingService.Info("MainControlViewModel 정리 중...");
            if (_cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested)
            {
                _cancellationTokenSource.Cancel();
                _cancellationTokenSource.Dispose();
            }
            // 다른 정리 작업
        }
    }
}
MainControlViewModel.cs 주요 특징:

서비스 주입: ILoggingService와 ICommandSendService를 생성자에서 주입받습니다.
CurrentAgentTarget: UI에서 사용자가 SAgentM의 IP와 포트, 그리고 릴레이 대상의 IP와 포트를 입력할 수 있도록 AgentTarget 모델 객체를 사용합니다.
LogEntries: LoggingService로부터 받은 로그 컬렉션을 UI에 바인딩합니다.
ResponseText: SAgentM으로부터 받은 응답의 요약 또는 오류 메시지를 UI에 표시합니다.
IsBusy: 명령 전송 중일 때 UI의 버튼을 비활성화하거나 로딩 인디케이터를 표시하는 데 사용됩니다. IsBusy 상태가 변경될 때 관련된 RelayCommand의 CanExecute 상태가 갱신되도록 처리했습니다.
명령 (ICommand):
모니터 제어 (On, Off, Standby) 명령과 릴레이 모니터 제어 명령을 RelayCommand로 구현했습니다.
각 명령 실행 메서드는 적절한 CommandPacket을 생성합니다.
SendCommandAsync 헬퍼 메서드:
실제 명령 전송 로직을 공통으로 처리합니다.
IsBusy 플래그를 관리하고, 로깅, 예외 처리 등을 수행합니다.
CommandSendService.SendCommandAsync를 호출하며, 타임아웃과 CancellationToken을 전달합니다.
수신된 응답 패킷의 PayloadJson을 GenericResponsePayload로 역직렬화하여 성공 여부와 메시지를 ResponseText에 표시합니다.
취소 처리: 각 명령 실행 시 새로운 CancellationTokenSource를 생성하여, CommandSendService에 전달합니다. (UI에 명시적인 취소 버튼은 아직 없지만, ViewModel 정리 시 진행 중인 작업을 취소할 수 있습니다.)
릴레이 명령 유효성 검사: CanExecuteRelayCommands를 통해 릴레이 IP와 포트가 입력되었는지 확인합니다.
이제 SControlM의 ViewModel 로직이 준비되었습니다. 다음 단계는 이 MainControlViewModel을 사용하는 MainWindow.xaml (UI 레이아웃)과 MainWindow.xaml.cs (코드 비하인드)를 작성하는 것입니다.