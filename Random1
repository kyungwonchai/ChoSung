송합니다. 다시 작성해서 수정된 전체 코드를 제공해드리겠습니다. 코드와 XAML 모두 완성된 상태로 드리겠습니다.

수정된 전체 코드 (C# + XAML)
C# 수정된 전체 코드 (CommandQueueViewModel)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public event PropertyChangedEventHandler PropertyChanged;

    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    private bool _isProcessing;
    private bool _isQueueStopped;
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3;
    public int RetryInterval { get; set; } = 3000;
    public int ResponseTimeout { get; set; } = 5000;
    public int MaximumQueueSize { get; set; } = 10;

    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress));
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false;
        _isQueueStopped = false;
        Progress = 0;
    }

    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("Queue limit reached or stopped. No further commands can be added.");
            return;
        }

        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("Queue limit reached or stopped. No further commands can be added.");
            return;
        }

        var newCommand = new CommandItem
        {
            CommandText = commandText,
            Status = "Pending",
            MaxRetryLimit = RetryLimit,
            RetryCount = 0
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(newCommand);
        });

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch();
            _isProcessing = true;

            while (retryCount < RetryLimit)
            {
                try
                {
                    stopwatch.Restart();
                    string result = await taskFunc();
                    stopwatch.Stop();

                    int responseTime = (int)stopwatch.ElapsedMilliseconds;
                    newCommand.ResponseTime = responseTime;
                    newCommand.RetryCount = retryCount;

                    if (responseTime > ResponseTimeout)
                    {
                        newCommand.Status = "Timeout";
                        ShowAlarm("Timeout occurred. All tasks stopped.");
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Response Timeout");
                        StopQueueProcessing(newCommand);
                        return new CommandResult { Success = false, Message = "Response Timeout" };
                    }

                    if (responseValidator(result))
                    {
                        newCommand.Status = "Completed";
                        newCommand.Result = 1;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        UpdateProgress();
                        _isProcessing = false;
                        return new CommandResult { Success = true, Message = result };
                    }
                    else
                    {
                        retryCount++;
                        newCommand.Status = "Retrying";
                        ShowAlarm($"Retrying {retryCount}/{RetryLimit} due to incorrect response.");
                        newCommand.RetryCount = retryCount;

                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed";
                            newCommand.Result = 0;
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Queue has been stopped over retry count.");
                            StopQueueProcessing(newCommand);
                            return new CommandResult { Success = false, Message = result };
                        }
                        await Task.Delay(RetryInterval);
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed";
                    newCommand.Result = 0;
                    stopwatch.Stop();
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;
                    newCommand.ResponseTime = responseTime;

                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred. All tasks stopped.");
                    StopQueueProcessing(newCommand);
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }

            UpdateProgress();
            _isProcessing = false;
            return new CommandResult { Success = false };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }

        UpdateProgress();
    }

    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue();
            await command();
            UpdateProgress();
        }

        _isProcessing = false;
    }

    private void StopQueueProcessing(CommandItem errorCommand)
    {
        _isQueueStopped = true;
        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(errorCommand);
        });
        ShowAlarm("Queue has been stopped due to a Timeout or failure.");
    }

    private void ShowAlarm(string message)
    {
        var errorCommand = new CommandItem
        {
            CommandText = message,
            Status = "Error",
            Result = 0,
            RetryCount = 0,
            ResponseTime = 0
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(errorCommand);
        });
    }

    private void UpdateProgress()
    {
        Progress = commandQueue.Count;
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

public class CommandItem
{
    public string CommandText { get; set; }
    public string Status { get; set; }
    public int Result { get; set; }
    public int RetryCount { get; set; }
    public int MaxRetryLimit { get; set; }
    public int ResponseTime { get; set; }
    public string CommandTime { get; set; }
    public string Output { get; set; }
}

public class CommandResult
{
    public bool Success { get; set; }
    public string Message { get; set; }
}
수정된 XAML 코드
xml
코드 복사
<Grid>
    <Grid.ColumnDefinitions>
        <ColumnDefinition Width="9*"/>
        <ColumnDefinition Width="1*"/>
    </Grid.ColumnDefinitions>

    <Grid.RowDefinitions>
        <RowDefinition Height="1*"/>
        <RowDefinition Height="1*"/>
    </Grid.RowDefinitions>

    <!-- DataGrid for Command Queue -->
    <DataGrid Grid.Row="0" Grid.Column="0" ItemsSource="{Binding RemainingCommands}" AutoGenerateColumns="False" Margin="10">
        <DataGrid.Columns>
            <DataGridTextColumn Header="Command Text" Binding="{Binding CommandText}" Width="200"/>
            <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="100"/>
            <DataGridTextColumn Header="Retry Count" Binding="{Binding RetryCount}" Width="50"/>
            <DataGridTextColumn Header="Response Time" Binding="{Binding ResponseTime}" Width="100"/>
        </DataGrid.Columns>
        <DataGrid.RowStyle>
            <Style TargetType="DataGridRow">
                <Style.Triggers>
                    <DataTrigger Binding="{Binding Status}" Value="Error">
                        <Setter Property="Background" Value="Yellow"/>
                    </DataTrigger>
                </Style.Triggers>
            </Style>
        </DataGrid.RowStyle>
    </DataGrid>

    <!-- ProgressBar -->
    <StackPanel Grid.Column="1" VerticalAlignment="Stretch" Margin="10">
        <TextBlock Text="Progress" HorizontalAlignment="Center"/>
        <ProgressBar VerticalAlignment="Top" Height="300" Width="30" Orientation="Vertical"
                     Value="{Binding Progress}" Maximum="{Binding MaximumQueueSize}" Margin="10"/>
        <TextBlock Text="{Binding Progress, StringFormat='Current Tasks: {0}'}" HorizontalAlignment="Center"/>
    </StackPanel>
</Grid>
설명:
Command Queue 및 DataGrid 처리:

DataGrid에서 각 명령에 대한 정보를 표시하며, "Status" 컬럼이 "Error"일 경우 행 배경색을 노랑으로 설정했습니다.
RetryCount, ResponseTime 등의 정보가 각각의 컬럼에 표시됩니다.
ProgressBar 상태 표시:

ProgressBar는 현재 남은 명령 작업을 시각적으로 표시하며, Progress 값과 최대 큐 크기를 기준으로 동작합니다.
TextBlock에서 현재 쌓인 작업 개수를 보여줍니다.
큐에 최대 10개 제한:

MaximumQueueSize가 10이 넘으면 추가 작업이 불가능하며, 알람을 표시합니다.
응답 시간이 5초를 초과할 경우 작업 중단:

응답 시간이 5초를 초과하면 모든 작업이 중단되고, 이후 작업이 더 이상 진행되지 않도록 했습니다.
재시도 표시:

재시도 횟수가 증가할 때마다 UI에 실시간으로 반영되도록 했으며, 3회 실패 후 큐가 중지되도록 했습니다.
필요한 부분이 빠지지 않도록 모두 포함했으며, 원하는 동작을 구현했습니