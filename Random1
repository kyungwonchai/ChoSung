, **유저 컨트롤(UserControl)**을 사용하여 UI를 구성하고, 메인 윈도우에서 해당 유저 컨트롤을 뷰박스(ViewBox) 안에 배치하여 크기에 맞게 조정할 수 있습니다. 또한, 유저 컨트롤의 표시/숨김(ON/OFF) 기능도 구현하겠습니다.

아래는 해당 구조로 코드를 다시 작성한 최고급 전체 코드입니다. 각 줄마다 상세한 설명을 추가하여 이해를 도울 수 있도록 작성하겠습니다.

1. UserControl: SensorControl.xaml
센서 데이터를 표시하는 UI 부분을 UserControl로 분리합니다. 이 UserControl을 메인 윈도우에서 ON/OFF할 수 있도록 구현할 것입니다.

SensorControl.xaml
xml
코드 복사
<UserControl x:Class="SensorApp.SensorControl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:SensorApp"
             Height="Auto" Width="Auto">
    <!-- ViewBox를 사용해 UserControl 내부 콘텐츠가 윈도우 크기에 맞게 조정되도록 설정 -->
    <ViewBox Stretch="Uniform">
        <Grid>
            <!-- 센서 데이터를 표시할 ItemsControl -->
            <ItemsControl ItemsSource="{Binding Sensors}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <!-- 센서 이름과 감지 여부에 따른 원형 색상을 표시 -->
                        <StackPanel Orientation="Horizontal" Margin="5">
                            <TextBlock Text="{Binding SensorName}" Width="50" VerticalAlignment="Center" />
                            <Ellipse Width="20" Height="20" 
                                     Fill="{Binding IsDetected, Converter={StaticResource BoolToColorConverter}}" />
                        </StackPanel>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
                <ItemsControl.ItemsPanel>
                    <ItemsPanelTemplate>
                        <!-- UniformGrid로 6열로 구성하여 18개의 센서를 표시 -->
                        <UniformGrid Columns="6" />
                    </ItemsPanelTemplate>
                </ItemsControl.ItemsPanel>
            </ItemsControl>
        </Grid>
    </ViewBox>
</UserControl>
설명:
ViewBox: ViewBox는 내부 콘텐츠를 윈도우 크기에 맞춰서 크기가 조정되도록 합니다.
ItemsControl: 센서 데이터를 리스트 형식으로 보여주며, ObservableCollection에서 데이터가 바인딩됩니다.
UniformGrid: 6열의 그리드 형태로 18개의 센서 정보를 배치합니다.
2. UserControl: SensorControl.xaml.cs
SensorControl.xaml.cs
csharp
코드 복사
using System.Windows.Controls;

namespace SensorApp
{
    public partial class SensorControl : UserControl
    {
        // SensorControl은 MainViewModel을 ViewModel로 사용
        public SensorControl()
        {
            InitializeComponent();
            DataContext = new MainViewModel();  // ViewModel을 연결
        }
    }
}
설명:
DataContext: MainViewModel을 DataContext로 설정하여 센서 데이터를 ViewModel에서 가져오도록 설정합니다.
UserControl 생성자: UserControl이 생성될 때 MainViewModel을 자동으로 사용하여 데이터를 UI에 바인딩합니다.
3. ViewModel: MainViewModel.cs
MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<SensorModel> Sensors { get; set; }
    private readonly SensorService _sensorService;

    public MainViewModel()
    {
        Sensors = new ObservableCollection<SensorModel>();
        _sensorService = new SensorService();
        InitializeSensors();

        // 비동기로 데이터를 주기적으로 받아서 업데이트
        Task.Run(async () => await UpdateSensorDataAsync());
    }

    // 센서 목록을 초기화 (R520 ~ R540)
    private void InitializeSensors()
    {
        for (int i = 0; i < 18; i++)
        {
            Sensors.Add(new SensorModel
            {
                SensorName = $"R{520 + i:X}",
                IsDetected = false // 초기에는 모두 감지되지 않음
            });
        }
    }

    // PLC 데이터를 비동기적으로 주기적으로 수신
    private async Task UpdateSensorDataAsync()
    {
        while (true)
        {
            try
            {
                string response = await _sensorService.SendCommandAsync(); // PLC 데이터 비동기 수신
                if (response != null)
                {
                    ParseResponseAndUpdateSensors(response); // 수신된 데이터를 파싱 및 업데이트
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"통신 오류: {ex.Message}"); // 오류 처리
            }

            await Task.Delay(1000); // 1초마다 업데이트
        }
    }

    // 응답 데이터를 파싱하고 센서 상태를 업데이트하는 메서드
    private void ParseResponseAndUpdateSensors(string response)
    {
        if (response.StartsWith("%01$RC") && response.EndsWith("18"))
        {
            string[] wordData = new string[3];
            wordData[0] = response.Substring(6, 4);  // R520~R52F
            wordData[1] = response.Substring(10, 4); // R530~R53F
            wordData[2] = response.Substring(14, 4); // R540

            for (int i = 0; i < 3; i++)
            {
                UpdateSensorStates(wordData[i], i * 8);  // 각 16비트를 8비트씩 상하교체
            }
        }
    }

    // 상하 교체 비트 처리 후 센서 상태 업데이트
    private void UpdateSensorStates(string wordData, int sensorStartIndex)
    {
        string swappedBinary = GetSwappedBinary(wordData); // 상하 비트 교체

        for (int i = 0; i < swappedBinary.Length; i++)
        {
            Sensors[sensorStartIndex + i].IsDetected = swappedBinary[i] == '1'; // 감지 여부 설정
        }

        OnPropertyChanged(nameof(Sensors));  // UI 갱신을 위해 PropertyChanged 호출
    }

    // 상하 교체 비트 처리 함수
    private string GetSwappedBinary(string hex)
    {
        string binary = Convert.ToString(Convert.ToInt32(hex, 16), 2).PadLeft(16, '0'); // 16진수 -> 2진수 변환
        return binary.Substring(8, 8) + binary.Substring(0, 8);  // 상하 비트 교체
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));  // PropertyChanged 이벤트 발생
    }
}
설명:
TaskCompletionSource를 사용한 비동기 통신과 실시간 데이터 처리는 앞서 설명한 방식 그대로 유지합니다.
센서 상태 업데이트는 응답 데이터를 상하 교체한 후 감지 여부를 반영하는 형태입니다.
4. MainWindow.xaml
메인 윈도우에서 **SensorControl(UserControl)**을 포함하고, 이를 ViewBox에 넣어 크기 조정 및 ON/OFF 기능을 구현합니다.

MainWindow.xaml
xml
코드 복사
<Window x:Class="SensorApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:SensorApp"
        Title="Sensor Monitoring" Height="450" Width="800">
    <Grid>
        <!-- 버튼으로 SensorControl을 ON/OFF하는 기능 -->
        <StackPanel Orientation="Vertical">
            <!-- ON/OFF 버튼 -->
            <Button Content="Toggle Sensor Control" Click="OnToggleSensorControl" Height="30" Width="200" Margin="10" />

            <!-- ViewBox에 SensorControl(UserControl)을 삽입 -->
            <ViewBox Stretch="Uniform" Visibility="{Binding IsSensorControlVisible, Converter={StaticResource BoolToVisibilityConverter}}">
                <local:SensorControl x:Name="sensorControl" />
            </ViewBox>
        </StackPanel>
    </Grid>
</Window>
5. MainWindow.xaml.cs
ON/OFF 기능을 추가하고, UserControl을 보이거나 숨길 수 있는 로직을 처리합니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.ComponentModel;
using System.Windows;

namespace SensorApp
{
    public partial class MainWindow : Window, INotifyPropertyChanged
    {
        private bool _isSensorControlVisible;

        public bool IsSensorControlVisible
        {
            get => _isSensorControlVisible;
            set
            {
                _isSensorControlVisible = value;
                OnPropertyChanged(nameof(IsSensorControlVisible));
            }
        }

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;  // DataContext를 MainWindow에 바인딩
            IsSensorControlVisible = true;  // 초기값으로 SensorControl을 표시
        }

        // ON/OFF 버튼 클릭 시 호출되는 메서드
        private void OnToggleSensorControl(object sender, RoutedEventArgs e)
        {
            IsSensorControlVisible = !IsSensorControlVisible;  // SensorControl의 표시/숨김 토글
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected void OnPropertyChanged(string name)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
설명:
IsSensorControlVisible: SensorControl의 표시 여부를 제어하는 속성입니다.
OnToggleSensorControl: 버튼을 클릭할 때마다 SensorControl의 ON/OFF 상태를 토글합니다.
6. BoolToVisibilityConverter
BoolToVisibilityConverter를 사용해 **SensorControl의 가시성(Visibility)**을 제어합니다.

BoolToVisibilityConverter.cs
csharp
코드 복사
using System;
using System.Globalization;
using System.Windows;
using System.Windows.Data;

public class BoolToVisibilityConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        return (bool)value ? Visibility.Visible : Visibility.Collapsed;  // true일 때 보이고, false일 때 숨김
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
7. App.xaml
BoolToVisibilityConverter를 리소스로 등록하여 사용할 수 있도록 설정합니다.

App.xaml
xml
코드 복사
<Application x:Class="SensorApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <!-- BoolToVisibilityConverter를 리소스로 등록 -->
        <local:BoolToVisibilityConverter x:Key="BoolToVisibilityConverter"/>
        <local:BoolToColorConverter x:Key="BoolToColorConverter"/>
    </Application.Resources>
</Application>
최종 설명:
유저 컨트롤(UserControl): SensorControl로 분리하여 센서 상태를 표시합니다.
ViewBox: SensorControl을 ViewBox에 넣어서 윈도우 크기에 맞춰 콘텐츠가 자동으로 크기 조정되도록 했습니다.
ON/OFF 기능: 메인 윈도우에 버튼을 추가해 센서 데이터 표시를 토글할 수 있도록 했습니다. BoolToVisibilityConverter를 사용하여, 센서 컨트롤의 가시성을 제어합니다.
이 코드를 통해 센서 데이터를 실시간으로 표시하면서, 유저 컨트롤을 ON/OFF할 수 있고, ViewBox를 사용해 콘텐츠 크기를 윈도우에 맞게 자동으로 조정할 수 있습니다.

더 궁금한 사항이 있으면 언제든지 질문해 주