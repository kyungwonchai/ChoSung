겠습니다. Unity Industries 3D Core 기본 프로젝트에서 SMD 라인의 '인쇄기(Printer)' 공정 부분만 시뮬레이션하는 것을 목표로, 사이클 타임 단축 및 유실 감소를 위한 분석 기반을 마련해보겠습니다. 인쇄기를 일반적인 '공정 설비'로 간주하고 병렬 구조와 공유 배출 로직에 초점을 맞춰 설명하겠습니다.

설명 순서 안내

요청하신 대로 전체 설명을 3단계로 나누어 진행하겠습니다. 우선 첫 번째 단계(약 1/3 분량)를 설명드립니다.

[1단계] 시뮬레이션 목표 재정의, 기본 구조 설계 및 Unity 모델링:
시뮬레이션할 대상(병렬 인쇄기 및 공유 배출)과 목표를 명확히 합니다.
Unity Scene에 필요한 기본 GameObject 구조를 설계하고 배치하는 방법을 상세히 설명합니다. (프린터, PCB, 입/출력 지점 등)
각 GameObject에 필요한 기본 컴포넌트를 정의합니다.
[2단계] 핵심 로직 구현 (상태 관리 및 기본 동작):
인쇄기(PrinterController)의 상세 상태(State Machine)를 정의하고 상태별 동작 로직을 설명합니다. (보드 수신, 작업 위치 이동, 기본 처리 등)
PCB(PCBController) 스크립트의 역할과 추적할 데이터를 정의합니다.
시간 기반 처리 및 지연을 구현하는 방법을 설명합니다. (Coroutine 활용)
[3단계] 상세 로직 구현 (청소, 배출 연동 및 데이터 수집):
인쇄기의 청소 로직(주기, 옵션별 시간 차이)을 구현하는 방법을 설명합니다.
공유 배출 시스템(Shuttle Conveyor)의 로직과 인쇄기와의 연동 방법을 설명합니다. (상태 확인, 우선순위 처리)
사이클 타임 측정 및 데이터 기록 방법을 구체화합니다.
전체적인 코드 예시와 함께 파라미터 조정 방법을 설명합니다.
[1단계] 시뮬레이션 목표 재정의, 기본 구조 설계 및 Unity 모델링

1. 시뮬레이션 목표 및 범위

목표: Front Printer와 Rear Printer라는 두 개의 병렬 공정 설비와 이들로부터 제품(PCB)을 받아 배출하는 단일 셔틀 컨베이어 시스템을 시뮬레이션합니다. 이를 통해 각 설비의 작업 흐름, 대기 시간, 공유 자원(셔틀) 경쟁 등을 관찰하고, 향후 사이클 타임 및 병목 현상 분석의 기초를 마련합니다.
범위:
각 프린터의 개별 투입구에서 PCB 생성 (시뮬레이션 시작점).
프린터 내부 공정 단계 시뮬레이션 (투입 대기 -> 작업 위치 이동 -> 인쇄 준비/작업/완료 -> 우측 버퍼 대기).
단일 셔틀 컨베이어가 각 프린터의 우측 버퍼에서 PCB를 번갈아 (또는 우선순위에 따라) 픽업하는 로직.
셔틀이 픽업한 PCB는 시스템 밖으로 배출되며, 이때 사이클 타임을 기록하고 PCB 객체는 제거 (시뮬레이션 종료점).
초기 단계에서는 청소 로직은 잠시 보류하고 기본 흐름부터 구현합니다.
2. Unity 기본 구조 설계 및 모델링 상세

Unity Scene을 열고 다음 GameObject들을 생성하고 구성합니다. 이름은 예시이며, 구체적인 프로젝트 규칙에 따라 변경 가능합니다.

PCB Prefab (기판 프리팹):

Create Empty로 GameObject 생성 후 PCB_Prefab으로 이름 변경.
자식으로 3D Object > Cube를 추가하여 얇고 넓은 직육면체 형태로 Scale 조정 (예: X:1, Y:0.1, Z:1.5). 이것이 PCB의 시각적 표현입니다.
PCB_Prefab 루트 GameObject에 Rigidbody 컴포넌트 추가 (물리적 이동이 필요하다면. 아니라면 제거). Use Gravity는 해제하고 Is Kinematic은 필요에 따라 체크합니다 (스크립트로만 제어 시 체크).
Box Collider 컴포넌트 추가 (충돌 감지 또는 트리거 사용 시). 크기를 Cube 메시에 맞춥니다.
이후 PCB의 상태와 정보를 관리할 PCBController C# 스크립트를 추가합니다 (다음 단계에서 생성).
이 PCB_Prefab을 Project 창으로 드래그하여 프리팹으로 저장합니다. Scene에서는 삭제해도 됩니다.
Printers (인쇄 설비):

Create Empty로 Printers라는 부모 GameObject를 생성하여 관련 객체들을 그룹화합니다.
Printers 아래에 Create Empty로 FrontPrinter와 RearPrinter GameObject를 생성합니다. 이들이 각 병렬 설비를 나타냅니다.
각 프린터 (FrontPrinter, RearPrinter) 내부 구조:
(시각적 모델 - 선택 사항): 각 프린터 GameObject 아래에 Cube나 다른 3D 모델을 이용해 설비의 외형을 간단히 만듭니다.
(로직을 위한 위치 지정자): 각 프린터 GameObject 아래에 Create Empty를 사용하여 다음 위치들을 나타내는 빈 GameObject를 생성합니다. 이들의 Transform.position 값이 중요합니다.
InputPoint: 외부에서 PCB가 처음 도착하는 위치.
ProcessingPoint: 실제 인쇄 작업(테이블 상승/하강, 인쇄)이 이루어지는 위치.
OutputBufferPoint: 작업 완료 후 셔틀 컨베이어를 기다리는 위치 (프린터 우측).
각 프린터 GameObject (FrontPrinter, RearPrinter)에 핵심 로직을 담당할 PrinterController C# 스크립트를 추가합니다 (다음 단계에서 생성).
Input Sources (투입 지점):

Create Empty로 InputSources 부모 GameObject 생성.
그 아래 Create Empty로 InputSource_Front와 InputSource_Rear 생성.
InputSource_Front의 위치는 FrontPrinter의 InputPoint와 연결될 이전 공정 위치로 설정합니다 (요청에 따라 뒷쪽).
InputSource_Rear의 위치는 RearPrinter의 InputPoint와 연결될 이전 공정 위치로 설정합니다 (요청에 따라 앞쪽).
각 InputSource GameObject에 InputSpawner C# 스크립트(가칭)를 추가하여 주기적으로 PCB_Prefab을 생성하고 해당 프린터의 InputPoint로 보내는 역할을 부여할 수 있습니다. (초기에는 수동으로 PCB를 배치하거나 간단한 생성 로직만 구현)
Shuttle Conveyor (셔틀 컨베이어):

Create Empty로 ShuttleConveyor GameObject 생성.
자식으로 Cube 등을 이용해 셔틀의 시각적 형태를 만듭니다.
셔틀의 초기 위치는 프린터들의 OutputBufferPoint 사이 또는 시작 지점으로 설정합니다.
셔틀이 PCB를 싣고 이동할 최종 목적지(배출 지점)를 나타내는 Transform이나 빈 GameObject (ExitPoint)를 Scene 어딘가에 배치합니다.
ShuttleConveyor GameObject에 셔틀의 이동 및 픽업 로직을 담당할 ShuttleController C# 스크립트를 추가합니다 (다음 단계에서 생성).
3. 코드 적용 방향 (1단계 해당 내용)

현재 단계에서는 Scene 구성과 GameObject 배치에 집중합니다. 코드는 아직 구체적으로 작성하지 않지만, 어떤 스크립트가 어떤 GameObject에 붙어야 하는지 명확히 합니다.

PCB_Prefab에는 PCBController 스크립트가 붙어 자신의 상태(예: 생성 시간, 현재 위치, 처리 상태)를 관리합니다.
FrontPrinter와 RearPrinter에는 각각 PrinterController 스크립트가 붙어 해당 프린터의 상태, 내부 PCB 이동, 처리 로직, 버퍼 상태 등을 관리합니다.
ShuttleConveyor에는 ShuttleController 스크립트가 붙어 프린터 버퍼 확인, 셔틀 이동, PCB 픽업 및 배출 로직을 관리합니다.