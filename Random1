송합니다, 제가 제공한 코드에서 발생하는 문제를 해결하는 데 실패한 것 같습니다. 이 문제를 해결하기 위해 단계별로 접근해 보겠습니다.

문제 분석
Camera2CameraInfo.from(info).cameraCharacteristics에서 발생하는 빨간 글씨 오류는 CameraInfo 객체를 잘못된 방식으로 처리하려고 하기 때문에 발생합니다. CameraX와 Camera2 API를 통합할 때, Camera2CameraInfo 객체는 CameraInfo에서 직접적으로 생성할 수 없으며, Camera2 API를 통해서 카메라의 특정 특성에 접근해야 합니다.

수정된 접근 방식
Camera2CameraInfo를 통해 CameraCharacteristics에 접근하는 것이 아니라, CameraX에서 Camera2 API를 사용하는 방식으로 센서 정보를 가져와야 합니다.

올바른 코드 예시
kotlin
코드 복사
package com.example.myapp

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Rect
import android.hardware.camera2.CameraCharacteristics
import android.hardware.camera2.CameraManager
import android.hardware.camera2.params.MeteringRectangle
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.core.Camera
import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var previewView: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private var camera: Camera? = null // Camera 객체 선언

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        previewView = findViewById(R.id.previewView)
        cameraExecutor = Executors.newSingleThreadExecutor()

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            // 카메라 선택기 설정
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            // CameraManager를 통해 CameraCharacteristics 가져오기
            val cameraManager = getSystemService(CAMERA_SERVICE) as CameraManager
            val cameraId = cameraManager.cameraIdList.first { id ->
                val characteristics = cameraManager.getCameraCharacteristics(id)
                characteristics.get(CameraCharacteristics.LENS_FACING) == CameraCharacteristics.LENS_FACING_BACK
            }

            val characteristics = cameraManager.getCameraCharacteristics(cameraId)
            val sensorArraySize = characteristics.get(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE)

            // 프리뷰 빌더 초기화 및 Camera2Interop 설정
            val previewBuilder = Preview.Builder()
            val camera2Interop = Camera2Interop.Extender(previewBuilder)

            if (sensorArraySize != null) {
                val focusArea = Rect(
                    (sensorArraySize.width() * 0.4).toInt(),
                    (sensorArraySize.height() * 0.4).toInt(),
                    (sensorArraySize.width() * 0.6).toInt(),
                    (sensorArraySize.height() * 0.6).toInt()
                )

                val meteringRectangle = MeteringRectangle(focusArea, MeteringRectangle.METERING_WEIGHT_MAX)

                camera2Interop.setCaptureRequestOption(
                    android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE,
                    android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                )

                camera2Interop.setCaptureRequestOption(
                    android.hardware.camera2.CaptureRequest.CONTROL_AF_REGIONS,
                    arrayOf(meteringRectangle)
                )

                camera2Interop.setCaptureRequestOption(
                    android.hardware.camera2.CaptureRequest.CONTROL_AE_REGIONS,
                    arrayOf(meteringRectangle)
                )
            }

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            try {
                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview
                ) // Camera 객체 초기화

                // 카메라 제어를 위한 cameraControl 사용
                val cameraControl = camera?.cameraControl

                // 예: 줌 설정 (1.0f ~ 최대 줌 비율)
                cameraControl?.setZoomRatio(2.0f)

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<String>, grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE_PERMISSIONS) {
            if (allPermissionsGranted()) {
                startCamera()
            } else {
                // 권한이 거부된 경우 처리
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA
        )
    }
}
코드 설명:
CameraManager 사용:

CameraManager를 사용하여 기기에서 사용 가능한 카메라 목록을 가져옵니다.
cameraIdList를 사용하여 후면 카메라(LENS_FACING_BACK)의 ID를 가져옵니다.
CameraCharacteristics 사용:

CameraManager.getCameraCharacteristics(cameraId)를 사용하여 특정 카메라의 특성을 가져옵니다.
SENSOR_INFO_ACTIVE_ARRAY_SIZE를 사용하여 센서의 활성 배열 크기를 얻습니다.
포커스 영역 설정:

활성 배열 크기(sensorArraySize)를 기반으로 중앙 20% 영역에 초점을 맞추도록 Rect 객체를 생성하고, MeteringRectangle을 사용하여 포커스 영역을 설정합니다.
Camera2Interop 설정:

Camera2Interop.Extender를 통해 CaptureRequest 옵션을 설정합니다.
결론:
이제 CameraCharacteristics에 올바르게 접근하고, Camera2 API를 사용하여 포커스 영역을 설정하는 방법을 설명했습니다. 이 방법을 통해 발생한 문제를 해결할 수 있기를 바랍니다. 추가적인 질문이나 문제가 있으면 언제든지 도와드리겠