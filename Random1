??? MySQL 이벤트 생성 쿼리
SQL

-- MySQL 이벤트 스케줄러 활성화 (이미 활성화되어 있다면 생략 가능)
SET GLOBAL event_scheduler = ON;

-- DELIMITER 변경 (이벤트 본문에 여러 SQL 문이 포함될 수 있으므로)
DELIMITER $$

CREATE EVENT IF NOT EXISTS `log_hyphen_in_line1`
ON SCHEDULE EVERY 10 MINUTE
STARTS CURRENT_TIMESTAMP
DO
BEGIN
    -- smd.repair_func_new_log 테이블에 데이터 삽입
    -- 중요: 아래 INSERT INTO 절의 컬럼 목록과 SELECT 절의 컬럼 목록은
    -- 실제 smd.repair_func_now 테이블과 smd.repair_func_new_log 테이블의 구조에 맞게 수정해야 합니다.

    -- 예시: smd.repair_func_now 테이블에 col1, col2, line1, col3 컬럼이 있고,
    --       smd.repair_func_new_log 테이블에 (자동 증가 pk 제외하고) 동일한 컬럼들이 있다고 가정
    INSERT INTO smd.repair_func_new_log (
        -- smd.repair_func_new_log 테이블에 삽입될 컬럼명들
        -- 예: line1, col_a, col_b (실제 컬럼명으로 변경)
        `line1`, -- line1 컬럼
        `another_column_from_now_table`, -- smd.repair_func_now의 다른 컬럼
        `yet_another_column_from_now_table` -- smd.repair_func_now의 또 다른 컬럼
        -- ... smd.repair_func_now에서 가져올 모든 컬럼을 여기에 명시합니다.
        --     smd.repair_func_new_log의 자동 생성 ID나 기본 타임스탬프 컬럼은 제외합니다.
    )
    SELECT
        -- smd.repair_func_now 테이블에서 선택할 컬럼명들
        -- 예: line1, column_a, column_b (실제 컬럼명으로 변경)
        `rfn`.`line1`,
        `rfn`.`another_column`, -- 위 INSERT 목록과 순서 및 대응 관계 일치 필요
        `rfn`.`yet_another_column`
        -- ... 위 INSERT INTO 컬럼 목록과 순서 및 개수가 일치해야 합니다.
    FROM smd.repair_func_now rfn
    WHERE `rfn`.`line1` LIKE '%-%'; -- line1 값에 '-'가 포함된 경우

END$$

-- DELIMITER 원래대로 복원
DELIMITER ;

-- 이벤트 생성 확인 (선택 사항)
-- SHOW EVENTS FROM smd WHERE Name = 'log_hyphen_in_line1';

-- 이벤트 활성화 (만약 DISABLED 상태로 생성되었다면)
-- ALTER EVENT log_hyphen_in_line1 ENABLE;
쿼리 설명:
SET GLOBAL event_scheduler = ON;

MySQL 이벤트 스케줄러를 활성화합니다. 이미 ON 상태라면 이 줄은 실행하지 않아도 됩니다. MySQL 서버 재시작 시 이 설정이 유지되도록 my.cnf (또는 my.ini) 파일에도 event_scheduler=ON을 추가하는 것이 좋습니다.
DELIMITER $$ ... DELIMITER ;

이벤트 본문(DO BEGIN ... END) 내에 여러 SQL 문장(세미콜론; 포함)이 있을 수 있으므로, SQL 문장의 기본 종료 문자를 $$로 일시적으로 변경했다가 이벤트 정의 후 다시 ;로 복원합니다.
CREATE EVENT IF NOT EXISTS log_hyphen_in_line1

log_hyphen_in_line1이라는 이름의 이벤트를 생성합니다. IF NOT EXISTS는 동일한 이름의 이벤트가 없을 경우에만 생성하도록 합니다.
ON SCHEDULE EVERY 10 MINUTE

이벤트가 10분 간격으로 실행되도록 예약합니다. MINUTE 대신 HOUR, DAY 등을 사용할 수도 있습니다.
STARTS CURRENT_TIMESTAMP

이벤트가 생성된 직후 (또는 가장 가까운 10분 주기)부터 시작되도록 설정합니다. 특정 시간부터 시작하도록 변경할 수도 있습니다.
DO BEGIN ... END

이벤트가 실행될 때 수행할 SQL 작업들을 정의합니다.
INSERT INTO smd.repair_func_new_log (...) SELECT ... FROM smd.repair_func_now ...:
smd.repair_func_now 테이블에서 line1 컬럼에 '-' (하이픈) 문자를 포함하는 (LIKE '%-%') 모든 행을 선택합니다.
선택된 행들의 지정된 컬럼 값들을 smd.repair_func_new_log 테이블의 해당 컬럼들로 삽입합니다.
매우 중요: INSERT INTO smd.repair_func_new_log 뒤에 오는 괄호 안의 컬럼 목록과 SELECT 뒤에 오는 컬럼 목록은 반드시 실제 테이블 구조에 맞게 정확히 수정해주셔야 합니다. 컬럼의 순서와 개수가 일치해야 하며, 데이터 타입도 호환되어야 합니다. smd.repair_func_new_log 테이블에 자동 증가하는 ID 컬럼이나 DEFAULT CURRENT_TIMESTAMP로 설정된 로그 시간 컬럼이 있다면, 이 컬럼들은 INSERT INTO 목록에 포함시키지 않아도 자동으로 값이 채워집니다.
사용 전 주의사항:
백업: 중요한 시스템에 적용하기 전에는 반드시 데이터베이스를 백업하세요.
테스트: 개발 또는 테스트 환경에서 충분히 테스트하여 의도한 대로 작동하는지 확인하세요. 특히 INSERT INTO ... SELECT ... 문의 컬럼 매칭을 주의 깊게 확인하세요.
권한: 이벤트를 생성하고 실행하려면 해당 MySQL 사용자에게 EVENT 권한이 필요합니다. (GRANT EVENT ON smd.* TO 'username'@'localhost';)
부하: smd.repair_func_now 테이블이 매우 크고, '-'가 포함된 데이터가 많으며, 10분마다 실행되는 이 쿼리가 시스템에 부하를 줄 수 있습니다. line1 컬럼에 인덱스가 없다면 조회 성능이 느릴 수 있습니다. 필요하다면 line1 컬럼에 대한 인덱싱을 고려하거나, 실행 주기를 조절하세