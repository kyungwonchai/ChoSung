습니다. 지금 상황은 Streamlit에서 row["time1"]를 읽으려고 할 때, MSSQL의 DATETIME 형식이 Python에서 문자열 또는 datetime 객체로 제대로 인식되지 않아서 에러가 나는 경우입니다.

✅ 문제 요약
MSSQL의 DATETIME 형식 컬럼을 가져옴 → row["time1"]
그런데 Streamlit/Python에서 접근 시 에러
예:
python
코드 복사
list indices must be integers or slices, not str
or
expected str, got NoneType
✅ 추천 해결 방법 3가지
✅ 1. SQL에서 time1을 문자열로 변환해서 전달 (yyyy-MM-dd HH:mm:ss)
가장 안정적이고 간단한 방법입니다.

프로시저 수정 (SELECT문에서 time1 가공):
sql
코드 복사
CONVERT(VARCHAR(19), MAX(time1), 120) AS time1
예시 전체:
sql
코드 복사
SELECT 
    model1,
    CONVERT(VARCHAR(19), MAX(time1), 120) AS time1,
    ...
120 포맷은 'yyyy-mm-dd hh:mi:ss'
Python에서 row["time1"]은 이제 문자열 "2024-03-19 15:10:05"로 처리됨.
✅ 2. Python 쪽에서 datetime 객체로 받도록 처리
만약 time1이 datetime 형식으로 넘어오고 str로 보여주기만 하면 되는 경우:

python
코드 복사
# row["time1"] 이 datetime 객체일 수 있으니 포맷팅해서 출력
formatted_time = row["time1"].strftime("%Y-%m-%d %H:%M:%S")
st.subheader(f"Model: {row['model1']} | Time: {formatted_time}")
✅ 3. 예외 방지 안전 처리
python
코드 복사
if row["time1"]:
    if isinstance(row["time1"], str):
        formatted_time = row["time1"]
    else:
        formatted_time = row["time1"].strftime("%Y-%m-%d %H:%M:%S")
else:
    formatted_time = "(no time)"
✅ 정리
방법	설명
SQL에서 CONVERT(..., 120) 사용	가장 안전, 문자열로 받아서 처리
Python에서 .strftime()	datetime 객체 그대로 받아 사용 가능
둘 다 혼용	타입 안정성 고려해 조건 분기 가능