네, 요청하신 내용을 바탕으로 C# WinForms 애플리케이션 코드를 작성해 드리겠습니다.

아래 코드는 전체 프로젝트를 한 번에 볼 수 있도록 주요 로직을 Form 클래스 내에 모두 구현했습니다. 실제 프로젝트에서는 기능별로 클래스를 분리하여 관리하는 것이 더 효율적일 수 있습니다.

코드의 각 부분에는 주석을 달아 어떤 역할을 하는지 쉽게 이해할 수 있도록 했습니다. 변수명은 요청하신 대로 전체 인프라와 세부 로직 간에 통일성을 유지하도록 명명했습니다.

시작하기 전 준비사항
Visual Studio를 실행하고 새 프로젝트 만들기를 선택합니다.

Windows Forms 앱(.NET Framework) 템플릿을 선택하고 프로젝트를 생성합니다. (또는 .NET 6/7/8 용 Windows Forms 앱도 괜찮습니다.)

디자인 뷰에서 도구 상자를 열어 Button과 RichTextBox를 폼에 추가합니다.

Button의 (Name) 속성은 btnProcessFiles로, Text 속성은 파일 처리 시작으로 변경합니다.

RichTextBox의 (Name) 속성은 rtbLog로, Dock 속성은 Fill로 설정하여 폼에 꽉 차게 만듭니다.

C# 전체 코드
아래 코드를 복사하여 Form1.cs 파일의 기존 코드를 모두 덮어쓰거나, 필요한 부분을 붙여넣으세요.

C#

using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace ProViewerFileProcessor
{
    public partial class Form1 : Form
    {
        // UI 컨트롤 정의
        private System.Windows.Forms.Button btnProcessFiles;
        private System.Windows.Forms.RichTextBox rtbLog;

        public Form1()
        {
            InitializeComponent();
            // 코드 실행 전, 위 '준비사항'에 따라 디자이너에서 컨트롤을 추가했는지 확인하세요.
        }

        /// <summary>
        /// '파일 처리 시작' 버튼 클릭 시 실행되는 이벤트 핸들러
        /// </summary>
        private async void btnProcessFiles_Click(object sender, EventArgs e)
        {
            // 기본 경로 설정
            string dataFolderPath = @"C:\proviewer\Data";

            // UI 업데이트
            btnProcessFiles.Enabled = false;
            rtbLog.Clear();
            Log("파일 처리 프로세스를 시작합니다...");
            Log($"대상 기본 폴더: {dataFolderPath}");
            Log("------------------------------------");


            try
            {
                // Task.Run을 사용하여 백그라운드 스레드에서 파일 처리를 실행 (UI 멈춤 방지)
                await Task.Run(() => ProcessAllMachineFolders(dataFolderPath));
                Log("------------------------------------");
                Log("✅ 모든 작업이 성공적으로 완료되었습니다.");
            }
            catch (Exception ex)
            {
                // 오류 발생 시 로그 기록
                Log($"❌ 처리 중 오류가 발생했습니다: {ex.Message}");
                Log($"Stack Trace: {ex.StackTrace}");
            }
            finally
            {
                // 버튼 다시 활성화
                btnProcessFiles.Enabled = true;
            }
        }

        /// <summary>
        /// 모든 Machine 폴더를 순회하며 처리를 시작하는 메인 메서드
        /// </summary>
        /// <param name="dataFolderPath">데이터 최상위 폴더 경로 (C:\proviewer\Data)</param>
        private void ProcessAllMachineFolders(string dataFolderPath)
        {
            // 처리할 머신 이름 배열
            string[] machineNames = {
                "Machine1", "Machine2", "Machine3", "Machine4",
                "Machine5", "Machine6", "Machine7", "Machine8"
            };

            foreach (var machineName in machineNames)
            {
                string stage1Path = Path.Combine(dataFolderPath, machineName, "Stage1");
                Log($"\n▶ {machineName} 폴더 처리 시작...");

                if (!Directory.Exists(stage1Path))
                {
                    Log($"  경고: '{stage1Path}' 폴더를 찾을 수 없습니다. 건너뜁니다.");
                    continue;
                }
                
                // Lane1, Lane2 폴더가 없으면 생성
                Directory.CreateDirectory(Path.Combine(stage1Path, "Lane1"));
                Directory.CreateDirectory(Path.Combine(stage1Path, "Lane2"));

                // Stage1 폴더 내의 .PRO 파일 목록을 이름 오름차순으로 정렬하여 가져옴
                List<string> proFiles = Directory.GetFiles(stage1Path, "*.PRO", SearchOption.TopDirectoryOnly)
                                                 .OrderBy(f => Path.GetFileName(f))
                                                 .ToList();

                if (proFiles.Count == 0)
                {
                    Log("  처리할 .PRO 파일이 없습니다.");
                    continue;
                }

                // 머신 이름에 따라 다른 처리 로직 호출
                switch (machineName)
                {
                    case "Machine4":
                        ProcessMachine4(stage1Path, proFiles);
                        break;
                    case "Machine5":
                        ProcessMachine5(stage1Path, proFiles);
                        break;
                    default: // Machine1, 2, 3, 6, 7, 8
                        ProcessGeneralMachines(stage1Path, proFiles);
                        break;
                }
            }
        }

        /// <summary>
        /// Machine 1, 2, 3, 6, 7, 8 처리 로직
        /// </summary>
        private void ProcessGeneralMachines(string stage1Path, List<string> proFiles)
        {
            foreach (var proFilePath in proFiles)
            {
                try
                {
                    var fileContent = new List<string>(File.ReadAllLines(proFilePath, Encoding.Default));
                    int targetLane = 0; // 0은 아직 레인을 찾지 못했음을 의미

                    bool inTakeUpUnitSection = false;
                    foreach (var line in fileContent)
                    {
                        if (line.Trim().Equals("[TakeUp.Unit]", StringComparison.OrdinalIgnoreCase))
                        {
                            inTakeUpUnitSection = true;
                            continue;
                        }

                        if (inTakeUpUnitSection)
                        {
                            if (string.IsNullOrWhiteSpace(line)) // 빈 줄을 만나면 섹션 끝
                            {
                                break; 
                            }

                            // '1,' 또는 '2,'로 시작하는 라인인지 정규식으로 확인
                            if (Regex.IsMatch(line.Trim(), @"^[12],"))
                            {
                                targetLane = int.Parse(line.Trim().Substring(0, 1));
                                break; // 레인 번호를 찾았으므로 더 이상 찾을 필요 없음
                            }
                        }
                    }

                    if (targetLane != 0) // 레인 번호를 성공적으로 찾았다면
                    {
                        ModifyAndMoveProFile(proFilePath, stage1Path, fileContent, targetLane);
                    }
                    else
                    {
                        Log($"  파일 '{Path.GetFileName(proFilePath)}': [TakeUp.Unit] 섹션에서 레인 결정 규칙을 찾지 못해 건너뜁니다.");
                    }
                }
                catch (Exception ex)
                {
                    Log($"  파일 '{Path.GetFileName(proFilePath)}' 처리 중 오류: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// Machine 4 처리 로직
        /// </summary>
        private void ProcessMachine4(string stage1Path, List<string> proFiles)
        {
            long previousTakeUpValue = 0;
            bool isFirstFile = true;

            foreach (var proFilePath in proFiles)
            {
                try
                {
                    var fileContent = new List<string>(File.ReadAllLines(proFilePath, Encoding.Default));
                    long currentTakeUpValue = 0;
                    int targetLane = 1; // 기본값은 1

                    // 파일에서 TakeUp 값 파싱
                    bool inTakeUpUnitSection = false;
                    foreach (var line in fileContent)
                    {
                        if (line.Trim().Equals("[TakeUp.Unit]", StringComparison.OrdinalIgnoreCase))
                        {
                            inTakeUpUnitSection = true;
                            continue;
                        }

                        if (inTakeUpUnitSection)
                        {
                            if (string.IsNullOrWhiteSpace(line)) break;
                            
                            if (line.Trim().StartsWith("2,20006"))
                            {
                                string lastValueStr = line.Trim().Split(',').LastOrDefault();
                                long.TryParse(lastValueStr, out currentTakeUpValue);
                                break;
                            }
                        }
                    }

                    if (isFirstFile)
                    {
                        targetLane = 1; // 첫 파일은 비교 대상이 없으므로 Lane 1
                        isFirstFile = false;
                    }
                    else
                    {
                        // 이전 값보다 증가했으면 Lane 2, 아니면 Lane 1
                        if (currentTakeUpValue > previousTakeUpValue)
                        {
                            targetLane = 2;
                        }
                    }
                    
                    ModifyAndMoveProFile(proFilePath, stage1Path, fileContent, targetLane);

                    // 다음 파일을 위해 현재 값을 이전 값으로 업데이트
                    previousTakeUpValue = currentTakeUpValue;

                }
                catch (Exception ex)
                {
                    Log($"  파일 '{Path.GetFileName(proFilePath)}' 처리 중 오류: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// Machine 5 처리 로직
        /// </summary>
        private void ProcessMachine5(string stage1Path, List<string> proFiles)
        {
            foreach (var proFilePath in proFiles)
            {
                try
                {
                    var fileContent = new List<string>(File.ReadAllLines(proFilePath, Encoding.Default));
                    int targetLane = 2; // Machine5는 항상 Lane 2
                    ModifyAndMoveProFile(proFilePath, stage1Path, fileContent, targetLane);
                }
                catch (Exception ex)
                {
                    Log($"  파일 '{Path.GetFileName(proFilePath)}' 처리 중 오류: {ex.Message}");
                }
            }
        }

        /// <summary>
        /// PRO 파일의 Lane= 값을 수정하고 올바른 Lane 폴더로 이동시키는 공통 메서드
        /// </summary>
        /// <param name="proFilePath">원본 파일 전체 경로</param>
        /// <param name="stage1Path">Stage1 폴더 경로</param>
        /// <param name="fileContent">파일 내용</param>
        /// <param name="targetLane">지정할 레인 번호 (1 또는 2)</param>
        private void ModifyAndMoveProFile(string proFilePath, string stage1Path, List<string> fileContent, int targetLane)
        {
            // "Lane="으로 시작하는 라인 찾기
            int laneLineIndex = fileContent.FindIndex(l => l.Trim().StartsWith("Lane=", StringComparison.OrdinalIgnoreCase));

            if (laneLineIndex != -1)
            {
                // Lane= 값을 새로운 레인 번호로 변경
                fileContent[laneLineIndex] = $"Lane={targetLane}";

                // 변경된 내용을 파일에 다시 씀
                File.WriteAllLines(proFilePath, fileContent, Encoding.Default);

                // 목적지 경로 설정 및 파일 이동
                string destFileName = Path.GetFileName(proFilePath);
                string destFolderPath = Path.Combine(stage1Path, $"Lane{targetLane}");
                string destFilePath = Path.Combine(destFolderPath, destFileName);

                // 혹시 같은 이름의 파일이 존재하면 덮어쓰기 위해 삭제 후 이동
                if (File.Exists(destFilePath))
                {
                    File.Delete(destFilePath);
                }
                File.Move(proFilePath, destFilePath);

                Log($"  파일 '{destFileName}' -> Lane={targetLane}으로 수정 후 'Lane{targetLane}' 폴더로 이동 완료.");
            }
            else
            {
                Log($"  파일 '{Path.GetFileName(proFilePath)}'에서 'Lane=' 라인을 찾을 수 없습니다.");
            }
        }


        /// <summary>
        /// RichTextBox에 스레드-안전하게 로그를 기록하는 메서드
        /// </summary>
        /// <param name="message">기록할 메시지</param>
        private void Log(string message)
        {
            if (rtbLog.InvokeRequired)
            {
                // 다른 스레드에서 호출된 경우, UI 스레드에서 실행하도록 위임
                rtbLog.Invoke(new Action<string>(Log), message);
            }
            else
            {
                // UI 스레드에서 직접 로그 추가
                rtbLog.AppendText(message + Environment.NewLine);
                rtbLog.ScrollToCaret(); // 자동으로 스크롤
            }
        }

        #region Windows Form Designer generated code
        // ... (이 부분은 Visual Studio 디자이너가 자동으로 생성하므로 수정할 필요 없습니다)
        private void InitializeComponent()
        {
            this.btnProcessFiles = new System.Windows.Forms.Button();
            this.rtbLog = new System.Windows.Forms.RichTextBox();
            this.SuspendLayout();
            // 
            // btnProcessFiles
            // 
            this.btnProcessFiles.Dock = System.Windows.Forms.DockStyle.Top;
            this.btnProcessFiles.Font = new System.Drawing.Font("맑은 고딕", 12F, System.Drawing.FontStyle.Bold, System.Drawing.GraphicsUnit.Point, ((byte)(129)));
            this.btnProcessFiles.Location = new System.Drawing.Point(0, 0);
            this.btnProcessFiles.Name = "btnProcessFiles";
            this.btnProcessFiles.Size = new System.Drawing.Size(800, 50);
            this.btnProcessFiles.TabIndex = 0;
            this.btnProcessFiles.Text = "파일 처리 시작";
            this.btnProcessFiles.UseVisualStyleBackColor = true;
            this.btnProcessFiles.Click += new System.EventHandler(this.btnProcessFiles_Click);
            // 
            // rtbLog
            // 
            this.rtbLog.BackColor = System.Drawing.SystemColors.Window;
            this.rtbLog.Dock = System.Windows.Forms.DockStyle.Fill;
            this.rtbLog.Location = new System.Drawing.Point(0, 50);
            this.rtbLog.Name = "rtbLog";
            this.rtbLog.ReadOnly = true;
            this.rtbLog.Size = new System.Drawing.Size(800, 400);
            this.rtbLog.TabIndex = 1;
            this.rtbLog.Text = "";
            // 
            // Form1
            // 
            this.AutoScaleDimensions = new System.Drawing.SizeF(7F, 12F);
            this.AutoScaleMode = System.Windows.Forms.AutoScaleMode.Font;
            this.ClientSize = new System.Drawing.Size(800, 450);
            this.Controls.Add(this.rtbLog);
            this.Controls.Add(this.btnProcessFiles);
            this.Name = "Form1";
            this.Text = "PRO 파일 분류기";
            this.ResumeLayout(false);
        }
        #endregion
    }
}

코드 주요 특징
비동기 처리: async/await와 Task.Run을 사용하여 파일 처리 중 UI가 멈추는 현상을 방지했습니다.

안전한 로그: 백그라운드 스레드에서 UI 컨트롤(RichTextBox)에 접근할 때 발생할 수 있는 오류를 InvokeRequired와 Invoke로 해결하여 스레드-안전하게 로그를 기록합니다.

로직 분리: 각 Machine 그룹의 처리 로직을 별도의 메서드(ProcessGeneralMachines, ProcessMachine4, ProcessMachine5)로 분리하여 가독성과 유지보수성을 높였습니다.

공통 로직 재사용: 파일 수정 및 이동 로직은 모든 Machine에서 공통적으로 사용되므로 ModifyAndMoveProFile 메서드로 만들어 재사용했습니다.

오류 처리: try-catch 구문을 사용하여 개별 파일 처리 중 오류가 발생하더라도 전체 프로세스가 중단되지 않고 다음 파일 처리를 계속하도록 구현했습니다.

인코딩 문제 방지: File.ReadAllLines와 File.WriteAllLines 사용 시 Encoding.Default를 지정하여 한글 또는 특수문자가 포함된 경우의 깨짐 문제를 방지합니다. (파일 인코딩이 다르다면 new UTF8Encoding(false) 등으로 변경해야 할 수 있습니다.)

폴더 자동 생성: 파일을 이동시킬 Lane1, Lane2 폴더가 존재하지 않는 경우 Directory.CreateDirectory를 통해 자동으로 생성합니다.

정규식 사용: [TakeUp.Unit] 섹션에서 '1,' 또는 '2,'로 시작하는 라인을 찾을 때 Regex를 사용하여 더 정확하고 간결하게 조건을 확인합니다.

