먼저, ML.NET을 사용하기 위해 NuGet 패키지를 설치해야 합니다. Visual Studio의 NuGet 패키지 관리자에서 Microsoft.ML 패키지를 설치하십시오.

1. NuGet 패키지 설치
Visual Studio에서 솔루션 탐색기로 이동합니다.
프로젝트를 마우스 오른쪽 버튼으로 클릭하고 "NuGet 패키지 관리..."를 선택합니다.
Microsoft.ML 패키지를 검색하고 설치합니다.
2. 수정된 MainWindow.xaml.cs
기존 FileData 클래스와 혼동되지 않도록 새로운 클래스 이름으로 변경하겠습니다. 또한, MLModelBuilder에서 발생할 수 있는 모든 오류를 수정합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private string logDirectory = @"C:\agent\SMDFIleClean";
        private MLModelBuilder _mlModelBuilder;
        private SettingsManager _settingsManager;

        public MainWindow()
        {
            InitializeComponent();
            _mlModelBuilder = new MLModelBuilder();
            _settingsManager = new SettingsManager();
            LoadSettings();
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                SaveSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnLoadSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                LoadSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void SaveSettings()
        {
            try
            {
                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = txtFileExtension.Text,
                    DriveName = txtDriveName.Text
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "Enter folder path";
                    txtFileExtension.Text = settings.FileExtension ?? "Enter file extension (e.g., .jpg)";
                    txtDriveName.Text = settings.DriveName ?? "Enter drive name (e.g., C:)";
                }
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private async void btnStart_Click(object sender, RoutedEventArgs e)
        {
            string folderPath = txtFolderPath.Text;
            string fileExtension = txtFileExtension.Text;
            string driveName = txtDriveName.Text;

            if (string.IsNullOrEmpty(folderPath) || folderPath == "Enter folder path" ||
                string.IsNullOrEmpty(fileExtension) || fileExtension == "Enter file extension (e.g., .jpg)" ||
                string.IsNullOrEmpty(driveName) || driveName == "Enter drive name (e.g., C:)")
            {
                MessageBox.Show("Please provide all inputs.");
                return;
            }

            try
            {
                var initialFiles = CollectInitialFileData(folderPath, fileExtension);
                _mlModelBuilder.TrainModel(initialFiles);

                await MonitorAndCleanFiles(folderPath, fileExtension, driveName);
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private List<FileRecord> CollectInitialFileData(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories);

                var fileDataList = files.Select(f => new FileRecord
                {
                    Hour = f.CreationTime.Hour,
                    DayOfWeek = (int)f.CreationTime.DayOfWeek
                }).ToList();

                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = $"Training on {files.Length} files";
                });

                return fileDataList;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return new List<FileRecord>();
            }
        }

        private async Task MonitorAndCleanFiles(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = GetDriveFreeSpace(driveName);
                    if (freeSpace < MinimumFreeSpace)
                    {
                        List<FileInfo> filesToDelete = GetFilesToDelete(folderPath, fileExtension);
                        await DeleteFilesAsync(filesToDelete);
                    }

                    UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return 0;
            }
        }

        private List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories)
                                      .OrderBy(f => f.CreationTime)
                                      .ToList();

                var filesToDelete = files.Where(file => _mlModelBuilder.Predict(file)).ToList();

                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = $"Monitoring {files.Count} files. {filesToDelete.Count} files marked for deletion.";
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
                return new List<FileInfo>();
            }
        }

        private async Task DeleteFilesAsync(List<FileInfo> files)
        {
            foreach (var file in files)
            {
                try
                {
                    file.Delete();
                    LogDeletion(file.FullName);
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                }
                catch (Exception ex)
                {
                    LogError(ex.Message);
                }
            }
        }

        private void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                DirectoryInfo directory = new DirectoryInfo(folderPath);
                var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories);
                long totalSize = files.Sum(f => f.Length);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add($"Folder: {folderPath}, Total Size: {totalSize / (1024 * 1024)} MB");
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogDeletion(string filePath)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "yyyyMMddlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: Deleted {filePath}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstDeletionLogs.Items.Add(logMessage);
                    if (lstDeletionLogs.Items.Count > 200)
                    {
                        lstDeletionLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add(logMessage);
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception)
            {
                // 에러 로깅에 실패한 경우 추가 조치 없음
            }
        }

        private void TextBox_GotFocus(object sender, RoutedEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if (textBox.Text == "Enter folder path" || textBox.Text == "Enter file extension (e.g., .jpg)" || textBox.Text == "Enter drive name (e.g., C:)")
                {
                    textBox.Text = string.Empty;
                }
            }
        }

        private void TextBox_LostFocus(object sender, RoutedEventArgs e)
        {
            TextBox textBox = sender as TextBox;
            if (textBox != null)
            {
                if (string.IsNullOrWhiteSpace(textBox.Text))
                {
                    if (textBox.Name == "txtFolderPath")
                    {
                        textBox.Text = "Enter folder path";
                    }
                    else if (textBox.Name == "txtFileExtension")
                    {
                        textBox.Text = "Enter file extension (e.g., .jpg)";
                    }
                    else if (textBox.Name == "txtDriveName")
                    {
                        textBox.Text = "Enter drive name (e.g., C:)";
                    }
                }
            }
        }
    }

    public class FileRecord
    {
        public float Hour { get; set; }
        public float DayOfWeek { get; set; }
    }
}
3. 수정된 MLModelBuilder.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileRecord> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileRecord>();
        }

        public void TrainModel(List<FileRecord> fileData)
        {
            try
            {
                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);
                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileRecord.Hour), nameof(FileRecord.DayOfWeek))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model.", ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileRecord
                {
                    Hour = fileInfo.CreationTime.Hour,
                    DayOfWeek = (int)fileInfo.CreationTime.DayOfWeek
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileRecord, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification.", ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var patternGroups = _fileDataList.GroupBy(f => new { f.Hour, f.DayOfWeek })
                    .Select(g => new { g.Key.Hour, g.Key.DayOfWeek, Count = g.Count() })
                    .OrderByDescending(g => g.Count);

                return string.Join(", ", patternGroups.Select(g => $"Hour: {g.Hour}, Day: {g.DayOfWeek}, Count: {g.Count}"));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns.", ex);
            }
        }
    }

    public class FileRecord
    {
        public float Hour { get; set; }
        public float DayOfWeek { get; set; }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
설명
NuGet 패키지 설치: Microsoft.ML 패키지를 설치합니다.
클래스 이름 변경: 기존 FileData 클래스를 FileRecord 클래스로 변경하여 혼동을 방지합니다.
예외 처리 추가: 모든 주요 메서드에 예외 처리를 추가하여 프로그램이 안정적으로 작동하도록 합니다.
이제 이 코드를 사용하면 설정이 자동으로 저장되고 불러와지며, 머신러닝 모델을 통해 파일 생성 패턴을 분석하고, 주기적으로 파일을 모니터링하고 삭제할 수 있습니다.