뮤토콜(Mewtocol) 프로토콜을 사용하여 PLC의 특정 번지에서 값을 읽고, 각 값에 따라 특정 작업을 수행한 후 값을 초기화하는 방법을 구현할 수 있습니다. 이를 위해 기존의 WPF 프로젝트에 다음과 같은 단계로 기능을 추가하겠습니다:

시리얼 포트를 통한 Mewtocol 명령 전송 및 수신: ComPortManager 클래스에서 시리얼 포트를 통해 Mewtocol 프로토콜을 사용하여 PLC와 통신합니다.
UI 업데이트: 읽어온 PLC의 데이터를 WPF UI에 표시합니다.
설명 추가 및 데이터 클리어: 특정 번지에서 읽어온 값에 대한 설명을 추가하고, 데이터를 클리어하는 작업을 수행합니다.
실시간 상태 업데이트: R520 및 R521 번지의 값을 실시간으로 읽어와 UI에 표시합니다.
1. ComPortManager 클래스 수정
ComPortManager 클래스는 시리얼 포트를 통해 PLC와 통신하는 기능을 담당합니다. 이 클래스에 데이터를 읽고 쓰는 기능을 추가합니다.

ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class ComPortManager
    {
        private SerialPort _port;
        private string _currentPortName;

        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _currentPortName = portName;

            if (_port != null && _port.IsOpen)
            {
                _port.Close();
            }

            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);
        }

        public async Task<string> SendDataToPLCAsync(string data)
        {
            try
            {
                if (_port == null || !_port.IsOpen)
                {
                    _port.Open();
                }

                _port.WriteLine(data);
                await Task.Delay(100); // 응답 대기 시간

                string response = _port.ReadLine();
                Console.WriteLine($"Sent: {data}, Received: {response}");

                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending data to PLC: {ex.Message}");
                return string.Empty;
            }
            finally
            {
                if (_port != null && _port.IsOpen)
                {
                    _port.Close();
                }
            }
        }

        public async Task<string> ReadFromPLCAsync(string address)
        {
            string command = $"%01#RDD{address}**\r"; // Mewtocol 명령어
            return await SendDataToPLCAsync(command);
        }

        public async Task<string> WriteToPLCAsync(string address, int value)
        {
            string command = $"%01#WDD{address}{value:D4}**\r"; // Mewtocol 명령어
            return await SendDataToPLCAsync(command);
        }

        public async Task<string> ClearPLCValueAsync(string address)
        {
            return await WriteToPLCAsync(address, 0); // 값을 0으로 클리어
        }
    }
}
2. UI 업데이트
UI에서 실시간으로 데이터를 표시하고, 특정 명령을 전송하는 버튼을 추가합니다.

MainWindow.xaml
xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:RouterMiddleACR.Controls"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <!-- PLC에서 읽어온 데이터를 표시할 텍스트 블록 -->
        <StackPanel Orientation="Vertical" Margin="10">
            <TextBlock Text="PLC 상태:" FontWeight="Bold" FontSize="16" />
            <TextBlock Text="{Binding R520Status}" Margin="5" />
            <TextBlock Text="{Binding R521Status}" Margin="5" />

            <!-- 데이터 읽기 및 초기화 버튼 -->
            <Button Content="데이터 읽기 및 초기화" Click="ReadAndClearData_Click" Margin="5" />
        </StackPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;
        }

        private async void ReadAndClearData_Click(object sender, RoutedEventArgs e)
        {
            await _viewModel.ReadAndClearPLCData();
        }
    }
}
3. MainViewModel 수정
MainViewModel에서 데이터를 읽고 UI에 바인딩하며, 사용자의 요청에 따라 PLC 데이터를 읽고 초기화하는 기능을 추가합니다.

MainViewModel.cs
csharp
코드 복사
using System.ComponentModel;
using System.Threading.Tasks;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1"); // 실제 포트 이름으로 변경

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        public async Task ReadAndClearPLCData()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300"); // DT2330에서 읽기
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300"); // 값을 0으로 초기화
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            // 예: 0 - "정상", 1 - "오류", ...
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200"); // R520 읽기
                string r521 = await _comPortManager.ReadFromPLCAsync("005201"); // R521 읽기

                // 상태 업데이트
                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000); // 1초 간격으로 업데이트
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
4. 적용 방법
시리얼 포트 설정: ComPortManager 클래스에서 시리얼 포트를 설정하여 PLC와의 통신을 준비합니다.
데이터 읽기: MainViewModel의 ReadAndClearPLCData 메서드에서 특정 PLC 번지(DT2330)의 값을 읽어옵니다.
상태 업데이트: 주기적으로 R520과 R521의 값을 읽어와 UI에 표시합니다.
UI 바인딩: MainWindow.xaml에서 TextBlock을 사용하여 PLC 상태를 UI에 표시합니다.
이 구조는 Mewtocol 프로토콜을 사용하여 PLC와 통신하고, UI를 통해 실시간으로 데이터를 표시하는 기능을 제공합니다. 이를 통해 PLC의 특정 주소에서 데이터를 읽고, 그에 따라 UI에 표시하거나 데이터를 초기화할 수 있습니다