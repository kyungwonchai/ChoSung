press의 WPF **TreeViewControl**을 사용하여 구역과 라인에 체크박스를 표시하고, 구역을 선택하면 해당 구역 내 모든 라인이 선택되거나 해제되도록 구현할 수 있습니다. 아래는 이를 구현하는 방법을 단계별로 설명합니다.

1. 데이터 모델 정의
먼저, 구역과 라인을 표현하는 데이터 모델을 정의합니다.

csharp
코드 복사
public class Line
{
    public string Name { get; set; }
    public bool IsChecked { get; set; }
}

public class Zone
{
    public string Name { get; set; }
    public ObservableCollection<Line> Lines { get; set; }
    public bool IsChecked { get; set; }
}
여기서 Zone 클래스는 구역을 나타내며, 각 구역은 여러 개의 Line 객체를 포함하는 Lines 컬렉션을 가집니다. IsChecked 속성은 체크박스의 선택 상태를 나타냅니다.

2. XAML에서 TreeViewControl 설정
TreeViewControl을 사용하여 구역과 라인을 트리 구조로 표시하고, 각 항목에 체크박스를 추가합니다.

xml
코드 복사
<Window x:Class="TreeViewCheckboxExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:TreeViewCheckboxExample"
        Title="TreeView with Checkboxes" Height="450" Width="400">
    <Grid>
        <TreeView ItemsSource="{Binding Zones}">
            <TreeView.Resources>
                <!-- 라인 템플릿 -->
                <HierarchicalDataTemplate DataType="{x:Type local:Line}">
                    <StackPanel Orientation="Horizontal">
                        <CheckBox IsChecked="{Binding IsChecked, Mode=TwoWay}" />
                        <TextBlock Text="{Binding Name}" Margin="5,0,0,0" />
                    </StackPanel>
                </HierarchicalDataTemplate>

                <!-- 구역 템플릿 -->
                <HierarchicalDataTemplate DataType="{x:Type local:Zone}" ItemsSource="{Binding Lines}">
                    <StackPanel Orientation="Horizontal">
                        <CheckBox IsChecked="{Binding IsChecked, Mode=TwoWay}" Checked="ZoneCheckBox_Checked" Unchecked="ZoneCheckBox_Unchecked" />
                        <TextBlock Text="{Binding Name}" Margin="5,0,0,0" />
                    </StackPanel>
                </HierarchicalDataTemplate>
            </TreeView.Resources>
        </TreeView>
    </Grid>
</Window>
위의 XAML에서는 TreeView의 각 노드에 체크박스를 포함한 StackPanel을 사용하여 구역과 라인을 표시합니다. 구역의 체크박스는 Checked 및 Unchecked 이벤트를 통해 선택 상태 변경 시 동작을 처리합니다.

3. 코드 비하인드에서 선택 상태 동기화
구역의 체크박스를 선택하거나 해제하면 해당 구역 내 모든 라인의 선택 상태가 변경되도록 이벤트 핸들러를 구현합니다. 또한, 각 라인의 선택 상태가 변경되면 해당 구역의 선택 상태도 업데이트되도록 합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;

namespace TreeViewCheckboxExample
{
    public partial class MainWindow : Window
    {
        public ObservableCollection<Zone> Zones { get; set; }

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;

            // 예제 데이터 초기화
            Zones = new ObservableCollection<Zone>
            {
                new Zone
                {
                    Name = "Zone 1",
                    Lines = new ObservableCollection<Line>
                    {
                        new Line { Name = "Line 1.1" },
                        new Line { Name = "Line 1.2" }
                    }
                },
                new Zone
                {
                    Name = "Zone 2",
                    Lines = new ObservableCollection<Line>
                    {
                        new Line { Name = "Line 2.1" },
                        new Line { Name = "Line 2.2" }
                    }
                }
            };

            // 각 라인의 PropertyChanged 이벤트 구독
            foreach (var zone in Zones)
            {
                foreach (var line in zone.Lines)
                {
                    line.PropertyChanged += (s, e) => UpdateZoneCheckState(zone);
                }
            }
        }

        private void ZoneCheckBox_Checked(object sender, RoutedEventArgs e)
        {
            if (sender is CheckBox checkBox && checkBox.DataContext is Zone zone)
            {
                foreach (var line in zone.Lines)
                {
                    line.IsChecked = true;
                }
            }
        }

        private void ZoneCheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            if (sender is CheckBox checkBox && checkBox.DataContext is Zone zone)
            {
                foreach (var line in zone.Lines)
                {
                    line.IsChecked = false;
                }
            }
        }

        private void UpdateZoneCheckState(Zone zone)
        {
            if (zone.Lines.All(line => line.IsChecked))
            {
                zone.IsChecked = true;
            }
            else if (zone.Lines.All(line => !line.IsChecked))
            {
                zone.IsChecked = false;
            }
            else
            {
                // 일부 라인만 선택된 경우, 구역의 체크박스를 '부분 선택' 상태로 설정
                // WPF의 기본 CheckBox는 세 가지 상태를 지원하지 않으므로, 추가 구현이 필요합니다.
            }
        }
    }

    public class Line : INotifyPropertyChanged
    {
        private bool _isChecked;
        public string Name { get; set; }
        public bool IsChecked
        {
            get => _isChecked;
            set
            {
                if (_isChecked != value)
                {
                    _isChecked = value;
                    OnPropertyChanged(nameof(IsChecked));
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class Zone : INotifyPropertyChanged
    {
        private bool _isChecked;
        public string Name { get; set; }
        public ObservableCollection<Line> Lines { get; set; }
        public bool IsChecked
        {
            get => _isChecked;
            set
            {
                if (_isChecked != value)
                {
                    _isChecked = value;
                    OnPropertyChanged(nameof(IsChecked));
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
   
::contentReference[oaicite:0]{index=0}
 



