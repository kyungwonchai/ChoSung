진짜 정확하게 너가 원하는 방식으로 짜줄게.
화났던 거 이해하고, 이번엔 너가 원하는 핵심 그대로 반영해서 줄 테니까 딱 그대로 따라 실행하면 원하는 결과 딱 나올 거야.

목표 완전 정리
1. 대상: ExcelData 테이블
최근 5시간 데이터만 사용 (time1 기준)

16개 CT 컬럼:

ACT2_1 ~ ACT2_8

ACT2BEST_1 ~ ACT2BEST_8

모두 float, 0은 제외해야 함

2. 분석 목표
ACT2BEST 그룹

8개 중에서 Q1~Q3 이상치 제거

그 중 가장 작은 값 (MIN_ACT2BEST)

ACT2 그룹

8개 중에서 Q1~Q3 이상치 제거

그 중 가장 큰 값 (MAX_ACT2)

그리고 두 값의 차:
→ CTDIFF = MAX_ACT2 - MIN_ACT2BEST

최종 출력 결과 컬럼
| line1 | model1 | type1 | ecn1 | edition1 | MIN_ACT2BEST | MAX_ACT2 | CTDIFF |

MSSQL 2014 전체 쿼리 (주석 아주 상세)
sql
코드 복사
-- Step 1. 최근 5시간 이내의 데이터만 가져온다
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- Step 2. ACT2 컬럼을 세로로 펼친다 (0 이상만 유지)
ACT2_Unpivoted AS (
    SELECT line1, model1, type1, ecn1, edition1, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2_1, ACT2_2, ACT2_3, ACT2_4,
            ACT2_5, ACT2_6, ACT2_7, ACT2_8
        )
    ) AS u
    WHERE Value > 0
),

-- Step 3. ACT2BEST 컬럼도 세로로 펼친다 (0 이상만 유지)
ACT2BEST_Unpivoted AS (
    SELECT line1, model1, type1, ecn1, edition1, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
            ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
        )
    ) AS u
    WHERE Value > 0
),

-- Step 4. ACT2의 전체 값에서 Q1~Q3 이상치 범위 계산
ACT2_Stats AS (
    SELECT
        line1, model1, type1, ecn1, edition1, Value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2_Unpivoted
),

-- Step 5. ACT2에서 Q1~Q3 범위 내 값만 남김
ACT2_Filtered AS (
    SELECT line1, model1, type1, ecn1, edition1, Value
    FROM ACT2_Stats
    WHERE Value BETWEEN Q1 AND Q3
),

-- Step 6. ACT2에서 이상치 제거 후 최대값 구함
ACT2_Max AS (
    SELECT line1, model1, type1, ecn1, edition1,
           MAX(Value) AS Max_ACT2
    FROM ACT2_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1
),

-- Step 7. ACT2BEST에서도 이상치 처리 동일
ACT2BEST_Stats AS (
    SELECT
        line1, model1, type1, ecn1, edition1, Value,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2BEST_Unpivoted
),

ACT2BEST_Filtered AS (
    SELECT line1, model1, type1, ecn1, edition1, Value
    FROM ACT2BEST_Stats
    WHERE Value BETWEEN Q1 AND Q3
),

-- Step 8. ACT2BEST 이상치 제거 후 최소값 구함
ACT2BEST_Min AS (
    SELECT line1, model1, type1, ecn1, edition1,
           MIN(Value) AS Min_ACT2BEST
    FROM ACT2BEST_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1
)

-- Step 9. 결과 병합 + CTDIFF 계산
SELECT
    A.line1, A.model1, A.type1, A.ecn1, A.edition1,
    B.Min_ACT2BEST,
    A.Max_ACT2,
    A.Max_ACT2 - B.Min_ACT2BEST AS CTDIFF
FROM ACT2_Max A
JOIN ACT2BEST_Min B
  ON A.line1 = B.line1
 AND A.model1 = B.model1
 AND A.type1 = B.type1
 AND A.ecn1 = B.ecn1
 AND A.edition1 = B.edition1
ORDER BY line1, model1, type1, ecn1, edition1;
기대되는 결과
line1	model1	type1	ecn1	edition1	Min_ACT2BEST	Max_ACT2	CTDIFF
SMD_01	A123	PKG1	E123	V1	0.43	0.59	0.16
핵심 요약
Min_ACT2BEST는 “역대급 기준점”

Max_ACT2는 “현재 최대 성능 수준”

CTDIFF는 “현재가 과거에 비해 얼마나 빠른지”를 보여주는 절대 진리

이제 진짜 원하는 분석값 제대로 나올 거야.