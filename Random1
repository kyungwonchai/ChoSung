

import React from 'react';
import CodeBlock from './CodeBlock';
import PdfDownloadButton from './PdfDownloadButton';

const flaskAppCode = `
# app.py
# 이 스크립트는 Flask 웹서버와 LED 제어 로직을 모두 포함합니다.
# 설치: pip install Flask gunicorn rpi_ws281x
import threading
import json
from datetime import datetime
from collections import deque
from flask import Flask, request, jsonify, render_template_string

# --- 전역 상태 변수 ---
IS_RASPBERRY_PI = False
logs = deque(maxlen=50) # 최근 50개 로그만 저장
last_command = {"status": "아직 수신된 명령 없음"}

# --- LED 제어 로직 ---
# 라즈베리파이 전용 라이브러리 임포트 시도
try:
    from rpi_ws281x import PixelStrip, Color
    IS_RASPBERRY_PI = True
    
    class LedController:
        def __init__(self):
            # LED 스트립 설정 (실제 환경에 맞게 수정)
            self.LED_COUNT = 792      # 물리적으로 연결된 총 LED 개수
            self.LED_PIN = 18         # GPIO 핀 번호
            self.LED_FREQ_HZ = 800000 # 주파수 (보통 800khz)
            self.LED_DMA = 10         # DMA 채널
            self.LED_BRIGHTNESS = 128 # 밝기 (0-255)
            self.LED_INVERT = False   # 신호 반전
            
            self.strip = PixelStrip(self.LED_COUNT, self.LED_PIN, self.LED_FREQ_HZ, 
                                    self.LED_DMA, self.LED_INVERT, self.LED_BRIGHTNESS)
            self.strip.begin()
            log("? 실제 LED 컨트롤러 초기화 완료 (Raspberry Pi).")
            self.turn_off_all()

        def light_up_led(self, index, color_dict, duration_sec):
            if not (0 <= index < self.LED_COUNT):
                log(f"?? [ERROR] LED 인덱스 {index}가 범위를 벗어남 (0-{self.LED_COUNT-1}).")
                return

            self.turn_off_all()
            # 라이브러리는 GRB 순서를 사용하므로 r,g,b 순서를 바꿔서 전달
            color = Color(color_dict.get('g', 0), color_dict.get('r', 0), color_dict.get('b', 0))
            self.strip.setPixelColor(index, color)
            self.strip.show()
            
            threading.Timer(duration_sec, self.turn_off_all).start()

        def turn_off_all(self):
            for i in range(self.strip.numPixels()):
                self.strip.setPixelColor(i, Color(0, 0, 0))
            self.strip.show()

except (ImportError, RuntimeError):
    IS_RASPBERRY_PI = False
    
    class MockLedController:
        def __init__(self):
            log("?? 에뮬레이션 모드로 LED 컨트롤러 초기화 (Not a Raspberry Pi).")
        
        def light_up_led(self, index, color_dict, duration_sec):
            log(f"[ACTION] LED {index} 점등. 색상: {color_dict}, 시간: {duration_sec}초")
            threading.Timer(duration_sec, self.turn_off_led, args=[index]).start()

        def turn_off_led(self, index):
            log(f"[ACTION] LED {index} 자동 소등.")
        
        def turn_off_all(self):
            log("[ACTION] 모든 LED 소등.")

# --- Flask 웹 애플리케이션 ---
app = Flask(__name__)
led_controller = LedController() if IS_RASPBERRY_PI else MockLedController()

def log(message):
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    logs.appendleft(f"[{timestamp}] {message}")

@app.route('/')
def status_page():
    status_html = """
    <!DOCTYPE html>
    <html lang="ko"><head>
        <meta charset="UTF-8"><meta name="viewport" content="width=device-width, initial-scale=1.0">
        <meta http-equiv="refresh" content="5">
        <title>LED 컨트롤러 상태</title>
        <style>
            body { font-family: sans-serif; background-color: #121212; color: #e0e0e0; margin: 0; padding: 2rem; }
            .container { max-width: 900px; margin: auto; background-color: #1e1e1e; border: 1px solid #333; border-radius: 8px; padding: 2rem; }
            h1, h2 { color: #bb86fc; border-bottom: 2px solid #3700b3; padding-bottom: 0.5rem; }
            .status-badge { padding: 0.5em 1em; border-radius: 1em; font-weight: bold; }
            .status-ok { background-color: #03dac6; color: #121212; }
            .status-emulated { background-color: #cf6679; color: #121212; }
            pre, .log-box { background-color: #2c2c2c; border: 1px solid #444; border-radius: 4px; padding: 1rem; font-family: monospace; font-size: 0.9em; white-space: pre-wrap; word-break: break-all; }
            .log-box { height: 300px; overflow-y: auto; }
        </style>
    </head><body>
        <div class="container">
            <h1>LED 컨트롤러 상태 대시보드</h1>
            <p><strong>시스템 모드:</strong> 
                {% if is_rpi %}<span class="status-badge status-ok">? 실제 하드웨어 모드 (Raspberry Pi)</span>
                {% else %}<span class="status-badge status-emulated">?? 에뮬레이션 모드 (PC/서버)</span>{% endif %}
            </p>
            <h2>마지막 수신 명령</h2>
            <pre>{{ last_command_str }}</pre>
            <h2>실시간 로그 (최대 50개)</h2>
            <div class="log-box">
                {% for entry in log_entries %}{{ entry }}<br>{% endfor %}
            </div>
        </div>
    </body></html>
    """
    return render_template_string(
        status_html, 
        is_rpi=IS_RASPBERRY_PI,
        last_command_str=json.dumps(last_command, indent=2, ensure_ascii=False),
        log_entries=list(logs)
    )

@app.route('/api/v1/light-up', methods=['POST'])
def light_up_api():
    global last_command
    data = request.get_json()
    if not data:
        return jsonify({"error": "Invalid JSON"}), 400

    led_index = data.get('ledIndex')
    color = data.get('color')
    duration = data.get('duration')

    if led_index is None or color is None or duration is None:
        log("?? [WARN] 잘못된 요청 수신. 필수 필드 누락.")
        last_command = {"error": "Invalid payload", "received": data}
        return jsonify({"error": "Missing fields: ledIndex, color, duration"}), 400

    log(f"?? 게이트웨이로부터 LED {led_index}번 점등 명령 수신.")
    last_command = {
        "ledIndex": led_index, "color": color, "duration": duration,
        "receivedAt": datetime.now().isoformat()
    }
    
    led_controller.light_up_led(led_index, color, duration)
    return jsonify({"status": "Request accepted"}), 202

if __name__ == '__main__':
    # 개발용 서버 실행: flask --app app run --host=0.0.0.0
    app.run(host='0.0.0.0', port=5000, debug=True)
`;

const systemdServiceFile = `
[Unit]
Description=Gunicorn instance for LED Controller Flask app
After=network.target

[Service]
# 이 서비스는 GPIO 접근을 위해 반드시 root 권한으로 실행해야 합니다.
User=root
Group=www-data

# 프로젝트 디렉토리 경로 (실제 경로로 수정)
WorkingDirectory=/home/pi/rpi_controller
# 가상환경에 설치된 gunicorn 실행파일 경로 (실제 경로로 수정)
ExecStart=/home/pi/rpi_controller/venv/bin/gunicorn --workers 1 --bind 0.0.0.0:5000 --access-logfile - --error-logfile - app:app
Restart=always

[Install]
WantedBy=multi-user.target
`;


const LedControlGuide: React.FC = () => {
    const viewId = 'led-control-guide-view';
    return (
        <div id={viewId} className="text-gray-300 leading-relaxed">
            <div className="flex justify-between items-start mb-2">
                <div>
                    <h1 className="text-3xl font-bold text-white mb-2">Raspberry Pi 컨트롤러 구현 (Python/Flask)</h1>
                    <p className="text-lg text-cyan-300 mb-6">Python과 Flask로 LED를 제어하고, 웹 기반 상태 모니터링 페이지를 제공합니다.</p>
                </div>
                <div className="flex-shrink-0 ml-4">
                    <PdfDownloadButton elementId={viewId} fileName="RPi-Controller-Guide-Python.pdf" />
                </div>
            </div>
            
            <section className="space-y-4 mb-12">
                <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">1. 제어 환경 설정</h2>
                <p>
                    라즈베리 파이 터미널에서 아래 명령어를 순서대로 실행하여 Python 개발 환경을 구축하고 필요한 라이브러리를 설치합니다.
                </p>
                <CodeBlock code={`# 1. 시스템 패키지 및 Python 설치 확인
sudo apt update && sudo apt install -y python3 python3-pip python3-venv

# 2. 프로젝트 폴더 및 가상환경 생성
mkdir ~/rpi_controller && cd ~/rpi_controller
python3 -m venv venv
source venv/bin/activate

# 3. 필수 라이브러리 설치 (가상환경 활성화 상태에서)
# rpi_ws281x 라이브러리는 라즈베리 파이에서만 설치됩니다.
pip install Flask gunicorn rpi_ws281x`} language="bash" />
                <div className="p-4 bg-gray-800/50 border border-l-4 border-yellow-400 text-yellow-200 rounded-r-lg">
                    <p><strong className="font-bold">중요:</strong> `rpi_ws281x` 라이브러리는 하드웨어 GPIO에 직접 접근하므로, 이 라이브러리를 사용하는 스크립트는 항상 <code className="bg-gray-700 px-1 rounded">sudo</code> (root 권한)로 실행해야 합니다.</p>
                </div>
            </section>

            <section className="space-y-6 mt-12">
                <h2 className="text-2xl font-semibold text-white border-b-2 border-cyan-500 pb-3 mb-6">2. 통합 제어 서버 코드 (`app.py`)</h2>
                <p>이 단일 파일은 API 서버, LED 제어 로직, 상태 모니터링 웹 페이지 기능을 모두 포함합니다. `rpi_controller` 폴더에 아래 내용으로 `app.py` 파일을 생성하세요.</p>
                <CodeBlock code={flaskAppCode} language="python" />
                 <h3 className="text-xl font-semibold text-white mt-6 mb-2">핵심 기능</h3>
                 <ul className="list-disc list-inside space-y-2 mt-2 pl-4 text-gray-400">
                    <li><strong className="text-white">상태 대시보드:</strong> 라즈베리파이의 IP 주소로 접속하면 실시간 로그와 마지막 명령을 볼 수 있는 웹 페이지가 제공됩니다.</li>
                    <li><strong className="text-white">자동 에뮬레이션:</strong> 라즈베리파이가 아닌 PC/서버에서 실행 시, 자동으로 하드웨어 제어 코드를 비활성화하고 모든 동작을 로그로만 출력합니다.</li>
                    <li><strong className="text-white">API 엔드포인트:</strong> Ubuntu 게이트웨이로부터 `POST /api/v1/light-up` 요청을 받아 LED 점등을 처리합니다.</li>
                </ul>
            </section>

            <section className="space-y-6 mt-12">
                <h2 className="text-2xl font-semibold text-white border-b-2 border-cyan-500 pb-3 mb-6">3. 개발 서버 실행 및 테스트</h2>
                <p>개발 및 테스트 단계에서는 아래 명령어로 간단하게 서버를 실행할 수 있습니다. 가상환경이 활성화된 상태에서 실행하세요.</p>
                <CodeBlock code={`# Flask 개발 서버 실행 (root 권한 필요)
sudo venv/bin/flask --app app run --host=0.0.0.0 --port=5000`} language="bash" />
                <p className="mt-2 pl-4 text-gray-400">서버 실행 후 웹 브라우저에서 <code className="bg-gray-700 px-1 rounded">http://[라즈베리파이_IP]:5000</code> 으로 접속하여 상태 대시보드가 보이는지 확인합니다.</p>
            </section>

            <section className="space-y-6 mt-12">
                <h2 className="text-2xl font-semibold text-white border-b-2 border-cyan-500 pb-3 mb-6">4. 운영 배포 및 자동 실행 (Gunicorn + systemd)</h2>
                <p>실제 현장 운영을 위해, 전문적인 WSGI 서버인 Gunicorn을 사용하고 systemd 서비스를 등록하여 시스템 재부팅 시에도 서버가 자동으로 실행되도록 설정합니다.</p>
                
                <h3 className="text-lg font-bold text-white mt-4">1. systemd 서비스 파일 생성</h3>
                <p>아래 내용으로 서비스 파일을 생성합니다. <strong className="text-yellow-300">`WorkingDirectory`와 `ExecStart`의 경로는 실제 프로젝트 경로에 맞게 수정해야 합니다.</strong></p>
                <CodeBlock code={`sudo nano /etc/systemd/system/led_controller.service`} language="bash" />
                <p>에디터가 열리면 아래 내용을 붙여넣고 저장합니다.</p>
                <CodeBlock code={systemdServiceFile} language="ini" />

                <h3 className="text-lg font-bold text-white mt-4">2. 서비스 활성화 및 시작</h3>
                <p>아래 명령어를 실행하여 서비스를 시스템에 등록하고 시작합니다.</p>
                 <CodeBlock code={`# systemd 데몬에 새 서비스 파일 리로드
sudo systemctl daemon-reload

# 부팅 시 서비스가 자동으로 시작되도록 활성화
sudo systemctl enable led_controller.service

# 지금 바로 서비스 시작
sudo systemctl start led_controller.service

# 서비스 상태 확인
sudo systemctl status led_controller.service`} language="bash" />
            </section>
        </div>
    );
};

export default LedControlGuide;
