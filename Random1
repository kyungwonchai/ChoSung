, 정확하게 이해하고 계십니다. 면밀히 분석하여 가이드 드리겠습니다.

분석 및 확인:

A처리 vs B처리:

A처리 (내가 보낸 요청에 대한 응답): _responseTasks 딕셔너리에서 해당 요청을 찾고, 관련된 TaskCompletionSource<T> (tcs)를 가져와 tcs.SetResult(받은 응답)를 호출하여 기다리던 비동기 작업(await GetResponseAsync(...) 같은)을 완료시키는 것이 맞습니다.
B처리 (서버가 일방적으로 보낸 메시지 - 선점 신호): 이 경우는 클라이언트가 특정 응답을 기다리고 있던 상황이 아닙니다. 따라서 _responseTasks에 있는 tcs와는 관련이 없습니다. 여기서 tcs.SetResult를 호출하면 엉뚱한 대기 중인 요청이 완료되는 심각한 버그가 발생할 수 있습니다. B처리는 이 메시지를 받아 다른 방식(이벤트 발생, 상태 업데이트, UI 표시 등)으로 처리해야 합니다.
B처리 함수 (HandlePreemptiveSignal)의 반환 타입 (void):

HandlePreemptiveSignal 함수의 목적은 받은 메시지를 처리하는 동작을 수행하는 것입니다. 이 함수가 비동기적으로 완료되어야 할 결과를 ReceiveLoopAsync에게 돌려줄 필요는 없습니다. 따라서 반환 타입이 void인 것은 전혀 문제가 되지 않으며 일반적입니다. (만약 HandlePreemptiveSignal 내부에서 await를 사용해야 한다면 async void나 async Task로 만들 수 있지만, 단순히 void여도 괜찮습니다.)
로그 기록 및 UI 갱신 문제:

"로그를 기록하면서 프로그램 UI에 로그를 갱신하는 곳이 있거든 그거 때문일라나": 네, 가능성이 매우 높습니다. 이것이 바로 이전에 언급된 "발송자 스레드와 다른 스레드..." 오류의 가장 전형적인 원인입니다.
왜 문제인가?:
ReceiveLoopAsync는 Task.Run을 통해 백그라운드 스레드(UI 스레드가 아닌 별도의 스레드)에서 실행됩니다.
B처리 로직 (HandlePreemptiveSignal 또는 이 함수가 호출하는 LogMessage 함수 등)도 같은 백그라운드 스레드에서 실행됩니다.
대부분의 UI 프레임워크(WPF, WinForms 등)는 UI 요소(텍스트박스, 리스트박스, 레이블 등)를 생성한 **UI 스레드(발송자 스레드)**에서만 해당 요소의 내용을 변경하거나 접근하는 것을 허용합니다.
만약 백그라운드 스레드에서 직접 UI 요소(예: 로그를 표시하는 텍스트박스)를 건드리려고 시도하면, UI 프레임워크는 스레드 안전성을 위해 InvalidOperationException (크로스-스레드 작업 오류)을 발생시킵니다. 이 예외가 ReceiveLoopAsync에서 제대로 처리되지 않으면 태스크가 중단되고 소켓 연결이 끊어지는 현상으로 이어질 수 있습니다.
가이드:

문제 해결을 위해 다음 단계를 따르세요.

UI 업데이트 코드 식별: B처리 경로(HandlePreemptiveSignal 또는 그 안에서 호출되는 LogMessage, 혹은 OnMessageSent 이벤트 핸들러 등)에서 실제로 UI 컨트롤의 속성을 변경하거나 메서드를 호출하는 코드 라인을 정확히 찾아야 합니다.

예시: logTextBox.AppendText(...), logListBox.Items.Add(...), statusLabel.Content = ... 등
UI 스레드로 작업 전달: 식별된 UI 업데이트 코드 바로 앞에서, 현재 스레드가 UI 스레드인지 확인하고, 아니라면 UI 스레드에서 해당 코드를 실행하도록 **작업을 전달(Dispatching)**해야 합니다.

WPF 사용 시: Dispatcher 객체 (일반적으로 Application.Current.Dispatcher 또는 컨트롤의 Dispatcher 속성)를 사용하여 InvokeAsync 또는 Invoke를 호출합니다.

C#

// LogMessage 함수 또는 UI를 업데이트하는 다른 함수 내부
string logEntry = "..."; // UI에 표시할 로그 문자열

// uiDispatcher는 미리 얻어둔 UI 스레드의 Dispatcher 객체
if (uiDispatcher.CheckAccess()) // 현재 UI 스레드인가?
{
    // 맞다면 직접 UI 업데이트
    ActualUiUpdateMethod(logEntry);
}
else // 아니라면
{
    // UI 스레드에서 실행하도록 예약 (InvokeAsync 사용 권장)
    uiDispatcher.InvokeAsync(() => ActualUiUpdateMethod(logEntry));
}

// ... (UI 업데이트와 관련 없는 다른 로깅 작업은 여기서 계속) ...

// 실제 UI 업데이트 메서드 (예시)
void ActualUiUpdateMethod(string text)
{
    myLogTextBox.AppendText(text + Environment.NewLine);
}
WinForms 사용 시: 업데이트하려는 Control 객체 (예: TextBox 인스턴스)의 InvokeRequired 속성을 확인하고 Invoke 또는 BeginInvoke 메서드를 사용합니다.

C#

// LogMessage 함수 또는 UI를 업데이트하는 다른 함수 내부
string logEntry = "..."; // UI에 표시할 로그 문자열

// myLogTextBox는 UI 컨트롤의 인스턴스
if (myLogTextBox.InvokeRequired) // 다른 스레드에서 호출되었는가?
{
    // 대리자(Delegate)를 사용하여 UI 스레드에서 메서드 호출
    myLogTextBox.Invoke(new Action(() => ActualUiUpdateMethod(logEntry)));
    // 또는 BeginInvoke 사용 (비동기 예약)
    // myLogTextBox.BeginInvoke(new Action(() => ActualUiUpdateMethod(logEntry)));
}
else // UI 스레드에서 호출되었다면
{
    // 직접 UI 업데이트
    ActualUiUpdateMethod(logEntry);
}

// ... (UI 업데이트와 관련 없는 다른 로깅 작업은 여기서 계속) ...

// 실제 UI 업데이트 메서드 (예시)
void ActualUiUpdateMethod(string text)
{
    myLogTextBox.AppendText(text + Environment.NewLine);
}
Dispatcher 또는 Control 객체 접근: LogMessage 함수나 이벤트 핸들러 등 UI 업데이트가 필요한 코드에서 UI 스레드의 Dispatcher(WPF) 또는 해당 Control(WinForms)에 접근할 수 있어야 합니다. 이는 보통 생성자 주입, 정적 속성, 또는 클래스 멤버 변수를 통해 이루어집니다.

결론:

사용자님의 추측대로, B처리(HandlePreemptiveSignal 또는 관련 함수) 중에 발생하는 UI 로그 갱신 작업이 백그라운드 스레드에서 직접 수행되면서 크로스-스레드 오류를 발생시키고, 이로 인해 소켓 루프가 비정상 종료되어 연결이 끊어지는 것이 거의 확실해 보입니다.

해결책은 UI 업데이트 코드를 찾아 해당 UI 프레임워크에 맞는 방식(Dispatcher 또는 Control.Invoke)으로 UI 스레드에서 안전하게 실행되도록 수정하는 것입니다.