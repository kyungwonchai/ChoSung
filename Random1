import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import pymssql
import numpy as np
import os
import json

# 데이터베이스 및 파일 설정
DB_CONFIG = {
    "server": "YOUR_SERVER",  # MSSQL 서버 주소
    "user": "YOUR_USER",  # 사용자명
    "password": "YOUR_PASSWORD",  # 비밀번호
    "database": "YOUR_DATABASE"  # 데이터베이스 이름
}
DATA_SOURCE = "txt"  # "db" 또는 "txt" 선택 가능
TXT_FILE_PATH = "runwait.txt"  # 텍스트 파일 경로

# 모델 저장 경로
MODEL_PATH = "qr_model.pth"
TOKENIZER_PATH = "tokenizer.json"

# QR 데이터 로드 함수
def fetch_data():
    if DATA_SOURCE == "db":
        conn = pymssql.connect(**DB_CONFIG)
        cursor = conn.cursor()
        cursor.execute("EXEC your_stored_procedure")
        data = cursor.fetchall()
        conn.close()
    elif DATA_SOURCE == "txt":
        with open(TXT_FILE_PATH, "r", encoding="utf-8") as f:
            data = [line.strip().split()[:2] for line in f if len(line.strip().split()) >= 2]
    return data

# QR 코드 토큰화 함수
def create_tokenizer(data):
    unique_chars = sorted(set("".join(qr for _, qr in data)))
    char_to_idx = {char: idx for idx, char in enumerate(unique_chars, start=1)}
    char_to_idx["<PAD>"] = 0
    
    def tokenizer(qr_code):
        return [char_to_idx.get(char, 0) for char in qr_code]
    
    return tokenizer, char_to_idx

# LSTM 기반 QR 예측 모델 정의
class QRModel(nn.Module):
    def __init__(self, input_dim, hidden_dim, output_dim):
        super(QRModel, self).__init__()
        self.lstm = nn.LSTM(input_dim, hidden_dim, batch_first=True)
        self.fc = nn.Linear(hidden_dim, output_dim)
    
    def forward(self, x):
        _, (h_n, _) = self.lstm(x)
        return self.fc(h_n.squeeze(0))

# 모델 저장 및 불러오기 함수
def save_model(model, tokenizer):
    torch.save(model.state_dict(), MODEL_PATH)
    with open(TOKENIZER_PATH, "w") as f:
        json.dump(tokenizer, f)

def load_model(input_dim, hidden_dim, output_dim):
    model = QRModel(input_dim, hidden_dim, output_dim)
    if os.path.exists(MODEL_PATH):
        model.load_state_dict(torch.load(MODEL_PATH))
    return model

def load_tokenizer():
    with open(TOKENIZER_PATH, "r") as f:
        char_to_idx = json.load(f)
    def tokenizer(qr_code):
        return [char_to_idx.get(char, 0) for char in qr_code]
    return tokenizer

# QR 코드 예측 함수
def predict_qr(qr_code):
    tokenizer = load_tokenizer()
    model = load_model(input_dim=50, hidden_dim=128, output_dim=len(model_to_idx))
    model.eval()
    
    qr_encoded = tokenizer(qr_code)
    qr_tensor = torch.tensor([qr_encoded], dtype=torch.float32)
    
    with torch.no_grad():
        output = model(qr_tensor)
        probabilities = torch.softmax(output, dim=1).squeeze().numpy()
    
    top_idx = np.argmax(probabilities)
    top_model = idx_to_model[top_idx]
    confidence = probabilities[top_idx] * 100
    
    return top_model, confidence

# 데이터 로드 및 학습 실행
if __name__ == "__main__":
    raw_data = fetch_data()
    tokenizer, char_to_idx = create_tokenizer(raw_data)
    model_list = list(set(model for model, _ in raw_data))
    model_to_idx = {model: idx for idx, model in enumerate(model_list)}
    idx_to_model = {idx: model for model, idx in model_to_idx.items()}
    
    dataset = [(qr, model_to_idx[model]) for model, qr in raw_data]
    input_dim = max(len(qr) for _, qr in raw_data)
    hidden_dim = 128
    output_dim = len(model_list)
    
    model = load_model(input_dim, hidden_dim, output_dim)