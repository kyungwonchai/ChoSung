, 알겠습니다. powercfg /SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE <초단위값> 명령을 사용하는 방식으로 SAgentM.App의 코드를 수정하겠습니다.

수정해야 할 파일은 SAgentM.App/Services/AgentCoreService.cs 입니다. 이 파일의 ExecuteDirectCommandAsync 메서드 내에서 SetDisplayTimeout 명령을 처리하는 부분을 변경하여 새로운 powercfg 명령 형식을 사용하도록 하겠습니다.

SControl.Common의 SetDisplayTimeoutPayload는 여전히 TimeoutMinutes (분 단위)를 사용하지만, AgentCoreService.cs 내부에서 이 값을 초 단위로 변환하여 powercfg 명령에 전달하게 됩니다.

수정: SAgentM.App/Services/AgentCoreService.cs (전체 코드)
C#

// SAgentM.App/Services/AgentCoreService.cs
using Newtonsoft.Json;
using SControl.Common; 
using System;
using System.Configuration;
using System.Diagnostics; 
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel; // Win32Exception 사용

namespace SAgentM.App.Services
{
    // IAgentCoreService 인터페이스 정의는 이전과 동일하게 유지합니다.
    public interface IAgentCoreService 
    { 
        void Start(); 
        void Stop(); 
        bool IsRunning { get; } 
    }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026; 
                _loggingService.UiWarn($"ListenPort 설정이 App.config에 없거나 잘못되어 기본값 {_port} 포트를 사용합니다.");
            }
        }

        public void Start()
        {
            if (_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 실행 중."); return; }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 중지됨."); return; }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5))) { _loggingService.UiWarn("리스닝 스레드 시간 내 종료 안됨."); }
            }
            _cancellationTokenSource?.Dispose(); _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try
            {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning)
                {
                    try
                    {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se)
                    {
                        if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted))
                        { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; }
                        _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se);
                        if (!_isRunning) break; Thread.Sleep(100);
                    }
                    catch (InvalidOperationException ioe) when (!_isRunning)
                    { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex)
                    { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally
            {
                if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); }
                _loggingService.UiInfo("ListenLoop 종료됨.");
            }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try
            {
                _loggingService.UiDebug($"[{clientIpInfo}] 클라이언트 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested)
                    {
                        string requestJson = null;
                        try
                        {
                            var readTask = reader.ReadLineAsync();
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask)
                            {
                                if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 후 취소 감지."); token.ThrowIfCancellationRequested(); }
                                requestJson = await readTask;
                            }
                            else { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 대기 중 취소 감지."); token.ThrowIfCancellationRequested(); }

                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 연결 종료 (스트림 끝)."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}");

                            CommandPacket requestPacket = null;
                            try
                            {
                                requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson);
                                receivedRequestPacket = requestPacket;
                            }
                            catch (JsonException jsonEx)
                            {
                                _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx);
                                await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON format: {jsonEx.Message}"))); continue;
                            }

                            if (requestPacket != null)
                            {
                                _loggingService.UiInfo($"[{clientIpInfo}] 명령 처리 시작: ID={requestPacket.PacketId}, Cmd={requestPacket.CommandName}");
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null)
                                {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] 응답 전송 전 취소 감지."); token.ThrowIfCancellationRequested(); }
                                    await writer.WriteLineAsync(responseJson);
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답 전송: {responseJson}");
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] 네트워크 IO 오류 (연결 끊김 예상): {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체 이미 해제됨 (연결 끊김 예상): {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 작업 취소됨."); break; }
                        catch (Exception ex)
                        {
                            _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 예기치 않은 오류.", ex);
                            if (client.Connected && stream.CanWrite)
                            { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}
                        }
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 자체가 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부에서 심각한 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request != null && request.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl)
            {
                MonitorControlPayload originalPayload = null;
                try { originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch { /* 무시 */ }
                if (originalPayload != null && originalPayload.Action == MonitorAction.Off)
                {
                    bool earlyConfirmWasSuccess = false;
                    if (response != null && !string.IsNullOrEmpty(response.PayloadJson))
                    { try { var genericRespPayload = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if (genericRespPayload != null) earlyConfirmWasSuccess = genericRespPayload.Success; } catch {/* 무시 */} }
                    if(earlyConfirmWasSuccess)
                    {
                        _loggingService.UiInfo($"[{clientIp}] 조기 확인 응답 전송 완료. 실제 모니터 끄기 (백그라운드). ID: {request.PacketId}");
                        Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료 (백그라운드). ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); 
                    } else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패 또는 페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiDebug($"[{clientIp}] 명령 처리 시작: {requestPacket.CommandName}, ID: {requestPacket.PacketId}");
            try
            {
                if (token.IsCancellationRequested) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 시작 전 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); token.ThrowIfCancellationRequested(); }
                switch (requestPacket.Instruction)
                {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token); 
                    default: _loggingService.UiWarn($"[{clientIp}] 알 수 없는 Instruction: {requestPacket.Instruction}, Packet ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 중 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, "Operation was canceled during command processing."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 명령 처리 중 오류: {requestPacket.CommandName}, ID: {requestPacket.PacketId}", ex); return CreateErrorResponse(requestPacket, $"Error processing command '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 직접 실행 명령: {requestPacket.CommandName}");
            bool success = false; string message = "Command execution failed or not implemented."; CommandPacket responsePacketToReturn = null;
            try
            {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName)
                {
                    case CommandNames.MonitorControl:
                        // ... (이전과 동일한 MonitorControl payload null 체크 및 역직렬화 로직) ...
                        // ... (MonitorAction.Off 및 기타 Action 처리 로직은 이전과 동일) ...
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "MonitorControl: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        MonitorControlPayload monitorPayload = null;
                        try { monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"MonitorControl: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (monitorPayload == null) { message = "MonitorControl: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        _loggingService.UiInfo($"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");
                        if (monitorPayload.Action == MonitorAction.Off)
                        { success = true; message = $"Monitor Off command acknowledged. Monitor will turn off shortly. Early confirm sent."; _loggingService.UiInfo($"[{clientIp}] {message} (ID: {requestPacket.PacketId})"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        else { LocalDeviceControl.SetMonitorState(monitorPayload.Action); success = true; message = $"Monitor state set to {monitorPayload.Action}."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        break;
                    
                    case CommandNames.SetDisplayTimeout: 
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "SetDisplayTimeout: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        SetDisplayTimeoutPayload timeoutPayload = null; 
                        try { timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"SetDisplayTimeout: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (timeoutPayload == null) { message = "SetDisplayTimeout: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        
                        // **** powercfg 명령 형식 변경 ****
                        int timeoutSeconds = timeoutPayload.TimeoutMinutes * 60; // 분을 초로 변환
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutPayload.TimeoutMinutes}분 ({timeoutSeconds}초)");
                        
                        try
                        {
                            string outputAc, errorAc, outputDc, errorDc; 
                            int exitCodeAc, exitCodeDc;

                            // SCHEME_CURRENT, SUB_VIDEO, VIDEOIDLE 별칭 사용
                            string acArgs = $"/SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}";
                            string dcArgs = $"/SETDCVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}";

                            RunPowerCfgCommand(acArgs, out outputAc, out errorAc, out exitCodeAc);
                            RunPowerCfgCommand(dcArgs, out outputDc, out errorDc, out exitCodeDc);
                            
                            if (exitCodeAc == 0 && exitCodeDc == 0) 
                            { 
                                success = true; 
                                message = $"Display timeout set to {timeoutPayload.TimeoutMinutes} min ({timeoutSeconds} sec) for AC/DC."; 
                                _loggingService.UiInfo($"[{clientIp}] {message}"); 
                            }
                            else 
                            { 
                                success = false; 
                                message = $"Failed to set display timeout. AC ExitCode: {exitCodeAc}, DC ExitCode: {exitCodeDc}."; 
                                if (!string.IsNullOrEmpty(errorAc)) message += $"\nAC Err: {errorAc.Trim()}"; 
                                if (!string.IsNullOrEmpty(errorDc)) message += $"\nDC Err: {errorDc.Trim()}"; 
                                _loggingService.UiError($"[{clientIp}] {message}"); 
                            }
                        } 
                        catch (Exception ex) 
                        { 
                            success = false; message = $"Error executing powercfg with SETACVALUEINDEX/SETDCVALUEINDEX: {ex.Message}"; 
                            _loggingService.UiError($"[{clientIp}] {message}", ex); 
                        }
                        responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
                        break;
                        // **** powercfg 명령 형식 변경 끝 ****
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break;
                }
            }
            catch (OperationCanceledException) { message = $"Direct command {requestPacket.CommandName} execution canceled."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            catch (Exception ex) { message = $"Error executing direct command {requestPacket.CommandName}: {ex.Message}"; _loggingService.UiError($"[{clientIp}] {message}", ex); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            return responsePacketToReturn;
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = string.Empty; error = string.Empty; exitCode = -1;
            try
            {
                _loggingService.UiDebug($"Executing powercfg command: powercfg.exe {arguments}");
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") 
                { 
                    Arguments = arguments, UseShellExecute = false, 
                    RedirectStandardOutput = true, RedirectStandardError = true, 
                    CreateNoWindow = true, Verb = "runas" 
                };
                using (Process process = Process.Start(startInfo))
                {
                    if (process == null) { error = "Failed to start powercfg.exe process."; _loggingService.UiError(error); return; }
                    
                    // 비동기적으로 출력/오류 스트림을 읽어야 교착 상태 방지 가능성 있음
                    // 여기서는 간단히 동기적으로 읽지만, 긴 출력이 예상되면 비동기 읽기 권장
                    output = process.StandardOutput.ReadToEnd(); 
                    error = process.StandardError.ReadToEnd(); 
                    
                    if (!process.WaitForExit(7000)) // 타임아웃 7초로 증가
                    {
                         process.Kill(); 
                         error += $"\npowercfg.exe process for arguments '{arguments}' timed out (7s) and was killed."; 
                         _loggingService.UiWarn(error);
                         exitCode = -99; // 타임아웃 시 임의의 종료 코드
                    }
                    else
                    {
                        exitCode = process.ExitCode;
                    }

                    if(!string.IsNullOrWhiteSpace(output)) _loggingService.UiDebug($"powercfg output: {output.Trim()}");
                    if(!string.IsNullOrWhiteSpace(error)) _loggingService.UiWarn($"powercfg error output: {error.Trim()}");
                }
            } 
            catch (Win32Exception w32Ex) 
            { 
                error = $"powercfg.exe Win32Exception (possibly UAC denied or not admin for Verb='runas'): {w32Ex.Message} (NativeErrorCode: {w32Ex.NativeErrorCode})"; 
                _loggingService.UiError(error, w32Ex); exitCode = w32Ex.NativeErrorCode; 
            } 
            catch (Exception ex) 
            { 
                error = $"powercfg.exe general exception: {ex.Message}"; 
                _loggingService.UiError(error, ex); exitCode = -2; 
            }
        }

        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이 명령: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            // (이전 답변 #33 또는 #35 의 RelayCommandAsync 전체 로직을 여기에 붙여넣으시면 됩니다.)
            // 현재 응답에서는 이 부분을 간략화하여 핵심 수정에 집중합니다.
            // 실제 구현 시에는 이전 답변의 전체 릴레이 로직을 사용하세요.
            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || 
                !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue)
            {
                return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP or Port missing.");
            }
            // ... 여기에 이전 답변의 전체 릴레이 로직 ...
            _loggingService.UiWarn("RelayCommandAsync is using placeholder logic in this snippet. Use full version from previous responses.");
            await Task.Delay(100, token); // 임시
            return CreateExecutionResponse(originalRelayRequest, false, "Relay functionality placeholder - implement full logic.");
        }

        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            return new CommandPacket {
                PacketId = pId, Instruction = CommandInstruction.DirectExecute, 
                CommandName = $"{cmdName}_Response", 
                PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }),
                ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort
            };
        }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            _loggingService.UiError($"Error response for Packet ID {pId} (Cmd: {cmdName}): {errorMsg}");
            return new CommandPacket {
                PacketId = pId, Instruction = CommandInstruction.DirectExecute, 
                CommandName = $"{cmdName}_ErrorResponse", 
                PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }),
                ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort
            };
        }
    }
}
AgentCoreService.cs의 주요 변경 사항:

ExecuteDirectCommandAsync 메서드 내 SetDisplayTimeout 처리 로직 변경:
timeoutPayload.TimeoutMinutes 값을 받아 timeoutSeconds = timeoutPayload.TimeoutMinutes * 60; 와 같이 초 단위로 변환합니다. (0분은 0초가 되어 "사용 안 함"으로 올바르게 처리됩니다.)
RunPowerCfgCommand를 호출할 때 전달하는 인수를 새로운 형식으로 변경했습니다:
AC 전원: argumentsAc = $"/SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}"
DC 전원: argumentsDc = $"/SETDCVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutSeconds}"
성공/실패 메시지에 분과 초를 함께 표시하도록 수정했습니다.
RunPowerCfgCommand 메서드 개선:
process.WaitForExit()에 타임아웃(7초)을 추가하고, 시간 초과 시 프로세스를 강제 종료(process.Kill())하고 로그를 남기도록 수정했습니다.
ProcessStartInfo에 Verb = "runas"가 이미 포함되어 있어 관리자 권한 상승을 시도합니다. Win32Exception 처리를 통해 UAC 거부 등의 상황을 좀 더 명확히 로깅할 수 있도록 했습니다.
powercfg.exe의 표준 출력 및 표준 오류를 로깅하여 디버깅에 도움이 되도록 했습니다.
다시 한번 강조:

SAgentM.App.exe는 반드시 관리자 권한으로 실행되어야 powercfg 명령이 성공할 수 있습니다. app.manifest 파일이 올바르게 설정되어 있고, 실행 시 UAC 프롬프트를 통해 권한을 부여했는지 확인해주세요.
만약 이 수정 후에도 powercfg 관련 오류(ExitCode 1 등)가 계속 발생한다면, 대상 Windows PC의 관리자 권한 명령 프롬프트에서 powercfg /SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE 60 (1분 설정) 또는 ... VIDEOIDLE 0 (사용 안 함 설정) 명령이 직접 실행 시 성공하는지 반드시 확인해야 합니다. 이 직접 실행 테스트가 실패하면 Windows 시스템 자체의 문제일 가능성이 큽니다.