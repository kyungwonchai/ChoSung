죄송합니다. 빌드 오류 때문에 많이 답답하셨을 것 같습니다. CS0117 오류는 컴파일러가 코드에 사용된 특정 타입(클래스, Enum 등)이나 그 타입의 멤버(메서드, 프로퍼티 등)를 찾지 못할 때 발생합니다. MessageContract.cs 파일과 관련된 오류라면, 주로 네임스페이스 설정이 잘못되었거나 파일 내용이 일치하지 않을 때 발생합니다.

공유 라이브러리를 사용하지 않고 각 프로젝트에 파일을 복사(Ctrl+CV)해서 사용하시는 경우, 다음과 같이 진행하시면 오류를 해결할 수 있습니다.

1. 최종 MessageContract.cs 파일 (모든 프로젝트 공통 사용)

아래 코드는 MessageContract.cs 파일의 최종 버전입니다. 이 파일 내용 전체를 그대로 복사해서 다음 세 프로젝트 각각의 Models 폴더(또는 원하시는 다른 폴더)에 넣어주세요.

MGSPBrokerService 프로젝트
MonitorAgent 프로젝트
MGSPMonitorControl (제어 UI) 프로젝트
중요: 이 파일의 네임스페이스를 모든 프로젝트에서 동일하게 유지하는 것이 매우 중요합니다. 여기서는 MonitorControl.SharedModels 라는 공통 네임스페이스를 사용하겠습니다.

C#

// 파일 경로 예시: MGSPBrokerService/Models/MessageContract.cs
// 파일 경로 예시: MonitorAgent/Models/MessageContract.cs
// 파일 경로 예시: MGSPMonitorControl/Models/MessageContract.cs

// !!! 중요 !!!
// 아래 네임스페이스는 세 프로젝트 모두에서 동일하게 사용해주세요.
// 이렇게 하면 각 프로젝트에서 이 파일에 정의된 타입을 동일한 방식으로 참조할 수 있습니다.
namespace MonitorControl.SharedModels // <--- 모든 프로젝트에서 이 네임스페이스를 사용합니다.
{
    using System; // DateTime 사용
    using System.Collections.Generic; // List 사용

    // 메시지 타입 구분용 Enum
    public enum MessageType
    {
        // 공통
        Ping,
        Pong,

        // Agent -> Broker (최초 연결 및 상태 보고)
        AgentHello,                 // Agent가 Broker에 처음 연결 시 자신을 알림 (AgentId, IP, Version 등)
        AgentStatusUpdate,          // Agent가 Broker에게 자신의 현재 상태 보고 (예: 모니터 상태)
        AgentCommandResult,         // Agent가 Broker에게 명령 실행 결과 보고

        // UI -> Broker (명령 및 요청)
        UiClientHello,              // UI 클라이언트가 Broker에 처음 연결 시 자신을 알림 (선택적)
        UiRequest_ControlAgent,     // UI가 Agent 제어 명령을 Broker에게 요청
        UiRequest_GetBrokerStatus,  // UI가 Broker에게 상태 및 로그 요청
        UiRequest_GetInitialAgentList, // UI가 Broker에게 현재 Agent 목록 요청

        // Broker -> Agent (명령 및 연결 관리)
        BrokerToAgent_ExecuteControl, // Broker가 Agent에게 실제 제어 명령 전달
        BrokerAck_AgentHello,       // Broker가 AgentHello에 대한 응답
        BrokerPingToAgent,          // Broker가 Agent 생존 확인용 Ping (Agent는 Pong으로 응답)
        BrokerRequestReRegistration, // Broker가 Agent에게 재등록 요청

        // Broker -> UI (상태 브로드캐스트 및 응답)
        BrokerToUi_BroadcastAgentRegisteredOrUpdated,
        BrokerToUi_BroadcastAgentDisconnected,
        BrokerToUi_BroadcastAgentStatus,
        BrokerToUi_ForwardAgentCommandResult,
        BrokerToUi_SendBrokerStatus,
        BrokerToUi_InitialAgentList,
        BrokerToUi_CommandDispatchFailed
    }

    // 모든 메시지의 기본 구조
    public class BrokerMessage
    {
        public MessageType Type { get; set; }
        public string SourceId { get; set; }
        public string TargetId { get; set; }
        public string CorrelationId { get; set; }
        public DateTime TimestampUtc { get; set; } = DateTime.UtcNow;
        public string Payload { get; set; } // 실제 데이터 (JSON 문자열)
    }

    // --- 페이로드 클래스들 ---

    public class AgentHelloPayload
    {
        public string AgentIdProvidedByApp { get; set; }
        public string MachineName { get; set; }
        public string PrimaryReportedIpAddress { get; set; }
        public List<string> AllIpAddresses { get; set; }
        public string AgentVersion { get; set; }
        public string OsVersion { get; set; }
        public string InitialMonitorStatus { get; set; }
    }

    public class UiControlAgentPayload
    {
        public string TargetAgentIdProvidedByApp { get; set; }
        public string ControlAction { get; set; }
        public string ControlType { get; set; }
        public string PrimaryIpAddress { get; set; }
        public int PrimaryPort { get; set; }
        public string GatewayAgentIdToUse { get; set; } // UI가 DB에서 조회한 게이트웨이 Agent의 AgentIdProvidedByApp
        public string OriginalParameters { get; set; }
    }

    public class BrokerExecuteControlPayload
    {
        public string ActionToPerform { get; set; }
        public string Parameters { get; set; }
        public bool IsGatewayRelayRequired { get; set; } = false;
        public string FinalTargetAgentIp { get; set; }
        public int FinalTargetAgentPort { get; set; }
        public string FinalTargetAgentId { get; set; } // 최종 대상 Agent의 ID (정보용)
    }

    public class AgentCommandResultPayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string CurrentMonitorStatus { get; set; }
    }
    
    public class AgentStatusUpdatePayload
    {
        public string CurrentMonitorStatus { get; set; }
        public bool IsRespondingToPing { get; set; } // 선택적
    }

    public class BrokerStatusInfoPayload // 이전 ServerStatusInfo와 유사
    {
        public DateTime ServerStartTimeUtc { get; set; }
        public string UptimeString { get; set; }
        public int ConnectedUiClientCount { get; set; }
        public int ConnectedAgentCount { get; set; }
        public List<string> RecentServerLogs { get; set; }
        public string BrokerVersion { get; set; }
    }

    // Broker가 UI로 Agent 정보를 브로드캐스트 할 때 사용하는 모델
    public class LiveAgentInfoForUi
    {
        public string AgentIdProvidedByApp { get; set; }
        public string AgentNameFromUiDb { get; set; } // UI가 DB정보와 매칭 후 채움
        public string PrimaryReportedIpAddress { get; set; }
        public List<string> AllIpAddresses { get; set; } // Agent가 보고한 전체 IP 목록
        public bool IsOnline { get; set; }
        public string CurrentMonitorStatus { get; set; }
        public DateTime LastHeartbeatUtc { get; set; }
        public string StatusMessageFromAgent { get; set; }
        // ControlType, GatewayAgentIdToUse 등 DB 설정 정보는 UI가 자체적으로 관리
    }
}
2. 각 프로젝트에서 MessageContract.cs 사용 시 using 지시문 추가

MessageContract.cs 파일에 정의된 MessageType, BrokerMessage, AgentHelloPayload 등의 타입을 사용하는 다른 C# 파일(예: RelayHub.cs, AgentCore.cs, MainWindow.xaml.cs 등)의 맨 위에는 반드시 다음 using 지시문을 추가해야 합니다.

C#

using MonitorControl.SharedModels; // MessageContract.cs 파일에 정의된 네임스페이스
이렇게 하시면 됩니다:

위 MessageContract.cs 전체 코드를 복사합니다.
MGSPBrokerService 프로젝트의 Models 폴더에 MessageContract.cs 파일을 만들고 내용을 붙여넣습니다. (기존 파일이 있다면 덮어씁니다)
MonitorAgent 프로젝트의 Models 폴더에도 MessageContract.cs 파일을 만들고 동일한 내용을 붙여넣습니다.
나중에 만들 MGSPMonitorControl (UI) 프로젝트의 Models 폴더에도 동일하게 작업합니다.
각 프로젝트에서 이 파일에 정의된 타입을 사용하는 모든 .cs 파일 상단에 using MonitorControl.SharedModels;를 추가합니다.
이렇게 하면 컴파일러가 MessageType이나 다른 페이로드 클래스들을 정확히 찾을 수 있게 되어 CS0117 오류가 해결될 것입니다.

이제 이 수정된 MessageContract.cs를 기준으로, 이전에 중단되었던 MonitorAgent 프로그램의 나머지 파일들을 이어서 드리겠습니다.

이전에 MonitorAgent/Config/AgentIdentifier.cs까지 드렸습니다. 다음은 MonitorAgent/Services/LoggingService.cs 입니다. (이 파일은 MessageContract.cs를 직접 사용하지는 않지만, Agent 코드의 일부이므로 순서대로 드립니다.)

MonitorAgent/Services/LoggingService.cs (수정된 최종본)
(이전 답변에서 이미 날짜별 로그 및 오래된 로그 삭제 기능이 포함된 버전을 드렸습니다. 혹시 그 버전과 다른 점이 있다면 알려주십시오. 여기서는 이전 최종본을 기준으로 다시 드립니다.)

C#

// MonitorAgent/Services/LoggingService.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using MonitorAgent.Config; // AppConstants 사용

namespace MonitorAgent.Services
{
    public enum LogLevel { Debug, Info, Warning, Error, Fatal }

    public interface ILoggingService
    {
        void LogDebug(string message);
        void LogInfo(string message);
        void LogWarning(string message);
        void LogError(string message, Exception ex = null);
        void LogFatal(string message, Exception ex = null);
    }

    public class AgentLoggingService : ILoggingService
    {
        private readonly string _logDirectory;
        private static readonly object _fileLock = new object();
        private LogLevel _currentLogLevel = LogLevel.Info;
        private const int DaysToKeepLogs = 3;

        public AgentLoggingService(string configuredLogLevel = "Info") // App.xaml.cs에서 AgentConfig 값으로 설정 가능
        {
            _logDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppConstants.LogDirectoryName);
            try
            {
                if (!Directory.Exists(_logDirectory))
                {
                    Directory.CreateDirectory(_logDirectory);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] Failed to create log directory '{_logDirectory}': {ex.Message}. Logging to base directory.");
                _logDirectory = AppDomain.CurrentDomain.BaseDirectory; // 폴백
            }
            
            SetLogLevel(configuredLogLevel); // 생성자에서 로그 레벨 설정
            LogInfo($"Agent Logging Service initialized. Log directory: {_logDirectory}. Log level: {_currentLogLevel}");

            CleanupOldLogs(); // 에이전트 시작 시 오래된 로그 정리
        }
        
        public void SetLogLevel(string logLevelString)
        {
            if (Enum.TryParse(logLevelString, true, out LogLevel parsedLevel))
            {
                _currentLogLevel = parsedLevel;
            }
            else
            {
                Console.WriteLine($"[WARN] Invalid log level string in config: '{logLevelString}'. Using default: {_currentLogLevel}.");
            }
        }

        private string GetLogFilePath()
        {
            return Path.Combine(_logDirectory, $"{DateTime.Now.ToString(AppConstants.LogFileNameDateFormat)}.log");
        }

        private void WriteLog(LogLevel level, string message, Exception ex = null)
        {
            if (level < _currentLogLevel) return;

            string logEntry = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] [{level.ToString().ToUpper()}] {message}";
            if (ex != null)
            {
                logEntry += $"{Environment.NewLine}   Exception >>> {ex.ToString()}"; // 스택 트레이스 포함
            }

            // 콘솔에도 항상 출력 (디버깅 및 서비스 실행 시 확인용)
            ConsoleColor originalColor = Console.ForegroundColor;
            switch (level)
            {
                case LogLevel.Debug:   Console.ForegroundColor = ConsoleColor.Gray; break;
                case LogLevel.Info:    Console.ForegroundColor = ConsoleColor.White; break;
                case LogLevel.Warning: Console.ForegroundColor = ConsoleColor.Yellow; break;
                case LogLevel.Error:   Console.ForegroundColor = ConsoleColor.Red; break;
                case LogLevel.Fatal:   Console.ForegroundColor = ConsoleColor.DarkRed; break;
                default: Console.ForegroundColor = ConsoleColor.Gray; break;
            }
            Console.WriteLine(logEntry);
            Console.ForegroundColor = originalColor;

            try
            {
                lock (_fileLock)
                {
                    File.AppendAllText(GetLogFilePath(), logEntry + Environment.NewLine, Encoding.UTF8);
                }
            }
            catch (Exception fileEx)
            {
                 Console.WriteLine($"[ERROR] !!! FAILED TO WRITE TO LOG FILE: {GetLogFilePath()} - {fileEx.Message} !!!");
            }
        }

        public void LogDebug(string message) => WriteLog(LogLevel.Debug, message);
        public void LogInfo(string message) => WriteLog(LogLevel.Info, message);
        public void LogWarning(string message) => WriteLog(LogLevel.Warning, message);
        public void LogError(string message, Exception ex = null) => WriteLog(LogLevel.Error, message, ex);
        public void LogFatal(string message, Exception ex = null) => WriteLog(LogLevel.Fatal, message, ex);

        private void CleanupOldLogs()
        {
            try
            {
                LogInfo($"Starting cleanup of logs older than {DaysToKeepLogs} days in '{_logDirectory}'...");
                if (!Directory.Exists(_logDirectory)) 
                {
                    LogWarning($"Log directory '{_logDirectory}' not found for cleanup.");
                    return;
                }

                var allLogFiles = Directory.GetFiles(_logDirectory, "*.log");
                int cleanedCount = 0;
                DateTime cutoffDate = DateTime.Now.Date.AddDays(-DaysToKeepLogs); // 오늘 날짜 기준 3일 전 자정

                foreach (var logFile in allLogFiles)
                {
                    string fileNameWithoutExtension = Path.GetFileNameWithoutExtension(logFile);
                    if (DateTime.TryParseExact(fileNameWithoutExtension, AppConstants.LogFileNameDateFormat, 
                                               System.Globalization.CultureInfo.InvariantCulture, 
                                               System.Globalization.DateTimeStyles.None, out DateTime logDate))
                    {
                        if (logDate.Date < cutoffDate) // cutoffDate 이전 날짜의 로그 파일
                        {
                            try
                            {
                                File.Delete(logFile);
                                LogInfo($"Deleted old log file: {Path.GetFileName(logFile)}");
                                cleanedCount++;
                            }
                            catch (Exception ex)
                            {
                                LogWarning($"Failed to delete old log file '{Path.GetFileName(logFile)}': {ex.Message}");
                            }
                        }
                    }
                }
                LogInfo($"Old log cleanup finished. Deleted {cleanedCount} file(s).");
            }
            catch (Exception ex)
            {
                LogError("Error during old log cleanup process.", ex);
            }
        }
    }
}
이제 MessageContract.cs는 세 프로젝트에 공통으로 적용하시고, 위 MonitorAgent/Services/LoggingService.cs 코드를 Agent 프로젝트에 업데이트하시면 됩니다.