비스에서 발생하는 모든 로그를 네임드 파이프를 통해 클라이언트에 전달하려면, LogService가 서비스 전체의 로그를 관리하고 전달하는 중앙 로그 처리 메커니즘으로 작동하도록 해야 합니다.

이를 위해 다음과 같은 단계와 코드 수정이 필요합니다:

중앙화된 로깅 메커니즘 구현: LogService를 서비스의 중앙 로깅 클래스으로 사용하여, 서비스 전체에서 발생하는 로그 메시지를 모두 수집하고 클라이언트에 전송합니다.

프로세스 종료 후 서비스 종료: 서비스가 종료될 때 먼저 서비스가 시작한 프로세스를 종료한 다음, 네임드 파이프를 닫고 리소스를 해제해야 합니다.

1. 중앙화된 로깅 메커니즘 구현
모든 서비스 클래스에서 로그 메시지를 LogService로 전달하도록 설정합니다. 이를 위해 각 서비스 클래스에서 발생하는 로그를 LogService로 보내고, LogService는 네임드 파이프를 통해 클라이언트에 로그를 전달합니다.

LogService 클래스 수정
csharp
코드 복사
using System;
using System.IO;
using System.IO.Pipes;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        private static LogService _instance; // 싱글톤 인스턴스
        private readonly string _logDirectory; // 로그 파일이 저장될 디렉터리 경로
        private readonly string _pipeName = "RouterMiddleACRLogPipe"; // 네임드 파이프 이름
        private NamedPipeServerStream _pipeServer;
        private StreamWriter _pipeWriter;
        private CancellationTokenSource _cancellationTokenSource;

        // 싱글톤 인스턴스 접근자
        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        // 생성자
        private LogService()
        {
            // 로그 디렉터리 경로 설정
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory); // 디렉터리가 없으면 생성
        }

        // 로그 서비스를 시작하는 메서드
        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ManagePipeServer(_cancellationTokenSource.Token));
        }

        // 로그 서비스를 중지하는 메서드
        public void Stop()
        {
            try
            {
                _cancellationTokenSource.Cancel();
                Task.Delay(1000).Wait(); // 모든 백그라운드 작업이 완료될 때까지 기다림
                ClosePipe();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error stopping service: {ex.Message}");
            }
        }

        // 로그 메시지를 기록하고 클라이언트로 전송하는 메서드
        public void LogMessage(string message)
        {
            try
            {
                string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";

                // 파일에 로그를 작성
                File.AppendAllText(logFilePath, logEntry + Environment.NewLine);

                // 네임드 파이프를 통해 클라이언트로 로그 전송
                _pipeWriter?.WriteLine(logEntry);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }

        // 파이프 서버를 닫는 메서드
        private void ClosePipe()
        {
            try
            {
                _pipeWriter?.Dispose();
                _pipeServer?.Dispose();
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error closing pipe: {ex.Message}");
            }
            finally
            {
                _pipeWriter = null;
                _pipeServer = null;
            }
        }

        // 파이프 서버를 관리하고, 클라이언트와의 지속적인 연결을 유지하는 메서드
        private async Task ManagePipeServer(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await StartPipeServer(cancellationToken);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error in pipe server: {ex.Message}");
                }

                // 클라이언트 연결이 끊어졌거나 예외 발생 시 파이프를 닫고 5초 후 재시도
                ClosePipe();
                await Task.Delay(5000, cancellationToken);
            }
        }

        // 네임드 파이프 서버를 시작하고 클라이언트와 통신하는 메서드
        private async Task StartPipeServer(CancellationToken cancellationToken)
        {
            try
            {
                _pipeServer = new NamedPipeServerStream(_pipeName, PipeDirection.Out, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous);
                Console.WriteLine("Waiting for client connection...");

                await _pipeServer.WaitForConnectionAsync(cancellationToken);
                Console.WriteLine("Client connected to pipe.");

                using (_pipeWriter = new StreamWriter(_pipeServer) { AutoFlush = true })
                {
                    while (!cancellationToken.IsCancellationRequested && _pipeServer.IsConnected)
                    {
                        await Task.Delay(1000, cancellationToken); // 1초 대기
                    }
                }
            }
            catch (IOException ex)
            {
                Console.WriteLine($"Pipe IO error: {ex.Message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Pipe server error: {ex.Message}");
            }
            finally
            {
                Console.WriteLine("Pipe server shutting down...");
                ClosePipe(); // 모든 경우에 파이프를 닫고 정리
            }
        }
    }
}
수정된 LogService 코드 설명
LogMessage 메서드:

서비스의 모든 로그 메시지를 받아 파일에 기록하고, 네임드 파이프를 통해 클라이언트에 전달합니다.
예외가 발생하더라도 로그를 남겨 문제 해결에 도움이 되도록 합니다.
중앙화된 로그 관리:

모든 로그 메시지는 LogMessage 메서드를 통해 기록되므로, 서비스 전체에서 발생하는 로그를 중앙에서 관리하고 클라이언트에 전달할 수 있습니다.
2. 프로세스 종료 후 서비스 종료
서비스가 종료될 때 서비스가 시작한 모든 프로세스를 먼저 종료하고, 그 후에 네임드 파이프를 닫고 리소스를 해제합니다.

서비스 클래스 수정
csharp
코드 복사
using System;
using System.Diagnostics;
using System.ServiceProcess;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public partial class RouterMiddleACRService : ServiceBase
    {
        private LogService _logService;
        private bool _isStopping = false; // 서비스 중지 상태를 나타내는 플래그
        private Process _managedProcess; // 서비스가 시작한 프로세스 관리

        public RouterMiddleACRService()
        {
            InitializeComponent();
            _logService = LogService.Instance;
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                _isStopping = false; // 서비스가 시작되면 중지 상태 초기화
                _logService.Start();
                StartManagedProcess(); // 예: 서비스가 시작할 프로세스
                _logService.LogMessage("RouterMiddleACRService started successfully.");
            }
            catch (Exception ex)
            {
                _logService.LogMessage($"Error during OnStart: {ex.Message}");
            }
        }

        protected override void OnStop()
        {
            if (_isStopping)
            {
                _logService.LogMessage("Service is already stopping. Ignoring additional stop request.");
                return;
            }

            try
            {
                _isStopping = true; // 중지 상태 설정

                // 먼저 관리하는 프로세스를 종료
                StopManagedProcess();

                // 로그 서비스 중지
                _logService.Stop();

                Task.Delay(5000).Wait(); // 필요한 경우 작업을 강제 종료하도록 딜레이 설정
                _logService.LogMessage("RouterMiddleACRService stopped successfully.");
            }
            catch (Exception ex)
            {
                _logService.LogMessage($"Error during OnStop: {ex.Message}");
            }
            finally
            {
                _isStopping = false; // 중지 완료 후 상태 초기화
            }
        }

        // 관리할 프로세스를 시작하는 메서드 (예시)
        private void StartManagedProcess()
        {
            try
            {
                _managedProcess = new Process
                {
                    StartInfo = new ProcessStartInfo
                    {
                        FileName = "YourProcess.exe", // 실행할 프로세스의 경로
                        Arguments = "", // 필요시 프로세스 인자
                        RedirectStandardOutput = true,
                        UseShellExecute = false,
                        CreateNoWindow = true
                    }
                };

                _managedProcess.Start();
                _logService.LogMessage("Managed process started.");
            }
            catch (Exception ex)
            {
                _logService.LogMessage($"Error starting managed process: {ex.Message}");
            }
        }

        // 관리 중인 프로세스를 종료하는 메서드
        private void StopManagedProcess()
        {
            try
            {
                if (_managedProcess != null && !_managedProcess.HasExited)
                {
                    _managedProcess.Kill();
                    _managedProcess.WaitForExit(5000); // 프로세스가 종료될 때까지 최대 5초 대기
                    _logService.LogMessage("Managed process stopped.");
                }
            }
            catch (Exception ex)
            {
                _logService.LogMessage($"Error stopping managed process: {ex.Message}");
            }
            finally
            {
                _managedProcess?.Dispose();
                _managedProcess = null;
            }
        }
    }
}
코드 설명
OnStop 메서드에서 프로세스 종료:

서비스가 중지될 때 StopManagedProcess 메서드를 호출하여 서비스가 시작한 모든 프로세스를 먼저 종료합니다. 그런 다음, 로그 서비스를 중지하고 필요한 리소스를 해제합니다.
StartManagedProcess 및 StopManagedProcess 메서드:

이 메서드들은 서비스가 시작할 프로세스를 관리하고, 서비스가 종료될 때 해당 프로세스를 안전하게 종료합니다.
중앙화된 로그 전달:

LogService.LogMessage를 사용하여 서비스의 모든 로그 메시지를 중앙화하여 관리하고, 클라이언트에 전달합니다.
이렇게 수정하면 서비스가 모든 프로세스를 안전하게 종료하고, 발생하는 모든 로그를 네임드 파이프를 통해 클라이언트로 전달할 수 있습니