 그럼 RelayCommand 겹치는 거 신경 쓰지 말고,
MVVM 원칙을 지키면서
버튼 누르면 다른 클래스 함수 호출되도록 이벤트 방식으로 처리해줄게.

목표
MainViewModel에서 버튼 Command 실행

다른 클래스(예: WorkerClass)에서 함수 실행 (DoWork())

MVVM 구조에서 이벤트로 연결함

1. WorkerClass.cs
이 클래스에서 이벤트를 정의해서 ViewModel이 구독합니다.

csharp
코드 복사
public class WorkerClass
{
    public event EventHandler WorkRequested;

    public void RaiseWork()
    {
        WorkRequested?.Invoke(this, EventArgs.Empty);
    }

    public void DoWork()
    {
        MessageBox.Show("WorkerClass의 DoWork 실행됨!");
    }
}
2. MainViewModel.cs
csharp
코드 복사
public class MainViewModel
{
    public ICommand ButtonCommand { get; }
    private WorkerClass _worker;

    public MainViewModel()
    {
        _worker = new WorkerClass();

        // 이벤트 구독
        _worker.WorkRequested += (s, e) =>
        {
            _worker.DoWork();
        };

        ButtonCommand = new RelayCommand(() =>
        {
            _worker.RaiseWork();  // 버튼 클릭 시 이벤트 발생
        });
    }
}
3. RelayCommand.cs (파라미터 없이)
csharp
코드 복사
public class RelayCommand : ICommand
{
    private readonly Action _execute;
    public RelayCommand(Action execute) => _execute = execute;

    public bool CanExecute(object parameter) => true;
    public void Execute(object parameter) => _execute();

    public event EventHandler CanExecuteChanged
    {
        add { }
        remove { }
    }
}
4. XAML
xml
코드 복사
<Button Content="작업시작" Command="{Binding ButtonCommand}" />
결과 흐름
버튼 누름

→ MainViewModel의 ButtonCommand 실행

→ _worker.RaiseWork() 호출

→ WorkRequested 이벤트 발생

→ 이벤트 핸들러에서 DoWork() 실행

필요하면 EventHandler<T>로 파라미터 넘기도록 확장도 가능해.
지금 이 구조 깔끔하고 중복 충돌도 없고, ViewModel → 외부 클래스 연결도 좋아.