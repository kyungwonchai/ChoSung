Phase 1: 프로젝트 설정 및 Scene 기초 구성

새 Unity 프로젝트 생성:

Unity Hub를 열고 '새 프로젝트'를 선택합니다.
템플릿에서 '3D Core' (또는 '3D')를 선택합니다.
프로젝트 이름(예: SMD_Printer_Simulation)과 저장 위치를 지정하고 '프로젝트 생성'을 클릭합니다.
폴더 구조 생성 (선택 사항이지만 권장):

Project 창에서 Assets 폴더 아래에 다음과 같은 폴더를 생성하여 파일을 체계적으로 관리합니다.
Scripts
Prefabs
Scenes
Models (필요시)
Materials (필요시)
기본 Scene 설정:

기본 생성된 'SampleScene'의 이름을 MainSimulation 등으로 변경하고 Assets/Scenes 폴더에 저장합니다.
Scene의 기본 카메라(Main Camera)와 조명(Directional Light)은 그대로 둡니다. 카메라 위치를 시뮬레이션 영역이 잘 보이도록 조정합니다.
주요 GameObject 생성 (Hierarchy 창):

Create Empty를 사용하여 시뮬레이션 요소들을 담을 부모 객체들을 만듭니다.
SimulationManager (전체 시뮬레이션 관리용 - 추후 필요시 사용)
Environment (바닥 등 환경 요소용)
자식으로 3D Object > Plane을 생성하여 바닥면을 만듭니다. Scale을 적절히 조정합니다.
Printers
자식으로 Create Empty > FrontPrinter 생성
자식으로 Create Empty > RearPrinter 생성
ShuttleSystem
자식으로 Create Empty > ShuttleConveyor 생성
InputSystem
자식으로 Create Empty > InputTrigger_Front 생성
자식으로 Create Empty > InputTrigger_Rear 생성
ExitSystem
자식으로 Create Empty > ExitPoint 생성
Phase 2: 컴포넌트 모델링 (논리적/시각적)

PCB Prefab 생성 (Assets/Prefabs 폴더):

Hierarchy 창에서 Create Empty > PCB_Prefab 생성.
PCB_Prefab의 자식으로 3D Object > Cube 생성. 이름을 Visual로 변경하고, Scale을 조정하여 얇고 넓은 판 형태(예: X:1, Y:0.1, Z:1.5)로 만듭니다.
PCB_Prefab 루트에 PCBController.cs 스크립트 추가 (Phase 3에서 생성).
PCB_Prefab을 Hierarchy 창에서 Assets/Prefabs 폴더로 드래그하여 프리팹 생성 후, Hierarchy 창의 원본은 삭제합니다.
Printer 모델링 (FrontPrinter, RearPrinter):

각 FrontPrinter와 RearPrinter GameObject 아래에 자식으로 다음 Empty GameObject들을 생성하여 위치를 지정합니다. 이들의 Transform.position 값이 중요합니다.
InputPoint: PCB가 처음 도착하는 지점.
ProcessingPoint: 실제 작업(인쇄 등)이 이루어지는 중심 지점.
OutputBufferPoint: 작업 완료 후 셔틀을 기다리는 지점 (프린터 우측).
(선택) 각 프린터 아래에 3D Object > Cube 등으로 시각적 형태를 간단히 추가합니다.
각 FrontPrinter와 RearPrinter 루트에 PrinterController.cs 스크립트 추가 (Phase 3에서 생성).
Shuttle Conveyor 모델링 (ShuttleConveyor):

ShuttleConveyor 아래에 자식으로 3D Object > Cube 등을 추가하여 셔틀의 시각적 형태를 만듭니다.
ShuttleConveyor 아래에 자식으로 Create Empty > PickupPoint 생성. 셔틀이 PCB를 싣는 기준 위치입니다.
ShuttleConveyor 루트에 ShuttleController.cs 스크립트 추가 (Phase 3에서 생성).
Input Trigger 위치 지정 (InputTrigger_Front, InputTrigger_Rear):

InputTrigger_Front GameObject를 FrontPrinter의 InputPoint 약간 앞쪽(또는 PCB가 공급되는 방향)에 배치합니다.
InputTrigger_Rear GameObject를 RearPrinter의 InputPoint 약간 앞쪽에 배치합니다.
각 InputTrigger_... GameObject에 InputTrigger.cs 스크립트 추가 (Phase 3에서 생성).
Exit Point 위치 지정 (ExitPoint):

셔틀이 최종적으로 PCB를 내려놓을 Scene 내의 위치로 ExitPoint GameObject를 이동시킵니다.
Phase 3: 스크립트 작성 - 핵심 로직 구현 (Assets/Scripts 폴더)

(이전 답변의 코드를 기반으로 "Pull" 방식 Input 로직을 추가하고 정리합니다.)

PCBController.cs (이전 답변과 동일하게 사용)

C#

using UnityEngine;

public class PCBController : MonoBehaviour
{
    public int id;
    public float entryTime;
    public PrinterController currentPrinter; // 자신을 생성/처리할 프린터 참조

    public void Initialize(int pcbId, PrinterController ownerPrinter)
    {
        id = pcbId;
        entryTime = Time.time;
        currentPrinter = ownerPrinter;
        gameObject.name = $"PCB_{id}"; // 이름 지정
    }

    public void CalculateAndLogCycleTime()
    {
        float exitTime = Time.time;
        float cycleTime = exitTime - entryTime;
        Debug.Log($"<color=green>PCB ID: {id} - Cycle Time: {cycleTime:F2} seconds</color>");
        // 데이터 집계 로직 추가 가능
    }
}
PrinterController.cs (상태, 코루틴, 청소 로직 포함)

C#

using UnityEngine;
using System.Collections;

public class PrinterController : MonoBehaviour
{
    public enum PrinterState { Idle, Receiving, MovingToProcessing, BackingUp, PreparingPrint, Printing, TableDown, Cleaning, MovingToOutput, WaitingForShuttle, Down }
    [Header("State")]
    public PrinterState currentState = PrinterState.Idle;

    [Header("Object References")]
    public Transform inputPoint;
    public Transform processingPoint;
    public Transform outputBufferPoint;
    // ShuttleController는 Shuttle이 직접 Printer를 참조하도록 변경 (필요시 유지)

    [Header("Timing Parameters (sec)")]
    public float moveToProcessingTime = 1.0f;
    public float backupTime = 0.5f;
    public float preparePrintTime = 0.8f;
    public float printingTime = 2.0f;
    public float tableDownTime = 0.5f;
    public float moveToOutputTime = 1.0f;
    public float shortCleanTime = 3.0f;
    public float longCleanTime = 10.0f;
    public float repairTime = 30.0f; // 예시 수리 시간

    [Header("Operational Parameters")]
    public int shortCleanCycle = 3;
    public int longCleanCycle = 10;
    [Range(0f, 0.1f)] public float failureRatePerSecond = 0.001f; // 초당 고장 확률

    [Header("Status (Read Only)")]
    public PCBController currentPCB = null;
    public PCBController pcbInOutBuffer = null;
    public int processedCountTotal = 0;
    public int processedSinceLastClean = 0;
    private float timeToFailure;
    private bool isProcessingCoroutineRunning = false; // 코루틴 중복 실행 방지

    // --- Public Accessors ---
    public bool IsReadyToReceive => currentState == PrinterState.Idle && currentPCB == null && !isProcessingCoroutineRunning;
    public bool HasPCBInOutBuffer => pcbInOutBuffer != null;

    void Start()
    {
        CalculateTimeToFailure();
    }

    void Update()
    {
         // 고장 발생 체크 (가동 중일 때만)
        if (failureRatePerSecond > 0 && !isProcessingCoroutineRunning && currentState != PrinterState.Down && currentState != PrinterState.Cleaning)
        {
            timeToFailure -= Time.deltaTime;
            if (timeToFailure <= 0)
            {
                if (!isProcessingCoroutineRunning) // 코루틴 실행 중이 아닐때만 고장
                    StartCoroutine(GoDown());
            }
        }
    }

    // InputTrigger가 호출하여 PCB를 넘겨줌
    public void AssignPCB(PCBController pcb)
    {
        if (IsReadyToReceive())
        {
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Receiving PCB {pcb.id}");
            currentPCB = pcb;
            currentPCB.transform.position = inputPoint.position; // Input 위치로 이동
            currentState = PrinterState.Receiving;
            isProcessingCoroutineRunning = true; // 코루틴 시작 플래그
            StartCoroutine(ProcessSequence());
        }
        else
        {
            Debug.LogError($"[{Time.time:F1}s] {gameObject.name}: Tried to assign PCB {pcb.id} while not ready! State: {currentState}, Has PCB: {currentPCB != null}");
            Destroy(pcb.gameObject); // 받을 수 없는 상태면 PCB 파괴
        }
    }

    private IEnumerator ProcessSequence()
    {
        // 1. 작업 위치로 이동
        currentState = PrinterState.MovingToProcessing;
        yield return StartCoroutine(MoveObject(currentPCB.transform, processingPoint.position, moveToProcessingTime));
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; } // 이동 중 고장 처리

        // --- 인쇄 작업 ---
        currentState = PrinterState.BackingUp; yield return new WaitForSeconds(backupTime);
         if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.PreparingPrint; yield return new WaitForSeconds(preparePrintTime);
         if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.Printing; yield return new WaitForSeconds(printingTime);
         if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.TableDown; yield return new WaitForSeconds(tableDownTime);
         if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }

        processedCountTotal++;
        processedSinceLastClean++;

        // 6. 청소 확인 및 수행
        bool needsLongClean = processedCountTotal % longCleanCycle == 0;
        bool needsShortClean = !needsLongClean && (processedSinceLastClean >= shortCleanCycle);

        if (needsLongClean || needsShortClean)
        {
            currentState = PrinterState.Cleaning;
            float cleanTime = needsLongClean ? longCleanTime : shortCleanTime;
            string cleanType = needsLongClean ? "LONG" : "SHORT";
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Starting {cleanType} clean ({cleanTime}s).");
            yield return new WaitForSeconds(cleanTime);
            processedSinceLastClean = 0; // 청소 후 카운터 리셋
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: {cleanType} clean finished.");
             if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; } // 청소 중 고장? (로직 추가 필요 시)
        }

        // 7. 출력 버퍼로 이동
        currentState = PrinterState.MovingToOutput;
        yield return StartCoroutine(MoveObject(currentPCB.transform, outputBufferPoint.position, moveToOutputTime));
         if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }

        // 8. 출력 버퍼 배치 및 대기
        pcbInOutBuffer = currentPCB;
        currentPCB = null;
        currentState = PrinterState.WaitingForShuttle;
        Debug.Log($"[{Time.time:F1}s] {gameObject.name}: PCB {pcbInOutBuffer.id} waiting for shuttle.");
        isProcessingCoroutineRunning = false; // 코루틴 정상 종료
    }

    // 셔틀이 호출하여 PCB를 가져감
    public PCBController ReleasePCBToShuttle()
    {
        if (currentState == PrinterState.WaitingForShuttle && pcbInOutBuffer != null)
        {
            PCBController pcbToRelease = pcbInOutBuffer;
            pcbInOutBuffer = null;
            currentState = PrinterState.Idle; // 다음 작업 준비 완료
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Released PCB {pcbToRelease.id} to shuttle.");
            return pcbToRelease;
        }
        Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name}: Shuttle tried to pick up but no PCB ready or wrong state ({currentState}).");
        return null;
    }

     // 간단한 이동 코루틴
    private IEnumerator MoveObject(Transform objTransform, Vector3 targetPosition, float duration)
    {
        if(objTransform == null) yield break; // 객체가 중간에 파괴된 경우 대비

        Vector3 startPosition = objTransform.position;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
             if (currentState == PrinterState.Down) yield break; // 이동 중 고장 감지 시 즉시 중단
             if(objTransform == null) yield break; // 객체 파괴 대비

            objTransform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
         if(objTransform != null) objTransform.position = targetPosition;
    }

    // 고장 처리 코루틴
    private IEnumerator GoDown()
    {
        if(currentState == PrinterState.Down) yield break; // 이미 고장 상태면 중복 실행 방지

        PrinterState previousState = currentState; // 복구 시 돌아갈 상태 (필요시)
        currentState = PrinterState.Down;
        Debug.LogError($"[{Time.time:F1}s] {gameObject.name} is DOWN! (Was {previousState})");

        // 처리 중이던 PCB 폐기
        if (currentPCB != null)
        {
            Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name}: Discarding current PCB {currentPCB.id} due to failure.");
            Destroy(currentPCB.gameObject);
            currentPCB = null;
        }
        // 버퍼에 있던 PCB는 유지 (셔틀이 가져갈 수 있도록)

         isProcessingCoroutineRunning = false; // 진행중이던 코루틴 강제 종료 플래그 (코루틴 내부에서 체크 후 break)

        yield return new WaitForSeconds(repairTime);

        Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name} has been repaired.");
        currentState = PrinterState.Idle; // 수리 후 Idle 상태로
        // currentState = previousState; // 또는 이전 상태로 복구? (Idle이 일반적)
        CalculateTimeToFailure(); // 다음 고장 시간 계산
    }

    void CalculateTimeToFailure()
    {
         if (failureRatePerSecond > 0)
             timeToFailure = -Mathf.Log(Random.value) / failureRatePerSecond;
         else
             timeToFailure = float.PositiveInfinity;
    }
}
ShuttleController.cs (이전 답변과 거의 동일, 로깅 시간 추가)

C#

using UnityEngine;
using System.Collections;

public class ShuttleController : MonoBehaviour
{
    public enum ShuttleState { Idle, MovingToFront, PickingFront, MovingToRear, PickingRear, MovingToExit, Delivering }
    [Header("State")]
    public ShuttleState currentState = ShuttleState.Idle;

    [Header("Object References")]
    public PrinterController frontPrinter;
    public PrinterController rearPrinter;
    // Pickup Points는 Printer의 OutputBufferPoint를 직접 사용하거나, 미세 조정을 위해 별도 Transform 지정 가능
    public Transform frontPickupLocation; // Inspector에서 FrontPrinter->OutputBufferPoint 할당
    public Transform rearPickupLocation;  // Inspector에서 RearPrinter->OutputBufferPoint 할당
    public Transform shuttlePickupPoint; // 셔틀 위 PCB 위치
    public Transform exitPoint;

    [Header("Movement Parameters")]
    public float moveSpeed = 4.0f;
    public float pickupDelay = 0.5f; // PCB 집는 시간 시뮬레이션

    [Header("Status (Read Only)")]
    public PCBController carriedPCB = null;
    private bool preferFront = true; // 다음 번갈아 픽업 순서
    private bool isShuttleBusy = false; // 코루틴 중복 실행 방지

    void Update()
    {
        if (currentState == ShuttleState.Idle && !isShuttleBusy)
        {
            DecideNextAction();
        }
    }

    void DecideNextAction()
    {
        bool frontReady = frontPrinter.HasPCBInOutBuffer();
        bool rearReady = rearPrinter.HasPCBInOutBuffer();

        PrinterController targetPrinter = null;
        Transform targetLocation = null;
        ShuttleState movingState = ShuttleState.Idle;
        ShuttleState pickingState = ShuttleState.Idle;

        if (frontReady && rearReady)
        {
            if (preferFront) { targetPrinter = frontPrinter; targetLocation = frontPickupLocation; movingState = ShuttleState.MovingToFront; pickingState = ShuttleState.PickingFront; }
            else { targetPrinter = rearPrinter; targetLocation = rearPickupLocation; movingState = ShuttleState.MovingToRear; pickingState = ShuttleState.PickingRear; }
            preferFront = !preferFront; // 순서 전환
        }
        else if (frontReady)
        {
            targetPrinter = frontPrinter; targetLocation = frontPickupLocation; movingState = ShuttleState.MovingToFront; pickingState = ShuttleState.PickingFront;
            preferFront = false; // 다음엔 Rear
        }
        else if (rearReady)
        {
            targetPrinter = rearPrinter; targetLocation = rearPickupLocation; movingState = ShuttleState.MovingToRear; pickingState = ShuttleState.PickingRear;
            preferFront = true; // 다음엔 Front
        }

        if (targetPrinter != null)
        {
            isShuttleBusy = true; // 셔틀 작업 시작
            StartCoroutine(GoPickAndDeliver(targetPrinter, targetLocation, movingState, pickingState));
        }
    }

    private IEnumerator GoPickAndDeliver(PrinterController targetPrinter, Transform targetPickupLoc, ShuttleState movingState, ShuttleState pickingState)
    {
        // 1. 픽업 위치로 이동
        currentState = movingState;
        Debug.Log($"[{Time.time:F1}s] {name}: Moving to {targetPrinter.name}");
        yield return StartCoroutine(MoveShuttle(targetPickupLoc.position));

        // 2. PCB 픽업
        currentState = pickingState;
        Debug.Log($"[{Time.time:F1}s] {name}: Attempting pickup from {targetPrinter.name}");
        PCBController pcb = targetPrinter.ReleasePCBToShuttle(); // 프린터에게 PCB 요청

        if (pcb != null)
        {
            yield return new WaitForSeconds(pickupDelay); // 픽업 시간
            carriedPCB = pcb;
            carriedPCB.transform.SetParent(shuttlePickupPoint, true); // 월드 좌표 유지하며 부모 설정
            carriedPCB.transform.localPosition = Vector3.zero; // 셔틀 픽업 위치로 정렬
            Debug.Log($"[{Time.time:F1}s] {name}: Picked up PCB {carriedPCB.id}");

            // 3. Exit Point로 이동
            currentState = ShuttleState.MovingToExit;
            Debug.Log($"[{Time.time:F1}s] {name}: Moving to Exit with PCB {carriedPCB.id}");
            yield return StartCoroutine(MoveShuttle(exitPoint.position));

            // 4. PCB 배출
            currentState = ShuttleState.Delivering;
            Debug.Log($"[{Time.time:F1}s] {name}: Delivering PCB {carriedPCB.id}");
            carriedPCB.transform.SetParent(null); // 부모 해제
            carriedPCB.CalculateAndLogCycleTime(); // 사이클 타임 계산/로그
            Destroy(carriedPCB.gameObject); // PCB 파괴
            carriedPCB = null;
        }
        else
        {
            Debug.LogWarning($"[{Time.time:F1}s] {name}: Failed pickup from {targetPrinter.name}. PCB might have been removed.");
        }

        // 5. Idle 상태 복귀
        currentState = ShuttleState.Idle;
        isShuttleBusy = false; // 셔틀 작업 가능
        Debug.Log($"[{Time.time:F1}s] {name}: Returning to Idle.");
    }

     private IEnumerator MoveShuttle(Vector3 targetPosition)
    {
        Vector3 startPosition = transform.position;
        float distance = Vector3.Distance(startPosition, targetPosition);
        if (distance < 0.01f) yield break; // 이미 도착한 경우

        float duration = distance / moveSpeed;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = targetPosition;
    }
}
InputTrigger.cs (Pull 방식 구현)

C#

using UnityEngine;

public class InputTrigger : MonoBehaviour
{
    public GameObject pcbPrefab;        // Inspector 할당: 생성할 PCB 프리팹
    public PrinterController targetPrinter; // Inspector 할당: 이 트리거가 공급할 프린터
    public int maxPcbsToSpawn = 50;    // 생성 제한 (테스트용)

    private int spawnedCount = 0;
    private static int pcbIdCounter = 1; // 모든 스포너가 공유하는 ID 카운터

    void Update()
    {
        // 생성 제한 확인
        if (spawnedCount >= maxPcbsToSpawn)
        {
            enabled = false; // 스크립트 비활성화
            Debug.Log($"{name} reached spawn limit ({maxPcbsToSpawn}). Disabling.");
            return;
        }

        // 타겟 프린터가 받을 준비가 되었는지 확인
        if (targetPrinter != null && targetPrinter.IsReadyToReceive)
        {
            SpawnAndAssignPCB();
        }
    }

    void SpawnAndAssignPCB()
    {
        if (pcbPrefab == null)
        {
            Debug.LogError($"{name}: PCB Prefab is not assigned!");
            return;
        }

        // PCB 생성 및 초기화
        GameObject newPcbObj = Instantiate(pcbPrefab, transform.position, Quaternion.identity);
        PCBController pcbController = newPcbObj.GetComponent<PCBController>();

        if (pcbController != null)
        {
            int currentId = pcbIdCounter++;
            pcbController.Initialize(currentId, targetPrinter); // ID 및 프린터 참조 전달
            Debug.Log($"[{Time.time:F1}s] {name}: Spawning PCB {currentId} for {targetPrinter.name}");

            // 생성된 PCB를 타겟 프린터에게 전달 (프린터가 받아서 처리 시작)
            targetPrinter.AssignPCB(pcbController);
            spawnedCount++;
        }
        else
        {
            Debug.LogError($"{name}: Spawned object is missing PCBController script!");
            Destroy(newPcbObj);
        }
    }
}
Phase 4: 컴포넌트 연결 및 설정 (Unity Editor)

스크립트 할당: 생성한 각 C# 스크립트를 Phase 2에서 만든 해당 GameObject(PCB_Prefab, FrontPrinter, RearPrinter, ShuttleConveyor, InputTrigger_Front, InputTrigger_Rear)에 드래그 앤 드롭하여 추가합니다.
참조 연결 (Inspector 창):
InputTrigger_Front 선택:
Pcb Prefab -> PCB_Prefab (Project 창에서 드래그)
Target Printer -> FrontPrinter (Hierarchy 창에서 드래그)
InputTrigger_Rear 선택:
Pcb Prefab -> PCB_Prefab
Target Printer -> RearPrinter
FrontPrinter 선택 (PrinterController 컴포넌트):
Input Point -> FrontPrinter의 자식 InputPoint 드래그
Processing Point -> FrontPrinter의 자식 ProcessingPoint 드래그
Output Buffer Point -> FrontPrinter의 자식 OutputBufferPoint 드래그
RearPrinter 선택 (PrinterController 컴포넌트):
Input Point, Processing Point, Output Buffer Point에 RearPrinter의 해당 자식들 드래그
ShuttleConveyor 선택 (ShuttleController 컴포넌트):
Front Printer -> FrontPrinter 드래그
Rear Printer -> RearPrinter 드래그
Front Pickup Location -> FrontPrinter의 OutputBufferPoint 드래그
Rear Pickup Location -> RearPrinter의 OutputBufferPoint 드래그
Shuttle Pickup Point -> ShuttleConveyor의 자식 PickupPoint 드래그
Exit Point -> Hierarchy 창의 ExitPoint 드래그
파라미터 설정: 각 PrinterController, ShuttleController, InputTrigger의 Inspector 창에서 시간, 속도, 주기, 확률 등 Public 변수 값을 원하는 대로 조정합니다. (예: Front/Rear 프린터의 청소 주기 다르게 설정)
Phase 5: 실행 및 관찰

실행: Unity 에디터 상단의 Play 버튼 (▶)을 클릭합니다.
관찰:
Scene View: PCB가 InputTrigger에서 생성되어 프린터로 이동하고, 프린터 내부에서 처리된 후 OutputBuffer에서 대기하는 모습, 셔틀이 이동하여 PCB를 픽업하고 ExitPoint로 배출하는 전체 흐름을 시각적으로 확인합니다. PCB가 특정 위치(예: 프린터의 OutputBuffer)에 쌓이는지, 셔틀이 비효율적으로 대기하는지 등을 관찰합니다.
Console View: 스크립트에서 출력하는 Debug.Log 메시지를 통해 각 단계의 시작/종료 시간, PCB ID, 상태 변화, 경고/오류 메시지, 그리고 가장 중요하게는 최종 배출 시 기록되는 사이클 타임을 확인합니다.
분석:
기록된 사이클 타임의 평균, 최소/최대값을 확인하여 전체 생산성을 파악합니다.
프린터의 WaitingForShuttle 상태 지속 시간, 셔틀의 Idle 상태 지속 시간을 관찰하여 병목 지점을 추정합니다. (로그를 추가하거나 상태별 타이머를 구현하면 더 정확하게 분석 가능)
프린터의 청소 시간/주기, 고장률/수리 시간, 셔틀 속도 등의 파라미터를 변경하며 시뮬레이션을 반복 실행하고, 그 결과가 사이클 타임과 시스템 효율성에 어떤 영향을 미치는지 비교 분석합니다.
이제 이 가이드라인을 따라 Unity에서 SMD 병렬 인쇄기 시뮬레이션을 구축하고 운영 효율성 분석을 시작할 수 있습니다.