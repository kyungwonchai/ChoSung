이제 요구사항을 완전히 이해했습니다. 각 작업에 대해 여러 개의 함수가 순서대로 실행되고, 각 함수는 동그라미 도형으로 표시됩니다. 각 행의 작업이 순서대로 진행되며, 다음 행은 큐에만 쌓이고 실행되지 않아야 합니다. 또한, 마우스 오버 시 함수 이름이 표시되고, 함수가 실행될 때 색상이 변경되도록 해야 합니다.

요구사항 요약:
각 행에 함수 개수만큼의 도형이 가로로 나열되어 있어야 합니다.
마우스를 도형에 올리면 해당 함수 이름이 표시됩니다.
각 함수는 순차적으로 실행되고, 함수 상태에 따라 색상이 변경됩니다:
대기 중: 회색
실행 중: 스카이블루
완료: 녹색
에러: 빨간색
작업은 행 단위로 처리되며, 한 행의 모든 함수가 완료되기 전까지는 다음 행의 작업이 실행되지 않습니다.
TaskModel.cs (도형을 통해 각 함수의 상태를 시각적으로 표시)
Models/TaskModel.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public List<string> Functions { get; set; }  // 각 작업에서 실행할 함수 이름 리스트
    public List<string> FunctionStatuses { get; set; } // 각 함수의 상태 (대기 중, 실행 중, 완료 등)

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsPaused { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        // 작업마다 3개의 함수를 실행하는 예시
        Functions = new List<string> { "FunctionA", "FunctionB", "FunctionC" };
        FunctionStatuses = new List<string> { "Waiting", "Waiting", "Waiting" };

        StartCommand = new RelayCommand(StartTask);
        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsRunning));

        // 각 함수를 순차적으로 실행하며 상태를 업데이트
        for (int i = 0; i < Functions.Count; i++)
        {
            FunctionStatuses[i] = "Running";
            OnPropertyChanged(nameof(FunctionStatuses)); // 상태 업데이트
            var success = await _taskQueue.ExecuteSpecificTask(UpdateTaskStatus, i); // 함수 실행

            FunctionStatuses[i] = success ? "Completed" : "Error";
            OnPropertyChanged(nameof(FunctionStatuses));

            if (!success)
            {
                Status = "Error";
                IsError = true;
                break;
            }
        }

        Status = IsError ? "Error" : "Completed";
        IsCompleted = !IsError;
        IsRunning = false;

        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCompleted));
        OnPropertyChanged(nameof(IsError));
        OnPropertyChanged(nameof(IsRunning));
    }

    private void PauseTask()
    {
        _taskQueue.PauseAllTasks();
        Status = "Paused";
        IsPaused = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsPaused));
    }

    private void ResumeTask()
    {
        _taskQueue.ResumeAllTasks();
        Status = "Running";
        IsPaused = false;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsPaused));
    }

    /// <summary>
    /// TaskQueue의 상태를 실시간으로 업데이트하는 메서드
    /// </summary>
    private async Task UpdateTaskStatus(string message)
    {
        Status = message;
        OnPropertyChanged(nameof(Status));
        await Task.CompletedTask;
    }
}
TaskQueue.cs (순차적 작업 실행 및 함수 상태 업데이트)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Func<string, Task>, Task<bool>>> _tasks; // 작업 리스트 (상태 업데이트)
    private CancellationTokenSource _cancellationTokenSource;
    private PlcCommunication _plcCommunication; // PLC 통신 인스턴스
    private bool _isPaused = false; // 일시정지 상태를 관리하는 필드

    public TaskQueue(PlcCommunication plcCommunication)
    {
        _tasks = new List<Func<Func<string, Task>, Task<bool>>>(); // 작업 초기화
        _cancellationTokenSource = new CancellationTokenSource(); // 취소 토큰 생성
        _plcCommunication = plcCommunication;
        AddDefaultTasks(); // 기본 작업 추가
    }

    // 기본 작업을 추가하는 메서드 (여러 작업을 큐에 추가)
    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    // 작업 큐를 순차적으로 실행하는 메서드
    public async Task<bool> ExecuteTaskQueue(Func<string, Task> updateStatus)
    {
        foreach (var task in _tasks)
        {
            if (_cancellationTokenSource.Token.IsCancellationRequested)
                return false;

            // 작업 일시정지 상태일 경우 대기
            while (_isPaused)
            {
                await Task.Delay(500); // 500ms마다 일시정지 상태를 체크
            }

            var success = await task(updateStatus);
            if (!success) return false;
        }
        return true;
    }

    // 특정 함수만 실행하는 메서드
    public async Task<bool> ExecuteSpecificTask(Func<string, Task> updateStatus, int taskIndex)
    {
        if (taskIndex < 0 || taskIndex >= _tasks.Count)
        {
            return false; // 잘못된 작업 인덱스일 경우
        }

        var success = await _tasks[taskIndex](updateStatus);
        return success;
    }

    // 작업 일시정지 상태로 설정하는 메서드
    public void PauseAllTasks()
    {
        _isPaused = true;
    }

    // 작업을 다시 실행 상태로 변경하는 메서드
    public void ResumeAllTasks()
    {
        _isPaused = false;
    }

    // COM 포트 1과 2를 통해 데이터를 전송하며 순차적으로 처리
    private async Task<bool> TaskA(Func<string, Task> updateStatus)
    {
        await updateStatus("Task A: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task A");
        
        await updateStatus("Task A: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task A");

        await updateStatus("Task A completed.");
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB(Func<string, Task> updateStatus)
    {
        await updateStatus("Task B: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task B");
        
        await updateStatus("Task B: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task B");

        await updateStatus("Task B completed.");
        return true;
    }

    private async Task<bool> TaskC(Func<string, Task> updateStatus)
    {
        await updateStatus("Task C: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task C");
        
        await updateStatus("Task C: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task C");

        await updateStatus("Task C completed.");
        return true;
    }
}
MainWindow.xaml (각 함수별 도형을 가로로 배치)
Views/MainWindow.xaml

xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />

                <!-- 각 작업의 함수 진행 상태를 도형으로 표시하는 열 -->
                <DataGridTemplateColumn Header="Functions Status" Width="*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionStatuses}" Orientation="Horizontal">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Stroke="Black" StrokeThickness="1">
                                            <Ellipse.ToolTip>
                                                <TextBlock Text="{Binding DataContext.Functions[DataContext.FunctionStatuses.IndexOf(.)], RelativeSource={RelativeSource AncestorType=ItemsControl}}"/>
                                            </Ellipse.ToolTip>
                                            <Ellipse.Style>
                                                <Style TargetType="Ellipse">
                                                    <Style.Triggers>
                                                        <!-- 대기 중인 함수는 회색 -->
                                                        <DataTrigger Binding="{Binding}" Value="Waiting">
                                                            <Setter Property="Fill" Value="Gray"/>
                                                        </DataTrigger>
                                                        <!-- 실행 중인 함수는 스카이블루 -->
                                                        <DataTrigger Binding="{Binding}" Value="Running">
                                                            <Setter Property="Fill" Value="SkyBlue"/>
                                                        </DataTrigger>
                                                        <!-- 완료된 함수는 녹색 -->
                                                        <DataTrigger Binding="{Binding}" Value="Completed">
                                                            <Setter Property="Fill" Value="LightGreen"/>
                                                        </DataTrigger>
                                                        <!-- 에러가 발생한 함수는 빨간색 -->
                                                        <DataTrigger Binding="{Binding}" Value="Error">
                                                            <Setter Property="Fill" Value="Red"/>
                                                        </DataTrigger>
                                                    </Style.Triggers>
                                                </Style>
                                            </Ellipse.Style>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>

        <!-- 일시정지 및 다시 시작 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="120,0,0,10"/>
    </Grid>
</Window>
설명:
TaskModel.cs: 각 작업에 세 개의 함수를 실행하는 예시로, 각 함수의 상태를 저장하고 실시간으로 업데이트합니다. 순차적으로 함수가 실행되고, 각 함수의 상태는 FunctionStatuses 리스트에서 관리됩니다.
TaskQueue.cs: 각 함수는 순차적으로 실행되며, 함수 실행 중에는 다른 함수나 작업이 실행되지 않습니다. 작업이 완료되면 그 다음 행이 처리됩니다.
MainWindow.xaml: 함수의 상태를 도형으로 시각화하여, 각 함수가 실행 중, 완료, 대기, 에러 상태를 시각적으로 표시합니다. 마우스를 도형에 올리면 해당 함수의 이름이 표시됩니다.
이제 이 코드는 각 작업의 함수들이 순차적으로 실행되며, 상태에 따라 도형 색상이 변경되고, 다음 작업은 큐에만 쌓이고 실행되지