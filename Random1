에서 앱이 켜져 있는 동안 화면이 꺼지지 않도록 설정하려면 Wake Lock을 사용해야 합니다. Wake Lock은 화면이 일정 시간 동안 켜져 있도록 유지할 수 있는 기능입니다. MainActivity에서 Wake Lock을 설정하여 앱이 활성화되어 있는 동안 화면이 꺼지지 않게 하는 방법을 보여드리겠습니다.

MainActivity.kt 수정
kotlin
코드 복사
package com.dxmxsmd.routeracralarm

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.media.AudioAttributes
import android.media.MediaPlayer
import android.media.RingtoneManager
import android.net.Uri
import android.os.Build
import android.os.Bundle
import android.os.PowerManager
import android.util.Log
import android.widget.Button
import android.widget.CheckBox
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.lifecycle.lifecycleScope
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity() {

    private lateinit var hubConnection: HubConnection
    private lateinit var notificationManager: NotificationManager
    private lateinit var vibrationCheckBox: CheckBox
    private lateinit var viewMessagesButton: Button
    private var wakeLock: PowerManager.WakeLock? = null

    // 런타임 권한 요청을 위한 launcher 정의
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            Log.d("Permission", "Notification permission granted")
        } else {
            Log.d("Permission", "Notification permission denied")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 진동 체크박스 초기화
        vibrationCheckBox = findViewById(R.id.vibrationCheckBox)

        // 최근 메시지 보기 버튼 초기화 및 클릭 리스너 설정
        viewMessagesButton = findViewById(R.id.viewMessagesButton)
        viewMessagesButton.setOnClickListener {
            openOrReplaceDataActivity() // DataActivity 열기 또는 교체
        }

        // 알림 채널 생성
        createNotificationChannel()

        // Android 13 이상에서 알림 권한 요청
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requestNotificationPermission()
        }

        // Wake Lock 설정
        acquireWakeLock()

        // SignalR 서버 연결 설정
        hubConnection = HubConnectionBuilder.create("https://your-signalr-server-address")
            .build()

        // SignalR 메시지 수신 대기
        hubConnection.on("ReceiveMessage", { message: String ->
            showNotification(message) // 메시지 수신 시 알림
            openOrReplaceDataActivity() // DataActivity 열기 또는 기존 액티비티 교체

            // 메시지에 "err1"이 포함되어 있으면 소리 재생
            if (message.contains("err1", ignoreCase = true)) {
                playAlarmSound()
            }
        }, String::class.java)

        lifecycleScope.launch {
            try {
                hubConnection.start().blockingAwait()
                Log.d("SignalR", "Connected to SignalR server.")
            } catch (e: Exception) {
                Log.e("SignalR", "SignalR connection failed", e)
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        releaseWakeLock() // 액티비티가 파괴될 때 Wake Lock 해제
    }

    private fun acquireWakeLock() {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        wakeLock = powerManager.newWakeLock(
            PowerManager.SCREEN_DIM_WAKE_LOCK or PowerManager.ACQUIRE_CAUSES_WAKEUP,
            "RouterACRAlarm::WakeLock"
        )
        wakeLock?.acquire()
    }

    private fun releaseWakeLock() {
        wakeLock?.let {
            if (it.isHeld) {
                it.release()
            }
        }
    }

    private fun showNotification(message: String) {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent: PendingIntent =
            PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)

        val builder = NotificationCompat.Builder(this, "SIGNALR_CHANNEL")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("New SignalR Message")
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)

        if (vibrationCheckBox.isChecked) {
            builder.setVibrate(longArrayOf(0, 500, 1000))
        }

        notificationManager.notify(1, builder.build())
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "SignalR Channel"
            val descriptionText = "Channel for SignalR notifications"
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel("SIGNALR_CHANNEL", name, importance).apply {
                description = descriptionText
            }
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        } else {
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        }
    }

    private fun requestNotificationPermission() {
        when {
            ActivityCompat.checkSelfPermission(
                this, Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED -> {
                Log.d("Permission", "Notification permission already granted")
            }
            else -> {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }

    private fun openOrReplaceDataActivity() {
        val intent = Intent(this, DataActivity::class.java)
        intent.flags = Intent.FLAG_ACTIVITY_CLEAR_TOP or Intent.FLAG_ACTIVITY_NEW_TASK
        startActivity(intent)
    }

    private fun playAlarmSound() {
        try {
            val alarmSound: Uri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM)
                ?: RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)
            
            val mediaPlayer = MediaPlayer().apply {
                setAudioAttributes(
                    AudioAttributes.Builder()
                        .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                        .setUsage(AudioAttributes.USAGE_ALARM)
                        .build()
                )
                setDataSource(this@MainActivity, alarmSound)
                prepare()
                start()
            }
        } catch (e: Exception) {
            Log.e("MainActivity", "Failed to play alarm sound", e)
        }
    }
}
변경 사항 및 설명
Wake Lock 설정:

acquireWakeLock 메서드를 통해 WakeLock을 획득하여, 앱이 켜져 있는 동안 화면이 꺼지지 않도록 설정했습니다.
PowerManager.SCREEN_DIM_WAKE_LOCK과 PowerManager.ACQUIRE_CAUSES_WAKEUP 플래그를 사용하여 화면이 어두워지지 않고 켜진 상태를 유지하게 합니다.
Wake Lock 해제:

releaseWakeLock 메서드를 통해 액티비티가 종료될 때 WakeLock을 해제하도록 합니다. 이를 통해 리소스 누수나 불필요한 화면 켜짐을 방지합니다.
onDestroy 메서드:
