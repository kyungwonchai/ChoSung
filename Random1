네, 알겠습니다. 기존에 등록된 유사한 작업을 삭제하고, 최근 3시간보다 오래된 데이터를 주기적으로 삭제하는 새 MySQL 이벤트를 등록하는 방법을 안내해 드릴게요.

📜 1단계: 기존 작업(이벤트) 확인 및 삭제
먼저, 삭제하려는 기존 작업(이벤트)의 정확한 이름을 알아야 합니다.

1.1. 등록된 이벤트 목록 확인:
다음 쿼리를 실행하여 현재 등록된 모든 이벤트 목록과 그 이름을 확인하세요.

SQL

SHOW EVENTS;
또는

SQL

SELECT EVENT_SCHEMA, EVENT_NAME, STATUS FROM INFORMATION_SCHEMA.EVENTS;
이 목록에서 삭제하고자 하는 이벤트의 이름을 찾으세요.

1.2. 특정 이벤트 삭제:
삭제할 이벤트의 이름을 찾았다면, 다음 명령어로 해당 이벤트를 삭제합니다. 삭제할_이벤트_이름 부분에 실제 이벤트 이름을 넣어주세요.

SQL

DROP EVENT IF EXISTS 삭제할_이벤트_이름;
예를 들어, 이전에 delete_old_data_periodically라는 이름의 이벤트를 만들었다면 다음과 같이 삭제합니다:

SQL

DROP EVENT IF EXISTS delete_old_data_periodically;
IF EXISTS를 사용하면 해당 이름의 이벤트가 없을 경우 오류 없이 넘어갑니다.

🚀 2단계: 새 작업(이벤트) 등록 - 3시간 이전 데이터 삭제
이제 3시간보다 오래된 데이터를 주기적으로 삭제하는 새 이벤트를 생성합니다.

2.1. Event Scheduler 활성화 확인 (다시 한번 확인)
이벤트 스케줄러가 실행 중인지 확인합니다.

SQL

SHOW VARIABLES LIKE 'event_scheduler';
Value가 ON이어야 합니다. OFF라면 다음 명령어로 활성화하세요 (DB 관리자 권한 필요).

SQL

SET GLOBAL event_scheduler = ON;
MySQL 서버 재시작 후에도 계속 활성화하려면 설정 파일(my.cnf 또는 my.ini)에 event_scheduler=ON을 추가해야 합니다.

2.2. 새 이벤트 생성 쿼리
다음은 매시간 실행되며, your_date_column 기준으로 3시간 이전의 데이터를 your_table_name에서 삭제하는 이벤트입니다.

SQL

CREATE EVENT delete_data_older_than_3_hours
ON SCHEDULE EVERY 1 HOUR  -- 🎈 매 시간마다 실행 (예: 'EVERY 30 MINUTE' 등으로 조절 가능)
STARTS CURRENT_TIMESTAMP + INTERVAL 5 MINUTE -- ⏰ 지금으로부터 5분 뒤에 첫 실행 시작
DO
  DELETE FROM your_table_name  -- 📝 실제 테이블 이름으로 변경하세요
  WHERE your_date_column < DATE_SUB(NOW(), INTERVAL 3 HOUR) -- ⏳ 3시간 이전 데이터 대상
  LIMIT 10000; -- 🛡️ 한 번의 실행으로 삭제할 최대 행 수 (타임아웃 방지를 위해 적절히 조절)
쿼리 설명 및 주의사항:

your_table_name: 실제 데이터를 삭제할 테이블 이름으로 변경해주세요.
your_date_column: 날짜/시간 데이터가 저장된 실제 컬럼 이름으로 변경해주세요. 이 컬럼의 데이터 타입은 DATETIME 또는 TIMESTAMP여야 DATE_SUB(NOW(), INTERVAL 3 HOUR)와 정확히 비교됩니다.
EVERY 1 HOUR: 이벤트 실행 주기입니다. 필요에 따라 EVERY 30 MINUTE, EVERY 6 HOUR 등으로 변경할 수 있습니다.
STARTS CURRENT_TIMESTAMP + INTERVAL 5 MINUTE: 이벤트가 처음 시작될 시간입니다. 바로 시작하거나 특정 시간을 지정할 수도 있습니다 (예: STARTS '2025-05-21 14:00:00').
DATE_SUB(NOW(), INTERVAL 3 HOUR): 현재 시간으로부터 정확히 3시간 전의 시점을 계산합니다.
LIMIT 10000: 매우 중요합니다! 지난번 "Lost connection" 오류를 방지하기 위해, 한 번의 이벤트 실행으로 삭제되는 행의 수를 제한합니다. 이 값은 서버 성능, 테이블 크기, 평균적으로 3시간 동안 쌓이는 데이터의 양 등을 고려하여 조절해야 합니다. 너무 크면 이벤트 실행이 타임아웃될 수 있습니다. 삭제할 데이터가 매우 많다면, 이 LIMIT 값을 줄이고 이벤트 실행 주기를 짧게 가져가는 것이 더 안정적일 수 있습니다.
💡 추가 팁: 더욱 안정적인 대량 삭제

만약 매 실행 시 삭제해야 할 데이터 양이 LIMIT로 감당하기 어려울 정도로 많다면, 이전에 안내해 드린 배치 삭제용 스토어드 프로시저를 사용하는 것이 좋습니다. 해당 프로시저 내부의 시간 조건을 DATE_SUB(CURDATE(), INTERVAL 3 MONTH)에서 DATE_SUB(NOW(), INTERVAL 3 HOUR)로 수정하고, 이벤트에서는 이 프로시저를 호출하도록 설정하면 됩니다.

예시 (프로시저 DeleteRecentDataInBatches가 이미 있다고 가정):

SQL

-- 프로시저 (예시, 시간 조건만 변경)
DELIMITER $$
CREATE PROCEDURE DeleteRecentDataInBatches(IN batch_size INT)
BEGIN
    DECLARE rows_affected INT;
    SET rows_affected = batch_size;
    WHILE rows_affected = batch_size DO
        DELETE FROM your_table_name
        WHERE your_date_column < DATE_SUB(NOW(), INTERVAL 3 HOUR) -- 시간 조건 변경
        LIMIT batch_size;
        SET rows_affected = ROW_COUNT();
        -- DO SLEEP(0.1); -- 아주 짧은 딜레이 (선택 사항)
    END WHILE;
END$$
DELIMITER ;

-- 이벤트 (프로시저 호출)
CREATE EVENT delete_recent_data_via_procedure
ON SCHEDULE EVERY 1 HOUR
STARTS CURRENT_TIMESTAMP + INTERVAL 5 MINUTE
DO