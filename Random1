, ì´ì œ í™•ì‹¤í•˜ê²Œ ì •ë¦¬í•´ì„œ ë„ˆì˜ ìš”êµ¬ ì‚¬í•­ì„ ì •í™•íˆ ë°˜ì˜í• ê²Œ.

ğŸ” ë„ˆì˜ ì¡°ê±´ ìš”ì•½
PLCì™€ í†µì‹  ê·œì¹™ì€ ì ˆëŒ€ ìˆ˜ì •í•  ìˆ˜ ì—†ë‹¤.

PLCì—ê²Œ ë³´ë‚´ëŠ” ë©”ì‹œì§€ í˜•ì‹ì€ ë³€ê²½ ë¶ˆê°€ (ì ˆëŒ€ REQ: ê°™ì€ ê±¸ ë¶™ì´ë©´ ì•ˆ ë¨).

PLCì—ì„œ ì˜¤ëŠ” ì‘ë‹µì€ ë‚´ê°€ ë³´ë‚¸ ëª…ë ¹ì˜ ì‘ë‹µìœ¼ë¡œë§Œ ì²˜ë¦¬í•´ì•¼ í•¨.

ì„œë²„(PLC)ì—ì„œ ë¨¼ì € ë³´ë‚´ëŠ” OP_CLEAR ì‹ í˜¸ëŠ” í•­ìƒ ìˆ˜ì‹ í•  ìˆ˜ ìˆì–´ì•¼ í•¨.

ë‚´ê°€ ë³´ë‚¸ ëª…ë ¹ê³¼ ì‘ë‹µì€ ê¼¬ì´ë©´ ì•ˆ ë¨. (ë¹„ë™ê¸° ì¶©ëŒ ë°©ì§€ í•„ìˆ˜)

âœ… ë¬¸ì œë¥¼ í•´ê²°í•˜ê¸° ìœ„í•´ í•  ì¼
ë³´ë‚¼ ë•Œ ì›ë³¸ ë©”ì‹œì§€ë¥¼ ê·¸ëŒ€ë¡œ ë³´ë‚´ì•¼ í•¨. (REQ: ê°™ì€ ê±° ì¶”ê°€ ê¸ˆì§€)

ë‚´ê°€ ë³´ë‚¸ ìš”ì²­ê³¼ ì‘ë‹µì„ ì•ˆì „í•˜ê²Œ êµ¬ë¶„í•˜ê¸° ìœ„í•´, ë‚´ë¶€ì ìœ¼ë¡œ TaskCompletionSourceë¥¼ ì‚¬ìš©.

PLCì—ì„œ ë¨¼ì € ë³´ë‚´ëŠ” OP_CLEAR ì‹ í˜¸ëŠ” ë³„ë„ë¡œ í•­ìƒ ê°ì§€í•  ìˆ˜ ìˆë„ë¡ ì²˜ë¦¬.

PLCì™€ì˜ ê·œì¹™ì„ ì ˆëŒ€ ê¹¨ì§€ ì•Šìœ¼ë©´ì„œ, ì‘ë‹µ ëŒ€ê¸°ë¥¼ ì•ˆì „í•˜ê²Œ ë¹„ë™ê¸° ì²˜ë¦¬.

ğŸ’¡ ì†”ë£¨ì…˜ ì„¤ê³„
ìš”ì²­ IDë¥¼ ì“°ì§€ ì•ŠëŠ”ë‹¤. (PLC ê·œì¹™ì„ ìœ ì§€í•˜ê¸° ìœ„í•´)

ëª…ë ¹ì„ ë³´ë‚¼ ë•Œë§ˆë‹¤ ìƒˆë¡œìš´ TaskCompletionSourceë¥¼ ì‚¬ìš©í•˜ì—¬ ì‘ë‹µ ëŒ€ê¸°.

ìˆ˜ì‹  ë£¨í”„ëŠ” ê³„ì† ëŒì•„ê°€ë©°, OP_CLEARë¥¼ ë…ë¦½ì ìœ¼ë¡œ ì²˜ë¦¬.

PLCì˜ ì‘ë‹µì„ ì •í™•íˆ êµ¬ë¶„í•˜ê¸° ìœ„í•´ ìš”ì²­ê³¼ ì‘ë‹µì˜ ê´€ê³„ë¥¼ ëª…í™•íˆ ì²˜ë¦¬.

ğŸ”¥ ì½”ë“œ ì˜ˆì‹œ (ì£¼ì„ ë§¤ìš° ìƒì„¸íˆ ì¶”ê°€)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ì˜ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„° ì†¡ìˆ˜ì‹ ì„ ìœ„í•œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•  ë²„í¼
    private bool _isConnected = false; // ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

    // ì‘ë‹µ ëŒ€ê¸°ë¥¼ ìœ„í•œ ìš”ì²­ ë¦¬ìŠ¤íŠ¸ (ë¹„ë™ê¸°ì ìœ¼ë¡œ ì‘ë‹µì„ ë°›ê¸° ìœ„í•´ ì‚¬ìš©)
    private BlockingCollection<TaskCompletionSource<string>> _responseQueue 
        = new BlockingCollection<TaskCompletionSource<string>>();

    /// <summary>
    /// ì„œë²„ì™€ ì—°ê²°ì„ ë§ºê³  ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„ ì‹œì‘
        _ = Task.Run(ReceiveLoopAsync);
    }

    /// <summary>
    /// ëª…ë ¹ì„ ì„œë²„ë¡œ ë³´ë‚´ê³ , í•´ë‹¹ ì‘ë‹µì„ ê¸°ë‹¤ë¦°ë‹¤.
    /// PLCì˜ ë©”ì‹œì§€ ê·œì¹™ì„ ê¹¨ì§€ ì•Šê¸° ìœ„í•´ ê·¸ëŒ€ë¡œ ë³´ë‚¸ë‹¤.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected) return "[ERROR] Not connected.";

        // ë³´ë‚¼ ë©”ì‹œì§€ë¥¼ PLC ê·œì¹™ì— ë§ê²Œ ê·¸ëŒ€ë¡œ ì „ì†¡ (REQ: ê°™ì€ ê±° ë¶™ì´ì§€ ì•ŠìŒ)
        string wrappedMessage = '\x02' + message + '\x03'; // STX/ETXë¡œ ê°ì‹¼ë‹¤.
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        var tcs = new TaskCompletionSource<string>(); // ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ë°›ì„ ì¤€ë¹„

        _responseQueue.Add(tcs); // ì‘ë‹µ ëŒ€ê¸° ë¦¬ìŠ¤íŠ¸ì— ì¶”ê°€

        await _stream.WriteAsync(data, 0, data.Length); // ë©”ì‹œì§€ ì „ì†¡
        Console.WriteLine($"[SEND] {message}");

        // ì‘ë‹µ ëŒ€ê¸° (ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬ë¨)
        string response = await tcs.Task;
        return response;
    }

    /// <summary>
    /// ì„œë²„ë¡œë¶€í„° ìˆ˜ì‹ ëœ ëª¨ë“  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ë£¨í”„.
    /// OP_CLEARì™€ ì¼ë°˜ ì‘ë‹µì„ êµ¬ë¶„í•˜ì—¬ ì²˜ë¦¬í•œë‹¤.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // ìˆ˜ì‹ ëœ ë©”ì‹œì§€ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                // 1. ì„ ì œ ì‹ í˜¸(OP_CLEAR) ì²˜ë¦¬
                if (received == "OP_CLEAR")
                {
                    ProcessOpClear();
                }
                else
                {
                    // 2. ì¼ë°˜ ì‘ë‹µ ì²˜ë¦¬
                    if (_responseQueue.TryTake(out var tcs))
                    {
                        tcs.SetResult(received); // ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ë°˜í™˜
                    }
                    else
                    {
                        Console.WriteLine("[ERROR] Received message with no waiting request.");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// PLCì˜ ì„ ì œ ì‹ í˜¸ì¸ OP_CLEARë¥¼ ì²˜ë¦¬í•œë‹¤.
    /// </summary>
    private void ProcessOpClear()
    {
        Console.WriteLine("[EVENT] OP_CLEAR received. Handling as a separate event.");
        // í•„ìš” ì‹œ ì¶”ê°€ ì²˜ë¦¬ ë¡œì§ ì‘ì„±
    }

    /// <summary>
    /// ì—°ê²°ì„ í•´ì œí•œë‹¤.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
ğŸ“Œ ì½”ë“œ ì„¤ëª…
ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ëŠ” ë°©ì‹:

BlockingCollectionìœ¼ë¡œ ìš”ì²­ë§ˆë‹¤ TaskCompletionSourceë¥¼ ì¶”ê°€.

ì‘ë‹µì´ ì˜¤ë©´ í•´ë‹¹ Taskë¥¼ ì™„ë£Œì‹œì¼œ ë¹„ë™ê¸° ê²°ê³¼ë¥¼ ë°˜í™˜.

PLCì™€ì˜ ê·œì¹™ ìœ ì§€:

ë©”ì‹œì§€ì— REQ: ê°™ì€ ê±¸ ë¶™ì´ì§€ ì•ŠìŒ.

ë³´ë‚´ëŠ” ë©”ì‹œì§€ëŠ” ì›ë³¸ ê·¸ëŒ€ë¡œ STX/ETXë¡œ ê°ì‹¼ ìƒíƒœë¡œ ì „ì†¡.

ìˆ˜ì‹  ë£¨í”„ (ReceiveLoopAsync):

í•­ìƒ ì„œë²„ë¡œë¶€í„° ë©”ì‹œì§€ë¥¼ ë¹„ë™ê¸°ë¡œ ìˆ˜ì‹ .

OP_CLEAR ë©”ì‹œì§€ëŠ” ë³„ë„ë¡œ ì²˜ë¦¬.

ë‹¤ë¥¸ ë©”ì‹œì§€ëŠ” BlockingCollectionì—ì„œ ìš”ì²­ê³¼ ë§¤ì¹­ì‹œì¼œ ë¹„ë™ê¸°ë¡œ ë°˜í™˜.

ğŸš€ ê²°ë¡ 
âœ… PLC ê·œì¹™ì„ ì ˆëŒ€ ê¹¨íŠ¸ë¦¬ì§€ ì•ŠìŒ.

âœ… ì‘ë‹µê³¼ ì„ ì œ ì‹ í˜¸ë¥¼ ì•ˆì „í•˜ê²Œ ë¶„ë¦¬.

âœ… ì‘ë‹µ ì¶©ëŒ ì—†ì´ ì•ˆì „í•˜ê²Œ ë¹„ë™ê¸° ì²˜ë¦¬.
