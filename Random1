 문제가 발생하는 이유는 대부분 ObservableCollection과 UI 바인딩이 제대로 동작하지 않거나, UI 스레드에서 컬렉션 갱신이 이루어지지 않아서입니다. 문제가 무엇인지 명확히 해결하기 위해 다음과 같은 단계로 문제를 분석하고 코드를 수정했습니다.

문제 분석
이벤트가 호출되었음에도 UI에 반영되지 않는 이유:

ObservableCollection은 내부적으로 컬렉션 변경 알림을 UI에 전달하지만, UI 스레드에서 변경하지 않으면 UI가 업데이트되지 않습니다.
DataGrid가 ObservableCollection을 제대로 참조하지 않거나, 뷰모델과의 데이터 바인딩이 깨졌을 가능성도 있습니다.
추가된 데이터가 보이지 않는 증상:

LogEntries 컬렉션에 데이터가 추가되었지만 UI가 이를 감지하지 못하고 갱신되지 않는 경우 발생합니다.
특히, 이벤트 기반 데이터 갱신 시 UI와 ObservableCollection이 동기화되지 않으면 문제가 생깁니다.
최종 해결 코드
1. MergeOIErrLogManager
이벤트를 통해 전달된 데이터를 UI 스레드에서 확실히 추가하도록 수정합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly object _lock = new object();

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 이벤트로 전달된 로그 처리
    /// </summary>
    /// <param name="logLine">로그 라인</param>
    public void HandleLogEvent(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            Application.Current.Dispatcher.Invoke(() => // 반드시 UI 스레드에서 실행
            {
                lock (_lock)
                {
                    LogEntries.Add(newEntry);

                    // 오래된 로그 삭제 (최근 2일치까지만 유지)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. SocketClientMergeOI
이벤트로 로그 데이터를 MergeOIErrLogManager로 전달합니다.

csharp
코드 복사
using System;

public class SocketClientMergeOI
{
    public event Action<string> OnLogReceived;

    private void RaiseLogEvent(string logMessage)
    {
        OnLogReceived?.Invoke(logMessage);
    }

    public void ProcessSocketMessage(string receivedMessage)
    {
        if (receivedMessage.Contains("ERROR"))
        {
            string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] ERROR: {receivedMessage}";
            RaiseLogEvent(logMessage);
        }
    }
}
3. MainViewModel
뷰모델에서 MergeOIErrLogManager와 SocketClientMergeOI를 연결하고, LogEntries를 바인딩합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    private readonly MergeOIErrLogManager _logManager;
    private readonly SocketClientMergeOI _socketClient;

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => _logManager.LogEntries;

    public MainViewModel()
    {
        _logManager = new MergeOIErrLogManager();
        _socketClient = new SocketClientMergeOI();

        // 이벤트 구독
        _socketClient.OnLogReceived += _logManager.HandleLogEvent;

        // 테스트: 소켓 메시지 시뮬레이션
        Task.Run(() => SimulateSocketMessages());
    }

    /// <summary>
    /// 테스트용: 소켓 메시지 시뮬레이션
    /// </summary>
    private async Task SimulateSocketMessages()
    {
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Connection lost");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("INFO: Reconnected");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Timeout");
    }
}
4. XAML
UI에서 LogEntries를 DataGrid에 바인딩합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- 시간 컬럼 -->
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <!-- 메시지 컬럼 -->
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <!-- 세부 내용 컬럼 -->
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
최종 점검 사항
UI 스레드에서 LogEntries 수정 확인

Application.Current.Dispatcher.Invoke를 통해 UI 스레드에서 컬렉션을 수정하도록 보장했습니다.
뷰모델과 XAML 바인딩 점검

DataGrid의 ItemsSource는 LogEntries와 정확히 바인딩되었습니다.
MainViewModel이 DataContext로 설정되어 있습니다.
테스트 코드

SimulateSocketMessages로 소켓 메시지 발생 시 로그가 정상적으로 추가되는지 확인합니다.