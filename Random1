춰 MSSQL 2014에서 100% 실행 가능한 전체 쿼리를 초정밀 주석 포함해서 짜줄게.

너가 원하는 분석 로직 (최종 요약)
기본 구조:
테이블: ExcelData

키 컬럼: line1, model1, type1, ecn1, edition1

시간 기준: 최근 5시간 (GETDATE() 기준)

측정값:

ACT2_1 ~ ACT2_8

ACT2BEST_1 ~ ACT2BEST_8
→ 모두 float, 0 값은 제외해야 함

목표 처리 흐름:
최근 5시간 데이터만 사용

각 행에 대해:

ACT2_1~8 중 0 초과만 추려서, 이상치(Q1~Q3 밖) 제거 후 → 행 기준 최대값 → A

ACT2BEST_1~8 도 동일 방식으로 행 기준 최대값 → B

이렇게 나온 전체 행의 A 중 최솟값 = max_act2
전체 행의 B 중 최솟값 = max_act2best

결과 출력은:

line1, model1, type1, ecn1, edition1,

max_act2, max_act2best, ctdiff = max_act2 - max_act2best

결과 컬럼
line1	model1	type1	ecn1	edition1	max_act2	max_act2best	ctdiff
MSSQL 2014 쿼리 전체 (주석 아주 상세하게)
sql
코드 복사
-- Step 1. 최근 5시간 이내 데이터 필터링
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- Step 2. 각 행을 기준으로 0보다 큰 ACT2 값들을 펼치고 이상치 제거 준비
ACT2_Long AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM RawData
    CROSS APPLY (VALUES
        (ACT2_1), (ACT2_2), (ACT2_3), (ACT2_4),
        (ACT2_5), (ACT2_6), (ACT2_7), (ACT2_8)
    ) AS V(val)
    WHERE val > 0
),

-- Step 3. 각 키 기준으로 ACT2 이상치 범위 계산
ACT2_Stats AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2_Long
),

-- Step 4. ACT2에서 이상치 제거한 후, 행 기준 최대값 추출
ACT2_RowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM ACT2_Stats
    WHERE val BETWEEN Q1 AND Q3
),

-- Step 5. 각 행별 ACT2 최대값 추출
ACT2_PerRowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1,
           MAX(val) AS act2_row_max
    FROM ACT2_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- Step 6. ACT2BEST도 위와 동일하게 처리
ACT2BEST_Long AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM RawData
    CROSS APPLY (VALUES
        (ACT2BEST_1), (ACT2BEST_2), (ACT2BEST_3), (ACT2BEST_4),
        (ACT2BEST_5), (ACT2BEST_6), (ACT2BEST_7), (ACT2BEST_8)
    ) AS V(val)
    WHERE val > 0
),

ACT2BEST_Stats AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2BEST_Long
),

ACT2BEST_RowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM ACT2BEST_Stats
    WHERE val BETWEEN Q1 AND Q3
),

ACT2BEST_PerRowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1,
           MAX(val) AS act2best_row_max
    FROM ACT2BEST_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- Step 7. 각 모델별로 전체 행 중 최소값만 남긴다 (A의 min, B의 min)
Final_MinPerModel AS (
    SELECT
        A.line1, A.model1, A.type1, A.ecn1, A.edition1,
        MIN(A.act2_row_max) AS max_act2,
        MIN(B.act2best_row_max) AS max_act2best
    FROM ACT2_PerRowMax A
    JOIN ACT2BEST_PerRowMax B
      ON A.line1 = B.line1 AND A.model1 = B.model1 AND A.type1 = B.type1
     AND A.ecn1 = B.ecn1 AND A.edition1 = B.edition1
    GROUP BY A.line1, A.model1, A.type1, A.ecn1, A.edition1
)

-- Step 8. 최종 결과 출력
SELECT *,
       max_act2 - max_act2best AS ctdiff
FROM Final_MinPerModel
ORDER BY line1, model1, type1, ecn1, edition1;
이 쿼리는 이렇게 동작해:
각 행마다 ACT2, ACT2BEST 각각 이상치 제거 후 max값만 구함

이후 모델별 전체 행 중에서 min값만 뽑음

그리고 그 둘을 빼서 ctdiff 계산

딱 너가 말한 대로:

행마다 max 구하고

모델별 min만 모아서

같은 행 비교 아님

각 그룹의 최저성능 비교임

바로 실행해보고 확인해줘.