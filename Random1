oncurrentQueue를 사용해서 작업을 추가하고, 문자열에 따라 구분 작업을 수행하며, 여러 파라미터를 넘기는 예시는 아래와 같습니다. 이 예시에서는 ConcurrentQueue에 TestTask라는 작업 개체를 추가하고, 해당 작업을 소비하는 TaskProcessor가 있습니다. 작업을 처리할 때 다양한 파라미터 (예: 테스트 제목, 옵저버 개체, 상태 코드, 메시지)를 넘겨 적절한 처리를 할 수 있습니다.

1. TestTask 클래스 정의
먼저 작업에 필요한 다양한 파라미터를 포함하는 TestTask 클래스를 정의합니다.

csharp
코드 복사
public class TestTask
{
    public string TestTitle { get; set; }  // 테스트 제목
    public object Observer { get; set; }   // 옵저버 객체
    public string MessageType { get; set; } // 메시지 타입 (문자열에 따라 구분)
    public int StatusCode { get; set; }    // 상태 코드 (추가 파라미터)
    public string AdditionalInfo { get; set; } // 추가 정보 (예: 로그 메시지 등)
    
    public TestTask(string testTitle, object observer, string messageType, int statusCode, string additionalInfo)
    {
        TestTitle = testTitle;
        Observer = observer;
        MessageType = messageType;
        StatusCode = statusCode;
        AdditionalInfo = additionalInfo;
    }
}
2. TaskProcessor 클래스 정의
이 클래스는 ConcurrentQueue에서 작업을 처리하는 역할을 합니다.

csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

public class TaskProcessor
{
    private ConcurrentQueue<TestTask> _taskQueue = new ConcurrentQueue<TestTask>();

    // 작업 추가 메서드
    public void EnqueueTask(TestTask task)
    {
        _taskQueue.Enqueue(task);
        Console.WriteLine($"Task Enqueued: {task.TestTitle}, MessageType: {task.MessageType}");
    }

    // 작업 처리 메서드
    public async Task ProcessTasksAsync()
    {
        while (true)
        {
            if (_taskQueue.TryDequeue(out TestTask task))
            {
                // 메시지 타입에 따라 작업을 처리
                switch (task.MessageType)
                {
                    case "Info":
                        HandleInfoTask(task);
                        break;
                    case "Warning":
                        HandleWarningTask(task);
                        break;
                    case "Error":
                        HandleErrorTask(task);
                        break;
                    default:
                        Console.WriteLine("Unknown message type.");
                        break;
                }
            }
            else
            {
                // 대기 시간 (잠시 멈추고 대기)
                await Task.Delay(500);
            }
        }
    }

    // 각 메시지 타입별 작업 처리 메서드
    private void HandleInfoTask(TestTask task)
    {
        Console.WriteLine($"[INFO] {task.TestTitle}: {task.AdditionalInfo}");
        // 옵저버와의 상호작용 등 추가 로직
    }

    private void HandleWarningTask(TestTask task)
    {
        Console.WriteLine($"[WARNING] {task.TestTitle}: {task.AdditionalInfo}, StatusCode: {task.StatusCode}");
        // 경고 처리 로직
    }

    private void HandleErrorTask(TestTask task)
    {
        Console.WriteLine($"[ERROR] {task.TestTitle}: {task.AdditionalInfo}, Observer: {task.Observer}");
        // 오류 처리 로직
    }
}
3. 작업 추가 및 처리 예시
이제 실제로 작업을 추가하고 처리하는 예시 코드를 작성합니다.

csharp
코드 복사
public class Program
{
    public static async Task Main(string[] args)
    {
        TaskProcessor processor = new TaskProcessor();

        // 작업을 추가
        processor.EnqueueTask(new TestTask("Test 1", new object(), "Info", 200, "All systems operational."));
        processor.EnqueueTask(new TestTask("Test 2", new object(), "Warning", 300, "Disk space is running low."));
        processor.EnqueueTask(new TestTask("Test 3", new object(), "Error", 500, "Critical failure in the system."));

        // 비동기적으로 작업 처리
        await processor.ProcessTasksAsync();
    }
}
설명
ConcurrentQueue를 사용하여 스레드 안전한 작업 큐를 구현했습니다.
TestTask는 여러 파라미터 (테스트 제목, 옵저버 개체, 메시지 타입, 상태 코드 등)를 포함하는 작업을 정의한 클래스입니다.
TaskProcessor는 큐에서 작업을 비동기적으로 처리하며, 메시지 타입에 따라 다른 로직을 수행합니다. HandleInfoTask, HandleWarningTask, HandleErrorTask는 각 메시지 타입에 대한 구체적인 작업 처리 방식을 담당합니다.
ProcessTasksAsync 메서드는 큐에서 작업을 비동기적으로 처리하며, 큐가 비어 있을 경우 잠시 대기했다가 다시 확인합니다.
이 구조를 사용하면 작업 처리 로직을 매우 유연하게 확장할 수 있습니다