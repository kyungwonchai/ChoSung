 스토어드 프로시저를 만들어야 합니다.
1. 테이블A 생성

테이블A는 컬럼명과 권한을 저장하는 테이블로, 아래 쿼리로 생성할 수 있습니다.

sql

CREATE TABLE TableA (
    ID INT PRIMARY KEY IDENTITY(1,1),
    ColName NVARCHAR(255),
    Auth BIT
);

ColName은 컬럼 이름을 저장하고, Auth는 쓰기 권한이 있는지 없는지를 나타내는 불린 값입니다.
2. 스토어드 프로시저 생성

프로시저1은 특정 테이블의 컬럼명을 TableA에 저장하는 프로시저입니다.

sql

CREATE PROCEDURE InsertColumnNames
    @TableName NVARCHAR(255)
AS
BEGIN
    DECLARE @ColumnName NVARCHAR(255);
    DECLARE column_cursor CURSOR FOR 
    SELECT COLUMN_NAME 
    FROM INFORMATION_SCHEMA.COLUMNS 
    WHERE TABLE_NAME = @TableName;

    OPEN column_cursor;

    FETCH NEXT FROM column_cursor INTO @ColumnName;

    WHILE @@FETCH_STATUS = 0
    BEGIN
        INSERT INTO TableA (ColName, Auth) VALUES (@ColumnName, 0);
        FETCH NEXT FROM column_cursor INTO @ColumnName;
    END;

    CLOSE column_cursor;
    DEALLOCATE column_cursor;
END;

이 프로시저를 실행하면, 지정된 테이블의 모든 컬럼 이름이 TableA에 저장됩니다. 여기서 Auth는 기본적으로 0으로 설정되어 있으므로, 필요한 경우 이 값을 변경하여 권한을 부여할 수 있습니다.
3. Winform에서 데이터 바인딩

Winform에서는 사용자 권한에 따라 해당 컬럼을 읽기 전용으로 설정할 수 있습니다. 아래는 그 예시 코드입니다.

csharp

using System.Data.SqlClient;

// ...

private void BindData()
{
    string connectionString = "여기에 연결 문자열을 입력하세요";
    using (SqlConnection connection = new SqlConnection(connectionString))
    {
        connection.Open();
        using (SqlCommand command = new SqlCommand("SELECT * FROM YourTable", connection))
        {
            using (SqlDataReader reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    for (int i = 0; i < reader.FieldCount; i++)
                    {
                        string colName = reader.GetName(i);
                        bool isWritable = CheckWritePermission(colName);
                        // isWritable 값에 따라 해당 컬럼을 읽기 전용으로 설정
                    }
                }
            }
        }
    }
}

private bool CheckWritePermission(string colName)
{
    // TableA에서 colName에 해당하는 Auth 값을 확인하고 반환
}

CheckWritePermission 함수는 TableA에서 해당 컬럼의 쓰기 권한을 확인하여 반환합니다.

이렇게 하면 사용자별로 컬럼의 쓰기 권한을 다르게 설정하고 관리할 수 있습니다. 입력 충돌 문제를 방지하기 위해서는 트랜잭션을 적절히 사용하거나, 다른 동기화 메커니즘을 사용해야 할 수도 있습니다.
