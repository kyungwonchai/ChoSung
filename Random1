# -*- coding: utf-8 -*-
# FILE_ID: streamlit/locker_app_20250411175800
import streamlit as st
import pymssql
import pandas as pd
import time

# --- DB 연결 정보 (실제 환경에서는 Secrets 사용 권장) ---
DB_SERVER = "YOUR_SERVER_NAME" # 예: 192.168.1.100 또는 SERVERNAME\SQLEXPRESS
DB_DATABASE = "LockerManagementDB"
DB_USER = "your_db_username"
DB_PASSWORD = "your_db_password"
# ---------------------------------------------------------

# 페이지 기본 설정
st.set_page_config(page_title="시생산 사물함관리", layout="wide")

# --- 데이터 로딩 함수 (캐싱 사용) ---
@st.cache_data(ttl=600) # 10분(600초) 동안 캐시 유지
def load_data():
    """데이터베이스에서 사물함 배정 데이터를 로드합니다."""
    conn = None
    try:
        conn = pymssql.connect(server=DB_SERVER, user=DB_USER, password=DB_PASSWORD, database=DB_DATABASE, charset='UTF-8')
        query = "SELECT LockerType, Floor, Zone, SpecificLocation, UserName, KnoxId, SubPart, Administrator, TransferStatus, Details, Remarks, Notes, LastUpdated FROM LockerAssignments ORDER BY Floor, Zone, SpecificLocation"
        df = pd.read_sql(query, conn)
        # 데이터 타입 변환 및 전처리
        df['SpecificLocation'] = df['SpecificLocation'].astype(str)
        if 'LastUpdated' in df.columns:
            df['LastUpdated'] = pd.to_datetime(df['LastUpdated']).dt.strftime('%Y-%m-%d %H:%M:%S')
        # 빈 UserName을 실제 null 또는 빈 문자열로 처리 (DB에 따라 다를 수 있음)
        df['UserName'] = df['UserName'].fillna('')
        return df
    except Exception as e:
        st.error(f"데이터 로딩 중 오류 발생: {e}")
        return pd.DataFrame()
    finally:
        if conn:
            conn.close()

# --- 현황 계산 함수 ---
def calculate_status(df, group_by_column):
    """지정된 컬럼으로 그룹화하여 현황 통계를 계산합니다."""
    if df is None or df.empty or group_by_column not in df.columns:
        return pd.DataFrame(columns=['총 개수', '사용', '여유', '사용률(%)'])

    status_df = df.groupby(group_by_column).agg(
        TotalCount = pd.NamedAgg(column='UserName', aggfunc='size'), # 그룹별 총 개수
        UsedCount = pd.NamedAgg(column='UserName', aggfunc=lambda x: x.ne('').sum()) # UserName이 비어있지 않은 개수
    ).reset_index()

    status_df.rename(columns={group_by_column: '구분', 'TotalCount': '총 개수', 'UsedCount': '사용'}, inplace=True)
    status_df['여유'] = status_df['총 개수'] - status_df['사용']
    status_df['사용률(%)'] = (status_df['사용'] / status_df['총 개수'] * 100).round(1)
    # NaN 값(총 개수가 0인 경우)을 0으로 처리
    status_df['사용률(%)'] = status_df['사용률(%)'].fillna(0)

    return status_df.set_index('구분') # 차트 생성을 위해 그룹 컬럼을 인덱스로 설정

# --- UI 구성 ---
st.title("시생산 사물함관리")

# 데이터 로드
df_full = load_data()

# --- 사이드바: 필터, 검색, 현황 버튼 ---
st.sidebar.header("필터 및 검색")

# 새로고침 버튼
if st.sidebar.button("새로고침"):
    st.cache_data.clear()
    st.success("데이터를 새로고침했습니다!")
    time.sleep(1)
    st.rerun()

# 종류 필터
locker_types = ["전체"] + sorted(df_full['LockerType'].astype(str).unique())
selected_type = st.sidebar.selectbox("종류 선택", locker_types)

# 층 필터
floors = ["전체"] + sorted(df_full['Floor'].astype(str).unique())
selected_floor = st.sidebar.selectbox("층 선택", floors)

# 구역 필터
zones = ["전체"] + sorted(df_full['Zone'].astype(str).unique())
selected_zone = st.sidebar.selectbox("구역 선택", zones)

# 검색어 입력
search_term = st.sidebar.text_input("검색어 입력")

# *** 신규: 현황 보기 버튼 ***
show_status_chart = st.sidebar.button("종류별 현황 차트 보기")

# --- 데이터 필터링 및 검색 ---
df_filtered = df_full.copy()

if selected_type != "전체":
    df_filtered = df_filtered[df_filtered['LockerType'] == selected_type]
if selected_floor != "전체":
    df_filtered = df_filtered[df_filtered['Floor'] == selected_floor]
if selected_zone != "전체":
    df_filtered = df_filtered[df_filtered['Zone'] == selected_zone]

if search_term:
    search_columns = ['LockerType', 'Floor', 'Zone', 'SpecificLocation', 'UserName', 'KnoxId', 'SubPart', 'Administrator', 'TransferStatus', 'Details', 'Remarks', 'Notes']
    string_columns = df_filtered.select_dtypes(include='object').columns
    searchable_string_columns = [col for col in search_columns if col in string_columns]
    if searchable_string_columns: # 검색 가능한 문자열 컬럼이 있을 경우에만 검색
        df_filtered = df_filtered[
            df_filtered[searchable_string_columns].apply(
                lambda row: row.str.contains(search_term, case=False, na=False).any(),
                axis=1
            )
        ]

# --- 메인 화면 ---

# *** 신규: 현황 차트 표시 (버튼 클릭 시) ***
if show_status_chart:
    if not df_full.empty:
        st.subheader("사물함 종류별 사용 현황")
        status_by_type_df = calculate_status(df_full, 'LockerType')
        if not status_by_type_df.empty:
            # st.bar_chart는 사용/여유 데이터를 별도 컬럼으로 요구
            st.bar_chart(status_by_type_df[['사용', '여유']])
            # 데이터 테이블도 함께 표시 (선택 사항)
            st.dataframe(status_by_type_df, use_container_width=True)
        else:
            st.write("현황 데이터를 계산할 수 없습니다.")
    else:
         st.warning("현황 차트를 표시할 데이터가 없습니다.")
    st.divider() # 구분선

# 필터링된 데이터 표시
st.write(f"총 {len(df_filtered)}개의 결과")
st.dataframe(df_filtered.reset_index(drop=True), use_container_width=True, height=600) # 높이 지정

```

**핵심 변경 사항:**

1.  **`calculate_status` 함수 추가:** 입력된 DataFrame과 그룹화할 컬럼 이름을 받아, 그룹별 총 개수, 사용 개수, 여유 개수, 사용률을 계산하여 새로운 DataFrame으로 반환하는 함수를 만들었습니다. 특히 `UsedCount` 계산 시 `UserName`이 단순히 `null`이 아닌, 빈 문자열(`''`)이 아닌 경우를 카운트하도록 수정했습니다 (`x.ne('').sum()`).
2.  **사이드바에 버튼 추가:** `st.sidebar.button("종류별 현황 차트 보기")`를 추가했습니다. 이 버튼을 클릭하면 `show_status_chart` 변수가 `True`가 됩니다.
3.  **조건부 차트 표시:** 메인 화면 영역에 `if show_status_chart:` 블록을 추가했습니다.
    * 버튼이 클릭되면(`True`) 먼저 전체 데이터(`df_full`)로 `calculate_status` 함수를 호출하여 종류별 현황 데이터(`status_by_type_df`)를 계산합니다.
    * 계산된 데이터프레임에서 '사용'과 '여유' 컬럼만 선택하여 `st.bar_chart()`에 전달하여 막대 차트를 그립니다.
    * 선택적으로 계산된 현황 데이터 테이블(`status_by_type_df`)도 `st.dataframe()`으로 표시합니다.
4.  **기존 표 유지:** 기존의 필터링/검색된 사물함 목록 표는 버튼 클릭 여부와 관계없이 항상 표시됩니다. 차트는 버튼 클릭 시 추가로 나타납니다.
5.  **데이터 로딩 수정:** `load_data` 함수에서 `UserName` 컬럼의 `NaN` 값을 빈 문자열로 채우도록 수정했습니다 (`fillna('')`).