너는 C# 프로그램에서 2400 포트로 소켓 서버에 비동기적으로 신호를 보낼 수 있음

그런데 반대로, 상대방(게)이 너에게 먼저 신호를 보내는 상황도 있음

따라서 수신 대기 상태를 항상 유지하면서, 상대가 보낸 데이터를 비동기적으로 캐치해야 함

이론 설명
소켓 통신에서 상대방이 먼저 데이터를 보낼 수 있는 구조를 처리하려면, 항상 Receive 혹은 ReceiveAsync를 대기 상태로 유지해야 합니다.

C#에서 Socket 클래스 또는 TcpClient를 사용할 수 있고, 일반적으로 NetworkStream.BeginRead 혹은 Socket.BeginReceive, async/await 기반 Stream.ReadAsync() 등을 사용하여 비동기 수신 루프를 만듭니다.

핵심 개념은 다음과 같습니다:

서버와 연결을 맺고 나면, 데이터를 보내는 것 외에 항상 수신 대기를 돌려야 함

상대가 데이터를 보내면, 수신 핸들러에서 그걸 파싱하고 처리

이때도 UI가 멈추지 않도록 비동기로 구성해야 함

연결이 끊기거나 에러 시 다시 연결 로직도 필요

예시 코드 (비동기 수신 포함된 구조, TcpClient 기반)
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientReceiver
{
    private TcpClient client;
    private NetworkStream stream;

    public async Task StartAsync(string ip, int port)
    {
        client = new TcpClient();
        await client.ConnectAsync(ip, port);
        Console.WriteLine("Connected to server.");

        stream = client.GetStream();

        // 수신 루프 시작
        _ = Task.Run(() => ReceiveLoop());
    }

    private async Task ReceiveLoop()
    {
        byte[] buffer = new byte[1024];

        while (true)
        {
            try
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead == 0)
                {
                    Console.WriteLine("Server closed connection.");
                    break;
                }

                string received = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                Console.WriteLine($"[RECV] {received}");

                // 여기서 받은 데이터를 처리
                ProcessReceivedData(received);
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Receive error: {ex.Message}");
                break;
            }
        }
    }

    private void ProcessReceivedData(string data)
    {
        // 예: STX ~ ETX 포함되었는지 확인 후 처리
        if (data.Contains("\u0002") && data.Contains("\u0003"))
        {
            string message = data.Trim('\u0002', '\u0003');
            Console.WriteLine($"Parsed message: {message}");
        }
        else
        {
            Console.WriteLine("Invalid message format.");
        }
    }

    public async Task SendAsync(string message)
    {
        if (stream == null) return;

        byte[] data = Encoding.ASCII.GetBytes("\u0002" + message + "\u0003");
        await stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");
    }
}
사용 예시
csharp
코드 복사
class Program
{
    static async Task Main()
    {
        var client = new SocketClientReceiver();
        await client.StartAsync("10.22.22.22", 2400);

        // 예: 너가 먼저 보낼 경우
        await client.SendAsync("HELLO");

        // 프로그램이 종료되지 않도록 대기
        Console.ReadLine();
    }
}
요약
ReceiveLoop()를 항상 돌려야 상대방의 선제 신호를 잡을 수 있음

async/await로 UI/메인 스레드를 막지 않음

신호 형식(STX/ETX 포함)은 데이터 가공 처리 부분에서 처리