네, 이해했습니다. 다음과 같은 추가 요구 사항을 반영하여 전체 코드를 수정해 드리겠습니다:

주요 요구 사항:
첫 번째 적재는 "Stack1" 문구로 다른 함수를 실행해야 합니다. 이는 첫 적재 작업을 구별하기 위함입니다.
적재 함수의 역할:
적재 명령을 PLC에 보내고, 응답을 받으면 신호가 전달된 것으로 간주합니다.
그 후, R520 센서와 R521 센서를 감시하여 물류가 정상적으로 적재되었는지 확인합니다. R520이 감지되고 꺼진 후 R521이 감지되면 적재 완료입니다.
3분 내에 적재 완료가 안 되면 에러 창이 발생해야 합니다.
큐 시스템:
적재 및 배출 함수가 동시에 실행되면 큐에 작업이 저장되고 순차적으로 처리됩니다.
큐의 상태를 리스트 박스에서 실시간으로 확인할 수 있어야 합니다.
수정된 전체 코드
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileCheckerMES20
    {
        private ObservableCollection<ProductOrderModel> _productOrders; // UI에 표시할 주문 목록
        private ComportManager _comPortPLC; // PLC와 통신할 객체
        private ConcurrentQueue<string> _taskQueue = new ConcurrentQueue<string>(); // 큐에 들어갈 작업 목록
        private DispatcherTimer _timer; // 작업을 주기적으로 처리하는 타이머
        private bool _isProcessingTask = false; // 현재 작업이 진행 중인지 여부
        private int _R520SensorTimeout = 180000; // 3분 타임아웃 (3 * 60 * 1000ms)
        private ObservableCollection<string> _taskList; // 리스트박스에 표시할 큐 상태

        private bool _isFirstStack = true; // 첫 적재 여부를 확인하는 플래그

        // 생성자
        public FileCheckerMES20(ObservableCollection<ProductOrderModel> productOrders, ComportManager comPortManager, ObservableCollection<string> taskList)
        {
            _productOrders = productOrders;
            _comPortPLC = comPortManager;
            _taskList = taskList;

            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _timer.Tick += ProcessQueue; // 큐에서 작업을 처리
            _timer.Start();
        }

        // 적재 함수
        public async Task ExecuteStackFunctionAsync(ProductOrderModel order)
        {
            // 작업을 큐에 추가
            _taskQueue.Enqueue($"적재: {order.ProductOrder}");
            _taskList.Add($"적재 대기: {order.ProductOrder}");

            if (!_isProcessingTask)
            {
                await ProcessQueueAsync(); // 작업 처리 시작
            }
        }

        // 배출 함수
        public async Task ExecuteOutFunctionAsync(ProductOrderModel order)
        {
            // 작업을 큐에 추가
            _taskQueue.Enqueue($"배출: {order.ProductOrder}");
            _taskList.Add($"배출 대기: {order.ProductOrder}");

            if (!_isProcessingTask)
            {
                await ProcessQueueAsync(); // 작업 처리 시작
            }
        }

        // 큐에서 작업을 처리하는 함수
        private async Task ProcessQueueAsync()
        {
            _isProcessingTask = true;

            while (_taskQueue.TryDequeue(out string task))
            {
                _taskList.Remove(task); // 큐에서 작업을 제거하고 리스트에서 표시 제거
                string[] taskParts = task.Split(':');
                string taskType = taskParts[0].Trim();
                string productOrder = taskParts[1].Trim();

                if (taskType == "적재")
                {
                    msgvs.Instance.LogT2($"적재 작업 시작: {productOrder}");
                    await ProcessStackAsync(productOrder); // 적재 작업 처리
                }
                else if (taskType == "배출")
                {
                    msgvs.Instance.LogT2($"배출 작업 시작: {productOrder}");
                    await ProcessOutAsync(productOrder); // 배출 작업 처리
                }
            }

            _isProcessingTask = false;
        }

        // 적재 작업 처리
        private async Task ProcessStackAsync(string productOrder)
        {
            // 첫 적재는 "Stack1" 처리
            if (_isFirstStack)
            {
                _isFirstStack = false;
                await ExecuteStack1Async(productOrder); // Stack1 처리
            }
            else
            {
                // 일반 적재 처리
                bool isCommandSent = SendStackCommandToPLC();

                if (isCommandSent)
                {
                    msgvs.Instance.LogT2($"PLC 적재 신호 전송 완료: {productOrder}");

                    // R520/R521 센서 감지 대기
                    bool isSensorSuccess = await MonitorSensorsAsync();

                    if (isSensorSuccess)
                    {
                        msgvs.Instance.LogT2($"적재 완료: {productOrder}");
                    }
                    else
                    {
                        msgvs.Instance.LogT2($"적재 실패: {productOrder}");
                        // 에러 발생: 적재가 완료되지 않음
                        ShowError($"적재 실패: {productOrder} (3분 내 감지되지 않음)");
                    }
                }
            }
        }

        // Stack1 처리 함수 (첫 적재 전용)
        private async Task ExecuteStack1Async(string productOrder)
        {
            msgvs.Instance.LogT2($"첫 적재(Stack1) 작업 시작: {productOrder}");

            // 첫 적재 시 PLC 명령 전송 (Stack1 전용 로직)
            bool isStack1Sent = SendStack1CommandToPLC();

            if (isStack1Sent)
            {
                msgvs.Instance.LogT2($"Stack1 적재 신호 전송 완료: {productOrder}");

                // R520/R521 센서 감지 대기
                bool isSensorSuccess = await MonitorSensorsAsync();

                if (isSensorSuccess)
                {
                    msgvs.Instance.LogT2($"첫 적재(Stack1) 완료: {productOrder}");
                }
                else
                {
                    msgvs.Instance.LogT2($"첫 적재 실패: {productOrder}");
                    // 에러 발생: 적재가 완료되지 않음
                    ShowError($"첫 적재 실패: {productOrder} (3분 내 감지되지 않음)");
                }
            }
        }

        // 배출 작업 처리
        private async Task ProcessOutAsync(string productOrder)
        {
            // 뮤토콜을 사용해 PLC에 배출 신호 전송 (배출 처리 로직 구현)
            bool isCommandSent = SendOutCommandToPLC();

            if (isCommandSent)
            {
                msgvs.Instance.LogT2($"PLC 배출 신호 전송 완료: {productOrder}");
            }
        }

        // PLC에 적재 신호 전송 함수 (구현되어 있다고 가정)
        private bool SendStackCommandToPLC()
        {
            // PLC에 적재 신호를 전송하는 로직
            // 예시: 뮤토콜로 명령 전송 및 응답 처리
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // PLC에 Stack1 적재 신호 전송 함수 (구현되어 있다고 가정)
        private bool SendStack1CommandToPLC()
        {
            // PLC에 Stack1 신호를 전송하는 로직
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // PLC에 배출 신호 전송 함수 (구현되어 있다고 가정)
        private bool SendOutCommandToPLC()
        {
            // PLC에 배출 신호를 전송하는 로직
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // 센서 감시 함수 (3분 동안 R520, R521 감시)
        private async Task<bool> MonitorSensorsAsync()
        {
            var startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalMilliseconds < _R520SensorTimeout)
            {
                // PLC에서 센서 상태를 읽어옴 (R520 감지 -> 꺼짐 -> R521 감지 순서)
                bool isR520Detected = ReadSensor("R520");
                bool isR521Detected = ReadSensor("R521");

                if (isR520Detected)
                {
                    msgvs.Instance.LogT2("R520 감지됨");
                    // R520이 감지되고 꺼졌는지 확인
                    while (!ReadSensor("R520"))
                    {
                        await Task.Delay(100); // 0.1초 대기
                    }

                    msgvs.Instance.LogT2("R520 꺼짐 확인");

                    // R521 감지 확인
                    if (isR521Detected)
                    {
                        msgvs.Instance.LogT2("R521 감지됨");
                        return true; // 적재 완료
                    }
                }

                await Task.Delay(100); // 0.1초 대기
            }

            return false; // 3분 내에 적재 완료되지 않음
        }

        // 센서 값을 읽는 함수 (구현되어 있다고 가정)
        private bool ReadSensor(string sensorId)
        {
            // PLC에서 센서 값을 읽어오는 로직
            // 예시: R520, R521 감지 여부 반환
            return false; // 센서 감지 여부를 반환 (가정)
        }

        // 에러 창을 표시하는 함수
        private void ShowError(string message)
        {
            // 에러 메시지 창을 띄움
            msgvs.Instance.LogT2(message);
        }
    }

    // 제품 주문 정보를 저장하는 모델 클래스 (INotifyPropertyChanged 구현)
    public class ProductOrderModel : INotifyPropertyChanged
    {
        private string _productOrder;
        private string _basicModel;
        private int _poRemain;
        private int _mgCount;
        private int _pCount;
        private string _poStatus;
        private string _pDate;

        public string ProductOrder
        {
            get => _productOrder;
            set
            {
                _productOrder = value;
                OnPropertyChanged(nameof(ProductOrder));
            }
        }

        public string BasicModel
        {
            get => _basicModel;
            set
            {
                _basicModel = value;
                OnPropertyChanged(nameof(BasicModel));
            }
        }

        public int PORemain
        {
            get => _poRemain;
            set
            {
                _poRemain = value;
                OnPropertyChanged(nameof(PORemain));
            }
        }

        public int MGCount
        {
            get => _mgCount;
            set
            {
                _mgCount = value;
                OnPropertyChanged(nameof(MGCount));
            }
        }

        public int PCount
        {
            get => _pCount;
            set
            {
                _pCount = value;
                OnPropertyChanged(nameof(PCount));
            }
        }

        public string POStatus
        {
            get => _poStatus;
            set
            {
                _poStatus = value;
                OnPropertyChanged(nameof(POStatus));
            }
        }

        public string PDate
        {
            get => _pDate;
            set
            {
                _pDate = value;
                OnPropertyChanged(nameof(PDate));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // 프로퍼티가 변경될 때마다 UI에 알림을 보냄
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 수정 내용:
첫 적재 작업 (Stack1):
첫 번째 적재 작업은 일반 적재와 구분하여 ExecuteStack1Async 함수로 처리합니다.
첫 적재는 "Stack1" 신호를 PLC에 보내고, 적재 완료 후 일반 적재로 넘어갑니다.
적재 및 배출 작업 큐 처리:
적재와 배출 작업은 큐에 저장되며, 하나씩 순차적으로 처리됩니다.
리스트 박스에 현재 큐에 저장된 명령이 실시간으로 표시됩니다.
센서 감시 및 에러 처리:
R520과 R521 센서를 감시하여 3분 안에 정상적으로 완료되는지 확인합니다.
3분 안에 완료되지 않으면 에러 창이 표시됩니다.
이제 첫 적재 작업은 "