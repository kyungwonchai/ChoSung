겠습니다. CS1955 오류는 속성(Property)을 메서드(Method)처럼 괄호()를 붙여 호출하려고 할 때 발생합니다. 이전에 제가 제공했던 코드 원본은 속성을 올바르게 정의하고 올바르게 사용하는 형태로 되어 있었습니다.

아마 코드를 입력하시거나 수정하시는 과정에서 실수로 속성 이름 뒤에 괄호 () 가 추가되었을 가능성이 높습니다.

오류가 발생하지 않아야 하는 PrinterController.cs 와 ShuttleController.cs 의 전체 코드를 다시 드리겠습니다. 이 코드로 각 파일을 완전히 대체해 보세요. (이전에 드렸던 코드와 동일하지만, 오류 해결을 위해 다시 확인하는 차원에서 제공합니다.)

1. PrinterController.cs (전체 코드)

C#

using UnityEngine;
using System.Collections;

public class PrinterController : MonoBehaviour
{
    // --- 상태 정의 ---
    public enum PrinterState { Idle, Receiving, MovingToProcessing, BackingUp, PreparingPrint, Printing, TableDown, Cleaning, MovingToOutput, WaitingForShuttle, Down }
    [Header("State")]
    public PrinterState currentState = PrinterState.Idle;

    // --- 참조 변수 ---
    [Header("Object References")]
    public Transform inputPoint;
    public Transform processingPoint;
    public Transform outputBufferPoint;
    // public ShuttleController shuttleController; // 셔틀이 직접 참조하므로 여기선 없어도 됨

    // --- 시간 관련 파라미터 ---
    [Header("Timing Parameters (sec)")]
    public float moveToProcessingTime = 1.0f;
    public float backupTime = 0.5f;
    public float preparePrintTime = 0.8f;
    public float printingTime = 2.0f;
    public float tableDownTime = 0.5f;
    public float moveToOutputTime = 1.0f;
    public float shortCleanTime = 3.0f;
    public float longCleanTime = 10.0f;
    public float repairTime = 30.0f;

    // --- 운영 관련 파라미터 ---
    [Header("Operational Parameters")]
    public int shortCleanCycle = 3;
    public int longCleanCycle = 10;
    [Range(0f, 0.1f)] public float failureRatePerSecond = 0.001f;

    // --- 상태 변수 (읽기 전용) ---
    [Header("Status (Read Only)")]
    public PCBController currentPCB = null;
    public PCBController pcbInOutBuffer = null;
    public int processedCountTotal = 0;
    public int processedSinceLastClean = 0;
    private float timeToFailure;
    private bool isProcessingCoroutineRunning = false;

    // --- 외부 접근용 속성 (Properties) ---
    // CS1955 에러 관련: 아래는 '속성'이므로 사용할 때 괄호() 없이 사용해야 합니다.
    // 예: if (printer.IsReadyToReceive) { ... }
    public bool IsReadyToReceive => currentState == PrinterState.Idle && currentPCB == null && !isProcessingCoroutineRunning;
    public bool HasPCBInOutBuffer => pcbInOutBuffer != null;

    // --- Unity 메시지 함수 ---
    void Start()
    {
        CalculateTimeToFailure();
    }

    void Update()
    {
        // 고장 발생 체크
        if (failureRatePerSecond > 0 && !isProcessingCoroutineRunning && currentState != PrinterState.Down && currentState != PrinterState.Cleaning)
        {
            timeToFailure -= Time.deltaTime;
            if (timeToFailure <= 0)
            {
                if (!isProcessingCoroutineRunning)
                    StartCoroutine(GoDown());
            }
        }
    }

    // --- 핵심 로직 함수 및 코루틴 ---

    // InputTrigger가 호출하여 PCB를 넘겨줌
    public void AssignPCB(PCBController pcb)
    {
        // IsReadyToReceive 는 속성이므로 괄호 없이 사용
        if (IsReadyToReceive)
        {
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Receiving PCB {pcb.id}");
            currentPCB = pcb;
            currentPCB.transform.position = inputPoint.position;
            currentState = PrinterState.Receiving;
            isProcessingCoroutineRunning = true;
            StartCoroutine(ProcessSequence());
        }
        else
        {
            Debug.LogError($"[{Time.time:F1}s] {gameObject.name}: Tried to assign PCB {pcb.id} while not ready! State: {currentState}, Has PCB: {currentPCB != null}");
            Destroy(pcb.gameObject);
        }
    }

    // 전체 처리 시퀀스 코루틴
    private IEnumerator ProcessSequence()
    {
        currentState = PrinterState.MovingToProcessing;
        yield return StartCoroutine(MoveObject(currentPCB.transform, processingPoint.position, moveToProcessingTime));
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }

        currentState = PrinterState.BackingUp; yield return new WaitForSeconds(backupTime);
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.PreparingPrint; yield return new WaitForSeconds(preparePrintTime);
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.Printing; yield return new WaitForSeconds(printingTime);
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        currentState = PrinterState.TableDown; yield return new WaitForSeconds(tableDownTime);
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }

        processedCountTotal++;
        processedSinceLastClean++;

        bool needsLongClean = processedCountTotal % longCleanCycle == 0;
        bool needsShortClean = !needsLongClean && (processedSinceLastClean >= shortCleanCycle);

        if (needsLongClean || needsShortClean)
        {
            currentState = PrinterState.Cleaning;
            float cleanTime = needsLongClean ? longCleanTime : shortCleanTime;
            string cleanType = needsLongClean ? "LONG" : "SHORT";
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Starting {cleanType} clean ({cleanTime}s).");
            yield return new WaitForSeconds(cleanTime);
            processedSinceLastClean = 0;
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: {cleanType} clean finished.");
            if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }
        }

        currentState = PrinterState.MovingToOutput;
        yield return StartCoroutine(MoveObject(currentPCB.transform, outputBufferPoint.position, moveToOutputTime));
        if (currentState == PrinterState.Down) { isProcessingCoroutineRunning = false; yield break; }

        pcbInOutBuffer = currentPCB;
        currentPCB = null;
        currentState = PrinterState.WaitingForShuttle;
        Debug.Log($"[{Time.time:F1}s] {gameObject.name}: PCB {pcbInOutBuffer.id} waiting for shuttle.");
        isProcessingCoroutineRunning = false;
    }

    // 셔틀이 호출하여 PCB를 가져감
    public PCBController ReleasePCBToShuttle()
    {
        // HasPCBInOutBuffer 는 속성이므로 괄호 없이 사용 (여기서는 직접 상태 체크)
        if (currentState == PrinterState.WaitingForShuttle && pcbInOutBuffer != null)
        {
            PCBController pcbToRelease = pcbInOutBuffer;
            pcbInOutBuffer = null;
            currentState = PrinterState.Idle;
            Debug.Log($"[{Time.time:F1}s] {gameObject.name}: Released PCB {pcbToRelease.id} to shuttle.");
            return pcbToRelease;
        }
        Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name}: Shuttle tried to pick up but no PCB ready or wrong state ({currentState}).");
        return null;
    }

    // 이동 코루틴
    private IEnumerator MoveObject(Transform objTransform, Vector3 targetPosition, float duration)
    {
        if(objTransform == null) yield break;
        Vector3 startPosition = objTransform.position;
        float elapsedTime = 0f;
        while (elapsedTime < duration)
        {
            if (currentState == PrinterState.Down) yield break;
            if(objTransform == null) yield break;
            objTransform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        if(objTransform != null) objTransform.position = targetPosition;
    }

    // 고장 처리 코루틴
    private IEnumerator GoDown()
    {
        if(currentState == PrinterState.Down) yield break;
        PrinterState previousState = currentState;
        currentState = PrinterState.Down;
        Debug.LogError($"[{Time.time:F1}s] {gameObject.name} is DOWN! (Was {previousState})");
        if (currentPCB != null)
        {
            Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name}: Discarding current PCB {currentPCB.id} due to failure.");
            Destroy(currentPCB.gameObject);
            currentPCB = null;
        }
        isProcessingCoroutineRunning = false;
        yield return new WaitForSeconds(repairTime);
        Debug.LogWarning($"[{Time.time:F1}s] {gameObject.name} has been repaired.");
        currentState = PrinterState.Idle;
        CalculateTimeToFailure();
    }

    // 다음 고장 시간 계산
    void CalculateTimeToFailure()
    {
        if (failureRatePerSecond > 0)
            timeToFailure = -Mathf.Log(Random.value) / failureRatePerSecond;
        else
            timeToFailure = float.PositiveInfinity;
    }
}
2. ShuttleController.cs (전체 코드)

C#

using UnityEngine;
using System.Collections;

public class ShuttleController : MonoBehaviour
{
    // --- 상태 정의 ---
    public enum ShuttleState { Idle, MovingToFront, PickingFront, MovingToRear, PickingRear, MovingToExit, Delivering }
    [Header("State")]
    public ShuttleState currentState = ShuttleState.Idle;

    // --- 참조 변수 ---
    [Header("Object References")]
    public PrinterController frontPrinter;
    public PrinterController rearPrinter;
    public Transform frontPickupLocation; // Inspector에서 FrontPrinter->OutputBufferPoint 할당
    public Transform rearPickupLocation;  // Inspector에서 RearPrinter->OutputBufferPoint 할당
    public Transform shuttlePickupPoint; // 셔틀 위 PCB 위치
    public Transform exitPoint;

    // --- 이동 관련 파라미터 ---
    [Header("Movement Parameters")]
    public float moveSpeed = 4.0f;
    public float pickupDelay = 0.5f;

    // --- 상태 변수 (읽기 전용) ---
    [Header("Status (Read Only)")]
    public PCBController carriedPCB = null;
    private bool preferFront = true;
    private bool isShuttleBusy = false;

    // --- Unity 메시지 함수 ---
    void Update()
    {
        if (currentState == ShuttleState.Idle && !isShuttleBusy)
        {
            DecideNextAction();
        }
    }

    // --- 핵심 로직 함수 및 코루틴 ---

    // 다음 행동 결정
    void DecideNextAction()
    {
        // CS1955 에러 관련: HasPCBInOutBuffer는 속성이므로 괄호() 없이 접근합니다.
        bool frontReady = frontPrinter.HasPCBInOutBuffer;
        bool rearReady = rearPrinter.HasPCBInOutBuffer;

        PrinterController targetPrinter = null;
        Transform targetLocation = null;
        ShuttleState movingState = ShuttleState.Idle;
        ShuttleState pickingState = ShuttleState.Idle;

        if (frontReady && rearReady)
        {
            if (preferFront) { targetPrinter = frontPrinter; targetLocation = frontPickupLocation; movingState = ShuttleState.MovingToFront; pickingState = ShuttleState.PickingFront; }
            else { targetPrinter = rearPrinter; targetLocation = rearPickupLocation; movingState = ShuttleState.MovingToRear; pickingState = ShuttleState.PickingRear; }
            preferFront = !preferFront;
        }
        else if (frontReady)
        {
            targetPrinter = frontPrinter; targetLocation = frontPickupLocation; movingState = ShuttleState.MovingToFront; pickingState = ShuttleState.PickingFront;
            preferFront = false;
        }
        else if (rearReady)
        {
            targetPrinter = rearPrinter; targetLocation = rearPickupLocation; movingState = ShuttleState.MovingToRear; pickingState = ShuttleState.PickingRear;
            preferFront = true;
        }

        if (targetPrinter != null)
        {
            isShuttleBusy = true;
            StartCoroutine(GoPickAndDeliver(targetPrinter, targetLocation, movingState, pickingState));
        }
    }

    // 픽업 및 배달 코루틴
    private IEnumerator GoPickAndDeliver(PrinterController targetPrinter, Transform targetPickupLoc, ShuttleState movingState, ShuttleState pickingState)
    {
        currentState = movingState;
        Debug.Log($"[{Time.time:F1}s] {name}: Moving to {targetPrinter.name}");
        yield return StartCoroutine(MoveShuttle(targetPickupLoc.position));

        currentState = pickingState;
        Debug.Log($"[{Time.time:F1}s] {name}: Attempting pickup from {targetPrinter.name}");

        // CS1955 에러 관련: ReleasePCBToShuttle은 메서드이므로 괄호()를 붙여 호출합니다.
        PCBController pcb = targetPrinter.ReleasePCBToShuttle();

        if (pcb != null)
        {
            yield return new WaitForSeconds(pickupDelay);
            carriedPCB = pcb;
            carriedPCB.transform.SetParent(shuttlePickupPoint, true);
            carriedPCB.transform.localPosition = Vector3.zero;
            Debug.Log($"[{Time.time:F1}s] {name}: Picked up PCB {carriedPCB.id}");

            currentState = ShuttleState.MovingToExit;
            Debug.Log($"[{Time.time:F1}s] {name}: Moving to Exit with PCB {carriedPCB.id}");
            yield return StartCoroutine(MoveShuttle(exitPoint.position));

            currentState = ShuttleState.Delivering;
            Debug.Log($"[{Time.time:F1}s] {name}: Delivering PCB {carriedPCB.id}");
            carriedPCB.transform.SetParent(null);
            carriedPCB.CalculateAndLogCycleTime();
            Destroy(carriedPCB.gameObject);
            carriedPCB = null;
        }
        else
        {
            Debug.LogWarning($"[{Time.time:F1}s] {name}: Failed pickup from {targetPrinter.name}. PCB might have been removed.");
        }

        currentState = ShuttleState.Idle;
        isShuttleBusy = false;
        Debug.Log($"[{Time.time:F1}s] {name}: Returning to Idle.");
    }

    // 셔틀 이동 코루틴
    private IEnumerator MoveShuttle(Vector3 targetPosition)
    {
        Vector3 startPosition = transform.position;
        float distance = Vector3.Distance(startPosition, targetPosition);
        if (distance < 0.01f) yield break;

        float duration = distance / moveSpeed;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = targetPosition;
    }
}
사용 방법:

Visual Studio에서 PrinterController.cs 파일을 엽니다.
파일의 모든 내용을 삭제합니다.
위에 제공된 PrinterController.cs 코드를 전체 복사하여 붙여넣습니다.
파일을 저장합니다.
Visual Studio에서 ShuttleController.cs 파일을 엽니다.
파일의 모든 내용을 삭제합니다.
위에 제공된 ShuttleController.cs 코드를 전체 복사하여 붙여넣습니다.
파일을 저장합니다.
(혹시 모르니) InputTrigger.cs 파일도 열어서 targetPrinter.IsReadyToReceive 부분에 괄호 ()가 없는지 확인합니다. (이전에 제공된 코드는 정상입니다.)
모든 파일을 저장한 후, Unity 에디터로 돌아가서 오류 목록(Error List) 또는 Console 창에 CS1955 오류가 사라졌는지 확인합니다.
이제 이 코드로 교체하면 속성을 잘못된 방식으로 호출해서 발생했던 CS1955 오류는