ì¸¡í•  ë•Œ vectorize_qr() í•¨ìˆ˜ëŠ” QR ì½”ë“œë§Œ ë²¡í„°í™” (ì…ë ¥ í¬ê¸° = max_length=10)
í•˜ì§€ë§Œ í›ˆë ¨í•  ë•ŒëŠ” vectorize_qr_with_line()ì„ ì‚¬ìš©í•˜ì—¬ QR + Line (11ì°¨ì›) ë²¡í„°í™”
ê²°ê³¼ì ìœ¼ë¡œ ì˜ˆì¸¡ ì…ë ¥ í¬ê¸°(10) â‰  ëª¨ë¸ ì…ë ¥ í¬ê¸°(11) â†’ í–‰ë ¬ í¬ê¸° ë¶ˆì¼ì¹˜ ì—ëŸ¬ ë°œìƒ
âœ… í•´ê²° ë°©ë²•:

ì˜ˆì¸¡ ì‹œì—ë„ vectorize_qr() ëŒ€ì‹  ëª¨ë¸ ì…ë ¥ í¬ê¸°ì— ë§ê²Œ 11ì°¨ì›ìœ¼ë¡œ ë³€í™˜
ë§ˆì§€ë§‰ ì»¬ëŸ¼(ë¼ì¸ ì •ë³´)ì—ëŠ” ë”ë¯¸ ê°’ 0 ì¶”ê°€
âœ… ì˜ˆì¸¡ ë¶€ë¶„ ìˆ˜ì • (ë§ˆì§€ë§‰ ì°¨ì› ë§ì¶”ê¸°)
ğŸ”¹ ê¸°ì¡´ ì˜ˆì¸¡ ì½”ë“œ (ì—ëŸ¬ ë°œìƒ)
python
Copy code
X_vectorized = vectorize_qr([qr_value], max_length=10)  # ğŸ”¥ ë¬¸ì œ ë°œìƒ (10ì°¨ì›)
ğŸ”¹ ìˆ˜ì •ëœ ì˜ˆì¸¡ ì½”ë“œ (ì…ë ¥ í¬ê¸° 11ë¡œ ë§ì¶¤)
python
Copy code
def predict_qr(model, model_encoder, qr_value, max_length):
    device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
    
    # ğŸ”¹ QR ì½”ë“œë§Œ ë³€í™˜
    X_vectorized = vectorize_qr([qr_value], max_length=max_length)  # (1, 10) í¬ê¸°
    
    # ğŸ”¹ ë§ˆì§€ë§‰ ì»¬ëŸ¼ì— ë”ë¯¸ ë¼ì¸ ê°’(0) ì¶”ê°€í•˜ì—¬ ëª¨ë¸ ì…ë ¥ í¬ê¸°(11)ë¡œ ë§ì¶¤
    X_vectorized = np.pad(X_vectorized, ((0, 0), (0, 1)), mode='constant', constant_values=0)  # (1, 11) í¬ê¸°
    
    # ğŸ”¹ ì˜ˆì¸¡ ìˆ˜í–‰
    model.eval()
    with torch.no_grad():
        inputs = torch.tensor(X_vectorized, dtype=torch.float32).to(device)
        outputs = model(inputs)
        predicted = torch.argmax(outputs, dim=1).cpu().numpy()[0]

    predicted_model = model_encoder.inverse_transform([predicted])[0]
    print(f"âœ… ì˜ˆì¸¡ëœ ëª¨ë¸: {predicted_model}")
ğŸ“Œ ìš”ì•½
1ï¸âƒ£ í›ˆë ¨í•  ë•Œ â†’ vectorize_qr_with_line() ì‚¬ìš© (ì…ë ¥ í¬ê¸° 11)
2ï¸âƒ£ ì˜ˆì¸¡í•  ë•Œ â†’ vectorize_qr() ì‚¬ìš©í•˜ë©´ 10ì°¨ì›ì´ë¼ ì—ëŸ¬ ë°œìƒ