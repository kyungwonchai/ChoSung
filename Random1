, 프로그램을 닫을 때 로딩 관련 오류들이 발생하는 것은 종료 프로세스와 아직 진행 중인 비동기 데이터 로딩 작업 간의 충돌 때문일 가능성이 높습니다. 창이 닫히면서 ViewModel의 Dispose 메서드가 호출되고 내부적으로 DbContext가 해제되는데, await 구문 이후에 재개된 비동기 로딩 코드가 이미 해제된 DbContext에 접근하려고 시도하면서 오류가 발생하는 것입니다.

이전 단계에서 CancellationToken과 _disposed 플래그를 추가했지만, await 이후에 상태를 다시 한번 확인하는 로직을 강화하여 이 문제를 해결해 보겠습니다.

프로그램 종료 시 실행되는 함수 (관련):

MainWindow.xaml.cs -> MainWindow_Closing 이벤트 핸들러
MainViewModel.cs -> Dispose 메서드 (여기서 _cts.Cancel() 및 _context.Dispose(), LogVM.Dispose() 호출)
LogViewModel.cs -> Dispose 메서드 (여기서 자신의 _cts.Cancel() 및 _context.Dispose() 호출)
각 ViewModel의 비동기 로딩 메서드 (LoadAssignmentsAsync, LoadMasterDataAsync, LoadLogsAsync) 내의 await 이후 코드
수정해야 할 파일 목록:

ViewModels/MainViewModel.cs (LoadAssignmentsAsync 등에서 await 이후 상태 확인 강화)
ViewModels/LogViewModel.cs (LoadLogsAsync에서 await 이후 상태 확인 강화)
아래에 이 두 파일의 수정된 전체 코드를 작성합니다.

1. ViewModels/MainViewModel.cs (수정)

LoadAssignmentsAsync와 LoadMasterDataAsync 내부에서 await 호출 이후에 _cts.IsCancellationRequested 또는 _disposed 상태를 다시 확인하는 로직을 추가합니다.

C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Security;
using System.Threading; // CancellationTokenSource 사용
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (종료 시 오류 방지 강화)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;

        #region Public Properties (이전과 동일)
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands (CanExecute에 _disposed 조건 추가)
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            // Command 초기화 시 CanExecute에 _disposed 조건 추가
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync(), _ => !_disposed);
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync(), _ => !_disposed && CanSaveChangesExecute()); // CanSaveChangesExecute 추가
            AddNewCommand = new RelayCommand(AddNewLocker, _ => !_disposed);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => !_disposed && SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => !_disposed && SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword, _ => !_disposed);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync(), _ => !_disposed);
            OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow, _ => !_disposed);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        // SaveChanges 가능 여부 (간단 버전)
        private bool CanSaveChangesExecute() => _context != null && _context.ChangeTracker.HasChanges();


        private async Task LoadInitialDataAsync() { if (_disposed || _cts.IsCancellationRequested) return; await LoadMasterDataAsync(); if (_disposed || _cts.IsCancellationRequested) return; await LoadAssignmentsAsync(); }

        /// <summary>
        /// 사물함 배정 목록 로드 (await 이후 상태 확인 강화)
        /// </summary>
        private async Task LoadAssignmentsAsync()
        {
            if (_context == null || _disposed || _cts.IsCancellationRequested) return;
            StatusBarText = "사물함 목록 로딩 중...";
            try
            {
                var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList();
                if (trackedAssignments.Any()) { foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; }

                // *** 수정: await 이후 CancellationToken 및 _disposed 재확인 ***
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation)
                                               .ToListAsync(_cts.Token);

                // await 이후 작업이 취소되었거나 ViewModel이 Dispose되었는지 다시 확인
                if (_cts.IsCancellationRequested || _disposed)
                {
                    Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨 (await 이후).");
                    return;
                }

                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료.";
            }
            catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 취소됨."; }
            catch (ObjectDisposedException) { Debug.WriteLine("LoadAssignmentsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 오류 (컨텍스트 해제됨)."; }
            catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("사물함 목록 로딩", ex); }
        }

        /// <summary>
        /// 마스터 데이터 목록 로드 (await 이후 상태 확인 강화)
        /// </summary>
        private async Task LoadMasterDataAsync()
        {
            if (_disposed || _cts.IsCancellationRequested) return; // 시작 전 확인
            StatusBarText = "마스터 데이터(콤보박스용) 로딩 중...";
            LockerDbContext tempContext = null;
            try
            {
                using (tempContext = new LockerDbContext())
                {
                    // 각 await 호출 후 CancellationToken 및 _disposed 상태 확인 추가
                    var types = await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token);
                    if (_cts.IsCancellationRequested || _disposed) return;
                    AllLockerTypes = new ObservableCollection<LockerType>(types);

                    var floors = await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token);
                    if (_cts.IsCancellationRequested || _disposed) return;
                    AllFloors = new ObservableCollection<Floor>(floors);

                    var zones = await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token);
                    if (_cts.IsCancellationRequested || _disposed) return;
                    AllZones = new ObservableCollection<Zone>(zones);

                    var subParts = await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token);
                    if (_cts.IsCancellationRequested || _disposed) return;
                    AllSubParts = new ObservableCollection<SubPart>(subParts);

                    var administrators = await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token);
                    if (_cts.IsCancellationRequested || _disposed) return;
                    AllAdministrators = new ObservableCollection<Administrator>(administrators);

                    if (!_cts.IsCancellationRequested && !_disposed) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료.";
                }
            }
            catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 취소됨."; }
            catch (ObjectDisposedException) { Debug.WriteLine("LoadMasterDataAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 오류 (컨텍스트 해제됨)."; }
            catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { if (!_cts.IsCancellationRequested && !_disposed) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } }
            catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩", ex); }
        }

        // CheckMasterPassword, OpenMasterDataWindow (이전과 동일)
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드 (CancellationToken 전달 추가)
        private async Task SaveChangesAsync() { if (_context == null || _disposed || !CanSaveChangesExecute()) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private bool CanSaveChangesExecute() { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } } // CanExecute용 헬퍼
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null || _disposed) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); } // 저장 버튼 상태 갱신
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null || _disposed || _cts.IsCancellationRequested) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null || _disposed) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); } // 저장 버튼 상태 갱신
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { /* ... */ return true; }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { /* ... */ }
        private string EscapeCsvValue(string value) { /* ... */ return value; }
        #endregion

        #region Helper Methods (이전과 동일)
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (CancellationToken 취소 및 Dispose 플래그 확인)
        // private bool disposed = false; // 클래스 멤버 변수로 이동됨
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed)
            {
                if (disposing)
                {
                    Debug.WriteLine("MainViewModel Dispose 시작...");
                    _cts?.Cancel(); // 진행 중인 비동기 작업 취소 요청
                    _cts?.Dispose();
                    _context?.Dispose(); // DbContext 해제
                    LogVM?.Dispose();    // LogViewModel 해제
                    Debug.WriteLine("MainViewModel 리소스 해제 완료.");
                }
                _disposed = true; // Dispose 되었음을 플래그로 표시
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
2. ViewModels/LogViewModel.cs (수정)

LoadLogsAsync 내부에서 await 이후에 _cts.IsCancellationRequested 또는 _disposed 상태를 다시 확인하는 로직을 추가합니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Diagnostics;
using System.Linq;
using System.Threading; // CancellationTokenSource 사용
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 감사 로그 조회 ViewModel (Dispose 오류 수정 최종)
    /// </summary>
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private ObservableCollection<AuditLog> _auditLogs;
        private string _statusMessage;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false; // Dispose 플래그 추가

        public ObservableCollection<AuditLog> AuditLogs { get => _auditLogs; set => SetProperty(ref _auditLogs, value); }
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        public LogViewModel()
        {
            AuditLogs = new ObservableCollection<AuditLog>();
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[Log] DB 연결 오류!"; LoadLogsCommand = new RelayCommand(_ => { }, _ => !_disposed); return; } // CanExecute 조건 추가

            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync(), _ => !_disposed && _context != null); // CanExecute 조건 추가

            if (_context != null) { _ = LoadLogsAsync(); }
        }

        /// <summary>
        /// 감사 로그를 비동기적으로 로드합니다. (CancellationToken 및 Dispose 확인 강화)
        /// </summary>
        public async Task LoadLogsAsync()
        {
            // *** 수정: 메서드 시작 시 _disposed 및 취소 상태 확인 ***
            if (_context == null || _disposed || _cts.IsCancellationRequested) return;
            StatusMessage = "로그 로딩 중...";
            (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged(); // 로딩 중 버튼 비활성화

            try
            {
                // *** 수정: ToListAsync 호출 전 다시 확인 ***
                if (_disposed || _cts.IsCancellationRequested) return;

                var logs = await _context.AuditLogs
                                         .OrderByDescending(log => log.Timestamp)
                                         .Take(1000)
                                         .AsNoTracking()
                                         .ToListAsync(_cts.Token); // 취소 토큰 전달

                // *** 수정: UI 업데이트 전 다시 확인 ***
                if (_disposed || _cts.IsCancellationRequested)
                {
                     Debug.WriteLine("LoadLogsAsync 작업 취소됨 (await 이후).");
                     return;
                }

                // 새 컬렉션 할당 방식으로 UI 업데이트
                AuditLogs = new ObservableCollection<AuditLog>(logs);
                StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
            }
            catch (OperationCanceledException)
            {
                Debug.WriteLine("LoadLogsAsync 작업 취소됨.");
                if (!_disposed) StatusMessage = "로그 로딩 취소됨.";
            }
            catch (ObjectDisposedException)
            {
                 Debug.WriteLine("LoadLogsAsync 실행 중 DbContext가 Dispose됨.");
                 if (!_disposed) StatusMessage = "로그 로딩 중 오류 발생 (컨텍스트 해제됨).";
            }
            catch (Exception ex)
            {
                if (!_disposed && !_cts.IsCancellationRequested)
                {
                    StatusMessage = $"로그 로딩 오류: {ex.Message}";
                    MessageBox.Show($"{StatusMessage}\n\n데이터베이스 연결 및 로그 테이블 상태를 확인하세요.", "로그 로딩 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
            finally
            {
                 if (!_disposed) (LoadLogsCommand as RelayCommand)?.RaiseCanExecuteChanged(); // 로딩 완료 후 버튼 상태 갱신
            }
        }

        #region IDisposable 구현 (CancellationToken 취소 및 _disposed 플래그 설정)
        // private bool disposed = false; // 클래스 멤버 변수로 이동됨
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed) // 중복 Dispose 방지
            {
                if (disposing)
                {
                    Debug.WriteLine("LogViewModel Dispose 시작...");
                    _cts?.Cancel(); // 진행 중인 비동기 작업 취소 요청
                    _cts?.Dispose();
                    _context?.Dispose(); // DbContext 해제
                    Debug.WriteLine("LogViewModel 리소스 해제 완료.");
                }
                _disposed = true; // Dispose 되었음을 플래그로 표시
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
핵심 변경 사항:

MainViewModel.cs / LogViewModel.cs:
CancellationTokenSource (_cts) 및 _disposed 플래그를 추가했습니다.
Dispose 메서드에서 _cts.Cancel()을 호출하여 진행 중인 비동기 작업을 취소하고 _disposed 플래그를 설정합니다.
LoadAssignmentsAsync, LoadMasterDataAsync, LoadLogsAsync 등 비동기 메서드 내부에서 await 호출 전후로 _cts.IsCancellationRequested와 _disposed를 확인하여, 작업이 취소되었거나 객체가 이미 해제된 경우 불필요한 작업을 중단하고 오류를 방지합니다.
비동기 DB 호출(ToListAsync, SaveChangesAsync) 시 _cts.Token을 전달합니다.
OperationCanceledException 및 ObjectDisposedException을 catch 블록에서 처리합니다.