네, 괜찮습니다! SControl.Common 라이브러리의 코드를 다시 제공해 드리겠습니다.

이 코드는 바로 이전에 제공해 드린 SAgentM.Service의 코드와 호환되도록 구성되어 있으며, 두 프로젝트 간의 데이터 교환 및 공통 기능의 핵심 역할을 합니다.

SControl.Common 프로젝트 코드 (재제공)
1. Enums.cs

통신 및 동작에 사용될 주요 열거형들을 정의합니다.
<!-- end list -->

C#

// SControl.Common/Enums.cs
namespace SControl.Common
{
    /// <summary>
    /// 명령 패킷의 처리 방식을 정의합니다. SAgentM이 수신한 패킷을 어떻게 처리할지 결정합니다.
    /// </summary>
    public enum CommandInstruction
    {
        /// <summary>
        /// 명령을 현재 SAgentM에서 직접 실행합니다.
        /// </summary>
        DirectExecute,

        /// <summary>
        /// 명령을 지정된 다음 대상 SAgentM으로 중계(릴레이)합니다.
        /// </summary>
        RelayToTarget
    }

    /// <summary>
    /// 실행 또는 중계될 명령의 고유한 이름들을 정의하는 상수 클래스입니다.
    /// </summary>
    public static class CommandNames
    {
        /// <summary>
        /// 모니터 제어 관련 명령을 나타냅니다.
        /// </summary>
        public const string MonitorControl = "MONITOR_CONTROL";

        // --- 향후 확장 가능한 명령 이름 예시 ---
        // /// <summary>
        // /// 시스템 종료 관련 명령을 나타냅니다.
        // /// </summary>
        // public const string SystemShutdown = "SYSTEM_SHUTDOWN";

        // --- 응답을 위한 CommandName 규칙 (예시) ---
        // public static string GetResponseCommandName(string requestCommandName)
        // {
        //     return $"{requestCommandName}_Response";
        // }
    }

    /// <summary>
    /// 모니터 제어 동작의 종류를 정의합니다. (Windows SC_MONITORPOWER 메시지 값 기준)
    /// </summary>
    public enum MonitorAction
    {
        /// <summary>
        /// 모니터를 켭니다 (SC_MONITORPOWER: -1).
        /// </summary>
        On = -1,

        /// <summary>
        /// 모니터를 절전 모드로 전환합니다 (SC_MONITORPOWER: 1).
        /// </summary>
        Standby = 1,

        /// <summary>
        /// 모니터를 끕니다 (SC_MONITORPOWER: 2).
        /// </summary>
        Off = 2
    }
}
2. Payloads.cs

각 명령어(CommandNames)에 대한 구체적인 데이터를 담는 클래스들을 정의합니다.
<!-- end list -->

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    /// <summary>
    /// 모니터 제어 명령(CommandNames.MonitorControl)을 위한 페이로드입니다.
    /// 어떤 모니터 동작을 수행할지 지정합니다.
    /// </summary>
    public class MonitorControlPayload
    {
        /// <summary>
        /// 수행할 모니터 동작 (On, Off, Standby) 입니다.
        /// </summary>
        public MonitorAction Action { get; set; }
    }

    /// <summary>
    /// 명령어 실행 결과 등을 담을 수 있는 일반적인 응답 페이로드 예시입니다.
    /// CommandHandler에서 이와 유사한 구조를 익명 타입으로 직렬화하여 사용했습니다.
    /// 필요하다면 특정 응답에 맞는 구체적인 페이로드 클래스를 정의할 수 있습니다.
    /// </summary>
    public class GenericResponsePayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string? ErrorCode { get; set; } // 선택적 오류 코드
        public object? Data { get; set; }      // 선택적 추가 데이터
    }

    // --- 다른 명령에 대한 페이로드 클래스 예시 (필요시 주석 해제 및 구체화) ---
    // /// <summary>
    // /// 시스템 종료 명령(CommandNames.SystemShutdown)을 위한 페이로드입니다.
    // /// </summary>
    // public class SystemShutdownPayload
    // {
    //     /// <summary>
    //     /// 종료 전 대기 시간(초)입니다. 0이면 즉시 종료를 의미합니다.
    //     /// </summary>
    //     public int DelaySeconds { get; set; }
    //
    //     /// <summary>
    //     /// 실행 중인 애플리케이션을 강제로 종료할지 여부입니다.
    //     /// </summary>
    //     public bool ForceShutdown { get; set; }
    // }
}
Payloads.cs 변경점:

GenericResponsePayload 예시 클래스를 추가했습니다. SAgentM.Service의 CommandHandler에서 응답 생성 시 익명 타입을 사용했는데, 이처럼 명시적인 DTO를 정의하여 사용할 수도 있습니다. 이는 SControlM에서 응답을 파싱할 때 더 명확한 타입을 제공할 수 있습니다.
3. CommandPacket.cs

SControlM과 SAgentM 간에 주고받을 실제 통신 데이터 패킷의 구조를 정의합니다.
<!-- end list -->

C#

// SControl.Common/CommandPacket.cs
using System;

namespace SControl.Common
{
    /// <summary>
    /// SControlM과 SAgentM 간 통신에 사용될 기본 명령 패킷입니다.
    /// 이 패킷은 일반적으로 JSON 형태로 직렬화되어 소켓을 통해 전송됩니다.
    /// </summary>
    public class CommandPacket
    {
        /// <summary>
        /// 패킷의 고유 식별자입니다. 요청 추적, 로깅 등에 사용될 수 있습니다.
        /// </summary>
        public Guid PacketId { get; set; }

        /// <summary>
        /// 이 패킷을 수신한 SAgentM이 취해야 할 주된 행동(지시)입니다.
        /// </summary>
        public CommandInstruction Instruction { get; set; }

        /// <summary>
        /// 실행되거나 중계될 실제 명령의 이름입니다 (예: CommandNames.MonitorControl).
        /// 이 이름에 따라 PayloadJson의 내용을 적절한 페이로드 타입으로 역직렬화해야 합니다.
        /// 응답의 경우, 요청 CommandName에 "_Response" 접미사가 붙는 규칙을 사용할 수 있습니다.
        /// </summary>
        public string CommandName { get; set; }

        /// <summary>
        /// CommandName에 해당하는 명령의 실제 인자(데이터)들을 JSON 문자열로 직렬화한 값입니다.
        /// 예: MonitorControlPayload 객체를 JSON으로 변환한 문자열.
        /// (System.Text.Json.JsonSerializer 사용 권장)
        /// </summary>
        public string? PayloadJson { get; set; } // 페이로드가 없는 명령도 있을 수 있으므로 nullable

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용됨]
        /// 이 명령 패킷(CommandName, PayloadJson)을 최종적으로 전달받아 실행할 SAgentM의 IP 주소입니다.
        /// 중계 SAgentM은 이 주소로 새로운 DirectExecute 패킷을 생성하여 전송합니다.
        /// </summary>
        public string? FinalTargetIpForRelayedCommand { get; set; }

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용됨]
        /// FinalTargetIpForRelayedCommand의 SAgentM 포트 번호입니다.
        /// </summary>
        public int? FinalTargetPortForRelayedCommand { get; set; }

        /// <summary>
        /// 이 패킷이 생성된 시간 (UTC 기준)입니다.
        /// 타임아웃 처리, 순서 보정 등에 활용될 수 있습니다.
        /// </summary>
        public DateTime TimestampUtc { get; set; }

        /// <summary>
        /// [주로 요청 패킷에 사용됨]
        /// 이 요청에 대한 응답을 수신할 SControlM 또는 중간 SAgentM의 IP 주소입니다.
        /// 단방향 명령이거나 응답이 필요 없는 경우 null일 수 있습니다.
        /// </summary>
        public string? ResponseAddress { get; set; }

        /// <summary>
        /// [주로 요청 패킷에 사용됨]
        /// 이 요청에 대한 응답을 수신할 SControlM 또는 중간 SAgentM의 포트 번호입니다.
        /// </summary>
        public int? ResponsePort { get; set; }

        // /// <summary>
        // /// 이 패킷이 응답 패킷인지 여부를 나타냅니다. (선택적 필드)
        // /// </summary>
        // public bool IsResponse { get; set; } = false;


        /// <summary>
        /// 기본 생성자. PacketId와 TimestampUtc를 자동으로 초기화합니다.
        /// </summary>
        public CommandPacket()
        {
            PacketId = Guid.NewGuid();
            TimestampUtc = DateTime.UtcNow;
        }
    }
}
4. LocalDeviceControl.cs

P/Invoke를 사용하여 로컬 PC의 하드웨어(여기서는 모니터)를 제어하는 함수를 제공합니다.
<!-- end list -->

C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 사용

namespace SControl.Common
{
    /// <summary>
    /// P/Invoke를 사용하여 로컬 장치를 제어하는 유틸리티 클래스입니다.
    /// 현재는 모니터 전원 제어 기능을 제공합니다.
    /// </summary>
    public static class LocalDeviceControl
    {
        // Windows API 상수 정의
        private const int HWND_BROADCAST = 0xFFFF;    // 메시지를 모든 최상위 창에 브로드캐스트
        private const uint WM_SYSCOMMAND = 0x0112;    // 시스템 명령 메시지 ID
        private const uint SC_MONITORPOWER = 0xF170;  // 모니터 전원 관련 시스템 명령 ID

        // SC_MONITORPOWER의 lParam 값은 MonitorAction enum 값과 일치시킴

        // user32.dll의 SendMessageTimeout 함수 선언
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,                     // 메시지를 받을 창의 핸들. HWND_BROADCAST 사용 가능.
            uint Msg,                        // 보낼 메시지 (WM_SYSCOMMAND).
            UIntPtr wParam,                  // 메시지의 첫 번째 파라미터 (SC_MONITORPOWER).
            IntPtr lParam,                   // 메시지의 두 번째 파라미터 (모니터 상태 코드). MonitorAction enum 값을 IntPtr로 변환하여 사용.
            SendMessageTimeoutFlags fuFlags, // 메시지 전송 방법 플래그.
            uint uTimeout,                   // 타임아웃 시간 (밀리초).
            out UIntPtr lpdwResult);         // 메시지 처리 결과 (거의 사용되지 않음).

        /// <summary>
        /// SendMessageTimeout 함수의 동작 방식을 지정하는 플래그입니다.
        /// </summary>
        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,            // 기본 동작.
            SMTO_BLOCK = 0x1,             // 호출 스레드는 메시지 처리 완료까지 대기.
            SMTO_ABORTIFHUNG = 0x2,       // 대상 프로세스가 응답하지 않으면 타임아웃 후 즉시 반환.
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8, // 대상이 응답 중이면 타임아웃 적용 안 함 (주의해서 사용).
            SMTO_ERRORONEXIT = 0x20       // (Windows Vista 이상) 함수가 반환되기 전에 발생한 오류를 GetLastError로 확인 가능하게 함.
        }

        /// <summary>
        /// 로컬 PC의 모니터 전원 상태를 변경합니다.
        /// </summary>
        /// <param name="action">수행할 모니터 동작 (On, Off, Standby).</param>
        /// <exception cref="Win32Exception">Windows API 호출 실패 시 발생합니다.</exception>
        /// <exception cref="ArgumentOutOfRangeException">제공된 action이 유효하지 않을 때 발생합니다.</exception>
        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }

            IntPtr lParam = (IntPtr)action; // MonitorAction enum 값을 lParam으로 직접 사용
            UIntPtr commandResult; 

            IntPtr apiResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,
                WM_SYSCOMMAND,
                (UIntPtr)SC_MONITORPOWER,
                lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, // 1초 타임아웃
                out commandResult);

            if (apiResult == IntPtr.Zero) 
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0) 
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (동작:{action}). Win32 오류 코드: {errorCode}");
                }
                // errorCode가 0인데 apiResult가 IntPtr.Zero인 경우 타임아웃 또는 기타 이유일 수 있음.
                // 명확한 오류 코드가 없으면 성공으로 간주하거나, 상황에 따라 특정 예외를 발생시킬 수 있습니다.
                // 여기서는 Win32Exception이 발생하지 않으면 일단 명령이 전달된 것으로 봅니다.
            }
            // API 호출이 성공적으로 '전송'되었다고 해서 모니터가 즉시 반응하거나,
            // 모든 환경에서 항상 상태 변경을 보장하는 것은 아닙니다. (예: 일부 가상 환경, 드라이버 문제 등)
        }
    }
}
이것이 SControl.Common 라이브러리의 코드입니다. SAgentM.Service 및 추후 구현될 SControlM에서 이 공통 라이브러리를 참조하여 일관된 데이터 구조와 기능을 사용하게 됩니다.