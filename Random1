아래는 주어진 로그 파일을 5초마다 감시하여 가장 최근의 데이터를 DataGrid에 추가하는 WPF MVVM 패턴의 코드입니다. 파일 내용은 각각의 컬럼에 맞게 파싱되고, 버튼을 눌렀을 때 가장 최근의 PO_NO와 그 앞의 PO_NO부터의 데이터를 가져옵니다.

View (XAML)
xml
코드 복사
<Window x:Class="LogFileWatcher.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log File Watcher" Height="450" Width="800">
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="File Name" Binding="{Binding FileName}" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" />
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" />
            </DataGrid.Columns>
        </DataGrid>
        <Button Content="Load Recent Logs" Command="{Binding LoadLogsCommand}" Width="150" Height="30" HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10"/>
    </Grid>
</Window>
ViewModel (C#)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;
using System.ComponentModel;

namespace LogFileWatcher
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly string _logFolder = @"C:\PROD_FILE_LOG";
        private FileSystemWatcher _fileWatcher;
        private Timer _timer;

        public ObservableCollection<LogEntry> LogEntries { get; set; } = new ObservableCollection<LogEntry>();

        public ICommand LoadLogsCommand { get; }

        public MainViewModel()
        {
            LoadLogsCommand = new RelayCommand(LoadRecentLogs);

            // 파일 감시기 초기화
            _fileWatcher = new FileSystemWatcher
            {
                Path = _logFolder,
                Filter = "*.txt",
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,
                EnableRaisingEvents = true
            };
            _fileWatcher.Created += OnFileCreated;

            // 5초마다 폴더 확인하는 타이머
            _timer = new Timer(WatchFolder, null, 0, 5000);
        }

        private void OnFileCreated(object sender, FileSystemEventArgs e)
        {
            // 새로운 파일이 생성될 때 데이터 로드
            LoadLogFile(e.FullPath);
        }

        private void WatchFolder(object state)
        {
            // 폴더 내의 모든 파일 가져오기
            var files = Directory.GetFiles(_logFolder, "*.txt").OrderByDescending(f => f);
            foreach (var file in files)
            {
                LoadLogFile(file);
            }
        }

        private void LoadLogFile(string filePath)
        {
            // 파일 내용 읽기 및 파싱
            var lines = File.ReadAllLines(filePath);
            var logEntry = new LogEntry
            {
                FileName = Path.GetFileName(filePath),
                MAG_NO = GetValueFromLine(lines, "MAG_NO"),
                MAG_QTY = int.Parse(GetValueFromLine(lines, "MAG_QTY")),
                PO_NO = GetValueFromLine(lines, "PO_NO"),
                PO_PLAN_QTY = int.Parse(GetValueFromLine(lines, "PO_PLAN_QTY")),
                PO_PROD_QTY = int.Parse(GetValueFromLine(lines, "PO_PROD_QTY"))
            };

            // 중복 확인 후 추가
            if (!LogEntries.Any(entry => entry.FileName == logEntry.FileName))
            {
                App.Current.Dispatcher.Invoke(() => LogEntries.Add(logEntry));
            }
        }

        private string GetValueFromLine(string[] lines, string key)
        {
            // 파일에서 키에 해당하는 값 추출
            var line = lines.FirstOrDefault(l => l.Contains(key));
            return line?.Split('=')[1].Trim('\'');
        }

        private void LoadRecentLogs()
        {
            // 버튼을 눌렀을 때 최근 파일부터 로드
            var files = Directory.GetFiles(_logFolder, "*.txt").OrderByDescending(f => f).Take(2);
            foreach (var file in files)
            {
                LoadLogFile(file);
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
    }
}
Model (C#)
csharp
코드 복사
public class LogEntry
{
    public string FileName { get; set; }
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
}
RelayCommand (C#)
csharp
코드 복사
using System;
using System.Windows.Input;

namespace LogFileWatcher
{
    public class RelayCommand : ICommand
    {
        private readonly Action _execute;

        public RelayCommand(Action execute)
        {
            _execute = execute;
        }

        public bool CanExecute(object parameter) => true;

        public void Execute(object parameter)
        {
            _execute();
        }

        public event EventHandler CanExecuteChanged;
    }
}
설명
FileSystemWatcher: 로그 파일이 생성되면 자동으로 감지하고 DataGrid에 추가합니다.
타이머: 5초마다 C:\PROD_FILE_LOG 폴더를 감시하여 파일을 확인하고, 새로운 파일이 있으면 추가합니다.
데이터 파싱: 각 로그 파일에서 필요한 값을 파싱하여 LogEntry 객체로 만들고, 이를 DataGrid에 표시합니다.
LoadLogsCommand: 버튼을 눌렀을 때 최근 두 개의 로그 파일을 로드하여 DataGrid에 표시합니다.
이 코드를 적용하면 WPF UI에서 자동으로 파일을 감시하고, DataGrid에 로그 파일의 데이터를 실시간으로 추가할 수 있습니