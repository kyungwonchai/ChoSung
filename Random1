처리로 로그를 관리하려면, LogHelper의 로그 추가 및 파일 저장 작업을 비동기로 수행해야 합니다. 이를 통해 UI가 멈추지 않고 원활하게 동작할 수 있습니다. C#에서는 async와 await 키워드를 사용하여 비동기 작업을 쉽게 구현할 수 있습니다.

1. LogHelper 클래스의 비동기 처리
비동기 방식으로 로그를 추가하고 파일에 기록하는 기능을 추가합니다.

csharp
코드 복사
using System;
using System.IO;
using System.Threading.Tasks;

public class LogHelper
{
    private static LogHelper _instance;
    private static readonly string logFilePath = "logfile.txt";  // 로그 파일 경로

    private LogHelper() 
    {
        if (!File.Exists(logFilePath))
        {
            using (var sw = File.CreateText(logFilePath))
            {
                sw.WriteLine("===== Log Started =====");
            }
        }
    }

    public static LogHelper Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new LogHelper();
            }
            return _instance;
        }
    }

    // 각각의 로그 타입별로 이벤트 정의
    public event EventHandler<LogItem> InfoLogGenerated;
    public event EventHandler<LogItem> ErrorLogGenerated;
    public event EventHandler<LogItem> WarningLogGenerated;

    // 로그를 파일에 비동기로 기록하는 메서드
    private async Task LogToFileAsync(LogItem logItem)
    {
        using (StreamWriter sw = File.AppendText(logFilePath))
        {
            await sw.WriteLineAsync($"{logItem.Timestamp:yyyy-MM-dd HH:mm:ss} [{logItem.LogType}] {logItem.Message}");
        }
    }

    // 새로운 로그 추가 비동기 메서드
    public async Task AddLogAsync(string message, string logType)
    {
        // LogItem 생성
        var logItem = new LogItem(DateTime.Now, message, logType);

        // 파일에 비동기로 로그 기록
        await LogToFileAsync(logItem);

        // 로그 타입에 따라 이벤트 발생
        switch (logType.ToLower())
        {
            case "info":
                OnInfoLogGenerated(logItem);  // Info 로그 이벤트 발생
                break;
            case "error":
                OnErrorLogGenerated(logItem);  // Error 로그 이벤트 발생
                break;
            case "warning":
                OnWarningLogGenerated(logItem);  // Warning 로그 이벤트 발생
                break;
        }
    }

    // 이벤트 발생 함수들
    protected virtual void OnInfoLogGenerated(LogItem logItem)
    {
        InfoLogGenerated?.Invoke(this, logItem);
    }

    protected virtual void OnErrorLogGenerated(LogItem logItem)
    {
        ErrorLogGenerated?.Invoke(this, logItem);
    }

    protected virtual void OnWarningLogGenerated(LogItem logItem)
    {
        WarningLogGenerated?.Invoke(this, logItem);
    }
}
2. MainViewModel 클래스
MainViewModel에서는 비동기 처리를 직접적으로 사용하지 않지만, 이벤트가 비동기적으로 발생하므로 UI가 멈추지 않고 로그를 추가할 수 있습니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

public class MainViewModel : INotifyPropertyChanged
{
    private const int MaxLogCount = 50;

    // 로그 타입별로 별도의 ObservableCollection 정의
    public ObservableCollection<LogItem> InfoLogs { get; set; }
    public ObservableCollection<LogItem> ErrorLogs { get; set; }
    public ObservableCollection<LogItem> WarningLogs { get; set; }

    public MainViewModel()
    {
        // 각 로그 컬렉션 초기화
        InfoLogs = new ObservableCollection<LogItem>();
        ErrorLogs = new ObservableCollection<LogItem>();
        WarningLogs = new ObservableCollection<LogItem>();

        // LogHelper 이벤트 구독
        LogHelper.Instance.InfoLogGenerated += OnInfoLogGenerated;
        LogHelper.Instance.ErrorLogGenerated += OnErrorLogGenerated;
        LogHelper.Instance.WarningLogGenerated += OnWarningLogGenerated;
    }

    // 50개 이상 로그가 쌓이면 첫 번째 항목 삭제하는 로직
    private void AddLogItem(ObservableCollection<LogItem> logCollection, LogItem logItem)
    {
        if (logCollection.Count >= MaxLogCount)
        {
            logCollection.RemoveAt(0);  // 첫 번째 항목 삭제
        }
        logCollection.Add(logItem);  // 새로운 로그 추가
    }

    // 각각의 이벤트 핸들러
    private void OnInfoLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(InfoLogs, logItem);  // Info 로그만 처리
    }

    private void OnErrorLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(ErrorLogs, logItem);  // Error 로그만 처리
    }

    private void OnWarningLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(WarningLogs, logItem);  // Warning 로그만 처리
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
3. MainWindow.xaml (UI: DataGrid 및 ListBox 구성)
UI는 동일합니다. DataGrid와 ListBox를 사용해 로그 타입에 따라 바인딩됩니다.

xml
코드 복사
<Window x:Class="LogApplication.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Log Viewer" Height="600" Width="800">
    <Grid>
        <StackPanel>
            <!-- Info 로그를 위한 DataGrid -->
            <TextBlock Text="Info Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <DataGrid ItemsSource="{Binding InfoLogs}" AutoGenerateColumns="False" CanUserAddRows="False" 
                      IsReadOnly="True" Height="150" Margin="5">
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="*"/>
                    <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*"/>
                    <DataGridTextColumn Header="Log Type" Binding="{Binding LogType}" Width="*"/>
                </DataGrid.Columns>
            </DataGrid>

            <!-- Error 로그를 위한 ListBox -->
            <TextBlock Text="Error Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <ListBox ItemsSource="{Binding ErrorLogs}" Height="150" Margin="5">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <TextBlock Text="{Binding Timestamp}" FontWeight="Bold"/>
                            <TextBlock Text="{Binding Message}"/>
                            <TextBlock Text="{Binding LogType}" FontStyle="Italic"/>
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <!-- Warning 로그를 위한 DataGrid -->
            <TextBlock Text="Warning Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <DataGrid ItemsSource="{Binding WarningLogs}" AutoGenerateColumns="False" CanUserAddRows="False" 
                      IsReadOnly="True" Height="150" Margin="5">
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="*"/>
                    <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*"/>
                    <DataGridTextColumn Header="Log Type" Binding="{Binding LogType}" Width="*"/>
                </DataGrid.Columns>
            </DataGrid>
        </StackPanel>
    </Grid>
</Window>
4. MainWindow.xaml.cs (비동기 로그 추가)
이제 로그를 비동기적으로 추가할 수 있습니다.

csharp
코드 복사
using System.Windows;
using System.Threading.Tasks;

namespace LogApplication
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // MainViewModel을 DataContext로 설정
            this.DataContext = new MainViewModel();

            // 비동기 로그 추가
            AddLogsAsync();
        }

        // 비동기적으로 로그를 추가하는 메서드
        private async Task AddLogsAsync()
        {
            await LogHelper.Instance.AddLogAsync("시스템이 정상적으로 시작되었습니다.", "Info");
            await LogHelper.Instance.AddLogAsync("파일을 찾을 수 없습니다.", "Error");
            await LogHelper.Instance.AddLogAsync("디스크 공간이 부족합니다.", "Warning");
        }
    }
}
5. 비동기 처리의 장점
UI 멈춤 방지: 로그를 추가하거나 파일에 기록하는 과정이 비동기적으로 처리되므로, UI가 멈추거나 느려지지 않습니다.

비동기 파일 기록: LogToFileAsync 메서드를 통해 파일 기록이 비동기로 처리됩니다.

비동기 로그 추가: AddLogAsync 메서드를 통해 로그를 추가할 때 비동기적으로 로그가 처리됩니다.

전체 흐름 요약:
비동기 로그 추가 및 기록: 로그가 비동기로 파일에 기록되고, UI에 반영됩니다.
여러 UI 요소로 분리: DataGrid와 ListBox에 각각의 로그 타입을 효율적으로 분기하여 바인딩합니다.
await 사용: MainWindow에서 로그를 비동기로 추가하고, a