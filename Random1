네, 알겠습니다. 오류 메시지를 보니 몇 가지 수정이 필요해 보입니다. 하나씩 해결해 보겠습니다.

1. MainViewModel.cs의 CanUserManageAgents 오류

오류 메시지: "CanUserManageAgents 이름이 현재 컨텍스트에 없습니다."

원인:
MainViewModel에서 AddAgentCommand, EditAgentCommand, DeleteAgentCommand의 CanExecute 조건으로 CanUserManageAgents라는 bool 타입의 속성을 사용하려고 하는데, 이 속성이 MainViewModel 클래스에 명시적으로 정의되어 있지 않기 때문입니다. 이전에 XAML 바인딩용으로 ManageAgentsButtonVisibility라는 Visibility 타입 속성을 만들었지만, 커맨드의 실행 가능 여부는 bool 값으로 판단해야 합니다.

해결 방법:
MainViewModel.cs에 bool 타입의 CanUserManageAgents와 CanUserControlPower 속성을 추가합니다.

수정된 MainViewModel.cs (관련 부분):

C#

// MGSPMonitorControl/ViewModels/MainViewModel.cs
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // Dispatcher, MessageBox
using System.Windows.Input;
using MGSPMonitorControl.Models;
using MGSPMonitorControl.Services;
using MGSPMonitorControl.Views; 
using MonitorControl.SharedModels; 
using Newtonsoft.Json; 

namespace MGSPMonitorControl.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly UserSession _currentUserSession;
        // ... (다른 필드들은 이전과 동일) ...

        // 기존 Visibility 속성은 XAML용으로 유지하거나, bool 속성에 컨버터 사용으로 대체 가능
        public Visibility ManageAgentsButtonVisibility => (_currentUserSession?.CanManageAgents ?? false) ? Visibility.Visible : Visibility.Collapsed;
        public Visibility ControlPowerButtonVisibility => (_currentUserSession?.CanControlPower ?? false) ? Visibility.Visible : Visibility.Collapsed;

        // RelayCommand의 CanExecute에서 사용할 bool 타입 속성 추가
        public bool CanUserManageAgentsProperty => _currentUserSession?.CanManageAgents ?? false;
        public bool CanUserControlPowerProperty => _currentUserSession?.CanControlPower ?? false;

        // ... (다른 속성들은 이전과 동일) ...

        public MainViewModel(UserSession userSession, IDatabaseService databaseService, IBrokerClientService brokerClientService)
        {
            _currentUserSession = userSession ?? throw new ArgumentNullException(nameof(userSession));
            // ... (나머지 생성자 코드는 이전과 동일) ...
            AddUiLog($"User '{_currentUserSession.Username}' logged in. ManageAgents: {CanUserManageAgentsProperty}, ControlPower: {CanUserControlPowerProperty}");


            // Commands 초기화 시 CanExecute 조건 수정
            LoadAgentsCommand = new RelayCommand(async () => await ExecuteLoadAgentsAsync(), () => true);
            AddAgentCommand = new RelayCommand(ExecuteAddAgent, () => CanUserManageAgentsProperty); // 수정됨
            EditAgentCommand = new RelayCommand(ExecuteEditAgent, () => SelectedAgent != null && CanUserManageAgentsProperty); // 수정됨
            DeleteAgentCommand = new RelayCommand(async () => await ExecuteDeleteAgentAsync(), () => SelectedAgent != null && CanUserManageAgentsProperty); // 수정됨
            
            MonitorOnCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOn"), 
                                              () => SelectedAgent != null && SelectedAgent.IsOnline && CanUserControlPowerProperty); // 수정됨
            MonitorOffCommand = new RelayCommand(async () => await ExecuteMonitorControlAsync("TurnMonitorOff"), 
                                               () => SelectedAgent != null && SelectedAgent.IsOnline && CanUserControlPowerProperty); // 수정됨
            PingAgentCommand = new RelayCommand(async () => await ExecutePingAgentAsync(), () => SelectedAgent != null && SelectedAgent.IsOnline);

            RequestBrokerStatusCommand = new RelayCommand(async () => await ExecuteRequestBrokerStatusAsync(), () => _brokerClientService.IsConnected);
            ConnectToBrokerCommand = new RelayCommand(async () => await _brokerClientService.ConnectAsync(), () => !_brokerClientService.IsConnected);
            DisconnectFromBrokerCommand = new RelayCommand(async () => await _brokerClientService.DisconnectAsync(), () => _brokerClientService.IsConnected);
            ClearUiLogsCommand = new RelayCommand(() => UiActionLogs.Clear());

            // ... (나머지 생성자 코드) ...
        }

        // ... (다른 메서드들은 이전과 동일) ...
    }
}
주요 변경점:

CanUserManageAgentsProperty 와 CanUserControlPowerProperty 라는 bool 타입 속성을 추가했습니다. (기존 Visibility 속성과 구분하기 위해 이름에 Property 추가)
각 RelayCommand의 CanExecute 람다식에서 이 새로운 bool 속성들을 참조하도록 수정했습니다.
2. LoginViewModel.cs의 RelayCommand 오류

오류 메시지: "제네릭이 아닌 형식 'RelayCommand'는 형식 인수와 함께 사용할 수 없습니다."

원인:
이전에 제공한 RelayCommand 클래스가 제네릭 타입 <T>를 받는 형태로 완전히 정의되지 않았거나, 호출하는 부분에서 혼동이 있었을 수 있습니다. LoginCommand에서 RelayCommand<object>를 사용하고 있으므로, RelayCommand 클래스가 이를 지원해야 합니다.

해결 방법:
RelayCommand.cs 파일을 제네릭 RelayCommand<T>와 파라미터 없는 경우를 위한 논-제네릭 RelayCommand를 모두 명확하게 지원하도록 수정합니다.

수정된 ViewModels/RelayCommand.cs (전체 코드):

C#

// MGSPMonitorControl/ViewModels/RelayCommand.cs
using System;
using System.Windows.Input;

namespace MGSPMonitorControl.ViewModels
{
    /// <summary>
    /// A command whose sole purpose is to relay its functionality to other
    /// objects by invoking delegates. The default return value for the CanExecute
    /// method is 'true'.
    /// </summary>
    public class RelayCommand : ICommand
    {
        private readonly Action _execute;
        private readonly Func<bool> _canExecute;

        /// <summary>
        /// Initializes a new instance of the <see cref="RelayCommand"/> class.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        /// <param name="canExecute">The execution status logic.</param>
        public RelayCommand(Action execute, Func<bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute();
        }

        public void Execute(object parameter)
        {
            _execute();
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }

    /// <summary>
    /// A generic command whose sole purpose is to relay its functionality to other
    /// objects by invoking delegates. The default return value for the CanExecute
    /// method is 'true'.
    /// </summary>
    /// <typeparam name="T">The type of the command parameter.</typeparam>
    public class RelayCommand<T> : ICommand
    {
        private readonly Action<T> _execute;
        private readonly Predicate<T> _canExecute;

        /// <summary>
        /// Initializes a new instance of the <see cref="RelayCommand{T}"/> class.
        /// </summary>
        /// <param name="execute">The execution logic.</param>
        /// <param name="canExecute">The execution status logic.</param>
        public RelayCommand(Action<T> execute, Predicate<T> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object parameter)
        {
            // 파라미터가 T 타입으로 변환 가능한지 확인 (또는 null 허용 시)
            if (parameter == null && typeof(T).IsValueType && Nullable.GetUnderlyingType(typeof(T)) == null)
                return _canExecute == null; // 값 타입이고 null을 받을 수 없는 T에 null이 오면 canExecute 조건만 따름 (또는 false 반환)

            // 파라미터가 T이거나 T로 캐스팅 가능할 때만 _canExecute 호출
            if (parameter is T || parameter == null) // null도 T 타입으로 간주 (참조 타입 또는 Nullable<T>)
            {
                 return _canExecute == null || _canExecute((T)parameter);
            }
            // T로 변환 불가능한 타입이 오면 false (또는 예외 발생)
            return false; 
        }

        public void Execute(object parameter)
        {
            _execute((T)parameter);
        }
        
        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
RelayCommand.cs 수정 사항:

파라미터가 없는 명령을 위한 논-제네릭 RelayCommand 클래스를 유지했습니다.
제네릭 파라미터를 받는 RelayCommand<T> 클래스를 추가했습니다.
LoginViewModel에서 new RelayCommand<object>(...) 호출이 이제 이 제네릭 클래스를 올바르게 참조하게 됩니다.
CanExecute(object parameter)와 Execute(object parameter) 메서드 내에서 파라미터 타입을 T로 안전하게 캐스팅하는 로직을 포함했습니다.
LoginViewModel.cs의 LoginCommand 초기화 부분 확인:

위 RelayCommand<T> 수정 후, LoginViewModel.cs의 LoginCommand 초기화는 다음과 같이 되어 있어야 합니다.

C#

// MGSPMonitorControl/ViewModels/LoginViewModel.cs
// ...
            // LoginCommand = new RelayCommand<object>(async (passwordBoxObj) => await ExecuteLoginAsync(passwordBoxObj as System.Windows.Controls.PasswordBox), CanExecuteLogin);
            // CommandParameter는 object로 전달되므로, CanExecuteLogin도 object를 받도록 수정하거나,
            // RelayCommand<PasswordBox>를 사용하고 ExecuteLoginAsync도 PasswordBox를 직접 받도록 하는 것이 더 타입 세이프합니다.
            // 여기서는 object를 유지하되, CanExecuteLogin의 파라미터도 object로 맞춥니다.
            LoginCommand = new RelayCommand<object>(
                async (param) => await ExecuteLoginAsync(param as System.Windows.Controls.PasswordBox), 
                (param) => CanExecuteLogin(param as System.Windows.Controls.PasswordBox) // CanExecuteLogin도 PasswordBox를 받도록 수정
            );
// ...
        // CanExecuteLogin 메서드 시그니처도 PasswordBox 또는 object를 받도록 수정
        private bool CanExecuteLogin(System.Windows.Controls.PasswordBox passwordBox) // 또는 (object parameter)
        {
            // var passwordBox = parameter as System.Windows.Controls.PasswordBox; // object로 받을 경우
            return !string.IsNullOrWhiteSpace(Username) && 
                   passwordBox?.SecurePassword.Length > 0 && 
                   !IsLoggingIn;
        }
// ...
수정된 LoginViewModel.cs (관련 부분만):

C#

// MGSPMonitorControl/ViewModels/LoginViewModel.cs
// ... (다른 using 및 속성 정의는 동일) ...
        public ICommand LoginCommand { get; }

        public LoginViewModel(IDatabaseService databaseService, IPasswordService passwordService)
        {
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _passwordService = passwordService ?? throw new ArgumentNullException(nameof(passwordService));

            // RelayCommand<T>를 사용하도록 명확히 하고, CanExecute 델리게이트의 파라미터 타입도 맞춤
            LoginCommand = new RelayCommand<System.Windows.Controls.PasswordBox>(
                async (pBox) => await ExecuteLoginAsync(pBox), 
                (pBox) => CanExecuteLogin(pBox) 
            );
            // ...
        }

        // CanExecuteLogin의 파라미터를 PasswordBox로 명시
        private bool CanExecuteLogin(System.Windows.Controls.PasswordBox passwordBox)
        {
            return !string.IsNullOrWhiteSpace(Username) && 
                   passwordBox != null && // null 체크 추가
                   passwordBox.SecurePassword.Length > 0 && 
                   !IsLoggingIn;
        }

        // ExecuteLoginAsync의 파라미터도 PasswordBox로 명시
        private async Task ExecuteLoginAsync(System.Windows.Controls.PasswordBox passwordBox)
        {
            if (passwordBox == null) 
            {
                ErrorMessage = "PasswordBox parameter is null."; // 방어 코드
                return;
            }
            // ... (나머지 로직 동일) ...
        }
// ... (나머지 LoginViewModel.cs 코드는 이전과 동일) ...
요약:

MainViewModel.cs에 CanUserManageAgentsProperty와 CanUserControlPowerProperty라는 bool 타입 속성을 추가하고, 커맨드에서 이 속성들을 사용하도록 수정했습니다.
RelayCommand.cs 파일을 파라미터 없는 버전과 제네릭 RelayCommand<T> 버전을 모두 포함하도록 수정했습니다.