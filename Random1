알겠습니다. Unity Industries 3D Core 기본 프로젝트에서 SMD 라인의 '인쇄기(Printer)' 공정 부분만 시뮬레이션하는 것을 목표로, 사이클 타임 단축 및 유실 감소를 위한 분석 기반을 마련해보겠습니다. 인쇄기를 일반적인 '공정 설비'로 간주하고 병렬 구조와 공유 배출 로직에 초점을 맞춰 설명하겠습니다.

설명 순서 안내

요청하신 대로 전체 설명을 3단계로 나누어 진행하겠습니다. 우선 첫 번째 단계(약 1/3 분량)를 설명드립니다.

[1단계] 시뮬레이션 목표 재정의, 기본 구조 설계 및 Unity 모델링:
시뮬레이션할 대상(병렬 인쇄기 및 공유 배출)과 목표를 명확히 합니다.
Unity Scene에 필요한 기본 GameObject 구조를 설계하고 배치하는 방법을 상세히 설명합니다. (프린터, PCB, 입/출력 지점 등)
각 GameObject에 필요한 기본 컴포넌트를 정의합니다.
[2단계] 핵심 로직 구현 (상태 관리 및 기본 동작):
인쇄기(PrinterController)의 상세 상태(State Machine)를 정의하고 상태별 동작 로직을 설명합니다. (보드 수신, 작업 위치 이동, 기본 처리 등)
PCB(PCBController) 스크립트의 역할과 추적할 데이터를 정의합니다.
시간 기반 처리 및 지연을 구현하는 방법을 설명합니다. (Coroutine 활용)
[3단계] 상세 로직 구현 (청소, 배출 연동 및 데이터 수집):
인쇄기의 청소 로직(주기, 옵션별 시간 차이)을 구현하는 방법을 설명합니다.
공유 배출 시스템(Shuttle Conveyor)의 로직과 인쇄기와의 연동 방법을 설명합니다. (상태 확인, 우선순위 처리)
사이클 타임 측정 및 데이터 기록 방법을 구체화합니다.
전체적인 코드 예시와 함께 파라미터 조정 방법을 설명합니다.
[1단계] 시뮬레이션 목표 재정의, 기본 구조 설계 및 Unity 모델링

1. 시뮬레이션 목표 및 범위

목표: Front Printer와 Rear Printer라는 두 개의 병렬 공정 설비와 이들로부터 제품(PCB)을 받아 배출하는 단일 셔틀 컨베이어 시스템을 시뮬레이션합니다. 이를 통해 각 설비의 작업 흐름, 대기 시간, 공유 자원(셔틀) 경쟁 등을 관찰하고, 향후 사이클 타임 및 병목 현상 분석의 기초를 마련합니다.
범위:
각 프린터의 개별 투입구에서 PCB 생성 (시뮬레이션 시작점).
프린터 내부 공정 단계 시뮬레이션 (투입 대기 -> 작업 위치 이동 -> 인쇄 준비/작업/완료 -> 우측 버퍼 대기).
단일 셔틀 컨베이어가 각 프린터의 우측 버퍼에서 PCB를 번갈아 (또는 우선순위에 따라) 픽업하는 로직.
셔틀이 픽업한 PCB는 시스템 밖으로 배출되며, 이때 사이클 타임을 기록하고 PCB 객체는 제거 (시뮬레이션 종료점).
초기 단계에서는 청소 로직은 잠시 보류하고 기본 흐름부터 구현합니다.
2. Unity 기본 구조 설계 및 모델링 상세

Unity Scene을 열고 다음 GameObject들을 생성하고 구성합니다. 이름은 예시이며, 구체적인 프로젝트 규칙에 따라 변경 가능합니다.

PCB Prefab (기판 프리팹):

Create Empty로 GameObject 생성 후 PCB_Prefab으로 이름 변경.
자식으로 3D Object > Cube를 추가하여 얇고 넓은 직육면체 형태로 Scale 조정 (예: X:1, Y:0.1, Z:1.5). 이것이 PCB의 시각적 표현입니다.
PCB_Prefab 루트 GameObject에 Rigidbody 컴포넌트 추가 (물리적 이동이 필요하다면. 아니라면 제거). Use Gravity는 해제하고 Is Kinematic은 필요에 따라 체크합니다 (스크립트로만 제어 시 체크).
Box Collider 컴포넌트 추가 (충돌 감지 또는 트리거 사용 시). 크기를 Cube 메시에 맞춥니다.
이후 PCB의 상태와 정보를 관리할 PCBController C# 스크립트를 추가합니다 (다음 단계에서 생성).
이 PCB_Prefab을 Project 창으로 드래그하여 프리팹으로 저장합니다. Scene에서는 삭제해도 됩니다.
Printers (인쇄 설비):

Create Empty로 Printers라는 부모 GameObject를 생성하여 관련 객체들을 그룹화합니다.
Printers 아래에 Create Empty로 FrontPrinter와 RearPrinter GameObject를 생성합니다. 이들이 각 병렬 설비를 나타냅니다.
각 프린터 (FrontPrinter, RearPrinter) 내부 구조:
(시각적 모델 - 선택 사항): 각 프린터 GameObject 아래에 Cube나 다른 3D 모델을 이용해 설비의 외형을 간단히 만듭니다.
(로직을 위한 위치 지정자): 각 프린터 GameObject 아래에 Create Empty를 사용하여 다음 위치들을 나타내는 빈 GameObject를 생성합니다. 이들의 Transform.position 값이 중요합니다.
InputPoint: 외부에서 PCB가 처음 도착하는 위치.
ProcessingPoint: 실제 인쇄 작업(테이블 상승/하강, 인쇄)이 이루어지는 위치.
OutputBufferPoint: 작업 완료 후 셔틀 컨베이어를 기다리는 위치 (프린터 우측).
각 프린터 GameObject (FrontPrinter, RearPrinter)에 핵심 로직을 담당할 PrinterController C# 스크립트를 추가합니다 (다음 단계에서 생성).
Input Sources (투입 지점):

Create Empty로 InputSources 부모 GameObject 생성.
그 아래 Create Empty로 InputSource_Front와 InputSource_Rear 생성.
InputSource_Front의 위치는 FrontPrinter의 InputPoint와 연결될 이전 공정 위치로 설정합니다 (요청에 따라 뒷쪽).
InputSource_Rear의 위치는 RearPrinter의 InputPoint와 연결될 이전 공정 위치로 설정합니다 (요청에 따라 앞쪽).
각 InputSource GameObject에 InputSpawner C# 스크립트(가칭)를 추가하여 주기적으로 PCB_Prefab을 생성하고 해당 프린터의 InputPoint로 보내는 역할을 부여할 수 있습니다. (초기에는 수동으로 PCB를 배치하거나 간단한 생성 로직만 구현)
Shuttle Conveyor (셔틀 컨베이어):

Create Empty로 ShuttleConveyor GameObject 생성.
자식으로 Cube 등을 이용해 셔틀의 시각적 형태를 만듭니다.
셔틀의 초기 위치는 프린터들의 OutputBufferPoint 사이 또는 시작 지점으로 설정합니다.
셔틀이 PCB를 싣고 이동할 최종 목적지(배출 지점)를 나타내는 Transform이나 빈 GameObject (ExitPoint)를 Scene 어딘가에 배치합니다.
ShuttleConveyor GameObject에 셔틀의 이동 및 픽업 로직을 담당할 ShuttleController C# 스크립트를 추가합니다 (다음 단계에서 생성).
3. 코드 적용 방향 (1단계 해당 내용)

현재 단계에서는 Scene 구성과 GameObject 배치에 집중합니다. 코드는 아직 구체적으로 작성하지 않지만, 어떤 스크립트가 어떤 GameObject에 붙어야 하는지 명확히 합니다.

PCB_Prefab에는 PCBController 스크립트가 붙어 자신의 상태(예: 생성 시간, 현재 위치, 처리 상태)를 관리합니다.
FrontPrinter와 RearPrinter에는 각각 PrinterController 스크립트가 붙어 해당 프린터의 상태, 내부 PCB 이동, 처리 로직, 버퍼 상태 등을 관리합니다.
ShuttleConveyor에는 ShuttleController 스크립트가 붙어 프린터 버퍼 확인, 셔틀 이동, PCB 픽업 및 배출 로직을 관리합니다.
(선택적) InputSource_... 에는 InputSpawner 스크립트가 붙어 PCB를 생성합니다.
여기까지가 1단계 설명입니다. 이 구조를 바탕으로 다음 단계에서 각 스크립트의 상태 머신 정의와 핵심 동작 로직 구현에 대해 자세히 설명드리겠습니다. 특히 PrinterController의 내부 상태 변화와 PCB 이동 로직을 중점적으로 다룰 예정입니다.


잘하는거같다 본젹코드로 바로넘어가자 핵심이 되는 모델링의 방법하나한 전부랑 코드만들어적용하는법 연결하는법등 모든부분의 핵심내용만해서 완성된 최종내용을 알려줘 누락없이 모두구현하자





생각하는 과정 표시
알겠습니다. Unity 3D Core 프로젝트에서 병렬 인쇄기 및 공유 셔틀 배출 시스템의 핵심 내용을 중심으로, 모델링 방법과 완성된 C# 코드 및 연결 방법을 누락 없이 상세히 설명드리겠습니다.

I. 최종 목표 시스템 요약

병렬 인쇄기 (Front/Rear): 각각 별도의 투입구로 PCB를 받음. 내부적으로 [투입 대기 -> 작업대 이동 -> 백업(상승) -> 인쇄 준비(상승) -> 인쇄 -> 테이블 하강 -> (청소) -> 출력 버퍼 이동] 단계를 거침. 청소는 보드 N개당 짧은 청소, 10개당 긴 청소 옵션이 있으며, 각 프린터는 설정이 다름.
공유 셔틀 배출: 단일 셔틀이 Y축 방향으로 이동하며 Front/Rear 프린터의 출력 버퍼에 있는 PCB를 픽업. 기본적으로 번갈아 픽업하지만, 한쪽 버퍼가 비어있으면 PCB가 있는 다른 쪽을 우선 픽업.
시뮬레이션 범위: 투입구에서 PCB 생성부터 셔틀이 최종 배출 지점으로 PCB를 옮기고 사이클 타임을 기록하는 것까지.
II. 상세 모델링 및 Scene 구성

(이전 단계에서 설명한 기본 구조를 바탕으로 핵심 컴포넌트와 설정을 구체화합니다)

PCB Prefab (PCB_Prefab):

GameObject: 얇은 Cube 형태.
Components:
Box Collider: Is Trigger 체크 해제 (물리적 이동 대신 스크립트 제어 시) 또는 체크 (트리거로 위치 감지 시). 여기서는 스크립트 제어를 가정하고 해제.
Rigidbody: 추가 안함 (스크립트로 Transform 직접 제어). 필요시 Kinematic으로 추가 가능.
PCBController (C# Script): 필수. PCB 상태, 생성 시간, 고유 ID 등 저장.
Prefab 저장: Project 창에 저장.
Printer GameObjects (FrontPrinter, RearPrinter):

Hierarchy:
FrontPrinter (Root GameObject)
(Optional) Visual Models (Cube 등)
InputPoint (Empty GameObject: Transform Position)
ProcessingPoint (Empty GameObject: Transform Position)
OutputBufferPoint (Empty GameObject: Transform Position)
RearPrinter (동일 구조)
Components (Root - FrontPrinter, RearPrinter):
PrinterController (C# Script): 필수. 프린터 로직 제어.
Inspector 설정: PrinterController 스크립트의 Public 변수들을 통해 각 위치(InputPoint, ProcessingPoint, OutputBufferPoint의 Transform)를 연결해주어야 함.
Shuttle Conveyor (ShuttleConveyor):

Hierarchy:
ShuttleConveyor (Root GameObject)
(Optional) Visual Model (Cube 등)
PickupPoint (Empty GameObject: PCB가 셔틀 위에 놓일 위치)
Components (Root):
ShuttleController (C# Script): 필수. 셔틀 로직 제어.
Inspector 설정: ShuttleController에 FrontPrinter와 RearPrinter의 PrinterController 참조, 각 프린터의 OutputBufferPoint, PickupPoint, 그리고 최종 목적지인 ExitPoint의 Transform 참조를 연결해야 함.
Input Spawners (InputSource_Front, InputSource_Rear):

GameObject: Scene 내 원하는 투입 위치에 배치된 Empty GameObject.
Components:
InputSpawner (C# Script): 필수. PCB 생성 및 초기 설정.
Inspector 설정: InputSpawner에 생성할 PCB_Prefab과 이 PCB가 가야 할 목표 프린터(FrontPrinter 또는 RearPrinter의 PrinterController 참조)를 연결해야 함.
Exit Point (ExitPoint):

GameObject: 셔틀이 PCB를 내려놓고 시뮬레이션이 종료되는 위치를 나타내는 Empty GameObject. Transform.position만 사용됨.
III. 핵심 C# 스크립트 구현

(전체적인 흐름과 핵심 로직 중심으로 작성. 실제 구현 시에는 디버깅 및 예외 처리가 필요합니다.)

1. PCBController.cs

C#

using UnityEngine;

public class PCBController : MonoBehaviour
{
    public int id; // 고유 식별자 (필요시)
    public float entryTime; // 시스템 진입 시간 (사이클 타임 측정용)
    public PrinterController currentPrinter; // 현재 자신을 처리 중인 프린터 (참조)

    public void Initialize(int pcbId, PrinterController targetPrinter)
    {
        id = pcbId;
        entryTime = Time.time;
        currentPrinter = targetPrinter;
        // 필요시 추가 초기화
    }

    // PCB가 최종 배출될 때 호출될 함수
    public void CalculateAndLogCycleTime()
    {
        float exitTime = Time.time;
        float cycleTime = exitTime - entryTime;
        Debug.Log($"PCB ID: {id} - Cycle Time: {cycleTime:F2} seconds");
        // 여기에 데이터를 파일이나 다른 시스템에 기록하는 로직 추가 가능
    }
}
2. PrinterController.cs

C#

using UnityEngine;
using System.Collections;

public class PrinterController : MonoBehaviour
{
    public enum PrinterState { Idle, Receiving, WaitingForProcessing, MovingToProcessing, BackingUp, PreparingPrint, Printing, TableDown, Cleaning, MovingToOutput, WaitingForShuttle, Down } // 추가: Down 상태
    public PrinterState currentState = PrinterState.Idle;

    [Header("Object References")]
    public Transform inputPoint;
    public Transform processingPoint;
    public Transform outputBufferPoint;
    public ShuttleController shuttleController; // 셔틀 컨트롤러 참조 (Inspector에서 할당)

    [Header("Timing Parameters")]
    public float moveToProcessingTime = 1.0f;
    public float backupTime = 0.5f;
    public float preparePrintTime = 0.8f;
    public float printingTime = 2.0f;
    public float tableDownTime = 0.5f;
    public float moveToOutputTime = 1.0f;
    public float shortCleanTime = 3.0f;
    public float longCleanTime = 10.0f;
    public float failureRate = 0.001f; // 초당 고장 확률 (예시)
    public float repairTime = 60.0f;   // 수리 시간 (예시)


    [Header("Cleaning Options")]
    public int shortCleanCycle = 3; // 짧은 청소 주기 (1~5)
    public int longCleanCycle = 10; // 긴 청소 주기 (고정)

    [Header("Status")]
    public PCBController currentPCB = null; // 현재 처리 중인 PCB
    public PCBController pcbInOutBuffer = null; // 출력 버퍼에 있는 PCB
    private int processedCount = 0; // 처리 완료된 PCB 수 (청소 주기용)
    private int processedSinceLastClean = 0; // 마지막 청소 후 처리된 PCB 수
    private float timeToFailure; // 다음 고장까지 남은 시간

    // --- 외부 호출용 프로퍼티/메소드 ---
    public bool IsReadyToReceive() => currentState == PrinterState.Idle && currentPCB == null;
    public bool HasPCBInOutBuffer() => pcbInOutBuffer != null;

    void Start()
    {
        CalculateTimeToFailure();
    }

    void Update()
    {
        // 고장 체크 (간단한 예시)
        if (currentState != PrinterState.Down && currentState != PrinterState.Cleaning) // 고장/청소 중 아닐 때만
        {
            timeToFailure -= Time.deltaTime;
            if (timeToFailure <= 0)
            {
                StartCoroutine(GoDown());
            }
        }

        // 간단한 상태 머신 예시 (실제로는 더 복잡한 로직 필요)
        // Update에서 상태 전환 트리거링 또는 Coroutine 내에서 상태 변경
    }

    // 외부(InputSpawner)에서 호출하여 PCB를 프린터로 전달
    public void ReceivePCB(PCBController pcb)
    {
        if (IsReadyToReceive())
        {
            Debug.Log($"{name}: Receiving PCB {pcb.id}");
            currentPCB = pcb;
            currentPCB.transform.position = inputPoint.position; // 우선 Input 위치로
            currentState = PrinterState.Receiving; // 상태 변경
            // PCB를 작업 위치로 이동 시작
            StartCoroutine(ProcessSequence());
        }
        else
        {
            Debug.LogWarning($"{name}: Cannot receive PCB now. State: {currentState}");
            // 실제 시스템에서는 여기에 대기 큐 로직 등이 필요할 수 있음
            Destroy(pcb.gameObject); // 임시: 받을 수 없으면 파괴
        }
    }

    // 전체 처리 시퀀스를 관리하는 코루틴
    private IEnumerator ProcessSequence()
    {
        // 1. 작업 위치로 이동
        currentState = PrinterState.MovingToProcessing;
        yield return StartCoroutine(MoveObject(currentPCB.transform, processingPoint.position, moveToProcessingTime));

        // --- 실제 인쇄 작업 ---
        // 2. 백업 (테이블 상승)
        currentState = PrinterState.BackingUp;
        yield return new WaitForSeconds(backupTime);

        // 3. 인쇄 준비 (마스크까지 상승)
        currentState = PrinterState.PreparingPrint;
        yield return new WaitForSeconds(preparePrintTime);

        // 4. 인쇄
        currentState = PrinterState.Printing;
        yield return new WaitForSeconds(printingTime);

        // 5. 테이블 내려옴
        currentState = PrinterState.TableDown;
        yield return new WaitForSeconds(tableDownTime);
        // --- 인쇄 작업 완료 ---

        processedCount++;
        processedSinceLastClean++;

        // 6. 청소 필요 여부 확인 및 수행
        bool needsLongClean = processedCount % longCleanCycle == 0;
        bool needsShortClean = !needsLongClean && (processedSinceLastClean >= shortCleanCycle);

        if (needsLongClean)
        {
            currentState = PrinterState.Cleaning;
            Debug.Log($"{name}: Starting LONG clean.");
            yield return new WaitForSeconds(longCleanTime);
            processedSinceLastClean = 0; // 긴 청소 후 카운터 리셋
            Debug.Log($"{name}: LONG clean finished.");
        }
        else if (needsShortClean)
        {
            currentState = PrinterState.Cleaning;
            Debug.Log($"{name}: Starting SHORT clean.");
            yield return new WaitForSeconds(shortCleanTime);
            processedSinceLastClean = 0; // 짧은 청소 후 카운터 리셋
            Debug.Log($"{name}: SHORT clean finished.");
        }

        // 7. 출력 버퍼로 이동
        currentState = PrinterState.MovingToOutput;
        yield return StartCoroutine(MoveObject(currentPCB.transform, outputBufferPoint.position, moveToOutputTime));

        // 8. 출력 버퍼에 PCB 배치 및 셔틀 대기 상태로 전환
        pcbInOutBuffer = currentPCB;
        currentPCB = null; // 현재 처리 PCB 참조 제거
        currentState = PrinterState.WaitingForShuttle;
        Debug.Log($"{name}: PCB {pcbInOutBuffer.id} waiting for shuttle at output buffer.");

        // 셔틀에게 알림 (ShuttleController가 주기적으로 체크하는 방식도 가능)
        // shuttleController?.NotifyPCBReady(this); // 직접 호출 방식
    }

    // 셔틀이 PCB를 가져갈 때 호출될 함수
    public PCBController ReleasePCBToShuttle()
    {
        if (currentState == PrinterState.WaitingForShuttle && pcbInOutBuffer != null)
        {
            PCBController pcbToRelease = pcbInOutBuffer;
            pcbInOutBuffer = null;
            currentState = PrinterState.Idle; // 다시 작업 가능 상태로
            Debug.Log($"{name}: Released PCB {pcbToRelease.id} to shuttle.");
            return pcbToRelease;
        }
        return null;
    }

    // 간단한 이동 코루틴
    private IEnumerator MoveObject(Transform objTransform, Vector3 targetPosition, float duration)
    {
        Vector3 startPosition = objTransform.position;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            objTransform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null; // 다음 프레임까지 대기
        }
        objTransform.position = targetPosition; // 정확한 위치 보정
    }

    // 고장 처리 코루틴
    private IEnumerator GoDown()
    {
        Debug.LogError($"{name} is DOWN!");
        currentState = PrinterState.Down;
        // 현재 처리 중인 PCB가 있다면 처리 (예: 폐기)
        if (currentPCB != null)
        {
            Debug.LogWarning($"{name}: Discarding current PCB {currentPCB.id} due to failure.");
            Destroy(currentPCB.gameObject);
            currentPCB = null;
        }
         // 출력 버퍼에 PCB가 있다면 대기 유지 (셔틀이 가져갈 수 있도록)

        yield return new WaitForSeconds(repairTime);

        Debug.Log($"{name} has been repaired.");
        currentState = PrinterState.Idle; // 수리 완료 후 Idle 상태로
        CalculateTimeToFailure(); // 다음 고장 시간 계산
    }


    void CalculateTimeToFailure()
    {
         if (failureRate > 0)
             // 간단한 지수 분포 기반 시간 계산 (평균 고장 간격 = 1 / failureRate)
             timeToFailure = -Mathf.Log(Random.value) / failureRate;
         else
             timeToFailure = float.PositiveInfinity; // 고장 없음
        // Debug.Log($"{name}: Next failure in {timeToFailure:F2} seconds."); // 디버그용
    }
}
3. ShuttleController.cs

C#

using UnityEngine;
using System.Collections;

public class ShuttleController : MonoBehaviour
{
    public enum ShuttleState { Idle, MovingToFront, PickingFront, MovingToRear, PickingRear, MovingToExit, Delivering }
    public ShuttleState currentState = ShuttleState.Idle;

    [Header("Object References")]
    public PrinterController frontPrinter;
    public PrinterController rearPrinter;
    public Transform frontPickupPoint; // Front 프린터의 OutputBufferPoint와 동일하거나 약간 다를 수 있음
    public Transform rearPickupPoint;  // Rear 프린터의 OutputBufferPoint와 동일하거나 약간 다를 수 있음
    public Transform shuttlePickupPoint; // 셔틀 자체의 PCB 탑재 위치
    public Transform exitPoint;

    [Header("Movement Parameters")]
    public float moveSpeed = 5.0f;
    public float pickupTime = 1.0f; // PCB를 집는 데 걸리는 시간

    [Header("Status")]
    public PCBController carriedPCB = null; // 현재 셔틀이 운반 중인 PCB
    private bool preferFront = true; // 다음 번갈아 픽업 순서 (True: Front 우선)

    void Update()
    {
        // Idle 상태일 때만 새 작업 시작
        if (currentState == ShuttleState.Idle)
        {
            DecideNextAction();
        }
    }

    void DecideNextAction()
    {
        bool frontReady = frontPrinter.HasPCBInOutBuffer();
        bool rearReady = rearPrinter.HasPCBInOutBuffer();

        // 1. 둘 다 준비되었을 경우: 번갈아 우선순위 적용
        if (frontReady && rearReady)
        {
            if (preferFront) StartCoroutine(GoPickPCB(frontPrinter, frontPickupPoint, ShuttleState.MovingToFront, ShuttleState.PickingFront));
            else StartCoroutine(GoPickPCB(rearPrinter, rearPickupPoint, ShuttleState.MovingToRear, ShuttleState.PickingRear));
            preferFront = !preferFront; // 우선순위 변경
        }
        // 2. Front만 준비되었을 경우
        else if (frontReady)
        {
            StartCoroutine(GoPickPCB(frontPrinter, frontPickupPoint, ShuttleState.MovingToFront, ShuttleState.PickingFront));
            preferFront = false; // 다음엔 Rear 우선
        }
        // 3. Rear만 준비되었을 경우
        else if (rearReady)
        {
            StartCoroutine(GoPickPCB(rearPrinter, rearPickupPoint, ShuttleState.MovingToRear, ShuttleState.PickingRear));
            preferFront = true; // 다음엔 Front 우선
        }
        // 4. 둘 다 준비 안 됨: Idle 상태 유지 (Update에서 계속 체크)
    }

    // 특정 프린터로 가서 PCB를 픽업하는 코루틴
    private IEnumerator GoPickPCB(PrinterController targetPrinter, Transform targetPickupPoint, ShuttleState movingState, ShuttleState pickingState)
    {
        currentState = movingState;
        Debug.Log($"{name}: Moving to {targetPrinter.name}");

        // 1. 프린터 픽업 위치로 이동
        yield return StartCoroutine(MoveShuttle(targetPickupPoint.position));

        // 2. PCB 픽업 시도 (프린터에서 PCB 받아오기)
        currentState = pickingState;
        Debug.Log($"{name}: Picking up PCB from {targetPrinter.name}");
        PCBController pcb = targetPrinter.ReleasePCBToShuttle();

        if (pcb != null)
        {
            carriedPCB = pcb;
            carriedPCB.transform.SetParent(shuttlePickupPoint); // PCB를 셔틀의 PickupPoint 자식으로 만듦
            carriedPCB.transform.localPosition = Vector3.zero; // 셔틀 PickupPoint의 로컬 중앙에 위치
            yield return new WaitForSeconds(pickupTime); // 픽업 시간

            // 3. Exit Point로 이동
            currentState = ShuttleState.MovingToExit;
            Debug.Log($"{name}: Moving to Exit with PCB {carriedPCB.id}");
            yield return StartCoroutine(MoveShuttle(exitPoint.position));

            // 4. PCB 배출 (내려놓기)
            currentState = ShuttleState.Delivering;
            Debug.Log($"{name}: Delivering PCB {carriedPCB.id} at Exit point.");
            carriedPCB.transform.SetParent(null); // 부모-자식 관계 해제
            carriedPCB.CalculateAndLogCycleTime(); // 사이클 타임 계산 및 로그
            Destroy(carriedPCB.gameObject); // PCB 객체 파괴
            carriedPCB = null;

            // 5. 작업 완료 후 Idle 상태로 복귀
            currentState = ShuttleState.Idle;
             Debug.Log($"{name}: Returning to Idle state.");
        }
        else
        {
            // 혹시 이동 중에 PCB가 사라졌거나 문제가 생긴 경우
            Debug.LogWarning($"{name}: Failed to pick up PCB from {targetPrinter.name}. Returning to Idle.");
            currentState = ShuttleState.Idle;
        }
    }

    // 셔틀 이동 코루틴
    private IEnumerator MoveShuttle(Vector3 targetPosition)
    {
        Vector3 startPosition = transform.position;
        float distance = Vector3.Distance(startPosition, targetPosition);
        float duration = distance / moveSpeed;
        float elapsedTime = 0f;

        while (elapsedTime < duration)
        {
            transform.position = Vector3.Lerp(startPosition, targetPosition, elapsedTime / duration);
            elapsedTime += Time.deltaTime;
            yield return null;
        }
        transform.position = targetPosition;
    }
}
4. InputSpawner.cs

C#

using UnityEngine;

public class InputSpawner : MonoBehaviour
{
    public GameObject pcbPrefab; // Inspector에서 PCB Prefab 할당
    public PrinterController targetPrinter; // 이 스포너가 공급할 프린터 (Inspector에서 할당)
    public float spawnInterval = 10.0f; // PCB 생성 간격 (초)
    public int maxSpawns = 20; // 최대 생성 개수 (테스트용)

    private float timer;
    private int spawnCount = 0;
    private int pcbCounter = 1; // PCB ID 부여용

    void Update()
    {
        if (spawnCount >= maxSpawns) return; // 최대 개수 도달 시 중지

        timer += Time.deltaTime;
        if (timer >= spawnInterval)
        {
            // 프린터가 받을 준비가 되었는지 확인하는 것이 더 좋을 수 있음
            // if (targetPrinter.IsReadyToReceive()) // <- 이렇게 하면 프린터가 막혔을 때 스폰 안함
            // {
                SpawnPCB();
                timer = 0f; // 타이머 리셋
            // }
        }
         // 우선 간단하게 시간 간격으로만 스폰
         if (timer >= spawnInterval)
         {
             SpawnPCB();
             timer = 0f;
         }
    }

    void SpawnPCB()
    {
        if (pcbPrefab == null || targetPrinter == null)
        {
            Debug.LogError("PCB Prefab or Target Printer not set in InputSpawner!");
            return;
        }

        GameObject newPcbObj = Instantiate(pcbPrefab, transform.position, Quaternion.identity);
        PCBController pcbController = newPcbObj.GetComponent<PCBController>();

        if (pcbController != null)
        {
            pcbController.Initialize(pcbCounter++, targetPrinter); // PCB 초기화 및 ID 부여
            targetPrinter.ReceivePCB(pcbController); // 생성된 PCB를 타겟 프린터로 전달
            spawnCount++;
            Debug.Log($"Spawner {name}: Spawned PCB {pcbController.id} for {targetPrinter.name}");
        }
        else
        {
            Debug.LogError("Spawned PCB does not have PCBController component!");
            Destroy(newPcbObj);
        }
    }
}
IV. Unity Editor에서 연결 및 설정

스크립트 컴포넌트 추가: 위에서 설명한 대로 각 GameObject에 맞는 C# 스크립트를 Add Component하여 추가합니다.
Public 변수 연결 (Drag & Drop):
각 InputSpawner 선택:
Pcb Prefab 필드에 Project 창의 PCB_Prefab을 드래그.
Target Printer 필드에 해당 스포너가 공급할 FrontPrinter 또는 RearPrinter GameObject를 Hierarchy 창에서 드래그.
각 PrinterController (FrontPrinter, RearPrinter) 선택:
Input Point, Processing Point, Output Buffer Point 필드에 Hierarchy 창에서 해당 자식 Empty GameObject들을 드래그.
Shuttle Controller 필드에 Scene의 ShuttleConveyor GameObject를 드래그.
ShuttleController (ShuttleConveyor) 선택:
Front Printer, Rear Printer 필드에 각각 FrontPrinter, RearPrinter GameObject를 드래그.
Front Pickup Point, Rear Pickup Point 필드에 각 프린터의 OutputBufferPoint Transform을 드래그 (또는 별도 지정 위치).
Shuttle Pickup Point 필드에 셔틀의 자식인 PickupPoint GameObject를 드래그.
Exit Point 필드에 Scene에 배치한 ExitPoint GameObject를 드래그.
파라미터 설정: 각 스크립트의 Inspector 창에 노출된 public 변수들(처리 시간, 청소 주기, 이동 속도, 스폰 간격 등)을 원하는 값으로 설정합니다. 특히 각 프린터의 청소 주기(shortCleanCycle)를 다르게 설정하여 차이를 관찰할 수 있습니다.
V. 실행 및 관찰

Unity 에디터에서 Play 버튼을 눌러 시뮬레이션을 시작합니다.
Console 창을 통해 각 객체의 상태 변화, PCB 이동, 픽업, 배출, 사이클 타임 로그 등을 확인합니다.
Scene 뷰를 통해 PCB와 셔틀의 움직임을 시각적으로 관찰합니다.