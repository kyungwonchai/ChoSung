 Windows Formsì—ì„œ ë¹„ë™ê¸° ë§¤í¬ë¡œ ì‹¤í–‰ + ë¡œê¹… + í™”ë©´ ìº¡ì²˜ + CV ë¶„ì„ì„ í¬í•¨í•œ ì „ë¬¸ê°€ ì½”ë“œ
ğŸ› ï¸ í”„ë¡œì íŠ¸ êµ¬ì¡°
Forms
MainForm.cs â†’ UI ê´€ë¦¬ (ë²„íŠ¼ í´ë¦­ ì‹œ ì‹¤í–‰)
Macro System
IMacroCommand.cs â†’ ê³µí†µ ì¸í„°í˜ì´ìŠ¤
KeyboardCommand.cs â†’ í‚¤ë³´ë“œ ì…ë ¥ ëª…ë ¹
MouseClickCommand.cs â†’ ë§ˆìš°ìŠ¤ í´ë¦­ ëª…ë ¹
DelayCommand.cs â†’ íŠ¹ì • ì‹œê°„ ëŒ€ê¸°
CVCommand.cs â†’ CV(ì´ë¯¸ì§€ ë¶„ì„) ëª…ë ¹
ScreenCaptureCommand.cs â†’ í™”ë©´ ìº¡ì²˜
Execution
MacroExecutor.cs â†’ ë§¤í¬ë¡œ ì‹¤í–‰ TaskQueue
MacroManager.cs â†’ ì‹±ê¸€í†¤ ë§¤í¬ë¡œ ê´€ë¦¬
Logging
MacroLogger.cs â†’ ë¡œê·¸ ê´€ë¦¬ (ListBox ë°”ì¸ë”©)
ğŸ“‚ 1. í”„ë¡œì íŠ¸ íŒŒì¼ ìœ„ì¹˜
ì½”ë“œ ë³µì‚¬
ğŸ“¦ MacroWinForms
 â”£ ğŸ“‚ Commands
 â”ƒ â”£ ğŸ“œ IMacroCommand.cs
 â”ƒ â”£ ğŸ“œ KeyboardCommand.cs
 â”ƒ â”£ ğŸ“œ MouseClickCommand.cs
 â”ƒ â”£ ğŸ“œ DelayCommand.cs
 â”ƒ â”£ ğŸ“œ CVCommand.cs
 â”ƒ â”— ğŸ“œ ScreenCaptureCommand.cs
 â”£ ğŸ“‚ Core
 â”ƒ â”£ ğŸ“œ MacroExecutor.cs
 â”ƒ â”£ ğŸ“œ MacroManager.cs
 â”ƒ â”— ğŸ“œ MacroLogger.cs
 â”£ ğŸ“‚ Forms
 â”ƒ â”— ğŸ“œ MainForm.cs
 â”£ ğŸ“œ Program.cs
 â”— ğŸ“œ MacroWinForms.csproj
ğŸ“œ 2. ì½”ë“œ ìƒì„¸ êµ¬í˜„
ğŸ”¹ (1) IMacroCommand.cs (ë§¤í¬ë¡œ ëª…ë ¹ ê³µí†µ ì¸í„°í˜ì´ìŠ¤)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Commands
{
    using System.Threading.Tasks;

    /// <summary>
    /// ëª¨ë“  ë§¤í¬ë¡œ ëª…ë ¹ì´ êµ¬í˜„í•´ì•¼ í•˜ëŠ” ì¸í„°í˜ì´ìŠ¤.
    /// </summary>
    public interface IMacroCommand
    {
        Task ExecuteAsync(); // ë¹„ë™ê¸° ì‹¤í–‰
    }
}
ğŸ”¹ (2) KeyboardCommand.cs (í‚¤ë³´ë“œ ì…ë ¥)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Commands
{
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class KeyboardCommand : IMacroCommand
    {
        private readonly Keys _key;

        public KeyboardCommand(Keys key)
        {
            _key = key;
        }

        public async Task ExecuteAsync()
        {
            await Task.Delay(100);
            SendKeys.SendWait(_key.ToString());
            Core.MacroLogger.Instance.AddLog($"í‚¤ ì…ë ¥: {_key}");
        }
    }
}
ğŸ”¹ (3) MouseClickCommand.cs (ë§ˆìš°ìŠ¤ í´ë¦­)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Commands
{
    using System;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class MouseClickCommand : IMacroCommand
    {
        private readonly int _x, _y;

        [DllImport("user32.dll")]
        private static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        private const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        private const uint MOUSEEVENTF_LEFTUP = 0x04;

        public MouseClickCommand(int x, int y)
        {
            _x = x;
            _y = y;
        }

        public async Task ExecuteAsync()
        {
            Cursor.Position = new System.Drawing.Point(_x, _y);
            await Task.Delay(50);
            mouse_event(MOUSEEVENTF_LEFTDOWN, _x, _y, 0, IntPtr.Zero);
            await Task.Delay(50);
            mouse_event(MOUSEEVENTF_LEFTUP, _x, _y, 0, IntPtr.Zero);
            Core.MacroLogger.Instance.AddLog($"ë§ˆìš°ìŠ¤ í´ë¦­: {_x}, {_y}");
        }
    }
}
ğŸ”¹ (4) DelayCommand.cs (ë”œë ˆì´)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Commands
{
    using System.Threading.Tasks;

    public class DelayCommand : IMacroCommand
    {
        private readonly int _milliseconds;

        public DelayCommand(int milliseconds)
        {
            _milliseconds = milliseconds;
        }

        public async Task ExecuteAsync()
        {
            Core.MacroLogger.Instance.AddLog($"ë”œë ˆì´ {_milliseconds}ms");
            await Task.Delay(_milliseconds);
        }
    }
}
ğŸ”¹ (5) ScreenCaptureCommand.cs (í™”ë©´ ìº¡ì²˜)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Commands
{
    using System;
    using System.Drawing;
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class ScreenCaptureCommand : IMacroCommand
    {
        private readonly string _savePath;

        public ScreenCaptureCommand(string savePath)
        {
            _savePath = savePath;
        }

        public async Task ExecuteAsync()
        {
            await Task.Delay(500);
            Bitmap bmp = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
            Graphics graphics = Graphics.FromImage(bmp);
            graphics.CopyFromScreen(0, 0, 0, 0, bmp.Size);
            bmp.Save(_savePath);
            Core.MacroLogger.Instance.AddLog($"í™”ë©´ ìº¡ì²˜ ì €ì¥: {_savePath}");
        }
    }
}
ğŸ”¹ (6) MacroExecutor.cs (ë¹„ë™ê¸° ë§¤í¬ë¡œ ì‹¤í–‰)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Core
{
    using System;
    using System.Collections.Concurrent;
    using System.Threading.Tasks;
    using MacroWinForms.Commands;

    public class MacroExecutor
    {
        private readonly ConcurrentQueue<IMacroCommand> _commandQueue = new ConcurrentQueue<IMacroCommand>();
        private bool _isRunning = false;

        public void AddCommand(IMacroCommand command)
        {
            _commandQueue.Enqueue(command);
        }

        public async Task ExecuteAllAsync()
        {
            if (_isRunning) return;
            _isRunning = true;

            while (_commandQueue.TryDequeue(out var command))
            {
                try
                {
                    await command.ExecuteAsync();
                }
                catch (Exception ex)
                {
                    MacroLogger.Instance.AddLog($"[Error] {ex.Message}");
                }
            }

            _isRunning = false;
        }
    }
}
ğŸ”¹ (7) MacroManager.cs (ë§¤í¬ë¡œ ì¤‘ì•™ ê´€ë¦¬)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Core
{
    using System.Threading.Tasks;

    public class MacroManager
    {
        private static MacroManager _instance;
        private static readonly object _lock = new object();
        private readonly MacroExecutor _executor;

        private MacroManager()
        {
            _executor = new MacroExecutor();
        }

        public static MacroManager Instance
        {
            get
            {
                lock (_lock)
                {
                    return _instance ??= new MacroManager();
                }
            }
        }

        public void AddCommand(IMacroCommand command)
        {
            _executor.AddCommand(command);
        }

        public async Task StartExecutionAsync()
        {
            await _executor.ExecuteAllAsync();
        }
    }
}
ğŸ”¹ (8) MacroLogger.cs (ë¡œê·¸ ì‹œìŠ¤í…œ)
csharp
ì½”ë“œ ë³µì‚¬
namespace MacroWinForms.Core
{
    using System;
    using System.Collections.ObjectModel;

    public class MacroLogger
    {
        private static MacroLogger _instance;
        private static readonly object _lock = new object();
        public ObservableCollection<string> Logs { get; private set; } = new ObservableCollection<string>();

        private MacroLogger() { }

        public static MacroLogger Instance
        {
            get
            {
                lock (_lock)
                {
                    return _instance ??= new MacroLogger();
                }
            }
        }

        public void AddLog(string message)
        {
            string logEntry = $"{DateTime.Now:yyyyMMddHHmmss} - {message}";
            Logs.Insert(0, logEntry);
            if (Logs.Count > 200) Logs.RemoveAt(200);
        }
    }