알겠습니다. 이중 실행 방지와 오래된 로그 파일 삭제 기능을 구현하되, 해당 과정에서 로그를 남기지 않고, 불필요한 객체(ViewModel 등)를 생성하지 않는 간결한 코드를 원하시는군요.

요청하신 대로 App.xaml.cs 파일을 수정하여, 애플리케이션 시작 시 가장 먼저 이 두 가지 작업을 조용히 처리하도록 코드를 재구성했습니다.

수정된 SAgentM.App/App.xaml.cs 전체 코드
아래 코드로 App.xaml.cs 파일 전체를 교체하시면 됩니다. 이중 실행 방지와 로그 삭제 로직이 OnStartup 메서드 최상단에 로깅 없이 간결하게 추가되었습니다.

C#

// SAgentM.App/App.xaml.cs
using SAgentM.App.Services;
using SAgentM.App.ViewModels;
using System;
using System.Configuration;
using System.IO;
using System.Linq;
using System.Threading;
using System.Windows;
using Hardcodet.Wpf.TaskbarNotification;
using Serilog; // 로깅 자체는 다른 곳에서 사용하므로 using은 유지

namespace SAgentM.App
{
    public partial class App : Application
    {
        private Mutex _mutex;
        // Mutex 이름은 시스템의 다른 앱과 충돌하지 않도록 고유해야 합니다.
        private const string MutexName = "Global\\SAgentMApp_Mutex_UniqueId_20250526";

        private TaskbarIcon _notifyIcon;
        private MainWindow _mainWindow;
        private ILoggingService _loggingService;
        private IAgentCoreService _agentCoreService;
        private MainViewModel _mainViewModel;

        protected override void OnStartup(StartupEventArgs e)
        {
            // --- ▼▼▼ 1. 이중 실행 방지 (로그 없음) ▼▼▼ ---
            bool createdNew;
            _mutex = new Mutex(true, MutexName, out createdNew);

            if (!createdNew)
            {
                // 이미 실행 중인 경우, 메시지 박스를 표시하고 조용히 종료합니다.
                MessageBox.Show("SAgentM 에이전트가 이미 실행 중입니다.", "실행 확인", MessageBoxButton.OK, MessageBoxImage.Information);
                Application.Current.Shutdown();
                return; // 여기서 OnStartup 처리를 중단합니다.
            }

            // --- ▼▼▼ 2. 오래된 로그 파일 자동 삭제 (로그 없음) ▼▼▼ ---
            try
            {
                string logFilePattern = ConfigurationManager.AppSettings["LogFilePath"] ?? "Logs_SAgentM\\SAgentM_App_.log";
                string baseDir = AppDomain.CurrentDomain.BaseDirectory;
                string fullLogPathPattern = Path.Combine(baseDir, logFilePattern);
                string logDirectory = Path.GetDirectoryName(fullLogPathPattern);

                if (!string.IsNullOrEmpty(logDirectory) && Directory.Exists(logDirectory))
                {
                    int daysToKeep = 3; // 3일보다 오래된 로그를 삭제
                    DateTime cutoffDate = DateTime.Now.Date.AddDays(-daysToKeep);
                    string fileNameWithoutDate = Path.GetFileNameWithoutExtension(logFilePattern).TrimEnd('_');
                    string fileExtension = Path.GetExtension(logFilePattern);
                    string searchPattern = $"{fileNameWithoutDate}_*{fileExtension}";

                    var logFiles = Directory.GetFiles(logDirectory, searchPattern)
                                            .Select(filePath => new FileInfo(filePath))
                                            .ToList();

                    foreach (var logFile in logFiles)
                    {
                        string datePart = logFile.Name.Replace(fileNameWithoutDate + "_", "").Replace(fileExtension, "");
                        if (DateTime.TryParseExact(datePart, "yyyyMMdd", System.Globalization.CultureInfo.InvariantCulture, System.Globalization.DateTimeStyles.None, out DateTime fileDate))
                        {
                            if (fileDate.Date < cutoffDate)
                            {
                                try { logFile.Delete(); }
                                catch { /* 파일 삭제 실패 시 오류를 무시하고 계속 진행 */ }
                            }
                        }
                    }
                }
            }
            catch { /* 로그 삭제 과정에서 발생하는 모든 예외를 무시하고 앱 시작은 계속 */ }
            // --- ▲▲▲ 사전 작업 로직 끝 ▲▲▲ ---


            // --- ▼▼▼ 기존 애플리케이션 초기화 로직 (위 작업이 모두 성공적으로 끝난 후 실행) ▼▼▼ ---
            base.OnStartup(e);

            // Serilog 전역 파일 로거 설정
            var logFilePatternForInit = ConfigurationManager.AppSettings["LogFilePath"] ?? "Logs_SAgentM\\SAgentM_App_.log";
            var baseDirForInit = AppDomain.CurrentDomain.BaseDirectory;
            var fullLogPathPatternForInit = Path.Combine(baseDirForInit, logFilePatternForInit);
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .WriteTo.File(fullLogPathPatternForInit, rollingInterval: RollingInterval.Day, shared: true)
                .CreateLogger();
            
            Log.Information("SAgentM.App OnStartup: 애플리케이션 시작");

            // 서비스 및 ViewModel 초기화
            _loggingService = new LoggingService();
            _agentCoreService = new AgentCoreService(_loggingService);
            _mainViewModel = new MainViewModel(_loggingService, _agentCoreService);
            _mainWindow = new MainWindow { DataContext = _mainViewModel };

            // TaskbarIcon 설정
            _notifyIcon = (TaskbarIcon)FindResource("AppNotifyIcon");

            // AgentCoreService 시작
            if (!_agentCoreService.IsRunning)
            {
                try { _agentCoreService.Start(); _mainViewModel.UpdateAgentStatus(); }
                catch (Exception ex) { _loggingService.UiError("AgentCoreService 시작 오류", ex); }
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            // 애플리케이션 종료 시 Mutex 해제 (안전장치)
            _mutex?.ReleaseMutex();
            _mutex?.Close();
            
            Log.Information("SAgentM.App OnExit: 애플리케이션 종료.");
            Log.CloseAndFlush();
            base.OnExit(e);
        }

        // 트레이 아이콘 더블 클릭
        private void AppNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e)
        {
            ShowHideMainWindow();
        }

        // 메뉴 - 보이기/숨기기
        private void ShowHideMainWindow_MenuItemClick(object sender, RoutedEventArgs e)
        {
            ShowHideMainWindow();
        }

        // 메뉴 - 종료
        private async void ExitApplication_MenuItemClick(object sender, RoutedEventArgs e)
        {
            if (_mainViewModel != null) { await _mainViewModel.CleanupAsync(); }
            
            // 트레이 아이콘 리소스 정리
            _notifyIcon?.Dispose();
            _notifyIcon = null;

            // Mutex 리소스 정리 (가장 중요한 부분)
            _mutex?.ReleaseMutex();
            _mutex?.Close();
            _mutex = null;

            Current.Shutdown();
        }
        
        private void ShowHideMainWindow()
        {
            if (_mainWindow == null) return;
            if (_mainWindow.IsVisible) { _mainWindow.Hide(); }
            else 
            { 
                _mainWindow.Show(); 
                if (_mainWindow.WindowState == WindowState.Minimized) 
                {
                    _mainWindow.WindowState = WindowState.Normal; 
                }
                _mainWindow.Activate();
            }
        }
    }
}
주요 변경 사항 요약
OnStartup 로직 순서 변경:

가장 먼저 이중 실행 방지(Mutex)와 오래된 로그 삭제 로직을 수행합니다.
이 과정에서 문제가 발생하거나, 이미 앱이 실행 중이면 base.OnStartup(e) 이나 다른 초기화 코드를 실행하기 전에 앱을 종료하여 불필요한 리소스 낭비를 막습니다.
로깅 제거:

이중 실행 확인 로직과 로그 파일 삭제 로직에서 Log.Information, Log.Warning 등 모든 종류의 로그 기록 코드를 완전히 제거했습니다.
로그 파일 삭제 시 발생하는 예외는 try-catch로 감싸서 앱이 비정상 종료되는 것을 방지하되, 내부는 비워두어 조용히 넘어가도록 처리했습니다.
리소스 정리 강화:

ExitApplication_MenuItemClick (정상 종료)와 OnExit (비정상 포함 종료) 양쪽에서 Mutex를 해제하도록 하여 안정성을 높였습니다. _mutex?.ReleaseMutex(); 와 같이 null 조건 연산자를 사용하여 이미 해제된 객체에 접근하려 할 때 발생하는 오류를 방지합니다.
