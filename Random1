penCV를 사용하여 특정 색상을 가진 사각형을 찾고, 마우스 클릭 및 키보드 입력을 자동으로 수행하는 코드이다.
RGB(정확히는 OpenCV의 BGR) 범위를 기반으로 색상을 필터링하며, 전체 원리를 주석과 함께 설명한다.

🔹 전체 코드 (완벽한 주석 포함)
csharp
코드 복사
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;

public partial class MainForm : Form
{
    private const int MaxLogCount = 500; // ListBox 최대 로그 개수

    public MainForm()
    {
        InitializeComponent();
    }

    /// <summary>
    /// 비동기로 특정 영역에서 색상을 검색하고, 조건이 맞으면 마우스 클릭 및 키보드 입력을 수행
    /// </summary>
    private async Task PerformAutomationAsync()
    {
        // 1. 스캔할 화면 영역 (X, Y 좌표 범위)
        int startX = 1200;
        int endX = 1500;
        int startY = 500;
        int endY = 600;

        // 2. 해당 영역 스크린샷 캡처 후 OpenCV Mat 객체로 변환
        Bitmap screenshot = CaptureScreen(startX, startY, endX - startX, endY - startY);
        Mat src = BitmapConverter.ToMat(screenshot);

        // 3. 색상 범위 지정 (OpenCV는 BGR 순서)
        Scalar lower = new Scalar(10, 77, 100);  // B=10~50, G=77~88, R=100~120
        Scalar upper = new Scalar(50, 88, 120);

        /*
         * ⬇ Cv2.InRange() 작동 원리 ⬇
         * 지정된 `lower`~`upper` 값 사이에 있는 모든 픽셀을 흰색(255)으로 마스킹, 나머지는 검은색(0) 처리
         * → 결과적으로 특정 색상 범위 내의 픽셀만 남김
         */
        Mat mask = new Mat();
        Cv2.InRange(src, lower, upper, mask); // 마스킹된 이미지 생성

        /*
         * ⬇ Cv2.FindContours() 작동 원리 ⬇
         * 마스크 이미지(이진 이미지)에서 흰색(255) 영역의 윤곽선을 찾음
         * → 검출된 윤곽선 데이터는 `contours` 배열에 저장됨
         */
        Cv2.FindContours(mask, out Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

        foreach (var contour in contours)
        {
            // 4. 검출된 윤곽선의 외접 사각형 계산
            Rect rect = Cv2.BoundingRect(contour);

            // 5. 사각형 크기 조건 확인 (너비 200 이상, 높이 30 이상)
            if (rect.Width >= 200 && rect.Height >= 30)
            {
                int centerX = startX + rect.X + rect.Width / 2;  // 버튼 중앙 X 좌표
                int centerY = startY + rect.Y + rect.Height / 2; // 버튼 중앙 Y 좌표
                int topClickY = startY + rect.Y - 157; // 상단 클릭할 Y 좌표

                LogMessage($"찾은 버튼: X={centerX}, Y={centerY}, Width={rect.Width}, Height={rect.Height}");

                // 6. 버튼 위쪽 특정 지점 클릭
                SetCursorPos(centerX, topClickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, (uint)centerX, (uint)topClickY, 0, 0);

                // 7. 키보드 입력 수행
                await Task.Delay(100);
                SendKeys.SendWait("kkkkbbbbb");
                await Task.Delay(100);
                SendKeys.SendWait("{TAB}");
                await Task.Delay(100);
                SendKeys.SendWait("aaaaabbbb");

                // 8. 버튼의 중앙 클릭
                await Task.Delay(100);
                SetCursorPos(centerX, centerY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, (uint)centerX, (uint)centerY, 0, 0);

                LogMessage("입력 및 버튼 클릭 완료");
                return;
            }
        }

        LogMessage("조건에 맞는 직사각형을 찾을 수 없음");
    }

    /// <summary>
    /// 지정된 영역의 스크린샷을 캡처하여 Bitmap으로 반환
    /// </summary>
    private Bitmap CaptureScreen(int x, int y, int width, int height)
    {
        Bitmap bmp = new Bitmap(width, height);
        using (Graphics g = Graphics.FromImage(bmp))
        {
            g.CopyFromScreen(x, y, 0, 0, new System.Drawing.Size(width, height), CopyPixelOperation.SourceCopy);
        }
        return bmp;
    }

    /// <summary>
    /// 로그 메시지를 ListBox에 추가 (500개 초과 시 오래된 로그 삭제)
    /// </summary>
    private void LogMessage(string message)
    {
        if (listBox1.InvokeRequired)
        {
            listBox1.Invoke(new Action(() => AddMessageToListBox(message)));
        }
        else
        {
            AddMessageToListBox(message);
        }
    }

    private void AddMessageToListBox(string message)
    {
        listBox1.Items.Add($"{DateTime.Now:HH:mm:ss} - {message}");

        if (listBox1.Items.Count > MaxLogCount)
        {
            listBox1.Items.RemoveAt(0);
        }

        listBox1.TopIndex = listBox1.Items.Count - 1;
    }

    // 마우스 이동 및 클릭을 위한 WinAPI 함수
    [DllImport("user32.dll")]
    private static extern bool SetCursorPos(int X, int Y);

    [DllImport("user32.dll")]
    private static extern void mouse_event(uint dwFlags, uint dx, uint dy, uint dwData, int dwExtraInfo);

    private const uint MOUSEEVENTF_LEFTDOWN = 0x0002;
    private const uint MOUSEEVENTF_LEFTUP = 0x0004;
}
🔹 핵심 개념 및 작동 원리
1️⃣ Cv2.InRange() 색상 필터링
원리: 특정 범위의 색상만 남기고 나머지를 제거
BGR 값 사용: lower = (10, 77, 100), upper = (50, 88, 120)
결과: 해당 색상 범위에 포함되는 픽셀만 흰색(255)으로 표시, 나머지는 검은색(0)
2️⃣ Cv2.FindContours() 윤곽선 추출
원리: Cv2.InRange()로 마스킹한 결과에서 흰색(255) 영역을 찾아 윤곽선을 검출
결과: 각 윤곽선이 contours 배열에 저장됨
3️⃣ Cv2.BoundingRect() 사각형 추출
원리: FindContours()로 찾은 윤곽선을 감싸는 최소 사각형을 구함
결과: 각 윤곽선에 대해 Rect 객체(위치, 크기 정보)를 얻음
4️⃣ 크기 조건 적용 (200x30 이상)
rect.Width >= 200 && rect.Height >= 30 조건 검사
조건 충족 시 → 마우스 클릭 & 키보드 입력 실행
5️⃣ ListBox 로그 관리
로그 추가 후 500개 초과 시 오래된 항목 삭제
UI가 멈추지 않도록 InvokeRequired 검사 후 업데이트
📌 결과
색상 필터링 후 조건 맞는 버튼만 찾음
클릭 후 키보드 입력 자동 실행
ListBox에 처리 로그 추가