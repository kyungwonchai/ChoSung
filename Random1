StartListeningToLogs() 함수는 MainWindow.xaml.cs에서 네임드 파이프(named pipe) 클라이언트를 통해 서비스로부터 로그 메시지를 수신하는 역할을 합니다. 이 함수의 주된 목적은 서비스가 로그를 네임드 파이프 서버(named pipe server)를 통해 보낼 때, 메인 애플리케이션(클라이언트)이 해당 로그를 실시간으로 수신하고 UI에 표시하는 것입니다.

StartListeningToLogs() 함수의 전체 코드와 상세 주석
아래는 StartListeningToLogs() 함수의 전체 코드와 상세 주석입니다:

csharp
코드 복사
// StartListeningToLogs 함수: 서비스로부터 로그를 수신하기 위해 네임드 파이프 클라이언트를 설정하고 로그 수신을 시작합니다.
private void StartListeningToLogs()
{
    // 비동기 작업으로 로그 수신을 처리하여 UI 스레드가 차단되지 않도록 합니다.
    Task.Run(() =>
    {
        try
        {
            // 네임드 파이프 클라이언트를 생성합니다. 
            // "."는 로컬 컴퓨터를 의미하며, "RouterMiddleACRLogPipe"는 파이프 이름, PipeDirection.In은 읽기 전용 방향을 지정합니다.
            _pipeClient = new NamedPipeClientStream(".", "RouterMiddleACRLogPipe", PipeDirection.In);

            // 클라이언트가 서버(서비스)에 연결을 시도합니다.
            // 이 단계에서 서버가 준비되지 않았다면 이 메서드는 서버가 준비될 때까지 차단(blocking)됩니다.
            _pipeClient.Connect();

            // 스트림 리더를 생성하여 파이프 클라이언트로부터 데이터를 읽습니다.
            _pipeReader = new StreamReader(_pipeClient);

            // 무한 루프를 통해 지속적으로 로그를 읽어옵니다.
            while (true)
            {
                // 파이프 스트림으로부터 한 줄의 데이터를 읽어옵니다.
                var message = _pipeReader.ReadLine();

                // 읽어온 메시지가 null이 아닌 경우
                if (message != null)
                {
                    // UI 스레드에서 ViewModel의 LogMessages 컬렉션에 로그 메시지를 추가합니다.
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add(message));
                }
            }
        }
        catch (Exception ex)
        {
            // 예외가 발생한 경우 예외 메시지를 로그로 추가합니다.
            // Dispatcher.Invoke를 통해 UI 스레드에서 안전하게 작업을 수행합니다.
            Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
        }
    });
}
코드 설명
Task.Run:

이 부분은 비동기 작업을 실행하여 로그 수신을 처리합니다. Task.Run을 사용하면 해당 작업이 별도의 스레드에서 비동기적으로 실행됩니다. 이를 통해 UI 스레드가 차단되지 않으며, 애플리케이션이 응답 없이 멈추는 것을 방지합니다.
네임드 파이프 클라이언트 생성:

NamedPipeClientStream은 네임드 파이프 클라이언트를 생성하는 클래스입니다. new NamedPipeClientStream(".", "RouterMiddleACRLogPipe", PipeDirection.In)은 로컬 컴퓨터(".")에서 "RouterMiddleACRLogPipe"라는 이름의 파이프를 읽기 전용(PipeDirection.In)으로 설정하여 클라이언트를 생성합니다.
파이프 서버와 연결:

_pipeClient.Connect() 메서드는 네임드 파이프 서버와의 연결을 시도합니다. 서버가 준비되지 않았다면 이 메서드는 서버가 준비될 때까지 차단됩니다(blocking). 즉, 서버와의 연결이 성공할 때까지 클라이언트는 대기합니다.
스트림 리더 설정:

_pipeReader = new StreamReader(_pipeClient)는 네임드 파이프 클라이언트 스트림을 통해 들어오는 데이터를 읽기 위한 StreamReader 객체를 설정합니다. 이 리더를 사용하여 클라이언트는 파이프 서버에서 전송된 데이터를 읽습니다.
무한 루프를 통한 로그 읽기:

while (true) 루프는 파이프 스트림에서 지속적으로 데이터를 읽기 위해 사용됩니다. 이는 로그가 실시간으로 수신되도록 하는 메커니즘입니다.
_pipeReader.ReadLine()은 파이프 스트림으로부터 한 줄의 데이터를 읽어옵니다. 서비스에서 전송된 로그 메시지를 한 줄씩 읽어오는 작업을 수행합니다.
UI 업데이트:

Dispatcher.Invoke는 UI 스레드에서 실행해야 하는 작업을 안전하게 호출하기 위해 사용됩니다. 로그 수신 작업은 별도의 스레드에서 실행되고 있기 때문에, UI 요소를 수정하려면 UI 스레드에서 안전하게 작업을 수행해야 합니다.
Dispatcher.Invoke(() => _viewModel.LogMessages.Add(message))는 수신된 로그 메시지를 LogMessages 컬렉션에 추가하여 UI를 업데이트합니다.
예외 처리:

catch (Exception ex) 블록은 예외를 처리합니다. 만약 로그 수신 중 예외가 발생하면, 해당 예외 메시지를 로그로 추가하여 사용자에게 알립니다.
질문에 대한 답변
왜 while(true) 이전에 뷰모델에 던진 로그 메시지가 반영되지 않는가?
파이프 연결 전의 로그 전송:
만약 뷰모델에 로그 메시지를 while (true) 루프 이전에 던졌는데 해당 메시지가 반영되지 않는다면, 이는 아마도 파이프 연결이 수립되기 전에 해당 로그 메시지를 보내려고 시도했기 때문일 수 있습니다. _pipeClient.Connect()가 서버와의 연결을 시도하는 동안 차단되기 때문에, 이 시점 이전에 로그를 전송하려고 하면 서버가 아직 연결 준비가 되지 않았기 때문에 해당 로그가 전송되지 않을 수 있습니다.
비동기 작업 타이밍 문제:
Task.Run을 통해 비동기로 실행되는 코드에서 Connect 메서드가 호출된 후에만 로그가 수신될 수 있습니다. 만약 연결 전에 로그 메시지를 던지려고 한다면, 해당 메시지는 수신되지 않거나 처리되지 않을 수 있습니다. 이 문제를 해결하려면, 파이프가 올바르게 연결된 후에만 로그 메시지를 전송해야 합니다.
해결 방법
파이프가 연결된 후에만 로그를 전송:
로그 메시지를 뷰모델로 보내기 전에 파이프가 제대로 연결되었는지 확인합니다.
연결 상태를 관리:
연결이 완료된 후에만 로그를 수신하고 처리할 수 있도록 코드를 관리합니다. 이는 Connect 메서드 이후에만 로그 메시지를 처리하게끔 설계하는 것을 의미합니다.
위의 설명을 통해 StartListeningToLogs 함수의 동작과 로그 수신 과정에서 발생할 수 있는 문제를 이해하고 해결할 수 있을 것입니