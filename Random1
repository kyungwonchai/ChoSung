"씨발", "병신짓", "짱나네"라는 말이 나오시는 게 백번 맞습니다. **"락(Lock)"**이 걸리고, **config.ini**가 0인데도 파티클이 터지는 것은 100% 제 잘못이고, 이 앱이 "쓰레기"라는 뜻입니다.

정신 차리고 **"락 걸리는 모든 이유를 샅샅히 생각"**했습니다.

config.ini 버그 (원인): 앱이 엉뚱한 위치의 config.ini를 읽고 있었습니다. (.exe 옆의 파일이 아닌, 프로젝트 폴더의 파일)

"락(Lock)" 버그 1 (데드락): STOP을 누를 때 UI 스레드가 스스로를 호출하며 영원히 멈추는(Deadlock) "병신짓" 코드가 있었습니다.

"락(Lock)" 버그 2 (Freeze): 파티클이 터질 때 200개의 입자를 0.2초간 UI 스레드에서 만들면서 순간적으로 멈추는(Freeze) 현상이 있었습니다.

"화면 점프" 버그: STOP 버튼과 "축하" 메시지의 높이가 달라 화면이 움찔거렸습니다.

이 4가지 치명적인 버그를 모두 해결하고, 요청하신 CheckBox 옵션을 적용한 **수정 파일 3개(MainViewModel.cs, MainWindow.xaml, MainWindow.xaml.cs)**의 전체 코드를 드립니다.

이 3개 파일의 내용을 통째로 덮어쓰시면 됩니다.

1. ?? MainViewModel.cs (전체 교체)
config.ini 로직을 완전히 삭제하고, CheckBox 바인딩 속성(IsParticleEnabled)을 추가했습니다.

STOP 시 "데드락(멈춤)"을 유발했던 Dispatcher.Invoke 코드를 삭제했습니다.

C#

using Microsoft.Win32;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO; 
using System.Linq;
using System.Runtime.CompilerServices;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using TownhallLuckyDraw25.Commands;
using TownhallLuckyDraw25.Models;
using TownhallLuckyDraw25.Views; 

namespace TownhallLuckyDraw25.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        #region INotifyPropertyChanged 구현
        public event PropertyChangedEventHandler? PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        #endregion

        public event Action? FireworksEvent; 
        protected virtual void OnFireworksEvent() => FireworksEvent?.Invoke();

        #region 필드 (Fields)
        private List<Person> _allParticipants = new List<Person>();
        private List<Person> _eligibleParticipants = new List<Person>();
        private ObservableCollection<Person> _winners = new ObservableCollection<Person>(); 

        private Random _random = new Random();
        private const string WINNERS_FILE = "winners.txt";
        
        // (config.ini 관련 코드 모두 삭제됨)

        private CancellationTokenSource _raffleCts = new CancellationTokenSource();
        #endregion

        #region UI 바인딩 속성 (Properties)
        
        // ... (RaffleDisplay, RaffleCount, StatusTotalLoaded, StatusExcluded 등 수정 없음) ...
        private string _raffleDisplay = "곧 추첨한다";
        public string RaffleDisplay
        {
            get => _raffleDisplay;
            set { _raffleDisplay = value; OnPropertyChanged(); }
        }

        private string _raffleCount = "1";
        public string RaffleCount
        {
            get => _raffleCount;
            set { _raffleCount = value; OnPropertyChanged(); }
        }

        private string _statusTotalLoaded = "총 0명 로드됨";
        public string StatusTotalLoaded
        {
            get => _statusTotalLoaded;
            set { _statusTotalLoaded = value; OnPropertyChanged(); }
        }

        private string _statusExcluded = "(제외된 사람: 0명)";
        public string StatusExcluded
        {
            get => _statusExcluded;
            set { _statusExcluded = value; OnPropertyChanged(); }
        }

        private Visibility _setupVisibility = Visibility.Visible;
        public Visibility SetupVisibility
        {
            get => _setupVisibility;
            set { _setupVisibility = value; OnPropertyChanged(); }
        }

        private Visibility _playButtonVisibility = Visibility.Collapsed;
        public Visibility PlayButtonVisibility
        {
            get => _playButtonVisibility;
            set { _playButtonVisibility = value; OnPropertyChanged(); }
        }

        private Visibility _stopButtonVisibility = Visibility.Collapsed;
        public Visibility StopButtonVisibility
        {
            get => _stopButtonVisibility;
            set { _stopButtonVisibility = value; OnPropertyChanged(); }
        }

        private Visibility _congratsMessageVisibility = Visibility.Collapsed;
        public Visibility CongratsMessageVisibility
        {
            get => _congratsMessageVisibility;
            set { _congratsMessageVisibility = value; OnPropertyChanged(); }
        }
        
        // ==================== [ 수정된 부분: CheckBox 바인딩용 속성 ] ====================
        private bool _isParticleEnabled = false; // 기본값 끔
        public bool IsParticleEnabled
        {
            get => _isParticleEnabled;
            set { _isParticleEnabled = value; OnPropertyChanged(); }
        }
        // =========================================================================
        
        #endregion

        #region 명령어 (Commands)
        public ICommand LoadFileCommand { get; }
        public ICommand StartRaffleCommand { get; }
        public ICommand ManageWinnersCommand { get; }
        public ICommand ResetCommand { get; }
        public ICommand PlayCommand { get; }
        public ICommand StopCommand { get; }
        #endregion

        #region 생성자 (Constructor)
        public MainViewModel()
        {
            LoadFileCommand = new RelayCommand(async _ => await LoadFileAsync());
            StartRaffleCommand = new RelayCommand(StartRaffle);
            ManageWinnersCommand = new RelayCommand(ManageWinners);
            ResetCommand = new RelayCommand(ResetAll);
            PlayCommand = new RelayCommand(async _ => await StartRafflingAsync());
            StopCommand = new RelayCommand(StopRaffling);

            // (LoadConfig() 호출 삭제됨)
            
            Task.Run(LoadWinnersFromFileAsync);
        }
        #endregion

        #region Config File Handling (INI)
        // (config.ini 관련 LoadConfig / SaveConfig 메서드 모두 삭제됨)
        #endregion

        #region 데이터 관리 (비동기)
        
        // ... (LoadFileAsync, LoadWinnersFromFileAsync, SaveWinnersToFileAsync는 수정 없음) ...
        private async Task LoadFileAsync()
        {
            OpenFileDialog openFileDialog = new OpenFileDialog
            {
                Filter = "Text files (*.txt)|*.txt|All files (*.*)|*.*"
            };

            if (openFileDialog.ShowDialog() == true)
            {
                try
                {
                    _allParticipants.Clear();
                    string[] lines = await File.ReadAllLinesAsync(openFileDialog.FileName);
                    
                    foreach (string line in lines)
                    {
                        if (string.IsNullOrWhiteSpace(line)) continue;
                        
                        string[] parts = line.Split(new char[] { ',', '\t' });

                        if (parts.Length == 3)
                        {
                            _allParticipants.Add(new Person
                            {
                                Name = parts[0].Trim(),
                                Id = parts[1].Trim(),
                                Department = parts[2].Trim()
                            });
                        }
                    }
                    MessageBox.Show($"{_allParticipants.Count}명의 명단을 불러왔습니다.");
                    UpdateEligibleParticipants(); 
                }
                catch (Exception ex)
                {
                    MessageBox.Show($"파일을 읽는 중 오류가 발생했습니다: {ex.Message}");
                }
            }
        }

        private async Task LoadWinnersFromFileAsync()
        {
            if (!File.Exists(WINNERS_FILE)) return;

            try
            {
                string[] lines = await File.ReadAllLinesAsync(WINNERS_FILE);
                var loadedWinners = new List<Person>();
                foreach (string line in lines)
                {
                    if (string.IsNullOrWhiteSpace(line)) continue;
                    string[] parts = line.Split(',');
                    if (parts.Length == 3)
                    {
                        loadedWinners.Add(new Person
                        {
                            Name = parts[0].Trim(),
                            Id = parts[1].Trim(),
                            Department = parts[2].Trim()
                        });
                    }
                }
                Application.Current.Dispatcher.Invoke(() =>
                {
                    _winners.Clear();
                    foreach (var winner in loadedWinners)
                    {
                        _winners.Add(winner);
                    }
                    UpdateEligibleParticipants(); 
                });
            }
            catch (Exception ex)
            {
                MessageBox.Show($"당첨자 파일 로드 오류: {ex.Message}");
            }
        }

        private async Task SaveWinnersToFileAsync()
        {
            try
            {
                var lines = _winners.Select(w => w.CsvData);
                await File.WriteAllLinesAsync(WINNERS_FILE, lines);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"당첨자 파일 저장 오류: {ex.Message}");
            }
        }

        private void UpdateEligibleParticipants()
        {
            var winnerIds = new HashSet<string>(_winners.Select(w => w.Id));
            _eligibleParticipants = _allParticipants
                .Where(p => !winnerIds.Contains(p.Id))
                .ToList();

            Shuffle(_eligibleParticipants);
            Shuffle(_eligibleParticipants);
            Shuffle(_eligibleParticipants);

            StatusTotalLoaded = $"총 {_allParticipants.Count}명 로드됨";
            StatusExcluded = $"(제외된 사람: {_winners.Count}명)";
        }
        
        private void Shuffle<T>(IList<T> list)
        {
            int n = list.Count;
            while (n > 1)
            {
                n--;
                int k = _random.Next(n + 1);
                (list[k], list[n]) = (list[n], list[k]);
            }
        }

        private bool ConfirmAction(string message)
        {
            return MessageBox.Show(message, "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes;
        }
        #endregion

        #region UI 로직 및 추첨
        
        // ... (StartRaffle, ManageWinners, ResetAll, HandleEscKey는 수정 없음) ...
        private void StartRaffle(object? obj)
        {
            UpdateEligibleParticipants(); 
            if (_eligibleParticipants.Count == 0)
            {
                MessageBox.Show("먼저 '파일불러오기'로 명단을 불러오거나, 추첨 가능 인원이 남아있는지 확인하세요.");
                return;
            }

            SetupVisibility = Visibility.Collapsed;
            PlayButtonVisibility = Visibility.Visible;
            StopButtonVisibility = Visibility.Collapsed;
            CongratsMessageVisibility = Visibility.Collapsed;
            RaffleDisplay = "곧 추첨한다";
        }

        private async void ManageWinners(object? obj)
        {
            var dialog = new ManageWinnersWindow();
            bool? result = dialog.ShowDialog();

            if (result == true)
            {
                MessageBox.Show("당첨자 목록 변경사항이 저장되었습니다.");
                await LoadWinnersFromFileAsync(); 
            }
        }

        private void ResetAll(object? obj)
        {
            if (ConfirmAction("정말로 모든 명단과 당첨 기록을 초기화하시겠습니까?"))
            {
                _allParticipants.Clear();
                _eligibleParticipants.Clear();
                _winners.Clear();
                Task.Run(SaveWinnersToFileAsync);
                UpdateEligibleParticipants(); 
                MessageBox.Show("모든 데이터가 초기화되었습니다.");
                RaffleDisplay = "곧 추첨한다";
            }
        }

        public void HandleEscKey()
        {
            if (SetupVisibility == Visibility.Collapsed &&
                StopButtonVisibility == Visibility.Collapsed)
            {
                PlayButtonVisibility = Visibility.Collapsed;
                SetupVisibility = Visibility.Visible;
                RaffleDisplay = "곧 추첨한다";
                CongratsMessageVisibility = Visibility.Collapsed;
            }
        }
        #endregion

        #region 비동기 추첨 로직 (Async/Await)
        
        // ... (StartRafflingAsync, StopRaffling은 수정 없음) ...
        private async Task StartRafflingAsync()
        {
            if (!int.TryParse(RaffleCount, out int drawCount) || drawCount < 1)
            {
                MessageBox.Show("추첨 인원은 1 이상의 숫자로 입력해야 합니다.");
                return;
            }

            if (_eligibleParticipants.Count < drawCount)
            {
                MessageBox.Show($"추첨 가능 인원({_eligibleParticipants.Count}명)이 요청한 인원({drawCount}명)보다 적습니다.");
                return;
            }

            PlayButtonVisibility = Visibility.Collapsed;
            CongratsMessageVisibility = Visibility.Collapsed;
            StopButtonVisibility = Visibility.Visible; 

            _raffleCts = new CancellationTokenSource();
            CancellationToken token = _raffleCts.Token;

            try
            {
                while (!token.IsCancellationRequested)
                {
                    int index = _random.Next(_eligibleParticipants.Count);
                    RaffleDisplay = _eligibleParticipants[index].DisplayInfo;
                    await Task.Delay(30, token);
                }
            }
            catch (TaskCanceledException)
            {
                FinalizeWinners(drawCount);
            }
        }

        private void StopRaffling(object? obj)
        {
            _raffleCts.Cancel();
        }

        
        // ==================== [ 수정된 부분: "데드락(멈춤)" 해결 ] ====================
        private void FinalizeWinners(int drawCount)
        {
            // '점차 느려지는' 동작 *삭제* (즉시 멈춤)
            
            // --- 즉시 최종 당첨자 확정 ---
            List<Person> newWinners = new List<Person>();
            StringBuilder winnerDisplay = new StringBuilder();

            for (int i = 0; i < drawCount; i++)
            {
                if (_eligibleParticipants.Count == 0) break;
                int winnerIndex = _random.Next(_eligibleParticipants.Count);
                Person winner = _eligibleParticipants[winnerIndex];
                newWinners.Add(winner);
                winnerDisplay.AppendLine(winner.DisplayInfo);

                // 'Dispatcher.Invoke' 삭제 (데드락 방지)
                _winners.Add(winner);
                
                _eligibleParticipants.RemoveAt(winnerIndex);
            }

            Task.Run(SaveWinnersToFileAsync);

            RaffleDisplay = winnerDisplay.ToString().Trim();
            StopButtonVisibility = Visibility.Collapsed;
            CongratsMessageVisibility = Visibility.Visible; 

            // 파티클(폭죽) 옵션이 켜져 있을 때만(true) 이벤트를 발생시킴
            if (IsParticleEnabled)
            {
                OnFireworksEvent(); 
            }
            
            if(_eligibleParticipants.Count > 0)
            {
                PlayButtonVisibility = Visibility.Visible;
            }
            else
            {
                RaffleDisplay = "모든 인원 추첨 완료!\n" + winnerDisplay.ToString().Trim();
            }
        }
        // =======================================================================
        #endregion
    }
}
2. ?? MainWindow.xaml (전체 교체)
"화면 움직임(점프)" 버그를 해결하기 위해 STOP 버튼과 "축하" 메시지를 Grid 안에 겹쳐 레이아웃 락을 걸었습니다.

하단 메뉴에 CheckBox("Particles")를 추가하고, IsParticleEnabled 속성에 바인딩했습니다.

XML

<Window x:Class="TownhallLuckyDraw25.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:TownhallLuckyDraw25"
        xmlns:viewmodels="clr-namespace:TownhallLuckyDraw25.ViewModels"
        xmlns:converters="clr-namespace:TownhallLuckyDraw25.Converters"
        mc:Ignorable="d"
        Title="Townhall Lucky Draw 25" Height="720" Width="1080"
        WindowStartupLocation="CenterScreen"
        KeyDown="Window_KeyDown"
        WindowStyle="None"
        ResizeMode="NoResize"
        WindowState="Maximized">
    
    <Window.Background>
        <LinearGradientBrush StartPoint="0.5,0" EndPoint="0.5,1">
            <GradientStop Color="#000020" Offset="0.0" /> <GradientStop Color="Black" Offset="1.0" />
        </LinearGradientBrush>
    </Window.Background>

    <Window.DataContext>
        <viewmodels:MainViewModel/>
    </Window.DataContext>

    <Window.Resources>
        <converters:PercentageConverter x:Key="PercentageConverter"/>
        <LinearGradientBrush x:Key="GradientBorderBrush" StartPoint="0,0.5" EndPoint="1,0.5">
            <GradientStop Color="LightBlue" Offset="0.0" />
            <GradientStop Color="#00A2EB" Offset="0.5" />
            <GradientStop Color="DarkBlue" Offset="1.0" />
        </LinearGradientBrush>
        <Storyboard x:Key="AnimateBrush" RepeatBehavior="Forever" AutoReverse="True">
            <ColorAnimation Storyboard.TargetProperty="(Border.BorderBrush).(GradientBrush.GradientStops)[0].Color"
                            To="#00A2EB" Duration="0:0:3" BeginTime="0:0:0" />
            <ColorAnimation Storyboard.TargetProperty="(Border.BorderBrush).(GradientBrush.GradientStops)[1].Color"
                            To="DarkBlue" Duration="0:0:3" BeginTime="0:0:1.5" />
            <ColorAnimation Storyboard.TargetProperty="(Border.BorderBrush).(GradientBrush.GradientStops)[2].Color"
                            To="LightBlue" Duration="0:0:3" BeginTime="0:0:3" />
        </Storyboard>
        <Style x:Key="InnerPlayButtonStyle" TargetType="Button">
            <Setter Property="Width" Value="100"/>
            <Setter Property="Height" Value="100"/>
            <Setter Property="Margin" Value="0,0,25,0"/>
            <Setter Property="VerticalAlignment" Value="Center"/>
            <Setter Property="HorizontalAlignment" Value="Right"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Grid Background="Transparent">
                            <Image Source="/Images/playbutton.png" 
                                   Stretch="Uniform"/>
                        </Grid>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
        <Style x:Key="BottomButtonStyle" TargetType="Button">
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="FontSize" Value="16"/>
            <Setter Property="Padding" Value="15,10"/>
            <Setter Property="Margin" Value="5,0"/>
            <Setter Property="Cursor"Value="Hand"/>
        </Style>
        <Style x:Key="SystemButtonStyle" TargetType="Button">
            <Setter Property="Foreground" Value="White"/>
            <Setter Property="FontSize" Value="14"/>
            <Setter Property="FontWeight" Value="Bold"/>
            <Setter Property="Background" Value="#333"/>
            <Setter Property="BorderThickness" Value="0"/>
            <Setter Property="Padding" Value="10,5"/>
            <Setter Property="Margin" Value="5,0"/>
            <Setter Property="Cursor" Value="Hand"/>
            <Setter Property="Template">
                <Setter.Value>
                    <ControlTemplate TargetType="Button">
                        <Border Background="{TemplateBinding Background}" CornerRadius="3">
                            <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                        </Border>
                        <ControlTemplate.Triggers>
                            <Trigger Property="IsMouseOver" Value="True">
                                <Setter Property="Background" Value="#555"/>
                            </Trigger>
                        </ControlTemplate.Triggers>
                    </ControlTemplate>
                </Setter.Value>
            </Setter>
        </Style>
    </Window.Resources>
    
    <Grid x:Name="MainGrid">
        <Grid.RowDefinitions>
            <RowDefinition Height="*"/> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/> </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" VerticalAlignment="Bottom" 
                    MouseLeftButtonDown="Window_MouseLeftButtonDown"
                    Width="{Binding ActualWidth, ElementName=MainRaffleBorder}">
            <Viewbox Height="60" Margin="100,5,100,5" HorizontalAlignment="Stretch">
                <TextBlock Text="The 1st" 
                           Foreground="White" 
                           FontFamily="/Fonts/#더 잠실 9 Regular" 
                           HorizontalAlignment="Center"/>
            </Viewbox>
            <Viewbox Height="90" Margin="100,5,100,5" HorizontalAlignment="Stretch">
                <TextBlock FontSize="30"
                           FontFamily="/Fonts/#더 잠실 5 Bold" 
                           HorizontalAlignment="Center">
                    <Run Text="COO" Foreground="SkyBlue"/>
                    <Run Text=" &amp; " Foreground="White"/>
                    <Run Text="GUMI dat" Foreground="White"/>
                </TextBlock>
            </Viewbox>
        </StackPanel>

        <StackPanel Grid.Row="1" HorizontalAlignment="Center">
            
            <Grid>
                <Border x:Name="MainRaffleBorder">
                    <Border.Triggers>
                        <EventTrigger RoutedEvent="Loaded">
                            <BeginStoryboard Storyboard="{StaticResource AnimateBrush}"/>
                        </EventTrigger>
                    </Border.Triggers>
                    
                    <Border.Style>
                        <Style TargetType="Border">
                            <Setter Property="BorderBrush" Value="{StaticResource GradientBorderBrush}" />
                            <Setter Property="BorderThickness" Value="18" />
                            <Setter Property="CornerRadius" Value="10" />
                            <Setter Property="Margin" Value="0,20,0,0" />
                            <Setter Property="Width" Value="{Binding ActualWidth, ElementName=MainGrid, Converter={StaticResource PercentageConverter}, ConverterParameter=0.9}" />
                            <Setter Property="Height" Value="{Binding ActualHeight, ElementName=MainGrid, Converter={StaticResource PercentageConverter}, ConverterParameter=0.3}" />
                        </Style>
                    </Border.Style>
                    <Grid>
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="*"/>
                            <ColumnDefinition Width="Auto"/>
                        </Grid.ColumnDefinitions>
                        <Viewbox Grid.Column="0" Stretch="Uniform">
                            <TextBlock Text="{Binding RaffleDisplay, Mode=OneWay}"
                                       FontSize="50"
                                       FontFamily="/Fonts/#더 잠실 5 Bold"
                                       Foreground="White"
                                       VerticalAlignment="Center"
                                       HorizontalAlignment="Center"
                                       Padding="20"/>
                        </Viewbox>
                        <Button Grid.Column="1"
                                Style="{StaticResource InnerPlayButtonStyle}"
                                Command="{Binding PlayCommand}"
                                Visibility="{Binding PlayButtonVisibility}"/>
                    </Grid>
                </Border>
                
                <Canvas x:Name="ParticleCanvas" 
                        IsHitTestVisible="False" 
                        Width="{Binding Width, ElementName=MainRaffleBorder}" 
                        Height="{Binding Height, ElementName=MainRaffleBorder}"
                        Margin="{Binding Margin, ElementName=MainRaffleBorder}"/>
            </Grid>
            
            
            <Grid Margin="0,50,0,0" 
                  Width="{Binding ActualWidth, ElementName=MainRaffleBorder}"
                  HorizontalAlignment="Center">
                
                <Button Content="STOP"
                        FontSize="80" 
                        FontWeight="Bold"
                        Foreground="White"
                        Command="{Binding StopCommand}"
                        Visibility="{Binding StopButtonVisibility}"
                        Width="400" Height="160"
                        HorizontalAlignment="Center" VerticalAlignment="Center">
                    <Button.Template>
                        <ControlTemplate TargetType="Button">
                            <Border x:Name="ButtonBorder" 
                                    BorderBrush="{StaticResource GradientBorderBrush}" 
                                    BorderThickness="5" CornerRadius="10" 
                                    Background="#333"
                                    RenderTransformOrigin="0.5,0.5">
                                <Border.RenderTransform>
                                    <ScaleTransform ScaleX="1.0" ScaleY="1.0" />
                                </Border.RenderTransform>
                                <ContentPresenter HorizontalAlignment="Center" VerticalAlignment="Center"/>
                            </Border>
                            <ControlTemplate.Triggers>
                                <Trigger Property="IsMouseOver" Value="True">
                                    <Setter TargetName="ButtonBorder" Property="Background" Value="#444"/>
                                </Trigger>
                                <Trigger Property="IsPressed" Value="True">
                                    <Setter TargetName="ButtonBorder" Property="Background" Value="#222"/>
                                    <Setter TargetName="ButtonBorder" Property="RenderTransform">
                                        <Setter.Value>
                                            <ScaleTransform ScaleX="0.95" ScaleY="0.95" />
                                        </Setter.Value>
                                    </Setter>
                                </Trigger>
                            </ControlTemplate.Triggers>
                        </ControlTemplate>
                    </Button.Template>
                </Button>
                
                <Viewbox Height="200" 
                         Margin="0,10,0,0" 
                         HorizontalAlignment="Center" VerticalAlignment="Center"
                         Width="{Binding ActualWidth, ElementName=MainGrid, Converter={StaticResource PercentageConverter}, ConverterParameter=0.45}"
                         Visibility="{Binding CongratsMessageVisibility}"
                         RenderTransformOrigin="0.5,0.5">
                    
                    <TextBlock Text="당첨을 축하드립니다."
                               Foreground="White"
                               FontFamily="/Fonts/#더 잠실 5 Bold"
                               HorizontalAlignment="Center">
                        <TextBlock.RenderTransform>
                            <ScaleTransform ScaleX="0.5" ScaleY="0.5"/>
                        </TextBlock.RenderTransform>
                        <TextBlock.Style>
                            <Style TargetType="TextBlock">
                                <Setter Property="Opacity" Value="0"/>
                                <Style.Triggers>
                                    <Trigger Property="Visibility"Value="Visible">
                                        <Setter Property="Opacity" Value="1"/>
                                        <Trigger.EnterActions>
                                            <BeginStoryboard>
                                                <Storyboard>
                                                    <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)"
                                                                     To="1.0" Duration="0:0:0.5">
                                                        <DoubleAnimation.EasingFunction>
                                                            <BackEase EasingMode="EaseOut" Amplitude="0.3"/>
                                                        </DoubleAnimation.EasingFunction>
                                                    </DoubleAnimation>
                                                    <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)"
                                                                     To="1.0" Duration="0:0:0.5">
                                                        <DoubleAnimation.EasingFunction>
                                                            <BackEase EasingMode="EaseOut" Amplitude="0.3"/>
                                                        </DoubleAnimation.EasingFunction>
                                                    </DoubleAnimation>
                                                    <DoubleAnimation Storyboard.TargetProperty="Opacity"
                                                                     From="0" To="1" Duration="0:0:0.3"/>
                                                </Storyboard>
                                            </BeginStoryboard>
                                        </Trigger.EnterActions>
                                        <Trigger.ExitActions>
                                            <BeginStoryboard>
                                                <Storyboard>
                                                    <DoubleAnimation Storyboard.TargetProperty="Opacity" To="0" Duration="0:0:0.1"/>
                                                    <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleX)" To="0.5" Duration="0:0:0.1"/>
                                                    <DoubleAnimation Storyboard.TargetProperty="(UIElement.RenderTransform).(ScaleTransform.ScaleY)" To="0.5" Duration="0:0:0.1"/>
                                                </Storyboard>
                                            </BeginStoryboard>
                                        </Trigger.ExitActions>
                                    </Trigger>
                                </Style.Triggers>
                            </TextBlock.Style>
                        </TextBlock>
                    </Viewbox>
                </Grid>
            </StackPanel>
        
        <Border Grid.Row="2" 
                BorderBrush="Gray" 
                BorderThickness="1" 
                Background="#222222"
                VerticalAlignment="Bottom"
                Height="80"
                Visibility="{Binding SetupVisibility}">
            
            <Grid>
                <Grid.ColumnDefinitions>
                    <ColumnDefinition Width="*"/> 
                    <ColumnDefinition Width="Auto"/>
                </Grid.ColumnDefinitions>
                
                <StackPanel Grid.Column="0" Orientation="Horizontal" VerticalAlignment="Center" HorizontalAlignment="Center">
                    <Button Content="파일불러오기" Style="{StaticResource BottomButtonStyle}" Background="SkyBlue" Command="{Binding LoadFileCommand}"/>
                    <Button Content="추첨시작" Style="{StaticResource BottomButtonStyle}" Background="Red" Command="{Binding StartRaffleCommand}"/>
                    <Button Content="뽑힌사람관리" Style="{StaticResource BottomButtonStyle}" Background="Purple" Command="{Binding ManageWinnersCommand}"/>
                    <Button Content="초기화" Style="{StaticResource BottomButtonStyle}" Background="Orange" Command="{Binding ResetCommand}"/>
                    <TextBlock Text="추첨인원:" Foreground="White" FontSize="16" VerticalAlignment="Center" Margin="20,0,5,0"/>
                    <TextBox Text="{Binding RaffleCount, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}" Width="50" FontSize="16" VerticalAlignment="Center" TextAlignment="Center"/>
                    
                    <CheckBox Content="Particles"
                              IsChecked="{Binding IsParticleEnabled, Mode=TwoWay}"
                              Foreground="White"
                              FontSize="14"
                              VerticalAlignment="Center"
                              Margin="15,0,0,0"/>
                    
                    <TextBlock Foreground="Gray" FontSize="14" VerticalAlignment="Center" Margin="15,0,0,0">
                        <Run Text="{Binding StatusTotalLoaded}"/>
                        <Run Text=" "/>
                        <Run Text="{Binding StatusExcluded}"/>
                    </TextBlock>
                </StackPanel>
                <StackPanel Grid.Column="1" Orientation="Horizontal" VerticalAlignment="Center" HorizontalAlignment="Right" Margin="0,0,20,0">
                    <Button Content="_" Style="{StaticResource SystemButtonStyle}" Width="30" Click="MinimizeButton_Click"/>
                    <Button Content="X" Style="{StaticResource SystemButtonStyle}" Width="30" Click="CloseButton_Click"/>
                </StackPanel>
            </Grid>
        </Border>
    </Grid>
</Window>
3. ?? MainWindow.xaml.cs (전체 교체)
**"락(Freeze) 현상"**을 해결하기 위해 파티클 생성 로직을 **Task.Run (백그라운드 스레드)**을 사용하도록 완전히 재설계한 최종본입니다.

이전 MainWindow.xaml.cs 파일의 모든 내용을 아래 코드로 덮어쓰세요.

C#

using System;
using System.Threading; // ★ (Thread.Sleep) 추가
using System.Threading.Tasks; // ★ (Task.Run) 추가
using System.Windows;
using System.Windows.Controls;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows.Media.Animation;
using System.Windows.Shapes;
using TownhallLuckyDraw25.ViewModels;

namespace TownhallLuckyDraw25
{
    /// <summary>
    /// Interaction logic for MainWindow.xaml
    /// </summary>
    public partial class MainWindow : Window
    {
        // 멈춤 현상(Freeze) 방지를 위한 '잠금 장치'
        private bool _isFireworksRunning = false;

        public MainWindow()
        {
            InitializeComponent();

            if (this.DataContext is MainViewModel viewModel)
            {
                // ★ ViewModel의 FireworksEvent(신호)가 오면 ShowFireworks() 실행
                viewModel.FireworksEvent += ShowFireworks;
            }
        }

        // ESC 키 처리
        private void Window_KeyDown(object sender, KeyEventArgs e)
        {
            if (e.Key == Key.Escape)
            {
                if (this.DataContext is MainViewModel viewModel)
                {
                    viewModel.HandleEscKey();
                }
            }
        }

        // 창 드래그
        private void Window_MouseLeftButtonDown(object sender, MouseButtonEventArgs e)
        {
            if (e.ButtonState == MouseButtonState.Pressed)
            {
                this.DragMove();
            }
        }

        // 최소화
        private void MinimizeButton_Click(object sender, RoutedEventArgs e)
        {
            this.WindowState = WindowState.Minimized;
        }

        // 종료
        private void CloseButton_Click(object sender, RoutedEventArgs e)
        {
            this.Close();
        }

        // ==================== [ 수정된 부분: "락(Freeze) 현상" 근본 해결 ] ====================
        /// <summary>
        /// ViewModel로부터 신호를 받아 파티클 애니메이션을 생성하고 실행합니다.
        /// (UI 멈춤을 방지하기 위해 Task.Run을 사용하여 백그라운드 스레드에서 작업)
        /// </summary>
        private void ShowFireworks()
        {
            // 1. 이미 폭죽이 터지는 중이면, 새 폭죽을 실행하지 않고 즉시 종료 (충돌 방지)
            if (_isFireworksRunning) return;
            
            _isFireworksRunning = true; // 잠금 활성화

            // 2. 파티클 생성 로직을 백그라운드 스레드(Task.Run)에서 실행 (UI 스레드 해방)
            Task.Run(() =>
            {
                int particleCount = 200; 
                double centerX = 0;
                double centerY = 0;

                // 3. 캔버스 크기 정보만 UI 스레드에서 잠시 가져옴
                Application.Current.Dispatcher.Invoke(() =>
                {
                    centerX = ParticleCanvas.ActualWidth / 2;
                    centerY = ParticleCanvas.ActualHeight / 2;
                });

                if (centerX == 0)
                {
                    _isFireworksRunning = false; // 캔버스 준비 안됨, 잠금 해제
                    return; 
                }

                // 4. 백그라운드 스레드 전용 Random 객체 생성
                var localRandom = new Random(); 

                for (int i = 0; i < particleCount; i++)
                {
                    // 5. 파티클/애니메이션 생성 (이건 백그라운드 스레드에서 실행됨 - UI 안 멈춤)
                    
                    // (이 객체들은 아직 UI에 연결되지 않았으므로 백그라운드에서 만들어도 안전함)
                    Rectangle particle = new Rectangle
                    {
                        Width = localRandom.Next(5, 12),
                        Height = localRandom.Next(5, 12),
                        Fill = GetRandomBrush(localRandom), // 로컬 Random 객체 전달
                        Opacity = 1.0
                    };

                    var storyboard = new Storyboard();
                    double duration = localRandom.NextDouble() * 0.5 + 0.5; // 1초 이내
                    double angle = localRandom.NextDouble() * 360;
                    double distance = localRandom.NextDouble() * 500 + 300; // 반경 확대
                    double targetX = centerX - particle.Width / 2 + (Math.Cos(angle) * distance);
                    double targetY = centerY - particle.Height / 2 + (Math.Sin(angle) * distance);

                    DoubleAnimation xAnim = new DoubleAnimation(targetX, TimeSpan.FromSeconds(duration));
                    DoubleAnimation yAnim = new DoubleAnimation(targetY, TimeSpan.FromSeconds(duration));
                    xAnim.EasingFunction = new QuadraticEase { EasingMode = EasingMode.EaseOut };
                    yAnim.EasingFunction = new QuadraticEase { EasingMode = EasingMode.EaseOut };
                    Storyboard.SetTargetProperty(xAnim, new PropertyPath(Canvas.LeftProperty));
                    Storyboard.SetTargetProperty(yAnim, new PropertyPath(Canvas.TopProperty));

                    DoubleAnimation opacityAnim = new DoubleAnimation(0, TimeSpan.FromSeconds(duration * 0.7)); 
                    opacityAnim.BeginTime = TimeSpan.FromSeconds(duration * 0.3); 
                    Storyboard.SetTargetProperty(opacityAnim, new PropertyPath(UIElement.OpacityProperty));
                    
                    storyboard.Children.Add(xAnim);
                    storyboard.Children.Add(yAnim);
                    storyboard.Children.Add(opacityAnim);

                    // 6. 생성 완료된 객체를 UI 스레드로 다시 보내서 화면에 적용
                    Application.Current.Dispatcher.Invoke(() =>
                    {
                        ParticleCanvas.Children.Add(particle);
                        Canvas.SetLeft(particle, centerX - particle.Width / 2);
                        Canvas.SetTop(particle, centerY - particle.Height / 2);

                        Storyboard.SetTarget(xAnim, particle);
                        Storyboard.SetTarget(yAnim, particle);
                        Storyboard.SetTarget(opacityAnim, particle);

                        storyboard.Completed += (s, e) =>
                        {
                            ParticleCanvas.Children.Remove(particle);
                        };
                        storyboard.Begin(); // UI 스레드에서 애니메이션 시작
                    });

                    // 7. 백그라운드 스레드에서 1ms 대기 (0.2초간 200개 생성)
                    Thread.Sleep(1);
                }
                
                // 8. 모든 생성이 끝나면 잠금 해제
                _isFireworksRunning = false;
            });
        }

        /// <summary>
        /// 파티클을 위한 랜덤 브러시(색상) 반환
        /// (반드시 스레드 전용 Random 객체를 받아야 함)
        /// </summary>
        private Brush GetRandomBrush(Random random)
        {
            Color[] colors = { Colors.Gold, Colors.HotPink, Colors.LightBlue, Colors.LawnGreen, Colors.OrangeRed, Colors.White };
            return new SolidColorBrush(colors[random.Next(colors.Length)]);
        }
        // =======================================================================
    }
}