래는 SocketClientMergeOI 클래스에서 이벤트를 통해 MergeOIErrLogManager로 메시지를 전달하는 구조입니다. 이벤트를 활용하여 두 클래스 간의 독립성을 유지하면서도 메시지 전달이 가능하도록 설계했습니다.

1. SocketClientMergeOI 클래스
SocketClientMergeOI는 특정 조건에서 로그 메시지를 이벤트로 전달합니다.

csharp
코드 복사
using System;

public class SocketClientMergeOI
{
    // 로그 이벤트 선언
    public event Action<string> OnLogReceived;

    /// <summary>
    /// 로그 메시지를 이벤트로 전송
    /// </summary>
    /// <param name="logMessage">로그 메시지</param>
    private void RaiseLogEvent(string logMessage)
    {
        OnLogReceived?.Invoke(logMessage); // 이벤트 발생
    }

    /// <summary>
    /// 예제 함수: 소켓 메시지 처리 중 에러 발생 시 로그 이벤트 호출
    /// </summary>
    public void ProcessSocketMessage(string receivedMessage)
    {
        try
        {
            // 예제: 소켓 메시지 처리 로직
            if (receivedMessage.Contains("ERROR"))
            {
                // 에러 로그 전송
                string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] ERROR: {receivedMessage}";
                RaiseLogEvent(logMessage);
            }
        }
        catch (Exception ex)
        {
            // 예외 로그 전송
            string errorLog = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] EXCEPTION: {ex.Message}";
            RaiseLogEvent(errorLog);
        }
    }
}
2. MergeOIErrLogManager 클래스
MergeOIErrLogManager는 이벤트를 구독하여 전달받은 메시지를 처리합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly object _lock = new object();

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    /// <summary>
    /// 이벤트로 전달된 로그 처리
    /// </summary>
    /// <param name="logLine">로그 라인</param>
    public void HandleLogEvent(string logLine)
    {
        var newEntry = ParseLogLine(logLine);
        if (newEntry != null)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                lock (_lock)
                {
                    LogEntries.Add(newEntry);

                    // 오래된 로그 삭제 (2일 이전 로그 제거)
                    var cutoffTime = DateTime.Now.AddDays(-2);
                    for (int i = LogEntries.Count - 1; i >= 0; i--)
                    {
                        if (LogEntries[i].Time < cutoffTime)
                        {
                            LogEntries.RemoveAt(i);
                        }
                    }
                }
            });
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간]
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
3. MainViewModel에서 연결
뷰모델에서 두 클래스의 이벤트를 연결하고 MergeOIErrLogManager를 초기화합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    public MergeOIErrLogManager LogManager { get; private set; }
    private SocketClientMergeOI _socketClient;

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => LogManager.LogEntries;

    public MainViewModel()
    {
        LogManager = new MergeOIErrLogManager();
        _socketClient = new SocketClientMergeOI();

        // 이벤트 구독
        _socketClient.OnLogReceived += LogManager.HandleLogEvent;

        // 테스트: 소켓 메시지 처리
        Task.Run(() => SimulateSocketMessages());
    }

    /// <summary>
    /// 테스트용: 소켓 메시지 시뮬레이션
    /// </summary>
    private async Task SimulateSocketMessages()
    {
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Connection lost");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("INFO: Reconnected");
        await Task.Delay(1000);
        _socketClient.ProcessSocketMessage("ERROR: Timeout");
    }
}
4. XAML
DataGrid는 LogEntries를 표시하도록 바인딩합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- 시간 컬럼 -->
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <!-- 메시지 컬럼 -->
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <!-- 세부 내용 컬럼 -->
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
5. 코드 설명
SocketClientMergeOI에서 이벤트 발생

RaiseLogEvent 메서드를 통해 새로운 로그 메시지를 이벤트로 발생시킵니다.
OnLogReceived 이벤트를 통해 다른 클래스에서 로그 메시지를 받을 수 있습니다.
MergeOIErrLogManager에서 이벤트 처리

HandleLogEvent 메서드로 이벤트를 받아 로그를 파싱하고 UI에 반영합니다.
MainViewModel에서 클래스 연결

SocketClientMergeOI와 MergeOIErrLogManager를 연결하여 이벤트로 데이터 전달.
이벤트를 구독하여 소켓 메시지가 발생할 때마다 로그가 자동으로 추가됩니다.
테스트용 메시지

SimulateSocketMessages로 이벤트 기반 메시지 동작을 확인할 수 있습니다.
6. 결과