, C# WPF 애플리케이션에서 이전에 만든 Web API를 호출하는 방법을 알려드리겠습니다. HttpClient 클래스를 사용하는 것이 표준적인 방법입니다.

사전 준비:

WPF 프로젝트: Visual Studio에서 새 C# WPF 애플리케이션 프로젝트를 생성하거나 기존 프로젝트를 사용합니다. (.NET 6.0 또는 8.0 권장)
API 실행: 호출하려는 ASP.NET Core Web API 프로젝트가 실행 중이어야 합니다. 실행 시 사용되는 URL (예: https://localhost:7123)을 알고 있어야 합니다.
모델 클래스: API가 반환하는 JSON 구조와 동일한 C# 클래스가 WPF 프로젝트에도 필요합니다. API 프로젝트에서 사용했던 RepairInfo 클래스를 복사하거나, 별도의 클래스 라이브러리로 만들어 공유할 수 있습니다.
WPF 애플리케이션 구현 단계:

1. XAML (UI 디자인 - MainWindow.xaml)

간단한 예시로 바코드를 입력할 TextBox, API 호출을 시작할 Button, 결과를 표시할 TextBlock들을 배치합니다.

XML

<Window x:Class="WpfApiCaller.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:WpfApiCaller"
        mc:Ignorable="d"
        Title="API 호출 테스트" Height="350" Width="400">
    <StackPanel Margin="20">
        <TextBlock Text="바코드 입력:" />
        <TextBox x:Name="BarcodeTextBox" Margin="0,5,0,10" />

        <Button x:Name="CallApiButton" Content="정보 조회" Click="CallApiButton_Click" Width="100" HorizontalAlignment="Left" Margin="0,0,0,10"/>

        <TextBlock Text="결과:" FontWeight="Bold" Margin="0,10,0,5"/>
        <TextBlock x:Name="ModelTextBlock" Text="Model: " />
        <TextBlock x:Name="PointTextBlock" Text="Point: " />
        <TextBlock x:Name="DetailTextBlock" Text="Detail: " />

        <TextBlock x:Name="StatusTextBlock" Margin="0,15,0,0" Foreground="Gray"/>
    </StackPanel>
</Window>
2. C# 코드 비하인드 (MainWindow.xaml.cs)

버튼 클릭 이벤트를 처리하고, HttpClient를 사용하여 API를 호출하고, 결과를 UI에 표시하는 로직을 작성합니다.

C#

using System;
using System.Net.Http;
using System.Net.Http.Headers; // Accept 헤더 등을 위해 추가
using System.Text.Json;       // System.Text.Json 사용
using System.Threading.Tasks;
using System.Windows;

namespace WpfApiCaller
{
    // 1. API 응답을 담을 모델 클래스 정의 (API 프로젝트의 모델과 일치해야 함)
    public class RepairInfo
    {
        public string? Model { get; set; }
        public string? Point { get; set; }
        public string? Detail { get; set; }
    }

    public partial class MainWindow : Window
    {
        // 2. HttpClient 인스턴스 생성
        // 앱 전체에서 재사용하는 것이 좋지만, 간단한 예제에서는 필요시 생성
        // 참고: 실제 앱에서는 static으로 만들거나 DI 컨테이너로 관리하는 것이 더 효율적입니다.
        private static readonly HttpClient client = new HttpClient();

        public MainWindow()
        {
            InitializeComponent();

            // (선택사항) HttpClient 기본 설정 (앱 시작 시 한 번만)
            // API 서버의 기본 주소 설정 (매번 URL 전체를 입력하지 않도록)
            // 실제 API 주소로 변경하세요!
            client.BaseAddress = new Uri("https://localhost:7123/"); // API 서버 주소 끝에 '/' 포함
            client.DefaultRequestHeaders.Accept.Clear();
            client.DefaultRequestHeaders.Accept.Add(
                new MediaTypeWithQualityHeaderValue("application/json")); // JSON 응답 선호
        }

        // 3. 버튼 클릭 이벤트 핸들러 (async void 사용)
        private async void CallApiButton_Click(object sender, RoutedEventArgs e)
        {
            string barcode = BarcodeTextBox.Text;
            if (string.IsNullOrWhiteSpace(barcode))
            {
                StatusTextBlock.Text = "바코드를 입력하세요.";
                return;
            }

            // 이전 결과 초기화 및 상태 업데이트
            ModelTextBlock.Text = "Model: ";
            PointTextBlock.Text = "Point: ";
            DetailTextBlock.Text = "Detail: ";
            StatusTextBlock.Text = "API 호출 중...";

            try
            {
                // 4. API 호출 (GET 요청)
                // BaseAddress를 설정했으므로 상대 경로만 사용
                HttpResponseMessage response = await client.GetAsync($"api/RepairInfo/{barcode}");

                // 5. 응답 처리
                if (response.IsSuccessStatusCode) // 상태 코드가 2xx 인 경우 (성공)
                {
                    // 응답 본문을 문자열로 읽기
                    string jsonResponse = await response.Content.ReadAsStringAsync();

                    // 6. JSON 역직렬화 (JSON 문자열 -> RepairInfo 객체)
                    // JsonSerializerOptions를 사용하여 속성 이름 대소문자 구분 안 함 설정 가능
                    var options = new JsonSerializerOptions
                    {
                        PropertyNameCaseInsensitive = true
                    };
                    RepairInfo? repairInfo = JsonSerializer.Deserialize<RepairInfo>(jsonResponse, options);

                    if (repairInfo != null)
                    {
                        // 7. UI 업데이트 (성공)
                        ModelTextBlock.Text = $"Model: {repairInfo.Model ?? "N/A"}";
                        PointTextBlock.Text = $"Point: {repairInfo.Point ?? "N/A"}";
                        DetailTextBlock.Text = $"Detail: {repairInfo.Detail ?? "N/A"}";
                        StatusTextBlock.Text = "조회 완료";
                    }
                    else
                    {
                         StatusTextBlock.Text = "데이터를 읽었지만, 내용을 처리할 수 없습니다.";
                    }
                }
                else if (response.StatusCode == System.Net.HttpStatusCode.NotFound) // 404 Not Found
                {
                    StatusTextBlock.Text = $"오류: 해당 바코드({barcode}) 정보를 찾을 수 없습니다. (404)";
                }
                else // 그 외 오류 상태 코드
                {
                    StatusTextBlock.Text = $"오류 발생: {response.StatusCode}";
                }
            }
            catch (HttpRequestException httpEx) // 네트워크/연결 관련 예외
            {
                // API 서버가 실행 중인지, URL이 맞는지, 네트워크 연결 상태 확인 필요
                StatusTextBlock.Text = $"네트워크 오류: {httpEx.Message}";
                // 개발 중 로컬 HTTPS 호출 시 인증서 문제일 수도 있음 (아래 '주의사항' 참고)
            }
            catch (JsonException jsonEx) // JSON 역직렬화 실패 예외
            {
                StatusTextBlock.Text = $"데이터 형식 오류: {jsonEx.Message}";
            }
            catch (Exception ex) // 그 외 모든 예외
            {
                StatusTextBlock.Text = $"알 수 없는 오류: {ex.Message}";
            }
        }
    }
}
설명:

RepairInfo 클래스: API 응답 JSON과 매핑될 C# 클래스를 정의합니다. 속성 이름과 타입이 JSON과 일치해야 합니다. Nullable(?)을 사용하여 JSON에 해당 필드가 없거나 null일 경우에 대비합니다.
HttpClient 생성: HTTP 요청을 보내기 위한 HttpClient 객체를 생성합니다. static readonly로 선언하여 애플리케이션 전체에서 인스턴스를 재사용하는 것이 좋습니다. 이는 소켓 고갈 문제를 방지하고 성능을 향상시킵니다.
async void 이벤트 핸들러: 버튼 클릭 이벤트 핸들러를 async void로 선언하여 내부에서 await 키워드를 사용, 비동기적으로 API를 호출할 수 있게 합니다. 이렇게 하면 API 호출 중에도 WPF UI가 멈추지 않고 반응성을 유지합니다.
API 호출 (GetAsync): client.GetAsync()를 사용하여 지정된 URL로 GET 요청을 비동기적으로 보냅니다. BaseAddress를 설정했기 때문에 상대 경로(api/RepairInfo/{barcode})만 사용합니다.
응답 처리 (HttpResponseMessage): GetAsync는 HttpResponseMessage 객체를 반환합니다. IsSuccessStatusCode 속성으로 요청 성공 여부(HTTP 상태 코드가 200-299 범위인지)를 확인합니다. StatusCode 속성으로 구체적인 상태 코드(예: 404 Not Found)를 확인할 수 있습니다.
JSON 역직렬화 (JsonSerializer.Deserialize): 성공적인 응답(2xx)의 경우, response.Content.ReadAsStringAsync()로 응답 본문을 문자열로 읽어옵니다. System.Text.Json.JsonSerializer.Deserialize<T>()를 사용하여 이 JSON 문자열을 미리 정의한 RepairInfo 객체로 변환합니다. PropertyNameCaseInsensitive = true 옵션은 JSON 속성 이름과 C# 속성 이름의 대소문자가 달라도 매핑되도록 해줍니다 (권장).
UI 업데이트: 역직렬화된 RepairInfo 객체의 데이터를 사용하여 TextBlock들의 Text 속성을 업데이트합니다. StatusTextBlock을 통해 현재 상태나 오류 메시지를 사용자에게 보여줍니다.
예외 처리: try...catch 블록을 사용하여 네트워크 오류(HttpRequestException), JSON 처리 오류(JsonException), 기타 예외 상황을 처리하고 사용자에게 적절한 메시지를 표시합니다.
주의사항 및 추가 팁:

API 서버 실행: WPF 앱 실행 전에 반드시 백엔드 API 서버가 실행 중이어야 합니다.
URL 확인: HttpClient의 BaseAddress 또는 GetAsync에 사용된 URL이 실제 실행 중인 API 서버의 주소 및 포트와 일치하는지 확인하세요. (HTTPS vs HTTP 주의)
HTTPS와 로컬 개발 인증서: 만약 API가 HTTPS(https://localhost:...)를 사용하고, 개발 환경에서 사용하는 자체 서명된 인증서가 클라이언트(WPF 앱 실행 머신)에서 신뢰되지 않으면 HttpRequestException이 발생할 수 있습니다.
해결 방법 1 (권장): dotnet dev-certs https --trust 명령어를 사용하여 개발 인증서를 신뢰하도록 설정합니다. (관리자 권한 필요)
해결 방법 2 (개발 중에만 임시 사용): HttpClientHandler를 사용하여 인증서 유효성 검사를 건너뛰도록 설정할 수 있으나, 보안상 매우 위험하므로 실제 운영 환경에서는 절대 사용하면 안 됩니다.
C#

// HttpClient 생성 시 Handler 설정 (개발 중에만 사용!)
var handler = new HttpClientHandler
{
    ServerCertificateCustomValidationCallback = HttpClientHandler.DangerousAcceptAnyServerCertificateValidator
};
private static readonly HttpClient client = new HttpClient(handler);
UI 스레드: async/await를 사용하면 대부분의 경우 await 이후 코드가 자동으로 원래의 UI 스레드 컨텍스트로 돌아와 UI 요소를 안전하게 업데이트할 수 있습니다. 하지만 복잡한 시나리오에서는 Dispatcher.InvokeAsync 또는 Dispatcher.BeginInvoke 사용이 필요할 수도 있습니다.
NuGet 패키지: 이 예제는 .NET에 내장된 System.Text.Json을 사용합니다. 만약 Newtonsoft.Json을 선호한다면 NuGet 패키지 관리자에서 Newtonsoft.Json을 설치하고 JsonConvert.DeserializeObject<T>()를 사용하면 됩니다.