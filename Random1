, 알겠습니다. 이제 다른 문제는 잠시 접어두고, 메인 화면에서 '새 사물함 추가' 후 저장했을 때 로그가 남지 않는 문제에만 집중하여 해결해 보겠습니다. 수정/삭제 시에는 로그가 남는다는 점이 중요 단서입니다.

이는 로그 기록 로직(AuditLogInterceptor)이 'Added' 상태의 엔티티를 처리하는 데 특정한 문제가 있음을 강하게 시사합니다. 가장 의심스러운 부분은 'Added' 상태일 때 엔티티의 모든 현재 값(CurrentValues)을 JSON으로 직렬화하여 NewValues에 저장하는 과정입니다. 새로 생성된 엔티티의 특정 속성 값 때문에 직렬화가 실패하거나, 생성된 로그 데이터에 문제가 있어 최종 로그 저장 단계(SaveAuditLogs 내부의 logContext.SaveChanges())에서 실패할 수 있습니다.

해결 방법:

AuditLogInterceptor.cs 파일의 GenerateAuditLogs 메서드에서, 엔티티 상태가 Added일 경우 NewValues 필드에 전체 데이터를 직렬화하는 대신, 단순히 추가되었다는 사실만 기록하도록 로직을 단순화합니다. 이렇게 하면 직렬화 오류 가능성을 완전히 배제하고 'Added' 로그 기록 자체의 성공 여부를 확인할 수 있습니다.

수정해야 할 파일 목록:

Infrastructure/AuditLogInterceptor.cs
아래는 이 수정 사항을 반영한 AuditLogInterceptor.cs 파일 전체 코드(주석 제외)입니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects;
using System.Data.Entity.Validation;

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}";

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { GenerateAuditLogs(interceptionContext); }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { SaveAuditLogs(interceptionContext); }
        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            foreach (var context in interceptionContext.DbContexts)
            {
                if (!(context is LockerDbContext dbContext) || !dbContext.ChangeTracker.HasChanges()) continue;

                bool isMaster = dbContext.IsMasterSave;
                string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
                string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

                if (!changedEntries.Any()) continue;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨 (isMaster={isMaster}).");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added)
                    {
                        Debug.WriteLine($"    - Added 상태 감지됨: {auditEntry.TableName}");
                        // *** 수정: Added 상태일 때 NewValues 단순화 ***
                        auditEntry.NewValues = "{ \"Status\": \"Added\" }"; // 직렬화 대신 고정 문자열 사용
                        Debug.WriteLine($"    - Added 로그 데이터 생성 완료 (단순화됨).");
                    }
                    else if (entry.State == EntityState.Deleted) { Debug.WriteLine($"    - Deleted 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } Debug.WriteLine($"    - Deleted 로그 데이터 생성 완료."); }
                    else if (entry.State == EntityState.Modified) { Debug.WriteLine($"    - Modified 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } Debug.WriteLine($"    - Modified 로그 데이터 생성 완료."); } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                    if (auditEntry != null) { Debug.WriteLine($"    -> auditEntries 리스트에 추가 시도: {auditEntry.TableName}, Action: {auditEntry.Action}"); auditEntries.Add(auditEntry); Debug.WriteLine($"    -> auditEntries 리스트에 추가 완료. 현재 리스트 개수: {auditEntries.Count}"); }
                    else { Debug.WriteLine($"    !!! 로그 객체 생성 실패? ({entry.Entity.GetType().Name})"); }
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any()) { string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode()); interceptionContext.UserState = auditEntries; Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장."); }
                 dbContext.IsMasterSave = false;
            }
        }

        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            List<AuditLog> auditEntries = interceptionContext.UserState as List<AuditLog>;
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges 시작. UserState에서 가져온 로그 수 = {auditEntries?.Count ?? 0}");
            if (auditEntries != null && auditEntries.Any()) { foreach(var log in auditEntries) Debug.WriteLine($"  - 저장 대상 로그: {log.Action} on {log.TableName} by {log.UserName}"); }

            if (interceptionContext.Exception == null && auditEntries != null && auditEntries.Any())
            {
                try { using (var logContext = new Data.LockerDbContext()) { Debug.WriteLine($"  -> {auditEntries.Count}개 로그 저장 시도 (새 Context 사용)..."); logContext.AuditLogs.AddRange(auditEntries); Debug.WriteLine($"  -> logContext.SaveChanges() 호출 시도..."); int logResult = logContext.SaveChanges(); Debug.WriteLine($"  -> 로그 저장 완료. 결과 = {logResult}"); } }
                catch (DbEntityValidationException vex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Validation): {vex.ToString()}"); LogValidationErrors(vex); }
                catch (DbUpdateException dbEx) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - Update): {dbEx.ToString()}"); LogDbUpdateException(dbEx); }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor - General): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"  -> 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"  -> 저장할 로그 없음."); }
            interceptionContext.UserState = null;
        }

        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) { try { var objectContext = ((IObjectContextAdapter)context).ObjectContext; var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity); if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) { return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value)); } if (entry.State == EntityState.Added) return "New"; } catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); } return "N/A"; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
    }
}
핵심 변경 사항:

GenerateAuditLogs 메서드:
if (entry.State == EntityState.Added) 블록 내부에서 NewValues를 생성하는 부분을 임시 진단용으로 간단한 문자열 auditEntry.NewValues = "{ \"Status\": \"Added\" }"; 로 변경했습니다. 원래의 JSON 직렬화 코드는 주석 처리했습니다.
다음 단계:

코드 적용 및 빌드: 위 코드로 AuditLogInterceptor.cs 파일을 업데이트하고 솔루션을 다시 빌드합니다.
테스트:
메인 화면(사물함 관리) 에서 새로운 행을 추가하고 저장 버튼을 클릭합니다.
로그 보기 창을 열어 Action이 "Added"이고 NewValues가 "{ Status: Added }" 인 로그가 기록되었는지 확인합니다.
결과 분석:
만약 단순화된 로그가 정상적으로 기록된다면, 문제는 원래의 Added 상태 엔티티에 대한 JSON 직렬화 과정에 있었던 것이 확실합니다. 이 경우, 직렬화 로직을 다시 검토하거나 필요한 정보만 선별하여 직렬화하는 방식으로 수정해야 합니다.