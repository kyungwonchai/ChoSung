약 DataGrid에 미완료된 명령만 표시하고, 완료된 명령은 모두 삭제하려면, RemainingCommands 컬렉션에 Pending, Processing, Retrying, Failed, Timeout 상태만 남기고, Completed 상태인 항목은 자동으로 삭제하는 방식으로 처리할 수 있습니다.

이를 위해 명령 상태가 Completed로 변경될 때 RemainingCommands 컬렉션에서 해당 항목을 삭제하도록 설정하면 됩니다.

해결 방법: 완료된 명령 제거
명령 상태가 완료(Completed)로 변경될 때 해당 항목을 제거:
명령의 상태가 **Completed**로 변경될 때 RemainingCommands 컬렉션에서 해당 명령을 삭제합니다.
UI에 미완료된 항목만 표시:
항상 미완료 상태만 DataGrid에 표시하고, 완료된 항목은 즉시 제거합니다.
수정된 코드
csharp
코드 복사
public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>(); // 미완료된 명령을 저장할 컬렉션
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>(); // 에러 발생한 명령을 저장할 컬렉션
    
    // 기타 기존 코드...

    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem
        {
            CommandText = commandText,
            Status = "Pending",
            MaxRetryLimit = RetryLimit,
            RetryCount = 0,
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff")
        };

        App.Current.Dispatcher.Invoke(() => RemainingCommands.Add(newCommand)); // 남은 명령 리스트에 추가

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing"; // 상태를 Processing으로 변경

            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch();
            _isProcessing = true;

            while (retryCount < RetryLimit)
            {
                try
                {
                    stopwatch.Restart();
                    string result = await taskFunc();
                    stopwatch.Stop();

                    int responseTime = (int)stopwatch.ElapsedMilliseconds;
                    newCommand.ResponseTime = responseTime;

                    // 응답이 올바르면 완료 처리
                    if (responseValidator(result))
                    {
                        newCommand.Status = "Completed"; // 상태를 Completed로 변경
                        newCommand.Result = 1;

                        // UI 갱신 후 완료된 명령은 RemainingCommands에서 삭제
                        App.Current.Dispatcher.Invoke(() =>
                        {
                            RemainingCommands.Remove(newCommand); // 완료된 명령 삭제
                        });

                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, result);
                        UpdateProgress();
                        _isProcessing = false;
                        return new CommandResult { Success = true, Message = result };
                    }
                    else if (responseTime > ResponseTimeout)
                    {
                        newCommand.Status = "Timeout"; // 타임아웃 상태로 처리
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Timeout occurred");
                        StopQueueProcessing(newCommand);
                        return new CommandResult { Success = false, Message = "Response Timeout" };
                    }
                    else
                    {
                        retryCount++;
                        newCommand.Status = $"Retrying {retryCount}/{RetryLimit}"; // 재시도 상태로 변경
                        await Task.Delay(RetryInterval);
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed"; // 예외 발생 시 실패 처리
                    newCommand.Result = 0;
                    stopwatch.Stop();
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;
                    newCommand.ResponseTime = responseTime;
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    StopQueueProcessing(newCommand);
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }

            UpdateProgress();
            _isProcessing = false;
            return new CommandResult { Success = false };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue(); // 큐에서 명령을 처리
        }

        UpdateProgress();
    }

    // 기타 기존 코드...
}
수정된 코드 설명:
Completed 상태의 명령 제거:

명령이 **성공적으로 완료(Completed)**되면, **RemainingCommands**에서 해당 항목을 삭제합니다.
RemainingCommands.Remove(newCommand)를 통해 완료된 명령을 제거하여 DataGrid에는 미완료 명령만 표시되도록 처리합니다.
미완료 상태만 표시:

RemainingCommands 컬렉션에 남아 있는 항목은 항상 Pending, Processing, Retrying, Failed, Timeout 상태의 항목만 포함됩니다.
Completed 상태가 되면 즉시 DataGrid에서 제거되어, 완료된 명령은 더 이상 표시되지 않습니다.
흐름:
명령이 추가될 때 Pending 상태로 **RemainingCommands**에 추가되어 UI(DataGrid)에 표시됩니다.
명령이 실행되면서 Processing 상태로 변경되고, UI에 반영됩니다.
응답이 올바르면 명령이 Completed 상태가 되고, RemainingCommands에서 삭제되어 DataGrid에서 사라집니다.
응답이 실패하거나 타임아웃이 발생하면 RemainingCommands에 남아 있으며, 이 상태는 계속 표시됩니다.
이 코드를 통해 미완료된 명령만 DataGrid에 표시되고, 완료된 명령은 자동으로 제거되어 