기존 for(;;) 무한 루프가 이미 별도의 스레드에서 실행되고 있었다면, 굳이 추가적인 스레드 생성 없이 비동기 방식 (Task.Run()) 을 사용하면 해결됩니다.
이제 WinForms 기반에서 메인 코드부터 UI까지 전체 코드를 제공할게요.

📌 전체 코드
WinForms 프로젝트를 생성한 후, 아래 코드를 Form1.cs 에 적용하면 됩니다.

csharp
Copy code
using System;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AsyncWinForms
{
    public partial class Form1 : Form
    {
        private CancellationTokenSource _cts;
        
        public Form1()
        {
            InitializeComponent();
        }

        // ✅ 버튼 클릭 시 무한 루프 시작 (기존 스레드 방식에서 Task.Run()으로 변경)
        private void btnStart_Click(object sender, EventArgs e)
        {
            if (_cts != null) return; // 이미 실행 중이면 중복 실행 방지

            _cts = new CancellationTokenSource();
            Task.Run(() => ProcessLoop(_cts.Token));
        }

        // ✅ 무한 루프 실행 함수 (이전의 스레드 대신 Task 사용)
        private async Task ProcessLoop(CancellationToken token)
        {
            for (;;)
            {
                if (token.IsCancellationRequested) break; // 종료 요청 시 루프 탈출

                // (1) 빠르게 실행되는 두 함수
                Function1();
                Function2();

                // (2) 오래 걸리는 함수는 병렬 실행
                _ = Task.Run(() => LongRunningFunction());

                // (3) 루프 간격을 조절하여 CPU 과부하 방지
                await Task.Delay(10);
            }
        }

        // ✅ 버튼 클릭 시 루프 중지
        private void btnStop_Click(object sender, EventArgs e)
        {
            _cts?.Cancel();
            _cts = null;
        }

        // ✅ 빠르게 실행되는 함수 1
        private void Function1()
        {
            AddLog("Function1 실행");
        }

        // ✅ 빠르게 실행되는 함수 2
        private void Function2()
        {
            AddLog("Function2 실행");
        }

        // ✅ 오래 걸리는 작업 (병렬 실행)
        private void LongRunningFunction()
        {
            AddLog("LongRunningFunction 시작");
            Thread.Sleep(3000); // 오래 걸리는 작업
            AddLog("LongRunningFunction 종료");
        }

        // ✅ ListBox에 로그 추가 (최대 100개 유지)
        private void AddLog(string message)
        {
            if (listBox1.InvokeRequired)
            {
                listBox1.Invoke((Action)(() => AddLog(message)));
                return;
            }

            if (listBox1.Items.Count >= 100)
                listBox1.Items.RemoveAt(0); // 100개 초과 시 가장 오래된 로그 삭제

            listBox1.Items.Add($"{DateTime.Now:HH:mm:ss} - {message}");
            listBox1.TopIndex = listBox1.Items.Count - 1; // 최신 로그 자동 스크롤
        }
    }
}
🔹 UI (Form1 디자인)
WinForms 디자이너에서 버튼과 리스트박스를 추가하세요.

button1 → btnStart (이름 변경)
button2 → btnStop (이름 변경)
listBox1 → 로그 출력 용
🚀 코드 동작 설명
[시작 버튼] (btnStart_Click)

기존 for(;;)을 Task.Run() 을 사용해 백그라운드에서 실행.
종료 요청을 받을 때까지 Function1(), Function2() 실행 후 LongRunningFunction()을 병렬로 처리.
[중지 버튼] (btnStop_Click)

CancellationTokenSource를 통해 루프를 안전하게 종료.
[비동기 처리]

Function1(), Function2()는 동기 실행.
LongRunningFunction()은 Task.Run()으로 별도 실행해 무한 루프를 멈추지 않음.
[ListBox에 로그 추가]

UI 업데이트를 위해 Invoke() 사용.
100개 초과 시 가장 오래된 로그 삭제하여 성능 유지.
✅ 이렇게 하면?
✔ 기존 스레드 방식 대신 Task.Run() 사용 → 더 가볍고 안정적
✔ LongRunningFunction()을 병렬 실행하여 루프가 멈추지 않음
✔ ListBox에 로그를 추가하며 오래된 로그는 자동 삭제 (최대 100개 유지)
✔ CPU 점유율 최소화 (await Task.Delay(10))