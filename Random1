송합니다. 제가 기대에 맞는 코드를 제대로 제공하지 못한 것 같습니다. 이제부터는 전체 작업 흐름과 각 파일별 세부 구조를 철저하게 정리하여, 로그 파일 처리부터 UI 표시까지의 전체 구조를 설명하겠습니다. 이를 기반으로 필요한 요청 사항을 주시면 추가로 맞춰드리겠습니다.

전반적인 흐름:
로그 파일 감지: 지정된 경로에서 로그 파일들이 생성될 때마다 감지하여 처리.
파일 내용 파싱: 각 로그 파일의 내용을 파싱하여 MAG_NO, PO_NO 등의 정보를 추출.
작업 목록에 추가: 파싱된 데이터를 기반으로 작업을 생성하여 DataGrid에 표시.
작업 순차 실행: 작업은 하나씩 순차적으로 실행되고, 해당 작업이 완료되면 다음 작업이 실행됨.
UI 업데이트: 각 작업의 함수 상태를 UI에서 도형으로 시각화. 진행 상태는 실시간으로 업데이트됨.
PLC 통신: PLC로 데이터를 보내고, 작업의 성공 또는 실패 여부를 처리.
에러 처리 및 대기열 관리: 작업 도중 에러가 발생하거나 통신이 실패했을 때 적절히 처리. 작업은 대기열에 쌓이며 순차적으로 처리됨.
파일별 구조 설명
1. LogEntry.cs (로그 파일의 내용을 저장하는 구조체)
Models/LogEntry.cs

csharp
코드 복사
/// <summary>
/// 로그 파일에서 파싱된 데이터를 저장하는 클래스.
/// 하나의 파일마다 PO 번호, MAG 번호 등 작업에 필요한 정보를 포함.
/// </summary>
public class LogEntry
{
    public string PO_NO { get; set; } // 주문 번호
    public string MAG_NO { get; set; } // 물류 번호
    public string BASIC_MODEL { get; set; } // 기본 모델
    public string MODEL_CODE { get; set; } // 모델 코드
    public int PO_PLAN_QTY { get; set; } // 계획된 수량
    public int PO_PROD_QTY { get; set; } // 생산된 수량
    public int MAG_QTY { get; set; } // 물류 수량
    public int SequenceFlag { get; set; } // 시퀀스 플래그
}
설명:
로그 파일에서 파싱한 데이터를 구조체처럼 보관합니다.
각 로그 파일의 정보를 기반으로 작업을 생성하기 위해 사용됩니다.
파싱한 데이터를 PO_NO, MAG_NO 등으로 저장하여 작업을 식별합니다.
2. FileWatcherService.cs (파일 감지 및 데이터 파싱)
Services/FileWatcherService.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;

/// <summary>
/// 지정된 경로에서 로그 파일을 감시하고 새로 생성된 파일을 감지하는 클래스.
/// 새로운 파일이 생성되면 해당 파일을 파싱하고 작업 목록에 추가.
/// </summary>
public class FileWatcherService
{
    private readonly string _logDirectory;
    private Action<LogEntry> _onFileDetected;

    public FileWatcherService(string logDirectory, Action<LogEntry> onFileDetected)
    {
        _logDirectory = logDirectory;
        _onFileDetected = onFileDetected;
    }

    /// <summary>
    /// 5초마다 경로를 확인하고 새 파일을 감지합니다.
    /// </summary>
    public async void StartWatching()
    {
        while (true)
        {
            var files = Directory.GetFiles(_logDirectory, "*.txt");
            foreach (var file in files)
            {
                var logEntry = ParseLogFile(file);
                _onFileDetected?.Invoke(logEntry); // 파일 파싱 후 LogEntry로 변환하여 작업 처리
            }
            await Task.Delay(5000); // 5초마다 체크
        }
    }

    /// <summary>
    /// 로그 파일을 파싱하여 LogEntry로 변환합니다.
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        // 파일 내용을 읽고, 파싱하여 LogEntry 객체 생성
        var lines = File.ReadAllLines(filePath);
        return new LogEntry
        {
            PO_NO = lines[0], // 예시로 파일 내용에서 필요한 정보를 파싱
            MAG_NO = lines[1],
            BASIC_MODEL = lines[2],
            MODEL_CODE = lines[3],
            PO_PLAN_QTY = int.Parse(lines[4]),
            PO_PROD_QTY = int.Parse(lines[5]),
            MAG_QTY = int.Parse(lines[6]),
            SequenceFlag = int.Parse(lines[7])
        };
    }
}
설명:
**FileWatcherService**는 지정된 경로에서 새 로그 파일을 감지하고, 해당 파일을 읽어 **LogEntry**로 변환.
감지된 파일은 onFileDetected 델리게이트를 통해 LogEntry 형태로 반환되어 후속 작업에서 처리됩니다.
5초마다 폴더를 스캔하여 새로운 파일을 찾아냅니다.
3. TaskQueue.cs (작업 대기열 관리 및 순차 실행)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// 여러 작업을 순차적으로 실행하고, 작업이 완료될 때까지 다음 작업을 대기하는 구조를 제공합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Func<string, Task>, Task<bool>>> _taskQueue;
    private bool _isRunning = false; // 현재 작업이 실행 중인지 여부

    public TaskQueue()
    {
        _taskQueue = new Queue<Func<Func<string, Task>, Task<bool>>>();
    }

    /// <summary>
    /// 작업을 대기열에 추가하고, 현재 실행 중인 작업이 없으면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Func<string, Task>, Task<bool>> task)
    {
        _taskQueue.Enqueue(task);
        if (!_isRunning)
        {
            RunNextTask(); // 작업 실행
        }
    }

    /// <summary>
    /// 대기열의 다음 작업을 실행합니다. 작업이 완료되면 다음 작업으로 넘어갑니다.
    /// </summary>
    private async void RunNextTask()
    {
        if (_taskQueue.Count == 0 || _isRunning) return; // 실행 중이면 무시

        _isRunning = true; // 작업 실행 중 플래그

        var task = _taskQueue.Dequeue(); // 대기열에서 작업 꺼내기
        try
        {
            var success = await task(UpdateTaskStatus);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"작업 중 오류 발생: {ex.Message}");
        }

        _isRunning = false; // 작업 완료됨

        RunNextTask(); // 다음 작업 실행
    }

    /// <summary>
    /// 각 작업의 상태를 업데이트합니다. (예: 작업 진행 중, 완료 등)
    /// </summary>
    private async Task UpdateTaskStatus(string status)
    {
        Console.WriteLine(status); // 상태 출력
        await Task.CompletedTask;
    }
}
설명:
작업이 대기열에 쌓이고, 순차적으로 실행됩니다.
작업이 완료되기 전에는 다음 작업이 실행되지 않으며, 작업이 완료되면 자동으로 다음 작업을 실행합니다.
예외 처리도 포함되어 있으며, 작업 중 문제가 발생하면 오류 메시지가 출력됩니다.
4. TaskModel.cs (작업 모델 및 상태 관리)
Models/TaskModel.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows.Input;

/// <summary>
/// 하나의 작업을 관리하며, 각 작업은 여러 함수를 순차적으로 실행합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    public List<string> Functions { get; set; } // 작업에서 실행할 함수 목록
    public List<string> FunctionStatuses { get; set; } // 함수 상태 (대기, 실행 중, 완료)
    public string CurrentFunctionStatus { get; set; } // 실시간 함수 상태

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Functions = new List<string> { "FunctionA", "FunctionB", "FunctionC" }; // 함수 목록
        FunctionStatuses = new List<string> { "Waiting", "Waiting", "Waiting" }; // 초기 상태

        StartCommand = new RelayCommand(StartTask);
        Status = "Pending"; // 기본 상태 설정
    }

    /// <summary>
    /// 각 함수가 순차적으로 실행되도록 작업을 대기열에 추가합니다.
    /// </summary>
    private void StartTask()
    {
        for (int i = 0; i < Functions.Count; i++)
        {
            int index = i;
            _taskQueue.EnqueueTask(async (updateStatus) =>
            {
                FunctionStatuses[index] = "Running"; // 함수 상태 업데이트
                OnPropertyChanged(nameof(FunctionStatuses)); // 상태 업데이트 알림

                // 실제 함수 실행 (PLC 통신 등을 포함)
                bool success = await _taskQueue.ExecuteSpecificTask(updateStatus, index);
                FunctionStatuses[index] = success ? "Completed" : "Error"; // 완료 후 상태 변경

                OnPropertyChanged(nameof(FunctionStatuses));
                return success;
            });
        }
    }
}
설명:
각 작업은 여러 개의 함수로 구성되며, 순차적으로 실행됩니다.
함수 상태는 Waiting, Running, Completed로 관리되며, 실행 중이거나 완료되면 UI에 업데이트됩니다.
5. MainWindow.xaml (UI에서 작업 및 함수 상태 시각화)
Views/MainWindow.xaml

xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록 및 함수 상태 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />

                <!-- 함수 상태를 도형으로 시각화 -->
                <DataGridTemplateColumn Header="Functions Status" Width="*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <ItemsControl ItemsSource="{Binding FunctionStatuses}">
                                    <ItemsControl.ItemsPanel>
                                        <ItemsPanelTemplate>
                                            <StackPanel Orientation="Horizontal" />
                                        </ItemsPanelTemplate>
                                    </ItemsControl.ItemsPanel>
                                    <ItemsControl.ItemTemplate>
                                        <DataTemplate>
                                            <Ellipse Width="20" Height="20" Stroke="Black" StrokeThickness="1">
                                                <Ellipse.Style>
                                                    <Style TargetType="Ellipse">
                                                        <Style.Triggers>
                                                            <!-- 대기 중인 함수는 회색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Waiting">
                                                                <Setter Property="Fill" Value="Gray"/>
                                                            </DataTrigger>
                                                            <!-- 실행 중인 함수는 스카이블루 -->
                                                            <DataTrigger Binding="{Binding}" Value="Running">
                                                                <Setter Property="Fill" Value="SkyBlue"/>
                                                            </DataTrigger>
                                                            <!-- 완료된 함수는 녹색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Completed">
                                                                <Setter Property="Fill" Value="LightGreen"/>
                                                            </DataTrigger>
                                                            <!-- 에러가 발생한 함수는 빨간색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Error">
                                                                <Setter Property="Fill" Value="Red"/>
                                                            </DataTrigger>
                                                        </Style.Triggers>
                                                    </Style>
                                                </Ellipse.Style>
                                            </Ellipse>
                                        </DataTemplate>
                                    </ItemsControl.ItemTemplate>
                                </ItemsControl>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <!-- 실시간 함수 상태 표시 -->
                <DataGridTextColumn Header="진행 상태" Binding="{Binding CurrentFunctionStatus}" Width="2*" />
            </DataGrid.Columns>
        </DataGrid>

        <!-- 일시정지 및 다시 시작 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="120,0,0,10"/>
    </Grid>
</Window>
설명:
함수 상태는 도형으로 시각화되며, 대기 중, 실행 중, 완료, 에러 상태에 따라 색상이 변경됩니다.
진행 상태는 별도의 컬럼으로 실시간 업데이트됩니다.
6. PlcCommunication.cs (PLC 통신 처리)
Models/PlcCommunication.cs

csharp
코드 복사
using System;
using System.Threading.Tasks;

/// <summary>
/// PLC와의 통신을 처리하는 클래스. 두 개의 COM 포트를 통해 데이터를 전송합니다.
/// </summary>
public class PlcCommunication
{
    private readonly string _comPort1;
    private readonly string _comPort2;

    public PlcCommunication(string comPort1, string comPort2)
    {
        _comPort1 = comPort1;
        _comPort2 = comPort2;
    }

    /// <summary>
    /// COM 포트 1을 통해 데이터를 전송합니다.
    /// </summary>
    public async Task SendDataToComPort1(string data)
    {
        try
        {
            Console.WriteLine($"COM 포트 1로 데이터 전송: {data}");
            await Task.Delay(500); // 데이터 전송 중 대기
        }
        catch (Exception ex)
        {
            Console.WriteLine($"COM 포트 1로 데이터 전송 실패: {ex.Message}");
            throw; // 예외 발생 시 다시 던짐
        }
    }

    /// <summary>
    /// COM 포트 2를 통해 데이터를 전송합니다.
    /// </summary>
    public async Task SendDataToComPort2(string data)
    {
        try
        {
            Console.WriteLine($"COM 포트 2로 데이터 전송: {data}");
            await Task.Delay(500); // 데이터 전송 중 대기
        }
        catch (Exception ex)
        {
            Console.WriteLine($"COM 포트 2로 데이터 전송 실패: {ex.Message}");
            throw; // 예외 발생 시 다시 던짐
        }
    }
}
설명:
PLC와의 통신을 처리하는 클래스입니다.
두 개의 COM 포트로 데이터를 전송하며, 전송 중에 발생하는 예외를 처리합니다.
전체 요약:
LogEntry: 각 로그 파일의 데이터를 저장하는 구조체.
FileWatcherService: 지정된 경로에서 새 파일을 감지하고, 파싱된 데이터를 작업에 전달.
TaskQueue: 작업 대기열을 관리하며, 작업이 완료되면 다음 작업을 자동으로 실행.
TaskModel: 각 작업의 상태를 관리하며, 함수들이 순차적으로 실행되도록 처리.
MainWindow.xaml: 각 작업의 함수 상태를 UI에서 시각적으로 표현하고 실시간으로 상태를 업데이트.
PlcCommunication: PLC와의 통신을 처리하는 클래스.
이제 전체적인 흐름을 이해하실 수 있습니다. 이 구조를 바탕으로 수정 요청 사항을 주시면, 그에 맞춰 최종 구현해드리겠습니다