pdateTaskStatus 메서드가 Func<string, Task> 형태의 비동기 작업을 필요로 하기 때문에 반환 타입을 **Task**로 설정하지 않았을 때 문제가 발생할 수 있습니다. 이를 해결하기 위해 TaskQueue.cs에서 호출할 때 **Task.CompletedTask**를 반환해야 하고, TaskModel.cs의 UpdateTaskStatus 메서드가 **async Task**로 선언되어야 합니다.

즉, TaskQueue에서 상태 업데이트 메서드가 비동기로 작동하도록 코드를 수정해야 합니다.

수정 사항:
UpdateTaskStatus 메서드를 **비동기 Task**로 수정합니다.
**TaskQueue**에서는 **await updateStatus()**를 호출하고, **Task.CompletedTask**를 반환합니다.
TaskModel.cs (수정된 UpdateTaskStatus)
csharp
코드 복사
using System.Threading.Tasks;
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsCancelled { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand CancelCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        StartCommand = new RelayCommand(StartTask);
        CancelCommand = new RelayCommand(CancelTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsRunning));

        // 비동기 작업을 실행하고, TaskQueue의 상태를 실시간으로 업데이트
        var success = await _taskQueue.ExecuteTaskQueue(UpdateTaskStatus);

        Status = success ? "Completed" : "Failed";
        IsCompleted = success;
        IsError = !success;
        IsRunning = false;

        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCompleted));
        OnPropertyChanged(nameof(IsError));
        OnPropertyChanged(nameof(IsRunning));
    }

    private void CancelTask()
    {
        _taskQueue.Cancel();
        Status = "Cancelled";
        IsCancelled = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCancelled));
    }

    /// <summary>
    /// TaskQueue의 상태를 실시간으로 업데이트하는 메서드 (비동기 Task로 변경)
    /// </summary>
    private async Task UpdateTaskStatus(string message)
    {
        Status = message;
        OnPropertyChanged(nameof(Status));
        await Task.CompletedTask; // 비동기 처리 완료
    }
}
TaskQueue.cs (수정된 TaskA, TaskB, TaskC)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Func<string, Task>, Task<bool>>> _tasks; // 작업 리스트 (실시간 상태 업데이트 가능)
    private CancellationTokenSource _cancellationTokenSource;

    public TaskQueue()
    {
        _tasks = new List<Func<Func<string, Task>, Task<bool>>>(); // 작업 초기화
        _cancellationTokenSource = new CancellationTokenSource(); // 취소 토큰 생성
        AddDefaultTasks(); // 기본 작업 추가
    }

    // 기본 작업을 추가하는 메서드 (여러 작업을 큐에 추가)
    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    // 작업 큐를 순차적으로 실행하는 메서드
    public async Task<bool> ExecuteTaskQueue(Func<string, Task> updateStatus)
    {
        foreach (var task in _tasks)
        {
            if (_cancellationTokenSource.Token.IsCancellationRequested)
                return false;

            var success = await task(updateStatus);
            if (!success) return false;
        }
        return true;
    }

    // 개별 작업을 취소하는 메서드
    public void Cancel()
    {
        _cancellationTokenSource.Cancel();
    }

    // 모든 작업을 취소하는 메서드
    public void CancelAll()
    {
        _cancellationTokenSource.Cancel();
    }

    // 예시로 작성한 작업 (실시간 상태 업데이트)
    private async Task<bool> TaskA(Func<string, Task> updateStatus)
    {
        await updateStatus("Task A is starting...");
        await Task.Delay(1000);  // 비동기 작업 대기
        await updateStatus("Task A completed.");
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB(Func<string, Task> updateStatus)
    {
        await updateStatus("Task B is starting...");
        await Task.Delay(1000);
        await updateStatus("Task B completed.");
        return true;
    }

    private async Task<bool> TaskC(Func<string, Task> updateStatus)
    {
        await updateStatus("Task C is starting...");
        await Task.Delay(1000);
        await updateStatus("Task C completed.");
        return true;
    }
}
요약:
**UpdateTaskStatus**는 **Task**로 반환 타입을 수정하여 비동기 처리가 가능하도록 했습니다.
**TaskQueue**의 TaskA, TaskB, TaskC는 상태 업데이트를 비동기적으로 처리하며, 실시간 상태를 UI에 반영합니다.
await Task.CompletedTask를 사용해 상태 업데이트가 완료되었음을 명시합니다.
이제 이 코드가 정상적으로 실시간 상태 업데이트를 처리하고 UI에 실시간으로 반영됩니다.