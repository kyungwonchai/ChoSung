알겠습니다. HTML <table> 구조를 그대로 사용하면서, 행 높이 조절을 순수 CSS에 최대한 의존하고 JavaScript의 직접적인 높이 계산 및 설정 로직을 제외한 코드를 드리겠습니다.

이 방식은 contenteditable 셀의 내용이 변경될 때 브라우저의 기본 테이블 렌더링 메커니즘에 따라 행 높이가 변경되도록 하는 것입니다.

핵심 CSS 속성:

td { vertical-align: top; }: 셀 내용의 수직 정렬을 위로 맞춥니다.
td.description-cell { white-space: pre-wrap; }: contenteditable이 적용된 설명 셀에서 이 속성은 공백과 줄바꿈을 유지하며, 내용이 길어지면 자동으로 줄바꿈되어 셀의 높이가 늘어나도록 합니다.
테이블 행 (<tr>)은 기본적으로 그 안에서 가장 높은 셀(<td>)의 높이에 맞춰집니다.
templates/index.html (JavaScript에서 높이 조절 로직 제거)

HTML

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>테이블 행 높이 (CSS 의존)</title>
    <style>
        body {
            font-family: sans-serif;
            margin: 20px;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            table-layout: fixed; /* 열 너비를 고정적으로 관리하는 데 도움 */
        }
        th, td {
            border: 1px solid #ccc;
            padding: 5px;
            text-align: left;
            vertical-align: top; /* 셀 내용 상단 정렬, 행 높이 확장에 중요 */
            word-wrap: break-word; /* 긴 단어 자동 줄바꿈 (구형 브라우저용) */
            overflow-wrap: break-word; /* 긴 단어 자동 줄바꿈 (표준) */
        }
        th {
            background-color: #f2f2f2;
        }
        /* contenteditable 셀의 높이가 내용에 따라 변경되도록 하는 핵심 CSS */
        td.description-cell {
            white-space: pre-wrap; /* 공백 및 줄바꿈 유지, 자동 줄바꿈 */
        }
        td.description-cell[contenteditable="true"] {
            background-color: #e8f5e9; /* 편집 가능 표시 */
            outline: none; /* 포커스 시 기본 윤곽선 제거 */
        }
        td.description-cell[contenteditable="true"]:focus {
            border: 1px solid #4CAF50; /* 포커스 시 테두리 강조 */
            box-shadow: 0 0 3px #4CAF50;
        }

        .thumbnail-image {
            max-width: 80px;
            max-height: 80px;
            height: auto;
            cursor: pointer;
            display: block;
            background-color: #f0f0f0;
            object-fit: cover;
        }

        /* 이미지 확대 모달 스타일 (이전과 동일) */
        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            padding-top: 50px;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            overflow: auto;
            background-color: rgba(0,0,0,0.85);
        }
        .modal-content {
            margin: auto;
            display: block;
            max-width: 80%;
            max-height: 80vh;
        }
        .modal-caption {
            margin: 15px auto;
            display: block;
            width: 80%;
            max-width: 700px;
            text-align: center;
            color: #ccc;
            padding: 10px 0;
            height: 50px;
        }
        .close-button {
            position: absolute;
            top: 15px;
            right: 35px;
            color: #f1f1f1;
            font-size: 40px;
            font-weight: bold;
            transition: 0.3s;
        }
        .close-button:hover,
        .close-button:focus {
            color: #bbb;
            text-decoration: none;
            cursor: pointer;
        }
    </style>
</head>
<body>

    <h1>테이블 행 높이 (CSS 및 브라우저 기본 동작 의존)</h1>

    <table id="myTable">
        <thead>
            <tr>
                <th style="width: 5%;">ID</th>
                <th style="width: 15%;">이름</th>
                <th style="width: 15%;">이미지</th>
                <th style="width: 65%;">설명</th>
            </tr>
        </thead>
        <tbody>
            {% for row_data in table_data %}
            <tr>
                <td>{{ row_data.id }}</td>
                <td>{{ row_data.name }}</td>
                <td>
                    {% if row_data.image_url %}
                    <img src="{{ row_data.image_url }}" alt="이미지: {{ row_data.name }}" class="thumbnail-image" data-title="{{ row_data.name }}">
                    {% else %}
                    <span>이미지 없음</span>
                    {% endif %}
                </td>
                <td class="description-cell" contenteditable="true" data-id="{{ row_data.id }}">{{ row_data.description }}</td>
            </tr>
            {% endfor %}
        </tbody>
    </table>

    <div id="imageModal" class="modal">
        <span class="close-button">&times;</span>
        <img class="modal-content" id="modalImage">
        <div id="modalCaption" class="modal-caption"></div>
    </div>

    <script>
        // --- 이미지 모달 로직 시작 ---
        const modal = document.getElementById("imageModal");
        const modalImg = document.getElementById("modalImage");
        const captionText = document.getElementById("modalCaption");
        const closeButton = document.getElementsByClassName("close-button")[0];

        function openModal(element) {
            if (modal && modalImg && captionText) {
                modal.style.display = "block";
                modalImg.src = element.src;
                captionText.innerHTML = element.dataset.title || element.alt;
            }
        }

        function thumbnailClickHandler() { // 'this'는 클릭된 이미지 요소를 참조
            openModal(this);
        }

        // 썸네일 이미지에 클릭 리스너 할당
        const currentThumbnails = document.querySelectorAll(".thumbnail-image");
        currentThumbnails.forEach(thumb => {
            thumb.addEventListener('click', thumbnailClickHandler);
        });

        if (closeButton) {
            closeButton.onclick = function() {
                if (modal) modal.style.display = "none";
            }
        }
        window.onclick = function(event) {
            if (event.target == modal) {
                if (modal) modal.style.display = "none";
            }
        }
        // --- 이미지 모달 로직 끝 ---

        // --- contenteditable 셀 로직 ---
        // JavaScript를 사용한 명시적인 행 높이 조절 로직(adjustSingleRowHeight, adjustAllTableHeights)은
        // "CSS로만 처리"라는 요청에 따라 여기서는 호출하지 않습니다.
        // contenteditable 셀의 높이 변경은 CSS의 white-space: pre-wrap 및
        // 브라우저의 기본 테이블 렌더링 방식에 의존합니다.
        // 행 자체는 가장 높은 셀에 맞춰 늘어나며, 다른 셀들도 그 높이를 시각적으로 채웁니다.

        // 편집 가능한 셀에 대한 이벤트 리스너 (데이터 저장 등 다른 용도로 사용 가능)
        const currentEditableCells = document.querySelectorAll('td.description-cell[contenteditable="true"]');
        currentEditableCells.forEach(cell => {
            cell.addEventListener('input', function() {
                // console.log(`ID ${this.dataset.id} 내용 변경 중: ${this.innerText}`);
                // 이 부분에서 JavaScript로 명시적인 높이 조정을 하지 않음
            });

            cell.addEventListener('blur', function() {
                // console.log(`ID ${this.dataset.id} 내용 최종: ${this.innerText}`);
                // 포커스 아웃 시에도 JavaScript로 명시적인 높이 조정을 하지 않음.
                // 필요하다면 여기서 특정 행에 대해 높이 재계산 JS를 호출할 수 있으나,
                // CSS 의존도를 높이기 위해 생략.
            });
        });

        // 참고: 페이지 로드 시 또는 창 크기 변경 시 모든 행의 높이를
        // JavaScript로 완벽하게 동기화하려면 adjustAllTableHeights 같은 함수가 필요하지만,
        // "CSS로만"이라는 요청에 따라 이 부분도 생략합니다.
        // window.addEventListener('load', adjustAllTableHeights);
        // window.addEventListener('resize', debounce(adjustAllTableHeights, 150));

    </script>

</body>
</html>
app.py (Flask 애플리케이션 - 변경 없음):

이전과 동일한 app.py 코드를 사용합니다. 데이터 제공 역할만 합니다.

Python

from flask import Flask, render_template, url_for

app = Flask(__name__)

@app.route('/')
def index():
    items_data = [
        {
            "id": 1,
            "name": "John Doe",
            "description": "This is a short description.",
            "image_filename": "img1.jpg"
        },
        {
            "id": 2,
            "name": "Jane Smith",
            "description": "This is a medium-length description. It might span multiple lines if the content is long enough to wrap.",
            "image_filename": "img2.jpg"
        },
        {
            "id": 3,
            "name": "Peter Jones",
            "description": "This item requires a very long description. If the text is extensive, it should automatically wrap to fit within the cell, and explicitly entered\nnew lines\nlike this one\nshould also be respected.\nThe content will be displayed across multiple lines.\nThis is the last line.",
            "image_filename": "img3.jpg"
        },
        {
            "id": 4,
            "name": "Alice Brown",
            "description": "First line.\nSecond line.\nThird line.\n\nFifth line (includes an empty line).",
            "image_filename": "img4.jpg"
        },
        {
            "id": 5,
            "name": "Robert Wilson",
            "description": "All cells in the same row will adjust to the height of the cell with the most content.",
            "image_filename": "img5.jpg"
        }
    ]

    processed_data = []
    for item in items_data:
        if item.get("image_filename"):
            item["image_url"] = url_for('static', filename=f'image1/{item["image_filename"]}')
        else:
            item["image_url"] = None # 또는 기본 이미지 URL
        processed_data.append(item)

    return render_template('index.html', table_data=processed_data)

if __name__ == '__main__':
    app.run(debug=True)
동작 방식 및 설명:

CSS의 역할:

td.description-cell에 적용된 white-space: pre-wrap; 스타일은 사용자가 contenteditable 영역에 텍스트를 입력하거나 삭제할 때, 해당 셀의 높이가 내용에 따라 자연스럽게 늘어나거나 줄어들도록 합니다.
HTML <table>의 기본 동작에 따라, <tr> (행)의 높이는 그 안에 포함된 <td> (셀) 중 가장 높이가 큰 셀에 맞춰집니다.
같은 행의 다른 <td> 셀들은 (예: ID, 이름, 이미지 셀) 시각적으로 이 행의 높이를 채우게 됩니다. vertical-align: top;으로 인해 내용은 위쪽에 정렬됩니다.
JavaScript의 역할 (최소화):

이 코드에서 JavaScript는 더 이상 contenteditable 셀의 input 이벤트가 발생할 때마다 모든 셀의 style.height를 명시적으로 계산하고 설정하지 않습니다.
이미지 클릭 시 모달을 띄우는 기능은 그대로 유지됩니다 (요청하신 부분이 행 높이 처리였으므로).
contenteditable 셀의 input 이나 blur 이벤트 리스너는 여전히 존재하지만, 이들은 주로 데이터 변경을 감지하거나 (예: 서버에 저장하기 위한 준비), 다른 UI 관련 작업을 위해 남겨둘 수 있습니다. 현재는 주석 처리된 console.log 외에는 특별한 동작을 하지 않습니다.
결과:

설명(Description) 셀에 텍스트를 입력하면 해당 셀과 행의 높이가 늘어납니다.
텍스트를 삭제하면 해당 셀과 행의 높이가 줄어듭니다.
이 모든 것이 CSS의 white-space 속성과 브라우저의 기본 테이블 렌더링 메커니즘에 의해 처리됩니다.
한계점 (JavaScript를 사용했을 때와의 비교):

정교함 부족: JavaScript로 모든 셀의 scrollHeight를 읽어 최대값을 구하고 명시적으로 style.height를 설정했을 때만큼 모든 셀의 높이가 "픽셀 단위로 완벽하게" 동기화되지는 않을 수 있습니다. 브라우저의 기본 동작은 대부분의 경우 충분히 좋아 보이지만, 미세한 시각적 차이가 발생할 수 있습니다.
반응성: 매우 빠르게 입력하거나 복잡한 내용을 붙여넣을 때, JavaScript로 강제하는 것보다 높이 반영이 약간 지연되거나 덜 부드럽게 느껴질 수 있습니다.