그런데 여기에 약간의 기술적인 함정이 있습니다.

    원인: RDP(원격 데스크톱) 창이 최소화되거나 다른 창에 가려져 '비활성' 상태가 되면, 본컴(Jemiok님 PC)의 윈도우는 해당 창으로 키보드/마우스 입력을 보내는 것을 중지합니다.

    결과: 본컴에서 아무리 열심히 다른 작업을 해도, RDP 클라이언트는 원격 PC에게 "지금 사용자가 나를 보고 있지 않다"는 신호를 보냅니다. 그러면 원격 PC는 '유휴(Idle) 상태'로 판단하고 결국 스스로 잠금 화면으로 들어가 버립니다.

Jemiok님이 제안하신 "주기적인 터치"가 정확히 필요한데, 그 '터치'를 본컴(A)이 아니라 원격 PC(B, C)가 스스로 하도록 만들면 모든 문제가 해결됩니다.

💡 해결책: 원격 PC에서 '셀프 활동' 스크립트 실행하기

Jemiok님은 개발자시니 이 방법이 가장 빠르고 확실할 겁니다.

두 대의 원격 PC(B, C) 각각에 접속해서, PowerShell (윈도우에 기본 내장)을 열고 아래 스크립트를 실행해두는 것입니다.

이 스크립트는 60초마다 아무런 기능도 하지 않는 Scroll Lock 키를 스스로 한 번 눌렀다 떼는 동작을 합니다. 원격 PC 입장에서는 "아, 방금 키보드 입력이 들어왔네! 유휴 상태가 아니구나!"라고 판단하게 되어 절대 잠기지 않습니다.

원격 PC (B, C) 각각에서 실행할 스크립트:

    원격 PC(B)에 접속합니다.

    시작 메뉴에서 **'PowerShell'**을 검색해서 실행합니다.

    아래 코드를 그대로 복사해서 PowerShell 창에 붙여넣기 하고 Enter 키를 칩니다.

PowerShell

$wshell = New-Object -ComObject wscript.shell;

Write-Host "---- 원격 PC 잠금 방지 스크립트 시작 ----";
Write-Host "60초마다 'Scroll Lock' 키를 눌러 세션을 활성 상태로 유지합니다.";
Write-Host "이 PowerShell 창을 최소화해두시면 됩니다. (Ctrl+C로 중지)";

while ($true) {
    try {
        # 'Scroll Lock' 키를 눌렀다 뗍니다. (켜고 끄기)
        # 이 키는 대부분의 프로그램에 아무런 영향을 주지 않습니다.
        $wshell.SendKeys("{SCROLLLOCK}");
        Start-Sleep -Seconds 1;
        $wshell.SendKeys("{SCROLLLOCK}");
        
        Write-Host "[$(Get-Date -Format 'HH:mm:ss')] Keep-Alive 신호 전송 완료."
        
        # 59초 대기 (총 60초 주기)
        Start-Sleep -Seconds 59
    }
    catch {
        Write-Host "오류 발생: $_"
        # 오류 발생 시 10초 후 재시도
        Start-Sleep -Seconds 10
    }
}

📋 사용 방법

    원격 PC (B)에 접속 -> PowerShell 열기 -> 위 코드 붙여넣기 -> 실행

    PowerShell 창을 최소화합니다. (닫으면 스크립트가 종료됩니다)

    원격 PC (C)에 접속 -> PowerShell 열기 -> 위 코드 붙여넣기 -> 실행

    PowerShell 창을 최소화합니다.

    이제 본컴에서 다른 작업을 하시거나 RDP 창을 최소화해도, 원격 PC들은 스스로 '활동' 중이라고 판단하여 잠기지 않습니다.

이 PowerShell 스크립트 방식이 Jemiok님이 원하시던 '백그라운드 터치'에 가장 가까운 해결책일 것 같습니다.