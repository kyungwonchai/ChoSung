ê² ìŠµë‹ˆë‹¤! Windows Forms ê¸°ë°˜ ë¹„ë™ê¸° ë§¤í¬ë¡œ ì‹¤í–‰ ì‹œìŠ¤í…œì„
ì†”ë£¨ì…˜(AutoHandleSolution) & í”„ë¡œì íŠ¸(AAutoHandle) ë¡œ ì„¤ì •í•˜ì—¬
OpenCV í¬í•¨, í‚¤ë³´ë“œ/ë§ˆìš°ìŠ¤ ì¡°ì‘, í™”ë©´ ìº¡ì²˜, ë¡œê·¸ ì‹œìŠ¤í…œê¹Œì§€ ì™„ë²½í•˜ê²Œ êµ¬í˜„í•´ ë“œë¦½ë‹ˆë‹¤.

ğŸ“‚ 1. í”„ë¡œì íŠ¸ êµ¬ì¡°
ì½”ë“œ ë³µì‚¬
ğŸ“¦ AutoHandleSolution
 â”£ ğŸ“‚ AAutoHandle
 â”ƒ â”£ ğŸ“‚ Commands
 â”ƒ â”ƒ â”£ ğŸ“œ IMacroCommand.cs
 â”ƒ â”ƒ â”£ ğŸ“œ KeyboardCommand.cs
 â”ƒ â”ƒ â”£ ğŸ“œ MouseClickCommand.cs
 â”ƒ â”ƒ â”£ ğŸ“œ DelayCommand.cs
 â”ƒ â”ƒ â”£ ğŸ“œ ScreenCaptureCommand.cs
 â”ƒ â”ƒ â”— ğŸ“œ CVCommand.cs  â˜… OpenCV í¬í•¨
 â”ƒ â”£ ğŸ“‚ Core
 â”ƒ â”ƒ â”£ ğŸ“œ MacroExecutor.cs
 â”ƒ â”ƒ â”£ ğŸ“œ MacroManager.cs
 â”ƒ â”ƒ â”— ğŸ“œ MacroLogger.cs
 â”ƒ â”£ ğŸ“‚ Forms
 â”ƒ â”ƒ â”— ğŸ“œ MainForm.cs
 â”ƒ â”£ ğŸ“œ Program.cs
 â”ƒ â”— ğŸ“œ AAutoHandle.csproj
 â”— ğŸ“œ AutoHandleSolution.sln
ğŸ“œ 2. ì „ì²´ ì½”ë“œ (AAutoHandle í”„ë¡œì íŠ¸)
ğŸ”¹ 1ï¸âƒ£ IMacroCommand.cs (ê³µí†µ ì¸í„°í˜ì´ìŠ¤)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System.Threading.Tasks;

    public interface IMacroCommand
    {
        Task ExecuteAsync(); // ë¹„ë™ê¸° ì‹¤í–‰
    }
}
ğŸ”¹ 2ï¸âƒ£ KeyboardCommand.cs (í‚¤ë³´ë“œ ì…ë ¥)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class KeyboardCommand : IMacroCommand
    {
        private readonly Keys _key;

        public KeyboardCommand(Keys key)
        {
            _key = key;
        }

        public async Task ExecuteAsync()
        {
            await Task.Delay(100);
            SendKeys.SendWait(_key.ToString());
            Core.MacroLogger.Instance.AddLog($"í‚¤ ì…ë ¥: {_key}");
        }
    }
}
ğŸ”¹ 3ï¸âƒ£ MouseClickCommand.cs (ë§ˆìš°ìŠ¤ í´ë¦­)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System;
    using System.Runtime.InteropServices;
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class MouseClickCommand : IMacroCommand
    {
        private readonly int _x, _y;

        [DllImport("user32.dll")]
        private static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        private const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        private const uint MOUSEEVENTF_LEFTUP = 0x04;

        public MouseClickCommand(int x, int y)
        {
            _x = x;
            _y = y;
        }

        public async Task ExecuteAsync()
        {
            Cursor.Position = new System.Drawing.Point(_x, _y);
            await Task.Delay(50);
            mouse_event(MOUSEEVENTF_LEFTDOWN, _x, _y, 0, IntPtr.Zero);
            await Task.Delay(50);
            mouse_event(MOUSEEVENTF_LEFTUP, _x, _y, 0, IntPtr.Zero);
            Core.MacroLogger.Instance.AddLog($"ë§ˆìš°ìŠ¤ í´ë¦­: {_x}, {_y}");
        }
    }
}
ğŸ”¹ 4ï¸âƒ£ DelayCommand.cs (ë”œë ˆì´)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System.Threading.Tasks;

    public class DelayCommand : IMacroCommand
    {
        private readonly int _milliseconds;

        public DelayCommand(int milliseconds)
        {
            _milliseconds = milliseconds;
        }

        public async Task ExecuteAsync()
        {
            Core.MacroLogger.Instance.AddLog($"ë”œë ˆì´ {_milliseconds}ms");
            await Task.Delay(_milliseconds);
        }
    }
}
ğŸ”¹ 5ï¸âƒ£ ScreenCaptureCommand.cs (í™”ë©´ ìº¡ì²˜)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System;
    using System.Drawing;
    using System.Threading.Tasks;
    using System.Windows.Forms;

    public class ScreenCaptureCommand : IMacroCommand
    {
        private readonly string _savePath;

        public ScreenCaptureCommand(string savePath)
        {
            _savePath = savePath;
        }

        public async Task ExecuteAsync()
        {
            await Task.Delay(500);
            Bitmap bmp = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
            Graphics graphics = Graphics.FromImage(bmp);
            graphics.CopyFromScreen(0, 0, 0, 0, bmp.Size);
            bmp.Save(_savePath);
            Core.MacroLogger.Instance.AddLog($"í™”ë©´ ìº¡ì²˜ ì €ì¥: {_savePath}");
        }
    }
}
ğŸ”¹ 6ï¸âƒ£ CVCommand.cs (OpenCV ì´ë¯¸ì§€ ë¶„ì„)
csharp
ì½”ë“œ ë³µì‚¬
namespace AAutoHandle.Commands
{
    using System;
    using System.Threading.Tasks;
    using OpenCvSharp;

    public class CVCommand : IMacroCommand
    {
        private readonly string _imagePath;

        public CVCommand(string imagePath)
        {
            _imagePath = imagePath;
        }

        public async Task ExecuteAsync()
        {
            await Task.Delay(200);
            Mat img = Cv2.ImRead(_imagePath);
            if (img.Empty())
            {
                Core.MacroLogger.Instance.AddLog($"[Error] ì´ë¯¸ì§€ ë¶„ì„ ì‹¤íŒ¨: {_imagePath}");
                return;
            }
            Core.MacroLogger.Instance.AddLog($"ì´ë¯¸ì§€ ë¶„ì„ ì„±ê³µ: {_imagePath}");
        }
    }
}
ğŸ”¹ 7ï¸âƒ£ MainForm.cs (UI)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Windows.Forms;
using AAutoHandle.Core;
using AAutoHandle.Commands;

namespace AAutoHandle
{
    public partial class MainForm : Form
    {
        public MainForm()
        {
            InitializeComponent();
            listBoxLogs.DataSource = MacroLogger.Instance.Logs;
        }

        private async void btnStartMacro_Click(object sender, EventArgs e)
        {
            var macroManager = MacroManager.Instance;

            macroManager.AddCommand(new KeyboardCommand(Keys.A));
            macroManager.AddCommand(new MouseClickCommand(500, 300));
            macroManager.AddCommand(new DelayCommand(1000));
            macroManager.AddCommand(new ScreenCaptureCommand("screenshot.png"));
            macroManager.AddCommand(new CVCommand("test.png"));

            await macroManager.StartExecutionAsync();
        }
    }
}