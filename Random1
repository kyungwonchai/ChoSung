아래는 요청하신 기능을 구현한 전체 코드입니다. 이 코드는 SignalR을 통해 보낸 메시지와 서버의 응답을 DataGrid에 최대 30개의 항목까지 표시하며, 각 항목에 보낸 시간, 보낸 값, 그리고 응답 결과를 포함합니다.

1. SignalRClient 클래스 (Singleton 패턴)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR.Client;

public class SignalRClient
{
    private static SignalRClient _instance;  // Singleton 인스턴스
    private HubConnection _hubConnection;  // SignalR 연결 객체
    public event EventHandler<string> LogMessageReceived;  // 로그 이벤트
    public event EventHandler<string> MessageResponseReceived;  // 메시지 응답 이벤트

    // Singleton 패턴을 위한 private 생성자
    private SignalRClient() { }

    // Singleton 인스턴스 접근
    public static SignalRClient Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new SignalRClient();
            }
            return _instance;
        }
    }

    // SignalR 연결 초기화 함수 (비동기형)
    public async Task InitializeSignalRConnectionAsync(string hubUrl)
    {
        try
        {
            if (_hubConnection == null || _hubConnection.State != HubConnectionState.Connected)
            {
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl(hubUrl)  // 허브 URL 설정
                    .Build();

                // 서버에서 오는 응답 처리
                _hubConnection.On<string>("ReceiveResponse", (responseMessage) => {
                    MessageResponseReceived?.Invoke(this, responseMessage);  // 응답 메시지 처리
                });

                await _hubConnection.StartAsync();  // 비동기로 SignalR 연결 시작
                Log("SignalR Connection Started");  // 연결 성공 로그
            }
        }
        catch (Exception ex)
        {
            LogError(ex.Message);  // 연결 실패 시 로그 기록
        }
    }

    // 메시지 전송 함수 (비동기)
    public async Task<bool> SendMessageAsync(string message)
    {
        try
        {
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                await _hubConnection.InvokeAsync("SendMessage", message);
                Log($"Message sent: {message}");  // 성공적으로 전송된 경우 로그
                return true;
            }
            else
            {
                LogError("SignalR is not connected.");
                return false;
            }
        }
        catch (Exception ex)
        {
            LogError(ex.Message);  // 전송 중 오류 발생 시 로그 기록
            return false;
        }
    }

    // 로그 기록 함수
    private void Log(string message)
    {
        LogMessageReceived?.Invoke(this, message);  // 로그 메시지를 외부로 전달
    }

    // 에러 로그 기록 함수
    private void LogError(string errorMessage)
    {
        Log($"Error: {errorMessage}");  // 에러 로그 기록
    }
}
2. MainViewModel 클래스 (DataGrid와 연동)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

public class MainViewModel : INotifyPropertyChanged
{
    private string _logMessage;

    public event PropertyChangedEventHandler PropertyChanged;

    public string LogMessage
    {
        get { return _logMessage; }
        set
        {
            _logMessage = value;
            OnPropertyChanged();
        }
    }

    // DataGrid에 표시할 메시지 목록 (최대 30개)
    public ObservableCollection<MessageModel> Messages { get; set; } = new ObservableCollection<MessageModel>();

    public MainViewModel()
    {
        InitializeSignalR();  // SignalR 연결 초기화
        SignalRClient.Instance.LogMessageReceived += OnLogMessageReceived;  // 로그 메시지 수신 이벤트 연결
        SignalRClient.Instance.MessageResponseReceived += OnMessageResponseReceived;  // 응답 메시지 수신 이벤트 연결
        OtherClass.SignalReceived += OnSignalReceived;  // 외부 클래스의 이벤트 수신
    }

    // SignalR 연결 초기화 함수 (비동기)
    private async void InitializeSignalR()
    {
        await SignalRClient.Instance.InitializeSignalRConnectionAsync("http://localhost:5000/myhub");  // 허브 URL 설정
    }

    // 외부 클래스에서 이벤트가 발생했을 때 호출되는 함수
    private async void OnSignalReceived(object sender, string message)
    {
        string sentTime = DateTime.Now.ToString("yyyyMMdd HHmmssfff");
        bool isSuccess = await SendSignalRMessageAsync(message);

        // 성공 여부에 따라 로그 메시지 설정
        if (isSuccess)
        {
            LogMessage = "Message sent successfully.";
            AddMessageToDataGrid(sentTime, message, "Waiting for response...");
        }
        else
        {
            LogMessage = "Message failed to send.";
        }
    }

    // SignalR을 통해 메시지를 보내는 함수
    private async Task<bool> SendSignalRMessageAsync(string message)
    {
        return await SignalRClient.Instance.SendMessageAsync(message);  // Singleton 인스턴스의 SendMessage 호출
    }

    // SignalRClient에서 발생한 로그 메시지를 수신하여 UI에 표시
    private void OnLogMessageReceived(object sender, string logMessage)
    {
        LogMessage = logMessage;  // 로그 메시지 업데이트
    }

    // SignalR 서버로부터 응답을 받았을 때 처리
    private void OnMessageResponseReceived(object sender, string responseMessage)
    {
        // 마지막 메시지의 응답을 업데이트
        if (Messages.Count > 0)
        {
            var lastMessage = Messages[^1];  // 마지막 메시지 참조
            lastMessage.Response = responseMessage;
        }
    }

    // 메시지를 DataGrid에 추가 (최대 30개 유지)
    private void AddMessageToDataGrid(string sentTime, string sentMessage, string response)
    {
        if (Messages.Count >= 30)
        {
            Messages.RemoveAt(0);  // 30개를 넘기면 오래된 항목 제거
        }

        Messages.Add(new MessageModel
        {
            SentTime = sentTime,
            SentMessage = sentMessage,
            Response = response
        });
    }

    // PropertyChanged 이벤트 발생 함수
    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
3. MessageModel 클래스 (DataGrid에 표시할 데이터 모델)
csharp
코드 복사
public class MessageModel
{
    public string SentTime { get; set; }  // 보낸 시간
    public string SentMessage { get; set; }  // 보낸 메시지
    public string Response { get; set; }  // 응답 결과
}
4. OtherClass (신호를 발생시키는 클래스)
csharp
코드 복사
using System;

public class OtherClass
{
    // 신호를 외부로 전달하는 이벤트
    public static event EventHandler<string> SignalReceived;

    // 특정 조건에서 신호를 발생시키는 함수
    public void TriggerSignal()
    {
        string message = "This is a test message";

        // 이벤트 발생, MainViewModel에서 수신하여 SignalR로 전송함
        SignalReceived?.Invoke(this, message);
    }
}
5. XAML (UI 부분, DataGrid 포함)
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- DataGrid to display messages -->
        <DataGrid ItemsSource="{Binding Messages}" AutoGenerateColumns="False" Height="350" VerticalAlignment="Top">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Sent Time" Binding="{Binding SentTime}" Width="200"/>
                <DataGridTextColumn Header="Sent Message" Binding="{Binding SentMessage}" Width="300"/>
                <DataGridTextColumn Header="Response" Binding="{Binding Response}" Width="300"/>
            </DataGrid.Columns>
        </DataGrid>

        <!-- Log Message TextBlock -->
        <TextBlock Text="{Binding LogMessage}" VerticalAlignment="Bottom" HorizontalAlignment="Center" Margin="10"/>
    </Grid>
</Window>
6. MainWindow.xaml.cs (MainViewModel 연결)
csharp
코드 복사
using System.Windows;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        DataContext = new MainViewModel();  // MainViewModel을 DataContext로 설정
    }
}
설명
SignalRClient 클래스:

SignalR 연결을 관리하고 메시지를 서버로 전송한 후 응답을 처리합니다.
Singleton 패턴으로 구현되어 애플리케이션 전역에서 하나의 인스턴스만 사용됩니다.
MainViewModel 클래스:
