Unity Industries 시뮬레이션을 위한 Hanwha Techwin SP1 프린터 및 셔틀 컨베이어 연동 동작 분석 (병렬 생산, 단일 출구 시나리오)
제공해주신 상세 분석 보고서를 바탕으로, Hanwha Techwin SP1 SMD 프린터의 병렬 듀얼 레인 공정과 셔틀 컨베이어가 연동하여 한쪽 레인에서는 A 모델, 다른 쪽 레인에서는 B 모델을 생산하고, 이를 단일 출구로 배출하는 과정을 Unity Industries 시뮬레이션용으로 설명드리겠습니다.

시뮬레이션 목표:
SP1 프린터의 두 레인이 독립적으로 다른 모델(A, B)을 동시에 인쇄하고, 프린터 후단의 셔틀 컨베이어가 이 두 라인의 결과물을 받아 하나의 라인으로 병합하여 배출하는 전체 공정을 시각화하고 분석합니다.

주요 구성 요소 및 역할 (Unity 내 Object 또는 Agent로 구현):

SP1 프린터 (Dual Lane):

레인 1 (좌측 또는 전면): 모델 A PCB 전용 생산 라인.
레인 2 (우측 또는 후면): 모델 B PCB 전용 생산 라인.
각 레인은 독립적인 인쇄 사이클(PCB 진입, 클램핑, 정렬, 인쇄, 언클램핑, 배출 준비)을 가집니다.
여기서는 "Dual Lane Conveyor (Bypass)" 또는 각 레인이 독립적으로 운영되는 유사한 구성으로 가정합니다. "Conveyor In Common Use..." 옵션은 이 시나리오에서는 과도하게 복잡할 수 있으나, 만약 프린터 내부에서 특정 공유 지점이 있다면 해당 로직 추가가 필요합니다.
셔틀 컨베이어:

SP1 프린터의 레인 1과 레인 2로부터 PCB를 입력받습니다.
입력받은 PCB를 단일 출구 라인으로 이송 및 배출합니다.
PLC 기반 제어 로직을 통해 어떤 레인의 PCB를 먼저 처리할지, 언제 이동할지 등을 결정합니다.
PCB (모델 A, 모델 B):

고유한 속성(모델명, 처리 상태 - 예: 미인쇄, 인쇄 완료)을 가집니다.
시뮬레이션 내에서 이동하고 상태가 변경되는 주요 엔티티입니다.
SMEMA 인터페이스 로직:

프린터 각 레인 출력단과 셔틀 컨베이어 입력단 사이, 그리고 셔틀 컨베이어 출력단과 후속 장비 입력단 사이에 적용됩니다.
"Board Available" (BA) 및 "Machine Ready" (MR) 신호를 통해 장비 간 PCB 이동을 동기화합니다. Unity에서는 Boolean 변수나 이벤트 트리거로 구현될 수 있습니다.
동작 시나리오 상세 설명 (Unity 시뮬레이션 관점):

초기 상태:

SP1 프린터 레인 1, 2는 유휴 상태 (Idle), PCB 대기 중.
셔틀 컨베이어는 홈 포지션(예: 두 프린터 레인 사이 또는 한쪽 레인 앞)에서 대기 중.
셔틀 컨베이어는 양쪽 프린터 레인으로부터 PCB를 받을 준비가 되었음을 알리는 MR 신호를 보낼 수 있습니다 (또는 프린터가 BA 신호를 보내면 그때 반응).
PCB 투입 및 프린터 내부 공정 (병렬 진행):

(Lane 1 - 모델 A):
모델 A PCB가 레인 1으로 진입합니다.
내부 공정 시작: PCB 로딩 -> 클램핑 -> 기준점 인식 -> 스텐실-PCB 정렬 -> 테이블 상승/접촉 -> 스퀴지 작동 (인쇄) -> 테이블 하강/분리 -> PCB 언클램핑.
인쇄 완료된 모델 A PCB가 레인 1 출구 컨베이어로 이동하여 정지합니다.
SP1 레인 1 -> 셔틀: SP1 레인 1이 셔틀 컨베이어 측으로 Board Available (BA_L1) 신호를 Asserted (ON) 상태로 변경합니다.
(Lane 2 - 모델 B):
모델 B PCB가 레인 2로 진입합니다.
레인 1과 동일한 내부 공정을 모델 B PCB에 대해 수행합니다.
인쇄 완료된 모델 B PCB가 레인 2 출구 컨베이어로 이동하여 정지합니다.
SP1 레인 2 -> 셔틀: SP1 레인 2가 셔틀 컨베이어 측으로 Board Available (BA_L2) 신호를 Asserted (ON) 상태로 변경합니다.
셔틀 컨베이어의 PCB 수신 및 병합 로직:

셔틀 컨베이어는 BA_L1과 BA_L2 신호를 지속적으로 모니터링합니다.
병합 결정 로직 (PLC 로직 시뮬레이션):
Case 1: 한쪽 레인만 BA 신호 ON (예: BA_L1만 ON)
셔틀은 레인 1과 정렬되도록 이동합니다 (이미 정렬되어 있다면 이동 없음).
셔틀은 SP1 레인 1 측으로 Machine Ready (MR_Shuttle_to_L1) 신호를 Asserted (ON) 상태로 변경합니다.
SMEMA 핸드셰이크 (L1 -> 셔틀):
SP1 레인 1은 BA_L1이 ON이고 셔틀로부터 MR_Shuttle_to_L1이 ON임을 확인합니다.
SP1 레인 1 컨베이어가 작동하여 모델 A PCB를 셔틀 컨베이어로 이송합니다.
PCB가 SP1 레인 1 센서를 벗어나면, SP1 레인 1은 BA_L1 신호를 De-asserted (OFF)로 변경합니다.
PCB가 셔틀 입력 센서에 감지되면, 셔틀은 MR_Shuttle_to_L1 신호를 De-asserted (OFF)로 변경합니다.
모델 A PCB가 셔틀 위에 안착됩니다.
Case 2: 양쪽 레인 모두 BA 신호 ON (BA_L1과 BA_L2 모두 ON)
셔틀의 PLC는 설정된 우선순위 규칙에 따라 처리할 레인을 결정합니다.
고정 우선순위: 예) 항상 레인 1을 먼저 처리.
라운드 로빈: 번갈아가며 처리 (이번엔 L1, 다음엔 L2).
선입선출 (FCFS): BA 신호가 먼저 활성화된 쪽 또는 해당 레인 앞 센서에 PCB가 더 오래 대기한 쪽을 먼저 처리 (타이머 기반).
선택된 레인에 대해 Case 1과 동일한 이동 및 SMEMA 핸드셰이크 과정을 수행합니다.
다른 쪽 레인의 PCB는 BA 신호를 유지한 채 대기합니다.
셔틀 컨베이어의 PCB 배출:

PCB (모델 A 또는 B)를 실은 셔틀 컨베이어가 단일 출구 컨베이어와 정렬되도록 이동합니다.
셔틀 -> 후속 장비: 셔틀이 후속 장비 측으로 Board Available (BA_Shuttle_Out) 신호를 Asserted (ON) 상태로 변경합니다.
후속 장비가 PCB를 받을 준비가 되면 셔틀 측으로 Machine Ready (MR_Downstream_to_Shuttle) 신호를 Asserted (ON) 상태로 변경합니다.
SMEMA 핸드셰이크 (셔틀 -> 후속 장비):
셔틀은 BA_Shuttle_Out이 ON이고 후속 장비로부터 MR_Downstream_to_Shuttle이 ON임을 확인합니다.
셔틀 컨베이어 벨트가 작동하여 PCB를 후속 장비로 이송합니다.
PCB가 셔틀 출력 센서를 벗어나면, 셔틀은 BA_Shuttle_Out 신호를 De-asserted (OFF)로 변경합니다.
PCB가 후속 장비 입력 센서에 감지되면, 후속 장비는 MR_Downstream_to_Shuttle 신호를 De-asserted (OFF)로 변경합니다.
셔틀은 이제 비워지고, 다시 프린터 레인으로부터 PCB를 받기 위해 대기 상태 또는 이동 상태로 전환됩니다 (병합 로직에 따라).
반복:

위 2~4단계가 반복적으로 수행되면서 모델 A와 모델 B PCB가 병렬로 인쇄되고 순차적으로 단일 라인으로 병합되어 배출됩니다.
Unity 시뮬레이션 구현 시 고려사항:

상태 머신: 프린터 각 레인, 셔틀 컨베이어는 각각의 상태(예: Idle, Loading, Printing, MovingToLane1, TransferringToOutlet 등)를 가지며, 이벤트(센서 감지, SMEMA 신호 변경, 타이머 완료)에 따라 상태가 전환됩니다.
타이밍: 각 공정 단계(프린터 사이클 타임, 셔틀 이동 시간, 컨베이어 벨트 속도에 따른 이송 시간)는 실제 장비 사양을 기반으로 설정되어야 합니다. SP1-C는 사이클 타임 5초, SP1-W는 7초 (인쇄 시간 제외) 등이 주요 파라미터입니다.
센서: PCB 위치 감지를 위한 가상 센서(Raycast, Collider 등)를 배치하여 상태 전환의 트리거로 사용합니다.
SMEMA 신호: Boolean 변수 (BA_L1, MR_Shuttle_to_L1 등)로 표현하고, 이 변수들의 상태 변화가 장비 간 상호작용을 제어하도록 합니다. 약 50ms의 필터링 시간 적용도 고려할 수 있습니다.
병합 로직 선택: 셔틀의 PLC 로직(라운드 로빈, 우선순위 등)을 스크립트로 구현하여 다양한 운영 전략을 시뮬레이션할 수 있도록 합니다.
시각화: 프린터 내부 작동(스퀴지 이동 등), 셔틀의 물리적 이동, PCB의 흐름을 명확하게 시각화합니다.
데이터 수집: 각 모델의 생산량, 평균 대기 시간, 장비 가동률 등의 통계 데이터를 수집하여 라인 효율성을 분석할 수 있도록 합니다.
이 설명을 바탕으로 Unity 내에서 각 장비의 동작 스크립트, PCB 엔티티, SMEMA 통신 로직 등을 구현하시면 사용자가 요구하는 "한쪽은 A모델, 한쪽은 B모델 생산, 출구는 1개"인 공정을 효과적으로 시뮬레이션할 수 있을 것입니다. 특히 셔틀 컨베이어의 병합 로직과 SMEMA 핸드셰이크의 정확한 구현이 시뮬레이션의 핵심입니다.





이거 유니티 새 빈 프로젝트에서 내가 따로 핸들링안해도 그려줄수있냐 어느정도 비슷하게만 보드 흐름이 중요하니 설비 중요 컨베어정도 그래고 시뮬레이션이 돌아가야해 무한으로 자동화해서 가만잇으면 그 동작을 눈으로 볼수있어야되 무한투입되고 무한동작하는설비




생각하는 과정 표시
네, Unity 새 빈 프로젝트에서 제가 제공해 드리는 C# 스크립트 코드와 단계별 씬(Scene) 구성 가이드를 따르면, 사용자가 직접 복잡한 3D 모델링이나 애니메이션 핸들링 없이도 설명하신 SMT 라인의 보드 흐름을 '어느 정도 비슷하게' 시각적으로 구현하고, 무한으로 자동화되어 계속 동작하는 모습을 눈으로 볼 수 있도록 도와드릴 수 있습니다.

핵심은 다음과 같습니다:

간략한 시각적 표현: 실제 설비의 복잡한 디테일 대신 Unity의 기본 도형(큐브, 평면 등)을 사용하여 프린터, 컨베이어 벨트, 셔틀 등을 표현합니다. 보드의 흐름을 명확히 보는 것이 중요하므로, 기능적인 형태 위주로 구성합니다.
스크립트 기반 로직: 각 설비의 동작(PCB 이동, 인쇄 시간, 셔틀 이동 및 결정 로직, SMEMA 신호 교환)은 C# 스크립트로 구현됩니다. 제가 핵심 스크립트 구조와 예시 코드를 제공해 드릴 것입니다.
무한 자동화:
PCB 무한 투입: 프린터 입구에서 일정한 간격 또는 조건에 따라 새로운 PCB(모델 A, B 구분 가능)가 계속 생성되도록 스크립트를 작성합니다.
설비 무한 동작: 각 설비는 PCB를 감지하고, 정해진 로직에 따라 처리한 후 다음 PCB를 받을 준비를 합니다. 라인 끝에 도달한 PCB는 자동으로 제거(또는 재활용)되어 시스템이 멈추지 않고 계속 돌아가도록 합니다.
사용자 작업 최소화: 사용자는 제공된 스크립트를 Unity 프로젝트에 추가하고, 제가 안내하는 대로 씬에 기본 도형으로 설비를 배치한 후, 스크립트를 각 도형에 연결하고 인스펙터 창에서 몇 가지 주요 파라미터(속도, 시간 등)를 설정하는 작업을 주로 하게 됩니다.
구현될 주요 요소 및 동작 방식 (Unity 에디터 및 스크립트 관점):

씬(Scene) 구성:

바닥 (Plane): 기준면
PCB 생성기 (Empty GameObject + Script): 레인 1용 (모델 A), 레인 2용 (모델 B) PCB를 주기적으로 생성하여 각 프린터 레인 입구로 보냅니다.
SP1 프린터 (Cube 또는 여러 개의 Cube 조합):
레인 1 컨베이어 (길쭉한 Cube + Script): PCB를 받아 인쇄 위치까지 이동, 인쇄 시간만큼 대기(시뮬레이션), 셔틀로 보낼 준비 (SMEMA BA 신호 발생).
레인 2 컨베이어 (길쭉한 Cube + Script): 레인 1과 동일하게 모델 B 처리.
셔틀 컨베이어 (Cube + Script):
이동 유닛 (Cube): 실제 PCB를 싣고 좌우(프린터 레인 1, 2, 출구 컨베이어 정렬 위치)로 이동.
셔틀 로직: 프린터 레인 1, 2의 BA 신호를 감지. 병합 로직(예: 라운드 로빈, 우선순위)에 따라 PCB를 받음 (SMEMA MR 신호 응답). 받은 PCB를 출구 컨베이어로 이동시켜 배출.
출구 컨베이어 (길쭉한 Cube + Script): 셔틀로부터 PCB를 받아 라인 밖으로 이동시킵니다.
PCB 제거기 (Empty GameObject + Trigger Collider): 라인 끝에 도달한 PCB를 감지하고 파괴(Destroy)하여 시스템 자원을 관리합니다.
주요 스크립트 (C#):

PCB.cs:
PCB의 데이터 (예: enum ModelType { A, B }).
목표 지점까지 이동하는 로직 (MoveTowards).
모델 A, B 구분을 위한 색상 변경 로직.
PCBGenerator.cs:
PCB 프리팹(미리 만들어둔 PCB 원형) 참조.
일정 시간 간격으로 PCB 프리팹을 복제(Instantiate)하여 특정 위치(프린터 레인 입구)에 생성.
모델 A와 B를 번갈아 생성하거나, 각 레인 전용 생성기를 둘 수 있음.
PrinterLane.cs:
bool isBusy: 현재 작업 중인지 여부.
float processingTime: 인쇄 공정 시간.
Transform pcbExitPoint: PCB 배출 위치.
bool boardAvailableSignal: 셔틀에게 보낼 BA 신호 (논리적 표현).
로직: PCB 도착 감지 -> isBusy = true -> processingTime 만큼 대기 (코루틴 사용) -> boardAvailableSignal = true -> 셔틀이 가져갈 때까지 대기 (셔틀의 MR 신호 확인).
ShuttleConveyor.cs:
Transform lane1PickupPoint, lane2PickupPoint, outletPoint: 각 위치.
PrinterLane lane1, lane2: 프린터 레인 스크립트 참조.
float travelSpeed: 셔틀 이동 속도.
bool machineReadySignalToLane1, machineReadySignalToLane2: 각 레인으로 보낼 MR 신호.
bool boardAvailableSignalToOutlet: 출구 컨베이어로 보낼 BA 신호.
로직:
lane1.boardAvailableSignal 및 lane2.boardAvailableSignal 모니터링.
병합 로직 (예: 간단한 라운드 로빈 또는 먼저 신호 보낸 쪽 우선).
선택된 레인으로 이동 -> 해당 레인에 machineReadySignal 전송 -> PCB 수신 -> 출구로 이동 -> boardAvailableSignalToOutlet 전송 -> PCB 배출.
OutletConveyor.cs:
셔틀로부터 PCB를 받아 라인 끝으로 이동시키는 간단한 컨베이어.
PCBDestroyer.cs:
OnTriggerEnter를 사용하여 특정 영역에 들어온 PCB 게임 오브젝트를 Destroy().
SMEMA 신호 처리 (간단화):

실제 전기 신호 대신, 스크립트 간의 Boolean 변수 (플래그)를 직접 참조하거나 간단한 함수 호출로 "신호가 켜졌다/꺼졌다"를 표현합니다. 예를 들어, 셔틀이 프린터 레인 1의 boardAvailableSignal이 true인지 확인하고, 준비되면 자신의 machineReadySignalToLane1을 true로 설정하는 식입니다.
구현 과정 요약 (사용자 측면):

Unity Hub에서 새 3D 프로젝트를 생성합니다.
제가 제공하는 C# 스크립트 파일들을 프로젝트의 Assets 폴더 어딘가에 복사해 넣습니다.
Unity 에디터에서 GameObject -> 3D Object 메뉴를 사용하여 씬에 바닥, 큐브(프린터, 컨베이어, 셔틀 등)를 배치하여 라인 형태를 만듭니다.
각 게임 오브젝트에 해당하는 스크립트를 드래그 앤 드롭하여 컴포넌트로 추가합니다.
각 스크립트의 인스펙터 창에 나타나는 변수들(예: 이동 속도, 처리 시간, 다른 오브젝트 참조 등)을 설정합니다. (예: PrinterLane 스크립트에 ShuttleConveyor 스크립트가 있는 게임 오브젝트를 연결)
PCB 모양으로 사용할 간단한 큐브를 만들고 Material 색상을 다르게 하여 모델 A, B 용 프리팹을 만듭니다. PCBGenerator 스크립트에 이 프리팹을 연결합니다.
카메라 위치를 조정하여 전체 라인이 잘 보이도록 합니다.
플레이 버튼을 누르면, PCB가 자동으로 생성되어 라인을 따라 이동하고 셔틀에 의해 병합되어 배출되는 과정을 무한 반복으로 볼 수 있습니다.
이런 방식으로 접근하면, 사용자가 직접 코딩을 깊게 하지 않더라도, 제공된 구성 요소들을 조립하고 설정하는 것만으로 원하는 SMT 라인 시뮬레이션의 기본 골격을 만들고 동작을 관찰할 수 있습니다. 완벽한 실제 설비와는 거리가 있겠지만, 보드 흐름과 자동화된 연동 동작을 이해하고 시각화하는 데는 충분할 것입니다.

제가 구체적인 스크립트 코드 예시를 제공해 드리면 훨씬 도움이 될까요? 모든 스크립트를 한 번에 다 드리긴 어렵지만, 주요 부분의 구조를 보여드릴 수 있습니다.





전체구조와,먼저 전체의 절반 실제코드주세요 고급패턴유지하고 수정없이바로쓸수잇게



생각하는 과정 표시
알겠습니다. Unity 새 빈 프로젝트에서 바로 사용하실 수 있도록 고급 패턴을 유지하면서 SMT 라인 시뮬레이션의 전체 구조 설명과 함께, **핵심 로직의 실제 C# 코드 "절반"**을 제공해 드리겠습니다.

"절반"의 범위는 다음과 같습니다:

PCB 데이터 정의 및 이동 로직 (PCB.cs)
PCB를 주기적으로 생성하는 로직 (PCBGenerator.cs)
프린터 레인이 PCB를 받아 처리하고, 처리 완료를 알리는 로직 (PrinterLane.cs)
간단한 센서 및 PCB 제거 로직 (SensorPoint.cs, PCBDestroyer.cs)
셔틀 컨베이어의 복잡한 이동 및 병합 로직, 그리고 전체 장비 간의 정교한 SMEMA 핸드셰이크 로직은 "나머지 절반"로 남겨두겠습니다. 하지만 이번 코드에서 그 기반이 되는 구조를 포함하도록 하겠습니다.

전체 시스템 아키텍처 개요

GameManager (혹은 SimulationManager): (선택 사항이지만 권장)

역할: 시뮬레이션 전반의 설정 (PCB 생성 간격 등), 주요 장비(프린터 레인, 셔틀)에 대한 참조 제공, 일시정지/재개 등 전역 제어.
구현: 싱글톤 패턴을 사용하거나, 각 장비가 시작 시점에 참조를 찾아 연결하도록 할 수 있습니다. (이번 코드에서는 각 장비가 필요한 참조를 [SerializeField]로 받도록 하겠습니다.)
PCB (Prefab + PCB.cs):

역할: 생산되는 실제 보드. 모델 정보(A 또는 B), 현재 상태 등을 가집니다. 지정된 목적지로 스스로 이동하는 기능을 가집니다.
주요 기능: 모델 타입 식별, 이동, 상태 관리.
PCBGenerator (PCBGenerator.cs):

역할: 설정된 주기로 지정된 모델의 PCB 프리팹을 생성하여 특정 시작 지점(예: 프린터 레인 입구)으로 보냅니다.
주요 기능: PCB 생성, 생성 주기 관리, 생성될 PCB 모델 설정.
Printer (Empty GameObject - 컨테이너 역할)

PrinterLane 두 개 (또는 그 이상)를 자식으로 가집니다.
PrinterLane (PrinterLane.cs):

역할: 컨베이어를 통해 PCB를 받아 지정된 "인쇄 위치"까지 이송. 설정된 시간 동안 "인쇄" 처리(시간 지연으로 시뮬레이션). 인쇄 완료 후 PCB를 출구 지점으로 이동시키고, 외부(셔틀)에서 가져갈 수 있도록 BoardAvailable 신호를 활성화합니다.
주요 기능: PCB 수신, 내부 컨베이어 동작, 인쇄 시간 처리, BoardAvailable 상태 관리.
ShuttleConveyor (ShuttleConveyor.cs): (이번 "절반"에서는 기본 틀만)

역할: 두 개(또는 그 이상)의 PrinterLane으로부터 BoardAvailable 신호를 감지. 자체 로직(우선순위, 라운드 로빈 등)에 따라 PCB를 수령 (MachineReady 신호로 응답). 수령한 PCB를 단일 출구 컨베이어로 이송.
주요 기능: 프린터 레인 모니터링, PCB 수령 결정, 셔틀 이동, PCB 배출.
OutletConveyor (가칭, SimpleConveyor.cs 등으로 구현 가능):

역할: 셔틀로부터 PCB를 받아 라인 밖(또는 다음 공정)으로 이송.
SensorPoint (SensorPoint.cs):

역할: 특정 지점에 PCB가 도착했는지 감지하는 범용 센서. UnityEvent를 사용하여 PCB 도착 시 특정 동작을 트리거합니다.
주요 기능: PCB 감지(Trigger Collider 사용), 이벤트 발생.
PCBDestroyer (PCBDestroyer.cs):

역할: 라인 끝에 도달한 PCB 오브젝트를 제거하여 시스템 리소스를 관리합니다.
주요 기능: PCB 감지 및 파괴.
SMEMA 신호 표현 방식 (이번 "절반"에서의 접근):

각 장비는 외부에 공개되는 프로퍼티(예: public bool IsBoardAvailable { get; private set; })를 통해 자신의 상태를 알립니다.
다른 장비는 이 프로퍼티를 직접 참조하여 상태를 확인하고 다음 행동을 결정합니다. (예: 셔틀이 PrinterLane.IsBoardAvailable을 확인).
조금 더 발전된 방식은 C# event나 UnityEvent를 사용하여 상태 변경을 알리고, 관심 있는 객체들이 이를 구독(subscribe)하는 것입니다. PrinterLane이 PCB 처리를 완료했을 때 OnBoardAvailable?.Invoke(); 와 같이 이벤트를 발생시키는 형태를 일부 도입하겠습니다.
실제 C# 코드 (절반)

1. PCB.cs
PCB 종류와 이동 로직을 담당합니다.

C#

// PCB.cs
using UnityEngine;

public enum ModelType { ModelA, ModelB, None }

public class PCB : MonoBehaviour
{
    public ModelType CurrentModelType { get; private set; }
    public float moveSpeed = 2f;

    private Transform targetDestination;
    private System.Action onArrivedAtDestination; // 도착 시 호출될 콜백

    public void Initialize(ModelType modelType)
    {
        CurrentModelType = modelType;
        // 모델별 외형 변경 (예: 색상)
        Renderer rend = GetComponent<Renderer>();
        if (rend != null)
        {
            rend.material.color = (modelType == ModelType.ModelA) ? Color.cyan : Color.magenta;
        }
        gameObject.name = "PCB_" + modelType.ToString();
    }

    void Update()
    {
        if (targetDestination != null)
        {
            transform.position = Vector3.MoveTowards(transform.position, targetDestination.position, moveSpeed * Time.deltaTime);
            if (Vector3.Distance(transform.position, targetDestination.position) < 0.01f)
            {
                Arrived();
            }
        }
    }

    public void SetDestination(Transform destination, System.Action onArrivedCallback = null)
    {
        targetDestination = destination;
        onArrivedAtDestination = onArrivedCallback;
    }

    private void Arrived()
    {
        transform.position = targetDestination.position; // 정확한 위치로 설정
        targetDestination = null; // 목적지 초기화
        onArrivedAtDestination?.Invoke(); // 콜백 호출
        onArrivedAtDestination = null; // 콜백 참조 제거
    }

    // PCB가 다른 장비로 옮겨갈 때 부모를 변경하여 함께 이동하도록 할 수 있음
    public void SetParent(Transform newParent)
    {
        transform.SetParent(newParent, true); // 월드 포지션 유지하며 부모 변경
    }
}
2. PCBGenerator.cs
주기적으로 PCB를 생성합니다.

C#

// PCBGenerator.cs
using UnityEngine;
using System.Collections;

public class PCBGenerator : MonoBehaviour
{
    [Header("PCB Settings")]
    [SerializeField] private GameObject pcbPrefab;
    [SerializeField] private ModelType modelToGenerate = ModelType.ModelA;
    [SerializeField] private float generationInterval = 5f; // PCB 생성 간격 (초)

    [Header("Target Settings")]
    [SerializeField] private PrinterLane targetPrinterLane; // 생성된 PCB가 처음 갈 프린터 레인
                                                            // 또는 Transform으로 시작 위치만 지정하고, PrinterLane이 직접 가져가도록 할 수도 있음

    void Start()
    {
        if (pcbPrefab == null)
        {
            Debug.LogError("PCB Prefab is not assigned!", this);
            enabled = false;
            return;
        }
        if (targetPrinterLane == null)
        {
            // 만약 프린터 레인이 아닌 일반 시작점으로 보내고 싶다면 이 부분을 수정/주석처리
            Debug.LogWarning("Target Printer Lane is not assigned. PCBs will be generated but not sent to a lane.", this);
        }
        StartCoroutine(GeneratePCBsRoutine());
    }

    IEnumerator GeneratePCBsRoutine()
    {
        while (true)
        {
            yield return new WaitForSeconds(generationInterval);
            GeneratePCB();
        }
    }

    void GeneratePCB()
    {
        GameObject newPcbGO = Instantiate(pcbPrefab, transform.position, Quaternion.identity);
        PCB pcbScript = newPcbGO.GetComponent<PCB>();

        if (pcbScript != null)
        {
            pcbScript.Initialize(modelToGenerate);
            Debug.Log($"Generated {modelToGenerate} at {Time.time}s", this);

            if (targetPrinterLane != null)
            {
                // 생성된 PCB를 즉시 프린터 레인의 입구로 보내고, 프린터 레인이 받을 준비가 되면 처리 시작
                // 이 부분은 프린터 레인의 수용 능력(버퍼)을 고려해야 함.
                // 여기서는 간단히 프린터 레인의 입구 센서 위치로 이동시킨다고 가정.
                targetPrinterLane.EnqueuePCB(pcbScript);
            }
            else
            {
                // 또는 특정 시작 컨베이어로 보내는 로직
            }
        }
        else
        {
            Debug.LogError("PCB Prefab does not have a PCB script attached!", this);
            Destroy(newPcbGO); // 잘못된 프리팹이면 파괴
        }
    }
}
3. SensorPoint.cs
PCB 감지 시 이벤트를 발생시키는 범용 센서입니다.

C#

// SensorPoint.cs
using UnityEngine;
using UnityEngine.Events; // UnityEvent를 사용하기 위함

public class SensorPoint : MonoBehaviour
{
    [System.Serializable]
    public class PCBEvent : UnityEvent<PCB> { } // PCB 객체를 전달하는 이벤트

    public PCBEvent onPCBDected;
    [SerializeField] private string pcbTag = "PCB"; // 감지할 PCB의 태그 (선택 사항)
    [SerializeField] private bool oneTimeDetection = false; // 한 번만 감지할지 여부
    private bool detected = false;

    void OnTriggerEnter(Collider other)
    {
        if (oneTimeDetection && detected) return;

        if (!string.IsNullOrEmpty(pcbTag) && !other.CompareTag(pcbTag)) return;

        PCB pcb = other.GetComponent<PCB>();
        if (pcb != null)
        {
            Debug.Log($"{gameObject.name} detected PCB: {pcb.name}", this);
            onPCBDected.Invoke(pcb);
            detected = true;
        }
    }

    public void ResetDetection()
    {
        detected = false;
    }
}
4. PrinterLane.cs
프린터 레인의 동작을 정의합니다. PCB를 받고, 처리하고, 내보낼 준비를 합니다.

C#

// PrinterLane.cs
using UnityEngine;
using System.Collections;
using System.Collections.Generic; // Queue를 사용하기 위함
using UnityEngine.Events;

public class PrinterLane : MonoBehaviour
{
    [Header("Lane Configuration")]
    [SerializeField] private float processingTime = 3f; // 인쇄 처리 시간
    [SerializeField] private int bufferCapacity = 1; // 입구 버퍼 용량 (0이면 바로 처리 시작 위치로)

    [Header("Movement Points (Transforms)")]
    [SerializeField] private Transform entryPoint;     // PCB가 레인으로 들어오는 시작점 (PCB Generator가 여기로 보냄)
    [SerializeField] private Transform processingPoint; // 실제 인쇄가 이루어지는 위치
    [SerializeField] private Transform exitPoint;      // 인쇄 완료 후 PCB가 대기하는 위치 (셔틀이 가져갈 위치)

    [Header("Sensors (Optional but Recommended)")]
    // SensorPoint 컴포넌트를 가진 GameObject를 연결
    [SerializeField] private SensorPoint entrySensor;
    [SerializeField] private SensorPoint processingSensor;
    [SerializeField] private SensorPoint exitSensor;


    private Queue<PCB> pcbQueue = new Queue<PCB>(); // 입력 대기 중인 PCB 큐
    private PCB currentProcessingPCB = null; // 현재 처리 중인 PCB
    private PCB pcbAtExit = null; // 출구에서 대기 중인 PCB

    public bool IsBoardAvailable { get; private set; } = false; // 셔틀이 가져갈 PCB가 출구에 있는가?
    public UnityEvent OnBoardAvailableEvent; // PCB가 출구에 준비되었을 때 발생하는 이벤트
    public UnityEvent OnBoardPickedUpEvent; // PCB가 셔틀에 의해 가져가졌을 때 발생하는 이벤트


    void Start()
    {
        if(entrySensor) entrySensor.onPCBDected.AddListener(HandlePCBAtEntry);
        if(processingSensor) processingSensor.onPCBDected.AddListener(HandlePCBAtProcessing);
        if(exitSensor) exitSensor.onPCBDected.AddListener(HandlePCBAtExit);
    }

    // PCB Generator 또는 이전 공정에서 PCB를 이 레인으로 보낼 때 호출
    public bool EnqueuePCB(PCB pcb)
    {
        if (pcbQueue.Count + (currentProcessingPCB != null ? 1 : 0) < bufferCapacity + 1) // 버퍼 + 처리중인 PCB
        {
            pcbQueue.Enqueue(pcb);
            Debug.Log($"{name}: PCB {pcb.name} enqueued. Queue size: {pcbQueue.Count}", this);
            // PCB를 레인의 물리적인 entryPoint로 이동시키는 로직
            // 여기서는 SensorPoint를 사용하므로, PCB가 entryPoint로 이동 완료 시 HandlePCBAtEntry가 호출될 것임
            pcb.SetDestination(entryPoint);
            TryProcessNextPCB();
            return true;
        }
        Debug.LogWarning($"{name}: Buffer is full. Cannot enqueue PCB {pcb.name}.", this);
        return false;
    }

    // 입구 센서에 PCB 도착 시
    private void HandlePCBAtEntry(PCB pcb)
    {
        // 이미 큐에 있거나 처리중인 PCB가 다시 감지될 수 있으므로, 적절한 로직 필요
        // 여기서는 EnqueuePCB에서 이미 큐에 넣고 이동시켰다고 가정
        Debug.Log($"{name}: PCB {pcb.name} detected at entry sensor.", this);
        TryProcessNextPCB(); // 다음 PCB 처리 시도
    }

    private void TryProcessNextPCB()
    {
        if (currentProcessingPCB == null && pcbQueue.Count > 0)
        {
            currentProcessingPCB = pcbQueue.Dequeue();
            Debug.Log($"{name}: Moving PCB {currentProcessingPCB.name} to processing point. Queue: {pcbQueue.Count}", this);
            currentProcessingPCB.SetDestination(processingPoint); // 처리 위치로 PCB 이동
            // 이동 완료는 processingSensor가 감지하거나, PCB의 onArrivedCallback으로 처리
        }
    }

    // 처리 위치 센서에 PCB 도착 시 (또는 PCB의 이동 완료 콜백)
    private void HandlePCBAtProcessing(PCB pcb)
    {
        if (pcb == currentProcessingPCB)
        {
            StartCoroutine(ProcessPCB(pcb));
        }
    }

    IEnumerator ProcessPCB(PCB pcb)
    {
        Debug.Log($"{name}: Started processing PCB {pcb.name} for {processingTime}s", this);
        yield return new WaitForSeconds(processingTime);
        Debug.Log($"{name}: Finished processing PCB {pcb.name}", this);

        pcbAtExit = pcb; // 처리 완료된 PCB를 출구 대기 상태로
        currentProcessingPCB = null; // 현재 처리 중인 PCB 없음

        pcbAtExit.SetDestination(exitPoint); // 출구 지점으로 PCB 이동
        // 이동 완료는 exitSensor가 감지하거나, PCB의 onArrivedCallback으로 처리
    }

    // 출구 센서에 PCB 도착 시
    private void HandlePCBAtExit(PCB pcb)
    {
        if (pcb == pcbAtExit)
        {
            IsBoardAvailable = true;
            OnBoardAvailableEvent.Invoke(); // 이벤트 발생
            Debug.Log($"{name}: PCB {pcb.name} is now available at exit. Waiting for pickup.", this);
        }
    }

    // 셔틀이 PCB를 가져갈 때 호출하는 함수
    public PCB PickUpBoardFromExit()
    {
        if (IsBoardAvailable && pcbAtExit != null)
        {
            PCB boardToReturn = pcbAtExit;
            Debug.Log($"{name}: PCB {boardToReturn.name} picked up from exit.", this);

            IsBoardAvailable = false;
            pcbAtExit = null;
            OnBoardPickedUpEvent.Invoke();

            TryProcessNextPCB(); // 다음 PCB 처리 시도

            if(exitSensor) exitSensor.ResetDetection(); // 출구 센서 리셋 (필요하다면)

            return boardToReturn;
        }
        return null;
    }
}
5. PCBDestroyer.cs
라인 끝에서 PCB를 제거합니다.

C#

// PCBDestroyer.cs
using UnityEngine;

public class PCBDestroyer : MonoBehaviour
{
    [SerializeField] private string pcbTag = "PCB"; // 감지할 PCB의 태그

    void OnTriggerEnter(Collider other)
    {
        if (!string.IsNullOrEmpty(pcbTag) && !other.CompareTag(pcbTag)) return;

        PCB pcb = other.GetComponent<PCB>();
        if (pcb != null)
        {
            Debug.Log($"Destroying PCB: {pcb.name}", this);
            Destroy(pcb.gameObject);
        }
        else // PCB 스크립트가 없는 경우도 고려 (예: 다른 파편)
        {
            if(other.CompareTag(pcbTag)) // 태그만 일치해도 파괴 (선택적)
            {
                Debug.Log($"Destroying object with tag '{pcbTag}': {other.name}", this);
                Destroy(other.gameObject);
            }
        }
    }
}
Unity 에디터에서의 설정 가이드 (요약)

프로젝트 준비: 새 3D Unity 프로젝트를 만듭니다.

스크립트 추가: 위 5개의 C# 스크립트를 프로젝트에 추가합니다.

PCB 프리팹 생성:

Create -> 3D Object -> Cube로 큐브를 만듭니다. 이름을 "PCB_Prefab" 등으로 변경.
크기를 조절합니다 (예: X:0.5, Y:0.1, Z:0.8).
PCB.cs 스크립트를 붙입니다.
Rigidbody 컴포넌트를 추가하고 Is Kinematic은 체크합니다 (스크립트로 이동 제어). Use Gravity는 해제합니다.
Box Collider 컴포넌트가 있는지 확인하고, Is Trigger는 해제합니다 (다른 센서의 트리거와 충돌하도록).
Tag를 "PCB"로 설정합니다 (SensorPoint, PCBDestroyer에서 사용).
이 "PCB_Prefab"을 Project 창으로 드래그하여 프리팹으로 만듭니다. 씬에서는 삭제합니다.
라인 구성 (기본 도형 사용):

바닥(Plane): Create -> 3D Object -> Plane.
PCBGenerator:
빈 GameObject(Create Empty)를 만들고 이름을 "PCB_Generator_A"로 합니다.
PCBGenerator.cs 스크립트를 붙입니다.
Pcb Prefab 슬롯에 위에서 만든 "PCB_Prefab"을 연결합니다.
Model To Generate를 ModelA로 설정.
Generation Interval 설정 (예: 5초).
Target Printer Lane은 잠시 후 만들 PrinterLane 오브젝트를 연결합니다.
(필요시 "PCB_Generator_B"도 동일하게 만듭니다).
PrinterLane:
빈 GameObject를 만들고 "PrinterLane_1"로 합니다.
PrinterLane.cs 스크립트를 붙입니다.
Processing Time 설정 (예: 3초).
Buffer Capacity 설정 (예: 1 또는 2).
Movement Points: 빈 GameObject들을 ("Entry_L1", "Processing_L1", "Exit_L1") 만들어 "PrinterLane_1"의 자식으로 배치하고, 각 Transform 슬롯에 연결합니다. 이 포인트들이 실제 PCB가 이동할 경로상 위치가 됩니다.
Sensors:
"Entry_L1_Sensor"라는 이름으로 빈 GameObject를 만들고, Entry_L1 Transform과 비슷한 위치에 배치합니다.
Box Collider를 추가하고 Is Trigger를 체크합니다. (센서 영역 크기 조절)
SensorPoint.cs 스크립트를 붙입니다.
PrinterLane_1 오브젝트를 Inspector로 드래그하여 SensorPoint의 On PCB Detected (PCB) 이벤트의 + 버튼을 누르고, PrinterLane 스크립트에서 HandlePCBAtEntry 함수를 선택합니다.
Processing_L1_Sensor, Exit_L1_Sensor도 유사하게 만들고 HandlePCBAtProcessing, HandlePCBAtExit에 각각 연결합니다.
PCBDestroyer:
빈 GameObject를 만들고 "Destroyer_Zone"으로 합니다.
라인의 끝 부분에 배치합니다.
Box Collider를 추가하고 Is Trigger를 체크합니다. 영역 크기 조절.
PCBDestroyer.cs 스크립트를 붙입니다. Pcb Tag가 "PCB"로 되어 있는지 확인합니다.
참조 연결:

PCB_Generator_A의 Target Printer Lane 슬롯에 "PrinterLane_1" 오브젝트를 연결합니다.
(만약 "PrinterLane_2"와 "PCB_Generator_B"를 만들었다면 동일하게 연결합니다).
이제 씬을 실행하면 PCBGenerator가 PCB를 생성하고, PrinterLane으로 보내져 처리된 후 출구 지점에서 대기하는 것까지 시뮬레이션될 것입니다. 셔틀 컨베이어가 없으므로 출구에 PCB가 쌓이거나, PCBDestroyer를 출구 바로 뒤에 두면 바로 파괴될 것입니다.

이것이 요청하신 "절반"의 코드와 구조입니다. 다음 단계에서는 이 기반 위에 셔틀 컨베이어 로직과 장비 간의 보다 세밀한 SMEMA 핸드셰이크를 구현할 수 있습니다. 고급 패턴(예: 이벤트 기반 통신 강화, 상태 머신 패턴 적용)도 더욱 구체화할 수 있습니다.






모델링을 자동으로 하는코드도 주셔야되요



생각하는 과정 표시
네, 알겠습니다. Unity 에디터에서 사용자가 직접 기본 도형들을 배치하고 설정하는 대신, C# 스크립트를 실행하여 SMT 라인의 기본적인 시각적 구조(모델링)를 자동으로 생성하고, 이전에 제공해 드린 동작 로직 스크립트들까지 함께 추가하여 기본적인 시뮬레이션 환경을 구축하는 코드를 제공해 드리겠습니다.

여기서 "모델링"은 Unity의 기본 도형(주로 큐브)을 사용하여 장비의 형태를 간략하게 표현하는 것을 의미합니다. 이 코드는 사용자가 빈 씬에서 스크립트의 특정 함수를 실행하면, 라인 레이아웃과 필요한 컴포넌트들이 자동으로 설정되도록 하는 것을 목표로 합니다.

핵심 자동 생성 스크립트: AutomatedLineBuilder.cs

이 스크립트는 다음 기능을 수행합니다:

SMT 라인 전체를 담을 부모 GameObject를 생성합니다.
파라미터에 따라 프린터 본체, 두 개의 프린터 레인(컨베이어 형태), 각 레인의 입구/처리/출구 지점(Transform)을 생성합니다.
각 프린터 레인에 PrinterLane.cs 스크립트를 추가하고, 필요한 Transform 참조를 연결합니다.
각 프린터 레인 입구 근처에 PCB 생성기 GameObject를 만들고 PCBGenerator.cs 스크립트를 추가하며, 생성된 PCB가 해당 레인으로 향하도록 설정합니다.
(선택적 확장) 센서 포인트 GameObject를 각 주요 지점에 생성하고 SensorPoint.cs를 추가하며, PrinterLane의 이벤트에 연결합니다.
(선택적 확장) 라인 끝에 PCB 제거 영역을 생성합니다.
주의:

이 코드는 에디터 모드에서 실행하여 씬을 구성하는 용도입니다. ([ContextMenu] 사용)
생성되는 모델은 매우 기본적인 큐브 형태입니다.
이전에 제공된 PCB.cs, PCBGenerator.cs, PrinterLane.cs, SensorPoint.cs, PCBDestroyer.cs 스크립트들이 프로젝트 내에 이미 존재해야 합니다.
PCB 프리팹은 사용자가 수동으로 만들거나, 이 스크립트에서 아주 간단한 큐브로 PCB 프리팹까지 생성하도록 확장할 수 있습니다. (여기서는 PCB 프리팹은 이미 프로젝트에 존재한다고 가정합니다.)
AutomatedLineBuilder.cs 코드

C#

// AutomatedLineBuilder.cs
using UnityEngine;
#if UNITY_EDITOR
using UnityEditor; // 에디터 기능을 사용하기 위함 (프리팹 연결 등)
#endif

public class AutomatedLineBuilder : MonoBehaviour
{
    [Header("Line Configuration")]
    [SerializeField] private int numberOfPrinterLanes = 2;
    [SerializeField] private float laneSpacing = 1.0f; // 프린터 레인 간 간격
    [SerializeField] private Color printerColor = Color.gray;
    [SerializeField] private Color conveyorColor = Color.darkGray;
    [SerializeField] private Color sensorColor = Color.yellow;

    [Header("Printer Lane Dimensions")]
    [SerializeField] private Vector3 printerBodySize = new Vector3(2.5f, 1.5f, 2f);
    [SerializeField] private float conveyorLength = 3.0f;
    [SerializeField] private float conveyorWidth = 0.6f;
    [SerializeField] private float conveyorHeight = 0.1f;
    [SerializeField] private float entryZoneLength = 0.5f; // 입구, 처리, 출구 영역 길이
    [SerializeField] private float processingZoneOffset = 1.0f; // 입구에서 처리 지점까지의 Z 오프셋
    [SerializeField] private float exitZoneOffset = 2.5f;     // 입구에서 출구 지점까지의 Z 오프셋

    [Header("PCB Generator Settings")]
    [SerializeField] private GameObject pcbPrefab; // 수동으로 연결 필요
    [SerializeField] private float pcbGenerationInterval = 5f;
    [SerializeField] private float pcbGeneratorOffset = -0.5f; // 레인 입구로부터 PCB 생성기 Z 오프셋

    [Header("Timing Settings")]
    [SerializeField] private float printerProcessingTime = 3f;
    [SerializeField] private int printerBufferCapacity = 1;


    [ContextMenu("1. Build SMT Line Layout")]
    private void BuildLayout()
    {
        // 기존 라인 오브젝트가 있다면 삭제 (중복 생성 방지)
        GameObject existingLine = GameObject.Find("SMT_Line_Automated");
        if (existingLine != null)
        {
            DestroyImmediate(existingLine);
        }

        // 전체 라인을 담을 부모 오브젝트 생성
        GameObject smtLineRoot = new GameObject("SMT_Line_Automated");
        smtLineRoot.transform.position = Vector3.zero;

        // 프린터 본체 생성 (모든 레인을 감싸는 형태)
        float totalPrinterWidth = (numberOfPrinterLanes * conveyorWidth) + ((numberOfPrinterLanes - 1) * laneSpacing);
        if (numberOfPrinterLanes == 1) totalPrinterWidth = conveyorWidth;

        GameObject printerBody = CreatePrimitive(PrimitiveType.Cube, "Printer_Body", printerColor);
        printerBody.transform.SetParent(smtLineRoot.transform);
        printerBody.transform.localScale = new Vector3(totalPrinterWidth + 0.2f, printerBodySize.y, printerBodySize.z); // 약간의 여유
        // 프린터 본체 위치는 레인들의 중앙, 바닥에 놓이도록 y조절
        printerBody.transform.position = new Vector3(0, printerBodySize.y / 2f, printerBodySize.z / 2f);


        // 프린터 레인 및 PCB 생성기 생성
        for (int i = 0; i < numberOfPrinterLanes; i++)
        {
            // 레인 위치 계산 (중앙 정렬)
            float laneXOffset = 0;
            if (numberOfPrinterLanes > 1)
            {
                laneXOffset = -(totalPrinterWidth / 2f) + (conveyorWidth / 2f) + i * (conveyorWidth + laneSpacing);
            }

            string laneName = $"PrinterLane_{i + 1}";
            GameObject laneGO = new GameObject(laneName);
            laneGO.transform.SetParent(smtLineRoot.transform);
            laneGO.transform.position = new Vector3(laneXOffset, conveyorHeight + 0.5f, 0); // 레인 컨베이어의 Y 위치는 바닥에서 약간 위

            // --- 1. 컨베이어 벨트 모델링 ---
            GameObject conveyorBelt = CreatePrimitive(PrimitiveType.Cube, "Conveyor_Belt", conveyorColor);
            conveyorBelt.transform.SetParent(laneGO.transform);
            conveyorBelt.transform.localPosition = new Vector3(0, 0, conveyorLength / 2f); // 로컬 Z축 중앙
            conveyorBelt.transform.localScale = new Vector3(conveyorWidth, conveyorHeight, conveyorLength);

            // --- 2. 이동 포인트 (Entry, Processing, Exit) GameObject 생성 ---
            Transform entryPoint = CreateNamedEmpty(laneGO.transform, "EntryPoint", new Vector3(0, conveyorHeight / 2f + 0.1f, entryZoneLength / 2f));
            Transform processingPoint = CreateNamedEmpty(laneGO.transform, "ProcessingPoint", new Vector3(0, conveyorHeight / 2f + 0.1f, processingZoneOffset));
            Transform exitPoint = CreateNamedEmpty(laneGO.transform, "ExitPoint", new Vector3(0, conveyorHeight / 2f + 0.1f, exitZoneOffset));

            // --- 3. 센서 GameObject 생성 및 설정 ---
            SensorPoint entrySensor = CreateSensor(laneGO.transform, "EntrySensor", entryPoint.localPosition, sensorColor);
            SensorPoint processingSensor = CreateSensor(laneGO.transform, "ProcessingSensor", processingPoint.localPosition, sensorColor);
            SensorPoint exitSensor = CreateSensor(laneGO.transform, "ExitSensor", exitPoint.localPosition, sensorColor);


            // --- 4. PrinterLane 스크립트 추가 및 설정 ---
            PrinterLane printerLaneScript = laneGO.AddComponent<PrinterLane>();
            printerLaneScript.SetInternalRefsForBuilder(processingTime, printerBufferCapacity, entryPoint, processingPoint, exitPoint, entrySensor, processingSensor, exitSensor);
            
            // 에디터에서 이벤트 리스너 연결 (코드로 추가)
#if UNITY_EDITOR
            UnityEditor.Events.UnityEventTools.AddPersistentListener(entrySensor.onPCBDected, printerLaneScript.HandlePCBAtEntry);
            UnityEditor.Events.UnityEventTools.AddPersistentListener(processingSensor.onPCBDected, printerLaneScript.HandlePCBAtProcessing);
            UnityEditor.Events.UnityEventTools.AddPersistentListener(exitSensor.onPCBDected, printerLaneScript.HandlePCBAtExit);
            EditorUtility.SetDirty(entrySensor); // 변경사항 저장
            EditorUtility.SetDirty(processingSensor);
            EditorUtility.SetDirty(exitSensor);
            EditorUtility.SetDirty(printerLaneScript);
#endif

            // --- 5. PCBGenerator 생성 및 설정 ---
            GameObject generatorGO = new GameObject($"PCB_Generator_Lane{i + 1}");
            generatorGO.transform.SetParent(smtLineRoot.transform);
            // 위치: 해당 레인의 입구 앞쪽
            generatorGO.transform.position = new Vector3(laneXOffset, conveyorHeight + 0.6f, entryPoint.localPosition.z + pcbGeneratorOffset);

            PCBGenerator generatorScript = generatorGO.AddComponent<PCBGenerator>();
            ModelType pcbModel = (i % 2 == 0) ? ModelType.ModelA : ModelType.ModelB; // 번갈아가며 모델 A, B 생성
            generatorScript.SetInternalRefsForBuilder(pcbPrefab, pcbModel, pcbGenerationInterval, printerLaneScript);
#if UNITY_EDITOR
            EditorUtility.SetDirty(generatorScript);
#endif
        }

        // 라인 끝에 PCBDestroyer 생성 (예시)
        GameObject destroyerGO = new GameObject("PCBDestroyer_Zone");
        destroyerGO.transform.SetParent(smtLineRoot.transform);
        // 위치는 마지막 레인의 출구보다 더 뒤로
        destroyerGO.transform.position = new Vector3(0, conveyorHeight + 0.5f, conveyorLength + 1.0f);
        BoxCollider destroyerCollider = destroyerGO.AddComponent<BoxCollider>();
        destroyerCollider.isTrigger = true;
        destroyerCollider.size = new Vector3(totalPrinterWidth + 1.0f, 1.0f, 0.5f); // 넓게
        destroyerGO.AddComponent<PCBDestroyer>(); // PCBDestroyer.cs 스크립트 필요
#if UNITY_EDITOR
        EditorUtility.SetDirty(destroyerGO);
#endif

        Debug.Log("SMT Line Layout Built!");
    }


    // 헬퍼 함수: 기본 도형 생성
    private GameObject CreatePrimitive(PrimitiveType type, string name, Color color)
    {
        GameObject go = GameObject.CreatePrimitive(type);
        go.name = name;
        Renderer rend = go.GetComponent<Renderer>();
        if (rend != null)
        {
            Material mat = new Material(Shader.Find("Standard")); // 기본 머티리얼 생성
            mat.color = color;
            rend.material = mat;
        }
        // 기본 도형은 콜라이더를 가지고 생성되므로, 필요에 따라 제거하거나 isTrigger로 변경
        Collider col = go.GetComponent<Collider>();
        if (col != null)
        {
            // 여기서는 시각적 표현이므로 콜라이더는 그대로 두거나, isTrigger=true로 할 수 있습니다.
            // 만약 물리적 상호작용이 필요 없다면 DestroyImmediate(col)도 가능.
        }
        return go;
    }

    // 헬퍼 함수: 이름 붙은 빈 오브젝트 (Transform 포인트용)
    private Transform CreateNamedEmpty(Transform parent, string name, Vector3 localPosition)
    {
        GameObject go = new GameObject(name);
        go.transform.SetParent(parent);
        go.transform.localPosition = localPosition;
        go.transform.localRotation = Quaternion.identity;
        go.transform.localScale = Vector3.one;
        return go.transform;
    }

    // 헬퍼 함수: 센서 GameObject 생성
    private SensorPoint CreateSensor(Transform parent, string name, Vector3 localPosition, Color gizmoColor)
    {
        GameObject sensorGO = CreateNamedEmpty(parent, name, localPosition).gameObject;
        BoxCollider col = sensorGO.AddComponent<BoxCollider>();
        col.isTrigger = true;
        col.size = new Vector3(conveyorWidth * 0.8f, conveyorHeight * 2, entryZoneLength * 0.8f); // 센서 영역 크기
        SensorPoint sensorScript = sensorGO.AddComponent<SensorPoint>();
        // SensorPoint에 시각적 기즈모 추가 (에디터에서만 보임)
        var gizmo = sensorGO.AddComponent<SensorGizmo>(); // 아래 SensorGizmo 클래스 필요
        gizmo.gizmoColor = gizmoColor;

        return sensorScript;
    }
}


// AutomatedLineBuilder.cs 파일 하단 또는 별도 파일에 추가
// 에디터에서 센서 영역을 시각적으로 표시하기 위한 간단한 기즈모 스크립트
public class SensorGizmo : MonoBehaviour
{
    public Color gizmoColor = Color.yellow;
    void OnDrawGizmos()
    {
        Collider col = GetComponent<Collider>();
        if (col != null)
        {
            Gizmos.color = gizmoColor;
            if (col is BoxCollider boxCollider)
            {
                Gizmos.matrix = Matrix4x4.TRS(transform.position, transform.rotation, transform.lossyScale);
                Gizmos.DrawWireCube(boxCollider.center, boxCollider.size);
            }
            else if (col is SphereCollider sphereCollider)
            {
                 Gizmos.matrix = Matrix4x4.TRS(transform.position, transform.rotation, transform.lossyScale);
                 Gizmos.DrawWireSphere(sphereCollider.center, sphereCollider.radius);
            }
        }
    }
}
PrinterLane.cs 및 PCBGenerator.cs 수정 사항:
AutomatedLineBuilder가 내부 참조를 설정할 수 있도록 public 메서드를 추가해야 합니다.

PrinterLane.cs 에 추가할 메서드:

C#

// PrinterLane.cs 내부에 추가
public void SetInternalRefsForBuilder(float procTime, int capacity, Transform entry, Transform proc, Transform exit,
                                      SensorPoint entrySens, SensorPoint procSens, SensorPoint exitSens)
{
    processingTime = procTime;
    bufferCapacity = capacity;
    entryPoint = entry;
    processingPoint = proc;
    exitPoint = exit;
    entrySensor = entrySens;
    processingSensor = procSens;
    exitSensor = exitSens;

    // Start()에서 호출하던 리스너 추가를 여기서도 해줄 수 있으나,
    // Builder에서 EditorUtility.Events.UnityEventTools를 사용하는 것이 더 확실합니다.
    // (빌드 시에는 Editor 코드가 제외되므로, 리스너 연결은 Awake/Start에서 유지하는 것이 안전할 수 있습니다.
    //  또는 Builder가 #if UNITY_EDITOR 블록으로 감싸서 에디터에서만 연결하도록 합니다.)
}
기존 Start()에서의 AddListener 부분은 그대로 두거나, AutomatedLineBuilder에서 연결했다면 중복을 피하기 위해 조건부로 실행하거나 삭제할 수 있습니다. Builder에서 Editor 코드로 연결하는 것이 일반적입니다. 위의 Builder 코드는 Editor 코드로 연결하도록 수정했습니다.

PCBGenerator.cs 에 추가할 메서드:

C#

// PCBGenerator.cs 내부에 추가
public void SetInternalRefsForBuilder(GameObject prefab, ModelType model, float interval, PrinterLane targetLane)
{
    pcbPrefab = prefab;
    modelToGenerate = model;
    generationInterval = interval;
    targetPrinterLane = targetLane;
}
사용 방법:

이전에 제공된 PCB.cs, PCBGenerator.cs (수정된 내용 포함), PrinterLane.cs (수정된 내용 포함), SensorPoint.cs, PCBDestroyer.cs 스크립트와 위의 AutomatedLineBuilder.cs (그리고 SensorGizmo.cs) 스크립트를 프로젝트에 추가합니다.
PCB 모양으로 사용할 간단한 큐브를 만들고 Material을 적용하여 "PCB_Prefab"이라는 이름의 프리팹으로 저장합니다. (이전 답변의 3번 항목 참고)
빈 씬(Scene)을 엽니다.
씬에 빈 GameObject를 하나 생성하고 이름을 "LineBuilder" 등으로 지정합니다.
"LineBuilder" GameObject에 AutomatedLineBuilder.cs 스크립트를 컴포넌트로 추가합니다.
Inspector 창에서 AutomatedLineBuilder 컴포넌트의 "Pcb Prefab" 슬롯에 2번 단계에서 만든 "PCB_Prefab"을 드래그 앤 드롭하여 연결합니다.
다른 파라미터들 (레인 수, 간격, 크기, 시간 등)을 원하는 대로 조절합니다.
"LineBuilder" GameObject의 Inspector 창에서 AutomatedLineBuilder 컴포넌트의 오른쪽 상단 점 3개(또는 톱니바퀴 아이콘)를 클릭하고, 나타나는 메뉴에서 "1. Build SMT Line Layout" 을 선택합니다.
씬에 SMT 라인의 기본 구조가 자동으로 생성되고, 필요한 스크립트와 참조가 연결된 것을 확인할 수 있습니다.
이제 Unity 플레이 버튼을 누르면 시뮬레이션이 (이전 코드의 로직에 따라) 동작하기 시작할 것입니다.
이 코드는 프린터 레인과 PCB 생성기 부분의 자동 생성을 다룹니다. 셔틀 컨베이어, 출구 컨베이어 등의 자동 생성은 이 패턴을 확장하여 유사하게 추가할 수 있습니다. 이 정도면 사용자가 코드를 통해 기본적인 "모델링"과 "씬 구성"을 자동화하는 경험을 할 수 있을 것입니다.