네, 알겠습니다. Serilog 사용에 문제가 있으셨군요. .NET Framework 4.6.0 버전을 기준으로 Serilog를 사용하지 않고, 에이전트(SAgentM.App)의 UI 로그와 함께 간단한 텍스트 파일 로그 기능을 포함하는 방식으로 전체 코드를 다시 수정하여 제공해 드리겠습니다.

핵심 변경 사항은 App.xaml.cs에서 Serilog 초기화 코드를 제거하고, Services/LoggingService.cs가 UI용 ObservableCollection 로그와 더불어 간단한 텍스트 파일 로그 기록 기능을 함께 수행하도록 수정하는 것입니다.

SAgentM.App 프로젝트 전체 코드 (.NET Framework 4.6.0 - WPF 에이전트, Serilog 제거)
사전 준비:

(이전과 동일) Visual Studio에서 ".NET Framework WPF 앱" 프로젝트 템플릿으로 SAgentM.App 프로젝트를 생성합니다.
대상 프레임워크를 .NET Framework 4.6 (또는 명시적으로 4.6.0)으로 설정합니다.
NuGet 패키지 설치:
Newtonsoft.Json (JSON 처리용)
(Serilog 관련 패키지는 이제 필요 없습니다.)
SControl.Common 프로젝트를 참조 추가합니다.
1. 수정: SAgentM.App/app.manifest (관리자 권한 실행 설정)
(이전과 동일: requireAdministrator 설정 유지)
<!-- end list -->

XML

<?xml version="1.0" encoding="utf-8"?>
<asmv1:assembly manifestVersion="1.0" xmlns="urn:schemas-microsoft-com:asm.v1" xmlns:asmv1="urn:schemas-microsoft-com:asm.v1" xmlns:asmv2="urn:schemas-microsoft-com:asm.v2" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <assemblyIdentity version="1.0.0.0" name="MyApplication.app"/>
  <trustInfo xmlns="urn:schemas-microsoft-com:asm.v2">
    <security>
      <requestedPrivileges xmlns="urn:schemas-microsoft-com:asm.v3">
        <requestedExecutionLevel  level="requireAdministrator" uiAccess="false" />
      </requestedPrivileges>
    </security>
  </trustInfo>
  <compatibility xmlns="urn:schemas-microsoft-com:compatibility.v1">
    <application>
      </application>
  </compatibility>
</asmv1:assembly>
2. 수정: SAgentM.App/App.config
(Serilog 관련 설정 키가 있었다면 제거, 나머지는 이전과 유사)
<!-- end list -->

XML

<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <startup> 
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.6" />
  </startup>
  <appSettings>
    <add key="ListenPort" value="4026" />
    <add key="MaxUiLogEntries" value="50" /> 
    <add key="LogFileDirectory" value="Logs_SAgentM" /> </appSettings>
</configuration>
3. 수정: SAgentM.App/App.xaml (변경 없음 - 기본 유지)
XML

<Application x:Class="SAgentM.App.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:SAgentM.App"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
         
    </Application.Resources>
</Application>
4. 수정: SAgentM.App/App.xaml.cs (Serilog 초기화 코드 제거)
C#

// SAgentM.App/App.xaml.cs
using System; // UnhandledExceptionEventArgs
using System.IO; // Path, Directory
using System.Windows;

namespace SAgentM.App
{
    public partial class App : Application
    {
        // LoggingService에서 파일 로깅을 직접 처리하므로, App 수준의 전역 로거 설정은 제거합니다.
        // LoggingService 인스턴스는 MainWindow 또는 MainViewModel에서 생성되어 사용됩니다.

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // 여기에 전역 예외 처리기 등을 설정할 수 있습니다.
            // Current.DispatcherUnhandledException += App_DispatcherUnhandledException;
            // AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
        }

        // private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        // {
        //     // 비 UI 스레드 예외 처리 (LoggingService를 통해 파일에 기록 가능)
        //     // 예: ((App.Current.MainWindow.DataContext as MainViewModel)?.Logger as LoggingService)?.FileLog(Models.LogLevel.Error, $"Unhandled non-UI exception: {e.ExceptionObject.ToString()}");
        //     MessageBox.Show($"치명적인 오류 발생 (비 UI 스레드): {e.ExceptionObject}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
        // }

        // private void App_DispatcherUnhandledException(object sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs e)
        // {
        //     // UI 스레드 예외 처리 (LoggingService를 통해 파일에 기록 가능)
        //     // 예: ((App.Current.MainWindow.DataContext as MainViewModel)?.Logger as LoggingService)?.FileLog(Models.LogLevel.Error, $"Unhandled UI exception: {e.Exception.ToString()}");
        //     MessageBox.Show($"UI 오류 발생: {e.Exception.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
        //     e.Handled = true; 
        // }

        // OnExit에서 특별히 처리할 전역 로거가 없으므로 기본 동작 유지
        // protected override void OnExit(ExitEventArgs e)
        // {
        //     base.OnExit(e);
        // }
    }
}
5. SAgentM.App/Utils/ObservableObject.cs (변경 없음)
(이전과 동일한 코드 사용)
<!-- end list -->

C#

// SAgentM.App/Utils/ObservableObject.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace SAgentM.App.Utils
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (Equals(storage, value))
            {
                return false;
            }
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
6. SAgentM.App/Utils/AsyncRelayCommand.cs (변경 없음)
(이전과 동일한 코드 사용)
<!-- end list -->

C#

// SAgentM.App/Utils/AsyncRelayCommand.cs
using System;
using System.Threading.Tasks;
using System.Windows.Input;

namespace SAgentM.App.Utils
{
    public class AsyncRelayCommand : ICommand
    {
        private readonly Func<object, Task> _executeAsync;
        private readonly Predicate<object> _canExecutePredicate;
        private bool _isExecuting;

        public AsyncRelayCommand(Func<Task> executeAsync, Func<bool> canExecutePredicate = null)
            : this(async _ => await executeAsync(), canExecutePredicate == null ? (Predicate<object>)null : _ => canExecutePredicate())
        {
        }

        public AsyncRelayCommand(Func<object, Task> executeAsync, Predicate<object> canExecutePredicate = null)
        {
            _executeAsync = executeAsync ?? throw new ArgumentNullException(nameof(executeAsync));
            _canExecutePredicate = canExecutePredicate;
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object parameter)
        {
            return !_isExecuting && (_canExecutePredicate == null || _canExecutePredicate(parameter));
        }

        public async void Execute(object parameter)
        {
            if (CanExecute(parameter))
            {
                _isExecuting = true;
                RaiseCanExecuteChanged();
                try
                {
                    await _executeAsync(parameter);
                }
                finally
                {
                    _isExecuting = false;
                    RaiseCanExecuteChanged();
                }
            }
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
7. SAgentM.App/Models/LogEntry.cs (변경 없음)
(이전 LogLevel에 Received, Sent 추가한 버전 그대로 사용)
<!-- end list -->

C#

// SAgentM.App/Models/LogEntry.cs
using System;

namespace SAgentM.App.Models
{
    public enum LogLevel
    {
        Info,
        Warning,
        Error,
        Debug,
        Received, // 명령 수신 로그용
        Sent      // 응답 전송 로그용
    }

    public class LogEntry
    {
        public DateTime Timestamp { get; }
        public LogLevel Level { get; }
        public string Message { get; }

        public LogEntry(LogLevel level, string message)
        {
            Timestamp = DateTime.Now;
            Level = level;
            Message = message;
        }

        public override string ToString()
        {
            return string.Format("[{0:HH:mm:ss.fff}] [{1}] {2}", Timestamp, Level, Message);
        }
    }
}
8. 수정: SAgentM.App/Services/ILoggingService.cs 및 LoggingService.cs (파일 로깅 기능 추가)
ILoggingService.cs (인터페이스 변경 없음)

C#

// SAgentM.App/Services/ILoggingService.cs
using SAgentM.App.Models;
using System.Collections.ObjectModel;
using System;

namespace SAgentM.App.Services
{
    public interface ILoggingService
    {
        ObservableCollection<LogEntry> UiLogEntries { get; }
        void UiLog(LogLevel level, string message); // 내부적으로 파일 로그도 함께 처리
        void UiInfo(string message);
        void UiWarn(string message);
        void UiError(string message, Exception ex = null);
        void UiDebug(string message);
        void UiReceived(string message);
        void UiSent(string message);
    }
}
LoggingService.cs (Serilog 제거, 간단한 파일 로깅 구현)

C#

// SAgentM.App/Services/LoggingService.cs
using SAgentM.App.Models;
using System;
using System.Collections.ObjectModel;
using System.Configuration;
using System.IO; // Path, Directory, File, StreamWriter
using System.Windows.Data; // BindingOperations

namespace SAgentM.App.Services
{
    public class LoggingService : ILoggingService
    {
        public ObservableCollection<LogEntry> UiLogEntries { get; }
        private readonly int _maxUiEntries;
        private readonly object _uiLogLock = new object();
        private readonly object _fileLogLock = new object(); // 파일 접근 동기화용
        private readonly string _logFileDirectory;
        private string _currentLogFilePath = string.Empty;

        public LoggingService()
        {
            UiLogEntries = new ObservableCollection<LogEntry>();
            BindingOperations.EnableCollectionSynchronization(UiLogEntries, _uiLogLock);

            if (!int.TryParse(ConfigurationManager.AppSettings["MaxUiLogEntries"], out _maxUiEntries))
            {
                _maxUiEntries = 50;
            }

            // 파일 로그 디렉토리 설정
            string configuredDir = ConfigurationManager.AppSettings["LogFileDirectory"] ?? "Logs_SAgentM";
            _logFileDirectory = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, configuredDir);
            try
            {
                if (!Directory.Exists(_logFileDirectory))
                {
                    Directory.CreateDirectory(_logFileDirectory);
                }
            }
            catch (Exception ex)
            {
                // UI 로그에 디렉토리 생성 실패 기록 시도 (주의: 이 시점에 UI 로그가 완전히 준비되지 않았을 수 있음)
                UiLog(LogLevel.Error, $"로그 디렉토리 생성 실패: {_logFileDirectory}. 오류: {ex.Message}");
                // 또는 System.Diagnostics.Trace.WriteLine 사용
            }
            UpdateLogFilePath(); // 오늘 날짜의 로그 파일 경로 설정
        }

        private void UpdateLogFilePath()
        {
            _currentLogFilePath = Path.Combine(_logFileDirectory, $"SAgentM_App_{DateTime.Now:yyyyMMdd}.log");
        }

        private void WriteToFile(LogLevel level, string formattedMessage)
        {
            // 날짜가 바뀌면 새 로그 파일 사용
            if (!Path.GetFileName(_currentLogFilePath).Contains(DateTime.Now.ToString("yyyyMMdd")))
            {
                UpdateLogFilePath();
            }

            lock (_fileLogLock)
            {
                try
                {
                    File.AppendAllText(_currentLogFilePath, formattedMessage + Environment.NewLine);
                }
                catch (Exception ex)
                {
                    // 파일 쓰기 실패 시 UI 로그에 기록 시도 (무한 루프 방지 주의)
                    // 또는 System.Diagnostics.Trace.WriteLine 사용
                    Console.WriteLine($"파일 로그 쓰기 실패: {ex.Message}"); // 최후의 수단
                }
            }
        }

        public void UiLog(LogLevel level, string message)
        {
            // 1. UI 로그 컬렉션에 추가
            var logEntry = new LogEntry(level, message);
            lock (_uiLogLock)
            {
                if (UiLogEntries.Count >= _maxUiEntries && _maxUiEntries > 0)
                {
                    UiLogEntries.RemoveAt(0);
                }
                UiLogEntries.Add(logEntry);
            }

            // 2. 파일 로그에도 동일한 메시지 기록
            WriteToFile(level, logEntry.ToString()); // LogEntry.ToString()은 이미 포맷된 문자열 반환
        }

        public void UiInfo(string message) => UiLog(LogLevel.Info, message);
        public void UiWarn(string message) => UiLog(LogLevel.Warning, message);
        public void UiError(string message, Exception ex = null)
        {
            string fullMessage = message;
            if (ex != null)
            {
                fullMessage += Environment.NewLine + "Exception: " + ex.ToString(); // 전체 예외 정보 기록
            }
            UiLog(LogLevel.Error, fullMessage);
        }
        public void UiDebug(string message) => UiLog(LogLevel.Debug, message);
        public void UiReceived(string message) => UiLog(LogLevel.Received, message);
        public void UiSent(string message) => UiLog(LogLevel.Sent, message);
    }
}
LoggingService.cs 주요 변경 사항:

Serilog 관련 코드를 모두 제거했습니다.
간단한 텍스트 파일 로깅 기능을 추가했습니다:
_logFileDirectory: 로그 파일을 저장할 디렉토리입니다 (App.config의 LogFileDirectory 설정 사용).
_currentLogFilePath: 현재 날짜에 해당하는 로그 파일 경로입니다 (예: Logs_SAgentM\SAgentM_App_20250521.log). 매일 새 파일이 생성됩니다.
WriteToFile: 실제 파일에 로그를 기록하는 메서드입니다. 스레드 안전성을 위해 lock (_fileLogLock)을 사용합니다.
UiLog 메서드가 호출될 때, UI용 ObservableCollection에 로그를 추가하는 것과 동시에 WriteToFile을 호출하여 파일에도 동일한 로그를 기록합니다.
9. SAgentM.App/Services/IAgentCoreService.cs (변경 없음)
(이전과 동일한 인터페이스 사용)
<!-- end list -->

C#

// SAgentM.App/Services/IAgentCoreService.cs
namespace SAgentM.App.Services
{
    public interface IAgentCoreService
    {
        void Start();
        void Stop();
        bool IsRunning { get; }
    }
}
10. SAgentM.App/Services/AgentCoreService.cs (변경 없음 - 이전 최종 버전 사용)
이전에 "모니터 끄기 실패" 문제 해결 및 powercfg 기능을 추가한 버전의 AgentCoreService.cs 코드를 그대로 사용합니다. 해당 버전은 이미 ILoggingService를 주입받아 사용하고 있으므로, Serilog 제거에 따른 직접적인 코드 변경은 없습니다. 로깅은 주입된 LoggingService를 통해 이루어지며, 이 LoggingService가 이제 UI 로그와 파일 로그를 모두 처리합니다. (이전 응답에서 제공된 전체 코드를 사용하시면 됩니다. 필요하시면 다시 요청해주세요.)
11. SAgentM.App/ViewModels/MainViewModel.cs (변경 없음 - 이전 최종 버전 사용)
ILoggingService와 IAgentCoreService를 사용하므로, LoggingService 내부 구현 변경에 영향을 받지 않습니다. (이전 응답에서 제공된 전체 코드를 사용하시면 됩니다.)
12. SAgentM.App/MainWindow.xaml (변경 없음 - 이전 최종 버전 사용)
ViewModel에 바인딩되므로 직접적인 변경은 없습니다. (이전 응답에서 제공된 전체 코드를 사용하시면 됩니다.)
13. SAgentM.App/MainWindow.xaml.cs (변경 없음 - 이전 최종 버전 사용)
ViewModel과 서비스를 초기화하는 방식은 동일합니다. (이전 응답에서 제공된 전체 코드를 사용하시면 됩니다.)
요약하면, 주된 변경은 다음과 같습니다:

App.xaml.cs: Serilog 초기화 코드 제거.
LoggingService.cs: Serilog 의존성 제거, 자체적인 간단한 텍스트 파일 로깅 기능 구현 (날짜별 파일 생성).
App.config: Serilog 관련 설정 키가 있었다면 제거, LogFileDirectory 키 추가 (선택적).
AgentCoreService.cs, MainViewModel.cs, MainWindow.xaml, MainWindow.xaml.cs는 이전 응답에서 제공된 최종 버전을 그대로 사용하시면, 이제 Serilog 없이 UI 로그와 파일 로그가 함께 기록되는 SAgentM.App이 됩니다.

만약 AgentCoreService.cs의 전체 코드가 다시 필요하시면 알려주세요. (가장 최근 버전은 "모니터 끄기" 명령 시 응답을 먼저 보내고, powercfg를 통한 "디스플레이 타임아웃 설정" 기능이 포함된 버전입니다.)

