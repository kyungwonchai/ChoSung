, 알겠습니다. 요청하신 UI 변경 사항들을 반영하겠습니다.

전체 글씨 크기 +1: MainWindow.xaml의 루트 요소(ThemedWindow)에 FontSize를 설정하여 전반적인 글씨 크기를 키웁니다. (예: 기본값이 12 또는 13 근처였다면 14 또는 15 정도로 설정)
컬럼 헤더 가운데 정렬: MainWindow.xaml의 LightBlueHeaderStyle에 HorizontalContentAlignment="Center"가 이미 설정되어 있는지 확인하고 적용합니다. (이전 코드에 이미 포함되어 있었습니다.)
연관 행 노란색 배경: 메인 그리드에서 특정 콤보박스 셀을 클릭(선택)했을 때, 해당 셀의 값과 동일한 값을 가진 다른 모든 행들의 배경을 노란색으로 변경합니다. 이를 위해 다음 작업이 필요합니다.
MainViewModel에 현재 선택된 셀의 정보(컬럼명, 값)를 저장할 속성 추가.
MainWindow.xaml.cs에서 그리드의 포커스 변경 이벤트를 감지하여 ViewModel의 속성을 업데이트하는 로직 추가.
행 배경을 동적으로 변경하기 위한 IMultiValueConverter 구현 (HighlightRowConverter).
MainWindow.xaml에서 TableView.RowStyle을 정의하고, 위에서 만든 컨버터와 ViewModel 속성을 사용하여 배경색을 조건부로 변경하는 MultiBinding 설정.
수정/추가해야 할 파일 목록:

Views/MainWindow.xaml (FontSize 설정, RowStyle 추가, 이벤트 핸들러 연결)
ViewModels/MainViewModel.cs (선택 셀 정보 속성 및 업데이트 메서드 추가)
Infrastructure/HighlightRowConverter.cs (신규 컨버터 구현)
아래에 이 3개 파일의 수정된 전체 코드를 작성합니다.

1. Views/MainWindow.xaml (수정)

ThemedWindow에 FontSize 설정.
TableView에 FocusedColumnChanged 및 CurrentItemChanged 이벤트 핸들러 추가.
TableView.RowStyle 추가 및 HighlightRowConverter 리소스 정의.
XML

<dx:ThemedWindow
    x:Class="LockerManagementApp.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
    xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
    xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
    xmlns:dxgt="http://schemas.devexpress.com/winfx/2008/xaml/grid/themekeys"
    xmlns:dxb="http://schemas.devexpress.com/winfx/2008/xaml/bars"
    xmlns:dxlc="http://schemas.devexpress.com/winfx/2008/xaml/layoutcontrol"
    xmlns:local="clr-namespace:LockerManagementApp.Views"
    xmlns:viewmodels="clr-namespace:LockerManagementApp.ViewModels"
    xmlns:models="clr-namespace:LockerManagementApp.Models"
    xmlns:infra="clr-namespace:LockerManagementApp.Infrastructure"
    Title="사물함 관리 프로그램 (DevExpress MVVM - .NET Framework 4.8)" Height="750" Width="1300"
    Loaded="MainWindow_Loaded" Closing="MainWindow_Closing"
    FontSize="14" >

    <dx:ThemedWindow.DataContext>
        <viewmodels:MainViewModel/>
    </dx:ThemedWindow.DataContext>

    <dx:ThemedWindow.Resources>
        <infra:BooleanToVisibilityConverter x:Key="BooleanToVisibilityConverter"/>
        <infra:HighlightRowConverter x:Key="HighlightRowConverter"/>

        <Style x:Key="LightBlueHeaderStyle" TargetType="dxg:BaseGridHeader"> <Setter Property="Background" Value="LightBlue"/> <Setter Property="HorizontalContentAlignment" Value="Center"/> <Setter Property="FontWeight" Value="Bold"/> </Style>
        <Style TargetType="dxg:GridColumnHeader" BasedOn="{StaticResource LightBlueHeaderStyle}"/> <Style TargetType="dxg:BandHeaderControl" BasedOn="{StaticResource LightBlueHeaderStyle}"/>

        <Style x:Key="ConditionalRowHighlightStyle" TargetType="dxg:RowControl">
            <Setter Property="Background">
                <Setter.Value>
                    <MultiBinding Converter="{StaticResource HighlightRowConverter}">
                        <Binding Path="DataContext"/>
                        <Binding Path="DataContext.SelectedCellValue" RelativeSource="{RelativeSource AncestorType={dx:ThemedWindow}}"/>
                        <Binding Path="DataContext.SelectedCellColumnFieldName" RelativeSource="{RelativeSource AncestorType={dx:ThemedWindow}}"/>
                    </MultiBinding>
                </Setter.Value>
            </Setter>
            <Style.Triggers>
                 <Trigger Property="IsSelected" Value="True">
                    <Setter Property="Background" Value="{dx:ThemeResource {dxgt:GridRowThemeKey ResourceKey=BorderSelectedBrush}}"/>
                    <Setter Property="Foreground" Value="{dx:ThemeResource {dxgt:GridRowThemeKey ResourceKey=TextRowSelectedBrush}}"/>
                </Trigger>
                 </Style.Triggers>
        </Style>

    </dx:ThemedWindow.Resources>

    <Grid>
        <Grid.RowDefinitions> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/> <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <DockPanel Grid.Row="0" LastChildFill="True">
            <StackPanel Orientation="Horizontal" DockPanel.Dock="Right" Margin="5">
                <TextBlock Text="마스터 키:" VerticalAlignment="Center" Margin="0,0,5,0"/>
                <PasswordBox x:Name="MasterPasswordBox" Width="100" VerticalAlignment="Center" infra:PasswordHelper.Attach="True" infra:PasswordHelper.Password="{Binding MasterPasswordInput, Mode=TwoWay, UpdateSourceTrigger=PropertyChanged}"/>
                <Button Content="확인" Margin="5,0,0,0" Command="{Binding CheckMasterPasswordCommand}"/>
            </StackPanel>
            <Border Background="LightGray" Padding="5">
                 <StackPanel Orientation="Horizontal"> <Button Content="🔄 새로고침" Margin="3" Command="{Binding LoadDataCommand}"/> <Button Content="💾 변경 사항 저장" Margin="3" Command="{Binding SaveChangesCommand}"/>
                     <Button Content="⚙️ 마스터 데이터 관리" Margin="15,3,3,3" Command="{Binding OpenMasterDataWindowCommand}" ToolTip="마스터 데이터(층, 구역 등)를 관리하는 새 창을 엽니다." Visibility="{Binding IsMasterModeEnabled, Converter={StaticResource BooleanToVisibilityConverter}, FallbackValue=Collapsed}"/>
                 </StackPanel>
            </Border>
        </DockPanel>

        <Grid Grid.Row="1" Margin="5">
            <Grid.RowDefinitions> <RowDefinition Height="Auto"/> <RowDefinition Height="*"/> </Grid.RowDefinitions>
            <Border Grid.Row="0" Background="WhiteSmoke" Padding="3"> <StackPanel Orientation="Horizontal"> <Button Content="➕ 새 사물함 추가" Margin="3" Command="{Binding AddNewCommand}"/> <Button Content="❌ 선택 항목 삭제" Margin="3" Command="{Binding DeleteCommand}"/> <Button Content="🧹 배정 해제" Margin="3" Command="{Binding ClearAssignmentCommand}"/> </StackPanel> </Border>
            <dxg:GridControl Grid.Row="1" ItemsSource="{Binding LockerAssignments}" SelectedItem="{Binding SelectedAssignment, Mode=TwoWay}">
                <dxg:GridControl.View>
                    <dxg:TableView AllowPerPixelScrolling="True" ShowGroupPanel="True" AllowEditing="True"
                                   NavigationStyle="Cell" ShowAutoFilterRow="True" NewItemRowPosition="None"
                                   ShowIndicator="True" ShowSearchPanelMode="Always"
                                   FocusedColumnChanged="TableView_FocusedColumnChanged"
                                   CurrentItemChanged="TableView_CurrentItemChanged"
                                   RowStyle="{StaticResource ConditionalRowHighlightStyle}">
                        <dxg:TableView.RowCellMenuCustomizations> <dxb:BarButtonItem Content="배정 해제" Command="{Binding View.DataContext.ClearAssignmentCommand}" Glyph="{dx:DXImage Svg/Actions/DeleteList.svg}"/> <dxb:BarItemSeparator/> <dxb:BarButtonItem Content="행 삭제" Command="{Binding View.DataContext.DeleteCommand}" Glyph="{dx:DXImage Svg/Actions/Delete.svg}"/> </dxg:TableView.RowCellMenuCustomizations>
                    </dxg:TableView>
                </dxg:GridControl.View>
                <dxg:GridControl.Columns>
                    <dxg:GridColumn FieldName="LockerType" Header="종류" Width="100" Fixed="Left" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:ComboBoxEditSettings ItemsSource="{Binding AllLockerTypes}" DisplayMember="Name" ValueMember="Name" IsTextEditable="False" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Floor" Header="층" Width="60" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:ComboBoxEditSettings ItemsSource="{Binding AllFloors}" DisplayMember="Name" ValueMember="Name" IsTextEditable="False" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Zone" Header="구역" Width="80" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:ComboBoxEditSettings ItemsSource="{Binding AllZones}" DisplayMember="Name" ValueMember="Name" IsTextEditable="True" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="SpecificLocation" Header="세부 위치" Width="120" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="UserName" Header="성명" Width="100" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="KnoxId" Header="Knox ID" Width="100" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="SubPart" Header="소파트" Width="120" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:ComboBoxEditSettings ItemsSource="{Binding AllSubParts}" DisplayMember="Name" ValueMember="Name" IsTextEditable="True" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Administrator" Header="관리 담당자" Width="120" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:ComboBoxEditSettings ItemsSource="{Binding AllAdministrators}" DisplayMember="Name" ValueMember="Name" IsTextEditable="True" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="TransferStatus" Header="전배복직" Width="100" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Details" Header="내용" Width="150" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Left"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Remarks" Header="특이사항" Width="150" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Left"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Notes" Header="비고" Width="150" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:TextEditSettings HorizontalContentAlignment="Left"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="LastUpdated" Header="최종 수정일시" Width="150" AllowEditing="False" ReadOnly="True" HeaderStyle="{StaticResource LightBlueHeaderStyle}"> <dxg:GridColumn.EditSettings> <dxe:DateEditSettings MaskType="DateTime" Mask="yyyy-MM-dd HH:mm:ss" MaskUseAsDisplayFormat="True" HorizontalContentAlignment="Center"/> </dxg:GridColumn.EditSettings> </dxg:GridColumn>
                    <dxg:GridColumn FieldName="Id" Header="ID" Visible="False" ReadOnly="True"/>
                </dxg:GridControl.Columns>
            </dxg:GridControl>
        </Grid>

        <StatusBar Grid.Row="2" Background="LightGray"> <StatusBarItem><TextBlock Text="{Binding StatusBarText}" Margin="5,0"/></StatusBarItem> </StatusBar>
    </Grid>

</dx:ThemedWindow>
2. ViewModels/MainViewModel.cs (수정)

선택된 셀 정보(값, 컬럼 필드명)를 저장할 속성 추가 (SelectedCellValue, SelectedCellColumnFieldName).
View의 이벤트 핸들러에서 호출할 공개 메서드 추가 (UpdateHighlightInfo).
C#

// 필요한 네임스페이스 (기존 포함)
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (행 하이라이트 로직 추가)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        // *** 신규: 행 하이라이트를 위한 속성 ***
        private object _selectedCellValue; // 현재 선택(포커스)된 셀의 값
        private string _selectedCellColumnFieldName; // 현재 선택(포커스)된 셀의 컬럼 필드명

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { /* ... */ } } } // CurrentItemChanged 이벤트 사용
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }

        // *** 신규: 행 하이라이트 속성 Getter/Setter ***
        public object SelectedCellValue { get => _selectedCellValue; private set => SetProperty(ref _selectedCellValue, value); }
        public string SelectedCellColumnFieldName { get => _selectedCellColumnFieldName; private set => SetProperty(ref _selectedCellColumnFieldName, value); }

        #endregion

        #region Commands (이전과 동일)
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            // ... (생성자 로직 이전과 동일) ...
            try { _context = new LockerDbContext(); } catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync()); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync()); AddNewCommand = new RelayCommand(AddNewLocker); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync()); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        // --- 데이터 로딩 메서드 (LoadAssignmentsAsync 수정됨) ---
        private async Task LoadInitialDataAsync() { await LoadMasterDataAsync(); await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null || _cts.IsCancellationRequested) return; StatusBarText = "사물함 목록 로딩 중..."; try { var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList(); if (trackedAssignments.Any()) { Debug.WriteLine($"LoadAssignmentsAsync: Detaching {trackedAssignments.Count} tracked LockerAssignment entities."); foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; } var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(_cts.Token); if (!_cts.IsCancellationRequested) { LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; } } catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); StatusBarText = "사물함 목록 로딩 취소됨."; } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { AllLockerTypes = new ObservableCollection<LockerType>(await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token)); if (_cts.IsCancellationRequested) return; AllFloors = new ObservableCollection<Floor>(await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token)); if (_cts.IsCancellationRequested) return; AllZones = new ObservableCollection<Zone>(await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token)); if (_cts.IsCancellationRequested) return; AllSubParts = new ObservableCollection<SubPart>(await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token)); if (_cts.IsCancellationRequested) return; AllAdministrators = new ObservableCollection<Administrator>(await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token)); if (!_cts.IsCancellationRequested) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; } } catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); StatusBarText = "마스터 데이터 로딩 취소됨."; } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { if (!_cts.IsCancellationRequested) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; /* 상태 변경 */ MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; /* 상태 변경 */ MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드 (이전과 동일)
        private async Task SaveChangesAsync() { if (_context == null || _cts.IsCancellationRequested) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null || _cts.IsCancellationRequested) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Helper Methods (오류 메시지 상세화)
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region Highlight Logic (신규)

        /// <summary>
        /// View(MainWindow.xaml.cs)에서 호출할 메서드.
        /// 선택된 셀 정보를 업데이트하여 RowStyle 바인딩이 갱신되도록 합니다.
        /// </summary>
        /// <param name="fieldName">포커스된 컬럼의 FieldName</param>
        /// <param name="currentItem">현재 선택된 행의 데이터 객체 (LockerAssignment)</param>
        public void UpdateHighlightInfo(string fieldName, LockerAssignment currentItem)
        {
            // 하이라이트를 적용할 콤보박스 컬럼들 목록
            var targetColumns = new List<string> { "LockerType", "Floor", "Zone", "SubPart", "Administrator" };

            if (currentItem != null && targetColumns.Contains(fieldName))
            {
                // 리플렉션을 사용하여 현재 항목에서 해당 필드의 값을 가져옵니다.
                var propertyInfo = typeof(LockerAssignment).GetProperty(fieldName);
                if (propertyInfo != null)
                {
                    SelectedCellValue = propertyInfo.GetValue(currentItem);
                    SelectedCellColumnFieldName = fieldName;
                }
                else
                {
                    ClearHighlightInfo(); // 속성을 찾지 못하면 초기화
                }
            }
            else
            {
                // 대상 컬럼이 아니거나 선택된 항목이 없으면 하이라이트 정보 초기화
                ClearHighlightInfo();
            }

            // 중요: ObservableCollection의 변경을 강제로 알려 RowStyle이 재평가되도록 함
            // (단순 속성 변경만으로는 RowStyle의 MultiBinding이 갱신되지 않을 수 있음)
            // 약간의 트릭: 컬렉션 자체를 다시 할당하거나, 임시 변경을 가했다 되돌립니다.
            // 또는 더 나은 방법: RowStyle 바인딩에 ViewModel 자체를 포함시키고 PropertyChanged("SelectedCellValue") 등을 발생시킵니다.
            // 여기서는 간단히 PropertyChanged 호출을 사용합니다. (ViewModelBase에 구현됨)
            OnPropertyChanged(nameof(SelectedCellValue));
            OnPropertyChanged(nameof(SelectedCellColumnFieldName));
            // UI 스레드에서 GridControl의 RefreshData()를 호출하는 것도 방법일 수 있습니다.
            // Application.Current.Dispatcher.Invoke(() => { /* gridControl.RefreshData(); */ });
        }

        /// <summary>
        /// 하이라이트 정보를 초기화합니다.
        /// </summary>
        private void ClearHighlightInfo()
        {
            SelectedCellValue = null;
            SelectedCellColumnFieldName = null;
        }

        #endregion

        #region IDisposable 구현 (CancellationToken 취소 추가)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    _cts?.Cancel(); // 진행 중인 비동기 작업 취소 요청
                    _cts?.Dispose();
                    _context?.Dispose(); // DbContext 해제
                    LogVM?.Dispose();    // LogViewModel 해제
                }
                disposed = true;
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. Infrastructure/HighlightRowConverter.cs (신규)

행 배경색을 조건부로 변경하는 IMultiValueConverter 구현입니다. Infrastructure 폴더에 이 파일을 추가하세요.

C#

using LockerManagementApp.Models; // LockerAssignment 모델 사용
using System;
using System.Globalization;
using System.Windows; // DependencyProperty, Visibility 사용
using System.Windows.Data; // IMultiValueConverter 사용
using System.Windows.Media; // Brush, Brushes 사용

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// 선택된 셀의 값과 현재 행의 해당 컬럼 값을 비교하여 배경색을 반환하는 MultiValueConverter 입니다.
    /// </summary>
    public class HighlightRowConverter : IMultiValueConverter
    {
        // 하이라이트 색상 (노란색)
        private static readonly Brush HighlightBrush = Brushes.Yellow;
        // 기본 배경색 (또는 테마 기본값 사용) - 여기서는 UnsetValue를 반환하여 기본값 유지
        // private static readonly Brush DefaultBrush = Brushes.Transparent;

        public object Convert(object[] values, Type targetType, object parameter, CultureInfo culture)
        {
            // values 배열에는 MultiBinding으로 전달된 값들이 순서대로 들어옵니다.
            // [0]: 현재 행의 DataContext (LockerAssignment 객체)
            // [1]: MainViewModel의 SelectedCellValue
            // [2]: MainViewModel의 SelectedCellColumnFieldName

            if (values == null || values.Length < 3 ||
                !(values[0] is LockerAssignment currentRow) || // 현재 행 데이터 확인
                values[1] == null || // 선택된 셀 값 확인
                !(values[2] is string selectedFieldName) || // 선택된 컬럼 필드명 확인
                string.IsNullOrEmpty(selectedFieldName))
            {
                // 필요한 값이 없으면 기본값 반환 (배경색 변경 없음)
                return DependencyProperty.UnsetValue; // 또는 Brushes.Transparent 등
            }

            object selectedValue = values[1];

            try
            {
                // 현재 행(currentRow)에서 선택된 컬럼(selectedFieldName)의 값을 가져옵니다.
                var propertyInfo = typeof(LockerAssignment).GetProperty(selectedFieldName);
                if (propertyInfo != null)
                {
                    object currentRowValue = propertyInfo.GetValue(currentRow);

                    // 선택된 셀 값과 현재 행의 값을 비교합니다. (null 처리 포함)
                    if (Equals(selectedValue, currentRowValue))
                    {
                        // 값이 같으면 하이라이트 색상 반환
                        return HighlightBrush;
                    }
                }
            }
            catch (Exception ex)
            {
                // 오류 발생 시 디버그 출력 (선택 사항)
                System.Diagnostics.Debug.WriteLine($"HighlightRowConverter 오류: {ex.Message}");
            }

            // 조건에 맞지 않으면 기본값 반환
            return DependencyProperty.UnsetValue;
        }

        public object[] ConvertBack(object value, Type[] targetTypes, object parameter, CultureInfo culture)
        {
            // 역변환은 필요하지 않음
            throw new NotImplementedException();
        }
    }
}
핵심 변경 사항:

MainWindow.xaml:
ThemedWindow에 FontSize="14" (또는 원하는 크기) 설정 추가.
LightBlueHeaderStyle의 HorizontalContentAlignment="Center" 확인 (이미 있어야 함).
TableView에 FocusedColumnChanged="TableView_FocusedColumnChanged" 및 CurrentItemChanged="TableView_CurrentItemChanged" 이벤트 핸들러 연결 추가.
TableView.RowStyle을 정의하고 ConditionalRowHighlightStyle 리소스를 참조하도록 설정.
ConditionalRowHighlightStyle 리소스 정의: TargetType="dxg:RowControl", Background 속성에 MultiBinding 사용 (HighlightRowConverter 및 ViewModel 속성 참조).
<dx:ThemedWindow.Resources> 안에 <infra:HighlightRowConverter x:Key="HighlightRowConverter"/> 리소스 정의 추가.
MainViewModel.cs:
SelectedCellValue (object 타입) 및 SelectedCellColumnFieldName (string 타입) 속성 추가 (SetProperty 사용).
UpdateHighlightInfo(string fieldName, LockerAssignment currentItem) 공개 메서드 추가: View의 이벤트 핸들러에서 호출되어 위 두 속성 값을 업데이트하고 OnPropertyChanged를 호출하여 바인딩 갱신 트리거.
ClearHighlightInfo() 비공개 헬퍼 메서드 추가.
Infrastructure/HighlightRowConverter.cs (신규):
IMultiValueConverter 인터페이스 구현.
Convert 메서드: 전달된 값(행 데이터, 선택된 값, 선택된 필드명)을 사용하여 현재 행의 해당 필드 값과 선택된 셀 값을 비교. 같으면 Brushes.Yellow, 다르면 DependencyProperty.UnsetValue 반환.
추가 작업:
