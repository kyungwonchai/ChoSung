말 죄송합니다. 이제 말씀하신 파일에서 데이터를 "="로 구분하여 처리하는 방식을 정확히 반영해 다시 코드를 제공하겠습니다. 파일을 읽을 때, 각 라인의 "=" 뒤에 나오는 값을 추출하고, 이를 **LogEntry**로 변환하는 방식으로 수정하겠습니다.

수정된 FileProcessor.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// FileProcessor는 지정된 폴더에서 로그 파일을 감지하고, 새로운 파일이 있을 때 LogEntry로 변환하여 처리합니다.
/// 날짜 정보를 추출하여 파일을 정렬하고, 새로 추가된 파일만 처리합니다.
/// PO_NO 별로 PO_PLAN_QTY에 맞춰 시퀀스 플래그(1, 2, 3)를 결정합니다.
/// </summary>
public class FileProcessor
{
    private readonly string _logDirectory; // 로그 파일 경로
    private Action<LogEntry> _onFileDetected; // 파일이 감지되었을 때 호출될 콜백
    private DateTime _lastProcessedFileDateTime = DateTime.MinValue; // 마지막으로 처리된 파일의 시간
    private Dictionary<string, int> _poNoToProdQtyMap = new Dictionary<string, int>(); // PO_NO별로 누적 생산 수량을 저장

    public FileProcessor(string logDirectory, Action<LogEntry> onFileDetected)
    {
        _logDirectory = logDirectory;
        _onFileDetected = onFileDetected;
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 새로운 파일이 있으면 날짜 순으로 정렬 후 처리합니다.
    /// </summary>
    public async void StartProcessing()
    {
        while (true)
        {
            // 지정된 디렉토리에서 모든 파일을 가져옵니다.
            var files = Directory.GetFiles(_logDirectory, "*.txt");

            // 파일 이름에서 날짜를 추출하고 날짜 순으로 정렬합니다.
            var sortedFiles = files
                .Where(f => TryExtractDateTimeFromFileName(f, out _))
                .OrderBy(f => ExtractDateTimeFromFileName(f))
                .ToList();

            // 새로운 파일이 있는지 확인하고 처리
            foreach (var file in sortedFiles)
            {
                DateTime fileDateTime = ExtractDateTimeFromFileName(file);

                // 새로 추가된 파일만 처리 (마지막으로 처리된 파일 이후의 파일)
                if (fileDateTime > _lastProcessedFileDateTime)
                {
                    var logEntry = ParseLogFile(file);

                    // PO_NO의 누적 생산 수량을 업데이트하고 시퀀스 플래그를 결정
                    logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

                    // 새로운 로그 엔트리를 콜백에 전달
                    _onFileDetected?.Invoke(logEntry);

                    // 마지막 처리 시간 업데이트
                    _lastProcessedFileDateTime = fileDateTime;
                }
            }

            await Task.Delay(5000); // 5초마다 폴더를 확인
        }
    }

    /// <summary>
    /// PO_NO별 누적 생산 수량을 바탕으로 시퀀스 플래그(1: 첫 파일, 2: 중간 파일, 3: 마지막 파일)를 결정합니다.
    /// </summary>
    private int DetermineSequenceFlag(LogEntry logEntry)
    {
        // PO_NO별 누적 생산 수량을 관리하는 딕셔너리에서 현재 PO_NO의 생산 수량을 가져옴
        if (!_poNoToProdQtyMap.TryGetValue(logEntry.PO_NO, out int currentProdQty))
        {
            currentProdQty = 0; // 해당 PO_NO가 처음 발견된 경우 누적 생산량은 0
        }

        // 현재 파일에서 생산된 물량을 누적 생산 수량에 더함
        int updatedProdQty = currentProdQty + logEntry.MAG_QTY;

        // 시퀀스 플래그 결정: 첫 파일, 중간 파일, 마지막 파일
        if (currentProdQty == 0)
        {
            // 처음 생산되는 파일일 경우
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 1; // 첫 파일
        }
        else if (updatedProdQty >= logEntry.PO_PLAN_QTY)
        {
            // 생산량이 계획 수량에 도달하면 마지막 파일로 간주
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 3; // 마지막 파일
        }
        else
        {
            // 중간 파일일 경우
            _poNoToProdQtyMap[logEntry.PO_NO] = updatedProdQty;
            return 2; // 중간 파일
        }
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출하여 DateTime으로 변환합니다.
    /// 파일명 형식은 "W_test_yyyyMMddHHmmss.txt" 형식으로 가정합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName); // 확장자를 제외한 파일 이름만 가져옴
        var dateTimePart = baseFileName.Split('_')[1]; // 파일명에서 날짜 부분 추출

        // "yyyyMMddHHmmss" 형식을 DateTime으로 변환
        DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out DateTime fileDateTime);
        return fileDateTime;
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출할 수 있는지 확인합니다.
    /// </summary>
    private bool TryExtractDateTimeFromFileName(string fileName, out DateTime fileDateTime)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName);
        var dateTimePart = baseFileName.Split('_')[1];

        // 날짜 형식이 올바른지 검증
        return DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out fileDateTime);
    }

    /// <summary>
    /// 로그 파일을 읽어서 LogEntry 객체로 변환합니다.
    /// 각 항목은 "="로 구분되어 있으며 "=" 뒤의 값을 읽어 처리합니다.
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);
        
        return new LogEntry
        {
            MAG_NO = ExtractValue(lines[0]), // MAG_NO
            MAG_QTY = int.Parse(ExtractValue(lines[1])), // MAG_QTY
            BASIC_MODEL = ExtractValue(lines[2]), // BASIC_MODEL
            MODEL_CODE = ExtractValue(lines[3]), // MODEL_CODE
            PO_NO = ExtractValue(lines[4]), // PO_NO
            PO_PLAN_QTY = int.Parse(ExtractValue(lines[5])), // PO_PLAN_QTY (전체 생산 계획 수량)
            PO_PROD_QTY = int.Parse(ExtractValue(lines[6])), // PO_PROD_QTY (현재까지 누적된 생산 수량)
            // SequenceFlag는 DetermineSequenceFlag 메서드를 통해 결정됨
        };
    }

    /// <summary>
    /// 파일의 각 라인에서 "=" 뒤의 값을 추출합니다.
    /// </summary>
    private string ExtractValue(string line)
    {
        var parts = line.Split('=');
        return parts.Length > 1 ? parts[1].Trim() : string.Empty;
    }
}
주요 수정 사항:
파일 내 항목 구분:

파일에서 각 항목을 = 로 구분하여, = 뒤의 값을 읽어 *