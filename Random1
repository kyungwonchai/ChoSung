알겠습니다. 이제 명령 추가는 별도의 이벤트나 코드 중간에서 실행될 수 있도록 구현하겠습니다. 외부 이벤트 또는 코드 중간에서 명령을 추가할 수 있는 방식으로 수정하고, 더 전문적이고 구조화된 코드로 제공드리겠습니다.

변경 사항:

명령 추가 방식: 명령을 외부에서 실행할 수 있도록 EnqueueCommand 함수를 그대로 사용하되, 이벤트 기반이 아니라 프로그램 내 다른 부분에서 명령을 추가할 수 있게 했습니다.
전문적인 코드 구조: 코드가 더 깔끔하게 관리되도록 리팩토링하고, 명확한 함수 분리 및 관리 기능을 강화했습니다.
1. XAML (UI 정의)
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 남아 있는 명령을 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding RemainingCommands}" HorizontalAlignment="Left" Height="300" VerticalAlignment="Top" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 보낸 명령 텍스트 -->
                        <TextBlock Text="{Binding CommandText}" Width="200"/>
                        <!-- 재시도 횟수 -->
                        <TextBlock Text=" 재시도: " Width="70"/>
                        <TextBlock Text="{Binding RetryCount}" Width="50"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 쌓인 명령의 수를 시각적으로 표시) -->
        <ProgressBar VerticalAlignment="Top" Height="300" Width="30" Orientation="Vertical" Value="{Binding Progress}" Maximum="10" HorizontalAlignment="Right" Margin="0,0,50,0"/>
    </Grid>
</Window>
2. C# ViewModel 및 모델 (CommandQueueViewModel.cs)
명령 추가를 외부에서 할 수 있도록 개선된 구조
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows.Input;
using System.ComponentModel;
using System.Data.SqlClient;
using System.Collections.Generic;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    // 명령을 저장하는 큐 (FIFO 방식)
    private Queue<Func<Task>> commandQueue = new Queue<Func<Task>>();

    // 남아 있는 명령을 표시할 ObservableCollection (리스트박스에 바인딩)
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();

    // 처리된 명령을 기록할 ObservableCollection (처리된 명령은 기록만 하고 삭제)
    public ObservableCollection<CommandItem> ProcessedCommands { get; set; } = new ObservableCollection<CommandItem>();

    // 최대 재시도 횟수
    private int maxRetryCount = 3;

    // 데이터베이스 연결 문자열
    private string connectionString = "your_connection_string_here"; 

    // INotifyPropertyChanged 이벤트를 사용해 UI 업데이트
    public event PropertyChangedEventHandler PropertyChanged;

    // 프로그레스바 상태 (큐에 남아 있는 명령의 개수를 나타냄)
    private int _progress;
    public int Progress
    {
        get => _progress;
        set { _progress = value; OnPropertyChanged(nameof(Progress)); }
    }

    // 외부에서 명령을 추가하는 함수
    public void AddCommandExternally(string commandText)
    {
        EnqueueCommand(commandText); // 명령을 내부적으로 처리
    }

    // 명령을 큐에 추가하고 리스트박스에 반영하는 함수
    private async void EnqueueCommand(string commandText)
    {
        // 남아 있는 명령 리스트에 새 명령 추가
        var newCommand = new CommandItem { CommandText = commandText };
        RemainingCommands.Add(newCommand); // 리스트박스에 추가

        // 큐에 추가
        commandQueue.Enqueue(() => ExecuteCommand(newCommand));

        // 큐에 첫 번째 명령이 추가된 경우에만 명령 처리 시작
        if (commandQueue.Count == 1)
        {
            await ProcessCommandQueue();
        }

        // 프로그레스바 업데이트 (큐에 남은 명령 개수 반영)
        UpdateProgress();
    }

    // 큐에 쌓인 명령을 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        // 큐에 명령이 남아 있는 동안 계속 처리
        while (commandQueue.Count > 0)
        {
            // 큐에서 명령을 꺼내어 실행
            var command = commandQueue.Dequeue();
            await command();

            // 프로그레스바 업데이트 (남은 명령 개수 반영)
            UpdateProgress();
        }
    }

    // 프로그레스바 상태 업데이트 (큐에 남아 있는 명령의 개수 반영)
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 큐에 남은 명령의 수를 UI에 반영
    }

    // PLC에 명령을 전송하고 응답을 처리하는 함수
    private async Task ExecuteCommand(CommandItem command)
    {
        int retryCount = 0; // 재시도 횟수 카운트
        bool success = false; // 명령 성공 여부
        string response = string.Empty; // PLC에서 받은 응답
        Stopwatch stopwatch = new Stopwatch(); // 응답 시간을 측정하기 위한 스톱워치

        // 재시도 횟수가 남아 있고 아직 성공하지 못한 경우 반복
        while (retryCount < maxRetryCount && !success)
        {
            stopwatch.Restart(); // 응답 시간 측정 시작
            response = await SendCommandToPLC(command.CommandText); // PLC로 명령 전송 및 응답 대기
            stopwatch.Stop(); // 응답 시간 측정 완료

            success = ValidateResponse(response); // 응답이 올바른지 확인

            // 응답이 실패하면 1초 대기 후 재시도
            if (!success)
            {
                retryCount++;
                await Task.Delay(1000); // 1초 대기 후 재시도
            }
        }

        // 명령이 완료되었으므로 리스트에서 제거하고, 처리된 명령에 추가
        RemainingCommands.Remove(command);
        command.ResponseText = response;
        command.Result = success ? 1 : 0;
        command.RetryCount = retryCount;
        command.ResponseTime = stopwatch.ElapsedMilliseconds;

        // 처리된 명령 리스트에 추가 (기록만 하고 화면에 반영하지 않을 수도 있음)
        ProcessedCommands.Add(command);

        // DB에 명령, 응답, 성공 여부, 재시도 횟수, 응답 시간 기록
        await LogCommandToDatabase(command.CommandText, response, success ? 1 : 0, retryCount, stopwatch.ElapsedMilliseconds);
    }

    // PLC에 명령을 전송하는 가상 함수 (실제 PLC와 통신하는 로직 필요)
    private async Task<string> SendCommandToPLC(string commandText)
    {
        await Task.Delay(500); // 실제 PLC 통신 시간을 가정 (500ms 대기)
        return "OK"; // 가상 응답 (실제 PLC 응답을 처리하는 코드로 변경 필요)
    }

    // 응답을 검증하는 함수 (응답이 올바른지 확인)
    private bool ValidateResponse(string response)
    {
        return response == "OK"; // 응답이 "OK"이면 성공으로 간주 (필요 시 수정 가능)
    }

    // DB에 명령과 응답을 기록하는 함수
    private async Task LogCommandToDatabase(string commandText, string response, int result, int retryCount, long responseTime)
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync(); // 비동기로 DB 연결
            using (SqlCommand command = new SqlCommand(
                "INSERT INTO CommandLog (CommandText, ResponseText, Result, RetryCount, ResponseTime) " +
                "VALUES (@CommandText, @ResponseText, @Result, @RetryCount, @ResponseTime)", connection))
            {
                // SQL 파라미터 설정 (SQL 인젝션 방지)
                command.Parameters.AddWithValue("@CommandText", commandText);
                command.Parameters.AddWithValue("@ResponseText", response);
                command.Parameters.AddWithValue("@Result", result);
                command.Parameters.AddWithValue("@RetryCount", retryCount);
                command.Parameters.AddWithValue("@ResponseTime", responseTime);

                await command.ExecuteNonQueryAsync(); // SQL 명령 실행
            }
        }
    }

    // UI 업데이트를 위한 이벤트 트리거 함수
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

// UI에 표시할 명령 기록 항목 클래스
public class CommandItem
{
    public string CommandText { get; set; } // 보낸 명령어
    public string ResponseText { get; set; } // 받은 응답
    public int Result { get; set; } // 성공 여부 (1: 성공, 0: 실패)
    public int RetryCount { get; set; } // 재시도 횟수
    public long ResponseTime { get; set; } // 응답 시간 (밀리초)
}
3. MainWindow.xaml.cs
이 코드는 외부에서 명령을 추가하는 구조로 만들어졌습니다. 명령 추가를 사용자가 특정 이벤트나 프로그램 흐름 중간에서 호출하여 실행할 수 있습니다.

csharp
코드 복사
using System.Windows;

namespace CommandQueueApp
{
    public partial class MainWindow : Window
    {
        private CommandQueueViewModel viewModel; // ViewModel 선언

        public MainWindow()
        {
            InitializeComponent();
            // ViewModel 인스턴스를 생성하고 DataContext로 설정
            viewModel = new CommandQueueViewModel();
            DataContext = viewModel; // MVVM 패턴에 따라 ViewModel과 View 바인딩
        }

        // 명령 추가를 외부 이벤트 또는 다른 함수에서 호출
        public void ExternalEventTriggerCommand()
        {
            // 외부에서 명령을 추가할 때 사용하는 함수
            viewModel.AddCommandExternally("READ 520-540");
        }
    }
}
4. SQL 테이블 생성 스크립트
sql
코드 복사
CREATE TABLE CommandLog (
    Id INT PRIMARY KEY IDENTITY(1,1), -- 자동 증가 ID
    CommandText NVARCHAR(255),        -- 보낸 명령어
    ResponseText NVARCHAR(255),       -- 받은 응답
    Result INT,                       -- 결과 (1: 성공, 0: 실패)
    RetryCount INT,                   -- 재시도 횟수
    ResponseTime INT,                 -- 응답 시간 (밀리초)
    Timestamp DATETIME DEFAULT GETDATE() -- 명령 발생 시간 (기본값: 현재 시간)
);
설명
명령 추가 방식:

AddCommandExternally 메서드를 통해 외부에서 명령을 추가할 수 있습니다. 이 함수는 ViewModel 내부에서 명령을 큐에 추가하고 처리합니다.
명령 처리:

큐에 명령이 추가되면, EnqueueCommand가 호출되어 FIFO 방식으로 명령이 순차적으로 처리됩니다.
프로그램의 어느 부분에서든 명령 추가 가능:

ExternalEventTriggerCommand 메서드를 통해 명령 추가가 가능합니다. 이 메서드는 명령을 외부 이벤트나 코드 중간에서 추가할 수 있도록 설계되었습니다.
XAML 및 UI 업데이트:

리스트박스는 RemainingCommands를 통해 처리되지 않은 명령만 표시합니다.
프로그레스바는 남은 명령 개수를 실시간으로 업데이트하여 시각적 상태를 표시합니다.
이 코드 구조는 명령 추가를 외부에서 자유롭게 할 수 있게 하고, 남은 명령만 UI에 표시하며, 큐에서 명령을 순차적으로 처리합니다.






