일을 읽기/쓰기 공유 모드로 열기 위해서는 FileStream을 열 때 FileShare.ReadWrite를 지정해야 합니다. 이를 통해 파일을 다른 프로세스가 읽거나 쓸 수 있도록 공유하면서 동시에 해당 파일을 열 수 있습니다.

아래는 파일을 읽기/쓰기 공유 모드로 여는 방법을 수정한 코드입니다.

수정된 ViewModel 코드 (파일을 읽기/쓰기 공유 모드로 열기)
csharp
코드 복사
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.ComponentModel;
using System.Security.Cryptography;
using System.Text;
using System.Windows;

namespace LogFileWatcher.ViewModels
{
    public class FileWatcherViewModel : INotifyPropertyChanged
    {
        private FileSystemWatcher _watcher;
        private readonly string _folderPath = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 있는 폴더 경로
        private readonly string _positionFolderPath = @"C:\G-MES2.0\GUMI_WEB\log_positions"; // 마지막 줄 위치를 저장할 폴더
        private readonly string[] _keywords = { "FST", "FNL", "PLAN" };  // 감지할 키워드 목록
        private Dictionary<string, int> _fileLinePositions = new Dictionary<string, int>();  // 파일별 마지막 읽은 줄 저장
        private HashSet<string> _processedLineHashes = new HashSet<string>(); // 중복 방지용 해시값 저장

        public event PropertyChangedEventHandler PropertyChanged;

        public FileWatcherViewModel()
        {
            LoadLastPositions();  // 프로그램 시작 시 마지막 읽은 위치 로드
            SetupWatcher();
            Application.Current.Exit += OnExit;  // 프로그램 종료 시 이벤트 처리
        }

        // 마지막으로 읽은 줄 번호를 파일로부터 로드하는 메서드
        private void LoadLastPositions()
        {
            if (!Directory.Exists(_positionFolderPath))
            {
                Directory.CreateDirectory(_positionFolderPath);
            }

            var positionFiles = Directory.GetFiles(_positionFolderPath, "*.txt");
            foreach (var positionFile in positionFiles)
            {
                string fileName = Path.GetFileNameWithoutExtension(positionFile);
                if (int.TryParse(File.ReadAllText(positionFile), out int lastLine))
                {
                    _fileLinePositions[fileName] = lastLine;
                }
            }
        }

        // 마지막으로 읽은 줄 번호를 저장하는 메서드
        private void SaveLastPosition(string fileName, int lastLine)
        {
            string positionFilePath = Path.Combine(_positionFolderPath, fileName + ".txt");
            File.WriteAllText(positionFilePath, lastLine.ToString());
        }

        // FileSystemWatcher 설정
        private void SetupWatcher()
        {
            _watcher = new FileSystemWatcher
            {
                Path = _folderPath,  // 감시할 폴더 경로 설정
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,  // 파일 이름과 파일 변경 시 감지
                Filter = "*.log",  // .log 확장자 파일만 감지
                EnableRaisingEvents = true,  // 이벤트 활성화
                IncludeSubdirectories = false  // 하위 폴더는 감지하지 않음
            };

            _watcher.Created += OnChanged;
            _watcher.Changed += OnChanged;
        }

        // 파일이 생성되거나 변경되었을 때 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            string fileName = Path.GetFileName(e.FullPath);
            string pattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_\d{2}\.log$";

            if (Regex.IsMatch(fileName, pattern))
            {
                if (!_fileLinePositions.ContainsKey(fileName))
                {
                    _fileLinePositions[fileName] = 0;
                }

                CheckFileForKeywords(e.FullPath, fileName);
            }
        }

        // 변경된 파일의 내용을 읽고 특정 키워드(FST, FNL, PLAN)가 있는지 확인하는 메서드
        private void CheckFileForKeywords(string filePath, string fileName)
        {
            try
            {
                int lastReadLine = _fileLinePositions[fileName];  // 마지막 읽은 줄 번호
                int currentLineNumber = 0;

                // 파일을 읽기/쓰기 공유 모드로 열기
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (StreamReader reader = new StreamReader(fs))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        currentLineNumber++;

                        if (currentLineNumber > lastReadLine)
                        {
                            // 줄을 해시화하여 중복 감지
                            string lineHash = ComputeHash(line);
                            if (!_processedLineHashes.Contains(lineHash))
                            {
                                foreach (var keyword in _keywords)
                                {
                                    if (line.Contains(keyword))
                                    {
                                        Console.WriteLine($"[{fileName}] 특정 문구 발견: {line}");
                                    }
                                }

                                // 해시값 저장 (중복 방지)
                                _processedLineHashes.Add(lineHash);
                            }

                            _fileLinePositions[fileName] = currentLineNumber;
                        }
                    }
                }

                SaveLastPosition(fileName, _fileLinePositions[fileName]);
            }
            catch (IOException ex)
            {
                Console.WriteLine("파일을 읽는 도중 오류가 발생했습니다: " + ex.Message);
            }
        }

        // 줄을 해시로 변환하여 중복을 감지하는 메서드
        private string ComputeHash(string input)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] inputBytes = Encoding.UTF8.GetBytes(input);
                byte[] hashBytes = sha256.ComputeHash(inputBytes);
                return Convert.ToBase64String(hashBytes);
            }
        }

        // 프로그램 종료 시 마지막 상태를 저장하는 메서드
        private void OnExit(object sender, ExitEventArgs e)
        {
            foreach (var kvp in _fileLinePositions)
            {
                SaveLastPosition(kvp.Key, kvp.Value);
            }
        }

        // INotifyPropertyChanged 구현
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 수정 사항:
파일 읽기/쓰기 공유 모드:

FileStream을 열 때 FileShare.ReadWrite 옵션을 추가했습니다. 이를 통해 다른 프로세스가 동시에 파일을 읽거나 쓸 수 있습니다.
FileStream 객체를 StreamReader와 함께 사용하여 파일을 읽습니다.
파일 읽기 예외 처리:

파일을 읽을 때 IOException을 처리하여 파일이 잠겨 있거나 읽기 중 오류가 발생할 경우 로그를 출력합니다.
동작 방식:
파일 감시: FileSystemWatcher가 파일을 감시하면서 변경 사항을 감지합니다.
공유 모드로 파일 읽기: 파일을 읽기/쓰기 공유 모드로 열고, 다른 프로세스가 동시에 해당 파일을 열거나 쓸 수 있습니다.
중복 방지: 각 줄의 해시값을 계산하여 중복된 줄을 처리하지 않고, 새로운 줄만 처리합니다.
이 코드로 파일을 읽기/쓰기 공유 모드로 열 수 있으며,