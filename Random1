이전에 FunctionTasks.Add로 비동기 함수들을 추가하는 방식으로 작업을 처리하셨다면, 그 구조에 맞춰 다시 수정된 코드와 설명을 제공하겠습니다. 또한, 도형 기반 UI와 연동하여 각 도형이 비동기 함수를 담당하고, 클릭 시 함수가 실행되도록 구현해 드리겠습니다.

요구 사항 요약:
FunctionTasks.Add 방식으로 비동기 함수를 추가하는 구조 유지.
각 도형이 비동기 함수와 연동되어 있고, 도형을 클릭하면 해당 함수만 실행.
Ctrl 키가 눌린 상태에서는 개별 함수만 실행하고, 그렇지 않으면 **전체 작업(시퀀스)**이 순차적으로 실행됨.
함수 실행 완료 시 도형 색상 변경(녹색 등), 그리고 각 함수가 끝나면 다음 함수가 실행.
1. FunctionItem Class (도형과 함수 연동)
csharp
코드 복사
public class FunctionItem
{
    public string Name { get; set; }  // 함수 이름 (Task A, Task B 등)
    public Brush Status { get; set; } // 도형 상태 (Gray, Green 등)
    public Func<Task> ExecuteFunction { get; set; } // 실제로 실행될 비동기 함수
}
2. TaskModel Class (비동기 함수 추가 및 도형 연동)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 각 도형에 연결된 비동기 함수 리스트
    public ObservableCollection<FunctionItem> FunctionItems { get; set; }

    public ICommand FunctionClickCommand { get; }

    // 기본 생성자
    public TaskModel(string magNo, string poNo)
    {
        MAG_NO = magNo;
        PO_NO = poNo;

        // FunctionItems에 비동기 함수 추가
        FunctionItems = new ObservableCollection<FunctionItem>
        {
            new FunctionItem { Name = "Task A", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskA },
            new FunctionItem { Name = "Task B", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskB },
            new FunctionItem { Name = "Task C", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskC }
        };

        // 도형 클릭 명령어
        FunctionClickCommand = new RelayCommand<FunctionItem>(ExecuteFunctionClick);
    }

    /// <summary>
    /// 도형 클릭 시 실행되는 함수
    /// Ctrl 키를 누른 상태에서 클릭되면 해당 함수만 실행
    /// </summary>
    private void ExecuteFunctionClick(FunctionItem function)
    {
        // Ctrl 키가 눌려 있는지 확인
        if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
        {
            ExecuteSpecificFunction(function);  // 특정 함수만 실행
        }
        else
        {
            StartTaskSequence();  // 전체 시퀀스를 순차적으로 실행
        }
    }

    /// <summary>
    /// 특정 함수를 실행 (Ctrl 클릭 시)
    /// </summary>
    private async void ExecuteSpecificFunction(FunctionItem function)
    {
        await function.ExecuteFunction();  // 비동기 함수 실행
        Application.Current.Dispatcher.Invoke(() =>
        {
            function.Status = Brushes.Green;  // 완료 후 도형 색상 변경
        });
    }

    /// <summary>
    /// 전체 작업 시퀀스를 순차적으로 실행
    /// </summary>
    private async void StartTaskSequence()
    {
        foreach (var function in FunctionItems)
        {
            await function.ExecuteFunction();  // 비동기 함수 실행
            Application.Current.Dispatcher.Invoke(() =>
            {
                function.Status = Brushes.Green;  // 완료 후 도형 색상 변경
            });
        }
    }

    // 비동기 함수 (1초 대기 후 완료 처리)
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 비동기 작업 실행
    }

    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);  // 비동기 작업 실행
    }

    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);  // 비동기 작업 실행
    }
}
설명:
FunctionItems: 각 도형과 비동기 함수가 연결된 리스트입니다. 각 도형은 FunctionItem에 해당하는 비동기 함수를 담당하며, 도형이 클릭되면 그 함수가 실행됩니다.
ExecuteFunctionClick: 도형을 클릭하면 이 함수가 실행되며, Ctrl 키가 눌린 경우 해당 함수만 실행, 그렇지 않은 경우 전체 작업이 실행됩니다.
ExecuteSpecificFunction: 특정 함수만 실행할 때 사용하는 함수로, 도형 색상이 녹색으로 변경됩니다.
StartTaskSequence: 전체 작업을 순차적으로 실행하는 함수입니다.
3. MainViewModel Class (작업 추가 및 데이터 바인딩)
csharp
코드 복사
using System.Collections.ObjectModel;

public class MainViewModel : ViewModelBase
{
    // 작업 목록 (TaskModel) 바인딩
    public ObservableCollection<TaskModel> TaskList { get; set; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>
        {
            new TaskModel("MAG001", "PO12345"),
            new TaskModel("MAG002", "PO67890")
        };
    }
}
설명:
TaskList는 각 작업(PO_NO, MAG_NO)을 관리하는 리스트로, 각 작업에는 FunctionItems가 연결되어 있습니다.
이 TaskList는 **UI (DataGrid)**에 바인딩되어 각 작업의 정보를 표시합니다.
4. XAML (UI - 도형 기반 함수 실행)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Task Queue Example" Height="400" Width="600">
    <Grid>
        <!-- DataGrid to display TaskModels -->
        <DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO Column -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                
                <!-- PO_NO Column -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*" />
                
                <!-- Functions Column with Ellipses -->
                <DataGridTemplateColumn Header="Functions">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionItems}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <!-- 도형(함수) -->
                                        <Ellipse Width="20" Height="20" Fill="{Binding Status}" 
                                                 Stroke="Black" StrokeThickness="1">
                                            <!-- 클릭 시 함수 실행 -->
                                            <Ellipse.InputBindings>
                                                <MouseBinding Command="{Binding DataContext.FunctionClickCommand, 
                                                                        RelativeSource={RelativeSource AncestorType=DataGrid}}" 
                                                              CommandParameter="{Binding}" 
                                                              MouseAction="LeftClick"/>
                                            </Ellipse.InputBindings>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
DataGrid: 각 TaskModel을 표시하는 UI입니다. MAG_NO와 PO_NO는 작업의 정보를 표시하며, FunctionItems는 도형으로 나타납니다.
Ellipse: 각 도형은 하나의 FunctionItem과 연결되어 있으며, 클릭하면 그 도형에 연결된 비동기 함수가 실행됩니다.
MouseBinding: 도형을 클릭하면 FunctionClickCommand가 실행되며, Ctrl 키 여부에 따라 특정 함수만 실행하거나 전체 작업을 순차적으로 실행합니다.
최종 요약:
FunctionItems에 비동기 함수를 추가하고, 각 도형이 해당 함수를 담당합니다.
Ctrl 키를 누른 상태에서 도형을 클릭하면 해당 비동기 함수만 실행되며, 그렇지 않으면 전체 시퀀스가 실행됩니다.
각 비동기 함수가 완료되면 도형의 색상이 녹색으로 변경됩니다.
이 방식으로 구현하면, 도형 기반으로 비동기 함수를 실행하고, 개별 실행과 전체 실행을 동시에 관리할 수 있습니다. 추가적인 요청이 있거나 더 복잡한 기능이 필요하면 언제든지 말씀해 주세요!