using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 실행된 함수가 몇 초 동안 실행되었는지 경과 시간을 표시합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    public ObservableCollection<string> FunctionNames { get; set; }

    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    private Stopwatch _stopwatch;
    private TaskQueue _taskQueue;
    public string Status { get; set; }
    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }

    public Action<TaskModel> StartNextTask { get; set; }

    private bool _isPaused = false;  // 작업이 일시정지되었는지 여부

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending"; // 기본 상태는 대기
        ProgressText = "Pending"; // 진행 상태 초기화

        _stopwatch = new Stopwatch(); // Stopwatch 초기화

        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);

        InitializeFunctionColors(); // 도형 색상 초기화
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        if (!_isPaused) // 일시정지 상태가 아닌 경우에만 작업 시작
        {
            Status = "Running";
            ProgressText = "Running...";
            _stopwatch.Restart();

            _taskQueue.EnqueueTask(ExecuteTaskSequence);
        }
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행합니다.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        switch (SequenceFlag)
        {
            case 1:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskC);
                break;
            case 2:
                await ExecuteTaskWithColor(0, ExecuteTaskC);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskD);
                break;
            case 3:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskE);
                break;
        }

        Status = "Completed";
        ProgressText = $"Completed in {_stopwatch.Elapsed.Seconds} seconds";
        StartNextTask?.Invoke(this);
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// 작업 완료 시 경과 시간을 갱신합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        if (!_isPaused)  // 일시정지 상태가 아니어야 실행
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[index] = Brushes.SkyBlue; // 진행 중 색상
                OnPropertyChanged(nameof(FunctionStatusColors));
            });

            await task(); // 비동기 작업 실행

            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[index] = Brushes.Green; // 완료 색상
                ProgressText = $"Running... ({_stopwatch.Elapsed.Seconds} seconds elapsed)";
                OnPropertyChanged(nameof(FunctionStatusColors));
            });
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// 현재 실행 중인 작업을 멈추고, 그 이후 작업은 실행되지 않습니다.
    /// </summary>
    private void PauseTask()
    {
        _isPaused = true; // 일시정지 상태로 설정
        _taskQueue.Pause(); // 작업 큐 일시정지
        ProgressText = "Paused";
    }

    /// <summary>
    /// 선택된 행부터 작업을 재개합니다.
    /// 재개 시 첫 번째 함수부터 다시 시작됩니다.
    /// </summary>
    private void ResumeTask()
    {
        _isPaused = false; // 일시정지 해제
        ResetTaskStatus(); // 첫 함수부터 재개

        _taskQueue.Resume(); // 작업 큐 재개
        StartTask(); // 첫 함수부터 다시 시작
        ProgressText = "Resumed";
    }

    /// <summary>
    /// 작업 상태를 대기 상태로 초기화하고, 모든 도형을 회색으로 설정.
    /// </summary>
    private void ResetTaskStatus()
    {
        Status = "Pending";
        ProgressText = "Pending"; // 상태 초기화
        _stopwatch.Reset(); // Stopwatch 초기화

        // 모든 도형 색상 초기화
        for (int i = 0; i < FunctionStatusColors.Count; i++)
        {
            FunctionStatusColors[i] = Brushes.Gray; // 대기 상태로 회색 설정
        }
        OnPropertyChanged(nameof(FunctionStatusColors));
    }

    /// <summary>
    /// 도형 색상을 초기화합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        int functionCount = 3; // 기본 함수 개수 3개

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 회색으로 설정
        }

        // 함수 이름 설정
        switch (SequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                break;
            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                break;
            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                break;
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task A Completed in {_stopwatch.Elapsed.Seconds} seconds";
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task B Completed in {_stopwatch.Elapsed.Seconds}";
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task C Completed in {_stopwatch.Elapsed.Seconds}";
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task D Completed in {_stopwatch.Elapsed.Seconds}";
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = $"Task E Completed in {_stopwatch.Elapsed.Seconds}";
    }
}
