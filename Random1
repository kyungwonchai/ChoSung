. 이제 너가 원하는 대로 외부 이벤트 방식이 아니라, 내부 함수로만 처리하게 만들겠다.

✅ 목표 정리
PLC와 통신 규칙 절대 변경하지 않음. (REQ: 같은 거 안 붙임)

OP_CLEAR 감지는 내부 함수로 처리 (이벤트 방식 X).

비동기 구조 유지하면서 응답과 OP_CLEAR를 정확히 구분.

내부에서만 사용할 수 있도록 완전히 통합된 코드.

🔥 완벽한 코드 (내부 함수로 처리 + 상세 주석 추가)
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // 서버와 연결을 담당하는 TcpClient 객체
    private NetworkStream _stream; // 데이터를 주고받기 위한 네트워크 스트림
    private byte[] _buffer = new byte[1024]; // 수신 데이터를 저장하는 버퍼 (1KB 크기)
    private bool _isConnected = false; // 서버와의 연결 상태를 확인하는 플래그

    // 요청 ID와 응답 TaskCompletionSource를 매핑하기 위한 딕셔너리
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    /// <summary>
    /// 서버에 연결하고 수신 루프를 시작한다.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient(); // TcpClient 객체 초기화
        await _client.ConnectAsync(ip, port); // 서버와 비동기로 연결
        _stream = _client.GetStream(); // 연결된 서버로부터 네트워크 스트림을 가져옴
        _isConnected = true; // 연결 성공 플래그 설정

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // 항상 돌아가는 수신 루프를 비동기로 실행 (Task.Run으로 백그라운드에서 실행)
        _ = Task.Run(ReceiveLoopAsync); 
    }

    /// <summary>
    /// 서버로 메시지를 보내고 응답을 기다린다. (PLC 규칙 유지)
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected)
        {
            return "[ERROR] Not connected."; // 연결되지 않은 경우 에러 반환
        }

        // 1. 메시지를 STX (\x02)와 ETX (\x03)로 감싼다.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        // 2. 응답을 기다리기 위한 TaskCompletionSource를 생성
        var tcs = new TaskCompletionSource<string>();

        // 3. 요청 ID 생성 (PLC 규칙과 상관없이 내부적으로만 사용)
        string requestId = Guid.NewGuid().ToString("N");
        _responseTasks.TryAdd(requestId, tcs);

        // 4. 서버로 메시지를 비동기로 전송
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // 5. 응답을 기다림 (비동기 방식)
        string response = await tcs.Task;

        // 6. 응답 처리 완료 후 딕셔너리에서 제거
        _responseTasks.TryRemove(requestId, out _);

        return response;
    }

    /// <summary>
    /// 항상 돌아가는 수신 루프. 모든 메시지를 감지하고 처리한다.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // 1. 서버로부터 데이터를 비동기로 읽음
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 2. 받은 데이터를 문자열로 변환하고 STX, ETX 제거
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                // 3. OP_CLEAR 신호 감지 (내부 함수로 처리)
                if (received == "OP_CLEAR")
                {
                    HandleOpClear(); // OP_CLEAR 발생 시 내부 함수 호출
                    Console.WriteLine("[EVENT] OP_CLEAR processed by internal function.");
                }
                else
                {
                    // 4. 일반적인 응답 처리 (TaskCompletionSource로 처리)
                    foreach (var key in _responseTasks.Keys)
                    {
                        if (_responseTasks.TryRemove(key, out var tcs))
                        {
                            tcs.SetResult(received); // 응답을 비동기로 반환
                            break; // 응답 처리가 완료되면 루프 종료
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// OP_CLEAR 메시지를 감지했을 때 호출되는 내부 함수.
    /// </summary>
    private void HandleOpClear()
    {
        // OP_CLEAR 처리 로직 작성 (내부에서만 사용됨)
        Console.WriteLine("[INFO] 내부 함수에서 OP_CLEAR 처리 완료.");
        // 예: 초기화 작업, 로그 기록 등 추가 가능
    }

    /// <summary>
    /// 서버 연결을 해제한다.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false; // 연결 상태를 false로 설정
        _stream?.Close(); // 스트림을 닫음
        _client?.Close(); // TCP 클라이언트를 닫음
        Console.WriteLine("[INFO] Disconnected.");
    }
}
📌 핵심 변경 사항
이벤트 방식 제거:

OnOpClearReceived 이벤트 대신 HandleOpClear() 함수로 직접 처리.

외부에서 등록할 필요 없이 내부 함수로만 사용.

내부 함수로 처리:

OP_CLEAR 신호를 받으면 HandleOpClear() 함수가 자동 호출.

응답 처리 방식과는 완전히 분리되어 안전하게 작동.

💡 사용 예제 (Program.cs)
csharp
코드 복사
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        var client = new ExpertSocketClient();

        await client.ConnectAsync("10.22.22.22", 2400);

        var response1 = await client.SendAndReceiveAsync("STATUS_CHECK");
        Console.WriteLine($"[MAIN] Response1: {response1}");

        var response2 = await client.SendAndReceiveAsync("RESET");
        Console.WriteLine($"[MAIN] Response2: {response2}");

        Console.WriteLine("Press Enter to exit...");
        Console.ReadLine();

        client.Disconnect();
    }
}
이제 진짜로 내부 함수로 OP_CLEAR를 처리하도록 만들었어.
모든 메시지는 ReceiveLoopAsync()에서 받아서 분기 처리하고, OP_CLEAR는 HandleOpClear()에서 처리하도록 완벽하게 설정했어.