C++ vector 자료형 마스터하기
1. vector 개요
vector는 C++ 표준 라이브러리(STL, Standard Template Library)에서 제공하는 동적 배열 컨테이너입니다.

std::vector<T> 형태로 사용되며, #include <vector> 헤더를 포함해야 합니다.
배열과 달리 크기가 자동 조정되며, 요소 추가/삭제 시 자동으로 메모리를 관리합니다.
vector는 내부적으로 동적 메모리 할당(Heap)을 사용하여 요소를 저장합니다.
연속적인 메모리 블록을 사용하므로 **빠른 랜덤 액세스(O(1))**가 가능합니다.
2. vector의 주요 특징
동적 크기 조정: 원소를 추가할 때 자동으로 크기가 조정됨.
연속적인 메모리 블록: 배열과 같이 메모리에 연속적으로 배치됨.
빠른 접근 속도: operator[]와 at()을 사용하여 O(1) 시간에 접근 가능.
자동 메모리 관리: push_back() 등으로 추가하면 자동으로 메모리 재할당됨.
유연한 크기 조정: resize()로 크기 변경 가능.
삽입 및 삭제 연산 지원: insert(), erase(), clear() 제공.
반복자(iterator) 지원: 범위 기반 for 문 및 begin(), end() 사용 가능.
메모리 재할당: 내부적으로 메모리를 추가할 때 기존 메모리보다 큰 새 블록을 할당하고 데이터를 복사하는 방식.
3. vector 선언 및 초기화
cpp
코드 복사
#include <iostream>
#include <vector>

int main() {
    // 기본 선언
    std::vector<int> v1;  // 비어 있는 벡터
    std::vector<int> v2(5);  // 크기 5, 기본값(0)으로 초기화
    std::vector<int> v3(5, 100);  // 크기 5, 모든 원소를 100으로 초기화
    std::vector<int> v4 = {1, 2, 3, 4, 5};  // 초기값 리스트 사용

    // 출력
    for (int i : v4) std::cout << i << " ";
}
출력:

코드 복사
1 2 3 4 5
4. 요소 접근 방법
cpp
코드 복사
std::vector<int> v = {10, 20, 30};

// 인덱스를 통한 접근
std::cout << v[1] << std::endl;  // 20 (O(1) 접근)
std::cout << v.at(1) << std::endl;  // 20 (O(1), 예외 처리 포함)

// 반복자를 통한 접근
std::vector<int>::iterator it = v.begin();
std::cout << *it << std::endl;  // 10

// 범위 기반 for 문 사용
for (int num : v) {
    std::cout << num << " ";  // 10 20 30
}
주의: v[1]은 예외 처리를 하지 않지만, v.at(1)은 범위를 벗어나면 std::out_of_range 예외 발생.

5. 요소 추가 및 삭제
cpp
코드 복사
std::vector<int> v;

// 요소 추가
v.push_back(1);  // {1}
v.push_back(2);  // {1, 2}
v.push_back(3);  // {1, 2, 3}

// 요소 삭제
v.pop_back();  // {1, 2} (마지막 요소 제거)

// 특정 위치 삽입
v.insert(v.begin(), 100);  // {100, 1, 2}

// 특정 위치 삭제
v.erase(v.begin());  // {1, 2}

// 전체 삭제
v.clear();  // 빈 벡터가 됨

// 크기 확인
std::cout << "Size: " << v.size() << std::endl;
출력:

makefile
코드 복사
Size: 0
6. 벡터 크기 관련 함수
cpp
코드 복사
std::vector<int> v = {1, 2, 3, 4, 5};

std::cout << "Size: " << v.size() << std::endl;     // 현재 크기
std::cout << "Capacity: " << v.capacity() << std::endl;  // 할당된 메모리 용량
std::cout << "Max Size: " << v.max_size() << std::endl;  // 최대 저장 가능 개수

v.resize(10, 100);  // 크기 10으로 확장, 부족한 부분을 100으로 채움
std::cout << "Size after resize: " << v.size() << std::endl;
출력:

yaml
코드 복사
Size: 5
Capacity: 5
Max Size: (매우 큰 값)
Size after resize: 10
7. vector의 메모리 관리 (reserve()와 shrink_to_fit())
cpp
코드 복사
std::vector<int> v;
v.reserve(100);  // 미리 메모리 공간 100개 확보 (성능 최적화)

// 필요 없는 메모리 반환
v.shrink_to_fit();
reserve(n): 용량을 n으로 설정 (실제 크기는 변하지 않음)
shrink_to_fit(): 실제 크기에 맞춰 메모리 해제 (강제적이지 않음)
8. 반복자 사용 (iterator)
cpp
코드 복사
std::vector<int> v = {10, 20, 30, 40, 50};

// 정방향 순회
for (auto it = v.begin(); it != v.end(); ++it) {
    std::cout << *it << " ";
}

// 역방향 순회
for (auto it = v.rbegin(); it != v.rend(); ++it) {
    std::cout << *it << " ";
}
출력:

코드 복사
10 20 30 40 50
50 40 30 20 10
9. 벡터의 정렬 및 탐색 (sort(), find())
cpp
코드 복사
#include <algorithm>  // sort, find 필요
std::vector<int> v = {5, 3, 8, 1, 9};

// 정렬 (오름차순)
std::sort(v.begin(), v.end());  // {1, 3, 5, 8, 9}

// 탐색
if (std::find(v.begin(), v.end(), 3) != v.end()) {
    std::cout << "3 Found!" << std::endl;
}
출력:

pgsql
코드 복사
3 Found!
10. vector의 내부 동작 및 성능 고려 사항
push_back()은 O(1) 평균 시간이지만, 용량을 초과할 경우 O(N) 재할당 발생.
**insert(), erase()**는 중간 요소 삽입/삭제 시 O(N) 시간 소요.
clear()는 O(N) (모든 요소 제거)
반복자 무효화 문제: erase()나 push_back() 후 기존 반복자는 사용할 수 없음.
11. vector vs array vs list
특징	vector	array	list (연결 리스트)
메모리 구조	연속적	연속적	비연속적 (노드)
접근 속도	O(1)	O(1)	O(N)
크기 변경	가능	불가능	가능
삽입/삭제 속도	O(N)	O(N)	O(1) (중간 삽입)
12. 정리
vector는 동적 배열로 크기 조절 가능.
빠른 랜덤 액세스 O(1), 하지만 삽입/삭제 O(N).
push_back() 최적화: reserve()를 활용하여 성능 개선 가능.