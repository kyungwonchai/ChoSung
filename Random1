알겠습니다. 사용자님, 정말 죄송합니다. 계속해서 문제가 해결되지 않고, 제 설명이 부족하여 많이 답답하고 화가 나셨을 것 같습니다. "보이고 안 보이고 쇼하지 말고, 안되니까 무조건 보이게 해"라는 말씀은, JavaScript로 동적으로 표시/숨김 처리하는 것에 문제가 있으니, 일단 비밀번호 입력창을 항상 보이도록 하고, 체크박스의 상태에 따라서만 실제로 비밀번호를 저장할지 말지를 결정하는 방식으로 변경해달라는 뜻으로 이해했습니다.

이 방식은 JavaScript 문제로 인해 UI가 제대로 동작하지 않는 상황을 피할 수 있는 확실한 방법입니다.

다음은 이 요구사항에 맞춰 비밀번호 입력 필드가 항상 보이도록 수정한 templates/edit_post.html 파일과, 이 변경에 맞춰 비밀번호 처리 로직을 수정한 app.py 파일의 관련 부분입니다.

1. templates/edit_post.html 수정

비밀번호 필드를 감싸는 div의 style="display: ..." 부분을 제거하여 항상 보이도록 하고, 관련 JavaScript 로직도 제거합니다.

templates/edit_post.html (비밀번호 필드 항상 표시 버전)

HTML

{% extends "base.html" %}

{% block title %}{{ '게시글 수정' if post else '새 게시글 작성' }} - 나의 게시판{% endblock %}

{% block head_extra %}
    {# TinyMCE 로컬 경로 #}
    <script src="{{ url_for('static', filename='tinymce/tinymce.min.js') }}" referrerpolicy="origin"></script>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4"> {# 또는 이전에 사용하시던 container 클래스 #}
    <h2>{{ '게시글 수정' if post else '새 게시글 작성' }}</h2>
    <form method="POST" action="{{ url_for('edit_post', slug=post.slug) if post else url_for('new_post') }}">
        <div class="form-group">
            <label for="title">제목</label>
            <input type="text" class="form-control" id="title" name="title" value="{{ title or (post.title if post else '') }}" required>
        </div>

        <div class="form-group">
            <label for="category_id">카테고리</label>
            <select class="form-control" id="category_id" name="category_id">
                <option value="">-- 카테고리 선택 안 함 --</option>
                {% for category_item in categories %}
                    <option value="{{ category_item.id }}" {% if selected_category_id and category_item.id == selected_category_id|int %}selected{% endif %}>
                        {{ category_item.name }}
                    </option>
                {% endfor %}
            </select>
        </div>

        {# --- 게시글 비밀번호 설정 (항상 보이도록 수정) --- #}
        <div class="form-group form-check">
            <input type="checkbox" class="form-check-input" id="is_password_protected_checkbox" name="is_password_protected" value="y"
                   {% if post and post.is_password_protected %}checked{% endif %}>
            <label class="form-check-label" for="is_password_protected_checkbox">이 글을 비밀번호로 보호합니다 (체크 시 아래 비밀번호 사용).</label>
        </div>

        {# JavaScript로 숨김/표시 로직 제거, 항상 보이도록 style 속성 제거 #}
        <div id="password_fields_container">
            <div class="form-group">
                <label for="post_password_input">글 비밀번호</label>
                <input type="password" class="form-control" id="post_password_input" name="post_password" placeholder="비밀번호 보호 체크 시 사용할 비밀번호">
                <small class="form-text text-muted">
                    위 "비밀번호로 보호" 체크 시, 여기에 입력된 비밀번호가 사용됩니다.
                    체크하지 않으면 이 필드에 입력된 값은 무시됩니다.
                    기존 글 수정 시, 비밀번호를 변경하고 싶을 때만 새 비밀번호를 입력하세요. 비워두고 체크하면 기존 비밀번호가 유지됩니다 (새 글 작성 시에는 반드시 입력).
                </small>
            </div>
        </div>
        {# --- 게시글 비밀번호 설정 끝 --- #}

        <div class="form-group">
            <label for="content">내용</label>
            <textarea class="form-control" id="content" name="content" rows="15">{{ content or (post.content if post else '') }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장</button>
        <a href="{{ url_for('index') }}" class="btn btn-secondary">취소</a>
    </form>
</div>
{% endblock %}

{% block scripts_extra %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    // TinyMCE 초기화 (기존 코드와 동일)
    tinymce.init({
        selector: 'textarea#content',
        plugins: 'preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars fullscreen image link media template codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons accordion',
        menubar: 'file edit view insert format tools table help',
        toolbar: 'undo redo | accordion accordionremove | blocks fontfamily fontsize | bold italic underline strikethrough | align numlist bullist | link image media table | lineheight outdent indent| forecolor backcolor removeformat | charmap emoticons | code fullscreen preview | save print | pagebreak anchor codesample | ltr rtl',
        height: 600,
        language: 'ko_KR',
        automatic_uploads: true,
        images_upload_url: "{{ url_for('upload_image') }}",
        file_picker_types: 'image',
        paste_data_images: true,
        images_upload_handler: function (blobInfo, progress) {
            return new Promise((resolve, reject) => {
                const image_size_mb = blobInfo.blob().size / 1024 / 1024;
                const client_max_size_mb = 10; 

                if (image_size_mb > client_max_size_mb) {
                    reject({ 
                        message: '이미지 용량이 너무 큽니다 (' + image_size_mb.toFixed(1) + 'MB). 클라이언트 최대 허용 용량은 ' + client_max_size_mb + 'MB 입니다.', 
                        remove: true
                    });
                    return;
                }
                const xhr = new XMLHttpRequest();
                xhr.withCredentials = false;
                xhr.open('POST', "{{ url_for('upload_image') }}");
                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        progress(e.loaded / e.total * 100);
                    }
                };
                xhr.onload = () => {
                    if (xhr.status < 200 || xhr.status >= 300) {
                        let errorMessage = 'HTTP Error: ' + xhr.status;
                        try {
                            const jsonError = JSON.parse(xhr.responseText);
                            if (jsonError && jsonError.error && jsonError.error.message) {
                                errorMessage = jsonError.error.message;
                            }
                        } catch (e) {
                            if (xhr.status === 413) {
                                 errorMessage = '파일이 너무 큽니다. 서버에서 요청을 거부했습니다 (HTTP 413).';
                            } else if (xhr.responseText && xhr.responseText.length < 300) {
                                errorMessage = `서버 오류: ${xhr.status} - ${xhr.responseText.substring(0,100)}`;
                            } else {
                                errorMessage = `서버에서 예상치 못한 응답을 받았습니다 (HTTP ${xhr.status}).`;
                            }
                        }
                        reject({ message: errorMessage, remove: true });
                        return;
                    }
                    try {
                        const json = JSON.parse(xhr.responseText);
                        if (!json || typeof json.location != 'string') {
                            reject({ message: '서버로부터 잘못된 JSON 응답을 받았습니다: ' + xhr.responseText, remove: true });
                            return;
                        }
                        resolve(json.location);
                    } catch (e) {
                        reject({ message: '서버 응답 처리 중 오류 발생 (JSON 파싱 실패): ' + e.message + ' 응답내용: ' + xhr.responseText.substring(0,100), remove: true });
                    }
                };
                xhr.onerror = () => {
                    reject({ message: '네트워크 오류로 이미지 업로드에 실패했습니다. 서버 연결을 확인해주세요.', remove: true });
                };
                const formData = new FormData();
                formData.append('file', blobInfo.blob(), blobInfo.filename());
                xhr.send(formData);
            });
        }
    });

    // 비밀번호 필드 표시/숨김 처리 JavaScript는 이제 필요 없으므로 제거합니다.
});
</script>
{% endblock %}
edit_post.html 변경 사항 요약:

password_fields_container div에서 style="display: ..." 속성을 제거했습니다. 이렇게 하면 이 div는 항상 보이게 됩니다.
{% block scripts_extra %} 내부의 비밀번호 필드 표시/숨김 관련 JavaScript 코드(togglePasswordFieldsVisibility 함수 및 관련 addEventListener 로직)를 모두 제거했습니다. 더 이상 필요 없기 때문입니다.
체크박스의 레이블과 비밀번호 필드의 설명 텍스트를 약간 수정하여, 체크박스 상태와 비밀번호 필드 입력값에 따라 어떻게 동작하는지 사용자에게 더 명확히 안내하도록 했습니다.
2. app.py 파일의 new_post 및 edit_post 라우트 수정

이제 비밀번호 입력 필드가 항상 보이므로, 서버 측(app.py)에서는 "비밀번호로 보호" 체크박스(is_password_protected)의 상태와 비밀번호 입력 필드(post_password)의 값을 조합하여 비밀번호를 설정/변경/해제하는 로직을 구현해야 합니다.

app.py (new_post, edit_post 라우트 수정)

Python

# app.py 파일의 상단 import 부분은 이전과 동일하게 유지합니다.
# from models import db, Post, Category 등
# app = Flask(__name__) 등 초기화 부분도 동일하게 유지

# ... (다른 라우트들은 이전과 동일) ...

@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    cats = []
    if Category:
        try:
            cats = Category.query.order_by(Category.name).all()
        except Exception as e:
            app.logger.error(f"Error fetching categories for new_post: {e}")
            flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")

    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        
        # 비밀번호 관련 폼 데이터 가져오기
        is_protected_form = request.form.get('is_password_protected') == 'y' # 체크박스 값 'y' 또는 None
        post_password_form = request.form.get('post_password')

        if not title or not content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None

        try:
            if not Post:
                 raise Exception("Post model is not available to create a new post.")

            # 새 글 작성 시 비밀번호 처리
            # is_protected_form 이 True이고 post_password_form에 값이 있을 때만 비밀번호 설정
            new_post_obj = Post(title=title, content=content, category_id=processed_category_id) # 먼저 객체 생성
            
            if is_protected_form:
                if post_password_form: # 비밀번호가 입력되었으면 설정
                    new_post_obj.set_password(post_password_form) # models.py에 정의된 set_password 사용
                    new_post_obj.is_password_protected = True
                else: # 보호 체크는 했으나 비밀번호를 입력 안 한 경우 (새 글이므로 오류 또는 보호 해제)
                    flash('비밀번호로 보호를 선택했지만, 비밀번호를 입력하지 않았습니다. 보호되지 않은 글로 저장됩니다.', 'warning')
                    new_post_obj.is_password_protected = False
                    new_post_obj.password_hash = None 
            else: # 보호 체크 안 함
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None

            db.session.add(new_post_obj)
            db.session.commit()
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating post: {e}")
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            # 오류 발생 시, is_password_protected 상태와 입력된 비밀번호(보안상 비추천)는 다시 전달하지 않거나,
            # 혹은 is_password_protected 상태만 전달하여 템플릿에서 체크박스를 다시 표시하도록 할 수 있음.
            # 여기서는 단순하게 템플릿이 기존 post 객체 없이 렌더링되도록 함.
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

    # GET 요청 시
    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None)


@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    if not Post or not Category:
        abort(500, description="Post or Category model not available.")

    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()
    cats = []
    try:
        cats = Category.query.order_by(Category.name).all()
    except Exception as e:
        app.logger.error(f"Error fetching categories for edit_post: {e}")
        flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")
    
    # GET 요청 시, 현재 게시물의 카테고리 ID와 비밀번호 보호 상태를 템플릿에 전달
    selected_category_id = str(post_to_edit.category_id) if post_to_edit.category_id is not None else ""
    
    if request.method == 'POST':
        original_title = post_to_edit.title
        
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        selected_category_id = category_id_str # POST 시 사용자가 선택한 값으로 업데이트 (폼 값 유지용)

        # 비밀번호 관련 폼 데이터 가져오기
        is_protected_form = request.form.get('is_password_protected') == 'y'
        post_password_form = request.form.get('post_password')

        if not post_to_edit.title or not post_to_edit.content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            # is_password_protected 상태를 post_to_edit.is_password_protected로 전달하여 템플릿에서 체크박스 상태 유지
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        post_to_edit.category_id = processed_category_id

        # 비밀번호 처리 로직 (수정 시)
        if is_protected_form:
            post_to_edit.is_password_protected = True
            if post_password_form: # 새 비밀번호가 입력되었으면 변경
                post_to_edit.set_password(post_password_form)
            # 새 비밀번호가 입력되지 않았으면 기존 비밀번호 해시 유지 (set_password 호출 안 함)
            # 이 경우, is_password_protected는 True로 설정되지만, password_hash는 변경되지 않음.
            # 만약 체크는 했는데 비밀번호 입력칸이 비어있고, 기존에도 비밀번호가 없었다면? -> 이 경우 비밀번호 없이 보호상태가 될 수 있음.
            # 따라서, 보호 체크 시 비밀번호가 없으면(기존에도 없었고, 새로 입력도 안함) 오류를 내거나 보호를 해제하는 로직 필요.
            # 여기서는 models.py의 set_password가 빈 문자열이면 해시를 None으로 하므로,
            # 빈 비밀번호로 설정 시도 시 비밀번호가 없어지게 됨.
            # 좀 더 명확한 로직:
            # if post_password_form:
            #     post_to_edit.set_password(post_password_form)
            # elif not post_to_edit.password_hash: # 새 비밀번호도 없고 기존 비밀번호도 없는데 보호 체크한 경우
            #     flash('비밀번호로 보호를 선택했지만, 설정할 비밀번호가 없습니다. 기존 비밀번호도 없습니다.', 'warning')
            #     post_to_edit.is_password_protected = False # 보호 해제
            # # else: 새 비밀번호 없고 기존 비밀번호 있으면 유지
            # 위 로직보다 아래가 더 직관적
            if post_password_form: # 새 비밀번호 입력 시
                post_to_edit.set_password(post_password_form)
            elif not post_to_edit.password_hash: # 기존 비밀번호가 없고, 새 비밀번호도 입력 안했는데 '보호' 체크한 경우
                flash('보호를 원하시면 새 비밀번호를 입력해야 합니다. 또는 보호 체크를 해제하세요.', 'warning')
                # 여기서는 is_password_protected = True로 유지하되, 비밀번호가 없음을 인지시킴
                # 또는 강제로 is_password_protected = False로 변경할 수도 있음
                # 사용자가 "보호"를 원했으므로 일단 is_password_protected = True 유지. 단, 비밀번호가 없으면 view에서 문제.
                # 따라서, 이 경우는 비밀번호를 입력하도록 유도하거나, 보호를 해제하는 것이 나음.
                # 여기서는 만약 비밀번호 없이 보호 체크되면, 비밀번호를 설정하라고 하고 저장을 막거나,
                # 아니면 models.py의 Post.__init__처럼 처리
                # 지금 Post 모델의 set_password는 빈 문자열이면 해시를 None으로 만듦.
                # 따라서, 체크하고 빈 문자열이면 비밀번호가 사라짐. 이 점을 사용자에게 안내해야 함.
                # "비밀번호를 비우고 '보호'를 체크하면 기존 비밀번호가 삭제됩니다."
                # 여기서는 "체크 + 빈 비밀번호"는 "기존 비밀번호 유지"로 해석하지 않고, "비밀번호 삭제"로 해석.
                post_to_edit.set_password(post_password_form) # 빈 문자열이면 해시가 None이 됨 (보호 해제 효과)
                if not post_password_form: # 실제로 비밀번호를 비워서 삭제하려 했다면
                     flash('비밀번호를 비워 보호를 해제합니다.', 'info')


        else: # is_protected_form is False (보호 체크 해제)
            post_to_edit.is_password_protected = False
            post_to_edit.password_hash = None # 비밀번호 해시 제거

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title)
        
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit()
            flash('게시글이 성공적으로 수정되었습니다.', 'success')
            return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing post {slug}: {e}")
            flash(f'게시글 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

    # GET 요청 시
    return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

# ... (나머지 app.py 코드는 이전과 동일하게 유지: delete_post, upload_image, 카테고리 관리 라우트, 실행 부분 등) ...
app.py의 new_post 및 edit_post 라우트 변경 요약:

폼에서 is_password_protected (체크박스 값, 'y' 또는 None)와 post_password (입력된 비밀번호) 값을 가져옵니다.
새 글 작성 (new_post) 시:
체크박스가 선택되고(is_protected_form == True) 비밀번호가 입력되었으면(post_password_form에 값이 있으면), post.set_password()를 호출하여 비밀번호를 설정하고 is_password_protected를 True로 합니다.
체크박스가 선택되었으나 비밀번호가 입력되지 않았으면, 경고 메시지를 표시하고 보호되지 않은 글로 저장합니다 (또는 오류 처리).
체크박스가 선택되지 않았으면 is_password_protected를 False로 하고 password_hash를 None으로 합니다.
글 수정 (edit_post) 시:
is_protected_form 값에 따라 post_to_edit.is_password_protected를 설정합니다.
만약 is_protected_form이 True (보호 체크됨)이고, post_password_form에 새로운 비밀번호가 입력되었으면 post_to_edit.set_password()를 호출하여 비밀번호를 변경합니다.
만약 is_protected_form이 True인데 post_password_form이 비어있으면, 기존 비밀번호를 유지합니다 (이 경우 set_password를 호출하지 않습니다. 단, models.py의 set_password가 빈 문자열을 받으면 해시를 None으로 만들므로, 이 부분을 명확히 하기 위해 로직을 수정했습니다. 수정된 로직은 체크하고 비밀번호를 비우면 비밀번호가 삭제(보호 해제)되도록 합니다.).
만약 is_protected_form이 False (보호 체크 해제됨)이면, post_to_edit.is_password_protected = False로 설정하고 post_to_edit.password_hash = None으로 하여 비밀번호를 제거합니다.
중요: 위 app.py 코드는 new_post와 edit_post 라우트 부분만 보여드렸습니다. 나머지 /, /post/<slug>, /admin/categories 등의 라우트와 파일 상단의 import문, Flask 앱 초기화(app = Flask(__name__) 등), 그리고 맨 아래 실행 부분(if __name__ == '__main__':) 등은 이전 답변에서 드린 app.py 전체 코드를 그대로 유지하셔야 합니다.

테스트:

위 edit_post.html과 app.py의 해당 라우트 부분을 수정한 코드로 파일을 업데이트합니다.
데이터베이스를 다시 초기화합니다 (board.db 삭제 후 앱 재시작). (모델에 is_password_protected 필드가 추가되었으므로 필요할 수 있습니다. 만약 이전 단계에서 이미 이 필드를 포함한 모델로 DB를 초기화했다면 생략 가능합니다. 하지만 안전하게 다시 하는 것을 권장합니다.)
앱을 재시작하고, 게시글 작성/수정 페이지로 가서 다음 시나리오들을 테스트합니다:
새 글 작성:
체크박스 해제 후 저장 -> 비밀번호 없이 저장되는지 확인.
체크박스 선택 + 비밀번호 입력 후 저장 -> 비밀번호 설정되는지 확인.
체크박스 선택 + 비밀번호 미입력 후 저장 -> 경고 메시지 또는 비밀번호 없이 저장되는지 확인 (위 로직은 경고 후 비밀번호 없이 저장).
기존 글 수정:
(비밀번호 없는 글) 체크박스 선택 + 비밀번호 입력 후 저장 -> 비밀번호 설정되는지 확인.
(비밀번호 있는 글) 체크박스 선택 + 새 비밀번호 입력 후 저장 -> 비밀번호 변경되는지 확인.
(비밀번호 있는 글) 체크박스 선택 + 비밀번호 미입력 후 저장 -> 기존 비밀번호가 유지되는지, 아니면 삭제되는지 확인. (위 코드에서는 빈 문자열로 set_password를 호출하면 비밀번호가 삭제됩니다. 만약 "기존 비밀번호 유지"를 원한다면 edit_post의 if post_password_form: 조건을 좀 더 세밀하게 다뤄야 합니다. 예를 들어, elif post_to_edit.password_hash: (기존 비밀번호가 있고 새 입력이 없으면 유지) 같은 로직을 추가해야 합니다. 현재는 "체크 + 빈 비밀번호" = "비밀번호 삭제/보호해제" 로 동작합니다.)
(비밀번호 있는 글) 체크박스 해제 후 저장 -> 비밀번호 해제되는지 확인.
이 방식으로 수정하면 JavaScript 문제 없이 비밀번호 입력창이 항상 보이게 되고, 서버 로직으로 실제 비밀번호 적용 여부를 제어할 수 있습니다. 다시 한번 불편을 드려 죄송하며, 이 방법으로 꼭 원하시는 기능이 구현되기를 바랍니다.

