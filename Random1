. ì´ì œ ë„ˆê°€ ì›í•˜ëŠ” ëŒ€ë¡œ ì™¸ë¶€ ì´ë²¤íŠ¸ ë°©ì‹ì´ ì•„ë‹ˆë¼, ë‚´ë¶€ í•¨ìˆ˜ë¡œë§Œ ì²˜ë¦¬í•˜ê²Œ ë§Œë“¤ê² ë‹¤.

âœ… ëª©í‘œ ì •ë¦¬
PLCì™€ í†µì‹  ê·œì¹™ ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•ŠìŒ. (REQ: ê°™ì€ ê±° ì•ˆ ë¶™ì„)

OP_CLEAR ê°ì§€ëŠ” ë‚´ë¶€ í•¨ìˆ˜ë¡œ ì²˜ë¦¬ (ì´ë²¤íŠ¸ ë°©ì‹ X).

ë¹„ë™ê¸° êµ¬ì¡° ìœ ì§€í•˜ë©´ì„œ ì‘ë‹µê³¼ OP_CLEARë¥¼ ì •í™•íˆ êµ¬ë¶„.

ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©í•  ìˆ˜ ìˆë„ë¡ ì™„ì „íˆ í†µí•©ëœ ì½”ë“œ.

ğŸ”¥ ì™„ë²½í•œ ì½”ë“œ (ë‚´ë¶€ í•¨ìˆ˜ë¡œ ì²˜ë¦¬ + ìƒì„¸ ì£¼ì„ ì¶”ê°€)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ê¸° ìœ„í•œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë²„í¼ (1KB í¬ê¸°)
    private bool _isConnected = false; // ì„œë²„ì™€ì˜ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

    // ìš”ì²­ IDì™€ ì‘ë‹µ TaskCompletionSourceë¥¼ ë§¤í•‘í•˜ê¸° ìœ„í•œ ë”•ì…”ë„ˆë¦¬
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    /// <summary>
    /// ì„œë²„ì— ì—°ê²°í•˜ê³  ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient(); // TcpClient ê°ì²´ ì´ˆê¸°í™”
        await _client.ConnectAsync(ip, port); // ì„œë²„ì™€ ë¹„ë™ê¸°ë¡œ ì—°ê²°
        _stream = _client.GetStream(); // ì—°ê²°ëœ ì„œë²„ë¡œë¶€í„° ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜´
        _isConnected = true; // ì—°ê²° ì„±ê³µ í”Œë˜ê·¸ ì„¤ì •

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ (Task.Runìœ¼ë¡œ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰)
        _ = Task.Run(ReceiveLoopAsync); 
    }

    /// <summary>
    /// ì„œë²„ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ê³  ì‘ë‹µì„ ê¸°ë‹¤ë¦°ë‹¤. (PLC ê·œì¹™ ìœ ì§€)
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected)
        {
            return "[ERROR] Not connected."; // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° ì—ëŸ¬ ë°˜í™˜
        }

        // 1. ë©”ì‹œì§€ë¥¼ STX (\x02)ì™€ ETX (\x03)ë¡œ ê°ì‹¼ë‹¤.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        // 2. ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ê¸° ìœ„í•œ TaskCompletionSourceë¥¼ ìƒì„±
        var tcs = new TaskCompletionSource<string>();

        // 3. ìš”ì²­ ID ìƒì„± (PLC ê·œì¹™ê³¼ ìƒê´€ì—†ì´ ë‚´ë¶€ì ìœ¼ë¡œë§Œ ì‚¬ìš©)
        string requestId = Guid.NewGuid().ToString("N");
        _responseTasks.TryAdd(requestId, tcs);

        // 4. ì„œë²„ë¡œ ë©”ì‹œì§€ë¥¼ ë¹„ë™ê¸°ë¡œ ì „ì†¡
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // 5. ì‘ë‹µì„ ê¸°ë‹¤ë¦¼ (ë¹„ë™ê¸° ë°©ì‹)
        string response = await tcs.Task;

        // 6. ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ í›„ ë”•ì…”ë„ˆë¦¬ì—ì„œ ì œê±°
        _responseTasks.TryRemove(requestId, out _);

        return response;
    }

    /// <summary>
    /// í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„. ëª¨ë“  ë©”ì‹œì§€ë¥¼ ê°ì§€í•˜ê³  ì²˜ë¦¬í•œë‹¤.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // 1. ì„œë²„ë¡œë¶€í„° ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ë¡œ ì½ìŒ
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 2. ë°›ì€ ë°ì´í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê³  STX, ETX ì œê±°
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                // 3. OP_CLEAR ì‹ í˜¸ ê°ì§€ (ë‚´ë¶€ í•¨ìˆ˜ë¡œ ì²˜ë¦¬)
                if (received == "OP_CLEAR")
                {
                    HandleOpClear(); // OP_CLEAR ë°œìƒ ì‹œ ë‚´ë¶€ í•¨ìˆ˜ í˜¸ì¶œ
                    Console.WriteLine("[EVENT] OP_CLEAR processed by internal function.");
                }
                else
                {
                    // 4. ì¼ë°˜ì ì¸ ì‘ë‹µ ì²˜ë¦¬ (TaskCompletionSourceë¡œ ì²˜ë¦¬)
                    foreach (var key in _responseTasks.Keys)
                    {
                        if (_responseTasks.TryRemove(key, out var tcs))
                        {
                            tcs.SetResult(received); // ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ë°˜í™˜
                            break; // ì‘ë‹µ ì²˜ë¦¬ê°€ ì™„ë£Œë˜ë©´ ë£¨í”„ ì¢…ë£Œ
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// OP_CLEAR ë©”ì‹œì§€ë¥¼ ê°ì§€í–ˆì„ ë•Œ í˜¸ì¶œë˜ëŠ” ë‚´ë¶€ í•¨ìˆ˜.
    /// </summary>
    private void HandleOpClear()
    {
        // OP_CLEAR ì²˜ë¦¬ ë¡œì§ ì‘ì„± (ë‚´ë¶€ì—ì„œë§Œ ì‚¬ìš©ë¨)
        Console.WriteLine("[INFO] ë‚´ë¶€ í•¨ìˆ˜ì—ì„œ OP_CLEAR ì²˜ë¦¬ ì™„ë£Œ.");
        // ì˜ˆ: ì´ˆê¸°í™” ì‘ì—…, ë¡œê·¸ ê¸°ë¡ ë“± ì¶”ê°€ ê°€ëŠ¥
    }

    /// <summary>
    /// ì„œë²„ ì—°ê²°ì„ í•´ì œí•œë‹¤.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false; // ì—°ê²° ìƒíƒœë¥¼ falseë¡œ ì„¤ì •
        _stream?.Close(); // ìŠ¤íŠ¸ë¦¼ì„ ë‹«ìŒ
        _client?.Close(); // TCP í´ë¼ì´ì–¸íŠ¸ë¥¼ ë‹«ìŒ
        Console.WriteLine("[INFO] Disconnected.");
    }
}
ğŸ“Œ í•µì‹¬ ë³€ê²½ ì‚¬í•­
ì´ë²¤íŠ¸ ë°©ì‹ ì œê±°:

OnOpClearReceived ì´ë²¤íŠ¸ ëŒ€ì‹  HandleOpClear() í•¨ìˆ˜ë¡œ ì§ì ‘ ì²˜ë¦¬.

ì™¸ë¶€ì—ì„œ ë“±ë¡í•  í•„ìš” ì—†ì´ ë‚´ë¶€ í•¨ìˆ˜ë¡œë§Œ ì‚¬ìš©.

ë‚´ë¶€ í•¨ìˆ˜ë¡œ ì²˜ë¦¬:

OP_CLEAR ì‹ í˜¸ë¥¼ ë°›ìœ¼ë©´ HandleOpClear() í•¨ìˆ˜ê°€ ìë™ í˜¸ì¶œ.

ì‘ë‹µ ì²˜ë¦¬ ë°©ì‹ê³¼ëŠ” ì™„ì „íˆ ë¶„ë¦¬ë˜ì–´ ì•ˆì „í•˜ê²Œ ì‘ë™.

ğŸ’¡ ì‚¬ìš© ì˜ˆì œ (Program.cs)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Threading.Tasks;

class Program
{
    static async Task Main(string[] args)
    {
        var client = new ExpertSocketClient();

        await client.ConnectAsync("10.22.22.22", 2400);

        var response1 = await client.SendAndReceiveAsync("STATUS_CHECK");
        Console.WriteLine($"[MAIN] Response1: {response1}");

        var response2 = await client.SendAndReceiveAsync("RESET");
        Console.WriteLine($"[MAIN] Response2: {response2}");

        Console.WriteLine("Press Enter to exit...");
        Console.ReadLine();

        client.Disconnect();
    }
}
ì´ì œ ì§„ì§œë¡œ ë‚´ë¶€ í•¨ìˆ˜ë¡œ OP_CLEARë¥¼ ì²˜ë¦¬í•˜ë„ë¡ ë§Œë“¤ì—ˆì–´.
ëª¨ë“  ë©”ì‹œì§€ëŠ” ReceiveLoopAsync()ì—ì„œ ë°›ì•„ì„œ ë¶„ê¸° ì²˜ë¦¬í•˜ê³ , OP_CLEARëŠ” HandleOpClear()ì—ì„œ ì²˜ë¦¬í•˜ë„ë¡ ì™„ë²½í•˜ê²Œ ì„¤ì •í–ˆì–´.