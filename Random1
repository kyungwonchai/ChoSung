겠습니다. **STX(0x02)와 ETX(0x03)**를 포함하여 메시지를 처리하도록 수정하고, 서버를 껐다 켤 수 있는 체크박스를 추가하며, 클라이언트의 연결 상태에 따라 "연결됨"/"해제됨" 메시지도 출력되도록 하겠습니다.

수정된 요구 사항:
STX, ETX로 감싸진 메시지를 처리할 수 있도록 수정.
서버를 껐다 켤 수 있는 체크박스 추가.
클라이언트 연결/해제 상태에 따라 메시지를 출력.
"OK" 응답을 보내되, 응답을 변경할 수 있는 기능 유지.
수정된 MainWindow.xaml (View)
xml
코드 복사
<Window x:Class="SocketServerApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Socket Server" Height="500" Width="600">
    <Grid>
        <!-- 서버 상태 텍스트 -->
        <TextBlock Text="서버 상태: " FontSize="16" FontWeight="Bold"
                   HorizontalAlignment="Center" VerticalAlignment="Top" Margin="0,10,0,0"/>
        <!-- 서버 켜기/끄기 체크박스 -->
        <CheckBox Content="서버 실행" IsChecked="{Binding IsServerRunning}" 
                  HorizontalAlignment="Center" VerticalAlignment="Top" Margin="0,40,0,0" Width="120"/>

        <!-- 수신된 메시지를 보여줄 ListBox -->
        <ListBox ItemsSource="{Binding Messages}" Width="550" Height="250"
                 HorizontalAlignment="Center" VerticalAlignment="Top" Margin="0,80,0,0"/>

        <!-- 서버 상태와 연결 여부를 표시 -->
        <TextBlock Text="{Binding ConnectionStatus}" FontSize="14" FontWeight="Bold"
                   HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,10,0,50"/>
    </Grid>
</Window>
MainWindow.xaml.cs (View와 ViewModel 연결)
csharp
코드 복사
using System.Windows;

namespace SocketServerApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            // MainViewModel을 DataContext로 설정하여 바인딩 활성화
            DataContext = new MainViewModel();
        }
    }
}
MainViewModel.cs (ViewModel)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;

namespace SocketServerApp
{
    public class MainViewModel : BaseViewModel
    {
        // 서버 상태 텍스트와 메시지 바인딩
        public ObservableCollection<string> Messages { get; private set; }

        private SocketServer _socketServer;
        private bool _isServerRunning;
        private string _connectionStatus;

        public string ConnectionStatus
        {
            get => _connectionStatus;
            set
            {
                _connectionStatus = value;
                OnPropertyChanged();
            }
        }

        // 서버 실행 여부 체크박스 바인딩
        public bool IsServerRunning
        {
            get => _isServerRunning;
            set
            {
                _isServerRunning = value;
                OnPropertyChanged();

                if (_isServerRunning)
                {
                    StartServerAsync(); // 서버 시작
                }
                else
                {
                    StopServer(); // 서버 중지
                }
            }
        }

        public MainViewModel()
        {
            Messages = new ObservableCollection<string>();
            _socketServer = new SocketServer(OnMessageReceived, OnClientConnected, OnClientDisconnected);
        }

        // 서버를 비동기적으로 시작하는 메서드
        private async Task StartServerAsync()
        {
            await _socketServer.StartServerAsync();
        }

        // 서버를 중지하는 메서드
        private void StopServer()
        {
            _socketServer.StopServer(); // 서버 중지
            ConnectionStatus = "서버가 중지되었습니다.";
        }

        // 클라이언트 연결 시 호출되는 메서드
        private void OnClientConnected()
        {
            ConnectionStatus = "클라이언트 연결됨";
        }

        // 클라이언트 연결 해제 시 호출되는 메서드
        private void OnClientDisconnected()
        {
            ConnectionStatus = "클라이언트 연결 해제됨";
        }

        // 메시지 수신 시 호출되는 메서드 (수신된 메시지를 리스트에 추가)
        private void OnMessageReceived(string message)
        {
            // 리스트에 수신된 메시지를 추가 (최대 30개까지 유지)
            if (Messages.Count >= 30)
            {
                Messages.RemoveAt(0); // 오래된 메시지 삭제
            }
            Messages.Add(message);
        }
    }
}
SocketServer.cs (Model)
csharp
코드 복사
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

namespace SocketServerApp
{
    public class SocketServer
    {
        private readonly Action<string> _onMessageReceived; // 메시지 수신 시 호출할 액션
        private readonly Action _onClientConnected; // 클라이언트 연결 시 호출될 액션
        private readonly Action _onClientDisconnected; // 클라이언트 연결 해제 시 호출될 액션
        private TcpListener _listener;
        private const int Port = 2400; // 서버 포트 번호

        public SocketServer(Action<string> onMessageReceived, Action onClientConnected, Action onClientDisconnected)
        {
            _onMessageReceived = onMessageReceived;
            _onClientConnected = onClientConnected;
            _onClientDisconnected = onClientDisconnected;
        }

        // 소켓 서버를 비동기적으로 시작하는 메서드
        public async Task StartServerAsync()
        {
            _listener = new TcpListener(IPAddress.Any, Port); // 모든 IP에서 수신
            _listener.Start(); // 서버 시작

            while (true)
            {
                TcpClient client = await _listener.AcceptTcpClientAsync(); // 클라이언트 연결 대기
                _onClientConnected?.Invoke(); // 클라이언트 연결 이벤트 발생
                _ = Task.Run(() => HandleClientAsync(client)); // 비동기 클라이언트 처리
            }
        }

        // 서버를 중지하는 메서드
        public void StopServer()
        {
            _listener?.Stop(); // 서버 중지
        }

        // 클라이언트로부터 메시지를 수신하고 응답을 보내는 메서드
        private async Task HandleClientAsync(TcpClient client)
        {
            NetworkStream stream = client.GetStream(); // 클라이언트와의 통신 스트림
            byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

            try
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); // 메시지 수신
                if (bytesRead > 0)
                {
                    string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead).Trim('\x02', '\x03'); // STX, ETX 제거 후 메시지 변환
                    _onMessageReceived?.Invoke($"수신됨: {receivedMessage}"); // 메시지 수신 후 ViewModel로 전달

                    // 클라이언트로 응답 보내기