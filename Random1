기존의 방식대로 QR 코드와 바코드를 같이 인식하되, 카메라 화면에서 손으로 확대/축소(Zoom) 기능을 추가하고, 오토포커스 속도를 개선하는 방법을 구현해드리겠습니다.

1. XML 레이아웃 (activity_main.xml)
카메라 프리뷰와 관련된 레이아웃을 정의합니다. 이 레이아웃에서는 PreviewView를 사용하여 카메라 프리뷰를 표시합니다.

xml
코드 복사
<RelativeLayout
    xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent">

    <!-- 카메라 프리뷰를 위한 PreviewView -->
    <androidx.camera.view.PreviewView
        android:id="@+id/previewView"
        android:layout_width="match_parent"
        android:layout_height="match_parent" />
</RelativeLayout>
2. Kotlin 코드 (MainActivity.kt)
이제 카메라 프리뷰에서 손으로 확대/축소 기능을 추가하고, 오토포커스 속도를 개선하는 코드를 작성합니다.

kotlin
코드 복사
package com.example.myapp

import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.util.Log
import android.view.ScaleGestureDetector
import android.view.View
import androidx.activity.ComponentActivity
import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.camera.core.CameraControl
import androidx.camera.core.Camera
import androidx.camera.core.Camera2Config
import androidx.camera.camera2.interop.Camera2CameraControl
import androidx.camera.camera2.interop.Camera2Interop
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var previewView: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private var cameraControl: CameraControl? = null
    private var camera: Camera? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        previewView = findViewById(R.id.previewView)
        cameraExecutor = Executors.newSingleThreadExecutor()

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        setupPinchToZoom()
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder().build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            // 오토포커스를 더 빠르게 설정하기 위해 Camera2Interop 사용
            val camera2Interop = Camera2Interop.Extender(preview)
            camera2Interop.setCaptureRequestOption(
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE,
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
            )

            try {
                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview
                )
                cameraControl = camera?.cameraControl

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun setupPinchToZoom() {
        val scaleGestureDetector = ScaleGestureDetector(this,
            object : ScaleGestureDetector.SimpleOnScaleGestureListener() {
                override fun onScale(detector: ScaleGestureDetector): Boolean {
                    val currentZoomRatio = camera?.cameraInfo?.zoomState?.value?.zoomRatio ?: 1f
                    val delta = detector.scaleFactor
                    cameraControl?.setZoomRatio(currentZoomRatio * delta)
                    return true
                }
            })

        previewView.setOnTouchListener { _, event ->
            scaleGestureDetector.onTouchEvent(event)
            return@setOnTouchListener true
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<String>, grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE_PERMISSIONS) {
            if (allPermissionsGranted()) {
                startCamera()
            } else {
                // 권한이 거부된 경우 처리
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA
        )
    }
}
3. 코드 설명
오토포커스 속도 개선:

Camera2Interop을 사용하여 오토포커스 모드를 CONTROL_AF_MODE_CONTINUOUS_PICTURE로 설정했습니다. 이는 카메라가 연속적으로 자동 초점을 조정하게 하여 빠른 초점 전환을 가능하게 합니다.
Pinch-to-Zoom 기능:

ScaleGestureDetector를 사용하여 손가락으로 화면을 확대/축소하는 기능을 추가했습니다. 사용자가 화면을 핀치할 때 onScale 메서드가 호출되어 줌 레벨을 조정합니다.
카메라 라이프사이클 관리:

startCamera 메서드는 카메라 프리뷰를 초기화하고, CameraX 라이브러리를 사용하여 카메라 기능을 관리합니다.
cameraControl 객체를 통해 카메라의 줌과 같은 제어 기능을 수행합니다.
권한 처리:

onRequestPermissionsResult에서 카메라 권한이 승인되었는지 확인하고, 필요한 경우 카메라를 시작합니다.
결론
이 코드로 QR 코드와 바코드를 같이 인식하면서, 손가락을 사용해 화면을 확대/축소할 수 있는 기능과 더 빠른 오토포커스 성능을 얻을 수 있습니다. 이 솔루션을 통해 인식 성능을 향상시키고 사용자 경험을 개선할 수 있습니다. 추가적인 질문이나 문제가 있으면 언제든지 알려주세요