아, 정말 죄송합니다. 매줄마다 한글로 매우 상세한 주석을 추가해서 다시 작성하겠습니다. 주석을 통해 코드가 어떻게 동작하는지 아주 명확히 설명하겠습니다.

수정된 코드 (상세한 한글 주석 포함)
csharp
코드 복사
// 비동기 작업을 큐에 추가하고 처리하는 메서드
private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
{
    // 새로운 명령 아이템 생성
    var newCommand = new CommandItem 
    { 
        CommandText = commandText, // 명령어 텍스트 설정
        Status = "Pending", // 상태를 "Pending"으로 초기화 (대기 중 상태)
        MaxRetryLimit = RetryLimit, // 최대 재시도 횟수 설정 (기본 3회)
        RetryCount = 0, // 재시도 횟수를 0으로 초기화
        CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 명령이 추가된 시간을 기록
    };

    // UI를 갱신하기 위해 Dispatcher를 사용하여 명령을 RemainingCommands 컬렉션에 추가
    App.Current.Dispatcher.Invoke(() =>
    {
        RemainingCommands.Add(newCommand); // 남아 있는 명령 리스트에 새 명령 추가
    });

    // 큐에 비동기 작업을 추가, 이 작업은 처리되면 실행됨
    commandQueue.Enqueue(async () =>
    {
        // 명령 처리 중이므로 상태를 "Processing"으로 설정
        newCommand.Status = "Processing";

        // UI에서 상태가 바로 반영되도록 OnPropertyChanged 호출
        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 업데이트

        int retryCount = 0; // 재시도 횟수를 0으로 초기화
        Stopwatch stopwatch = new Stopwatch(); // 응답 시간을 측정하기 위한 스톱워치 생성
        _isProcessing = true; // 현재 작업이 처리 중임을 나타내는 플래그

        // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
        while (retryCount < RetryLimit) 
        {
            try
            {
                stopwatch.Restart(); // 스톱워치를 시작해 응답 시간을 측정
                string result = await taskFunc(); // 실제 비동기 작업 실행 (응답 대기)
                stopwatch.Stop(); // 응답이 끝나면 스톱워치 종료

                int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간(밀리초) 계산
                newCommand.ResponseTime = responseTime; // 명령 객체에 응답 시간 기록
                newCommand.RetryCount = retryCount; // 명령 객체에 현재 재시도 횟수 기록

                // 응답 시간이 설정된 제한 시간보다 크면 실패로 처리
                if (responseTime > ResponseTimeout)
                {
                    newCommand.Status = "Timeout"; // 상태를 "Timeout"으로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 업데이트

                    newCommand.Result = 0; // 실패 결과 설정
                    // 데이터베이스에 Timeout 상태로 로그 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Timeout occurred");
                    
                    // 큐 처리를 멈춤
                    StopQueueProcessing(newCommand);
                    // 실패 결과 반환
                    return new CommandResult { Success = false, Message = "Response Timeout" };
                }

                // 응답이 올바르면 작업 완료로 처리
                if (responseValidator(result))
                {
                    newCommand.Status = "Completed"; // 상태를 "Completed"로 변경 (성공 상태)
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                    newCommand.Result = 1; // 성공 결과 설정
                    // 데이터베이스에 성공 상태로 로그 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, result);
                    
                    UpdateProgress(); // 작업이 완료되었으므로 프로그레스바 업데이트
                    _isProcessing = false; // 작업 완료 상태로 처리 중 플래그 해제
                    return new CommandResult { Success = true, Message = result }; // 성공 결과 반환
                }
                else // 응답이 올바르지 않을 경우
                {
                    retryCount++; // 재시도 횟수 증가
                    newCommand.Status = $"Retrying {retryCount}/{RetryLimit}"; // 상태를 "Retrying"으로 변경
                    App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                    // 재시도 횟수가 한계에 도달하면 실패로 처리
                    if (retryCount >= RetryLimit)
                    {
                        newCommand.Status = "Failed"; // 상태를 "Failed"로 변경 (재시도 실패)
                        App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                        newCommand.Result = 0; // 실패 결과 설정
                        // 데이터베이스에 실패 상태로 로그 기록
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, "Failed after retries");
                        
                        ShowAlarm("Queue has been stopped over retry count."); // 경고 알림
                        StopQueueProcessing(newCommand); // 큐 처리 중단
                        return new CommandResult { Success = false, Message = result }; // 실패 결과 반환
                    }

                    // 재시도 간격 대기
                    await Task.Delay(RetryInterval); // 재시도 대기 시간
                }
            }
            catch (Exception ex) // 예외가 발생할 경우
            {
                newCommand.Status = "Failed"; // 상태를 "Failed"로 변경
                App.Current.Dispatcher.Invoke(() => OnPropertyChanged(nameof(RemainingCommands))); // UI 상태 즉시 반영

                newCommand.Result = 0; // 실패 결과 설정
                stopwatch.Stop(); // 응답 시간 측정을 멈춤
                int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산

                newCommand.ResponseTime = responseTime; // 명령 객체에 응답 시간 기록
                // 예외 발생 시 데이터베이스에 로그 기록
                await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                
                ShowAlarm("Error occurred. All tasks stopped."); // 경고 알림
                StopQueueProcessing(newCommand); // 큐 처리 중단
                return new CommandResult { Success = false, Message = ex.Message }; // 실패 결과 반환
            }
        }

        UpdateProgress(); // 프로그레스바 업데이트
        _isProcessing = false; // 작업 완료 상태로 처리 중 플래그 해제
        return new CommandResult { Success = false }; // 실패 결과 반환
    });

    // 현재 다른 작업이 진행 중이지 않으면 큐에서 작업 처리 시작
    if (!_isProcessing)
    {
        _isProcessing = true; // 처리 중 상태 설정
        await ProcessCommandQueue(); // 큐에서 작업을 처리
    }

    UpdateProgress(); // 프로그레스바 상태 업데이트
}

// 큐에서 작업을 순차적으로 처리하는 메서드
private async Task ProcessCommandQueue()
{
    // 큐에 남아있는 작업이 있을 때까지 반복
    while (commandQueue.Count > 0)
    {
        // 만약 큐가 중단된 상태라면 더 이상 작업을 처리하지 않음
        if (_isQueueStopped)
        {
            break; // 루프를 종료하여 큐 처리를 중단
        }

        var command = commandQueue.Dequeue(); // 큐에서 작업을 꺼냄
        await command(); // 꺼낸 작업을 실행
        UpdateProgress(); // 작업이 끝날 때마다 Progress 업데이트
    }

    _isProcessing = false; // 모든 작업이 끝난 후 처리 중 상태를 해제
}

// 큐의 처리를 멈추고 추가 작업을 차단하는 메서드
private void StopQueueProcessing(CommandItem errorCommand)
{
    _isQueueStopped = true; // 큐를 멈춘 상태로 설정

    // UI 스레드에서 에러 목록에 추가
    App.Current.Dispatcher.Invoke(() =>
    {
        // 에러 목록이 20개 이하일 때만 추가 (더 이상 에러 목록이 쌓이지 않도록)
        if (ErrorCommands.Count < 20)
        {
            errorCommand.Status = "Failed"; // 상태를 "Failed"로 변경
            errorCommand.CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff"); // 에러 발생 시간 기록
            ErrorCommands.Add(errorCommand); // 에러 리스트에 추가
        }
    });

    ShowAlarm("Queue has been stopped due to a Timeout or failure."); // 에러 알람 표시
}

// 알람 메시지를 UI에 추가하는 메서드
private void ShowAlarm(string message)
{
    var errorCommand = new CommandItem
    {
        CommandText = message, // 알람 메시지 설정
        Status = "Error", // 상태를 "Error"로 설정
        Result = 0, // 실패 상태로 설정
        RetryCount = 0, // 재시도 횟수 없음
        ResponseTime = 0, // 응답 시간 없음
        CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 알람 발생 시간 기록
    };

    // UI 스레드에서 에러 메시지를 에러 리스트박스에 추가
    App.Current.Dispatcher.Invoke(() =>
    {
        if (ErrorCommands.Count < 20) // 에러가 20개 이하일 때만 추가
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
        }
    });
}

// 프로그레스바 상태를 업데이트하는 메서드
private void UpdateProgress()
{
    // 남아 있는 명령의 개수에 따라 Progress 값을 업데이트
    Progress = commandQueue.Count;
}

// INotifyPropertyChanged 인터페이스의 OnPropertyChanged 메서드 구현
protected void OnPropertyChanged(string propertyName)
{
    // UI에 데이터가 변경되었음을 알림
    PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
}
주요 주석 설명:
작업 처리 상태 (Status):

명령이 처리 중일 때 "Processing"으로 상태가 바뀌며, 재시도 중일 때는 "Retrying"으로 상태가 표시됩니다.
재시도 실패 시에는 "Failed"로 상태가 업데이트되며, UI에 즉시 반영되도록 OnPropertyChanged가 호출됩니다.
재시도 처리 (Retrying):

RetryCount가 증가할 때마다 상태를 "Retrying {n}/{MaxRetryLimit}"로 표시하여 재시도 상태를 UI에 반영합니다.
에러 발생 시 처리 (StopQueueProcessing):

작업이 실패하거나 응답 시간이 초과될 때, 해당 명령의 상태를 "Failed" 또는 "Timeout"으로 업데이트하여 UI에도 반영됩니다.
비동기 작업 처리: 큐에 쌓인 작업들이 하나씩 비동기적으로 처리되며, 작업의 상태 변화가 UI에 실시간으로 반영됩니다.

이제 이 코드는 각 상태가 명확하게 UI에 표시되고, 작업의 진행 상황을 실시간으로 확인할 수 있습니다.