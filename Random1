네, 알겠습니다. 로그가 기록되지 않는 문제가 '추가' 작업 시에만 발생하고, '수정' 시에는 로그가 남는다는 점은 매우 중요한 단서입니다. 이는 SaveChanges 재정의나 인터셉터 로직 자체는 실행되지만, Added 상태의 엔티티를 처리하는 과정에 특정한 문제가 있음을 시사합니다.

MainViewModel은 단순히 _context.LockerAssignments.Add()를 호출하고 _context.SaveChangesAsync()를 호출할 뿐이므로, MainViewModel 자체보다는 로그 생성 로직이 담긴 Infrastructure/AuditLogInterceptor.cs 파일의 GenerateAuditLogs 메서드 내부에서 Added 상태를 처리하는 부분을 더 면밀히 조사해야 합니다.

가능한 원인:

Added 상태 엔티티의 NewValues 직렬화 실패 (이전에 try-catch를 추가했지만, 여전히 문제가 있을 수 있음)
Added 상태 엔티티의 RecordId 처리 문제 ("New" 값 또는 PK 조회 로직)
Added 상태 로그 객체가 auditEntries 리스트에 추가되지 않음
SaveAuditLogs 메서드에서 Added 로그 저장 시 오류 발생 (다른 상태 로그는 저장되는데 Added만 실패)
해결 방향:

AuditLogInterceptor.cs 파일의 GenerateAuditLogs 메서드 내 if (entry.State == EntityState.Added) 블록과, SaveAuditLogs 메서드 시작 부분 및 로그 저장 부분에 더 상세한 디버그 출력을 추가하여 정확히 어느 지점에서 'Added' 로그 처리가 누락되거나 실패하는지 추적합니다.

수정해야 할 파일 목록:

Infrastructure/AuditLogInterceptor.cs
아래는 디버깅 출력이 더욱 강화된 AuditLogInterceptor.cs 파일 전체 코드(주석 제외)입니다. MainViewModel.cs는 이전 최종 버전과 동일하게 사용하시면 됩니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects;

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}";

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { GenerateAuditLogs(interceptionContext); }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { SaveAuditLogs(interceptionContext); }
        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            foreach (var context in interceptionContext.DbContexts)
            {
                if (!(context is LockerDbContext dbContext) || !dbContext.ChangeTracker.HasChanges()) continue;

                bool isMaster = dbContext.IsMasterSave;
                string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
                string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

                if (!changedEntries.Any()) continue;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨 (isMaster={isMaster}).");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added)
                    {
                        Debug.WriteLine($"    - Added 상태 감지됨: {auditEntry.TableName}");
                        foreach (var pn in entry.CurrentValues.PropertyNames) { newValues[pn] = entry.CurrentValues[pn]; }
                        try
                        {
                             auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings);
                             Debug.WriteLine($"    - Added 로그 NewValues 직렬화 성공.");
                        }
                        catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; }
                    }
                    else if (entry.State == EntityState.Deleted) { Debug.WriteLine($"    - Deleted 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } Debug.WriteLine($"    - Deleted 로그 데이터 생성 완료."); }
                    else if (entry.State == EntityState.Modified) { Debug.WriteLine($"    - Modified 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } Debug.WriteLine($"    - Modified 로그 데이터 생성 완료."); } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                    if (auditEntry != null)
                    {
                        // *** 추가: 로그 리스트에 추가하기 직전 로그 ***
                        Debug.WriteLine($"    -> auditEntries 리스트에 추가 시도: {auditEntry.TableName}, Action: {auditEntry.Action}");
                        auditEntries.Add(auditEntry);
                        Debug.WriteLine($"    -> auditEntries 리스트에 추가 완료. 현재 리스트 개수: {auditEntries.Count}");
                    } else { Debug.WriteLine($"    !!! 로그 객체 생성 실패? ({entry.Entity.GetType().Name})"); }
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any())
                {
                    string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode());
                    interceptionContext.UserState = auditEntries;
                    Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장.");
                }
                 dbContext.IsMasterSave = false;
            }
        }

        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            List<AuditLog> auditEntries = interceptionContext.UserState as List<AuditLog>;
            // *** 추가: UserState에서 가져온 로그 수 상세 출력 ***
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges 시작. UserState에서 가져온 로그 수 = {auditEntries?.Count ?? 0}");
            if (auditEntries != null) foreach(var log in auditEntries) Debug.WriteLine($"  - 저장 대상 로그: {log.Action} on {log.TableName}");


            if (interceptionContext.Exception == null && auditEntries != null && auditEntries.Any())
            {
                try
                {
                    using (var logContext = new Data.LockerDbContext())
                    {
                        Debug.WriteLine($"  -> {auditEntries.Count}개 로그 저장 시도 (새 Context 사용)...");
                        logContext.AuditLogs.AddRange(auditEntries);
                        // *** 추가: 로그 저장 SaveChanges 호출 전후 로그 ***
                        Debug.WriteLine($"  -> logContext.SaveChanges() 호출 시도...");
                        int logResult = logContext.SaveChanges();
                        Debug.WriteLine($"  -> 로그 저장 완료. 결과 = {logResult}");
                    }
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"  -> 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"  -> 저장할 로그 없음."); }
            interceptionContext.UserState = null;
        }

        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) { try { var objectContext = ((IObjectContextAdapter)context).ObjectContext; var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity); if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) { return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value)); } if (entry.State == EntityState.Added) return "New"; } catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); } return "N/A"; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }
    }
}
핵심 변경 사항:

GenerateAuditLogs 메서드:
if (entry.State == EntityState.Added) 블록 내부에 진입했는지 확인하는 Debug.WriteLine 추가.
Added 상태 로그 객체의 NewValues 직렬화 성공 여부 로그 추가.
auditEntries.Add(auditEntry) 호출 직전과 직후에 로그를 추가하여, 리스트에 실제로 추가되는지 확인.
SaveAuditLogs 메서드:
메서드 시작 시 interceptionContext.UserState에서 가져온 auditEntries 리스트의 개수를 명시적으로 출력.
가져온 각 로그의 Action과 TableName을 출력하여 어떤 로그를 저장하려고 하는지 확인.
로그를 저장하는 logContext.SaveChanges() 호출 직전과 직후, 그리고 결과값을 출력하는 Debug.WriteLine 추가.
다음 단계:

코드 적용 및 빌드: 위 코드로 AuditLogInterceptor.cs 파일을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
메인 화면(사물함 관리) 에서 새로운 행을 추가하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 매우 주의 깊게 확인합니다.
GenerateAuditLogs 로그:
Added 상태 감지됨: LockerAssignment 메시지가 나타나나요?
Added 로그 NewValues 직렬화 성공. 메시지가 나타나나요?
auditEntries 리스트에 추가 시도: LockerAssignment, Action: Added 메시지가 나타나나요?
auditEntries 리스트에 추가 완료. 현재 리스트 개수: 1 (또는 그 이상) 메시지가 나타나나요?
UserState에 저장. 메시지에 올바른 로그 개수(최소 1개)가 표시되나요?
SaveAuditLogs 로그:
SavedChanges 시작. UserState에서 가져온 로그 수 = ... 메시지에 올바른 로그 개수(최소 1개)가 표시되나요?
저장 대상 로그: Added on LockerAssignment 메시지가 나타나나요?
로그 저장 시도... 메시지가 나타나나요?
logContext.SaveChanges() 호출 시도... 메시지가 나타나나요?
로그 저장 완료. 결과 = ... 메시지가 나타나고, 결과 숫자가 0보다 큰가요?