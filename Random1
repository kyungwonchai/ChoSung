// MemoAppMGSP.Server/Services/Implementations/ServerNotificationService.cs
using MemoAppMGSP.SharedModels; // 공유 모델 사용
using MemoAppMGSP.Server.Services.Interfaces; // 구현할 인터페이스
using Microsoft.AspNetCore.SignalR;         // SignalR Hub Context 사용
using Microsoft.EntityFrameworkCore;       // EF Core 사용
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using MemoAppMGSP.Server.Data;             // YourDbContext, SignalRConnection 사용
using MemoAppMGSP.Server;                 // MemoHub 네임스페이스

namespace MemoAppMGSP.Server.Services.Implementations
{
    /// <summary>
    /// IServerNotificationService 인터페이스의 구현체입니다.
    /// SignalR HubContext와 DB를 사용하여 알림을 발송합니다.
    /// </summary>
    public class ServerNotificationService : IServerNotificationService
    {
        private readonly IHubContext<MemoHub> _hubContext;
        private readonly YourDbContext _dbContext; // DB 컨텍스트 주입

        /// <summary>
        /// 생성자: IHubContext와 YourDbContext를 의존성 주입받습니다.
        /// </summary>
        /// <param name="hubContext">SignalR Hub 컨텍스트</param>
        /// <param name="dbContext">데이터베이스 컨텍스트</param>
        public ServerNotificationService(IHubContext<MemoHub> hubContext, YourDbContext dbContext)
        {
            _hubContext = hubContext ?? throw new ArgumentNullException(nameof(hubContext));
            _dbContext = dbContext ?? throw new ArgumentNullException(nameof(dbContext));
        }

        /// <summary>
        /// 지정된 사용자에게 새 메모 수신 알림을 비동기적으로 보냅니다.
        /// </summary>
        /// <param name="receiverUserId">메모를 받을 사용자의 ID</param>
        /// <param name="memo">전송된 메모 객체</param>
        public async Task NotifyMemoReceivedAsync(Guid receiverUserId, Memo memo)
        {
            List<string> connectionIds = new List<string>();
            try
            {
                // --- DB에서 해당 사용자의 활성 ConnectionId 목록 조회 (EF Core 사용) ---
                connectionIds = await _dbContext.SignalRConnections // DbContext 사용
                                        .Where(c => c.UserId == receiverUserId) // 받는 사람 ID로 필터링
                                        .Select(c => c.ConnectionId)         // ConnectionId 만 선택
                                        .AsNoTracking()                       // 읽기 전용 최적화
                                        .ToListAsync();                      // 비동기 리스트 변환
            }
            catch (Exception ex)
            {
                // TODO: 실제 로깅 프레임워크(Serilog, NLog 등)를 사용하여 오류 로깅
                Console.WriteLine($"[ERROR] NotifyMemoReceivedAsync - Error fetching connection IDs for user {receiverUserId}: {ex.Message}");
                // 오류가 발생해도 다른 로직에 영향을 주지 않도록 여기서 반환할 수 있음 (정책 결정 필요)
                return;
            }

            // 조회된 연결 ID가 하나 이상 있을 경우 메시지 발송
            if (connectionIds.Any()) // connectionIds.Count > 0 보다 Any() 사용 권장
            {
                try
                {
                    // "ReceiveMemo"는 클라이언트(SignalRNotificationService)에서 .On(...)으로 등록한 메서드 이름과 일치해야 함
                    // Clients(connectionIds) 를 사용하여 특정 ConnectionId 목록에게만 메시지 전송
                    await _hubContext.Clients.Clients(connectionIds).SendAsync("ReceiveMemo", memo);
                    Console.WriteLine($"[INFO] NotificationService: Sent memo '{memo?.Title}' to User {receiverUserId} via SignalR ({connectionIds.Count} connections).");
                }
                catch (Exception ex)
                {
                     // TODO: 로깅
                     Console.WriteLine($"[ERROR] NotifyMemoReceivedAsync - Error sending SignalR message to user {receiverUserId} ({string.Join(",", connectionIds)}): {ex.Message}");
                }
            }
            else
            {
                // 사용자가 현재 연결되어 있지 않은 경우
                Console.WriteLine($"[INFO] NotificationService: No active connections found for user {receiverUserId}. Memo notification not sent via SignalR.");
                // TODO: 오프라인 사용자 알림 처리 로직 (예: DB에 '읽지 않은 알림' 플래그 설정 또는 별도 테이블 기록)
            }
        }
    }
}