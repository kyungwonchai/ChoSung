실시간으로 초점을 맞추고, 이를 0.01초마다 빠르게 조정하려면 CameraX에서 제공하는 기본적인 자동 초점 기능을 사용하는 대신, 사용자 정의 방식으로 초점을 강제로 조정하는 방법을 고려할 수 있습니다. 다만, 이런 방식은 장치의 성능과 CameraX의 제약에 따라 다소 한계가 있을 수 있습니다.

초점 조정의 강제적 업데이트
아래 코드는 카메라의 자동 초점 기능을 0.01초마다 강제로 업데이트하도록 설정합니다. 이 코드는 장치의 성능에 따라 다르게 작동할 수 있으므로 최적의 결과를 얻으려면 여러 테스트가 필요합니다.

수정된 코드
kotlin
코드 복사
package com.dxmxsmd.mobilechecker

import android.Manifest
import android.content.pm.PackageManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.widget.TextView
import androidx.activity.ComponentActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var viewFinder: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var handler: Handler

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewFinder = findViewById(R.id.viewFinder)

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        cameraExecutor = Executors.newSingleThreadExecutor()
        handler = Handler(Looper.getMainLooper())
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val preview = Preview.Builder()
                .build()
                .also {
                    it.setSurfaceProvider(viewFinder.surfaceProvider)
                }

            val barcodeScanner = BarcodeScanning.getClient()

            val imageAnalysis = ImageAnalysis.Builder()
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor, { imageProxy ->
                        processImageProxy(barcodeScanner, imageProxy)
                    })
                }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                cameraProvider.unbindAll()
                val camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageAnalysis
                )

                // 초점 조정을 강제로 시도
                handler.post(object : Runnable {
                    override fun run() {
                        camera.cameraControl.startFocusAndMetering(
                            FocusMeteringAction.Builder(
                                viewFinder.meteringPointFactory.createPoint(
                                    viewFinder.width / 2f,
                                    viewFinder.height / 2f
                                ),
                                FocusMeteringAction.FLAG_AF
                            ).build()
                        )
                        handler.postDelayed(this, 10) // 10ms (0.01초)마다 반복
                    }
                })

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    private fun processImageProxy(barcodeScanner: BarcodeScanner, imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        val rawValue = barcode.rawValue
                        findViewById<TextView>(R.id.text_view_result).text = rawValue
                    }
                }
                .addOnFailureListener {
                    // Handle failure
                }
                .addOnCompleteListener {
                    imageProxy.close()
                }
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
        handler.removeCallbacksAndMessages(null) // 모든 핸들러 작업 중지
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)
    }
}
주요 내용:
강제 초점 조정:

Handler를 사용해 cameraControl.startFocusAndMetering()을 10ms마다 호출하여 초점 조정을 강제합니다.
FocusMeteringAction을 통해 중앙점에 초점을 맞추도록 설정했습니다.
카메라 사용 시 주기적 초점 조정:

이 방식은 장치에 따라 초점 조정이 지나치게 자주 발생하여 성능에 영향을 줄 수 있으므로 주의가 필요합니다.
해제 시 핸들러 작업 중지:

onDestroy에서 handler.removeCallbacksAndMessages(null)을 호출하여 모든 핸들러 작업을 중지합니다.
이 방법으로 CameraX의 기본 자동 초점 기능을 보완하여 초점을 더 자주 맞추도록 설정했습니다. 다만, 이 방식은 모든 디바이스에서 동일하게 효과적이지 않을 수 있으며, 성능 테스트가 필요합니