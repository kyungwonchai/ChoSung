폴더에 접근한 후 정상적으로 종료하고, 이후 다른 코드에 영향을 주지 않기 위한 C# 코드의 예제를 드리겠습니다. 여기서는 WindowsIdentity와 WindowsImpersonationContext를 사용하여 임퍼소네이션을 수행하고, 이후 정상적으로 원래 사용자 컨텍스트로 돌아오는 과정을 포함합니다.

csharp
Copy code
using System;
using System.Security.Principal;
using System.Runtime.InteropServices;

public class ImpersonationDemo
{
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool LogonUser(String lpszUsername, String lpszDomain, String lpszPassword, 
        int dwLogonType, int dwLogonProvider, out SafeTokenHandle phToken);

    [DllImport("kernel32.dll", CharSet = CharSet.Auto)]
    public extern static bool CloseHandle(IntPtr handle);

    public void AccessSharedFolder()
    {
        SafeTokenHandle safeTokenHandle;
        try
        {
            const int LOGON32_PROVIDER_DEFAULT = 0;
            const int LOGON32_LOGON_INTERACTIVE = 2;

            // Put your domain, username, and password here
            string domain = "DOMAIN";
            string username = "USERNAME";
            string password = "PASSWORD";

            bool returnValue = LogonUser(username, domain, password, 
                LOGON32_LOGON_INTERACTIVE, LOGON32_PROVIDER_DEFAULT, out safeTokenHandle);

            if (false == returnValue)
            {
                int ret = Marshal.GetLastWin32Error();
                Console.WriteLine("LogonUser failed with error code: " + ret);
                throw new System.ComponentModel.Win32Exception(ret);
            }

            using (safeTokenHandle)
            {
                using (WindowsImpersonationContext impersonatedUser = WindowsIdentity.Impersonate(safeTokenHandle.DangerousGetHandle()))
                {
                    // Access the shared folder
                    Console.WriteLine("Accessing shared folder...");
                    // Your code to access the shared folder here

                    // Revert to the original user
                    impersonatedUser.Undo();
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine("Exception occurred. " + ex.Message);
        }
    }

    public void OtherOperations()
    {
        // Your other code here, like finding the default printer
        // This code will run under the original user context
    }
}

public sealed class SafeTokenHandle : SafeHandleZeroOrMinusOneIsInvalid
{
    private SafeTokenHandle()
        : base(true) {}

    protected override bool ReleaseHandle()
    {
        return CloseHandle(handle);
    }
}

class Program
{
    static void Main()
    {
        ImpersonationDemo demo = new ImpersonationDemo();
        demo.AccessSharedFolder();
        demo.OtherOperations();
    }
}
이 코드에서는 다음을 수행합니다:

LogonUser 함수를 사용하여 임퍼소네이션을 시작합니다.
공유폴더에 접근하는 코드를 WindowsImpersonationContext 내부에서 실행합니다.
impersonatedUser.Undo()를 호출하여 원래 사용자 컨텍스트로 돌아갑니다.
OtherOperations 메서드는 원래 사용자 컨텍스트에서 실행되어, 임퍼소네이션으로 인한 영향을 받지 않습니다.
이렇게 하면 공유폴더 접근 후 다른 코드 실행 시 문제가 발생하지 않도록 할 수 있습니다. LogonUser를 사용할 때는 사용자 이름, 도메인, 비밀번호