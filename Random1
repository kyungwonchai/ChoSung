항상 돌고 있는 수신 루프 (ReceiveLoopAsync())를 유지.

모든 메시지는 수신 루프에서 잡히며, 분류 로직을 추가.

명령을 보낼 때마다 TaskCompletionSource로 비동기 응답을 안전하게 처리.

PLC의 선제 메시지 (OP_CLEAR)는 별도의 이벤트로 처리.

💡 코드 예시 (주석 매우 상세히 추가)
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // 서버와의 연결을 담당하는 TcpClient 객체
    private NetworkStream _stream; // 데이터를 송수신하기 위한 스트림
    private byte[] _buffer = new byte[1024]; // 수신 데이터를 저장할 버퍼 (1KB 크기)
    private bool _isConnected = false; // 서버와 연결 상태를 나타내는 플래그

    // 응답 대기를 위한 비동기 처리를 관리하는 리스트 (FIFO 방식)
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    // 선제 신호(OP_CLEAR)를 감지했을 때 발생시키는 이벤트
    public event Action OnOpClearReceived;

    /// <summary>
    /// 서버와 비동기로 연결을 수립하고, 수신 루프를 시작한다.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // 수신 루프를 비동기로 실행 (별도의 Task로 실행)
        _ = Task.Run(ReceiveLoopAsync); // 항상 돌아가면서 메시지를 감지
    }

    /// <summary>
    /// PLC로 명령을 보내고 해당 응답을 비동기로 기다린다.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected) return "[ERROR] Not connected.";

        // PLC 규칙에 따라 메시지를 STX와 ETX로 감싼다.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        // 응답을 받기 위한 TaskCompletionSource를 생성
        var tcs = new TaskCompletionSource<string>();
        string requestId = Guid.NewGuid().ToString("N"); // 고유한 요청 ID 생성
        _responseTasks.TryAdd(requestId, tcs);

        // 서버로 메시지 전송
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // 응답을 기다림 (수신 루프에서 응답이 오면 완료됨)
        string response = await tcs.Task;
        
        _responseTasks.TryRemove(requestId, out _); // 응답 처리 후 제거

        return response;
    }

    /// <summary>
    /// 서버로부터 오는 모든 데이터를 처리하는 수신 루프.
    /// OP_CLEAR 메시지를 별도로 처리하고, 명령 응답은 대응되는 Task로 반환한다.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // 데이터를 비동기로 읽음 (버퍼 크기: 1KB)
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 받은 데이터를 문자열로 변환하고 STX와 ETX를 제거
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                if (received == "OP_CLEAR")
                {
                    // 선제 신호(OP_CLEAR)를 감지했을 때 이벤트 발생
                    OnOpClearReceived?.Invoke();
                    Console.WriteLine("[EVENT] OP_CLEAR received and processed.");
                }
                else
                {
                    // 응답을 받아야 할 요청이 있는지 확인
                    foreach (var key in _responseTasks.Keys)
                    {
                        if (_responseTasks.TryRemove(key, out var tcs))
                        {
                            tcs.SetResult(received);
                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// 서버 연결을 해제한다.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
📌 코드 설명 (아주 상세하게)
SendAndReceiveAsync() 메서드:

요청을 보낼 때마다 TaskCompletionSource를 사용해서 비동기로 응답을 기다림.

PLC로 보내는 메시지는 원본 그대로 전송 (STX/ETX 포함).

응답은 ReceiveLoopAsync()에서 잡아서 처리.

ReceiveLoopAsync() 메서드:

항상 돌아가면서 메시지를 감지.

OP_CLEAR 메시지가 오면 즉시 이벤트로 감지 (OnOpClearReceived).

일반 메시지는 TaskCompletionSource로 대기 중인 요청에게 전달.

OnOpClearReceived 이벤트:

PLC에서 먼저 보내는 OP_CLEAR 신호를 잡기 위해 사용.

UI 또는 다른 클래스에서 이 이벤트를 등록해서 원하는 로직을 실행할 수 있음.

🔑 이 구조로 해결된 점
✅ PLC와의 규칙을 절대 깨지 않음 (명령은 원본 그대로 보냄).

✅ SendAndReceiveAsync()로 응답을 안전하게 비동기 처리.

✅ OP_CLEAR는 항상 별도로 감지 가능 (수신 루프에서 자동 감지).

✅ 응답이 꼬이지 않게 안전하게 처리됨.