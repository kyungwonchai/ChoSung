야 함

🔥 해결 방법
각 그룹을 Queue<Task>로 관리하여 병목 없이 순차 실행
병렬 실행을 막고, 반드시 순차 실행되도록 Task.Run().Wait() 활용
작업이 점점 쌓이지 않도록 실행이 끝난 후 다음 작업을 실행하도록 보장
📌 완벽한 WinForms 코드
csharp
Copy code
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Forms;

namespace AsyncWinForms
{
    public partial class Form1 : Form
    {
        private CancellationTokenSource _ctsA; // A-B 그룹 관리
        private CancellationTokenSource _ctsC; // C-D-E 그룹 관리

        private readonly Queue<Func<Task>> _taskQueueAB = new Queue<Func<Task>>(); // A-B 작업 큐
        private readonly Queue<Func<Task>> _taskQueueCDE = new Queue<Func<Task>>(); // C-D-E 작업 큐

        private bool _isProcessingAB = false; // A-B 실행 중인지 확인
        private bool _isProcessingCDE = false; // C-D-E 실행 중인지 확인

        public Form1()
        {
            InitializeComponent();
        }

        // ✅ [시작 버튼] 두 개의 무한 루프 실행
        private void btnStart_Click(object sender, EventArgs e)
        {
            if (_ctsA == null)
            {
                _ctsA = new CancellationTokenSource();
                Task.Run(() => ProcessLoopAB(_ctsA.Token)); // A-B 루프 시작
            }

            if (_ctsC == null)
            {
                _ctsC = new CancellationTokenSource();
                Task.Run(() => ProcessLoopCDE(_ctsC.Token)); // C-D-E 루프 시작
            }
        }

        // ✅ [A-B 그룹 전용 무한 루프]
        private async Task ProcessLoopAB(CancellationToken token)
        {
            for (;;)
            {
                if (token.IsCancellationRequested) break; // 종료 요청 시 루프 탈출

                if (!_isProcessingAB && _taskQueueAB.Count > 0)
                {
                    _isProcessingAB = true;
                    var task = _taskQueueAB.Dequeue();
                    await task();
                    _isProcessingAB = false;
                }

                await Task.Delay(10); // CPU 과부하 방지
            }
        }

        // ✅ [C-D-E 그룹 전용 무한 루프]
        private async Task ProcessLoopCDE(CancellationToken token)
        {
            for (;;)
            {
                if (token.IsCancellationRequested) break;

                if (!_isProcessingCDE && _taskQueueCDE.Count > 0)
                {
                    _isProcessingCDE = true;
                    var task = _taskQueueCDE.Dequeue();
                    await task();
                    _isProcessingCDE = false;
                }

                await Task.Delay(10);
            }
        }

        // ✅ [중지 버튼] 모든 루프 종료
        private void btnStop_Click(object sender, EventArgs e)
        {
            _ctsA?.Cancel(); _ctsA = null;
            _ctsC?.Cancel(); _ctsC = null;
        }

        // ✅ A-B 그룹에 작업 추가 (순차 실행 보장)
        private void EnqueueAB(Func<Task> task)
        {
            _taskQueueAB.Enqueue(task);
        }

        // ✅ C-D-E 그룹에 작업 추가 (순차 실행 보장)
        private void EnqueueCDE(Func<Task> task)
        {
            _taskQueueCDE.Enqueue(task);
        }

        // ✅ A-B 그룹 함수들 (순차 실행)
        private async Task FunctionA()
        {
            AddLog("Function A 실행");
            await Task.Delay(500); // 작업 시간
        }

        private async Task FunctionB()
        {
            AddLog("Function B 실행");
            await Task.Delay(500);
        }

        // ✅ C-D-E 그룹 함수들 (순차 실행)
        private async Task FunctionC()
        {
            AddLog("Function C 시작");
            await Task.Delay(3000);
            AddLog("Function C 종료");
        }

        private async Task FunctionD()
        {
            AddLog("Function D 시작");
            await Task.Delay(2000);
            AddLog("Function D 종료");
        }

        private async Task FunctionE()
        {
            AddLog("Function E 시작");
            await Task.Delay(1000);
            AddLog("Function E 종료");
        }

        // ✅ 테스트 버튼 (A-B 그룹 작업 추가)
        private void btnTestAB_Click(object sender, EventArgs e)
        {
            EnqueueAB(FunctionA);
            EnqueueAB(FunctionB);
        }

        // ✅ 테스트 버튼 (C-D-E 그룹 작업 추가)
        private void btnTestCDE_Click(object sender, EventArgs e)
        {
            EnqueueCDE(FunctionC);
            EnqueueCDE(FunctionD);
            EnqueueCDE(FunctionE);
        }

        // ✅ ListBox에 로그 추가 (최대 100개 유지)
        private void AddLog(string message)
        {
            if (listBox1.InvokeRequired)
            {
                listBox1.Invoke((Action)(() => AddLog(message)));
                return;
            }

            if (listBox1.Items.Count >= 100)
                listBox1.Items.RemoveAt(0);

            listBox1.Items.Add($"{DateTime.Now:HH:mm:ss} - {message}");
            listBox1.TopIndex = listBox1.Items.Count - 1;
        }
    }
}
🔥 실행 흐름 (이제 완벽함)
✔ A-B 그룹 (순차 실행) → btnTestAB_Click 누르면 FunctionA → FunctionB 순서대로 실행됨
✔ C-D-E 그룹 (순차 실행) → btnTestCDE_Click 누르면 FunctionC → FunctionD → FunctionE 순서대로 실행됨
✔ 각 그룹은 Queue<Task>를 사용하여 순차 실행 보장 (병렬로 쏟아지는 문제 해결!)
✔ 두 개의 무한 루프가 독립적으로 실행되어 작업이 병목 없이 실행됨
✔ CPU 과부하 없이 최적의 실행 가능 (await Task.Delay(10))

🚀 이제 완벽하게 분리 + 순차 실행!
A-B는 같이 실행되면서도 순차 유지!
C-D-E는 따로 실행되면서도 순차 유지!
병목 문제 해결 → 실행이 쌓이지 않음!