네, 로그 파일을 읽기-쓰기 공유 모드로 읽어오는 것이 맞습니다. 로그 파일이 다른 프로세스(예: 로그를 쓰는 프로세스)에 의해 열려 있을 때도 읽을 수 있어야 하며, 이 때문에 파일을 공유 모드로 열어야 합니다.

또한, 줄이 깨진 경우에는 그 줄을 처리하지 않고, 완전한 줄만 처리해야 합니다. 로그 파일이 쓰여지는 중간에 읽을 경우 줄이 끝나지 않았거나 불완전한 상태일 수 있으므로, 줄이 완전히 기록된 경우에만 인정해야 합니다.

수정된 코드: 읽기-쓰기 공유 모드 및 줄 깨짐 처리 추가
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileChecker
    {
        // 로그 파일이 위치한 디렉토리 경로
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 정규식 패턴: 파일 이름 규칙을 정의 (IP 주소 형식 + "_M4OI"로 시작)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 타이머: 주기적으로 파일 변경을 확인하기 위한 타이머
        private DispatcherTimer _timer;

        // 현재 감시 중인 파일 경로 (가장 최근 파일)
        private string _currentMonitoredFile;

        // 마지막 감지된 PLAN Selected 시간
        private DateTime _lastPlanSelectedDate;

        // 마지막으로 감시 중인 파일의 수정 시간
        private DateTime _lastWriteTime;

        // 현재 처리 중인 ProductOrder 객체
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (주문 목록을 실시간으로 갱신)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // 첫 실행 여부 체크
        private bool _isFirstExecution;

        // 생성자: 타이머를 초기화하고 설정하는 작업
        public FileChecker(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders;
            _isFirstExecution = true;

            // 타이머 초기화 및 설정 (1초마다 파일 상태를 확인)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 주기적으로 디렉토리 내 파일들을 확인
            _timer.Start(); // 타이머 시작

            // 처음 실행할 때 가장 최근 파일을 감시 대상으로 설정
            _currentMonitoredFile = GetLatestLogFile(); // 최근 파일을 가져옴
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 초기값 설정

            // 마지막 PLAN Selected 감지 시간을 현재 시간으로 초기화
            _lastPlanSelectedDate = DateTime.Now;
        }

        // 주기적으로 디렉토리 내 파일을 확인하는 메소드 (타이머에 의해 1초마다 호출)
        private void CheckFiles(object sender, EventArgs e)
        {
            // 현재 디렉토리에서 가장 최신 파일을 확인
            string latestFile = GetLatestLogFile();

            // 새로운 파일이 감지되었거나 현재 감시 중인 파일이 변경된 경우
            if (_currentMonitoredFile == null || latestFile != _currentMonitoredFile)
            {
                // 새로운 파일로 감시 대상을 변경
                _currentMonitoredFile = latestFile;
                _lastWriteTime = File.GetLastWriteTime(_currentMonitoredFile); // 마지막 수정 시간 업데이트
            }

            // 처음 실행일 때는 로그를 거슬러 올라가서 처음 나오는 "PLAN Selected"를 찾아 처리
            if (_isFirstExecution)
            {
                ProcessLogsFromBeginning(_currentMonitoredFile);
                _isFirstExecution = false; // 첫 실행 이후에는 실시간 감시로 전환
            }

            // 현재 감시 중인 파일의 마지막 수정 시간을 확인
            DateTime latestWriteTime = File.GetLastWriteTime(_currentMonitoredFile);

            // 파일이 수정된 경우에만 파일을 읽고 처리
            if (latestWriteTime > _lastWriteTime)
            {
                _lastWriteTime = latestWriteTime; // 마지막 수정 시간 업데이트
                ReadLogFile(_currentMonitoredFile); // 파일을 읽고 처리
            }
        }

        // 지정된 경로에서 가장 최근에 수정된 파일을 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 로그 파일 디렉토리에서 파일 목록을 가져와 패턴에 맞는 파일만 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일 필터링
                .OrderByDescending(f => f.LastWriteTime) // 수정 시간을 기준으로 내림차순 정렬
                .ToList();

            // 가장 최근에 수정된 파일의 경로 반환 (없을 경우 null 반환)
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일을 읽어 각 로그 라인을 처리하는 메소드 (읽기-쓰기 공유 모드로 파일을 읽음)
        private void ReadLogFile(string filePath)
        {
            try
            {
                // 파일을 읽기-쓰기 공유 모드로 열기 (다른 프로세스에서 파일을 쓰는 중에도 읽을 수 있음)
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    string line;
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        // 줄이 완전히 쓰여진 상태에서만 처리 (null이 아니고 완전한 줄이어야 함)
                        if (!string.IsNullOrWhiteSpace(line))
                        {
                            ProcessLogLine(line, filePath);
                        }
                    }
                }
            }
            catch (IOException ex)
            {
                // 파일을 읽는 중 예외가 발생한 경우 처리 (예: 파일 잠김)
                Console.WriteLine($"파일을 읽는 중 오류 발생: {ex.Message}");
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 날짜를 추출하여 yyyyMMdd 형식으로 변환
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 파일 이름의 마지막 두 글자를 날짜로 사용
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도와 월을 yyyyMM 형식으로 가져옴
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 날짜 조합

            // "PLAN Selected" 라인을 감지했을 때 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 분리하여 제품 주문 번호를 가져옴
                string productOrder = splitLine[1]; // 두 번째 값이 제품 주문 번호

                // 새로운 주문이거나 다른 주문일 경우 처리
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    // 최근 2일 이내에 PLAN Selected가 감지되지 않은 경우 처리
                    if (DateTime.Now.Subtract(_lastPlanSelectedDate).TotalDays > 2)
                    {
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder,
                            PDate = fullDate, // yyyyMMdd 형식으로 날짜 설정
                            POStatus = "wait" // 주문 상태를 "대기(wait)"로 설정
                        };
                        _productOrders.Add(_currentProductOrder); // 새로운 주문을 목록에 추가
                    }

                    // 마지막 PLAN Selected 감지 시간을 현재 시간으로 업데이트
                    _lastPlanSelectedDate = DateTime.Now;
                }
            }
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                var modelData = line.Split(':')[1].Trim(); // BasicModel 데이터를 추출
                _currentProductOrder.BasicModel = modelData; // 모델 데이터 저장
            }
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                var mbData = line.Split('^'); // MB^ 데이터를 처리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 설정
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 수량 설정
            }
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가
            }
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "stack"; // 상태를 "적재(stack)"로 변경
            }
            else if (line.Contains("JD^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "out"; // 상태를 "배출(out)"로 변경
                ExecuteOutFunction(); // 배출 처리 호출
            }
        }

        // 배출 처리를 위한 메소드
        private void ExecuteOutFunction()
        {
            // 배출 처리 로직 구현
        }

        // 첫 실행 시 로그 파일의 처음부터 PLAN Selected가 등장하는 시점까지 처리
        private void ProcessLogsFromBeginning(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 처리하지 않음

            // 파일을 읽기-쓰기 공유 모드로 열기
            using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            using (var streamReader = new StreamReader(fileStream))
            {
                string line;
                bool planSelectedFound = false;

                // 처음 등장하는 PLAN Selected 부분부터 처리
                while ((line = streamReader.ReadLine()) != null)
                {
                    if (!planSelectedFound && line.Contains("PLAN Selected"))
                    {
                        planSelectedFound = true; // PLAN Selected를 처음 찾았을 때 처리 시작
                    }

                    if (planSelectedFound && !string.IsNullOrWhiteSpace(line))
                    {
                        ProcessLogLine(line, filePath); // 이후 줄을 처리
                    }
                }
            }
        }
    }

    // ProductOrderModel 클래스: 제품 주문 정보를 저장하는 모델 클래스
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; } // 제품 주문 번호
        public string BasicModel { get; set; } // 제품 모델 정보
        public int PORemain { get; set; } // 잔여 수량
        public int MGCount { get; set; } // 매거진 당 제품 수량
        public int PCount { get; set; } // 생산된 제품 개수
        public string POStatus { get; set; } // 주문 상태 (대기, 적재, 배출 등)
        public string PDate { get; set; } // 제품 주문 날짜 (yyyyMMdd 형식)
    }
}
수정 사항
읽기-쓰기 공유 모드:

파일을 읽을 때, FileStream을 읽기-쓰기 공유 모드(FileShare.ReadWrite)로 열어, 다른 프로세스가 해당 파일에 쓰고 있는 중에도 파일을 읽을 수 있도록 했습니다.
줄이 깨진 경우 무시:

로그 파일에서 읽어온 줄이 **완전하지 않거나 깨진 경우(null 또는 빈 줄)**에는 그 줄을 무시하도록 처리했습니다.
ReadLine() 메소드로 파일의 각 줄을 읽을 때 완전한 줄만 처리하며, 빈 줄이나 null인 경우는 건너뜁니다.
설명
FileShare.ReadWrite: 다른 프로세스가 파일을 쓰는 중에도 읽을 수 있도록 파일을 공유 모드로 엽니다.
줄 깨짐 방지: 로그 파일에서 줄이 불완전하거나 깨진 경우에는 해당 줄을 처리하지 않고, 완전한 줄만 처리하여 로그 데이터를 신뢰성 있게 처리합니다.
이제 로그 파일이 지속적으로 쓰이는 중에도 안전하게 파일을 읽을 수 있으며, 불완전한 줄은 무시하고 완전한 줄만 처리할 수 있습