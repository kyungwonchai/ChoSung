이제 이해했습니다. 동일한 WPF DevExpress 프로그램을 다시 실행하면 새 인스턴스를 생성하지 않고 기존 인스턴스에 새로운 탭을 추가하는 방법을 설명하겠습니다. 이를 위해 싱글톤 패턴과 IPC(Inter-Process Communication)를 사용할 것입니다.

프로젝트 설정
Visual Studio에서 새 WPF 애플리케이션 프로젝트를 생성합니다.
NuGet 패키지 관리자에서 DevExpress WPF를 설치합니다.
MainWindow.xaml
MainWindow.xaml 파일에 탭 컨트롤과 버튼을 추가합니다.

xml
코드 복사
<Window x:Class="ClipboardNoteApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
        Title="Clipboard Note App" Height="450" Width="800">
    <Grid>
        <DockPanel>
            <Button x:Name="btnCheckClipboard" Content="Check Clipboard" DockPanel.Dock="Top" Click="BtnCheckClipboard_Click"/>
            <dx:DXTabControl x:Name="tabControl" DockPanel.Dock="Bottom">
                <!-- Tabs will be added here dynamically -->
            </dx:DXTabControl>
        </DockPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
MainWindow.xaml.cs 파일에 코드를 추가하여 클립보드 내용을 읽고 탭을 추가하는 로직을 구현합니다. 또한, 프로그램이 여러 번 실행되었을 때 새로운 인스턴스를 생성하지 않고 기존 인스턴스에 새로운 탭을 추가하도록 합니다.

csharp
코드 복사
using DevExpress.Xpf.Core;
using System;
using System.Diagnostics;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Interop;

namespace ClipboardNoteApp
{
    public partial class MainWindow : Window
    {
        private const string UniqueEventName = "ClipboardNoteApp_UniqueEvent";
        private static EventWaitHandle eventWaitHandle;

        public MainWindow()
        {
            InitializeComponent();
            InitializeEventWaitHandle();
        }

        private void InitializeEventWaitHandle()
        {
            bool createdNew;
            eventWaitHandle = new EventWaitHandle(false, EventResetMode.AutoReset, UniqueEventName, out createdNew);

            if (!createdNew)
            {
                SendMessageToRunningInstance(GetClipboardText());
                Application.Current.Shutdown();
            }
            else
            {
                StartListeningForMessages();
            }
        }

        private void StartListeningForMessages()
        {
            new System.Threading.Thread(() =>
            {
                while (true)
                {
                    eventWaitHandle.WaitOne();
                    Dispatcher.Invoke(() =>
                    {
                        string clipboardText = GetClipboardText();
                        if (!string.IsNullOrEmpty(clipboardText))
                        {
                            AddNewTabWithText(clipboardText);
                        }
                    });
                }
            }).Start();
        }

        private void SendMessageToRunningInstance(string message)
        {
            var hwnd = FindWindow(null, "Clipboard Note App");
            if (hwnd != IntPtr.Zero)
            {
                COPYDATASTRUCT cds = new COPYDATASTRUCT
                {
                    dwData = IntPtr.Zero,
                    lpData = message,
                    cbData = message.Length + 1
                };
                SendMessage(hwnd, WM_COPYDATA, IntPtr.Zero, ref cds);
            }
        }

        private const int WM_COPYDATA = 0x004A;

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, ref COPYDATASTRUCT lParam);

        private void BtnCheckClipboard_Click(object sender, RoutedEventArgs e)
        {
            string clipboardText = GetClipboardText();
            if (!string.IsNullOrEmpty(clipboardText))
            {
                AddNewTabWithText(clipboardText);
            }
        }

        private string GetClipboardText()
        {
            string clipboardText = string.Empty;
            if (Clipboard.ContainsText())
            {
                clipboardText = Clipboard.GetText();
            }
            return clipboardText;
        }

        private void AddNewTabWithText(string text)
        {
            var newTab = new DXTabItem
            {
                Header = DateTime.Now.ToString("yyMMddHHmmss"),
                Content = new TextBox
                {
                    Text = text,
                    AcceptsReturn = true,
                    VerticalScrollBarVisibility = ScrollBarVisibility.Auto
                }
            };
            tabControl.Items.Add(newTab);
            tabControl.SelectedItem = newTab;
        }

        protected override void OnSourceInitialized(EventArgs e)
        {
            base.OnSourceInitialized(e);
            HwndSource source = PresentationSource.FromVisual(this) as HwndSource;
            source.AddHook(WndProc);
        }

        private IntPtr WndProc(IntPtr hwnd, int msg, IntPtr wParam, IntPtr lParam, ref bool handled)
        {
            if (msg == WM_COPYDATA)
            {
                COPYDATASTRUCT cds = (COPYDATASTRUCT)Marshal.PtrToStructure(lParam, typeof(COPYDATASTRUCT));
                string message = cds.lpData;
                AddNewTabWithText(message);
                handled = true;
            }
            return IntPtr.Zero;
        }

        [StructLayout(LayoutKind.Sequential)]
        public struct COPYDATASTRUCT
        {
            public IntPtr dwData;
            public int cbData;
            [MarshalAs(UnmanagedType.LPStr)]
            public string lpData;
        }
    }
}
설명
클립보드 내용 가져오기: GetClipboardText 메서드에서 클립보드의 텍스트 내용을 가져옵니다.
탭 추가: AddNewTabWithText 메서드에서 새로운 탭을 생성하고 텍스트를 표시합니다.
프로그램 활성화: InitializeEventWaitHandle 메서드에서 EventWaitHandle을 사용하여 프로그램이 여러 번 실행되었을 때 기존 인스턴스에 새로운 탭을 추가합니다.
IPC 사용: SendMessageToRunningInstance와 StartListeningForMessages 메서드를 통해 IPC를 구현하여 메시지를 전달하고, 기존 인스턴스가 새로운 탭을 추가하도록 합니다.
이 코드는 동일한 WPF DevExpress 프로그램이 여러 번 실행되더라도 새로운 인스턴스를 생성하지 않고 기존 인스턴스에 탭을 추가하도록 합니다. 이로 인해 클립보드 내용을 메모장처럼 표시하는 페이지를 구현할 수 있습