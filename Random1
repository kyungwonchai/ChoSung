수명과 클래스명에 pop1을 붙여 혼동을 줄이도록 하겠습니다. System.Timers.Timer를 명시적으로 사용하고, 변수와 클래스명을 구분하기 쉽게 일관되게 수정한 코드를 제공합니다.

1. MainViewModelPop1 코드 (이벤트에 따라 에러 메시지 추가 및 제거)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media;
using System.Timers;

namespace YourNamespace
{
    public class MainViewModelPop1 : INotifyPropertyChanged
    {
        public event Action<string, bool> ErrorTriggeredPop1; // 에러 발생/해결 이벤트 (메시지, 추가 여부)

        private System.Timers.Timer _delayTimerPop1; // 3초 지연 타이머
        private WarningWindowPop1 _warningWindowPop1; // 경고창 인스턴스 저장
        private ObservableCollection<ErrorMessagePop1> _errorMessagesPop1; // 에러 메시지 목록

        public MainViewModelPop1()
        {
            _delayTimerPop1 = new System.Timers.Timer(3000);
            _delayTimerPop1.Elapsed += DelayTimerElapsedPop1;
            _delayTimerPop1.AutoReset = false;

            _errorMessagesPop1 = new ObservableCollection<ErrorMessagePop1>();

            // 에러 발생/해결 이벤트 구독
            ErrorTriggeredPop1 += HandleErrorEventPop1;
        }

        // 에러 이벤트 처리 (추가 또는 제거)
        private void HandleErrorEventPop1(string message, bool isAdd)
        {
            if (isAdd)
            {
                AddErrorMessagePop1(message);
            }
            else
            {
                RemoveErrorMessagePop1(message);
            }
        }

        private void AddErrorMessagePop1(string message)
        {
            if (_errorMessagesPop1.Any(m => m.ContentPop1 == message)) return;

            Color color = _errorMessagesPop1.Count % 2 == 0 ? Colors.Yellow : Colors.Aqua;
            _errorMessagesPop1.Add(new ErrorMessagePop1(message, new SolidColorBrush(color)));

            if (_errorMessagesPop1.Count == 1)
            {
                ShowWarningWindowPop1(); // 첫 메시지 추가 시 창 표시
            }
            else
            {
                UpdateWarningWindowPop1(); // 메시지 추가 시 창 업데이트
            }

            Debug.WriteLine($"[DEBUG] Error added: {message}");
        }

        private void RemoveErrorMessagePop1(string message)
        {
            var errorMessagePop1 = _errorMessagesPop1.FirstOrDefault(m => m.ContentPop1 == message);
            if (errorMessagePop1 != null)
            {
                _errorMessagesPop1.Remove(errorMessagePop1);
                Debug.WriteLine($"[DEBUG] Error removed: {message}");

                if (_errorMessagesPop1.Count == 0)
                {
                    CloseWarningWindowPop1(); // 메시지가 없으면 창 닫기
                }
                else
                {
                    UpdateWarningWindowPop1(); // 메시지 제거 시 창 업데이트
                }
            }
        }

        private void ShowWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _warningWindowPop1 = new WarningWindowPop1(_errorMessagesPop1);
                _warningWindowPop1.Topmost = true;
                _warningWindowPop1.Show();

                _warningWindowPop1.Closed += (sender, e) =>
                {
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed");
                };

                Debug.WriteLine("[DEBUG] Warning window shown");
            });
        }

        private void UpdateWarningWindowPop1()
        {
            if (_warningWindowPop1 != null)
            {
                _warningWindowPop1.UpdateMessagesPop1(_errorMessagesPop1);
                Debug.WriteLine("[DEBUG] Warning window updated");
            }
        }

        private void CloseWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_warningWindowPop1 != null)
                {
                    _warningWindowPop1.Close();
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed and messages cleared");
                }
            });
        }

        private void DelayTimerElapsedPop1(object sender, ElapsedEventArgs e)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessagesPop1.Count > 0)
                {
                    ShowWarningWindowPop1();
                }
            });
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ErrorMessagePop1
    {
        public string ContentPop1 { get; }
        public SolidColorBrush ColorPop1 { get; }

        public ErrorMessagePop1(string content, SolidColorBrush color)
        {
            ContentPop1 = content;
            ColorPop1 = color;
        }
    }
}
모든 변수, 메서드, 이벤트에 Pop1을 추가하여 명확하게 구분했습니다.
System.Timers.Timer을 명시적으로 사용하여, 네임스페이스로 모호함을 방지했습니다.
2. WarningWindowPop1.xaml
여러 메시지를 표시하기 위해 ItemsControl을 사용하여 템플릿을 구성합니다.

xml
코드 복사
<Window x:Class="YourNamespace.WarningWindowPop1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WarningPop1" Height="500" Width="500"
        WindowStyle="None" AllowsTransparency="True" Background="#AAFF0000"
        ShowInTaskbar="False" Topmost="True" ResizeMode="NoResize"
        WindowStartupLocation="CenterScreen" 
        MouseDown="Window_MouseDownPop1">
    <Grid>
        <ItemsControl ItemsSource="{Binding ErrorMessagesPop1}">
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding ContentPop1}"
                               FontSize="15"
                               Foreground="{Binding ColorPop1}"
                               TextAlignment="Center"
                               VerticalAlignment="Center"
                               HorizontalAlignment="Center"/>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>
    </Grid>
</Window>
WarningWindowPop1.xaml.cs
경고창에서 전달된 메시지를 실시간으로 업데이트할 수 있도록 ObservableCollection을 사용합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;

namespace YourNamespace
{
    public partial class WarningWindowPop1 : Window
    {
        public ObservableCollection<ErrorMessagePop1> ErrorMessagesPop1 { get; set; } = new ObservableCollection<ErrorMessagePop1>();

        public WarningWindowPop1(ObservableCollection<ErrorMessagePop1> errorMessagesPop1)
        {
            InitializeComponent();
            ErrorMessagesPop1 = errorMessagesPop1;
            DataContext = this;
        }

        public void UpdateMessagesPop1(ObservableCollection<ErrorMessagePop1> errorMessagesPop1)
        {
            ErrorMessagesPop1.Clear();
            foreach (var message in errorMessagesPop1)
            {
                ErrorMessagesPop1.Add(message);
            }
        }

        private void Window_MouseDownPop1(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            this.Close(); // 클릭하면 창 닫기
        }
    }
}
3. 외부 클래스에서 이벤트를 통한 에러 발생 및 해제
외부 클래스에서 MainViewModelPop1의 이벤트를 통해 에러를 발생시키고, 해제합니다.

csharp
코드 복사
namespace YourNamespace
{
    public class SampleErrorTriggerPop1
    {
        public event Action<string, bool> OnErrorPop1; // 에러 메시지 이벤트 (메시지, 추가 여부)

        public void TriggerErrorPop1(string message)
        {
            OnErrorPop1?.Invoke(message, true); // 에러 발생
        }

        public void ResolveErrorPop1(string message)
        {
            OnErrorPop1?.Invoke(message, false); // 에러 해결
        }
    }
}
MainWindow에서 이벤트 연결
SampleErrorTriggerPop1의 OnErrorPop1 이벤트를 MainViewModelPop1의 ErrorTriggeredPop1에 연결하여 에러 메시지가 추가되거나 제거될 때마다 창을 자동으로 제어합니다.

csharp
코드 복사
using System.Windows;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private MainViewModelPop1 _viewModelPop1;
        private SampleErrorTriggerPop1 _errorTriggerPop1;

        public MainWindow()
        {
            InitializeComponent();
            _viewModelPop1 = new MainViewModelPop1();
            DataContext = _viewModelPop1;

            _errorTriggerPop1 = new SampleErrorTriggerPop1();
            _errorTriggerPop1.OnErrorPop1 += _viewModelPop1.ErrorTriggeredPop1; // 이벤트 연결
        }

        private void OnAddErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTriggerPop1.TriggerErrorPop1("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
            _errorTriggerPop1.TriggerErrorPop1("Warning!\nNetwork connection lost.\nAttempting to reconnect...");
        }

        private void OnResolveErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTriggerPop1.ResolveErrorPop1("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
        }
    }
}
이제 OnAddErrorMessageClicked 버튼을 눌러 에러를 발생시키고, OnResolveErrorMessageClicked 버튼을 눌러 특정 에러 메시지를 제거할 수 있