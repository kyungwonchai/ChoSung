알겠습니다. .NET Desktop Framework (예: .NET Framework 4.7.2 또는 4.8)를 사용하여 WPF 프로그램 간 안정적인 소켓 통신 시스템을 구현하고, 제어 대상 IP를 프로그램 로딩 시 데이터베이스에서 가져오는 완전한 코드를 제공하겠습니다.

구성 단계:

데이터베이스 설정: 테이블 생성 SQL 스크립트 및 샘플 데이터 삽입 스크립트.
CoreLogicLibrary 프로젝트: 핵심 통신 및 비즈니스 로직 (클래스 라이브러리).
WpfApp 프로젝트: 사용자 인터페이스 및 프로그램 실행 로직 (WPF 애플리케이션).
사전 준비 사항:

.NET Framework: 4.7.2 이상 버전을 권장합니다.
Newtonsoft.Json: JSON 직렬화를 위해 NuGet 패키지 관리자에서 Newtonsoft.Json을 두 프로젝트 모두에 설치해야 합니다.
패키지 관리자 콘솔: Install-Package Newtonsoft.Json
SQL Server: 데이터베이스 예제는 SQL Server 기준으로 작성됩니다. 다른 DBMS를 사용하시는 경우 스크립트 수정이 필요할 수 있습니다.
Phase 1: 데이터베이스 설정 (SQL Server 기준)

1. 테이블 생성 스크립트 (CreateManagedPCsTable.sql)

SQL

IF OBJECT_ID('dbo.ManagedPCs', 'U') IS NOT NULL
    DROP TABLE dbo.ManagedPCs;
GO

CREATE TABLE dbo.ManagedPCs (
    PCID INT IDENTITY(1,1) PRIMARY KEY,
    PCName NVARCHAR(100) NOT NULL UNIQUE,
    IPAddress VARCHAR(50) NOT NULL,
    Port INT NOT NULL DEFAULT 12345, -- 기본 포트
    Description NVARCHAR(255) NULL,
    IsEnabled BIT NOT NULL DEFAULT 1, -- 이 PC를 제어 목록에 포함할지 여부
    LastHeartbeat DATETIME2 NULL -- 마지막 통신 성공 시간 (선택적 확장)
);
GO

CREATE INDEX IX_ManagedPCs_PCName ON dbo.ManagedPCs(PCName);
CREATE INDEX IX_ManagedPCs_IPAddress ON dbo.ManagedPCs(IPAddress);
GO

PRINT 'Table ManagedPCs created successfully.';
2. 샘플 데이터 삽입 스크립트 (InsertSamplePCs.sql)

SQL

-- 기존 샘플 데이터가 있다면 중복을 피하기 위해 정리 (선택적)
-- DELETE FROM ManagedPCs WHERE PCName IN ('개발용PC-01', '디자인팀PC', '서버실모니터링PC');

-- 샘플 데이터 삽입
INSERT INTO dbo.ManagedPCs (PCName, IPAddress, Port, Description, IsEnabled)
VALUES
('개발용PC-01', '192.168.0.101', 12345, '1번 개발자 자리 PC', 1),
('디자인팀PC', '192.168.0.102', 12345, '디자인팀 공용 PC', 1),
('서버실모니터링PC', '127.0.0.1', 12346, '로컬 테스트용 (다른 포트)', 1), -- 자기 자신을 다른 포트로 테스트
('비활성PC예시', '192.168.0.103', 12345, '현재 사용 안 함', 0);
GO

PRINT 'Sample data inserted into ManagedPCs successfully.';
SELECT * FROM dbo.ManagedPCs;
데이터베이스 연결 문자열 (App.config에 사용될 예시):

SQL Server Express를 로컬에 설치했고 Windows 인증을 사용하는 경우:
"Data Source=.\SQLEXPRESS;Initial Catalog=YourDatabaseName;Integrated Security=True;"

SQL Server 표준 버전을 사용하고 SQL 인증을 사용하는 경우:
"Data Source=YourServerAddress;Initial Catalog=YourDatabaseName;User ID=YourUserId;Password=YourPassword;"

YourDatabaseName을 실제 데이터베이스 이름으로 변경하십시오.

Phase 2: CoreLogicLibrary 프로젝트 (.NET Framework 클래스 라이브러리)

프로젝트를 새로 만들고 (예: SocketControl.Core), Newtonsoft.Json을 NuGet으로 설치합니다.

1. Models/CommandPacket.cs

C#

using Newtonsoft.Json;

namespace SocketControl.Core.Models
{
    public enum CommandAction
    {
        Execute, // 로컬 실행
        Relay    // 다른 IP로 중계
    }

    public enum MonitorCommandType
    {
        Off,
        On,
        Sleep
    }

    public class CommandPacket
    {
        public CommandAction Action { get; set; }
        public string TargetIpForRelay { get; set; } // Action이 Relay일 경우, 중계 대상 IP
        public string CommandType { get; set; } = string.Empty; // 예: "MONITOR_CONTROL"
        public string Payload { get; set; } = string.Empty; // 실제 명령 내용 (예: JSON 직렬화된 MonitorControlPayload)

        public string ToJson() => JsonConvert.SerializeObject(this);
        public static CommandPacket FromJson(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<CommandPacket>(json);
            }
            catch
            {
                // 로깅 또는 예외 처리 필요
                return null;
            }
        }
    }

    public class MonitorControlPayload
    {
        public MonitorCommandType MonitorAction { get; set; }

        public string ToJson() => JsonConvert.SerializeObject(this);
        public static MonitorControlPayload FromJson(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<MonitorControlPayload>(json);
            }
            catch
            {
                return null;
            }
        }
    }
}
2. Models/ManagedPC.cs

C#

using System;

namespace SocketControl.Core.Models
{
    public class ManagedPC
    {
        public int PCID { get; set; }
        public string PCName { get; set; }
        public string IPAddress { get; set; }
        public int Port { get; set; }
        public string Description { get; set; }
        public bool IsEnabled { get; set; }
        public DateTime? LastHeartbeat { get; set; } // UI 표시용 상태

        public override string ToString()
        {
            return $"{PCName} ({IPAddress}:{Port})";
        }
    }
}
3. Interfaces/ISocketCommunicator.cs

C#

using System;
using System.Threading;
using System.Threading.Tasks;
using SocketControl.Core.Models;

namespace SocketControl.Core.Interfaces
{
    public interface ISocketCommunicator : IDisposable
    {
        Task StartListeningAsync(int port, CancellationToken cancellationToken);
        Task SendCommandAsync(string targetIp, int targetPort, CommandPacket command, CancellationToken cancellationToken);

        event Func<CommandPacket, string, Task> CommandReceivedAsync; // CommandPacket, SourceIP
        event Action<string, LogLevel> LogMessage; // Message, Level
        event Action<string> ClientConnected; // Client IP:Port
        event Action<string> ClientDisconnected; // Client IP:Port
    }

    public enum LogLevel
    {
        Debug,
        Info,
        Warning,
        Error,
        Action
    }
}
4. Services/SocketCommunicator.cs

코드 스니펫

using System;
using System.Collections.Concurrent;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using SocketControl.Core.Interfaces;
using SocketControl.Core.Models;

namespace SocketControl.Core.Services
{
    public class SocketCommunicator : ISocketCommunicator
    {
        private TcpListener _listener;
        private readonly ConcurrentDictionary<string, TcpClient> _connectedClients = new ConcurrentDictionary<string, TcpClient>();
        private readonly TimeSpan _connectTimeout = TimeSpan.FromSeconds(5);
        private readonly TimeSpan _keepAliveInterval = TimeSpan.FromSeconds(30); // TCP Keep-alive (OS level)
        private readonly CancellationTokenSource _internalCts = new CancellationTokenSource(); // For internal task management

        public event Func<CommandPacket, string, Task> CommandReceivedAsync;
        public event Action<string, LogLevel> LogMessage;
        public event Action<string> ClientConnected;
        public event Action<string> ClientDisconnected;

        private void OnLog(string message, LogLevel level) => LogMessage?.Invoke(message, level);

        public async Task StartListeningAsync(int port, CancellationToken externalCancellationToken)
        {
            if (_listener != null)
            {
                OnLog($"Listener already started on port {port}.", LogLevel.Info);
                return;
            }

            using (var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(_internalCts.Token, externalCancellationToken))
            {
                try
                {
                    _listener = new TcpListener(IPAddress.Any, port);
                    _listener.Start();
                    OnLog($"Server started. Listening on port {port}...", LogLevel.Info);

                    while (!linkedCts.Token.IsCancellationRequested)
                    {
                        TcpClient client = await _listener.AcceptTcpClientAsync().WithCancellation(linkedCts.Token).ConfigureAwait(false);
                        string clientEndPoint = client.Client.RemoteEndPoint.ToString();
                        OnLog($"Client attempting to connect: {clientEndPoint}", LogLevel.Info);
                        
                        SetKeepAlive(client.Client, (ulong)_keepAliveInterval.TotalMilliseconds, 1000UL);

                        if (_connectedClients.TryAdd(clientEndPoint, client))
                        {
                            ClientConnected?.Invoke(clientEndPoint);
                            // Fire and forget is generally discouraged, but for client handling,
                            // we want the loop to continue accepting. Ensure HandleClientAsync is robust.
                            _ = HandleClientAsync(client, clientEndPoint, linkedCts.Token);
                        }
                        else
                        {
                            OnLog($"Failed to add client {clientEndPoint} (already exists or error). Closing new connection.", LogLevel.Warning);
                            client.Close();
                        }
                    }
                }
                catch (OperationCanceledException)
                {
                    OnLog("Listening operation was canceled.", LogLevel.Info);
                }
                catch (SocketException ex)
                {
                    OnLog($"SocketException in StartListeningAsync: {ex.Message} (Code: {ex.SocketErrorCode})", LogLevel.Error);
                }
                catch (Exception ex)
                {
                    OnLog($"Error in StartListeningAsync: {ex.Message}", LogLevel.Error);
                }
                finally
                {
                    StopListeningInternal();
                }
            }
        }
        
        private void SetKeepAlive(Socket socket, ulong time, ulong interval)
        {
            if (socket == null || !socket.Connected) return;
            try
            {
                byte[] SIO_KEEPALIVE_VALS = new byte[12];
                BitConverter.GetBytes(1U).CopyTo(SIO_KEEPALIVE_VALS, 0); // on/off
                BitConverter.GetBytes(time).CopyTo(SIO_KEEPALIVE_VALS, 4); // time ms
                BitConverter.GetBytes(interval).CopyTo(SIO_KEEPALIVE_VALS, 8); // interval ms
                socket.IOControl(IOControlCode.KeepAliveValues, SIO_KEEPALIVE_VALS, null);
            }
            catch (Exception ex)
            {
                OnLog($"Failed to set TCP Keep-Alive: {ex.Message}", LogLevel.Warning);
            }
        }

        private async Task HandleClientAsync(TcpClient client, string clientEndPoint, CancellationToken cancellationToken)
        {
            OnLog($"Handling client: {clientEndPoint}", LogLevel.Debug);
            try
            {
                using (client) // Ensures client is disposed when this method exits
                using (var stream = client.GetStream())
                {
                    byte[] lengthBuffer = new byte[4];

                    while (client.Connected && !cancellationToken.IsCancellationRequested)
                    {
                        int bytesRead = await ReadExactlyAsync(stream, lengthBuffer, 0, 4, cancellationToken).ConfigureAwait(false);
                        if (bytesRead < 4) // Connection closed or error
                        {
                            OnLog($"Length prefix read failed or incomplete from {clientEndPoint}. Expected 4, got {bytesRead}.", LogLevel.Debug);
                            break;
                        }

                        int messageLength = BitConverter.ToInt32(lengthBuffer, 0);
                        if (messageLength <= 0 || messageLength > 1 * 1024 * 1024) // 1MB limit
                        {
                            OnLog($"Invalid message length {messageLength} from {clientEndPoint}. Closing connection.", LogLevel.Warning);
                            break;
                        }

                        byte[] messageBuffer = new byte[messageLength];
                        bytesRead = await ReadExactlyAsync(stream, messageBuffer, 0, messageLength, cancellationToken).ConfigureAwait(false);
                        if (bytesRead < messageLength) // Connection closed or error during message read
                        {
                             OnLog($"Message body read failed or incomplete from {clientEndPoint}. Expected {messageLength}, got {bytesRead}.", LogLevel.Debug);
                            break;
                        }

                        string messageJson = Encoding.UTF8.GetString(messageBuffer, 0, bytesRead);
                        CommandPacket command = CommandPacket.FromJson(messageJson);

                        if (command != null && CommandReceivedAsync != null)
                        {
                            string sourceIp = ((IPEndPoint)client.Client.RemoteEndPoint).Address.ToString();
                            await CommandReceivedAsync(command, sourceIp).ConfigureAwait(false);
                        }
                        else if (command == null)
                        {
                            OnLog($"Failed to deserialize command from {clientEndPoint}. JSON: {messageJson}", LogLevel.Warning);
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                OnLog($"Client handling for {clientEndPoint} was canceled.", LogLevel.Info);
            }
            catch (IOException ex) when (ex.InnerException is SocketException se)
            {
                OnLog($"IOException (Socket: {se.SocketErrorCode}) with client {clientEndPoint}: {se.Message}", LogLevel.Warning);
            }
            catch (IOException ex)
            {
                OnLog($"IOException with client {clientEndPoint}: {ex.Message}", LogLevel.Warning);
            }
            catch (Exception ex)
            {
                OnLog($"Unhandled error handling client {clientEndPoint}: {ex.ToString()}", LogLevel.Error);
            }
            finally
            {
                if (_connectedClients.TryRemove(clientEndPoint, out _))
                {
                     OnLog($"Client {clientEndPoint} removed from active list.", LogLevel.Info);
                }
                // client.Close() is implicitly called by using statement
                ClientDisconnected?.Invoke(clientEndPoint);
                OnLog($"Connection with {clientEndPoint} closed.", LogLevel.Info);
            }
        }

        private async Task<int> ReadExactlyAsync(NetworkStream stream, byte[] buffer, int offset, int count, CancellationToken cancellationToken)
        {
            int totalBytesRead = 0;
            while (totalBytesRead < count)
            {
                if (cancellationToken.IsCancellationRequested) throw new OperationCanceledException();
                if (!stream.CanRead) throw new IOException("Stream is not readable.");
                
                int bytesRead = await stream.ReadAsync(buffer, offset + totalBytesRead, count - totalBytesRead, cancellationToken).ConfigureAwait(false);
                if (bytesRead == 0) break; // Stream ended
                totalBytesRead += bytesRead;
            }
            return totalBytesRead;
        }

        public async Task SendCommandAsync(string targetIp, int targetPort, CommandPacket command, CancellationToken cancellationToken)
        {
            TcpClient client = null;
            try
            {
                client = new TcpClient();
                SetKeepAlive(client.Client, (ulong)_keepAliveInterval.TotalMilliseconds, 1000UL);

                var connectTask = client.ConnectAsync(targetIp, targetPort);
                using (var timeoutCts = new CancellationTokenSource(_connectTimeout))
                using (var linkedCts = CancellationTokenSource.CreateLinkedTokenSource(cancellationToken, timeoutCts.Token))
                {
                    await connectTask.WithCancellation(linkedCts.Token).ConfigureAwait(false);
                }
                
                if (!client.Connected) // Should be redundant if WithCancellation throws, but as a safeguard
                {
                    throw new SocketException((int)SocketError.TimedOut);
                }

                using (var stream = client.GetStream())
                {
                    string jsonCommand = command.ToJson();
                    byte[] messageBytes = Encoding.UTF8.GetBytes(jsonCommand);
                    byte[] lengthPrefix = BitConverter.GetBytes(messageBytes.Length);

                    await stream.WriteAsync(lengthPrefix, 0, lengthPrefix.Length, cancellationToken).ConfigureAwait(false);
                    await stream.WriteAsync(messageBytes, 0, messageBytes.Length, cancellationToken).ConfigureAwait(false);
                    await stream.FlushAsync(cancellationToken).ConfigureAwait(false);
                    OnLog($"Command '{command.CommandType}' sent to {targetIp}:{targetPort}.", LogLevel.Info);
                }
            }
            catch (OperationCanceledException) // Handles both external cancellation and timeout
            {
                OnLog($"Send command to {targetIp}:{targetPort} was canceled or timed out.", LogLevel.Warning);
                throw;
            }
            catch (SocketException ex)
            {
                OnLog($"SocketException when sending to {targetIp}:{targetPort}: {ex.Message} (Code: {ex.SocketErrorCode})", LogLevel.Error);
                throw;
            }
            catch (Exception ex)
            {
                OnLog($"Error sending command to {targetIp}:{targetPort}: {ex.Message}", LogLevel.Error);
                throw;
            }
            finally
            {
                client?.Close(); // Ensures client is closed
            }
        }

        private void StopListeningInternal()
        {
            if (_listener == null) return;
            try
            {
                _listener.Stop();
                _listener = null;
                OnLog("Listener stopped.", LogLevel.Info);

                // Gracefully close all connected clients
                foreach (var clientPair in _connectedClients)
                {
                    clientPair.Value.Close(); // This will trigger HandleClientAsync to exit
                }
                _connectedClients.Clear();
            }
            catch (Exception ex)
            {
                OnLog($"Error stopping listener: {ex.Message}", LogLevel.Error);
            }
        }

        public void Dispose()
        {
            OnLog("Disposing SocketCommunicator.", LogLevel.Debug);
            _internalCts.Cancel(); // Signal all internal operations to stop
            StopListeningInternal();
            _internalCts.Dispose();
             GC.SuppressFinalize(this);
        }
    }

    // Helper extension for Task with CancellationToken, especially for non-cancellable operations like ConnectAsync prior to .NET Core
    // For NetworkStream.ReadAsync/WriteAsync, CancellationToken is directly supported.
    // For TcpClient.ConnectAsync, cancellation token support was added in later .NET versions.
    // This helper is more relevant if ConnectAsync itself doesn't take a CancellationToken or if you want more control.
    // .NET Framework's ConnectAsync doesn't directly accept a CancellationToken.
    internal static class TaskExtensions
    {
        public static async Task<T> WithCancellation<T>(this Task<T> task, CancellationToken cancellationToken)
        {
            var tcs = new TaskCompletionSource<bool>();
            using (cancellationToken.Register(s => ((TaskCompletionSource<bool>)s).TrySetResult(true), tcs))
            {
                if (task != await Task.WhenAny(task, tcs.Task).ConfigureAwait(false))
                {
                    throw new OperationCanceledException(cancellationToken);
                }
            }
            return await task.ConfigureAwait(false); // Propagate exceptions from original task
        }
         public static async Task WithCancellation(this Task task, CancellationToken cancellationToken)
        {
            var tcs = new TaskCompletionSource<bool>();
            using (cancellationToken.Register(s => ((TaskCompletionSource<bool>)s).TrySetResult(true), tcs))
            {
                if (task != await Task.WhenAny(task, tcs.Task).ConfigureAwait(false))
                {
                    throw new OperationCanceledException(cancellationToken);
                }
            }
            await task.ConfigureAwait(false); // Propagate exceptions from original task
        }
    }
}
5. Interfaces/ICommandHandler.cs

C#

using System.Threading.Tasks;
using SocketControl.Core.Models;

namespace SocketControl.Core.Interfaces
{
    public interface ICommandHandler
    {
        Task HandleAsync(CommandPacket command, string sourceIp);
    }
}
6. Services/LocalCommandExecutor.cs

C#

using System;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using SocketControl.Core.Interfaces;
using SocketControl.Core.Models;

namespace SocketControl.Core.Services
{
    public class LocalCommandExecutor : ICommandHandler
    {
        private readonly Action<string, LogLevel> _logAction;

        private const int HWND_BROADCAST = 0xFFFF;
        private const int WM_SYSCOMMAND = 0x0112;
        private const int SC_MONITORPOWER = 0xF170;
        private const int MONITOR_ON = -1;
        private const int MONITOR_LOW_POWER = 1;
        private const int MONITOR_OFF = 2;

        [DllImport("user32.dll", CharSet = CharSet.Auto)]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        public LocalCommandExecutor(Action<string, LogLevel> logAction)
        {
            _logAction = logAction;
        }

        private void Log(string message, LogLevel level) => _logAction?.Invoke(message, level);

        public Task HandleAsync(CommandPacket command, string sourceIp)
        {
            Log($"Executing local command '{command.CommandType}' from {sourceIp}. Payload: {command.Payload}", LogLevel.Info);

            if (command.CommandType == "MONITOR_CONTROL")
            {
                MonitorControlPayload monitorPayload = MonitorControlPayload.FromJson(command.Payload);
                if (monitorPayload != null)
                {
                    switch (monitorPayload.MonitorAction)
                    {
                        case MonitorCommandType.On:
                            SetMonitorState(MONITOR_ON);
                            Log("Monitor turned ON.", LogLevel.Action);
                            break;
                        case MonitorCommandType.Off:
                            SetMonitorState(MONITOR_OFF);
                            Log("Monitor turned OFF.", LogLevel.Action);
                            break;
                        case MonitorCommandType.Sleep:
                            SetMonitorState(MONITOR_LOW_POWER);
                            Log("Monitor set to SLEEP.", LogLevel.Action);
                            break;
                    }
                }
                else
                {
                    Log($"Failed to deserialize MonitorControlPayload: {command.Payload}", LogLevel.Warning);
                }
            }
            // Handle other local commands here
            return Task.CompletedTask;
        }

        private void SetMonitorState(int state)
        {
            // This P/Invoke call is generally safe from non-UI threads.
            SendMessage((IntPtr)HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)state);
        }
    }
}
7. Services/RelayCommandHandler.cs

C#

using System;
using System.Threading;
using System.Threading.Tasks;
using SocketControl.Core.Interfaces;
using SocketControl.Core.Models;

namespace SocketControl.Core.Services
{
    public class RelayCommandHandler : ICommandHandler
    {
        private readonly ISocketCommunicator _communicator;
        private readonly int _defaultRelayPort;
        private readonly Action<string, LogLevel> _logAction;

        public RelayCommandHandler(ISocketCommunicator communicator, int defaultRelayPort, Action<string, LogLevel> logAction)
        {
            _communicator = communicator;
            _defaultRelayPort = defaultRelayPort; // Consider making this configurable per relayed command if needed
            _logAction = logAction;
        }

        private void Log(string message, LogLevel level) => _logAction?.Invoke(message, level);

        public async Task HandleAsync(CommandPacket command, string sourceIp)
        {
            if (string.IsNullOrEmpty(command.TargetIpForRelay))
            {
                Log($"Relay command from {sourceIp} is missing TargetIpForRelay.", LogLevel.Warning);
                return;
            }

            Log($"Relaying command '{command.CommandType}' from {sourceIp} to {command.TargetIpForRelay}. Payload: {command.Payload}", LogLevel.Info);

            var commandToRelay = new CommandPacket
            {
                Action = CommandAction.Execute, // The relayed command should be executed by the final target
                CommandType = command.CommandType,
                Payload = command.Payload
                // TargetIpForRelay is not needed for the relayed packet itself
            };

            try
            {
                // Using a CancellationToken.None or a short timeout for relay operations
                // Consider passing a CancellationToken if long relay operations are possible
                await _communicator.SendCommandAsync(command.TargetIpForRelay, _defaultRelayPort, commandToRelay, CancellationToken.None);
                Log($"Successfully initiated relay of command to {command.TargetIpForRelay}.", LogLevel.Info);
            }
            catch (Exception ex)
            {
                Log($"Failed to relay command to {command.TargetIpForRelay}: {ex.Message}", LogLevel.Error);
            }
        }
    }
}
8. Services/CommandProcessor.cs

C#

using System;
using System.Threading.Tasks;
using SocketControl.Core.Interfaces;
using SocketControl.Core.Models;

namespace SocketControl.Core.Services
{
    public class CommandProcessor
    {
        private readonly ICommandHandler _localExecutor;
        private readonly ICommandHandler _relayHandler;
        private readonly Action<string, LogLevel> _logAction;

        public CommandProcessor(ICommandHandler localExecutor, ICommandHandler relayHandler, Action<string, LogLevel> logAction)
        {
            _localExecutor = localExecutor ?? throw new ArgumentNullException(nameof(localExecutor));
            _relayHandler = relayHandler ?? throw new ArgumentNullException(nameof(relayHandler));
            _logAction = logAction;
        }

        private void Log(string message, LogLevel level) => _logAction?.Invoke(message, level);

        public async Task ProcessIncomingCommandAsync(CommandPacket command, string sourceIp)
        {
            Log($"Processing command Action: {command.Action}, Type: {command.CommandType} from {sourceIp}", LogLevel.Debug);
            try
            {
                switch (command.Action)
                {
                    case CommandAction.Execute:
                        await _localExecutor.HandleAsync(command, sourceIp);
                        break;
                    case CommandAction.Relay:
                        await _relayHandler.HandleAsync(command, sourceIp);
                        break;
                    default:
                        Log($"Unknown command action: {command.Action}", LogLevel.Warning);
                        break;
                }
            }
            catch (Exception ex)
            {
                Log($"Error processing command from {sourceIp}: {ex.ToString()}", LogLevel.Error);
                // Optionally, send an error response back to the source
            }
        }
    }
}
9. Data/DatabaseHelper.cs

C#

using System;
using System.Collections.Generic;
using System.Data;
using System.Data.SqlClient;
using System.Threading.Tasks;
using SocketControl.Core.Models;

namespace SocketControl.Core.Data
{
    public class DatabaseHelper
    {
        private readonly string _connectionString;
        private readonly Action<string, Interfaces.LogLevel> _logAction;


        public DatabaseHelper(string connectionString, Action<string, Interfaces.LogLevel> logAction)
        {
            _connectionString = connectionString;
            _logAction = logAction;
        }

        private void Log(string message, Interfaces.LogLevel level) => _logAction?.Invoke(message, level);

        public async Task<List<ManagedPC>> GetEnabledManagedPCsAsync()
        {
            var pcs = new List<ManagedPC>();
            // For .NET Framework, SqlClient is in System.Data.SqlClient
            // For .NET Core/5+, it's Microsoft.Data.SqlClient (NuGet)
            // This code assumes .NET Framework context.
            try
            {
                using (var connection = new SqlConnection(_connectionString))
                {
                    await connection.OpenAsync().ConfigureAwait(false);
                    // Only fetch enabled PCs
                    string query = "SELECT PCID, PCName, IPAddress, Port, Description, IsEnabled, LastHeartbeat FROM dbo.ManagedPCs WHERE IsEnabled = 1 ORDER BY PCName;";
                    using (var command = new SqlCommand(query, connection))
                    {
                        using (var reader = await command.ExecuteReaderAsync().ConfigureAwait(false))
                        {
                            while (await reader.ReadAsync().ConfigureAwait(false))
                            {
                                pcs.Add(new ManagedPC
                                {
                                    PCID = reader.GetInt32(reader.GetOrdinal("PCID")),
                                    PCName = reader.GetString(reader.GetOrdinal("PCName")),
                                    IPAddress = reader.GetString(reader.GetOrdinal("IPAddress")),
                                    Port = reader.GetInt32(reader.GetOrdinal("Port")),
                                    Description = reader.IsDBNull(reader.GetOrdinal("Description")) ? null : reader.GetString(reader.GetOrdinal("Description")),
                                    IsEnabled = reader.GetBoolean(reader.GetOrdinal("IsEnabled")),
                                    LastHeartbeat = reader.IsDBNull(reader.GetOrdinal("LastHeartbeat")) ? (DateTime?)null : reader.GetDateTime(reader.GetOrdinal("LastHeartbeat"))
                                });
                            }
                        }
                    }
                }
                Log($"Successfully loaded {pcs.Count} enabled PCs from database.", Interfaces.LogLevel.Info);
            }
            catch (SqlException ex)
            {
                Log($"SQL Error loading PCs: {ex.Message}", Interfaces.LogLevel.Error);
                // Potentially throw a custom exception or return an empty list to allow app to start
            }
            catch (Exception ex)
            {
                Log($"General Error loading PCs: {ex.Message}", Interfaces.LogLevel.Error);
            }
            return pcs;
        }

        // Optional: Method to update LastHeartbeat (example)
        public async Task UpdatePCLastHeartbeatAsync(int pcId)
        {
            try
            {
                using (var connection = new SqlConnection(_connectionString))
                {
                    await connection.OpenAsync().ConfigureAwait(false);
                    string query = "UPDATE dbo.ManagedPCs SET LastHeartbeat = @HeartbeatTime WHERE PCID = @PCID;";
                    using (var command = new SqlCommand(query, connection))
                    {
                        command.Parameters.AddWithValue("@HeartbeatTime", DateTime.UtcNow);
                        command.Parameters.AddWithValue("@PCID", pcId);
                        await command.ExecuteNonQueryAsync().ConfigureAwait(false);
                    }
                }
                Log($"Updated heartbeat for PCID {pcId}.", Interfaces.LogLevel.Debug);
            }
            catch (Exception ex)
            {
                Log($"Error updating heartbeat for PCID {pcId}: {ex.Message}", Interfaces.LogLevel.Warning);
            }
        }
    }
}
Phase 3: WpfApp 프로젝트 (.NET Framework WPF 애플리케이션)

새 WPF 애플리케이션 프로젝트를 만들고 (예: SocketControl.UI), SocketControl.Core 프로젝트를 참조로 추가합니다. Newtonsoft.Json도 NuGet으로 설치합니다.

1. Common/ObservableObject.cs

C#

using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace SocketControl.UI.Common
{
    public class ObservableObject : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
2. Common/RelayCommand.cs

C#

using System;
using System.Windows.Input;

namespace SocketControl.UI.Common
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute;
        private readonly Predicate<object> _canExecute;

        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter) => _canExecute?.Invoke(parameter) ?? true;
        public void Execute(object parameter) => _execute(parameter);

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }

    public class RelayCommand<T> : ICommand
    {
        private readonly Action<T> _execute;
        private readonly Predicate<T> _canExecute;

        public RelayCommand(Action<T> execute, Predicate<T> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            if (parameter == null && typeof(T).IsValueType)
                return _canExecute?.Invoke(default(T)) ?? true;
            if (parameter == null || parameter is T)
                return _canExecute?.Invoke((T)parameter) ?? true;
            return false;
        }

        public void Execute(object parameter)
        {
             if (parameter == null && typeof(T).IsValueType)
                _execute(default(T));
            else
                _execute((T)parameter);
        }
        
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}
3. ViewModels/ManagedPCViewModel.cs

C#

using SocketControl.Core.Models;
using SocketControl.UI.Common;
using System;

namespace SocketControl.UI.ViewModels
{
    public class ManagedPCViewModel : ObservableObject
    {
        private readonly ManagedPC _pc;
        public ManagedPC PC => _pc;

        public int PCID => _pc.PCID;
        public string PCName => _pc.PCName;
        public string IPAddress => _pc.IPAddress;
        public int Port => _pc.Port;
        public string Description => _pc.Description;

        private string _status = "Unknown";
        public string Status
        {
            get => _status;
            set => SetProperty(ref _status, value);
        }
        
        private DateTime? _lastHeartbeatUi; // UI update for heartbeat
        public DateTime? LastHeartbeatUi
        {
            get => _lastHeartbeatUi;
            set
            {
                if (SetProperty(ref _lastHeartbeatUi, value))
                {
                    _pc.LastHeartbeat = value; // Keep model in sync if needed
                }
            }
        }


        public ManagedPCViewModel(ManagedPC pc)
        {
            _pc = pc ?? throw new ArgumentNullException(nameof(pc));
            LastHeartbeatUi = _pc.LastHeartbeat; // Initialize from model
        }
    }
}
4. Services/NetworkServiceManager.cs (이전 NetworkServiceManager 수정)

C#

using System;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using SocketControl.Core.Data;
using SocketControl.Core.Interfaces;
using SocketControl.Core.Models;
using SocketControl.Core.Services;

namespace SocketControl.UI.Services
{
    public class NetworkServiceManager : IDisposable
    {
        private readonly ISocketCommunicator _communicator;
        private readonly CommandProcessor _commandProcessor;
        private readonly DatabaseHelper _dbHelper;
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        
        private int _listeningPort = 12345; // Default, can be from config
        private int _defaultRemotePort = 12345; // Default, can be from config

        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();
        public ObservableCollection<ManagedPCViewModel> ManagedPCs { get; } = new ObservableCollection<ManagedPCViewModel>();
        public ObservableCollection<string> ConnectedClients { get; } = new ObservableCollection<string>();


        public NetworkServiceManager()
        {
            // Load ports from App.config if available
            if (int.TryParse(ConfigurationManager.AppSettings["ListeningPort"], out int lPort))
                _listeningPort = lPort;
            if (int.TryParse(ConfigurationManager.AppSettings["DefaultRemotePort"], out int rPort))
                _defaultRemotePort = rPort;

            string connectionString = ConfigurationManager.ConnectionStrings["DefaultConnection"]?.ConnectionString;
            if (string.IsNullOrEmpty(connectionString))
            {
                LogToUi("CRITICAL: Database connection string 'DefaultConnection' not found in App.config.", LogLevel.Error);
                // Potentially throw or handle gracefully if DB is optional
                // For this app, DB is essential for loading target PCs.
                MessageBox.Show("Database connection string is missing. Application will have limited functionality or exit.", "Configuration Error", MessageBoxButton.OK, MessageBoxImage.Error);
                // Environment.Exit(1); // Or allow to run without PC list
            }
            
            _dbHelper = new DatabaseHelper(connectionString, LogToUi);

            _communicator = new SocketCommunicator();
            _communicator.LogMessage += LogToUi; // Core lib's log
            _communicator.CommandReceivedAsync += OnCommandReceivedFromNetworkAsync;
            _communicator.ClientConnected += OnClientConnected;
            _communicator.ClientDisconnected += OnClientDisconnected;

            var localExecutor = new LocalCommandExecutor(LogToUi);
            // Default relay port should ideally also be configurable or part of ManagedPC model for relay nodes
            var relayHandler = new RelayCommandHandler(_communicator, _defaultRemotePort, LogToUi);
            _commandProcessor = new CommandProcessor(localExecutor, relayHandler, LogToUi);
        }

        private void OnClientConnected(string clientEndpoint)
        {
            Application.Current?.Dispatcher.Invoke(() =>
            {
                ConnectedClients.Add(clientEndpoint);
                LogToUi($"Peer connected: {clientEndpoint}", LogLevel.Info);
            });
        }

        private void OnClientDisconnected(string clientEndpoint)
        {
            Application.Current?.Dispatcher.Invoke(() =>
            {
                ConnectedClients.Remove(clientEndpoint);
                LogToUi($"Peer disconnected: {clientEndpoint}", LogLevel.Info);
            });
        }


        private void LogToUi(string message, LogLevel level)
        {
            string logEntry = $"[{level.ToString().ToUpper()}] {DateTime.Now:HH:mm:ss}: {message}";
            Application.Current?.Dispatcher.Invoke(() =>
            {
                if (LogMessages.Count > 200) // Limit log size
                {
                    LogMessages.RemoveAt(0);
                }
                LogMessages.Add(logEntry);
            });
        }

        public async Task InitializeAsync()
        {
            LogToUi("Initializing NetworkServiceManager...", LogLevel.Info);
            await LoadManagedPCsAsync();
            // Start listening for incoming commands
            _ = Task.Run(() => _communicator.StartListeningAsync(_listeningPort, _cts.Token));
        }
        
        public async Task LoadManagedPCsAsync()
        {
            LogToUi("Loading managed PCs from database...", LogLevel.Info);
            var pcs = await _dbHelper.GetEnabledManagedPCsAsync();
            Application.Current?.Dispatcher.Invoke(() =>
            {
                ManagedPCs.Clear();
                foreach (var pc in pcs)
                {
                    ManagedPCs.Add(new ManagedPCViewModel(pc));
                }
                LogToUi($"Loaded {ManagedPCs.Count} PCs.", LogLevel.Info);
            });
        }

        private Task OnCommandReceivedFromNetworkAsync(CommandPacket command, string sourceIp)
        {
            // This is already on a background thread from SocketCommunicator
            return _commandProcessor.ProcessIncomingCommandAsync(command, sourceIp);
        }

        public async Task SendCommandToPCAsync(ManagedPCViewModel pcViewModel, string commandType, string payloadJson, CommandAction action = CommandAction.Execute, string relayTargetIp = null)
        {
            if (pcViewModel == null)
            {
                LogToUi("Target PC ViewModel is null.", LogLevel.Warning);
                return;
            }

            var command = new CommandPacket
            {
                Action = action,
                CommandType = commandType,
                Payload = payloadJson,
                TargetIpForRelay = action == CommandAction.Relay ? relayTargetIp : null
            };

            string targetDisplay = $"{pcViewModel.PCName} ({pcViewModel.IPAddress}:{pcViewModel.Port})";
            if (action == CommandAction.Relay) targetDisplay += $" -> {relayTargetIp}";

            LogToUi($"Attempting to send '{commandType}' to {targetDisplay}...", LogLevel.Info);

            try
            {
                // Use a CancellationToken for the send operation if needed, e.g., _cts.Token or a new one.
                // For UI-triggered sends, a short timeout might be implicit in user expectation.
                await _communicator.SendCommandAsync(pcViewModel.IPAddress, pcViewModel.Port, command, _cts.Token);
                LogToUi($"Successfully sent '{commandType}' to {targetDisplay}.", LogLevel.Action);
                
                // Optional: Update heartbeat or status on successful send (not necessarily successful execution)
                // pcViewModel.Status = "Command Sent";
                // await _dbHelper.UpdatePCLastHeartbeatAsync(pcViewModel.PCID);
                // pcViewModel.LastHeartbeatUi = DateTime.UtcNow; // Assuming UTC for consistency
            }
            catch (OperationCanceledException)
            {
                LogToUi($"Send command to {targetDisplay} was canceled.", LogLevel.Warning);
                pcViewModel.Status = "Send Canceled/Timeout";
            }
            catch (Exception ex)
            {
                LogToUi($"Failed to send '{commandType}' to {targetDisplay}: {ex.Message}", LogLevel.Error);
                pcViewModel.Status = "Send Failed";
            }
        }

        // Specific command methods
        public async Task SendMonitorCommandAsync(ManagedPCViewModel pc, MonitorCommandType monitorAction)
        {
            if (pc == null) return;
            var payload = new MonitorControlPayload { MonitorAction = monitorAction };
            await SendCommandToPCAsync(pc, "MONITOR_CONTROL", payload.ToJson());
        }

        public async Task SendRelayMonitorCommandAsync(ManagedPCViewModel relayNode, string finalTargetIp, int finalTargetPort, MonitorCommandType monitorAction)
        {
            // Note: This assumes finalTargetPort is known. The CommandPacket currently only has TargetIpForRelay.
            // For simplicity, we'll assume the relayed command goes to the _defaultRemotePort on the finalTargetIp.
            // Or, the payload itself for "MONITOR_CONTROL" could be extended to include final target port if it varies.
            if (relayNode == null || string.IsNullOrEmpty(finalTargetIp)) return;

            var payload = new MonitorControlPayload { MonitorAction = monitorAction };
            var commandForRelayNode = new CommandPacket
            {
                Action = CommandAction.Relay,
                TargetIpForRelay = finalTargetIp, // The IP the relay node should forward to
                CommandType = "MONITOR_CONTROL", // The type of command to be relayed
                Payload = payload.ToJson() // The payload for the final target
            };
            
            string relayDisplay = $"{relayNode.PCName} ({relayNode.IPAddress}:{relayNode.Port})";
            string finalDisplay = $"{finalTargetIp}:{_defaultRemotePort}"; // Assuming default port for final target
            LogToUi($"Attempting to relay Monitor '{monitorAction}' via {relayDisplay} to {finalDisplay}...", LogLevel.Info);

            try
            {
                 // Send the "Relay this command" packet to the relayNode
                await _communicator.SendCommandAsync(relayNode.IPAddress, relayNode.Port, commandForRelayNode, _cts.Token);
                LogToUi($"Successfully sent relay request for Monitor '{monitorAction}' via {relayDisplay} to {finalDisplay}.", LogLevel.Action);
            }
            catch (OperationCanceledException)
            {
                LogToUi($"Relay request via {relayDisplay} to {finalDisplay} was canceled.", LogLevel.Warning);
            }
            catch (Exception ex)
            {
                LogToUi($"Failed to send relay request via {relayDisplay} to {finalDisplay}: {ex.Message}", LogLevel.Error);
            }
        }


        public void Dispose()
        {
            LogToUi("Disposing NetworkServiceManager and shutting down operations...", LogLevel.Info);
            _cts.Cancel(); // Signal cancellation to all operations
            _communicator?.Dispose();
            _cts.Dispose();
        }
    }
}
5. ViewModels/MainViewModel.cs

C#

using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using SocketControl.Core.Models; // For MonitorCommandType
using SocketControl.UI.Common;
using SocketControl.UI.Services;


namespace SocketControl.UI.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly NetworkServiceManager _networkService;
        public ObservableCollection<ManagedPCViewModel> ManagedPCs => _networkService.ManagedPCs;
        public ObservableCollection<string> LogMessages => _networkService.LogMessages;
        public ObservableCollection<string> ConnectedClientsList => _networkService.ConnectedClients;


        private ManagedPCViewModel _selectedPC;
        public ManagedPCViewModel SelectedPC
        {
            get => _selectedPC;
            set => SetProperty(ref _selectedPC, value);
        }

        private ManagedPCViewModel _selectedRelayNode;
        public ManagedPCViewModel SelectedRelayNode
        {
            get => _selectedRelayNode;
            set => SetProperty(ref _selectedRelayNode, value);
        }

        private string _finalTargetIpForRelay;
        public string FinalTargetIpForRelay
        {
            get => _finalTargetIpForRelay;
            set => SetProperty(ref _finalTargetIpForRelay, value);
        }


        public ICommand RefreshPCListCommand { get; }
        public ICommand SendMonitorOffCommand { get; }
        public ICommand SendMonitorOnCommand { get; }
        public ICommand SendMonitorSleepCommand { get; }
        public ICommand SendRelayMonitorOffCommand { get; }
        // Add more relay commands if needed

        public MainViewModel(NetworkServiceManager networkService)
        {
            _networkService = networkService ?? throw new System.ArgumentNullException(nameof(networkService));
            
            RefreshPCListCommand = new RelayCommand(async _ => await _networkService.LoadManagedPCsAsync());

            SendMonitorOffCommand = new RelayCommand<ManagedPCViewModel>(
                async pc => await _networkService.SendMonitorCommandAsync(pc, MonitorCommandType.Off),
                pc => pc != null);
            SendMonitorOnCommand = new RelayCommand<ManagedPCViewModel>(
                async pc => await _networkService.SendMonitorCommandAsync(pc, MonitorCommandType.On),
                pc => pc != null);
            SendMonitorSleepCommand = new RelayCommand<ManagedPCViewModel>(
                async pc => await _networkService.SendMonitorCommandAsync(pc, MonitorCommandType.Sleep),
                pc => pc != null);

            SendRelayMonitorOffCommand = new RelayCommand(
                async _ => await _networkService.SendRelayMonitorCommandAsync(SelectedRelayNode, FinalTargetIpForRelay, 0, MonitorCommandType.Off), // Port 0 -> default
                _ => SelectedRelayNode != null && !string.IsNullOrWhiteSpace(FinalTargetIpForRelay)
            );

            // Initialize: Load PCs and start listening
            // This should ideally be called after the ViewModel is constructed and UI is ready
            // For simplicity, can be here or triggered from MainWindow Loaded event.
            // Task.Run(async () => await _networkService.InitializeAsync()); // Run in background
        }
        
        public async Task InitializeAsync()
        {
            await _networkService.InitializeAsync();
        }
    }
}
6. App.xaml
(No changes needed from default, unless you add global styles/resources)

7. App.xaml.cs

C#

using System.Windows;
using SocketControl.UI.Services; // If NetworkServiceManager is used globally
using SocketControl.UI.ViewModels; // If MainViewModel is set here

namespace SocketControl.UI
{
    public partial class App : Application
    {
        // private NetworkServiceManager _networkServiceManager; // If managing globally

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Example of setting up MainViewModel and NetworkServiceManager
            // var networkService = new NetworkServiceManager();
            // var mainViewModel = new MainViewModel(networkService);
            // var mainWindow = new MainWindow { DataContext = mainViewModel };
            // await mainViewModel.InitializeAsync(); // Initialize after DataContext is set
            // mainWindow.Show();

            // If you prefer to initialize in MainWindow.xaml.cs's constructor or Loaded event,
            // then just standard startup:
            // var mainWindow = new MainWindow();
            // mainWindow.Show();
        }

        protected override void OnExit(ExitEventArgs e)
        {
            // If _networkServiceManager is global, dispose it here
            // _networkServiceManager?.Dispose();
            base.OnExit(e);
        }
    }
}
Note on App.xaml.cs: I've commented out one approach for global service manager. A common way is to instantiate NetworkServiceManager and MainViewModel in MainWindow.xaml.cs or use a simple DI container if the app grows. For this example, we'll instantiate them in MainWindow.xaml.cs.

8. MainWindow.xaml

XML

<Window x:Class="SocketControl.UI.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:SocketControl.UI"
        xmlns:vm="clr-namespace:SocketControl.UI.ViewModels"
        mc:Ignorable="d"
        Title="Socket Remote Control" Height="700" Width="1000"
        d:DataContext="{d:DesignInstance Type=vm:MainViewModel, IsDesignTimeCreatable=False}"
        Loaded="MainWindow_Loaded"
        Closing="MainWindow_Closing">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> <RowDefinition Height="200"/>  </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Horizontal" Margin="0,0,0,10">
            <Button Content="Refresh PC List" Command="{Binding RefreshPCListCommand}" Margin="0,0,10,0" Padding="5"/>
        </StackPanel>

        <Grid Grid.Row="1">
            <Grid.ColumnDefinitions>
                <ColumnDefinition Width="*"/>
                <ColumnDefinition Width="Auto"/>
                <ColumnDefinition Width="2*"/>
            </Grid.ColumnDefinitions>

            <GroupBox Header="Managed PCs" Grid.Column="0" Margin="0,0,5,0">
                <ListView ItemsSource="{Binding ManagedPCs}" SelectedItem="{Binding SelectedPC}" DisplayMemberPath="PCName" MaxHeight="500">
                    <ListView.View>
                        <GridView>
                            <GridViewColumn Header="Name" DisplayMemberBinding="{Binding PCName}" Width="150"/>
                            <GridViewColumn Header="IP Address" DisplayMemberBinding="{Binding IPAddress}" Width="120"/>
                            <GridViewColumn Header="Port" DisplayMemberBinding="{Binding Port}" Width="60"/>
                             <GridViewColumn Header="Status" DisplayMemberBinding="{Binding Status}" Width="100"/>
                        </GridView>
                    </ListView.View>
                </ListView>
            </GroupBox>

            <GridSplitter Grid.Column="1" Width="5" HorizontalAlignment="Center" VerticalAlignment="Stretch"/>

            <TabControl Grid.Column="2" Margin="5,0,0,0">
                <TabItem Header="Direct Control">
                    <StackPanel DataContext="{Binding SelectedPC}" Margin="10" IsEnabled="{Binding Path=IsNotNull}">
                        <TextBlock Text="{Binding PCName, StringFormat='Selected: {0}'}" FontWeight="Bold" Margin="0,0,0,10"/>
                        <TextBlock Text="{Binding IPAddress, StringFormat='IP: {0}'}"/>
                        <TextBlock Text="{Binding Port, StringFormat='Port: {0}'}"/>
                        <TextBlock Text="{Binding Description, StringFormat='Desc: {0}'}" TextWrapping="Wrap" Margin="0,0,0,10"/>
                        <TextBlock Text="{Binding Status, StringFormat='Status: {0}'}" Margin="0,0,0,10"/>

                        <Button Content="Monitor OFF" Command="{Binding DataContext.SendMonitorOffCommand, RelativeSource={RelativeSource AncestorType=Window}}" CommandParameter="{Binding}" Margin="0,5" Padding="5"/>
                        <Button Content="Monitor ON" Command="{Binding DataContext.SendMonitorOnCommand, RelativeSource={RelativeSource AncestorType=Window}}" CommandParameter="{Binding}" Margin="0,5" Padding="5"/>
                        <Button Content="Monitor SLEEP" Command="{Binding DataContext.SendMonitorSleepCommand, RelativeSource={RelativeSource AncestorType=Window}}" CommandParameter="{Binding}" Margin="0,5" Padding="5"/>
                    </StackPanel>
                </TabItem>
                <TabItem Header="Relay Control">
                    <StackPanel Margin="10">
                        <TextBlock Text="Relay Via Node:" Margin="0,0,0,5"/>
                        <ComboBox ItemsSource="{Binding DataContext.ManagedPCs, RelativeSource={RelativeSource AncestorType=Window}}"
                                  SelectedItem="{Binding DataContext.SelectedRelayNode, RelativeSource={RelativeSource AncestorType=Window}}"
                                  DisplayMemberPath="PCName" Margin="0,0,0,10"/>
                        
                        <TextBlock Text="Final Target IP:" Margin="0,0,0,5"/>
                        <TextBox Text="{Binding DataContext.FinalTargetIpForRelay, RelativeSource={RelativeSource AncestorType=Window}, UpdateSourceTrigger=PropertyChanged}" Margin="0,0,0,10}"/>

                        <Button Content="Relay Monitor OFF" 
                                Command="{Binding DataContext.SendRelayMonitorOffCommand, RelativeSource={RelativeSource AncestorType=Window}}" 
                                Margin="0,5" Padding="5"/>
                        </StackPanel>
                </TabItem>
            </TabControl>
        </Grid>
        
        <GroupBox Header="Connected Clients (Listening On This PC)" Grid.Row="2" Margin="0,10,0,0" MaxHeight="100">
            <ListBox ItemsSource="{Binding ConnectedClientsList}"/>
        </GroupBox>

        <GroupBox Header="Logs" Grid.Row="3" Margin="0,10,0,0">
            <ListBox ItemsSource="{Binding LogMessages}" HorizontalContentAlignment="Stretch">
                <ListBox.ItemContainerStyle>
                    <Style TargetType="ListBoxItem">
                        <Setter Property="Focusable" Value="False"/>
                    </Style>
                </ListBox.ItemContainerStyle>
            </ListBox>
        </GroupBox>
    </Grid>
</Window>
Helper IsNotNull for enabling UI based on selection: You might need a ValueConverter for IsEnabled="{Binding Path=IsNotNull}" or simply rely on Command.CanExecute. For simplicity, I've removed IsNotNull and commands directly use parameter.

9. MainWindow.xaml.cs

C#

using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows;
using SocketControl.UI.Services;
using SocketControl.UI.ViewModels;

namespace SocketControl.UI
{
    public partial class MainWindow : Window
    {
        private NetworkServiceManager _networkServiceManager;
        private MainViewModel _mainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            // Create services and view model
            _networkServiceManager = new NetworkServiceManager();
            _mainViewModel = new MainViewModel(_networkServiceManager);
            DataContext = _mainViewModel;
        }

        private async void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // Initialize after UI is loaded and DataContext is set
            if (_mainViewModel != null)
            {
                await _mainViewModel.InitializeAsync();
            }
        }
        
        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            _networkServiceManager?.Dispose();
        }
    }
}
10. App.config (WpfApp 프로젝트에 추가/수정)

XML

<?xml version="1.0" encoding="utf-8" ?>
<configuration>
  <startup> 
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" /> </startup>
  <connectionStrings>
    <add name="DefaultConnection" 
         connectionString="Data Source=.\SQLEXPRESS;Initial Catalog=YourPcControlDB;Integrated Security=True;Connect Timeout=15" 
         providerName="System.Data.SqlClient" />
  </connectionStrings>
  <appSettings>
    <add key="ListeningPort" value="12345"/>
    <add key="DefaultRemotePort" value="12345"/>
  </appSettings>
</configuration>
사용 방법 및 주의사항:

데이터베이스 설정:

SQL Server에 데이터베이스를 생성합니다 (예: YourPcControlDB).
제공된 CreateManagedPCsTable.sql 스크립트를 실행하여 테이블을 만듭니다.
InsertSamplePCs.sql 스크립트를 실행하여 샘플 데이터를 추가합니다 (IP 주소는 실제 환경에 맞게 수정).
WpfApp 프로젝트의 App.config 파일에 있는 DefaultConnection 연결 문자열을 실제 DB 설정에 맞게 수정합니다.
NuGet 패키지:

SocketControl.Core 및 SocketControl.UI 두 프로젝트 모두에 Newtonsoft.Json 패키지를 설치합니다.
빌드 및 실행:

솔루션을 빌드합니다.
SocketControl.UI 프로젝트를 시작 프로젝트로 설정하고 실행합니다.
프로그램이 시작되면 데이터베이스에서 제어 대상 PC 목록을 로드합니다.
목록에서 PC를 선택하고 "Direct Control" 탭에서 모니터 제어 명령을 보낼 수 있습니다.
"Relay Control" 탭에서 중계 노드 PC와 최종 대상 IP를 지정하여 명령을 중계할 수 있습니다. (중계 노드 PC에도 이 프로그램이 실행 중이고 리스닝 상태여야 합니다.)
방화벽:

각 PC에서 사용하는 리스닝 포트(기본값 12345)에 대해 Windows 방화벽 또는 기타 보안 소프트웨어에서 인바운드 연결을 허용해야 합니다.
안정성 및 오류 처리:

제공된 코드는 기본적인 오류 처리, 로깅, 비동기 작업 관리를 포함하고 있습니다.
SocketCommunicator는 메시지 프레이밍 (길이 접두사) 및 TCP Keep-Alive를 사용하여 안정성을 높이려고 시도합니다.
모든 IDisposable 객체는 Dispose 메서드나 using 구문을 통해 관리됩니다. NetworkServiceManager의 Dispose는 앱 종료 시 호출되어 내부 리소스를 정리합니다.
확장성:

새로운 로컬 명령을 추가하려면 LocalCommandExecutor를 수정하고, CommandPacket에 새 CommandType 및 Payload 구조를 정의하면 됩니다.