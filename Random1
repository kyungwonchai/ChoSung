extBlock은 본래 텍스트 표시용으로 설계된 컨트롤로, 텍스트 입력이나 커서 표시 기능을 지원하지 않습니다. 따라서 입력과 커서 이동이 필요한 경우 TextBlock 대신 TextBox나 RichTextBox를 사용해야 합니다. 하지만 TextBox에서는 Inlines와 같은 서식화 기능을 제공하지 않으므로, 텍스트를 형식화하면서도 커서를 활성화하려면 RichTextBox를 사용하는 것이 적절합니다.

RichTextBox 사용으로 다시 돌아가도록 하겠습니다.
RichTextBox는 텍스트의 서식화와 커서 이동을 모두 지원하므로, 여기서 이를 활용하여 구현하겠습니다.

1. XAML 설정
RichTextBox를 추가합니다.

xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <TextBox Name="g_searchTextBox1" Width="200" Margin="10" VerticalAlignment="Top" HorizontalAlignment="Left"/>
        <RichTextBox Name="g_textBoxA" Width="200" Height="100" Margin="10,50,0,0" VerticalAlignment="Top" HorizontalAlignment="Left" TextChanged="TextBoxA_TextChanged"/>
        <Button Name="g_loadButton1" Content="Load Data" Width="100" Height="30" Margin="220,10,0,0" VerticalAlignment="Top" HorizontalAlignment="Left" Click="LoadButton_Click"/>
        <dxg:GridControl Name="g_gridControl1" AutoGenerateColumns="False" ItemsSource="{Binding}" Margin="0,150,0,0">
            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="Column1" Header="Column 1" Width="100"/>
                <dxg:GridColumn FieldName="Column2" Header="Column 2" Width="150"/>
                <dxg:GridColumn FieldName="Column3" Header="Column 3" Width="200"/>
                <!-- 필요한 만큼 열 추가 -->
            </dxg:GridControl.Columns>
            <dxg:GridControl.View>
                <dxg:TableView AutoWidth="False" CellValueChanged="TableView_CellValueChanged"/>
            </dxg:GridControl.View>
        </dxg:GridControl>
    </Grid>
</Window>
2. C# 코드 설정
이제 RichTextBox를 사용하여 텍스트를 서식화하고 커서를 활성화하도록 C# 코드를 수정하겠습니다.

csharp
코드 복사
using System;
using System.Data;
using System.Data.SqlClient;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Media;
using DevExpress.Xpf.Grid;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private DataTable g_dataTable1;
        private SqlDataAdapter g_dataAdapter1;
        private SqlCommandBuilder g_commandBuilder1;
        private string g_connectionString1 = "your_connection_string_here";
        private string g_selectQuery1 = "SELECT * FROM Table_UFS_DRAM";

        public MainWindow()
        {
            InitializeComponent();
            g_searchTextBox1.TextChanged += SearchTextBox_TextChanged;
            (g_gridControl1.View as TableView).RowUpdated += TableView_RowUpdated;
        }

        private void LoadButton_Click(object sender, RoutedEventArgs e)
        {
            LoadData();
        }

        private void LoadData()
        {
            using (SqlConnection g_connection1 = new SqlConnection(g_connectionString1))
            {
                g_dataAdapter1 = new SqlDataAdapter(g_selectQuery1, g_connection1);
                g_commandBuilder1 = new SqlCommandBuilder(g_dataAdapter1);

                g_dataTable1 = new DataTable();
                g_dataAdapter1.Fill(g_dataTable1);

                // 명령을 명시적으로 설정
                g_dataAdapter1.UpdateCommand = g_commandBuilder1.GetUpdateCommand();
                g_dataAdapter1.InsertCommand = g_commandBuilder1.GetInsertCommand();
                g_dataAdapter1.DeleteCommand = g_commandBuilder1.GetDeleteCommand();

                g_gridControl1.ItemsSource = g_dataTable1.DefaultView;
            }
        }

        private void TableView_CellValueChanged(object sender, CellValueChangedEventArgs e)
        {
            UpdateDatabase();
        }

        private void UpdateDatabase()
        {
            try
            {
                using (SqlConnection g_connection1 = new SqlConnection(g_connectionString1))
                {
                    g_dataAdapter1.UpdateCommand.Connection = g_connection1;
                    g_dataAdapter1.InsertCommand.Connection = g_connection1;
                    g_dataAdapter1.DeleteCommand.Connection = g_connection1;

                    g_connection1.Open();
                    g_dataAdapter1.Update(g_dataTable1);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error updating database: " + ex.Message);
            }
        }

        private void SearchTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (g_dataTable1 != null)
            {
                string g_filter1 = g_searchTextBox1.Text;
                (g_gridControl1.ItemsSource as DataView).RowFilter = $"ColumnName LIKE '%{g_filter1}%'";
            }
        }

        private void TextBoxA_TextChanged(object sender, TextChangedEventArgs e)
        {
            string inputText = new TextRange(g_textBoxA.Document.ContentStart, g_textBoxA.Document.ContentEnd).Text.Trim();
            string dbValue = GetUFSMARKFromDatabase(g_searchTextBox1.Text);

            if (!string.IsNullOrEmpty(dbValue))
            {
                CompareAndHighlightText(g_textBoxA, inputText, dbValue);
            }
        }

        private string GetUFSMARKFromDatabase(string input)
        {
            string result = string.Empty;
            string query = "SELECT UFSMARK FROM Table_UFS_DRAM WHERE SomeColumn = @input";

            using (SqlConnection connection = new SqlConnection(g_connectionString1))
            {
                SqlCommand command = new SqlCommand(query, connection);
                command.Parameters.AddWithValue("@input", input);

                connection.Open();
                object dbResult = command.ExecuteScalar();
                if (dbResult != null)
                {
                    result = dbResult.ToString();
                }
            }

            return result;
        }

        private void CompareAndHighlightText(RichTextBox richTextBox, string inputText, string dbValue)
        {
            richTextBox.Document.Blocks.Clear();

            Paragraph paragraph = new Paragraph();
            int minLength = Math.Min(inputText.Length, dbValue.Length);

            for (int i = 0; i < minLength; i++)
            {
                if (inputText[i] == dbValue[i])
                {
                    paragraph.Inlines.Add(new Run(inputText[i].ToString()));
                }
                else
                {
                    paragraph.Inlines.Add(new Run(inputText[i].ToString()) { Foreground = Brushes.Red });
                }
            }

            // 남은 문자 처리
            if (inputText.Length > dbValue.Length)
            {
                for (int i = dbValue.Length; i < inputText.Length; i++)
                {
                    paragraph.Inlines.Add(new Run(inputText[i].ToString()) { Foreground = Brushes.Red });
                }
            }

            richTextBox.Document.Blocks.Add(paragraph);
        }
    }
}
주요 변경 사항
RichTextBox: RichTextBox를 사용하여 텍스트 서식화와 커서 활성화를 지원합니다.
TextBoxA_TextChanged: TextBox의 값을 변경할 때 RichTextBox에서 텍스트를 가져와 비교하고, RichTextBox에 결과를 표시합니다.
CompareAndHighlightText: RichTextBox의 텍스트를 비교하여 일치하지 않는 부분을 빨간색으로 표시합니다.
이 변경 사항을 통해 RichTextBox에서 텍스트를 서식화하고 커서를 활성화할 수 있으며, TextBoxA에 입력된 값이 변경될 때마다 데이터베이스에서 값을 가져와 비교하고, 일치하지 않는 부분을 빨간색으로 표시할 수 있습니