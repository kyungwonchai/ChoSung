되는 문제는 일반적으로 다음과 같은 원인으로 발생할 수 있습니다:

메시지 버퍼링 문제: NetworkStream.WriteAsync 메서드가 비동기적으로 데이터를 쓰기 때문에, 여러 개의 메시지가 동시에 전송될 수 있습니다. 이 경우, 메시지 경계가 분리되지 않아 여러 개의 메시지가 한 번에 처리될 수 있습니다.

클라이언트-서버 통신 문제: 클라이언트가 서버에 메시지를 보낼 때, 적절한 메시지 구분자(예: 줄바꿈 문자 \n 또는 특수 구분자)를 사용하지 않으면, 여러 메시지가 결합되어 전송될 수 있습니다.

버퍼 크기 문제: 클라이언트가 서버에서 데이터를 수신할 때, 수신 버퍼가 너무 커서 여러 개의 메시지를 한 번에 읽어버릴 수 있습니다.

해결 방안
메시지 구분자 추가: 각 메시지 끝에 줄바꿈 문자(\n) 또는 특수 구분자를 추가하여 서버가 메시지를 구분할 수 있게 합니다.

수신 측에서 메시지 분할 처리: 서버는 수신한 데이터를 구분자로 분할하여 개별 메시지로 처리해야 합니다.

수정된 LogService.cs
SendLogMessage 메서드를 수정하여 각 메시지 끝에 줄바꿈 문자를 추가합니다.

csharp
코드 복사
private async Task SendLogMessage(string message)
{
    try
    {
        // 네트워크 스트림과 TCP 클라이언트가 유효한지 확인
        if (_networkStream != null && _tcpClient != null && _tcpClient.Connected)
        {
            // 메시지 끝에 줄바꿈 문자를 추가하여 메시지 구분
            string messageWithDelimiter = message + "\n";
            byte[] data = Encoding.UTF8.GetBytes(messageWithDelimiter);
            await _networkStream.WriteAsync(data, 0, data.Length); // 메시지 전송
            Console.WriteLine("Log message sent to main UI server.");
        }
        else
        {
            throw new InvalidOperationException("Network stream or TCP client is not connected.");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error sending log message: {ex.Message}");
        _isConnected = false; // 전송 실패 시 연결 끊김으로 처리
        // 재시도 로직을 추가할 수 있음
    }
}
수신 측 처리
수신 측에서 메시지를 수신할 때, 데이터를 구분자로 분할하여 개별 메시지로 처리합니다.

MainWindow.xaml.cs에서 수신 처리 수정
csharp
코드 복사
private void StartListeningToLogs()
{
    Task.Run(async () =>
    {
        try
        {
            _tcpClient = new TcpClient("127.0.0.1", 9000); // 로컬호스트의 포트 9000에 연결
            _networkStream = _tcpClient.GetStream();

            byte[] buffer = new byte[1024];
            int bytesRead;
            StringBuilder messageBuilder = new StringBuilder();

            // 로그 메시지를 지속적으로 수신하여 UI에 표시
            while ((bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
            {
                string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                messageBuilder.Append(receivedData);

                // 메시지 구분자로 분할하여 개별 메시지로 처리
                string[] messages = messageBuilder.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);
                for (int i = 0; i < messages.Length - 1; i++)
                {
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add(messages[i])); // UI에 로그 메시지 추가
                }

                // 마지막 부분은 아직 완성되지 않은 메시지일 수 있으므로 저장
                messageBuilder.Clear();
                messageBuilder.Append(messages.Last());
            }
        }
        catch (Exception ex)
        {
            Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
        }
        finally
        {
            _networkStream?.Close();
            _tcpClient?.Close();
        }
    });
}
주요 변경점 설명
메시지 구분자 추가: SendLogMessage 메서드에서 각 메시지 끝에 줄바꿈 문자(\n)를 추가하여 메시지 구분자를 명확히 합니다.

수신 측 메시지 분할 처리:

수신 측에서는 messageBuilder를 사용하여 받은 데이터를 계속 추가하고, 줄바꿈 문자(\n)를 기준으로 메시지를 분할합니다.
분할된 메시지 배열에서 마지막 메시지는 완성되지 않은 메시지일 수 있으므로 messageBuilder에 다시 추가하여 다음 수신 시 완성합니다.
이 변경 사항을 적용하면, 여러 메시지가 한 줄에 겹쳐서 전송되는 문제를 해결할 수 있으며, 메시지 경계를 명확히 구분할 수 있습니다