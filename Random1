습니다. 디버그 로그 상으로는 저장이 성공한 것처럼 보이는데 실제로는 로그가 기록되지 않는 현상, 그리고 이전의 여러 오류들을 종합적으로 고려했을 때, DbContext의 SaveChanges 메서드를 재정의(override)하여 로그를 기록하는 방식 자체에 EF6와의 상호작용 문제가 있을 수 있다고 판단됩니다.

대신 Entity Framework 6의 인터셉터(Interceptor) 기능을 사용하는 방식으로 로그 기록 로직을 변경해 보겠습니다. 이 방식은 SaveChanges가 호출되기 전과 후에 특정 코드를 실행할 수 있게 해주어, 로그 기록 로직을 DbContext의 핵심 저장 로직과 분리하여 안정성을 높일 수 있습니다.

수정/추가해야 할 파일 목록:

Data/LockerDbContext.cs: 기존의 SaveChanges/SaveChangesAsync 재정의 및 관련 로그 생성 메서드를 모두 제거합니다. (기본 DbContext 기능만 남김)
Infrastructure/AuditLogInterceptor.cs (신규): 로그 기록 로직을 담당할 인터셉터 클래스를 새로 추가합니다.
App.xaml.cs: 애플리케이션 시작 시 위에서 만든 인터셉터를 Entity Framework에 등록합니다.
(ViewModels/MainViewModel.cs 와 ViewModels/MasterDataViewModel.cs의 SaveChangesAsync 호출 부분도 원래대로 await _context.SaveChangesAsync(_cts.Token); 또는 await _context.SaveChangesAsync(); 형태로 되돌려야 하지만, 일단 위 3개 파일을 먼저 적용합니다.)
아래에 이 3개 파일의 수정된 전체 코드(주석 제외)를 작성합니다.

1. Data/LockerDbContext.cs (수정 - SaveChanges 재정의 제거)

C#

using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Threading;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        private const string ConnectionStringName = "LockerDbConnection";

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();
            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        // *** 수정: SaveChanges 및 SaveChangesAsync 오버라이드 및 관련 헬퍼 메서드 제거 ***
        // 로그 기록 로직은 AuditLogInterceptor로 이동
    }
}
2. Infrastructure/AuditLogInterceptor.cs (신규 파일)

이 파일을 Infrastructure 폴더에 새로 추가하세요. NuGet 패키지 관리자에서 Newtonsoft.Json을 설치해야 합니다.

C#

using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception; // IDbCommandInterceptor 사용
using System.Diagnostics;
using System.Linq;

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings
        {
            ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
            PreserveReferencesHandling = PreserveReferencesHandling.None,
            Formatting = Formatting.None
        };

        // 임시 로그 저장을 위한 키 (Context 간 데이터 전달용)
        private const string AuditLogEntriesKey = "AuditLogEntries";

        // --- IDbCommandInterceptor 인터페이스 구현 ---

        // NonQueryExecuting/ed: INSERT, UPDATE, DELETE 명령 실행 전/후 (SaveChanges 호출 시)
        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            GenerateAuditLogs(interceptionContext);
        }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            SaveAuditLogs(interceptionContext);
        }

        // ReaderExecuting/ed: SELECT 명령 실행 전/후 (여기서는 로깅 불필요)
        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }

        // ScalarExecuting/ed: 단일 값 반환 명령 실행 전/후 (여기서는 로깅 불필요)
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        // --- 로깅 로직 ---

        /// <summary>
        /// SaveChanges 실행 전에 호출되어 변경 내용을 기반으로 로그를 생성하고 UserState에 저장합니다.
        /// </summary>
        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            // 여러 DbContext가 사용될 수 있으므로 각 Context별로 처리
            foreach (var context in interceptionContext.DbContexts)
            {
                if (context == null || !(context is DbContext dbContext)) continue;

                string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                    .ToList();

                if (!changedEntries.Any()) continue; // 변경된 엔티티 없으면 다음 Context로

                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavingChanges: Context '{dbContext.GetType().Name}' 에서 {changedEntries.Count}개 변경 감지됨.");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                    else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                    else if (entry.State == EntityState.Modified) { bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }
                    auditEntries.Add(auditEntry);
                    Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}");
                }
                UpdateLockerAssignmentTimestamps(changedEntries); // 타임스탬프 업데이트는 여기서도 필요

                // 생성된 로그 목록을 UserState에 저장하여 SavedChanges에서 접근 가능하도록 함
                if (auditEntries.Any())
                {
                    interceptionContext.UserState = auditEntries;
                }
            }
        }

        /// <summary>
        /// SaveChanges 실행 성공 후에 호출되어 UserState에 저장된 로그를 DB에 저장합니다.
        /// </summary>
        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            // 작업이 성공했고(예외 없음), UserState에 저장된 로그가 있으면
            if (interceptionContext.Exception == null && interceptionContext.UserState is List<AuditLog> auditEntries && auditEntries.Any())
            {
                // 별도의 DbContext 인스턴스를 사용하여 로그 저장 (중요: 루프 방지)
                // 또는 원래 컨텍스트를 조심스럽게 사용 (여기서는 별도 인스턴스 사용)
                try
                {
                    using (var logContext = new Data.LockerDbContext()) // 새 컨텍스트 사용
                    {
                        Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: {auditEntries.Count}개 로그 저장 시도...");
                        logContext.AuditLogs.AddRange(auditEntries);
                        logContext.SaveChanges(); // 로그만 저장
                        Debug.WriteLine($"  -> 로그 저장 완료.");
                    }
                }
                catch (Exception ex)
                {
                    // 로그 저장 실패는 기록만 하고 무시
                    Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor): {ex.ToString()}");
                }
            }
            else if (interceptionContext.Exception != null)
            {
                 Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}");
            }
            else
            {
                 Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: 저장할 로그 없음.");
            }
        }

        // 엔티티 타입에서 실제 테이블 이름 가져오기 (선택 사항, 더 정확한 로깅 위해)
        private string GetTableName(DbEntityEntry entry)
        {
            // 간단히 클래스 이름 사용
            return entry.Entity.GetType().Name;
            // 또는 EF 메타데이터 사용 (더 복잡)
            // var objectContext = ((IObjectContextAdapter)entry.Context).ObjectContext;
            // var objectSet = objectContext.CreateObjectSet(entry.Entity.GetType());
            // return objectSet.EntitySet.Name;
        }

        // 엔티티의 기본 키 값 가져오기 (EF6 메타데이터 사용)
        private string GetPrimaryKeyValue(DbEntityEntry entry)
        {
            try
            {
                var objectStateEntry = ((IObjectContextAdapter)entry.Context).ObjectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity);
                if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0)
                {
                    // 복합키인 경우 콤마로 구분하여 반환
                    return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value));
                }
                // Added 상태이고 Identity 키인 경우 아직 키 값이 없을 수 있음
                if (entry.State == EntityState.Added) return "New";
            }
            catch (Exception ex)
            {
                 Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}");
            }
            return "N/A";
        }

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries)
        {
            var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified));
            int count = 0;
            foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; }
            if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨.");
        }
    }
}
3. App.xaml.cs (수정)

OnStartup 메서드에서 DbInterception.Add()를 사용하여 위에서 만든 인터셉터를 등록합니다.

C#

using System;
using System.Diagnostics;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using System.Data.Entity.Infrastructure.Interception; // DbInterception 사용
using LockerManagementApp.Infrastructure; // AuditLogInterceptor 네임스페이스

namespace LockerManagementApp
{
    public partial class App : Application
    {
        public static bool IsShuttingDown { get; private set; } = false;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // *** 수정: AuditLogInterceptor 등록 ***
            DbInterception.Add(new AuditLogInterceptor());
            Debug.WriteLine("AuditLogInterceptor 등록 완료.");

            SetupGlobalExceptionHandling();
            Debug.WriteLine("애플리케이션 시작됨.");
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Debug.WriteLine("애플리케이션 종료 시작됨.");
            IsShuttingDown = true;
            base.OnExit(e);
            Debug.WriteLine("애플리케이션 종료 완료.");
        }

        #region 전역 예외 처리 (Global Exception Handling)
        private void SetupGlobalExceptionHandling()
        {
            DispatcherUnhandledException += App_DispatcherUnhandledException;
            TaskScheduler.UnobservedTaskException += TaskScheduler_UnobservedTaskException;
            AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
            Debug.WriteLine("전역 예외 처리기 설정 완료.");
        }
        private void App_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e) { Debug.WriteLine("--- DispatcherUnhandledException 발생 ---"); LogAndShowException(e.Exception, "UI Thread Exception"); e.Handled = true; }
        private void TaskScheduler_UnobservedTaskException(object sender, UnobservedTaskExceptionEventArgs e) { Debug.WriteLine("--- TaskScheduler_UnobservedTaskException 발생 ---"); LogAndShowException(e.Exception, "Background Task Exception"); e.SetObserved(); }
        private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e) { Debug.WriteLine("--- CurrentDomain_UnhandledException 발생 ---"); LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception", !e.IsTerminating); }
        private void LogAndShowException(Exception exception, string source, bool showMessageBox = true) { string errorMessage = $"예기치 않은 오류 발생 ({source}):\n\n{exception.ToString()}"; Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}"); if (showMessageBox && !IsShuttingDown) { try { MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception msgEx) { Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}"); } } }
        #endregion
    }
}
핵심 변경 사항:

LockerDbContext.cs: SaveChanges/SaveChangesAsync 재정의 및 관련 헬퍼 메서드를 모두 제거했습니다. 로그 기록 로직은 이제 인터셉터가 담당합니다.
Infrastructure/AuditLogInterceptor.cs (신규):
IDbCommandInterceptor 인터페이스를 구현합니다.
NonQueryExecuting 메서드: SaveChanges가 DB 명령을 실행하기 전에 호출됩니다. 여기서 변경된 엔티티를 감지하고 로그(AuditLog 객체)를 생성하여 interceptionContext.UserState에 임시 저장합니다.
NonQueryExecuted 메서드: SaveChanges의 DB 명령 실행이 성공적으로 완료된 후 호출됩니다. UserState에 저장된 로그 목록을 가져와 별도의 DbContext 인스턴스를 사용하여 AuditLogs 테이블에 저장합니다. (로그 저장 실패는 원본 작업에 영향을 주지 않습니다.)
App.xaml.cs: OnStartup 메서드에서 DbInterception.Add(new AuditLogInterceptor());를 호출하여 애플리케이션 시작 시 EF6에 인터셉터를 등록합니다.
다음 단계:

NuGet 패키지: Newtonsoft.Json 패키지가 설치되어 있는지 확인합니다.
코드 적용 및 빌드: 위 코드로 해당 파일들을 업데이트/추가하고 솔루션을 다시 빌드합니다.
ViewModel 수정 확인: MainViewModel.cs 와 MasterDataViewModel.cs 에서 SaveChangesAsync 호출 시 isMaster 플래그를 전달하던 부분을 제거하고, 원래의 await _context.SaveChangesAsync(); 또는 await _context.SaveChangesAsync(cancellationToken); 형태로 되돌려야 합니다. (이전 단계에서 DbContext의 관련 오버로드를 제거했기 때문입니다.)