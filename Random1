 ëª¨ë¸ ì •ì˜ (MLP + ì •ê·œí™” + ë“œë¡­ì•„ì›ƒ ì ìš©)
python
Copy code
import torch
import torch.nn as nn
import torch.optim as optim
import torch.utils.data as data_utils

# ğŸ“Œ MLP ê¸°ë°˜ ëª¨ë¸ ì •ì˜ (ì •ê·œí™” + ë“œë¡­ì•„ì›ƒ ì ìš©)
class QRMLPModel(nn.Module):
    def __init__(self, input_size, num_classes, dropout_rate=0.3):
        super(QRMLPModel, self).__init__()
        self.fc1 = nn.Linear(input_size, 128)
        self.bn1 = nn.BatchNorm1d(128)  # ë°°ì¹˜ ì •ê·œí™” ì¶”ê°€
        self.dropout1 = nn.Dropout(dropout_rate)  # ë“œë¡­ì•„ì›ƒ ì¶”ê°€

        self.fc2 = nn.Linear(128, 64)
        self.bn2 = nn.BatchNorm1d(64)
        self.dropout2 = nn.Dropout(dropout_rate)

        self.fc3 = nn.Linear(64, 32)
        self.bn3 = nn.BatchNorm1d(32)
        self.dropout3 = nn.Dropout(dropout_rate)

        self.fc4 = nn.Linear(32, num_classes)  # ì¶œë ¥ ë ˆì´ì–´
        self.relu = nn.ReLU()

    def forward(self, x):
        x = self.relu(self.bn1(self.fc1(x)))
        x = self.dropout1(x)
        x = self.relu(self.bn2(self.fc2(x)))
        x = self.dropout2(x)
        x = self.relu(self.bn3(self.fc3(x)))
        x = self.dropout3(x)
        x = self.fc4(x)  # ìµœì¢… ì¶œë ¥
        return x
âœ… í›ˆë ¨ í•¨ìˆ˜ (L2 ì •ê·œí™” + ë“œë¡­ì•„ì›ƒ ì ìš©)
python
Copy code
def train_qr_mlp_model(X_train, y_train, X_val, y_val, input_size, num_classes, 
                         dropout_rate=0.3, weight_decay=1e-4, 
                         epochs=20, batch_size=64, learning_rate=0.001):

    # ğŸ”¹ ë°ì´í„° ë¡œë“œ
    train_dataset = data_utils.TensorDataset(torch.tensor(X_train, dtype=torch.float32), 
                                             torch.tensor(y_train, dtype=torch.long))
    val_dataset = data_utils.TensorDataset(torch.tensor(X_val, dtype=torch.float32), 
                                           torch.tensor(y_val, dtype=torch.long))
    train_loader = data_utils.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    val_loader = data_utils.DataLoader(val_dataset, batch_size=batch_size, shuffle=False)

    # ğŸ”¹ ëª¨ë¸ ì´ˆê¸°í™” (ì •ê·œí™” + ë“œë¡­ì•„ì›ƒ í¬í•¨)
    model = QRMLPModel(input_size=input_size, num_classes=num_classes, dropout_rate=dropout_rate).to(device)

    criterion = nn.CrossEntropyLoss()  # ğŸ”¹ ì†ì‹¤ í•¨ìˆ˜
    optimizer = optim.Adam(model.parameters(), lr=learning_rate, weight_decay=weight_decay)  # ğŸ”¹ L2 ì •ê·œí™” ì ìš©

    # ğŸ”¹ í›ˆë ¨ ì‹œì‘
    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()

        avg_loss = total_loss / len(train_loader)

        # ğŸ”¹ ê²€ì¦ í‰ê°€
        model.eval()
        val_loss = 0
        correct = 0
        total = 0
        with torch.no_grad():
            for inputs, targets in val_loader:
                inputs, targets = inputs.to(device), targets.to(device)
                outputs = model(inputs)
                val_loss += criterion(outputs, targets).item()
                predicted = torch.argmax(outputs, dim=1)
                correct += (predicted == targets).sum().item()
                total += targets.size(0)

        val_loss /= len(val_loader)
        accuracy = correct / total

        print(f"Epoch [{epoch+1}/{epochs}] - Loss: {avg_loss:.4f}, Val Loss: {val_loss:.4f}, Accuracy: {accuracy:.4f}")

    print("ğŸ‰ í›ˆë ¨ ì™„ë£Œ!")
    return model
ğŸ“Œ ì ìš©ëœ í•µì‹¬ ê¸°ìˆ 
âœ… L2 ì •ê·œí™” (weight_decay=1e-4) â†’ ëª¨ë¸ì˜ ê°€ì¤‘ì¹˜ê°€ ë„ˆë¬´ ì»¤ì§€ëŠ” ê²ƒì„ ë°©ì§€í•˜ì—¬ ê³¼ì í•© ì¤„ì„
âœ… Dropout (nn.Dropout(0.3)) â†’ íŠ¹ì • ë‰´ëŸ°ì„ ëœë¤í•˜ê²Œ ë¹„í™œì„±í™”í•˜ì—¬ íŠ¹ì • íŒ¨í„´ì— ê³¼ì í•©í•˜ëŠ” ê²ƒ ë°©ì§€
âœ… Batch Normalization (nn.BatchNorm1d) â†’ í•™ìŠµ ì•ˆì •í™” ë° í›ˆë ¨ ì†ë„ í–¥ìƒ
âœ… Adam ì˜µí‹°ë§ˆì´ì € (optim.Adam) â†’ weight_decay ì¶”ê°€í•˜ì—¬ L2 ì •ê·œí™” ì ìš©
âœ… í›ˆë ¨/ê²€ì¦ Loss & Accuracy ì¶œë ¥ â†’ ê³¼ì í•© ê°ì§€ ê°€ëŠ¥