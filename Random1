면, OCR 결과에서 - 기호는 나타나지 않게 됩니다.

2. OCR 오판으로 소수점을 못 찾았을 때, 강제로 소수점 추가하는 방법
이 기능은 OCR로 인식된 텍스트를 실제 숫자로 변환하기 직전에 처리하는 것이 좋습니다. ProcessOcrResult 함수 내부에서, 공백으로 분리된 각 숫자 문자열에 대해 소수점이 없는 경우 마지막 숫자 바로 앞에 소수점을 삽입하는 로직을 추가할 수 있습니다.

수정할 위치: MainWindow.xaml.cs 파일의 ProcessOcrResult 함수 내부입니다.

아래는 수정된 ProcessOcrResult 함수의 해당 부분 코드입니다.

C#

        private void ProcessOcrResult(string rawText)
        {
            LogTrace($"ProcessOcrResult: 원본 텍스트='{rawText}'");
            // 기존의 '-' 기호 제거는 whitelist로 처리했으므로 여기서는 생략 가능,
            // 혹은 더 확실하게 한 번 더 제거할 수 있습니다.
            string processedText = rawText.Replace("-", ""); 
            string[] parts = processedText.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length != 2) 
            { 
                LogTrace($"ProcessOcrResult: 값 분리 오류, {parts.Length}개 분리됨."); 
                lblStatus.Text = $"상태: 값 분리 오류 (인식된 값 {parts.Length}개)"; 
                return; 
            }

            // ## 여기가 핵심 수정 부분입니다 ##
            string part1String = parts[0];
            string part2String = parts[1];

            // part1에 대한 처리: 소수점이 없고, 길이가 2 이상이면 마지막 숫자 앞에 점 추가
            if (!part1String.Contains(".") && part1String.Length >= 2)
            {
                part1String = part1String.Insert(part1String.Length - 1, ".");
                LogTrace($"ProcessOcrResult: part1 자동 소수점 추가 -> '{part1String}' (원본: '{parts[0]}')");
            }
            else if (!part1String.Contains(".") && part1String.Length == 1) // 한 자리 숫자인 경우
            {
                // part1String = part1String + ".0"; // 예: "5" -> "5.0" (필요에 따라 주석 해제)
                LogTrace($"ProcessOcrResult: part1 한 자리 숫자 확인 -> '{part1String}' (원본: '{parts[0]}')");
            }


            // part2에 대한 처리: 소수점이 없고, 길이가 2 이상이면 마지막 숫자 앞에 점 추가
            if (!part2String.Contains(".") && part2String.Length >= 2)
            {
                part2String = part2String.Insert(part2String.Length - 1, ".");
                LogTrace($"ProcessOcrResult: part2 자동 소수점 추가 -> '{part2String}' (원본: '{parts[1]}')");
            }
            else if (!part2String.Contains(".") && part2String.Length == 1) // 한 자리 숫자인 경우
            {
                // part2String = part2String + ".0"; // 예: "5" -> "5.0" (필요에 따라 주석 해제)
                LogTrace($"ProcessOcrResult: part2 한 자리 숫자 확인 -> '{part2String}' (원본: '{parts[1]}')");
            }
            // ## 핵심 수정 부분 끝 ##

            if (decimal.TryParse(part1String, out decimal val1) && decimal.TryParse(part2String, out decimal val2))
            {
                // 소수점 첫째 자리까지만 사용 (나머지 버림)
                decimal temp = Math.Truncate(val1 * 10) / 10m;
                decimal humid = Math.Truncate(val2 * 10) / 10m;
                LogTrace($"ProcessOcrResult: 숫자 변환 성공. temp={temp}, humid={humid}. DB 업로드 시작.");
                UploadToDatabase(temp, humid);
            }
            else 
            { 
                LogTrace($"ProcessOcrResult: 숫자 변환 실패. parts[0]='{part1String}', parts[1]='{part2String}'"); 
                lblStatus.Text = $"상태: 숫자 변환 오류 ({part1String},{part2String})"; 
            }
        }
설명:

part1String과 part2String으로 각 숫자 문자열을 받습니다.
각 문자열에 대해 Contains(".")를 사용하여 소수점이 이미 있는지 확인합니다.
소수점이 없고(!part1String.Contains(".")) 문자열의 길이가 2 이상이면(part1String.Length >= 2), Insert() 메소드를 사용하여 문자열의 마지막 문자 바로 앞에 .을 삽입합니다.
예: "254" -> "25.4", "62" -> "6.2"
만약 한 자리 숫자에 대해 ".0"을 붙이고 싶다면 (예: "5" -> "5.0"), 주석 처리된 part1String = part1String + ".0"; 부분을 활성화할 수 있습니다. 현재는 한 자리 숫자는 그대로 둡니다.
이렇게 가공된 part1String과 part2String을 사용하여 decimal.TryParse를 수행합니다.
이 로직을 적용하면 OCR이 소수점을 놓치더라