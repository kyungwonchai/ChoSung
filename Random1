알겠습니다. PLC 시뮬레이터를 하나의 WPF 애플리케이션에서 구현하여 COM 포트 통신을 통해 PLC와의 상호작용을 모방하도록 하겠습니다. 이 프로그램은 시리얼 포트를 통해 Mewtocol 명령을 수신하고, 수신된 명령에 따라 내부 메모리(예: D2300, D2330, D2310)를 업데이트하며, 지정된 동작을 시뮬레이션합니다.

프로젝트 구성
프로젝트명: PLCPanaSimul
주요 기능:
뮤토콜 명령 수신 및 처리: COM 포트를 통해 명령을 수신하고, 시뮬레이션된 메모리 공간을 업데이트합니다.
PLC 메모리 시뮬레이션: D2300, D2330, D2310 등의 주소를 가지는 메모리를 시뮬레이션합니다.
센서 상태 시뮬레이션: 버튼을 눌러 센서의 상태(R520, R521)를 변경합니다.
기본 응답 전송: 명령 처리 후 기본 응답 메시지를 시리얼 포트로 전송합니다.
1. MainWindow.xaml
xml
코드 복사
<Window x:Class="PLCPanaSimul.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Panasonic Simulator" Height="400" Width="500">
    <Grid>
        <!-- D2300 데이터를 시뮬레이션하여 보내는 버튼 -->
        <Button x:Name="BtnSendD2300" Content="Send D2300" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Height="30" Margin="10" Click="BtnSendD2300_Click"/>
        <!-- D2330 완료 신호를 시뮬레이션하여 보내는 버튼 -->
        <Button x:Name="BtnCompleteD2330" Content="Complete D2330" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Height="30" Margin="140,10,0,0" Click="BtnCompleteD2330_Click"/>
        
        <!-- 센서 상태 시뮬레이션 -->
        <Button x:Name="BtnSensorR520" Content="Sensor R520" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Height="30" Margin="10,50,0,0" Click="BtnSensorR520_Click"/>
        <Button x:Name="BtnSensorR521" Content="Sensor R521" HorizontalAlignment="Left" VerticalAlignment="Top" Width="120" Height="30" Margin="140,50,0,0" Click="BtnSensorR521_Click"/>
        
        <!-- 로그 출력 -->
        <ListBox x:Name="LogListBox" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="460" Height="200" Margin="10,100,0,0"/>
    </Grid>
</Window>
2. MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Windows;
using PLCPanaSimul.Services;
using System.Threading.Tasks;

namespace PLCPanaSimul
{
    public partial class MainWindow : Window
    {
        private PLCSimulator _plcSimulator;
        private ComPortManager _comPortManager;

        public MainWindow()
        {
            InitializeComponent();
            
            // PLC 시뮬레이터 초기화
            _plcSimulator = new PLCSimulator(LogMessage);
            // COM 포트 관리자 초기화 및 포트 열기
            _comPortManager = new ComPortManager("COM1", _plcSimulator.ProcessReceivedData);
            _comPortManager.OpenPort();
        }

        private void BtnSendD2300_Click(object sender, RoutedEventArgs e)
        {
            // D2300에 값을 쓰는 명령을 시뮬레이션
            _plcSimulator.SendDataToPLC("D2300", "1");
        }

        private void BtnCompleteD2330_Click(object sender, RoutedEventArgs e)
        {
            // D2330에 동작 완료 신호를 시뮬레이션
            _plcSimulator.CompleteOperation("D2330");
        }

        private void BtnSensorR520_Click(object sender, RoutedEventArgs e)
        {
            // 센서 R520의 상태 변경을 시뮬레이션
            _plcSimulator.SetSensorStatus("R520", true);
        }

        private void BtnSensorR521_Click(object sender, RoutedEventArgs e)
        {
            // 센서 R521의 상태 변경을 시뮬레이션
            _plcSimulator.SetSensorStatus("R521", true);
        }

        // 로그 메시지를 출력하는 메서드
        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() => LogListBox.Items.Add(message));
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _comPortManager.ClosePort(); // 창 닫기 시 포트 닫기
        }
    }
}
3. PLCSimulator.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace PLCPanaSimul.Services
{
    public class PLCSimulator
    {
        private Dictionary<string, int> _memory; // PLC의 메모리 시뮬레이션
        private Action<string> _logCallback; // 로그 출력 콜백

        public PLCSimulator(Action<string> logCallback)
        {
            _memory = new Dictionary<string, int>
            {
                { "D2300", 0 },
                { "D2330", 0 },
                { "R520", 0 },
                { "R521", 0 }
            };
            _logCallback = logCallback;
        }

        // 시리얼 포트로 수신된 데이터를 처리하는 메서드
        public void ProcessReceivedData(string data)
        {
            // 수신된 데이터를 로그로 기록
            _logCallback?.Invoke($"Received: {data}");

            // Mewtocol 프로토콜 명령 처리 로직 (간단한 예시)
            if (data.Contains("WDD"))
            {
                // 예시: D2300에 쓰기 명령이 포함된 경우 처리
                if (data.Contains("D2300"))
                {
                    SendDataToPLC("D2300", "1"); // D2300에 1을 씀
                }
            }
        }

        // PLC로 데이터를 전송하는 메서드 (시뮬레이션)
        public void SendDataToPLC(string address, string value)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = int.Parse(value);
                _logCallback?.Invoke($"Data sent to {address}: {value}");

                // 동작 완료를 시뮬레이션하기 위해 3초 후에 D2330에 동작 완료 값을 씀
                Task.Delay(3000).ContinueWith(_ => CompleteOperation("D2330"));
            }
        }

        // 동작 완료를 시뮬레이션하는 메서드
        public void CompleteOperation(string address)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = 1;
                _logCallback?.Invoke($"Operation completed at {address}");
            }
        }

        // 센서 상태를 설정하는 메서드
        public void SetSensorStatus(string sensor, bool status)
        {
            if (_memory.ContainsKey(sensor))
            {
                _memory[sensor] = status ? 1 : 0;
                _logCallback?.Invoke($"Sensor {sensor} status: {(status ? "Active" : "Inactive")}");
            }
        }
    }
}
4. ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;

namespace PLCPanaSimul.Services
{
    public class ComPortManager
    {
        private SerialPort _port;
        private Action<string> _dataReceivedCallback;

        public ComPortManager(string portName, Action<string> dataReceivedCallback)
        {
            _dataReceivedCallback = dataReceivedCallback;
            _port = new SerialPort(portName, 9600, Parity.None, 8, StopBits.One);
            _port.DataReceived += Port_DataReceived;
        }

        public void OpenPort()
        {
            if (!_port.IsOpen)
            {
                _port.Open();
            }
        }

        public void ClosePort()
        {
            if (_port.IsOpen)
            {
                _port.Close();
            }
        }

        private void Port_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            var sp = (SerialPort)sender;
            string data = sp.ReadExisting(); // 수신된 데이터 읽기
            _dataReceivedCallback?.Invoke(data); // 수신된 데이터를 콜백 메서드로 전달
        }
    }
}
코드 설명
MainWindow.xaml: 사용자 인터페이스로, 버튼을 통해 PLC 시뮬레이터의 동작을 시뮬레이션하고, ListBox를 통해 로그를 출력합니다.

MainWindow.xaml.cs: PLC 시뮬레이터와 시리얼 포트 관리자 인스턴스를 생성하고, UI 이벤트에 대한 핸들러를 제공합니다.

PLCSimulator.cs: 시뮬레이터의 핵심 로직을 처리합니다. Mewtocol 프로토콜을 통해 수신된 명령을 해석하고, 가상의 PLC 메모리에 값을 쓰며, 일정 시간 후 동작 완료를 시뮬레이션합니다.

ComPortManager.cs: 시리얼 포트를 관리하고, 데이터 수신 이벤트를 처리하여 수신된 데이터를 PLCSimulator로 전달합니다.

이 코드는 WPF 애플리케이션에서 시리얼 포트를 통해 Mewtocol 프로토콜을 사용하는 PLC 시뮬레이션을 수행합니다. 실제 PLC 장비 없이도 명령 전송 및 응답을 테스트할 수 있습니