, 인터넷이 연결되지 않은 내부망(오프라인) 환경의 클라이언트 PC에서도 사용할 수 있도록 패키지화하는 방법을 아주 상세하게 안내해 드리겠습니다.

## 개요 (Overview)
가장 큰 변화는 인터넷 의존성을 제거하고 프론트엔드와 백엔드를 하나의 패키지로 통합하는 것입니다.

통합 서버 (Node.js): 우분투 서버에서 실행되며, 기존처럼 공유 폴더 접근 API를 제공할 뿐만 아니라, 빌드(Build)된 React 애플리케이션 파일(HTML, CSS, JS) 자체를 웹서버처럼 제공합니다.

독립형 프론트엔드 (React): react-pdf 라이브러리가 인터넷 CDN을 통해 다운로드하던 pdf.worker.js 파일을 프로젝트 내부에 포함시킵니다. npm run build 명령으로 모든 코드를 정적 파일(static files)로 변환하여 인터넷 연결 없이도 동작하도록 만듭니다.

클라이언트는 최초에 우분투 서버에 접속하여 웹 애플리케이션을 다운로드받기만 하면, 그 이후에는 외부 인터넷망과 단절되어도 우분투 서버와의 내부 네트워크 연결만 유지된다면 계속 사용할 수 있습니다.

## 시스템 아키텍처 (System Architecture)
                                     ┌─────────────────────────────────┐
                                     │       우분투 서버 (Ubuntu Server)       │
                                     │                                 │
  ┌───────────────┐  HTTP 요청/응답  │  ┌───────────────────────────┐  │  파일 시스템 접근  ┌──────────────────┐
  │ 사용자 브라우저 │◀───────────────▶│   통합 Node.js 애플리케이션   │◀──────────────▶│  마운트된 공유폴더 │
  │ (내부 네트워크) │                │  │ 1. API 서버 (폴더/파일 목록)│  │                │ (/mnt/shared)    │
  └───────────────┘                │  │ 2. 웹 서버 (React 앱 제공)  │  │                └──────────────────┘
                                     │  └───────────────────────────┘  │
                                     └─────────────────────────────────┘
## 1. 우분투 서버 환경 준비 (Ubuntu Server Preparation)
Node.js 및 npm 설치
우분투 터미널에서 아래 명령어를 실행하여 Node.js(v18.x 권장)와 npm을 설치합니다.

Bash

sudo apt-get update
sudo apt-get install -y ca-certificates curl gnupg
curl -fsSL https://deb.nodesource.com/setup_18.x | sudo -E bash -
sudo apt-get install -y nodejs
네트워크 공유 폴더 마운트 (가장 중요)
윈도우의 공유 폴더를 우분투에서 로컬 폴더처럼 사용하기 위해 '마운트' 과정이 필요합니다.

cifs-utils 설치: 윈도우 공유 폴더(CIFS/SMB)에 연결하기 위한 도구입니다.

Bash

sudo apt-get install -y cifs-utils
마운트 포인트 생성: 공유 폴더를 연결할 로컬 디렉토리를 생성합니다.

Bash

sudo mkdir /mnt/shared_docs
수동 마운트 (테스트용): 아래 명령어로 공유 폴더가 잘 연결되는지 테스트합니다.

Bash

# sudo mount -t cifs -o username=YOUR_WINDOWS_USERNAME,password=YOUR_PASSWORD //WINDOWS_SERVER_IP/SHARE_NAME /mnt/shared_docs
# 예시:
sudo mount -t cifs -o username=guest //192.168.1.100/ScannedPDF /mnt/shared_docs
ls -l /mnt/shared_docs 명령어로 파일 목록이 보이면 성공입니다.

자동 마운트 (서버 재부팅 시에도 유지): 서버가 재부팅되어도 자동으로 연결되도록 /etc/fstab 파일에 등록합니다.
sudo nano /etc/fstab 명령어로 파일을 열고 맨 아래에 다음 한 줄을 추가합니다.

//WINDOWS_SERVER_IP/SHARE_NAME /mnt/shared_docs cifs username=YOUR_WINDOWS_USERNAME,password=YOUR_PASSWORD,iocharset=utf8,file_mode=0777,dir_mode=0777 0 0
저장 후 sudo mount -a 명령어로 설정을 적용합니다.

## 2. 통합 애플리케이션 프로젝트 구조 설정
하나의 폴더에서 백엔드와 프론트엔드를 모두 관리합니다.

프로젝트 폴더를 생성합니다.

Bash

mkdir ~/pdf-viewer-app
cd ~/pdf-viewer-app
백엔드 package.json 파일을 초기화합니다.

Bash

npm init -y
npm install express cors
프론트엔드 React 앱을 client라는 폴더에 생성합니다.

Bash

npx create-react-app client
최종 폴더 구조는 다음과 같습니다.

/pdf-viewer-app
├── client/              <-- 프론트엔드 (React)
│   ├── node_modules/
│   ├── public/
│   ├── src/
│   └── package.json
├── node_modules/        <-- 백엔드
├── package.json
└── server.js            <-- 백엔드 서버 파일
## 3. 백엔드 (Node.js / Express) 구현
~/pdf-viewer-app 폴더에 server.js 파일을 생성하고 아래 코드를 작성합니다. 이 코드는 API 역할과 함께 빌드된 React 앱을 서빙하는 웹서버 역할을 겸합니다.

~/pdf-viewer-app/server.js

JavaScript

const express = require('express');
const fs = require('fs');
const path = require('path');
const cors = require('cors');

const app = express();
const PORT = 3001; // 서버 실행 포트

// 1. 공유 폴더가 마운트된 우분투 로컬 경로
const SHARED_DRIVE_PATH = '/mnt/shared_docs';

// API 요청에 대해 CORS 허용
app.use(cors());
app.use('/api', cors()); // '/api'로 시작하는 경로에만 CORS 적용도 가능

// API 라우트 (기존과 동일)
app.get('/api/folders', (req, res) => {
    try {
        const allEntries = fs.readdirSync(SHARED_DRIVE_PATH, { withFileTypes: true });
        const directories = allEntries.filter(d => d.isDirectory()).map(d => d.name);
        res.json(directories);
    } catch (error) {
        console.error('Error reading shared directory:', error);
        res.status(500).json({ message: '공유 폴더를 읽는 중 오류가 발생했습니다.', error: error.message });
    }
});

app.get('/api/pdfs/:folderName', (req, res) => {
    const targetFolderPath = path.join(SHARED_DRIVE_PATH, req.params.folderName);
    try {
        const pdfFiles = fs.readdirSync(targetFolderPath).filter(f => f.toLowerCase().endsWith('.pdf')).sort();
        res.json(pdfFiles);
    } catch (error) {
        res.status(500).json({ message: 'PDF 파일 목록을 읽는 중 오류가 발생했습니다.', error: error.message });
    }
});

app.get('/api/pdf/:folderName/:pdfName', (req, res) => {
    const pdfFilePath = path.join(SHARED_DRIVE_PATH, req.params.folderName, req.params.pdfName);
    if (fs.existsSync(pdfFilePath)) {
        res.setHeader('Content-Type', 'application/pdf');
        res.sendFile(pdfFilePath);
    } else {
        res.status(404).json({ message: 'PDF 파일을 찾을 수 없습니다.' });
    }
});

// 2. 빌드된 React 앱 제공 (가장 중요)
//    'client/build' 폴더에 있는 정적 파일들을 서비스하도록 설정
app.use(express.static(path.join(__dirname, 'client/build')));

// 3. 모든 그 외의 요청에 대해 React의 index.html을 반환
//    (React Router 사용 시 페이지 새로고침해도 404가 뜨지 않게 함)
app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, 'client/build', 'index.html'));
});

app.listen(PORT, () => {
    console.log(`✅ PDF Viewer server is running on http://localhost:${PORT}`);
    console.log(`✅ Serving React app from: ${path.join(__dirname, 'client/build')}`);
    console.log(`✅ Watching shared folder: ${SHARED_DRIVE_PATH}`);
});
## 4. 프론트엔드 (React) 구현 및 오프라인 설정
필요한 라이브러리 설치
client 폴더로 이동해서 axios와 react-pdf를 설치합니다.

Bash

cd client
npm install axios react-pdf
PDF.js 워커 파일 복사 (오프라인 핵심)
인터넷 CDN 대신 로컬 파일을 사용하도록 pdf.worker.min.js 파일을 public 폴더로 복사합니다.

Bash

# client 폴더 안에서 실행
cp node_modules/pdfjs-dist/build/pdf.worker.min.js public/
이제 이 워커 파일은 React 앱이 빌드될 때 함께 포함됩니다.

App.js 코드 수정
~/pdf-viewer-app/client/src/App.js 파일을 열고 아래 내용으로 전체를 교체합니다. API_BASE_URL이 사라지고, pdfjs.GlobalWorkerOptions.workerSrc 경로가 로컬로 변경된 점이 핵심입니다.

~/pdf-viewer-app/client/src/App.js

JavaScript

import React, { useState, useEffect } from 'react';
import axios from 'axios';
import { Document, Page, pdfjs } from 'react-pdf';
import 'react-pdf/dist/esm/Page/AnnotationLayer.css';
import 'react-pdf/dist/esm/Page/TextLayer.css';
import './App.css'; // CSS는 이전과 동일하게 사용합니다.

// ✅ 오프라인을 위해 로컬에 복사된 pdf.worker.js 파일을 사용하도록 설정
pdfjs.GlobalWorkerOptions.workerSrc = `/pdf.worker.min.js`;

function App() {
  const [folders, setFolders] = useState([]);
  const [selectedFolder, setSelectedFolder] = useState('');
  const [pdfFiles, setPdfFiles] = useState([]);
  const [selectedPdfName, setSelectedPdfName] = useState(null);
  const [pdfUrl, setPdfUrl] = useState(null);
  const [numPages, setNumPages] = useState(null);
  const [pageNumber, setPageNumber] = useState(1);
  const [scale, setScale] = useState(1.5);

  useEffect(() => {
    // ✅ API 경로를 상대 경로로 변경
    axios.get(`/api/folders`)
      .then(response => setFolders(response.data))
      .catch(error => console.error('폴더 목록 로딩 실패:', error));
  }, []);

  useEffect(() => {
    if (selectedFolder) {
      axios.get(`/api/pdfs/${selectedFolder}`)
        .then(response => {
          setPdfFiles(response.data.slice(0, 16));
          setPdfUrl(null);
          setSelectedPdfName(null);
        })
        .catch(error => console.error('PDF 목록 로딩 실패:', error));
    } else {
      setPdfFiles([]);
      setPdfUrl(null);
      setSelectedPdfName(null);
    }
  }, [selectedFolder]);

  const handlePdfIconClick = (pdfFileName) => {
    // ✅ PDF 파일 URL도 상대 경로로 변경
    const url = `/api/pdf/${selectedFolder}/${pdfFileName}`;
    setPdfUrl(url);
    setSelectedPdfName(pdfFileName);
    setPageNumber(1);
  };

  // ... (나머지 핸들러 및 렌더링 함수는 이전 코드와 동일) ...
  const handleFolderChange = (e) => setSelectedFolder(e.target.value);
  const onDocumentLoadSuccess = ({ numPages }) => setNumPages(numPages);
  const changePage = (offset) => setPageNumber(p => p + offset);
  const changeScale = (offset) => setScale(s => s + offset);

  const renderPdfIcons = (files) => (
    <div className="pdf-icon-grid">
      <div className="pdf-icon-row">
        {files.slice(0, 8).map((file, index) => (
          <button key={index} className={`pdf-icon ${selectedPdfName === file ? 'selected' : ''}`} onClick={() => handlePdfIconClick(file)}>
            {index + 1}
          </button>
        ))}
      </div>
      <div className="pdf-icon-row">
        {files.slice(8, 16).map((file, index) => (
          <button key={index + 8} className={`pdf-icon ${selectedPdfName === file ? 'selected' : ''}`} onClick={() => handlePdfIconClick(file)}>
            {index + 9}
          </button>
        ))}
      </div>
    </div>
  );

  return (
    <div className="App">
      <h1>PDF 문서 뷰어 (Ubuntu Ver.)</h1>
      <div className="controls-container">
        <select className="folder-selector" onChange={handleFolderChange} value={selectedFolder}>
          <option value="">-- 폴더를 선택하세요 --</option>
          {folders.map((folder, index) => <option key={index} value={folder}>{folder}</option>)}
        </select>
        {pdfFiles.length > 0 && renderPdfIcons(pdfFiles)}
      </div>
      {pdfUrl && (
        <div className="pdf-viewer-container">
          <div className="pdf-controls">
            <button onClick={() => changeScale(-0.1)} disabled={scale <= 0.5}>축소</button>
            <span>{Math.round(scale * 100)}%</span>
            <button onClick={() => changeScale(0.1)} disabled={scale >= 3}>확대</button>
            <button onClick={() => changePage(-1)} disabled={pageNumber <= 1}>이전</button>
            <span>{pageNumber} / {numPages}</span>
            <button onClick={() => changePage(1)} disabled={pageNumber >= numPages}>다음</button>
          </div>
          <Document file={pdfUrl} onLoadSuccess={onDocumentLoadSuccess}><Page pageNumber={pageNumber} scale={scale} /></Document>
        </div>
      )}
    </div>
  );
}
export default App;
CSS 코드는 이전과 동일하게 client/src/App.css에 넣어주시면 됩니다.

## 5. 빌드 및 최종 실행
프론트엔드 앱 빌드
client 폴더 안에서 npm run build 명령을 실행합니다.

Bash

cd ~/pdf-viewer-app/client
npm run build
이 명령은 client/build 폴더에 최적화된 HTML, CSS, JS 파일들을 생성합니다.

통합 서버 실행
프로젝트의 최상위 폴더(~/pdf-viewer-app)로 이동하여 Node.js 서버를 실행합니다.

Bash

cd ~/pdf-viewer-app
node server.js
이제 서버는 API 요청을 처리함과 동시에 client/build 폴더의 내용물을 웹으로 서비스합니다.

클라이언트 접속
내부망에 있는 어떤 클라이언트 PC에서든 웹 브라우저를 열고 아래 주소로 접속합니다.

http://<우분투서버의IP주소>:3001

(예: http://192.168.1.50:3001)