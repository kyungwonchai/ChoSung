알겠습니다. 에러 없이 작동할 수 있도록 Flask 애플리케이션을 재구성하고 전체 코드를 다시 제공하겠습니다. app.py 파일이 최상위 디렉터리에 위치하도록 하고, 전체 파일 구조와 코드도 수정하여 제대로 작동하도록 하겠습니다.

1. 프로젝트 구조 설정
먼저, 프로젝트 구조를 다음과 같이 구성합니다:

arduino
코드 복사
apk-version-manager/
├── venv/
├── app.py
├── static/
│   └── apks/
│       ├── apk1.apk
│       └── apk2.apk
└── version_files/
    ├── apk1_version.json
    └── apk2_version.json
app.py: Flask 애플리케이션의 엔트리 포인트입니다.
static/apks/: 다운로드 가능한 APK 파일을 저장하는 디렉터리입니다.
version_files/: 각 APK의 버전 정보를 저장하는 JSON 파일을 위한 디렉터리입니다.
2. Flask 애플리케이션 코드 (app.py)
python
코드 복사
from flask import Flask, jsonify, send_from_directory, abort
import os

app = Flask(__name__)

# APK 파일이 저장된 경로
APK_DIR = os.path.join(os.getcwd(), 'static', 'apks')
VERSION_DIR = os.path.join(os.getcwd(), 'version_files')

# APK1 버전 정보를 제공하는 엔드포인트
@app.route('/api/apk1/version', methods=['GET'])
def apk1_version():
    version_file = os.path.join(VERSION_DIR, 'apk1_version.json')
    if os.path.exists(version_file):
        with open(version_file) as f:
            version_info = f.read()
        return jsonify(version_info)
    else:
        abort(404, description="Version file not found.")

# APK2 버전 정보를 제공하는 엔드포인트
@app.route('/api/apk2/version', methods=['GET'])
def apk2_version():
    version_file = os.path.join(VERSION_DIR, 'apk2_version.json')
    if os.path.exists(version_file):
        with open(version_file) as f:
            version_info = f.read()
        return jsonify(version_info)
    else:
        abort(404, description="Version file not found.")

# APK1 파일 다운로드 엔드포인트
@app.route('/download/apk1', methods=['GET'])
def download_apk1():
    apk_file = 'apk1.apk'
    if os.path.exists(os.path.join(APK_DIR, apk_file)):
        return send_from_directory(APK_DIR, apk_file)
    else:
        abort(404, description="APK file not found.")

# APK2 파일 다운로드 엔드포인트
@app.route('/download/apk2', methods=['GET'])
def download_apk2():
    apk_file = 'apk2.apk'
    if os.path.exists(os.path.join(APK_DIR, apk_file)):
        return send_from_directory(APK_DIR, apk_file)
    else:
        abort(404, description="APK file not found.")

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=5000)
3. 버전 정보 파일 (version_files/apk1_version.json 및 version_files/apk2_version.json)
각 APK의 버전 정보를 담고 있는 JSON 파일을 작성합니다.

apk1_version.json:
json
코드 복사
{
    "version": "1.0.1",
    "apk_url": "/download/apk1"
}
apk2_version.json:
json
코드 복사
{
    "version": "2.0.0",
    "apk_url": "/download/apk2"
}
4. 시스템 서비스 등록
Flask 애플리케이션을 Ubuntu 서버에서 서비스로 등록하는 방법입니다.

서비스 파일 생성:

/etc/systemd/system/apkmanager.service 파일을 생성합니다.

bash
코드 복사
sudo nano /etc/systemd/system/apkmanager.service
서비스 파일 내용:

ini
코드 복사
[Unit]
Description=Flask APK Version Manager
After=network.target

[Service]
User=your-username
WorkingDirectory=/home/your-username/apk-version-manager
Environment="PATH=/home/your-username/apk-version-manager/venv/bin"
ExecStart=/home/your-username/apk-version-manager/venv/bin/python /home/your-username/apk-version-manager/app.py

[Install]
WantedBy=multi-user.target
서비스 시작 및 자동 실행 설정:

bash
코드 복사
sudo systemctl daemon-reload
sudo systemctl start apkmanager
sudo systemctl enable apkmanager
5. Android 애플리케이션에서 APK 업데이트 기능 구현
아래는 Android 애플리케이션에서 APK 버전 관리를 위한 Kotlin DSL 코드를 예시로 제공합니다.

5-1. Gradle 설정
build.gradle 파일에서 필요한 라이브러리를 추가합니다.

gradle
코드 복사
dependencies {
    implementation 'com.squareup.okhttp3:okhttp:4.9.0'
    implementation 'org.json:json:20210307'
}
5-2. Kotlin 코드
kotlin
코드 복사
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream
import android.content.Context
import android.content.Intent
import android.net.Uri
import androidx.core.content.FileProvider

fun checkForUpdates(context: Context, apkName: String) {
    val client = OkHttpClient()
    val request = Request.Builder()
        .url("http://your-server-ip:5000/api/$apkName/version")
        .build()

    client.newCall(request).execute().use { response ->
        if (!response.isSuccessful) throw IOException("Unexpected code $response")

        val responseData = response.body?.string()
        val jsonObject = JSONObject(responseData)
        val latestVersion = jsonObject.getString("version")
        val apkUrl = jsonObject.getString("apk_url")

        val currentVersion = BuildConfig.VERSION_NAME
        if (latestVersion != currentVersion) {
            downloadAndInstallApk(context, apkUrl, apkName)
        }
    }
}

fun downloadAndInstallApk(context: Context, apkUrl: String, apkName: String) {
    val client = OkHttpClient()
    val request = Request.Builder().url("http://your-server-ip:5000$apkUrl").build()

    client.newCall(request).execute().use { response ->
        if (!response.isSuccessful) throw IOException("Unexpected code $response")

        val apkFile = File(context.getExternalFilesDir(null), "$apkName.apk")
        FileOutputStream(apkFile).use { fos ->
            fos.write(response.body?.bytes())
        }

        val apkUri: Uri = FileProvider.getUriForFile(
            context,
            context.applicationContext.packageName + ".provider",
            apkFile
        )

        val intent = Intent(Intent.ACTION_VIEW).apply {
            flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
            setDataAndType(apkUri, "application/vnd.android.package-archive")
        }
        context.startActivity(intent)
    }
}
6. AndroidManifest 설정
6-1. FileProvider 설정
AndroidManifest.xml 파일에서 FileProvider를 추가합니다.

xml
코드 복사
<application>
    <provider
        android:name="androidx.core.content.FileProvider"
        android:authorities="${applicationId}.provider"
        android:exported="false"
        android:grantUriPermissions="true">
        <meta-data
            android:name="android.support.FILE_PROVIDER_PATHS"
            android:resource="@xml/file_paths" />
    </provider>
</application>
6-2. file_paths.xml 설정
res/xml/file_paths.xml 파일을 생성하여 다음과 같이 설정합니다.

xml
코드 복사
<paths xmlns:android="http://schemas.android.com/apk/res/android">
    <external-files-path name="external_files" path="." />
</paths>
결론
이제 Ubuntu 서버에서 APK 버전 관리를 위한 Flask 애플리케이션이 제대로 동작해야 합니다. Android 앱은 지정된 서버로부터 APK 버전 정보를 가져오고, 필요에 따라 최신 버전을 다운로드하여 설치할 수 있습니다. 이 설정을 통해 사내 환경에서 안전하고 관리가 용이한 APK 업데이트 시스템을 구축할 수 