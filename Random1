. 도형에 마우스를 올렸을 때 함수 이름이 표시되지 않는 문제
도형에 마우스를 올리면 함수 이름을 표시하기 위해 ToolTip에서 함수 이름을 제대로 바인딩해야 합니다. 현재 문제는 ToolTip에서 정확한 함수 이름을 가져오지 못하는 것으로 보입니다.

이를 해결하기 위해 ItemsControl과 ToolTip의 데이터 바인딩을 수정하겠습니다.

도형에 함수 이름 표시 (수정된 부분)
xml
코드 복사
<DataGridTemplateColumn Header="Function Status" Width="2*">
    <DataGridTemplateColumn.CellTemplate>
        <DataTemplate>
            <ItemsControl ItemsSource="{Binding FunctionStatusColors}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Ellipse Width="20" Height="20" Fill="{Binding}" Margin="5">
                            <!-- Tooltip으로 함수 이름 표시 -->
                            <Ellipse.ToolTip>
                                <!-- 마우스 오버 시 FunctionNames의 함수 이름을 표시 -->
                                <TextBlock Text="{Binding DataContext.FunctionNames[ItemsControl.AlternationIndex], RelativeSource={RelativeSource AncestorType=ItemsControl}}"/>
                            </Ellipse.ToolTip>
                        </Ellipse>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
                <ItemsControl.ItemsPanel>
                    <ItemsPanelTemplate>
                        <StackPanel Orientation="Horizontal"/>
                    </ItemsPanelTemplate>
                </ItemsControl.ItemsPanel>
            </ItemsControl>
        </DataTemplate>
    </DataGridTemplateColumn.CellTemplate>
</DataGridTemplateColumn>
수정된 부분 설명:
**ToolTip**에서 TextBlock의 Text 속성을 FunctionNames 리스트에 정확하게 바인딩하도록 변경했습니다.
**ItemsControl.AlternationIndex**를 사용하여 현재 도형의 인덱스에 해당하는 함수 이름을 FunctionNames 리스트에서 가져옵니다.
이제 도형에 마우스를 올리면 각 도형에 해당하는 함수 이름이 올바르게 표시될 것입니다.

2. DataGrid에서 최대 20개의 작업만 남기고 과거 작업 삭제
이 부분에서는 작업이 20개를 넘을 경우, 가장 오래된 작업을 삭제하여 최신 작업만 20개를 유지하도록 구현할 수 있습니다.

MainViewModel.cs에 작업 삭제 로직 추가 (수정된 코드)
csharp
코드 복사
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업 재개
    public ICommand ResumeAllCommand { get; }

    // 최대 작업 개수 (20개로 설정)
    private const int MaxTaskCount = 20;

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(logEntry, _taskQueue);
            task.StartNextTask = StartNextTask; // 현재 작업이 끝나면 다음 작업을 실행하도록 설정
            TaskList.Add(task); // UI 스레드에서 작업 목록에 추가

            if (TaskList.Count == 1) // 첫 번째 작업일 때 바로 시작
            {
                task.StartTask(); // 첫 번째 작업 시작
            }

            // 작업 개수가 최대 개수를 넘을 경우, 가장 오래된 작업을 삭제
            if (TaskList.Count > MaxTaskCount)
            {
                TaskList.RemoveAt(0); // 가장 오래된 작업 삭제
            }
        });
    }

    /// <summary>
    /// 다음 작업을 실행하는 메서드.
    /// 현재 작업이 완료되면 호출됩니다.
    /// </summary>
    private void StartNextTask(TaskModel currentTask)
    {
        // 현재 작업이 완료된 후 다음 작업을 찾음
        int currentIndex = TaskList.IndexOf(currentTask);
        if (currentIndex + 1 < TaskList.Count)
        {
            var nextTask = TaskList[currentIndex + 1];
            nextTask.StartTask(); // 다음 작업 시작
        }
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
설명:
TaskList.RemoveAt(0): 작업 리스트가 20개를 넘으면 **가장 오래된 작업(인덱스 0)**을 삭제합니다.
최대 작업 개수는 20으로 설정되어 있으며, 필요에 따라 조정할 수 있습니다.
최종 결론
도형에 마우스를 올리면 해당 도형에 해당하는 함수 이름이 정확하게 표시되도록 수정했습니다.
최대 작업 개수를 20개로 제한하고, 최신 작업만 20개를 유지하면서 과거 작업을 삭제하는 로직을 추가했습니다.
이제 두 가지 요구 사항이 모두 반영되었습니다. 추가적으로 수정이 필요하다면 언제든지 알려주세요