네, 두 가지 질문 모두 중요한 포인트입니다. 순서대로 답변드리고 관련 파일들의 수정된 전체 코드를 제공하겠습니다.

첫째: "모니터 1분 후 꺼짐"을 "5초 후 꺼짐"으로 수정 가능한지? 어떤 파일을 어디서 수정해야 하는지?
네, 가능합니다. 현재 "끄기" 명령은 SetDisplayTimeout 명령을 통해 모니터 꺼짐 시간을 1분(60초)으로 설정하고 있습니다. 이를 5초로 변경하려면, SAgentM.App 에이전트가 받는 CommandPacket의 페이로드 내용을 수정하고, 에이전트가 이 값을 초 단위로 직접 사용하도록 하는 것이 가장 깔끔합니다.

수정 대상 파일 및 내용:

SControl.Common/Payloads.cs (수정):
SetDisplayTimeoutPayload 클래스의 TimeoutMinutes 속성을 TimeoutSeconds로 변경합니다.
SAgentM.App/Services/AgentCoreService.cs (수정):
ExecuteDirectCommandAsync 메서드 내 SetDisplayTimeout 명령 처리 부분에서, SetDisplayTimeoutPayload의 TimeoutSeconds 값을 직접 powercfg 명령어에 사용하도록 수정합니다. (기존의 * 60 초 변환 로직 제거)
Flask 웹 앱: scontrol_flask_web/app/routes_user.py (수정):
send_batch_command 함수에서 "끄기" 명령 시, SetDisplayTimeoutPayload에 해당하는 딕셔너리를 구성할 때 TimeoutSeconds: 5를 사용합니다. ("켜기"는 TimeoutSeconds: 0)
Flask 웹 앱: scontrol_flask_web/app/scheduler_tasks.py (수정):
_send_display_timeout_to_all_pcs 함수 및 이를 호출하는 scheduled_task_monitor_off 함수에서 "끄기" 명령 시 TimeoutSeconds: 5를 사용하도록 수정합니다. ("켜기"는 TimeoutSeconds: 0)
1. 수정: SControl.Common/Payloads.cs (전체 파일)
TimeoutMinutes를 TimeoutSeconds로 변경합니다.

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    public class MonitorControlPayload
    {
        public MonitorAction Action { get; set; }
    }

    public class SetDisplayTimeoutPayload // 이름은 유지, 속성만 변경 또는 새 페이로드 정의도 가능
    {
        /// <summary>
        /// 디스플레이를 끄기까지의 시간(초)입니다. 0은 "사용 안 함(Never)"을 의미합니다.
        /// </summary>
        public int TimeoutSeconds { get; set; } // TimeoutMinutes에서 TimeoutSeconds로 변경
    }

    public class GenericResponsePayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string ErrorCode { get; set; } 
        public object Data { get; set; }      
    }
}
2. 수정: SAgentM.App/Services/AgentCoreService.cs (전체 파일)
SetDisplayTimeout 명령 처리 시 payload.TimeoutSeconds를 직접 사용합니다. (주석은 최소화했습니다.)

C#

// SAgentM.App/Services/AgentCoreService.cs
using Newtonsoft.Json;
using SControl.Common;
using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;

namespace SAgentM.App.Services
{
    public interface IAgentCoreService { void Start(); void Stop(); bool IsRunning { get; } }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026;
                _loggingService.UiWarn($"ListenPort 설정 누락/오류. 기본값 {_port} 사용.");
            }
        }

        public void Start()
        {
            if (_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 실행 중."); return; }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 중지됨."); return; }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5))) { _loggingService.UiWarn("리스닝 스레드 시간 내 종료 안됨."); }
            }
            _cancellationTokenSource?.Dispose(); _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try
            {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning)
                {
                    try {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se) { if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted)) { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; } _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se); if (!_isRunning) break; Thread.Sleep(100); }
                    catch (InvalidOperationException ioe) when (!_isRunning) { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex) { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally { if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); } _loggingService.UiInfo("ListenLoop 종료됨."); }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try
            {
                _loggingService.UiDebug($"[{clientIpInfo}] 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested)
                    {
                        string requestJson = null;
                        try {
                            var readTask = reader.ReadLineAsync();
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask) { if (token.IsCancellationRequested) token.ThrowIfCancellationRequested(); requestJson = await readTask; }
                            else { token.ThrowIfCancellationRequested(); }
                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 연결 종료됨."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}");
                            CommandPacket requestPacket = null;
                            try { requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson); receivedRequestPacket = requestPacket; }
                            catch (JsonException jsonEx) { _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx); await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON: {jsonEx.Message}"))); continue; }
                            if (requestPacket != null) {
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null) {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                                    await writer.WriteLineAsync(responseJson);
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답: {responseJson}");
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] IO오류: {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체해제오류: {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 처리 작업 취소됨."); break; }
                        catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 오류.", ex); if (client.Connected && stream.CanWrite) { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}}
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request?.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl) {
                MonitorControlPayload originalPayload = null;
                try { if(!string.IsNullOrEmpty(request.PayloadJson)) originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch {}
                if (originalPayload?.Action == MonitorAction.Off) {
                    bool earlyConfirmSuccess = false;
                    if (response?.PayloadJson != null) { try { var genericResp = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if(genericResp != null) earlyConfirmSuccess = genericResp.Success; } catch {} }
                    if(earlyConfirmSuccess) { _loggingService.UiInfo($"[{clientIp}] 조기 응답 후 실제 모니터 끄기 실행. ID: {request.PacketId}"); Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료. ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); }
                    else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패/페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            try {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.Instruction) {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token); 
                    default: return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { return CreateErrorResponse(requestPacket, "Processing canceled."); }
            catch (Exception ex) { return CreateErrorResponse(requestPacket, $"Error processing '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            bool success = false; string message = "Execution failed."; 
            try {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName) {
                    case CommandNames.MonitorControl:
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "MonitorControl payload missing.");
                        MonitorControlPayload monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
                        if (monitorPayload == null) throw new ArgumentException("Cannot deserialize MonitorControlPayload.");
                        if (monitorPayload.Action == MonitorAction.Off) { success = true; message = $"Monitor Off acknowledged. Will turn off shortly."; }
                        else { LocalDeviceControl.SetMonitorState(monitorPayload.Action); success = true; message = $"Monitor state set to {monitorPayload.Action}."; }
                        _loggingService.UiInfo($"[{clientIp}] {message} (Cmd: MonitorControl, Action: {monitorPayload.Action})");
                        break;
                    
                    case CommandNames.SetDisplayTimeout: 
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "SetDisplayTimeout payload missing.");
                        SetDisplayTimeoutPayload timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson);
                        if (timeoutPayload == null) throw new ArgumentException("Cannot deserialize SetDisplayTimeoutPayload.");
                        
                        // ▼▼▼ TimeoutMinutes 대신 TimeoutSeconds를 직접 사용 ▼▼▼
                        int timeoutValueInSeconds = timeoutPayload.TimeoutSeconds; 
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutValueInSeconds}초");
                        
                        string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
                        string acArgs = $"/SETACVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutValueInSeconds}";
                        string dcArgs = $"/SETDCVALUEINDEX SCHEME_CURRENT SUB_VIDEO VIDEOIDLE {timeoutValueInSeconds}";

                        RunPowerCfgCommand(acArgs, out outputAc, out errorAc, out exitCodeAc);
                        RunPowerCfgCommand(dcArgs, out outputDc, out errorDc, out exitCodeDc);
                        
                        if (exitCodeAc == 0 && exitCodeDc == 0) { success = true; message = $"Display timeout set to {timeoutValueInSeconds} sec for AC/DC."; }
                        else { success = false; string acErrClean = string.IsNullOrEmpty(errorAc)?"":errorAc.Trim().Replace("\r\n"," ").Replace("\n"," "); string dcErrClean = string.IsNullOrEmpty(errorDc)?"":errorDc.Trim().Replace("\r\n"," ").Replace("\n"," "); message = $"Failed display timeout. AC Exit:{exitCodeAc}, DC Exit:{exitCodeDc}."; if (!string.IsNullOrEmpty(acErrClean)) message += $" AC Err: {acErrClean}"; if (!string.IsNullOrEmpty(dcErrClean)) message += $" DC Err: {dcErrClean}"; }
                        _loggingService.UiInfo($"[{clientIp}] {message}");
                        break;
                        // ▲▲▲ TimeoutMinutes 대신 TimeoutSeconds를 직접 사용 ▲▲▲
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; success = false; break;
                }
            }
            catch (OperationCanceledException opEx) { message = $"Cmd {requestPacket.CommandName} canceled: {opEx.Message}"; success = false; _loggingService.UiWarn($"[{clientIp}] {message}");}
            catch (ArgumentNullException argEx) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx.ParamName} - {argEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx); }
            catch (ArgumentException argEx2) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx2.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx2); }
            catch (JsonException jsonEx) { message = $"Cmd {requestPacket.CommandName} JSON payload error: {jsonEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); }
            catch (Exception ex) { message = $"Error executing {requestPacket.CommandName}: {ex.Message}"; success = false; _loggingService.UiError($"[{clientIp}] ExecuteDirectCmd Error: {message}", ex); }
            return CreateExecutionResponse(requestPacket, success, message);
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = ""; error = ""; exitCode = -1;
            try {
                _loggingService.UiDebug($"Executing: powercfg.exe {arguments}");
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") { Arguments = arguments, UseShellExecute = false, RedirectStandardOutput = true, RedirectStandardError = true, CreateNoWindow = true, Verb = "runas" };
                using (Process process = Process.Start(startInfo)) {
                    if (process == null) { error = "Failed to start powercfg.exe."; exitCode = -100; _loggingService.UiError(error); return; }
                    output = process.StandardOutput.ReadToEnd(); error = process.StandardError.ReadToEnd(); 
                    if (!process.WaitForExit(7000)) { process.Kill(); error += $"\npowercfg '{arguments}' timeout (7s)."; exitCode = -99;  _loggingService.UiWarn(error); }
                    else { exitCode = process.ExitCode; }
                    if(!string.IsNullOrWhiteSpace(output)) _loggingService.UiDebug($"powercfg output: {output.Trim()}");
                    if(!string.IsNullOrWhiteSpace(error) && exitCode != 0) _loggingService.UiWarn($"powercfg error output: {error.Trim()}");
                }
            } 
            catch (Win32Exception w32Ex) { error = $"powercfg Win32Ex (UAC denied?): {w32Ex.Message}"; exitCode = w32Ex.NativeErrorCode; _loggingService.UiError(error, w32Ex); } 
            catch (Exception ex) { error = $"powercfg Ex: {ex.Message}"; exitCode = -2; _loggingService.UiError(error, ex); }
        }

        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue) { return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP/Port missing."); }
            var packetForFinalTarget = new CommandPacket { Instruction = CommandInstruction.DirectExecute, CommandName = originalRelayRequest.CommandName, PayloadJson = originalRelayRequest.PayloadJson, ResponseAddress = originalRelayRequest.ResponseAddress, ResponsePort = originalRelayRequest.ResponsePort, PacketId = Guid.NewGuid() };
            string relayStatusMessage = $"Relay: {packetForFinalTarget.CommandName} to {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}.";
            bool relayCommSuccess = false; CommandPacket responseFromFinalTarget = null;
            try {
                token.ThrowIfCancellationRequested();
                using (var targetClient = new TcpClient()) {
                    var connectTask = targetClient.ConnectAsync(originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand.Value);
                    if (await Task.WhenAny(connectTask, Task.Delay(TimeSpan.FromSeconds(5), token)) != connectTask || token.IsCancellationRequested) { token.ThrowIfCancellationRequested(); targetClient.Close(); throw new TimeoutException("Relay target connection timed out."); }
                    await connectTask; _loggingService.UiDebug($"[{clientIp}] 릴레이 대상 연결 성공.");
                    using (NetworkStream rS = targetClient.GetStream()) using (StreamWriter rW = new StreamWriter(rS, Encoding.UTF8){AutoFlush=true}) using (StreamReader rR = new StreamReader(rS, Encoding.UTF8)){
                        string jsonToRelay = JsonConvert.SerializeObject(packetForFinalTarget); if(token.IsCancellationRequested) token.ThrowIfCancellationRequested(); await rW.WriteLineAsync(jsonToRelay); _loggingService.UiDebug($"[{clientIp}] 릴레이 데이터 전송: {jsonToRelay}");
                        var targetResponseTask = rR.ReadLineAsync();
                        if (await Task.WhenAny(targetResponseTask, Task.Delay(TimeSpan.FromSeconds(10), token)) == targetResponseTask && !token.IsCancellationRequested){
                            string targetJson = await targetResponseTask; if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                            if (!string.IsNullOrEmpty(targetJson)){ _loggingService.UiInfo($"[{clientIp}] 릴레이 대상 응답: {targetJson}"); responseFromFinalTarget = JsonConvert.DeserializeObject<CommandPacket>(targetJson); relayCommSuccess = true; }
                            else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 빈 응답."); relayStatusMessage = "Relay sent, empty response from final target."; }
                        } else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 응답 시간 초과/취소."); relayStatusMessage = "Relay sent, no response/timeout/canceled from final target."; }
                    }
                }
            }
            catch (OperationCanceledException) { relayStatusMessage = $"Relay of {originalRelayRequest.CommandName} canceled."; _loggingService.UiInfo($"[{clientIp}] {relayStatusMessage}"); }
            catch (TimeoutException tex) { relayStatusMessage = $"Relay failed: Timeout - {tex.Message}"; _loggingService.UiWarn($"[{clientIp}] {relayStatusMessage}"); }
            catch (SocketException se) { relayStatusMessage = $"Relay failed: Socket error - {se.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", se); }
            catch (Exception ex) { relayStatusMessage = $"Relay failed: Unexpected error - {ex.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", ex); }
            if (responseFromFinalTarget != null) { responseFromFinalTarget.PacketId = originalRelayRequest.PacketId; return responseFromFinalTarget; }
            else { return CreateExecutionResponse(originalRelayRequest, relayCommSuccess, relayStatusMessage); }
        }

        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_Response", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort };
        }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN";
            _loggingService.UiError($"Error response for PktID {pId} (Cmd: {cmdName}): {errorMsg}");
            return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_ErrorResponse", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort };
        }
    }
}
3. 수정: Flask 웹 앱 scontrol_flask_web/app/routes_user.py (전체 파일)
"끄기" 명령 시 TimeoutSeconds: 5, "켜기" 명령 시 TimeoutSeconds: 0을 전송합니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection
from app.auth import ip_auth_required
from app.socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone # dt로 별칭 사용
import math

user_bp = Blueprint('user', __name__)

@user_bp.route('/control_panel')
@ip_auth_required('user')
def control_panel():
    page = request.args.get('page', 1, type=int); per_page = 20; offset = (page - 1) * per_page
    pcs_on_current_page = []; total_pcs = 0; conn = None
    pagination_data = {'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 'items': [], 'has_prev': False, 'has_next': False, 'prev_num': 1, 'next_num': 1} 
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute("SELECT COUNT(*) AS total FROM dbo.target_pcs"); total_pcs_result = cursor.fetchone()
            if total_pcs_result: total_pcs = total_pcs_result.get('total', 0)
            if total_pcs > 0: query = "SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY"; cursor.execute(query, (offset, per_page)); pcs_on_current_page = cursor.fetchall()
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({'total_items': total_pcs, 'total_pages': total_pages, 'items': pcs_on_current_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1 if page > 1 else 1, 'next_num': page + 1 if page < total_pages else total_pages})
    except Exception as e: current_app.logger.error(f"제어판 PC 목록 조회 오류: {e}", exc_info=True); flash("PC 목록 DB 조회 오류.", "error")
    title = "원격 제어판"; 
    if g.current_user_role == 'admin': title = "원격 제어판 (관리자 모드)"
    return render_template('user/control_panel.html', pcs=pcs_on_current_page, pagination=pagination_data, title=title)

@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    selected_pc_ids_str = request.form.getlist('selected_pcs'); command_action_str = request.form.get('command_action')
    if not selected_pc_ids_str: flash("PC를 선택하세요.", 'warning'); return redirect(url_for('user.control_panel'))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]: flash("명령(켜기/끄기) 지정 오류.", 'warning'); return redirect(url_for('user.control_panel'))

    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]; conn = None; target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids: placeholders = ', '.join(['%s'] * len(selected_pc_ids)); sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"; cursor.execute(sql_select_pcs, tuple(selected_pc_ids)); target_pcs_to_control = cursor.fetchall()
    except Exception as e: current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True); flash("명령 대상 PC 정보 DB 조회 오류.", "error"); return redirect(url_for('user.control_panel'))
    if not target_pcs_to_control: flash("선택된 PC 정보 없음.", "warning"); return redirect(url_for('user.control_panel'))

    # ▼▼▼ "끄기"는 5초, "켜기"는 0초(Never)로 설정 ▼▼▼
    timeout_seconds_for_command = 0 if command_action_str == "켜기" else 5 
    action_desc_timeout = "디스플레이 항상 켜기(0초)" if command_action_str == "켜기" else "디스플레이 5초 후 자동 꺼짐"
    payload_timeout = {'TimeoutSeconds': timeout_seconds_for_command} # 필드명 TimeoutSeconds
    # ▲▲▲ "끄기"는 5초, "켜기"는 0초(Never)로 설정 ▲▲▲

    for pc_data in target_pcs_to_control:
        packet_set_timeout = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': "SET_DISPLAY_TIMEOUT", 'PayloadJson': json.dumps(payload_timeout), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: packet_set_timeout.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: packet_set_timeout.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"PC '{pc_data.get('pc_name','N/A')}' ({target_ip})"; flash(f"{log_prefix} '{action_desc_timeout}' 전송 시도...", 'info')
        current_app.logger.info(f"{log_prefix} - 전송: {action_desc_timeout}, PktID: {packet_set_timeout['PacketId']}")
        response_timeout = send_command_to_agent(target_ip, packet_set_timeout)
        _process_agent_response(response_timeout, log_prefix, "타임아웃 설정")

        if command_action_str == "켜기": # "켜기"일 때만 즉시 모니터 켜기 명령 추가
            action_desc_monitor_on = "모니터 즉시 켜기"; payload_monitor_on = {'Action': -1} # MonitorAction.On
            packet_monitor_on = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': "MONITOR_CONTROL", 'PayloadJson': json.dumps(payload_monitor_on), 'ResponseAddress': None, 'ResponsePort': None, 'Instruction': packet_set_timeout['Instruction'], 'FinalTargetIpForRelayedCommand': packet_set_timeout.get('FinalTargetIpForRelayedCommand'), 'FinalTargetPortForRelayedCommand': packet_set_timeout.get('FinalTargetPortForRelayedCommand') }
            flash(f"{log_prefix} '{action_desc_monitor_on}' 추가 전송 시도...", 'info'); current_app.logger.info(f"{log_prefix} - 전송: {action_desc_monitor_on}, PktID: {packet_monitor_on['PacketId']}")
            response_monitor_on = send_command_to_agent(target_ip, packet_monitor_on)
            _process_agent_response(response_monitor_on, log_prefix, "즉시 모니터 켜기")
    return redirect(url_for('user.control_panel'))

def _process_agent_response(agent_response, log_prefix, command_description):
    if agent_response.get('success'):
        raw_pkt = agent_response.get('raw_response')
        if raw_pkt and isinstance(raw_pkt, dict) and 'PayloadJson' in raw_pkt:
            payload_str = raw_pkt.get('PayloadJson')
            current_app.logger.info(f"{log_prefix} - '{command_description}' 응답 PayloadJson: >>>{payload_str}<<<")
            if payload_str is not None:
                try:
                    resp_pl = json.loads(payload_str)
                    if resp_pl.get('Success'): flash(f"{log_prefix} ({command_description}): 성공 - {resp_pl.get('Message', 'OK')}", 'success'); current_app.logger.info(f"{log_prefix} ({command_description}) 성공: {resp_pl.get('Message')}")
                    else: flash(f"{log_prefix} ({command_description}): 실패 (에이전트) - {resp_pl.get('Message', 'Agent error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 에이전트 실패: {resp_pl.get('Message')}")
                except json.JSONDecodeError as je: flash(f"{log_prefix} ({command_description}): 응답 JSON 형식 오류 - {je.msg}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 파싱 오류: {je.msg}. 원본: {payload_str}", exc_info=True)
                except Exception as e: flash(f"{log_prefix} ({command_description}): 응답 처리 중 알 수 없는 오류 - {e}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_str}", exc_info=True)
            else: flash(f"{log_prefix} ({command_description}): 전송 성공 (페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 페이로드 없음. RawPkt: {raw_pkt}")
        else: flash(f"{log_prefix} ({command_description}): 전송 성공 (상세 응답/페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 상세 응답/페이로드 없음. RawPkt: {raw_pkt}")
    else: flash(f"{log_prefix} ({command_description}): 전송 실패 - {agent_response.get('message', 'Socket error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 전송 실패: {agent_response.get('message')}")
4. 수정: Flask 웹 앱 scontrol_flask_web/app/scheduler_tasks.py (전체 파일)
스케줄된 작업에서도 "끄기"는 5초, "켜기"는 0초(Never)로 TimeoutSeconds를 설정합니다.

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date
import holidays
from flask import current_app # _send_display_timeout_to_all_pcs 등에서 사용될 수 있음
from .db_utils import get_db_connection
from .socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone

def is_operational_day(target_date, app_instance_logger): # 로거를 직접 받거나 current_app.logger 사용
    conn = None
    try:
        conn = get_db_connection() 
        if not conn: app_instance_logger.error(f"is_operational_day ({target_date}): DB 연결 실패. 기본 가동일 처리."); return True 
        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"; cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),)); exception_day = cursor.fetchone()
            if exception_day: is_op = bool(exception_day['is_operational']); app_instance_logger.info(f"{target_date} 사용자 지정 예외: {'가동일' if is_op else '비가동일'}"); return is_op
        if target_date.weekday() >= 5: app_instance_logger.info(f"{target_date} 주말(비가동일)."); return False
        kr_holidays = holidays.KR(years=target_date.year, observed=True) 
        if target_date in kr_holidays: app_instance_logger.info(f"{target_date} 공휴일('{kr_holidays.get(target_date)}'). (비가동일)"); return False
        app_instance_logger.info(f"{target_date} 평일(가동일)."); return True
    except Exception as e: app_instance_logger.error(f"is_operational_day ({target_date}) 오류: {e}", exc_info=True); return True 

def _send_display_timeout_to_all_pcs(timeout_seconds_val, action_description, app_instance_logger): # 초 단위로 받음
    conn = None; pcs_to_control = []
    try:
        conn = get_db_connection()
        if not conn: app_instance_logger.error(f"_send_display_timeout_to_all_pcs: DB 연결 실패."); return
        with conn.cursor() as cursor: cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs"); pcs_to_control = cursor.fetchall()
    except Exception as e: app_instance_logger.error(f"스케줄 PC 목록 조회 오류: {e}", exc_info=True); return 
    if not pcs_to_control: app_instance_logger.info("스케줄: 제어할 PC 없음."); return

    app_instance_logger.info(f"스케줄: '{action_description}' ({len(pcs_to_control)}대 PC).")
    payload_obj = {'TimeoutSeconds': timeout_seconds_val} # TimeoutSeconds 사용
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        command_packet = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: command_packet.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: command_packet.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip})]"
        app_instance_logger.info(f"{log_prefix} - '{action_description}' 전송 시도. PktID: {command_packet['PacketId']}")
        try:
            # send_command_to_agent는 current_app.logger를 사용. app_context 내에서 호출되므로 OK
            agent_response = send_command_to_agent(target_ip, command_packet) 
            if agent_response.get('success'):
                raw_pkt = agent_response.get('raw_response')
                if raw_pkt and isinstance(raw_pkt, dict) and raw_pkt.get('PayloadJson'):
                    resp_pl = json.loads(raw_pkt['PayloadJson'])
                    if resp_pl.get('Success'): app_instance_logger.info(f"{log_prefix} - 성공: {resp_pl.get('Message', 'OK')}")
                    else: app_instance_logger.error(f"{log_prefix} - 실패 (에이전트): {resp_pl.get('Message', 'Agent error')}")
                else: app_instance_logger.warning(f"{log_prefix} - 전송 성공, 상세 응답 확인 불가. Raw: {raw_pkt}")
            else: app_instance_logger.error(f"{log_prefix} - 전송 실패: {agent_response.get('message', 'Socket error')}")
        except Exception as e_send: app_instance_logger.error(f"{log_prefix} - 명령 전송 중 예외: {e_send}", exc_info=True)

def scheduled_task_monitor_on(app_instance): 
    with app_instance.app_context(): 
        today = date.today(); app_instance.logger.info(f"[Scheduler] 모니터 켜기 작업 (06:00) 시작, 오늘: {today}")
        if is_operational_day(today, app_instance.logger): # 로거 전달
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 켜기(타임아웃 0초)' 명령 전송.")
            _send_display_timeout_to_all_pcs(0, "디스플레이 항상 켜기 (타임아웃 0초)", app_instance.logger) # 로거 전달
            
            # --- 추가: 즉시 모니터 켜기 (SC_MONITORPOWER) 명령 전송 ---
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 즉시 켜기' 명령 추가 전송.")
            _send_immediate_monitor_control_to_all_pcs(-1, "모니터 즉시 켜기 (SC_MONITORPOWER)", app_instance.logger) # MonitorAction.On = -1
            # --- 추가 끝 ---
        else: app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 켜기' 명령 미실행.")
        app_instance.logger.info(f"[Scheduler] 모니터 켜기 작업 완료.")

def scheduled_task_monitor_off(app_instance): 
    with app_instance.app_context():
        today = date.today(); app_instance.logger.info(f"[Scheduler] 모니터 끄기 작업 (07:00) 시작, 오늘: {today}")
        if not is_operational_day(today, app_instance.logger): 
            app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 끄기(5초 후 타임아웃)' 명령 전송.")
            _send_display_timeout_to_all_pcs(5, "디스플레이 5초 후 자동 꺼짐 설정", app_instance.logger) # 5초로 변경
        else: app_instance.logger.info(f"[Scheduler] 가동일: '모니터 끄기' 명령 미실행.")
        app_instance.logger.info(f"[Scheduler] 모니터 끄기 작업 완료.")

# --- 즉시 모니터 제어를 위한 헬퍼 함수 (신규 추가) ---
def _send_immediate_monitor_control_to_all_pcs(monitor_action_value, action_description, app_instance_logger):
    conn = None; pcs_to_control = []
    try:
        conn = get_db_connection();
        if not conn: app_instance_logger.error(f"_send_immediate_monitor_control: DB 연결 실패."); return
        with conn.cursor() as cursor: cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs"); pcs_to_control = cursor.fetchall()
    except Exception as e: app_instance_logger.error(f"스케줄 즉시 모니터 제어 PC 목록 조회 오류: {e}", exc_info=True); return
    if not pcs_to_control: app_instance_logger.info("스케줄 즉시 모니터 제어: 대상 PC 없음."); return

    app_instance_logger.info(f"스케줄 즉시 모니터 제어 시작: '{action_description}' ({len(pcs_to_control)}대 PC).")
    payload_obj = {'Action': monitor_action_value} # MonitorControlPayload
    common_command_name = "MONITOR_CONTROL" # SControl.Common.CommandNames.MonitorControl

    for pc_data in pcs_to_control:
        command_packet = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: command_packet.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: command_packet.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"[Scheduler-Immediate][PC: {pc_data.get('pc_name','N/A')}({target_ip})]"
        app_instance_logger.info(f"{log_prefix} - '{action_description}' 전송 시도. PktID: {command_packet['PacketId']}")
        try:
            agent_response = send_command_to_agent(target_ip, command_packet)
            # 응답 처리 로직은 _send_display_timeout_to_all_pcs와 유사하게 구현 가능 (생략)
            if agent_response.get('success'): app_instance_logger.info(f"{log_prefix} - '{action_description}' 명령 전송 성공 또는 에이전트 응답 수신.")
            else: app_instance_logger.error(f"{log_prefix} - '{action_description}' 명령 전송 실패: {agent_response.get('message')}")
        except Exception as e_send: app_instance_logger.error(f"{log_prefix} - '{action_description}' 명령 전송 중 예외: {e_send}", exc_info=True)

변경 사항 요약:

SControl.Common/Payloads.cs:
SetDisplayTimeoutPayload의 TimeoutMinutes (int)를 TimeoutSeconds (int)로 변경했습니다.
SAgentM.App/Services/AgentCoreService.cs:
ExecuteDirectCommandAsync 내 SetDisplayTimeout 처리부에서 timeoutPayload.TimeoutMinutes * 60 대신 timeoutPayload.TimeoutSeconds를 직접 powercfg 명령에 사용합니다.
scontrol_flask_web/app/routes_user.py:
send_batch_command 함수에서 "끄기" 명령 시 payload_for_agent = {'TimeoutSeconds': 5} (5초)로, "켜기" 명령 시 payload_for_agent = {'TimeoutSeconds': 0} (Never)으로 페이로드를 구성하여 전송합니다.
"켜기" 명령 시, SetDisplayTimeout 명령 전송 후, 이어서 MONITOR_CONTROL 명령 (페이로드: {'Action': -1})을 추가로 전송하여 즉시 모니터를 켜도록 합니다. (이 로직은 이전 답변 #44에서 이미 추가되었던 내용입니다. 다시 한번 확인하여 포함했습니다.)
_process_agent_response 헬퍼 함수를 사용하여 각 명령에 대한 응답 처리 및 로깅을 수행합니다.
scontrol_flask_web/app/scheduler_tasks.py:
_send_display_timeout_to_all_pcs 함수가 이제 timeout_seconds_val을 인자로 받습니다.
scheduled_task_monitor_off: "끄기" 명령 시 _send_display_timeout_to_all_pcs(5, ...) (5초)를 호출합니다.
scheduled_task_monitor_on: "켜기" 명령 시 _send_display_timeout_to_all_pcs(0, ...) (Never)를 호출하고, 추가적으로 _send_immediate_monitor_control_to_all_pcs(-1, ...) (즉시 모니터 켜기)를 호출하는 로직을 추가했습니다. 이를 위해 _send_immediate_monitor_control_to_all_pcs 헬퍼 함수도 새로 만들었습니다.
중요: 위 코드들을 각 파일에 적용하신 후에는 반드시 SAgentM.App (WPF 에이전트)를 재빌드하시고, Flask 웹 애플리케이션도 재시작해야 변경사항이 반영됩니다.

"모니터를 꺼짐을 해당없음(0)으로 수정하면 이게 바로켜지지가 않잖아? 켜게하는 명령을 추가하고싶은데" 라는 질문에 대해서는, 위 routes_user.py와 scheduler_tasks.py의 "켜기" 로직에 이미 디스플레이 타임아웃을 0으로 설정하는 명령과 함께 즉시 모니터를 켜는 MONITOR_CONTROL 명령을 추가로 보내도록 구현되어 있습니다. 따라서 별도의 추가 명령 없이 "켜기" 버튼/스케줄이 이 두 가지 동작을 모두 수행하게 됩니다.