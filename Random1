송합니다, 설명을 더 명확하게 드릴게요. DT2330 번지에 대한 값 처리와 기존 0부터 4까지 버튼을 통합하여 각 버튼이 0부터 4까지의 값으로 동작하도록 해야 하는데, 이를 반영하지 못했습니다.

각 버튼이 0부터 4까지의 값에 대해 PLC로 값을 전송하고, DT2330을 처리하는 방식으로 통합해보겠습니다. DT2330과 관련된 기능을 추가한 후, 필요한 기능을 구현한 버튼을 동적으로 생성하도록 할게요.

수정된 MainWindow.xaml
DT2330에 대한 값을 처리하는 추가 버튼들을 동적으로 생성하기 위해 ItemsControl을 사용합니다. 이 경우, 0부터 4까지의 버튼을 만들어 PLC로 값을 전송하게 합니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <StackPanel Orientation="Vertical" Margin="10">
            <!-- PLC 상태 표시 -->
            <TextBlock Text="PLC 상태:" FontWeight="Bold" FontSize="16" />
            <TextBlock Text="{Binding R520Status}" Margin="5" />
            <TextBlock Text="{Binding R521Status}" Margin="5" />

            <!-- 사용자 입력 텍스트박스와 전송 버튼 -->
            <TextBox x:Name="ValueInputTextBox" Width="200" Margin="5"/>
            <Button Content="텍스트 값 전송" Command="{Binding SendTextBoxValueCommand}" CommandParameter="{Binding Text, ElementName=ValueInputTextBox}" Margin="5" />

            <!-- Zero부터 4까지 동적 버튼 생성 -->
            <ItemsControl ItemsSource="{Binding ButtonCommands}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Button Content="{Binding Key}" Command="{Binding Value}" Margin="2"/>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- DT2330 처리용 버튼들 추가 -->
            <ItemsControl ItemsSource="{Binding DT2330Commands}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Button Content="{Binding Key}" Command="{Binding Value}" Margin="2"/>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </StackPanel>
    </Grid>
</Window>
수정된 MainViewModel.cs
MainViewModel에 DT2330 관련 명령을 추가하고, 이를 기반으로 버튼을 동적으로 생성하여 UI에 반영합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        // Zero부터 4까지 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        // DT2330 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> DT2330Commands { get; set; }

        // 명령 생성
        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            DT2330Commands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();
            InitializeDT2330Commands();

            // 명령 초기화
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 0; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await SendNumberToPLC(value))));
            }
        }

        private void InitializeDT2330Commands()
        {
            for (int i = 0; i <= 4; i++)
            {
                int value = i;
                DT2330Commands.Add(new KeyValuePair<string, ICommand>(
                    $"Process DT2330 - {i}",
                    new RelayCommand(async () => await ProcessDT2330Value(value))));
            }
        }

        public async Task SendNumberToPLC(int number)
        {
            string command = $"%01#WDD0230000230{number:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(command);
            LogMessage($"Sent {number} to PLC");
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                await _comPortManager.SendDataToPLCAsync(command);
                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ProcessDT2330Value(int value)
        {
            // DT2330 값을 처리하고, 특정 작업을 수행합니다
            LogMessage($"Processed value from DT2330: {value}");

            // 필요에 따라 값을 초기화하거나 다른 작업을 수행할 수 있습니다
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
설명 및 적용 방법
UI 수정: MainWindow.xaml에서 두 개의 ItemsControl을 사용하여 두 종류의 버튼을 동적으로 생성합니다. 첫 번째 ItemsControl은 Zero부터 4까지의 PLC 값을 전송하는 버튼을 생성하고, 두 번째 ItemsControl은 DT2330의 값을 처리하는 버튼을 생성합니다.

ViewModel 수정:

InitializeCommands: Zero부터 4까지의 값을 PLC로 전송하는 명령을 동적으로 생성하여 ButtonCommands에 추가합니다.
InitializeDT2330Commands: DT2330의 값을 0부터 4까지 처리하는 명령을 동적으로 생성하여 DT2330Commands에 추가합니다.
ProcessDT2330Value: DT2330의 특정 값을 처리하고 필요에 따라 초기화하거나 다른 작업을 수행하는 메서드입니다.
적용 방법: 각 버튼이 클릭될 때, 해당하는 명령이 실행되어 PLC로 값을 전송하거나 DT2330 값을 처리합니다. 이를 통해 사용자는 다양한 입력을 PLC에 전송하고, PLC로부터 특정 값을 읽어와 처리할 수 있습니다.

이렇게 수정된 코드를 적용하면, 기존 기능을 유지하면서 새로운 기능을 통합하여 보다 유연하고 확장 가능한 UI와 기능을 제공할 수 있습