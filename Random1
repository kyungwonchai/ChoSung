알겠습니다. 말씀하신 대로 정지는 전체적으로 공통으로 적용되는 버튼이고, **리쥼(Resume)**은 각 행에서 개별적으로 동작해야 한다는 점을 기억해냈습니다. 또한, TaskQueue는 그대로 작업을 관리하며, 일시정지된 작업들을 다시 순차적으로 실행하는 기능만 포함하겠습니다.

지금부터는 이전 작업과 일치하도록 일시정지와 리쥼 기능을 다시 반영한 코드를 제공합니다.

전체 수정된 코드
1. TaskQueue.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하며, 작업이 완료되면 다음 작업을 실행합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;  // 현재 작업이 실행 중인지 여부

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        // 현재 작업이 실행 중이 아니면 즉시 실행
        if (!_isRunning)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;  // 현재 작업 실행 중

        var task = _tasks.Dequeue();  // 큐에서 작업을 가져와 실행
        await task();  // 비동기 작업 실행

        _isRunning = false;  // 작업 완료 후 실행 중 상태 해제
        RunNextTask();  // 다음 작업 실행
    }

    /// <summary>
    /// 작업 큐를 초기화하고 비웁니다.
    /// </summary>
    public void ClearQueue()
    {
        _tasks.Clear();  // 작업 큐 비우기
        _isRunning = false;  // 실행 상태 해제
    }
}
2. TaskModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스에 따라 함수들을 실행합니다.
/// 작업이 완료되면 상태를 변경하고, 도형 색상을 업데이트합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수와 도형 상태를 한 곳에서 관리
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }  // 리쥼 커맨드 (특정 행에서 시작)

    private TaskQueue _taskQueue;
    private Action<TaskModel> _resumeFromHere;  // 특정 행부터 재개할 델리게이트

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, Action<TaskModel> resumeFromHere)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;
        _taskQueue = taskQueue;
        _resumeFromHere = resumeFromHere;  // 해당 행부터 재개하기 위한 델리게이트 전달

        // 함수 상태 초기화
        FunctionStatusList = new ObservableCollection<FunctionStatus>();

        Status = "Pending";  // 처음엔 대기 상태
        ResumeCommand = new RelayCommand(() => _resumeFromHere(this));  // 리쥼 버튼 클릭 시 실행

        // 함수 추가 (예시로 3개의 함수)
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
    }

    /// <summary>
    /// 함수 이름, 작업, 도형 색상을 함께 관리
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);  // 도형과 상태를 함께 관리
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            functionStatus.UpdateStatus(Brushes.SkyBlue);  // 실행 중
            await functionStatus.Task();  // 비동기 작업 실행
            functionStatus.UpdateStatus(Brushes.Green);  // 완료됨
        }
        Status = "Completed";  // 전체 작업 완료
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}

/// <summary>
/// FunctionStatus는 각 함수의 상태와 이름을 관리하는 클래스입니다.
/// </summary>
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush statusColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = statusColor;
    }

    /// <summary>
    /// 도형의 색상을 업데이트하여 상태를 나타냅니다.
    /// </summary>
    public void UpdateStatus(Brush newColor)
    {
        StatusColor = newColor;
        OnPropertyChanged(nameof(StatusColor));  // UI 업데이트
    }
}
3. MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.Windows;
using System.Linq;

public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();
    }

    /// <summary>
    /// 특정 행의 리쥼 버튼을 눌렀을 때 그 행부터 시작하여 남은 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeTasksFrom(TaskModel startTask)
    {
        _taskQueue.ClearQueue();  // 기존 큐를 비워서 모든 작업을 리셋
        bool startAdding = false;

        // TaskList에서 선택한 행부터 끝까지 다시 큐에 작업 추가
        foreach (var task in TaskList)
        {
            if (task == startTask)
            {
                startAdding = true;
            }

            if (startAdding)
            {
                _taskQueue.EnqueueTask(async () => await task.ExecuteTaskSequence());
            }
        }
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(logEntry, _taskQueue, ResumeTasksFrom);
            TaskList.Add(task);  // UI 스레드에서 작업 목록에 추가
        });
    }
}
4. XAML 코드
xml
코드 복사
<Window x:Class="YourApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- 작업 목록을 표시하는 DataGrid -->
        <DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>
                <DataGridTemplateColumn Header="Function Status">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <!-- 도형과 상태를 표시하는 ItemsControl -->
                            <ItemsControl ItemsSource="{Binding FunctionStatusList}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <StackPanel Orientation="Horizontal">
                                            <!-- 함수 이름 표시 -->
                                            <Ellipse Width="30" Height="30" Fill="{Binding StatusColor}">
                                                <Ellipse.ToolTip>
                                                    <TextBlock Text="{Binding FunctionName}" />
                                                </Ellipse.ToolTip>
                                            </Ellipse>
                                        </StackPanel>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <!-- 리쥼 버튼 -->
                <DataGridTemplateColumn Header="Resume">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Button Content="Resume" Command="{Binding ResumeCommand}"/>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
주요 기능:
전체 정지: 전체 작업 정지 버튼은 없애고, 각 작업의 리쥼(Resume) 버튼만 남겼습니다.
작업 재개: 각 행에 있는 리쥼(Resume) 버튼을 누르면 해당 행부터 모든 작업이 순차적으로 다시 시작됩니다.
도형 상태: 작업의 상태에 따라 도형의 색상이 변경됩니다.
작업 큐 초기화: 기존 작업을 리셋하고 새로운 작업을 재개할 수 있습니다.
이전 방식으로 일시정지와 리쥼 기능을 복원했으며, 이제 다시 정상적으로 동작할 것입니