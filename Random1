겠습니다. 아래는 요청하신 사항들을 반영하여, c:\prod_file_logs 디렉토리에서 생성된 지 3일 이상 된 파일들만 대상으로 하고, 최대 30만 행까지 수집하여 CSV로 저장하는 코드입니다. DetailCMD 파일명을 정확히 구분하고, CSV 파일은 c:\Agent 디렉토리에 yyyyMMddHHmmss 형식의 타임스탬프를 붙여 저장됩니다.

코드
python
코드 복사
import os
import csv
import re
from datetime import datetime, timedelta

# 디렉토리 경로 설정
directory_path = 'c:/prod_file_logs/'
output_directory = 'c:/Agent/'

# 3일 전 날짜 계산
three_days_ago = datetime.now() - timedelta(days=3)

# 출력할 최대 행 수
max_rows = 300000

# 정규 표현식 패턴 설정
time_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'  # 날짜와 시간 추출 패턴
key_pattern = r'고유키:[^\s]+'  # 고유키 추출 패턴 (공백 전까지)
send_value_pattern = r'보낸값:[^\s]+'  # 보낸값 추출 패턴 (공백 전까지)
recv_value_pattern = r'받은값:[^\s]+'  # 받은값 추출 패턴 (공백 전까지)

# CSV로 저장할 데이터를 담을 리스트
data_for_csv = []

# 디렉토리 내 모든 파일 순회
for filename in os.listdir(directory_path):
    # "DetailCMD"가 포함된 .txt 파일만 처리하며, 3일 전보다 이전에 생성된 파일만
    file_path = os.path.join(directory_path, filename)
    if filename.endswith('.txt') and 'DetailCMD' in filename:
        file_creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
        
        if file_creation_time <= three_days_ago:
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()  # 파일의 모든 줄을 읽음
                i = 0
                
                # 각 줄을 순회하면서 "보낸값"과 "받은값" 쌍 찾기
                while i < len(lines):
                    # "보낸값" 줄을 찾음
                    send_match = re.search(send_value_pattern, lines[i])
                    
                    if send_match:
                        # "보낸값" 줄에서 시간, 고유키, 보낸값 추출
                        time_match = re.search(time_pattern, lines[i])
                        key_match = re.search(key_pattern, lines[i])
                        
                        if time_match and key_match:
                            # 시간과 고유키 추출
                            time_str = time_match.group()
                            unique_key = key_match.group().split(':')[1]  # 고유키 값만 추출
                            send_value = send_match.group().split(':')[1]  # 보낸값 값만 추출

                            # 다음 줄에서 "받은값" 추출
                            if i + 1 < len(lines):
                                recv_match = re.search(recv_value_pattern, lines[i + 1])

                            if recv_match:
                                recv_value = recv_match.group().split(':')[1]  # 받은값 값만 추출
                                
                                # 시간 형식을 "yyMMdd HHmmss"로 변환
                                original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                                formatted_time = original_time.strftime('%y%m%d %H%M%S')

                                # 응답값의 길이 계산
                                recv_length = len(recv_value)

                                # 데이터 리스트에 추가 (시간, 고유키, 보낸값, 받은값, 받은값 길이)
                                data_for_csv.append([formatted_time, unique_key, send_value, recv_value, recv_length])

                                # 데이터가 max_rows만큼 모이면 CSV로 저장하고 종료
                                if len(data_for_csv) >= max_rows:
                                    # length와 시간 순으로 정렬
                                    data_for_csv.sort(key=lambda x: (x[4], x[0]))

                                    # 파일 이름에 타임스탬프 추가
                                    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                                    output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')
                                    
                                    # CSV 파일로 저장
                                    with open(output_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                                        csv_writer = csv.writer(csvfile)
                                        csv_writer.writerow(['Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length'])
                                        csv_writer.writerows(data_for_csv)
                                    exit()  # 스크립트 종료
                        
                        # "보낸값" 다음 줄로 이동
                        i += 2
                    else:
                        # "보낸값"이 없는 경우 다음 줄로 이동
                        i += 1

# 혹시 max_rows보다 적게 데이터가 모일 경우에 대비하여 최종 저장
if data_for_csv and len(data_for_csv) < max_rows:
    # length와 시간 순으로 정렬
    data_for_csv.sort(key=lambda x: (x[4], x[0]))

    # 파일 이름에 타임스탬프 추가
    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')
    
    # CSV 파일로 저장
    with open(output_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length'])
        csv_writer.writerows(data_for_csv)

print(f'\nCSV 파일 생성 완료: {output_csv_path}')
코드 설명
3일 전 파일 필터링:

three_days_ago 변수를 사용하여, c:/prod_file_logs 디렉토리의 파일 중 3일 전 또는 그 이전에 생성된 파일만 처리합니다.
파일 필터링 조건:

DetailCMD가 포함된 파일명을 대소문자 구분하여 정확하게 처리합니다.
최대 30만 행까지 수집:

max_rows를 30만으로 설정하여, 최대 30만 행이 모이면 즉시 CSV로 저장 후 스크립트를 종료합니다.
정렬 조건:

data_for_csv 리스트를 응답값 길이(length)가 작은 순서대로, 같은 길이일 경우 시간을 기준으로 정렬합니다.
CSV 파일 이름에 타임스탬프 추가:

저장될 CSV 파일 이름에 현재 시간(yyyyMMddHHmmss 형식의 타임스탬프)을 추가하여 저장합니다.
최종 데이터 저장:
