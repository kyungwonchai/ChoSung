using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>();
    public string CurrentTime { get; set; }
    public event PropertyChangedEventHandler PropertyChanged;

    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    private bool _isProcessing;
    private bool _isQueueStopped;
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3;
    public int RetryInterval { get; set; } = 3000;
    public int ResponseTimeout { get; set; } = 5000;
    public int MaximumQueueSize { get; set; } = 10;

    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress));
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false;
        _isQueueStopped = false;
        Progress = 0;

        DispatcherTimer timer = new DispatcherTimer();
        timer.Interval = TimeSpan.FromMilliseconds(100);
        timer.Tick += (s, e) => UpdateCurrentTime();
        timer.Start();
    }

    private void UpdateCurrentTime()
    {
        CurrentTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff");
        OnPropertyChanged(nameof(CurrentTime));
    }

    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("Queue limit reached or stopped. No further commands can be added.");
            return;
        }
        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem
        {
            CommandText = commandText,
            Status = "Pending",
            MaxRetryLimit = RetryLimit,
            RetryCount = 0,
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff")
        };

        App.Current.Dispatcher.Invoke(() => RemainingCommands.Add(newCommand));

        commandQueue.Enqueue(async () =>
        {
            if (_isQueueStopped)
            {
                newCommand.Status = "Stopped";
                return new CommandResult { Success = false, Message = "Queue Stopped" };
            }

            newCommand.Status = "Processing";
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Start();
            string result = await taskFunc();
            stopwatch.Stop();

            int responseTime = (int)stopwatch.ElapsedMilliseconds;
            newCommand.ResponseTime = responseTime;
            newCommand.RetryCount++;

            if (responseTime > ResponseTimeout)
            {
                newCommand.Status = "Timeout";
                StopQueueProcessing(newCommand);
                return new CommandResult { Success = false, Message = "Timeout" };
            }

            if (responseValidator(result))
            {
                newCommand.Status = "Completed";
                newCommand.Result = 1;
                return new CommandResult { Success = true, Message = "Success", Data = result };
            }

            if (newCommand.RetryCount < RetryLimit)
            {
                await Task.Delay(RetryInterval);
                return new CommandResult { Success = false, Message = "Retry" };
            }

            newCommand.Status = "Failed";
            StopQueueProcessing(newCommand);
            return new CommandResult { Success = false, Message = "Failed after retries" };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }
        UpdateProgress();
    }

    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0 && !_isQueueStopped)
        {
            var command = commandQueue.Dequeue();
            await command();
            UpdateProgress();
        }
        _isProcessing = false;
    }

    private void StopQueueProcessing(CommandItem errorCommand)
    {
        _isQueueStopped = true;
        commandQueue.Clear();
        App.Current.Dispatcher.Invoke(() => ErrorCommands.Add(errorCommand));
        ShowAlarm("Queue has been stopped due to a Timeout or failure.");
    }

    private void ShowAlarm(string message)
    {
        var errorCommand = new CommandItem
        {
            CommandText = message,
            Status = "Error",
            Result = 0,
            RetryCount = 0,
            ResponseTime = 0,
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff")
        };

        App.Current.Dispatcher.Invoke(() => {
            ErrorCommands.Add(errorCommand);
            TrimErrorCommands();
        });
    }

    private void TrimErrorCommands()
    {
        while (ErrorCommands.Count > 50)
        {
            ErrorCommands.RemoveAt(0);
        }
    }

    private void UpdateProgress()
    {
        Progress = commandQueue.Count;
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

public class CommandResult
{
    public bool Success { get; set; }
    the message; Message { get; set; }
    public string Data { get; set; }
}
