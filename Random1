 프로젝트는 8개의 값을 가진 데이터(부류 A와 부류 B의 값을 포함)에서 한 값을 나머지 7개의 값으로 예측하는 모델을 생성하고, 이를 통해 데이터 모니터링 시스템을 구축하는 과제입니다. 다음은 Python과 Scikit-learn을 사용하여 이 문제를 해결하는 전체 코드를 포함한 상세 설명입니다.

1. 주요 단계
데이터 준비
부류 A와 부류 B의 4개씩 총 8개의 실수값 데이터 준비.
모델 학습 및 평가
한 값을 제외한 나머지 7개의 값으로 예측 모델을 학습.
이를 반복해 8개 값 각각에 대해 예측.
최적 모델 선택
각 값에 대해 가장 예측 성능이 좋은 모델을 선택.
실시간 모니터링
새로운 값이 들어올 때, 예측 오차의 평균치 계산.
오차 평균의 변화 추이를 시각화.
2. 전체 코드
python
코드 복사
import numpy as np
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt

# 초기 데이터 설정
np.random.seed(42)
data_a = np.random.rand(4)  # 부류 A의 4개 값 (0~1 사이)
data_b = np.random.rand(4)  # 부류 B의 4개 값 (0~1 사이)
data = np.concatenate([data_a, data_b])  # 총 8개의 데이터

# 모델 리스트
models = {
    "RandomForest": RandomForestRegressor(),
    "LinearRegression": LinearRegression(),
    "SVR": SVR(kernel="linear")
}

# 최적 모델 찾기 및 예측
best_models = []
errors = []
for i in range(8):
    # i번째 값을 제외한 나머지 7개 값으로 학습 데이터 구성
    X = np.delete(data, i).reshape(-1, 1)  # 7개의 값
    y = np.delete(data, np.arange(len(data)) != i)  # 예측 대상 (1개의 값)
    
    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)
    
    # 각 모델로 학습 및 평가
    best_model = None
    best_error = float("inf")
    for model_name, model in models.items():
        model.fit(X_train, y_train)
        predictions = model.predict(X_test)
        error = mean_squared_error(y_test, predictions)
        
        if error < best_error:
            best_error = error
            best_model = model_name
    
    best_models.append(best_model)
    errors.append(best_error)

# 결과 출력
print("Best model for each data point:", best_models)
print("Errors for each model:", errors)

# 실시간 모니터링 시뮬레이션
new_data = np.random.rand(100, 8)  # 새로운 데이터 (100개의 샘플)
avg_errors = []

for sample in new_data:
    sample_errors = []
    for i, model_name in enumerate(best_models):
        model = models[model_name]
        X_sample = np.delete(sample, i).reshape(-1, 1)
        y_sample = sample[i]
        
        prediction = model.predict(X_sample)
        error = abs(prediction - y_sample)
        sample_errors.append(error)
    
    avg_error = np.mean(sample_errors)
    avg_errors.append(avg_error)

# 평균 오차의 변화 시각화
plt.plot(avg_errors, label="Average Prediction Error")
plt.xlabel("New Sample Index")
plt.ylabel("Average Error")
plt.legend()
plt.title("Real-time Monitoring of Prediction Errors")
plt.show()
3. 코드 상세 설명
1) 데이터 준비
data_a와 data_b는 각각 4개의 실수값으로 이루어진 배열입니다.
이를 합쳐 총 8개의 데이터로 구성합니다.
python
코드 복사
data_a = np.random.rand(4)  # 부류 A의 4개 값
data_b = np.random.rand(4)  # 부류 B의 4개 값
data = np.concatenate([data_a, data_b])  # 총 8개의 데이터
2) 모델 학습 및 평가
각 데이터 점에 대해 한 값을 제외한 나머지 7개를 독립 변수(X), 제외된 값을 종속 변수(y)로 설정합니다.
3가지 모델(RandomForest, LinearRegression, SVR)을 테스트하며 가장 낮은 MSE(Mean Squared Error)를 가진 모델을 선택합니다.
최적 모델은 best_models 리스트에 저장됩니다.
python
코드 복사
for i in range(8):
    X = np.delete(data, i).reshape(-1, 1)  # 7개의 값
    y = np.delete(data, np.arange(len(data)) != i)  # 예측 대상
    
    for model_name, model in models.items():
        model.fit(X_train, y_train)
        ...
3) 실시간 모니터링
새로운 샘플 데이터(new_data)가 들어올 때, 각 값에 대해 선택된 모델로 예측 오차를 계산합니다.
예측 오차의 평균치를 기록하며, 이를 통해 모델 성능의 추이를 확인합니다.
python
코드 복사
for sample in new_data:
    sample_errors = []
    for i, model_name in enumerate(best_models):
        ...
    avg_error = np.mean(sample_errors)
    avg_errors.append(avg_error)
4) 결과 시각화
새로운 샘플에 대한 평균 오차의 변화를 시각화합니다.
이 그래프는 모델 성능의 변화를 실시간으로 모니터링하는 데 유용합니다.
python
코드 복사
plt.plot(avg_errors, label="Average Prediction Error")
plt.xlabel("New Sample Index")
plt.ylabel("Average Error")
plt.legend()
plt.title("Real-time Monitoring of Prediction Errors")
plt.show()
4. 향후 확장
추가 모델 테스트
Gradient Boosting, Neural Network 등을 추가로 테스트 가능.
실시간 데이터 수집
실제 데이터 스트림에서 입력을 받아 처리하도록 확장.
배포