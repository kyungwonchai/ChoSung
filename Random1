네, 요청하신 모든 조건을 만족하는 WPF 비동기 로그 분석 및 업로드 에이전트의 전체 소스 코드와 설명을 제공해 드리겠습니다.

요구사항이 복잡하고 여러 기능이 유기적으로 연결되어 있어, MVVM(Model-View-ViewModel) 패턴을 기반으로 역할을 명확히 분리하여 안정적이고 확장 가능하게 설계했습니다. UI 스레드를 전혀 차단하지 않고 모든 핵심 로직은 백그라운드에서 비동기적으로 처리됩니다.

1. 시스템 아키텍처 및 파일 구조
프로젝트는 역할에 따라 다음과 같은 폴더와 파일로 구성됩니다. 이 구조는 코드의 유지보수와 이해를 돕습니다.

LogUploaderAgent/
│
├── App.xaml
├── App.xaml.cs               # 애플리케이션 시작점, 트레이 아이콘 초기화
│
├── MainWindow.xaml           # 주 윈도우 (거의 보이지 않음)
├── MainWindow.xaml.cs        # 주 윈도우 로직 (숨김 처리)
│
├── Views/
│   ├── SettingsWindow.xaml       # 모니터링 폴더 설정 UI
│   └── SettingsWindow.xaml.cs    # 설정 UI 로직
│
├── ViewModels/
│   └── MainViewModel.cs          # UI와 비즈니스 로직을 연결하는 중간자
│
├── Services/
│   ├── LogProcessingService.cs   # 핵심 로직: 로그 파일 스캔, 분석, DB 업로드 서비스
│   ├── SettingsService.cs        # 설정(appsettings.json, history.log) 관리 서비스
│   └── DatabaseService.cs        # MS-SQL 데이터베이스 연동 서비스
│
├── Models/
│   └── LogEntry.cs               # 데이터베이스에 업로드될 로그 데이터 모델
│
└── Utils/
    └── NotifyIconWrapper.cs      # 시스템 트레이 아이콘 관리 래퍼 클래스
2. 데이터베이스 테이블 생성 (Database Table Creation)
MS-SQL Server 2014에서 아래 쿼리를 실행하여 로그를 저장할 테이블을 생성하세요.

고유번호 (LogID): BIGINT와 IDENTITY를 사용하여 자동으로 증가하는 고유 키를 생성합니다.

파일수정시간 (FileModifiedUTC): DATETIME2 타입을 사용하여 정밀한 시간(초 단위 포함)을 저장하며, 표준시(UTC)로 저장하는 것을 권장합니다.

**폴더이름 (FolderName), 프로젝트이름 (ProjectName)**: NVARCHAR(260)`으로 경로 길이를 충분히 확보합니다.

내용 (LogContent): NVARCHAR(MAX)로 설정하여 용량 제한 없이 로그 내용을 저장합니다.

SQL

CREATE TABLE LogEntries (
    LogID BIGINT IDENTITY(1,1) PRIMARY KEY,
    FileModifiedUTC DATETIME2 NOT NULL,
    FolderName NVARCHAR(260) NOT NULL,
    ProjectName NVARCHAR(260) NOT NULL,
    LogContent NVARCHAR(MAX) NULL
);
3. 전체 소스 코드 (Full Source Code)
시작 전 NuGet 패키지 설치
프로젝트 생성 후, NuGet 패키지 관리자에서 다음 패키지를 설치해야 합니다.

System.Data.SqlClient (MS-SQL 연결용)

System.Text.Json (설정 파일 처리용)

1) Utils/NotifyIconWrapper.cs
WPF에는 기본 트레이 아이콘이 없으므로, Windows Forms의 것을 활용하는 래퍼 클래스입니다.

C#

using System;
using System.Drawing;
using System.Windows;
using System.Windows.Forms;

namespace LogUploaderAgent.Utils
{
    public class NotifyIconWrapper : IDisposable
    {
        private readonly NotifyIcon _notifyIcon;

        public NotifyIconWrapper()
        {
            _notifyIcon = new NotifyIcon();
            _notifyIcon.Icon = SystemIcons.Information; // 아이콘을 원하는 것으로 변경 가능
            _notifyIcon.Visible = true;

            var contextMenu = new ContextMenuStrip();
            contextMenu.Items.Add("설정 (Settings)", null, OnSettingsClicked);
            contextMenu.Items.Add("종료 (Exit)", null, OnExitClicked);
            _notifyIcon.ContextMenuStrip = contextMenu;
        }

        public event EventHandler SettingsClicked;
        public event EventHandler ExitClicked;

        private void OnSettingsClicked(object sender, EventArgs e)
        {
            SettingsClicked?.Invoke(this, EventArgs.Empty);
        }

        private void OnExitClicked(object sender, EventArgs e)
        {
            ExitClicked?.Invoke(this, EventArgs.Empty);
        }

        public void Dispose()
        {
            _notifyIcon.Dispose();
        }
    }
}
2) Models/LogEntry.cs
데이터베이스 테이블의 구조와 일치하는 데이터 모델 클래스입니다.

C#

using System;

namespace LogUploaderAgent.Models
{
    public class LogEntry
    {
        public DateTime FileModifiedUTC { get; set; }
        public string FolderName { get; set; }
        public string ProjectName { get; set; }
        public string LogContent { get; set; }
    }
}
3) Services/DatabaseService.cs
데이터베이스 연결 및 데이터 업로드 로직을 담당합니다. 연결 문자열은 반드시 자신의 환경에 맞게 수정해야 합니다.

C#

using System;
using System.Data.SqlClient;
using System.Threading.Tasks;
using LogUploaderAgent.Models;

namespace LogUploaderAgent.Services
{
    public class DatabaseService
    {
        // !!! 중요: 본인 환경에 맞는 SQL Server 연결 문자열로 변경하세요. !!!
        private readonly string _connectionString = "Server=YOUR_SERVER_NAME;Database=YOUR_DATABASE;User Id=YOUR_USER;Password=YOUR_PASSWORD;";

        public async Task UploadLogAsync(LogEntry logEntry)
        {
            try
            {
                using (var connection = new SqlConnection(_connectionString))
                {
                    await connection.OpenAsync();
                    string query = @"
                        INSERT INTO LogEntries (FileModifiedUTC, FolderName, ProjectName, LogContent)
                        VALUES (@FileModifiedUTC, @FolderName, @ProjectName, @LogContent)";

                    using (var command = new SqlCommand(query, connection))
                    {
                        command.Parameters.AddWithValue("@FileModifiedUTC", logEntry.FileModifiedUTC);
                        command.Parameters.AddWithValue("@FolderName", logEntry.FolderName);
                        command.Parameters.AddWithValue("@ProjectName", logEntry.ProjectName);
                        command.Parameters.AddWithValue("@LogContent", (object)logEntry.LogContent ?? DBNull.Value);

                        await command.ExecuteNonQueryAsync();
                    }
                }
            }
            catch (Exception ex)
            {
                // 실제 환경에서는 파일 로그 등으로 에러를 기록하는 것이 좋습니다.
                Console.WriteLine($"[DB Error] {ex.Message}");
                // 예외를 다시 던져서 처리 로직이 중단되게 할 수 있습니다.
                // throw; 
            }
        }
    }
}
4) Services/SettingsService.cs
애플리케이션의 전역 설정과 각 폴더별 처리 이력을 관리합니다.

C#

using System;
using System.Collections.Generic;
using System.IO;
using System.Text.Json;
using System.Threading.Tasks;

namespace LogUploaderAgent.Services
{
    public class SettingsService
    {
        private readonly string _configFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "appsettings.json");
        private const string HistoryFileName = "agent_history.log"; // 이력 파일명

        // 전역 설정: 모니터링할 폴더 목록 로드
        public async Task<List<string>> LoadMonitoredFoldersAsync()
        {
            if (!File.Exists(_configFilePath))
            {
                return new List<string>();
            }
            var json = await File.ReadAllTextAsync(_configFilePath);
            return JsonSerializer.Deserialize<List<string>>(json) ?? new List<string>();
        }

        // 전역 설정: 모니터링할 폴더 목록 저장
        public async Task SaveMonitoredFoldersAsync(IEnumerable<string> folders)
        {
            var json = JsonSerializer.Serialize(folders, new JsonSerializerOptions { WriteIndented = true });
            await File.WriteAllTextAsync(_configFilePath, json);
        }

        // 폴더별 이력: 마지막 처리 시간 로드
        public DateTime GetLastProcessedTime(string monitoredFolderPath)
        {
            string historyFilePath = Path.Combine(monitoredFolderPath, HistoryFileName);
            if (!File.Exists(historyFilePath))
            {
                // 이력 파일이 없으면 아주 오래된 시간을 반환하여 모든 폴더를 검사하도록 함
                return DateTime.MinValue;
            }
            // ISO 8601 형식 (YYYY-MM-DDTHH:mm:ss.fffffffZ)으로 저장된 시간 읽기
            var content = File.ReadAllText(historyFilePath);
            return DateTime.Parse(content, null, System.Globalization.DateTimeStyles.RoundtripKind);
        }

        // 폴더별 이력: 마지막 처리 시간 저장
        public void SetLastProcessedTime(string monitoredFolderPath, DateTime time)
        {
            string historyFilePath = Path.Combine(monitoredFolderPath, HistoryFileName);
            // 시간을 UTC로, 그리고 재파싱이 용이한 ISO 8601 형식으로 저장
            File.WriteAllText(historyFilePath, time.ToUniversalTime().ToString("o"));
        }
    }
}
5) Services/LogProcessingService.cs
이 프로젝트의 핵심입니다. 모든 비동기 처리 로직이 여기에 담겨 있습니다.

C#

using System;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using LogUploaderAgent.Models;

namespace LogUploaderAgent.Services
{
    public class LogProcessingService
    {
        private readonly SettingsService _settingsService;
        private readonly DatabaseService _databaseService;
        private CancellationTokenSource _cancellationTokenSource;

        public LogProcessingService(SettingsService settingsService, DatabaseService databaseService)
        {
            _settingsService = settingsService;
            _databaseService = databaseService;
        }

        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ProcessLoopAsync(_cancellationTokenSource.Token));
        }

        public void Stop()
        {
            _cancellationTokenSource?.Cancel();
        }

        private async Task ProcessLoopAsync(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                var monitoredFolders = await _settingsService.LoadMonitoredFoldersAsync();

                foreach (var folderPath in monitoredFolders)
                {
                    if (token.IsCancellationRequested) break;
                    if (!Directory.Exists(folderPath)) continue;

                    try
                    {
                        await ProcessMonitoredFolderAsync(folderPath, token);
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error processing folder {folderPath}: {ex.Message}");
                    }
                }
                // 모든 폴더를 순회한 후 잠시 대기
                await Task.Delay(TimeSpan.FromSeconds(10), token);
            }
        }

        private async Task ProcessMonitoredFolderAsync(string monitoredPath, CancellationToken token)
        {
            var lastProcessedTime = _settingsService.GetLastProcessedTime(monitoredPath);

            var subDirectories = Directory.EnumerateDirectories(monitoredPath, "*", SearchOption.TopDirectoryOnly)
                .Select(path => new DirectoryInfo(path))
                .Where(di => di.LastWriteTime > lastProcessedTime) // 마지막 처리 시간 이후 수정된 폴더만
                .OrderBy(di => di.LastWriteTime) // 수정 시간 오름차순 (과거부터)
                .ToList();

            if (!subDirectories.Any()) return;

            var lastDirectory = subDirectories.Last();

            // 마지막 폴더를 제외한 나머지 폴더 처리
            foreach (var dir in subDirectories.Where(d => d.FullName != lastDirectory.FullName))
            {
                if (token.IsCancellationRequested) return;
                await ProcessSingleDirectoryAsync(dir, false, token);
                _settingsService.SetLastProcessedTime(monitoredPath, dir.LastWriteTime);
            }

            // 마지막 폴더 특별 처리
            await ProcessSingleDirectoryAsync(lastDirectory, true, token);
            _settingsService.SetLastProcessedTime(monitoredPath, lastDirectory.LastWriteTime);
        }

        private async Task ProcessSingleDirectoryAsync(DirectoryInfo targetDirectory, bool isLatest, CancellationToken token)
        {
            // 1. .proj 파일 검사
            var projFile = targetDirectory.EnumerateFiles("*.proj")
                .OrderByDescending(f => f.LastWriteTime)
                .FirstOrDefault();

            if (projFile == null) return; // .proj 파일 없으면 처리 대상 아님

            // 2. Histories 폴더 및 bot_engine.log 파일 검사
            var historiesDir = Path.Combine(targetDirectory.FullName, "Histories");
            if (!Directory.Exists(historiesDir)) return;

            var logFile = Directory.EnumerateDirectories(historiesDir)
                .Select(subDir => Path.Combine(subDir, "bot_engine.log"))
                .FirstOrDefault(File.Exists);

            if (logFile == null) return; // bot_engine.log 파일 없으면 처리 대상 아님

            // 3. 로그 처리
            if (isLatest)
            {
                await HandleLatestLogAsync(logFile, targetDirectory, projFile.Name, token);
            }
            else
            {
                await HandleNormalLogAsync(logFile, targetDirectory, projFile.Name);
            }
        }

        private async Task HandleNormalLogAsync(string logFilePath, DirectoryInfo directory, string projectName)
        {
            string contentToUpload = await ExtractStoppingContentAsync(logFilePath);
            if (!string.IsNullOrEmpty(contentToUpload))
            {
                await UploadData(logFilePath, directory, projectName, contentToUpload);
            }
        }

        private async Task HandleLatestLogAsync(string logFilePath, DirectoryInfo directory, string projectName, CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                // 1. 다음 폴더가 생성되었는지 확인
                var parentDir = directory.Parent.FullName;
                var nextDirExists = Directory.EnumerateDirectories(parentDir)
                                        .Any(d => new DirectoryInfo(d).LastWriteTime > directory.LastWriteTime);

                // 2. 종료 메시지가 있는지 확인
                var hasShutdownMessage = await CheckForShutdownMessageAsync(logFilePath);

                if (nextDirExists || hasShutdownMessage)
                {
                    // 마무리 작업 수행
                    string contentToUpload = await ExtractStoppingContentAsync(logFilePath);
                    if (!string.IsNullOrEmpty(contentToUpload))
                    {
                        await UploadData(logFilePath, directory, projectName, contentToUpload);
                    }
                    return; // 처리 완료 후 루프 종료
                }

                // 조건 미충족 시 1분 대기
                await Task.Delay(TimeSpan.FromMinutes(1), token);
            }
        }
        
        private async Task<string> ExtractStoppingContentAsync(string logFilePath)
        {
            try
            {
                // 읽기/쓰기 공유 모드로 파일 열기
                using (var fs = new FileStream(logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var sr = new StreamReader(fs, Encoding.UTF8))
                {
                    string fileContent = await sr.ReadToEndAsync();
                    const string marker = "### STATE:Stopping";
                    int index = fileContent.IndexOf(marker, StringComparison.Ordinal);

                    if (index != -1)
                    {
                        return fileContent.Substring(index);
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[FileReadError] {logFilePath}: {ex.Message}");
            }
            return null;
        }

        private async Task<bool> CheckForShutdownMessageAsync(string logFilePath)
        {
            string lastLine = null;
            try
            {
                // 읽기/쓰기 공유 모드로 파일 열기
                using (var fs = new FileStream(logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var sr = new StreamReader(fs, Encoding.UTF8))
                {
                    string line;
                    while ((line = await sr.ReadLineAsync()) != null)
                    {
                        if (!string.IsNullOrWhiteSpace(line))
                        {
                            lastLine = line;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[FileReadError] {logFilePath}: {ex.Message}");
                return false;
            }

            return lastLine?.Trim() == "Exit - Shutdown Engine BOT";
        }
        
        private async Task UploadData(string logFilePath, DirectoryInfo directory, string projectName, string content)
        {
            var logEntry = new LogEntry
            {
                FileModifiedUTC = File.GetLastWriteTimeUtc(logFilePath),
                FolderName = directory.Name,
                ProjectName = projectName,
                LogContent = content
            };
            await _databaseService.UploadLogAsync(logEntry);
            Console.WriteLine($"Uploaded log for: {directory.Name}");
        }
    }
}
6) ViewModels/MainViewModel.cs
UI의 데이터와 커맨드를 관리합니다.

C#

using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using LogUploaderAgent.Services;

namespace LogUploaderAgent.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly SettingsService _settingsService;
        public ObservableCollection<string> MonitoredFolders { get; }

        public MainViewModel(SettingsService settingsService)
        {
            _settingsService = settingsService;
            MonitoredFolders = new ObservableCollection<string>();
        }

        public async Task LoadSettingsAsync()
        {
            var folders = await _settingsService.LoadMonitoredFoldersAsync();
            MonitoredFolders.Clear();
            foreach (var folder in folders)
            {
                MonitoredFolders.Add(folder);
            }
        }

        public async Task SaveSettingsAsync()
        {
            await _settingsService.SaveMonitoredFoldersAsync(MonitoredFolders);
        }

        public bool HasSettings()
        {
            return MonitoredFolders.Any();
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
7) Views/SettingsWindow.xaml
폴더를 설정하는 UI입니다.

XML

<Window x:Class="LogUploaderAgent.Views.SettingsWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="폴더 설정 (Folder Settings)" Height="450" Width="600"
        WindowStartupLocation="CenterScreen">
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>
        
        <TextBlock Grid.Row="0" Text="모니터링할 폴더 목록 (최대 5개)" FontWeight="Bold" Margin="0,0,0,10"/>

        <ListBox Grid.Row="1" ItemsSource="{Binding MonitoredFolders}" Name="FolderListBox">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding}" Margin="2"/>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <StackPanel Grid.Row="2" Orientation="Horizontal" HorizontalAlignment="Right" Margin="0,10,0,0">
            <Button Content="추가 (Add)" Width="100" Margin="5" Click="AddButton_Click"/>
            <Button Content="제거 (Remove)" Width="100" Margin="5" Click="RemoveButton_Click"/>
            <Button Content="저장 (Save)" Width="100" Margin="5" Click="SaveButton_Click" IsDefault="True"/>
            <Button Content="취소 (Cancel)" Width="100" Margin="5" Click="CancelButton_Click" IsCancel="True"/>
        </StackPanel>
    </Grid>
</Window>
8) Views/SettingsWindow.xaml.cs
설정 UI의 코드 비하인드입니다.

C#

using System.Windows;
using System.Windows.Forms;
using LogUploaderAgent.ViewModels;

namespace LogUploaderAgent.Views
{
    public partial class SettingsWindow : Window
    {
        private readonly MainViewModel _viewModel;

        public SettingsWindow(MainViewModel viewModel)
        {
            InitializeComponent();
            _viewModel = viewModel;
            DataContext = _viewModel;
        }

        private void AddButton_Click(object sender, RoutedEventArgs e)
        {
            if (_viewModel.MonitoredFolders.Count >= 5)
            {
                System.Windows.MessageBox.Show("최대 5개의 폴더만 설정할 수 있습니다.", "제한", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }

            using (var dialog = new FolderBrowserDialog())
            {
                if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    if (!_viewModel.MonitoredFolders.Contains(dialog.SelectedPath))
                    {
                        _viewModel.MonitoredFolders.Add(dialog.SelectedPath);
                    }
                }
            }
        }

        private void RemoveButton_Click(object sender, RoutedEventArgs e)
        {
            if (FolderListBox.SelectedItem is string selectedFolder)
            {
                _viewModel.MonitoredFolders.Remove(selectedFolder);
            }
        }

        private async void SaveButton_Click(object sender, RoutedEventArgs e)
        {
            await _viewModel.SaveSettingsAsync();
            DialogResult = true;
            Close();
        }

        private void CancelButton_Click(object sender, RoutedEventArgs e)
        {
            DialogResult = false;
            Close();
        }
    }
}
9) App.xaml.cs
애플리케이션의 생명주기를 관리하고, 시작 시 로직을 수행합니다.

C#

using System.Windows;
using LogUploaderAgent.Services;
using LogUploaderAgent.Utils;
using LogUploaderAgent.ViewModels;
using LogUploaderAgent.Views;

namespace LogUploaderAgent
{
    public partial class App : Application
    {
        private NotifyIconWrapper _notifyIcon;
        private MainViewModel _mainViewModel;
        private SettingsService _settingsService;
        private DatabaseService _databaseService;
        private LogProcessingService _logProcessingService;

        protected override async void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // MainWindow를 생성하지만 보여주지는 않음
            MainWindow = new MainWindow();
            
            // 서비스 및 뷰모델 초기화
            _settingsService = new SettingsService();
            _databaseService = new DatabaseService();
            _mainViewModel = new MainViewModel(_settingsService);
            _logProcessingService = new LogProcessingService(_settingsService, _databaseService);

            // 트레이 아이콘 설정
            _notifyIcon = new NotifyIconWrapper();
            _notifyIcon.SettingsClicked += (s, a) => ShowSettings();
            _notifyIcon.ExitClicked += (s, a) => ShutdownApp();

            // 설정 로드
            await _mainViewModel.LoadSettingsAsync();

            if (_mainViewModel.HasSettings())
            {
                // 설정이 있으면 바로 백그라운드 작업 시작
                _logProcessingService.Start();
            }
            else
            {
                // 설정이 없으면 설정창 먼저 표시
                ShowSettings(true);
            }
        }

        private void ShowSettings(bool isFirstRun = false)
        {
            var settingsWindow = new SettingsWindow(_mainViewModel);
            var result = settingsWindow.ShowDialog();

            // 설정 창에서 저장을 눌렀고, 폴더가 1개 이상 설정되었다면
            if (result == true && _mainViewModel.HasSettings())
            {
                // 백그라운드 처리 시작 (또는 재시작)
                _logProcessingService.Stop();
                _logProcessingService.Start();
            }
            // 첫 실행인데 설정을 안 하고 창을 닫으면 프로그램 종료
            else if (isFirstRun && !_mainViewModel.HasSettings())
            {
                ShutdownApp();
            }
        }

        private void ShutdownApp()
        {
            _logProcessingService.Stop();
            _notifyIcon.Dispose();
            Shutdown();
        }
    }
}
10) MainWindow.xaml
프로그램의 보이지 않는 주 창입니다.

XML

<Window x:Class="LogUploaderAgent.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Agent" Height="0" Width="0" WindowStyle="None" ShowInTaskbar="False" Opacity="0">
</Window>
11) MainWindow.xaml.cs
창이 보이지 않도록 숨기는 역할을 합니다.

C#

using System.Windows;

namespace LogUploaderAgent
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
4. 실행 방법 및 사용법
프로젝트 생성: Visual Studio에서 'WPF 앱(.NET Framework)' 또는 'WPF 애플리케이션'(.NET 6/7/8) 프로젝트를 생성합니다.

NuGet 패키지 설치: System.Data.SqlClient 와 System.Text.Json을 설치합니다.

코드 복사/붙여넣기: 위 파일 구조에 맞게 각 파일을 생성하고 코드를 붙여넣습니다.

연결 문자열 수정: Services/DatabaseService.cs 파일의 _connectionString 변수 값을 자신의 MS-SQL 서버 정보에 맞게 수정합니다.

데이터베이스 테이블 생성: MS-SQL 서버에 접속하여 2번 항목의 CREATE TABLE 쿼리를 실행합니다.

애플리케이션 실행:

프로그램을 시작하면 화면에 아무것도 나타나지 않고, 작업 표시줄 오른쪽 시스템 트레이에 아이콘이 생깁니다.

최초 실행 시: 설정된 폴더가 없으므로 '폴더 설정' 창이 자동으로 열립니다. '추가' 버튼으로 모니터링할 폴더를 1개 이상(최대 5개) 선택하고 '저장'을 누릅니다.

저장 후: 설정이 저장되면 에이전트가 백그라운드에서 즉시 로그 분석 및 업로드 작업을 시작합니다.

설정 변경: 언제든지 트레이 아이콘을 우클릭하여 '설정' 메뉴를 선택하면 폴더 목록을 수정할 수 있습니다. 변경 사항을 저장하면 에이전트는 새로운 설정을 즉시 반영하여 동작합니다.