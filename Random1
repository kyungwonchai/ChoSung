네, 특정 폴더 안에 있는 수많은 솔루션들의 경로를 출력하는 파이썬 스크립트와, 이 솔루션들을 정리된 목록에 따라 사내 깃허브에 새로운 저장소로 푸시하는 두 가지 파이썬 스크립트를 아주 상세하게 안내해 드리겠습니다. 👨‍💻

각 단계별 코드와 함께 상세한 설명을 제공하여 그대로 따라 하실 수 있도록 구성했습니다.

1. 특정 폴더 안의 모든 솔루션(하위 폴더) 경로 출력하기
첫 번째 스크립트는 지정된 폴더 내의 모든 하위 폴더 경로를 찾아내어 화면에 출력하거나 파일로 저장하는 역할을 합니다. 이는 두 번째 스크립트에서 사용할 solutions_map 변수를 만드는 데 기초 자료가 됩니다.

주요 기능
지정된 상위 폴더(root_directory) 내의 모든 하위 폴더 목록을 재귀적으로 탐색합니다.

탐색된 폴더 경로들을 리스트로 만들어 반환합니다.

결과를 화면에 출력하고, 필요시 solution_paths.txt 파일로 저장합니다.

전체 코드 (list_solutions.py)
Python

import os

def find_solution_directories(root_path):
    """
    지정된 경로의 모든 하위 디렉터리 경로를 찾아서 리스트로 반환합니다.

    Args:
        root_path (str): 탐색을 시작할 최상위 폴더 경로입니다.

    Returns:
        list: 모든 하위 폴더의 전체 경로가 담긴 리스트입니다.
    """
    if not os.path.isdir(root_path):
        print(f"오류: '{root_path}'는 유효한 디렉터리가 아닙니다.")
        return []

    solution_paths = []
    # os.walk를 사용하여 root_path부터 시작하는 모든 하위 폴더와 파일을 순회합니다.
    # dirpath: 현재 폴더 경로, dirnames: 현재 폴더의 하위 폴더 목록, filenames: 현재 폴더의 파일 목록
    for dirpath, dirnames, filenames in os.walk(root_path):
        # 우리는 폴더(솔루션) 목록이 필요하므로 dirnames를 사용합니다.
        for dir_name in dirnames:
            # 전체 경로를 만듭니다.
            full_path = os.path.join(dirpath, dir_name)
            solution_paths.append(full_path)
        # 더 깊이 들어가지 않으려면 여기서 break 할 수 있지만, 모든 하위 폴더를 원하므로 계속 진행합니다.
        # 이 예제에서는 최상위 레벨의 폴더만 원한다고 가정하고 break를 추가합니다.
        # 만약 모든 깊이의 폴더를 원한다면 아래 break 줄을 삭제하세요.
        break # root_path 바로 아래의 폴더들만 필요한 경우

    return solution_paths

def save_paths_to_file(paths, filename="solution_paths.txt"):
    """
    경로 리스트를 텍스트 파일에 저장합니다.

    Args:
        paths (list): 저장할 경로의 리스트입니다.
        filename (str): 저장할 파일의 이름입니다.
    """
    with open(filename, "w", encoding="utf-8") as f:
        for path in paths:
            f.write(f"{path}\n")
    print(f"'{filename}' 파일에 경로 목록이 저장되었습니다.")


if __name__ == "__main__":
    # 여기에 솔루션들이 모여있는 최상위 폴더 경로를 입력하세요.
    # 예: "C:/Projects/MySolutions" 또는 "/Users/user/Documents/MySolutions"
    # raw string(r"...")을 사용하면 역슬래시(\)를 이스케이프 처리할 필요가 없어 편리합니다.
    target_root_directory = r"C:\your\solutions\root\folder"

    # 함수를 호출하여 솔루션 폴더 경로 목록을 가져옵니다.
    all_solution_paths = find_solution_directories(target_root_directory)

    if all_solution_paths:
        print("===== 발견된 솔루션 폴더 경로 =====")
        for path in all_solution_paths:
            print(path)
        print("===================================")

        # 결과를 파일로 저장하고 싶다면 아래 함수의 주석을 해제하세요.
        # save_paths_to_file(all_solution_paths)
사용 방법
위 코드를 list_solutions.py 라는 이름의 파일로 저장합니다.

target_root_directory 변수에 실제 솔루션들이 들어있는 최상위 폴더 경로를 정확하게 입력합니다.

터미널(명령 프롬프트)을 열고 python list_solutions.py 명령을 실행합니다.

화면에 출력되는 경로 목록을 확인하고, 이 목록을 바탕으로 두 번째 스크립트의 solutions_map 변수를 작성합니다.

2. 목록을 기반으로 모든 솔루션을 사내 깃허브에 푸시하기
두 번째 스크립트는 미리 정의된 딕셔너리(solutions_map)를 기반으로, 각 솔루션 폴더를 로컬 Git 저장소로 만들고 사내 깃허브(GitHub Enterprise 등)에 새로운 원격 저장소를 생성한 후 푸시하는 작업을 자동화합니다.

사전 준비 사항
Git 설치: 이 스크립트를 실행하는 컴퓨터에 Git이 설치되어 있어야 하며, 환경 변수(Path)에 등록되어 어디서든 git 명령을 실행할 수 있어야 합니다.

사내 깃허브 인증: 사내 깃허브에 코드를 푸시하려면 인증이 필요합니다. 일반적으로 SSH 키를 사용하거나 **Personal Access Token (PAT)**을 사용합니다.

SSH (권장): 로컬 컴퓨터에 SSH 키를 생성하고 공개키를 사내 깃허브 계정에 등록합니다.

HTTPS (PAT 사용): 사내 깃허브에서 PAT를 발급받아 비밀번호처럼 사용합니다. 이 경우 원격 저장소 주소는 https://<YOUR_USERNAME>:<YOUR_PAT>@your.company.github.com/your-org/repository_name.git 형태가 됩니다.

주요 기능
solutions_map 딕셔너리에 정의된 저장소 이름: 로컬 폴더 경로 쌍을 순회합니다.

각 폴더로 이동하여 git init 명령으로 로컬 저장소를 생성합니다.

사내 깃허브의 원격 저장소 주소를 생성하고 git remote add origin으로 연결합니다.

폴더 내의 모든 파일을 스테이징(git add .)하고 커밋(git commit -m "Initial commit")합니다.

새로운 main 브랜치를 만들고 원격 저장소로 푸시(git push -u origin main)합니다.

각 단계의 성공 여부와 오류를 명확하게 출력합니다.

전체 코드 (push_to_github.py)
Python

import os
import subprocess

def run_git_command(command, working_directory):
    """
    지정된 작업 디렉터리에서 Git 명령어를 실행하고 결과를 반환합니다.

    Args:
        command (list): 실행할 명령어와 인자들의 리스트입니다. (예: ["git", "status"])
        working_directory (str): 명령어가 실행될 폴더 경로입니다.

    Returns:
        tuple: (성공 여부(bool), 표준 출력(str), 표준 에러(str))
    """
    try:
        # subprocess.run을 사용하여 외부 프로세스(git)를 실행합니다.
        process = subprocess.run(
            command,
            cwd=working_directory, # change working directory
            check=True,            # 명령이 실패하면 CalledProcessError를 발생시킵니다.
            capture_output=True,   # stdout과 stderr의 출력을 캡처합니다.
            text=True,             # 출력을 UTF-8 텍스트로 디코딩합니다.
            encoding='utf-8'
        )
        # 성공 시
        return True, process.stdout.strip(), ""
    except FileNotFoundError:
        # 'git' 명령어를 찾을 수 없는 경우
        return False, "", "오류: 'git' 명령을 찾을 수 없습니다. Git이 설치되어 있고 PATH에 등록되어 있는지 확인하세요."
    except subprocess.CalledProcessError as e:
        # 명령 실행이 실패한 경우 (0이 아닌 종료 코드)
        return False, e.stdout.strip(), e.stderr.strip()


def push_solution_to_github(repo_name, local_path, github_org, github_url):
    """
    지정된 로컬 경로의 솔루션을 새로운 GitHub 저장소로 푸시합니다.

    Args:
        repo_name (str): 생성할 GitHub 저장소의 이름입니다.
        local_path (str): Git으로 관리할 로컬 솔루션 폴더 경로입니다.
        github_org (str): GitHub의 조직(Organization) 이름입니다.
        github_url (str): 사내 GitHub의 기본 URL입니다. (예: 'your.company.github.com')
    """
    print(f"[{repo_name}] 작업을 시작합니다...")
    print(f"  - 대상 폴더: {local_path}")

    if not os.path.isdir(local_path):
        print(f"  - 오류: 폴더를 찾을 수 없습니다. 건너뜁니다.")
        print("-" * 40)
        return

    # 1. Git 저장소 초기화 (git init)
    print("  - 1/5: Git 저장소를 초기화합니다...")
    success, out, err = run_git_command(["git", "init"], local_path)
    if not success and "Reinitialized existing Git repository" not in err:
        print(f"  - Git 초기화 실패: {err}")
        print("-" * 40)
        return
    print("  - Git 저장소 초기화 완료.")

    # 2. 원격 저장소 추가 (git remote add)
    # SSH 주소 방식: git@your.company.github.com:your-org/repository_name.git
    remote_url = f"git@{github_url}:{github_org}/{repo_name}.git"
    print(f"  - 2/5: 원격 저장소를 추가합니다: {remote_url}")

    # 이미 'origin' 원격 저장소가 있는지 확인하고, 있다면 URL을 변경합니다.
    success, out, err = run_git_command(["git", "remote"], local_path)
    if success and "origin" in out.split():
        run_git_command(["git", "remote", "set-url", "origin", remote_url], local_path)
    else:
        run_git_command(["git", "remote", "add", "origin", remote_url], local_path)
    print("  - 원격 저장소 추가 완료.")

    # 3. 모든 파일 스테이징 (git add .)
    print("  - 3/5: 모든 파일을 스테이징합니다...")
    success, out, err = run_git_command(["git", "add", "."], local_path)
    if not success:
        print(f"  - 파일 스테이징 실패: {err}")
        print("-" * 40)
        return
    print("  - 파일 스테이징 완료.")

    # 4. 첫 커밋 (git commit)
    print("  - 4/5: 첫 커밋을 생성합니다...")
    commit_message = "Initial commit"
    # --allow-empty-message 옵션이 필요할 수도 있지만, 기본적으로 메시지를 넣습니다.
    # 이미 커밋이 있는지 확인하여 중복 실행을 방지할 수 있습니다.
    success, out, err = run_git_command(["git", "commit", "-m", commit_message], local_path)
    if not success and "nothing to commit" not in err and "nothing added to commit" not in err:
        print(f"  - 커밋 실패: {err}")
        print("-" * 40)
        return
    elif "nothing to commit" in err or "nothing added to commit" in err:
         print("  - 이미 커밋할 내용이 없으므로 커밋을 건너뜁니다.")
    else:
        print("  - 커밋 생성 완료.")

    # 5. 원격 저장소로 푸시 (git push)
    print("  - 5/5: 원격 저장소로 푸시합니다...")
    # 기본 브랜치 이름을 'main'으로 설정합니다. (최신 Git 경향 반영)
    # git branch -M main
    run_git_command(["git", "branch", "-M", "main"], local_path)
    success, out, err = run_git_command(["git", "push", "-u", "origin", "main"], local_path)

    if not success:
        # 푸시 실패 시 흔한 오류 메시지를 확인하여 원인을 파악합니다.
        if "src refspec main does not match any" in err:
             print(f"  - 푸시 실패: 'main' 브랜치를 찾을 수 없습니다. 커밋이 정상적으로 생성되었는지 확인하세요.")
        elif "repository not found" in err:
             print(f"  - 푸시 실패: 원격 저장소를 찾을 수 없습니다. '{repo_name}' 저장소가 사내 GitHub에 생성되었는지, 접근 권한이 있는지 확인하세요.")
        else:
            print(f"  - 푸시 실패: {err}")
        print("-" * 40)
        return

    print(f"  - 성공! [{repo_name}] 저장소로 푸시를 완료했습니다.")
    print("-" * 40)


if __name__ == "__main__":
    # ===== 설정 값 =====
    # 사내 깃허브 URL (https:// 제외)
    COMPANY_GITHUB_URL = "github.mycompany.com"
    # 코드를 푸시할 깃허브 조직(Organization) 이름
    GITHUB_ORGANIZATION = "MyProject"

    # 여기에 푸시할 솔루션 목록을 '저장소이름': '로컬경로' 형태로 추가합니다.
    # 첫 번째 스크립트(list_solutions.py)의 출력 결과를 참고하여 작성하세요.
    # 경로는 raw string(r"...")을 사용하는 것이 편리합니다.
    solutions_map = {
        "Project-A-Auth-Service": r"C:\your\solutions\root\folder\ProjectA\AuthService",
        "Project-A-Data-Processor": r"C:\your\solutions\root\folder\ProjectA\DataProcessor",
        "Project-B-Main-API": r"C:\your\solutions\root\folder\ProjectB\MainAPI",
        "Shared-Common-Library": r"C:\your\solutions\root\folder\CommonLib",
        # 필요에 따라 계속 추가...
    }
    # ====================

    # **중요**: 이 스크립트를 실행하기 전에 사내 GitHub에 `solutions_map`에 정의된 이름으로
    # 비어있는(Empty) 저장소를 미리 생성해야 합니다.
    # GitHub API를 사용하여 저장소 생성을 자동화할 수도 있지만, 이 예제에서는 수동 생성을 가정합니다.

    print("===== 사내 GitHub 저장소로 솔루션 푸시를 시작합니다. =====")
    for repo_key, folder_path in solutions_map.items():
        push_solution_to_github(repo_key, folder_path, GITHUB_ORGANIZATION, COMPANY_GITHUB_URL)

    print("===== 모든 작업이 완료되었습니다. =====")

사용 방법
위 코드를 push_to_github.py 라는 이름의 파일로 저장합니다.

가장 중요한 단계: 사내 깃허브에 접속하여 solutions_map의 **키(key)**에 해당하는 이름으로 **비어있는 저장소(Empty Repository)**를 미리 모두 생성해야 합니다. (예: Project-A-Auth-Service, Project-B-Main-API 등)

코드 상단의 설정 값 섹션을 자신의 환경에 맞게 수정합니다.

COMPANY_GITHUB_URL: github.mycompany.com 과 같은 사내 깃허브 주소를 입력합니다.

GITHUB_ORGANIZATION: 저장소를 생성할 조직(Organization) 이름을 입력합니다. 개인 계정에 만들 경우, 조직 이름 대신 본인의 유저네임을 입력하면 됩니다.

solutions_map: list_solutions.py의 결과를 바탕으로, { "새로운 저장소 이름": "로컬 솔루션 폴더 전체 경로" } 형식의 딕셔너리를 완성합니다.

터미널을 열고 python push_to_github.py 명령을 실행합니다.

스크립트가 각 폴더를 순회하며 Git 초기화, 원격 연결, 커밋, 푸시 작업을 자동으로 수행하는 것을 확인합니다. 각 단계별 진행 상황과 결과가 터미널에 출력됩니다.