버튼 클릭 이벤트가 발생하고, SendToPLCCommand를 통해 LogService로 메시지가 전달되는 경로를 살펴보겠습니다.

이 과정에서 로그를 출력하여 문제를 진단하는 방법도 함께 설명하겠습니다.

1. 버튼 클릭 이벤트 처리 경로
XAML에서 버튼 클릭 이벤트: 버튼은 XAML에서 Command 속성으로 SendToPLCCommand를 바인딩하고 있습니다. 예를 들어, 다음과 같은 XAML 코드가 있을 것입니다:

xml
코드 복사
<Button Content="{Binding DisplayName}" Command="{Binding DataContext.SendToPLCCommand, RelativeSource={RelativeSource AncestorType=Window}}" CommandParameter="{Binding Number}" />
여기서 CommandParameter는 ButtonMapping의 Number 값을 전달하며, Command는 SendToPLCCommand로 바인딩됩니다.

SendToPLCCommand의 실행: 버튼이 클릭되면 SendToPLCCommand가 실행됩니다. SendToPLCCommand는 RelayCommand<int> 타입이며, 이 커맨드는 Action<int>를 실행합니다.

csharp
코드 복사
public MainViewModel()
{
    SendToPLCCommand = new RelayCommand<int>(SendToPLC);
    ConnectToService();
}
RelayCommand<int>는 다음과 같이 정의된 클래스입니다:

csharp
코드 복사
public class RelayCommand<T> : ICommand
{
    private readonly Action<T> _execute;
    private readonly Func<T, bool> _canExecute;

    public RelayCommand(Action<T> execute, Func<T, bool> canExecute = null)
    {
        _execute = execute ?? throw new ArgumentNullException(nameof(execute));
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute((T)parameter);
    }

    public void Execute(object parameter)
    {
        _execute((T)parameter);
    }

    public event EventHandler CanExecuteChanged
    {
        add { CommandManager.RequerySuggested += value; }
        remove { CommandManager.RequerySuggested -= value; }
    }
}
SendToPLC 메서드 실행: RelayCommand<int>가 실행되면, SendToPLC 메서드가 호출됩니다. 이 메서드는 LogService로 메시지를 전송하는 역할을 합니다.

csharp
코드 복사
private async void SendToPLC(int number)
{
    LogMessage($"Button clicked with number: {number}"); // 버튼 클릭 로그

    if (_networkStream != null)
    {
        string message = $"%01#WDD0230002300{number:D2}00**\r"; // Mewtocol 메시지 형식
        LogMessage($"Sending message to PLC: {message}"); // PLC로 전송할 메시지 로그
        byte[] data = Encoding.ASCII.GetBytes(message);
        await _networkStream.WriteAsync(data, 0, data.Length);
    }
    else
    {
        LogMessage("Network stream is null, cannot send message."); // 네트워크 스트림이 null일 때의 로그
    }
}
SendToPLC 메서드에서 LogMessage를 사용하여 로그를 기록합니다. 이 로그는 LogService에서 처리되어 파일에 저장되거나, UI에 표시될 수 있습니다.

로그 출력: LogMessage 메서드는 로그 메시지를 LogService로 전달합니다. LogService는 해당 메시지를 파일에 기록하거나, 네트워크를 통해 UI로 전송합니다.

csharp
코드 복사
public async Task LogMessage(string message)
{
    try
    {
        string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
        string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");

        File.AppendAllText(logFilePath, logEntry + Environment.NewLine);
        Console.WriteLine(logEntry); // 콘솔에 로그 출력

        if (_isConnected && _tcpClient != null && _tcpClient.Connected)
        {
            await SendLogMessage(logEntry); // 연결된 경우 UI로 로그 메시지 전송
        }
        else
        {
            Console.WriteLine("Unable to send log message; not connected.");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error logging message: {ex.Message}");
    }
}
2. 로그를 사용한 디버깅 방법
버튼 클릭 이벤트 로그:

버튼 클릭 시 어떤 번호가 전달되는지 확인하려면, SendToPLC 메서드에서 LogMessage를 사용하여 로그를 출력합니다.
"Button clicked with number: {number}" 로그가 출력되면, 버튼 클릭이 제대로 처리되고 있는 것입니다.
네트워크 스트림 상태 확인 로그:

SendToPLC 메서드에서 _networkStream이 null인지 여부를 로그로 확인합니다.
"Network stream is null, cannot send message." 로그가 출력되면, 네트워크 스트림이 설정되지 않은 상태이므로, ConnectToService 메서드를 점검해야 합니다.
메시지 전송 로그:

PLC로 메시지가 전송되기 전, "Sending message to PLC: {message}" 로그를 출력하여 전송할 메시지를 확인합니다.
이 로그가 제대로 출력되면, 메시지가 PLC로 전송되고 있음을 알 수 있습니다.
LogService 로그:

LogService에서 로그 메시지를 처리할 때 발생하는 오류나 상태를 확인하기 위해 로그를 출력합니다.
"Error logging message: {ex.Message}"와 같은 로그를 통해 문제가 발생하는 위치를 파악할 수 있습니다.
3. 수정된 코드
위의 설명을 바탕으로, 로그 메시지를 추가하고, 각 단계에서 발생할 수 있는 문제를 진단할 수 있도록 코드에 로그를 추가했습니다.

MainViewModel.cs
csharp
코드 복사
public MainViewModel()
{
    SendToPLCCommand = new RelayCommand<int>(SendToPLC);
    ConnectToService();
}

private void ConnectToService()
{
    try
    {
        _tcpClient = new TcpClient("127.0.0.1", 9000);
        _networkStream = _tcpClient.GetStream();
        LogMessage("Connected to service successfully."); // 서비스 연결 성공 로그
    }
    catch (Exception ex)
    {
        LogMessage($"Error connecting to service: {ex.Message}"); // 서비스 연결 실패 로그
    }
}

private async void SendToPLC(int number)
{
    LogMessage($"Button clicked with number: {number}"); // 버튼 클릭 로그

    if (_networkStream != null)
    {
        string message = $"%01#WDD0230002300{number:D2}00**\r"; // Mewtocol 메시지 형식
        LogMessage($"Sending message to PLC: {message}"); // PLC로 전송할 메시지 로그
        byte[] data = Encoding.ASCII.GetBytes(message);
        await _networkStream.WriteAsync(data, 0, data.Length);
        LogMessage("Message sent to PLC successfully."); // 메시지 전송 성공 로그
    }
    else
    {
        LogMessage("Network stream is null, cannot send message."); // 네트워크 스트림이 null일 때의 로그
    }
}
4. 문제 해결 방법
네트워크 연결 확인: 네트워크 스트림이 null인 경우, ConnectToService 메서드를 통해 네트워크 연결이 제대로 이루어졌는지 확인하세요.
버튼 클릭 이벤트 확인: 버튼 클릭 시 올바른 number 값이 SendToPLC 메서드에 전달되고 있는지 확인하세요.
**