"name=LockerDbConnection") 호출이 App.config 파일의 <connectionStrings> 섹션에 정의된 name 속성과 정확히 일치하는지 다시 한번 확인해 보시는 것이 중요합니다.

아래는 이전에 모든 모델(DbSet)과 로그 기록 로직이 포함된 LockerDbContext.cs 파일의 전체 코드입니다.

C#

// 필요한 네임스페이스
using LockerManagementApp.Models; // 모델 클래스들
using System;
using System.Collections.Generic;
using System.Data.Entity; // EF6 DbContext 사용
using System.Data.Entity.Infrastructure; // DbEntityEntry 사용
using System.Linq;
using System.Threading.Tasks;
using System.Web.Script.Serialization; // 간단한 JSON 직렬화 (또는 Newtonsoft.Json)

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스입니다.
    /// 데이터베이스 연결 및 테이블 접근, 변경 로그 기록을 관리합니다.
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- 테이블 매핑을 위한 DbSet 속성들 ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; } // 사물함 배정 정보
        public DbSet<AuditLog> AuditLogs { get; set; }             // 감사 로그
        public DbSet<LockerType> LockerTypes { get; set; }         // 마스터: 사물함 종류
        public DbSet<Floor> Floors { get; set; }                  // 마스터: 층
        public DbSet<Zone> Zones { get; set; }                   // 마스터: 구역
        public DbSet<SubPart> SubParts { get; set; }              // 마스터: 소파트
        public DbSet<Administrator> Administrators { get; set; }    // 마스터: 관리자

        /// <summary>
        /// 기본 생성자. App.config의 "LockerDbConnection" 이름의 연결 문자열을 사용합니다.
        /// 이 부분의 "name=LockerDbConnection"이 App.config과 정확히 일치해야 합니다.
        /// </summary>
        public LockerDbContext() : base("name=LockerDbConnection")
        {
            // 데이터베이스 초기화 전략 설정 (선택 사항)
            // 예: Database.SetInitializer<LockerDbContext>(null); // DB 자동 관리 안 함
            // 예: Database.SetInitializer(new MigrateDatabaseToLatestVersion<LockerDbContext, Migrations.Configuration>()); // Code First 마이그레이션 사용 시
        }

        /// <summary>
        /// 모델(테이블) 생성 시 추가 구성을 위한 메서드입니다 (Fluent API).
        /// </summary>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // 필요한 경우 Fluent API를 사용하여 모델 상세 설정
            // 예: modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).HasMaxLength(1000);

            base.OnModelCreating(modelBuilder);
        }

        #region SaveChanges Overrides for Audit Logging

        /// <summary>
        /// 동기 방식 변경 사항 저장 시 감사 로그를 기록합니다.
        /// </summary>
        public override int SaveChanges()
        {
            var auditEntries = CreateAuditEntries(); // 변경 내용 기반으로 로그 엔트리 생성
            var result = base.SaveChanges(); // 실제 DB 변경 적용
            if (result > 0 && auditEntries.Any()) // 변경이 성공했고 기록할 로그가 있으면
            {
                SaveAuditLogs(auditEntries); // 로그 저장
            }
            return result;
        }

        /// <summary>
        /// 비동기 방식 변경 사항 저장 시 감사 로그를 기록합니다.
        /// </summary>
        public override async Task<int> SaveChangesAsync()
        {
            var auditEntries = CreateAuditEntries(); // 변경 내용 기반으로 로그 엔트리 생성
            var result = await base.SaveChangesAsync(); // 실제 DB 변경 적용
            if (result > 0 && auditEntries.Any()) // 변경이 성공했고 기록할 로그가 있으면
            {
                await SaveAuditLogsAsync(auditEntries); // 로그 저장 (비동기)
            }
            return result;
        }

        /// <summary>
        /// 현재 변경 추적 중인 엔티티를 기반으로 감사 로그 엔트리 목록을 생성합니다.
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            // 실제 환경에서는 인증된 사용자 정보 사용 필요
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";

            var auditEntries = new List<AuditLog>();
            // 상태가 변경된(Added, Modified, Deleted) 엔티티만 가져옴
            var changedEntries = ChangeTracker.Entries()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                .ToList();

            // JSON 직렬화 도구 (Newtonsoft.Json 권장)
            var serializer = new JavaScriptSerializer();
            serializer.MaxJsonLength = int.MaxValue; // 긴 데이터 로깅을 위해 길이 제한 증가

            foreach (var entry in changedEntries)
            {
                // AuditLog 자체의 변경은 로깅하지 않음
                if (entry.Entity is AuditLog) continue;

                var auditEntry = new AuditLog
                {
                    Timestamp = DateTime.Now,
                    UserName = currentUserName,
                    TableName = entry.Entity.GetType().Name, // 클래스 이름을 테이블 이름으로 사용
                    Action = entry.State.ToString() // "Added", "Modified", "Deleted"
                };

                // 레코드의 기본 키(Id) 값 가져오기 시도
                try { auditEntry.RecordId = entry.Property("Id").CurrentValue?.ToString(); }
                catch { auditEntry.RecordId = "N/A"; } // Id 속성이 없는 경우

                var oldValues = new Dictionary<string, object>();
                var newValues = new Dictionary<string, object>();
                var affectedColumns = new List<string>();

                if (entry.State == EntityState.Added)
                {
                    // 추가된 경우: 모든 현재 값을 NewValues에 기록
                    foreach (var propertyName in entry.CurrentValues.PropertyNames)
                    {
                        newValues[propertyName] = entry.CurrentValues[propertyName];
                    }
                    try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Deleted)
                {
                    // 삭제된 경우: 모든 원본 값을 OldValues에 기록
                    foreach (var propertyName in entry.OriginalValues.PropertyNames)
                    {
                        oldValues[propertyName] = entry.OriginalValues[propertyName];
                    }
                    try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                }
                else if (entry.State == EntityState.Modified)
                {
                    // 수정된 경우: 변경된 속성의 이전 값과 새 값을 기록
                    foreach (var propertyName in entry.OriginalValues.PropertyNames)
                    {
                        var originalValue = entry.OriginalValues[propertyName];
                        var currentValue = entry.CurrentValues[propertyName];

                        // 값이 실제로 변경되었는지 확인
                        if (!Equals(originalValue, currentValue))
                        {
                            affectedColumns.Add(propertyName);
                            oldValues[propertyName] = originalValue;
                            newValues[propertyName] = currentValue;
                        }
                    }

                    // 변경된 컬럼이 있을 경우에만 로그 기록
                    if (affectedColumns.Any())
                    {
                        auditEntry.AffectedColumns = string.Join(",", affectedColumns);
                        try { auditEntry.OldValues = serializer.Serialize(oldValues); } catch { auditEntry.OldValues = "Serialization Error"; }
                        try { auditEntry.NewValues = serializer.Serialize(newValues); } catch { auditEntry.NewValues = "Serialization Error"; }
                    }
                    else
                    {
                        // 실제 변경된 속성이 없으면 이 엔티티 로그는 건너뜀
                        continue;
                    }
                }

                auditEntries.Add(auditEntry);
            }

            // LockerAssignment 엔티티의 LastUpdated 속성 업데이트
            UpdateLockerAssignmentTimestamps(changedEntries);

            return auditEntries;
        }

        /// <summary>
        /// 생성된 감사 로그를 동기적으로 저장합니다.
        /// </summary>
        private void SaveAuditLogs(List<AuditLog> auditEntries)
        {
            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    this.AuditLogs.AddRange(auditEntries);
                    base.SaveChanges(); // 로그 테이블에만 저장
                }
                catch (Exception ex)
                {
                    // 로그 저장 실패 시 예외 처리 (예: 파일 로깅)
                    System.Diagnostics.Debug.WriteLine($"!!! 감사 로그 저장 실패: {ex.ToString()}");
                }
            }
        }

        /// <summary>
        /// 생성된 감사 로그를 비동기적으로 저장합니다.
        /// </summary>
        private async Task SaveAuditLogsAsync(List<AuditLog> auditEntries)
        {
            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    this.AuditLogs.AddRange(auditEntries);
                    await base.SaveChangesAsync(); // 로그 테이블에만 저장
                }
                catch (Exception ex)
                {
                    // 로그 저장 실패 시 예외 처리
                    System.Diagnostics.Debug.WriteLine($"!!! 감사 로그 저장 실패 (비동기): {ex.ToString()}");
                }
            }
        }

        /// <summary>
        /// 변경된 LockerAssignment 엔티티의 LastUpdated 타임스탬프를 업데이트합니다.
        /// </summary>
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries)
        {
            // LockerAssignment 타입이면서 Added 또는 Modified 상태인 엔트리 필터링
            var lockerEntries = changedEntries
                .Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified));

            foreach (var entry in lockerEntries)
            {
                // LastUpdated 속성을 현재 시간으로 설정
                ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now;
            }
        }

        #endregion
    }