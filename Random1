, 달력 기반 자동 모니터 제어 스케줄링 기능을 간단하게 비활성화하시려면, Flask 애플리케이션이 시작될 때 APScheduler가 관련 작업을 등록하고 시작하는 부분을 주석 처리하시면 됩니다.

가장 핵심적인 파일은 app/__init__.py 입니다.

수정: app/__init__.py (스케줄러 관련 부분 주석 처리)
create_app 함수 내에서 APScheduler 관련 작업 등록 및 시작 부분을 찾아 다음과 같이 주석 처리합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app
from config import config
import datetime
import os
from flask_apscheduler import APScheduler 

scheduler = APScheduler()

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # --- Jinja2 필터 및 컨텍스트 프로세서 (이전과 동일) ---
    # ... (format_datetime, inject_now, inject_user_info_to_templates 등록 코드 생략 - 이전 답변 #54 내용 유지) ...
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)


    # --- 블루프린트 등록 (이전과 동일) ---
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 
    # 로그 보기 블루프린트가 있다면 그것도 등록 (이전 답변 #52 참고)
    from .routes_logs import logs_bp 
    app.register_blueprint(logs_bp, url_prefix='/history')


    # --- APScheduler 초기화 및 작업 등록 ---
    if not scheduler.running:
        scheduler.init_app(app)
        app.logger.info("APScheduler init_app(app) 호출됨.")

        # from . import scheduler_tasks # 스케줄 작업 함수들이 있는 모듈 임포트 -> 주석 처리 가능 또는 유지
        
        # current_flask_app_for_scheduler = app 

        job_id_on = 'scheduled_task_monitor_on_daily'
        job_id_off = 'scheduled_task_monitor_off_daily'

        try:
            # ▼▼▼▼▼ 달력 자동 제어 기능을 비활성화하려면 아래 add_job 호출들을 주석 처리 ▼▼▼▼▼
            """
            scheduler.add_job(
                id=job_id_on, 
                func=scheduler_tasks.scheduled_task_monitor_on, # 이 함수가 호출되지 않음
                args=[current_flask_app_for_scheduler], 
                trigger='cron', 
                hour=6, 
                minute=0, 
                misfire_grace_time=3600,
                replace_existing=True 
            )
            app.logger.info(f"스케줄 작업 '{job_id_on}' 매일 06:00 등록/대체됨.")

            scheduler.add_job(
                id=job_id_off, 
                func=scheduler_tasks.scheduled_task_monitor_off, # 이 함수가 호출되지 않음
                args=[current_flask_app_for_scheduler], 
                trigger='cron', 
                hour=7, 
                minute=0, 
                misfire_grace_time=3600,
                replace_existing=True
            )
            app.logger.info(f"스케줄 작업 '{job_id_off}' 매일 07:00 등록/대체됨.")
            """
            # ▲▲▲▲▲ 여기까지 주석 처리 ▲▲▲▲▲

            # ▼▼▼ 스케줄러 시작 부분도 주석 처리 (작업이 없으면 시작할 필요 없음) ▼▼▼
            """
            if not app.config.get('TESTING', False): 
                scheduler.start() 
                app.logger.info("APScheduler 시작됨.")
            else:
                app.logger.info("TESTING 모드: APScheduler 자동 시작 안 함.")
            """
            app.logger.info("달력 기반 자동 제어 스케줄 작업이 비활성화되었습니다 (주석 처리됨).")
            # ▲▲▲ 스케줄러 시작 부분 주석 처리 ▲▲▲

        except Exception as e:
            app.logger.error(f"APScheduler 작업 등록 또는 시작 중 오류 발생 (현재는 비활성화됨): {e}", exc_info=True)
    else:
        app.logger.info("APScheduler가 이미 실행 중이거나 다른 방식으로 초기화됨.")


    app.logger.info("Flask application 생성 및 설정 완료.")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")
        # if scheduler.running: # 스케줄러가 실행 중일 때만 로그 출력
        #    app.logger.debug(f"등록된 스케줄러 작업: {scheduler.get_jobs()}")


    return app
주요 변경 사항 (주석 처리):

scheduler.add_job(...) 호출 부분:
scheduled_task_monitor_on 작업을 등록하는 scheduler.add_job(...) 호출 전체를 주석 처리합니다.
scheduled_task_monitor_off 작업을 등록하는 scheduler.add_job(...) 호출 전체를 주석 처리합니다.
scheduler.start() 호출 부분:
스케줄러를 시작하는 scheduler.start() 호출 부분을 주석 처리합니다. (등록된 작업이 없으므로 스케줄러를 시작할 필요가 없습니다.)
이렇게 수정하면:

Flask 애플리케이션이 시작될 때 APScheduler가 scheduled_task_monitor_on과 scheduled_task_monitor_off 함수를 특정 시간에 실행하도록 등록하지 않습니다.
따라서, 달력(공휴일, 주말, 사용자 지정 예외)에 기반한 자동 모니터 켜기/끄기 설정 명령이 실행되지 않습니다.
관리자 메뉴의 "달력 예외 관리" 페이지는 여전히 접근하여 예외 날짜를 설정할 수 있지만, 이 설정이 실제 자동화 동작에 영향을 주지는 않게 됩니다. (수동 명령 전송에는 영향 없음)
다시 자동 기능을 활성화하려면:
위에서 주석 처리한 부분들의 주석을 다시 해제하고 Flask 애플리케이션을 재시작하면 됩니다.

이 방법이 가장 간단하게 달력 기반 자동 제어 동작을 비활성화하는 방법입니다.