def find_all_lis(arr):
    n = len(arr)
    lis = [1] * n
    prev = [[] for _ in range(n)]  # 각 요소의 이전 인덱스 목록을 저장

    # LIS 값 계산과 이전 인덱스 추적
    for i in range(1, n):
        for j in range(i):
            if arr[i] > arr[j] and lis[i] < lis[j] + 1:
                lis[i] = lis[j] + 1
                prev[i] = [j]
            elif arr[i] > arr[j] and lis[i] == lis[j] + 1:
                prev[i].append(j)

    # LIS 길이 찾기
    max_len = max(lis)

    # LIS 부분 수열 재구성 함수
    def construct_lis_paths_stack(end_index):
        stack = [(end_index, [arr[end_index]])]
        all_paths = []

        while stack:
            current_index, path = stack.pop()
            if not prev[current_index]:  # 시작점 도달
                all_paths.append(path[::-1])  # 경로를 반전해서 저장
            else:
                for predecessor in prev[current_index]:
                    stack.append((predecessor, path + [arr[predecessor]]))

        return all_paths

    # 모든 LIS 부분 수열 찾기
    all_lis = []
    for i in range(n):
        if lis[i] == max_len:
            all_lis.extend(construct_lis_paths_stack(i))

    print("LIS 길이:", max_len)
    for seq in all_lis:
        print("LIS 부분 수열:", seq)

# 예제 테스트
find_all_lis([1, 5, 4, 2, 15, 6, 7, 124, 6, 1251, 1152, 12, 4, 421, 5, 16])
