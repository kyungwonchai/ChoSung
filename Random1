지적해주신 내용이 정확합니다. 죄송합니다. 제가 제시한 이전 방법은 체크 스크립트(check.sh)가 수 초 내에 완료되는 일반적인 경우를 가정한 것이었습니다.

스크립트 실행 시간(3분)이 Watchdog의 확인 주기(interval=10초)보다 훨씬 길기 때문에, 말씀하신 대로 10초마다 3분짜리 프로세스가 계속 생성되어 시스템 리소스를 고갈시키고 결국 시스템이 다운되는 심각한 문제가 발생합니다.

이 문제를 해결하기 위한 올바른 아키텍처는 역할을 명확히 분리하는 것입니다.

## ⚙️ 해결 방안: 역할 분리 (Decoupling)
핵심은 오래 걸리는 작업과 빠른 상태 확인을 분리하는 것입니다.

장기 실행 검사 서비스 (Checker Daemon): 3분짜리 검사 스크립트(check.sh)를 백그라운드에서 계속 실행시키는 별도의 서비스입니다. 이 서비스는 검사가 성공할 때마다 "나 살아있어"라는 의미의 생존 신호(Heartbeat) 파일을 갱신합니다.

Watchdog: 10초마다 아주 빠른 스크립트를 실행합니다. 이 스크립트는 3분짜리 검사를 직접 실행하는 것이 아니라, 위에서 만든 생존 신호 파일이 최근에 갱신되었는지만 1초 안에 확인합니다.

만약 장기 실행 검사 서비스가 어떤 이유로 멈추거나 먹통이 되면, 생존 신호 파일이 더 이상 갱신되지 않습니다. 그러면 Watchdog이 이를 감지하고 시스템을 재부팅하게 됩니다.

## 📝 단계별 실행 방법
1. 장기 실행 검사 서비스 스크립트 작성 (/usr/local/bin/long_running_checker.sh)
이 스크립트는 무한 루프를 돌며 실제 3분짜리 검사를 수행하고, 성공 시 생존 신호 파일을 touch 명령어로 갱신합니다.

sudo nano /usr/local/bin/long_running_checker.sh

Bash

#!/bin/bash

# 생존 신호를 남길 파일 경로
HEARTBEAT_FILE="/tmp/checker_heartbeat"

while true; do
    # 여기에 원래 3분 이상 걸리는 실제 검사 명령어를 넣으세요.
    # 예시: /path/to/your/real_check.sh
    # 아래는 예시로 3분간 대기하는 코드입니다. 실제 검사 코드로 대체하세요.
    echo "Starting 3-minute check..."
    /path/to/your/real_check.sh

    # 위 검사가 성공적으로 끝나면 (종료 코드 0), 생존 신호 파일을 갱신합니다.
    # $? 변수는 직전 명령어의 종료 코드를 담고 있습니다.
    if [ $? -eq 0 ]; then
        echo "Check successful. Updating heartbeat."
        touch "$HEARTBEAT_FILE"
    else
        echo "Check failed. Not updating heartbeat."
    fi

    # 다음 검사까지 잠시 대기 (선택 사항)
    sleep 10
done
[중요]

/path/to/your/real_check.sh 부분을 실제 3분짜리 검사 스크립트의 경로로 반드시 바꾸세요.

스크립트에 실행 권한을 부여합니다: sudo chmod +x /usr/local/bin/long_running_checker.sh

2. 장기 실행 검사 서비스를 systemd로 등록
이 스크립트가 항상 백그라운드에서 실행되도록 systemd 서비스로 만드는 것이 가장 안정적입니다.

sudo nano /etc/systemd/system/long-checker.service

Ini, TOML

[Unit]
Description=Long Running Checker Service
After=network.target

[Service]
ExecStart=/usr/local/bin/long_running_checker.sh
Restart=always
User=pi  # 스크립트를 실행할 사용자 계정 (필요시 변경)
StandardOutput=journal
StandardError=journal

[Install]
WantedBy=multi-user.target
이제 서비스를 활성화하고 시작합니다.

Bash

sudo systemctl enable long-checker.service
sudo systemctl start long-checker.service

# 서비스가 잘 동작하는지 확인
sudo systemctl status long-checker.service
3. Watchdog용 빠른 상태 확인 스크립트 작성 (/etc/watchdog.d/quick_heartbeat_check.sh)
이 스크립트는 1초도 안 걸립니다. 오직 생존 신호 파일의 수정 시간만 확인합니다.

sudo nano /etc/watchdog.d/quick_heartbeat_check.sh

Bash

#!/bin/bash

HEARTBEAT_FILE="/tmp/checker_heartbeat"
# 허용할 최대 지연 시간(초). 장기 실행 검사가 3분(180초)이므로,
# 그보다 넉넉하게 5분(300초) 정도로 설정합니다.
MAX_DELAY=300

# 파일이 존재하지 않으면 즉시 실패
if [ ! -f "$HEARTBEAT_FILE" ]; then
    exit 1
fi

# 파일의 마지막 수정 시간과 현재 시간의 차이를 초 단위로 계산
LAST_MODIFIED=$(stat -c %Y "$HEARTBEAT_FILE")
CURRENT_TIME=$(date +%s)
TIME_DIFF=$((CURRENT_TIME - LAST_MODIFIED))

# 시간 차이가 허용된 지연 시간을 초과하면 실패(exit 1)
if [ $TIME_DIFF -gt $MAX_DELAY ]; then
    # 장기 실행 검사 프로세스가 멈췄다고 판단, 재부팅 유발
    exit 1
else
    # 아직 정상 범위, 성공(exit 0)
    exit 0
fi
마찬가지로 실행 권한을 부여합니다: sudo chmod +x /etc/watchdog.d/quick_heartbeat_check.sh

4. /etc/watchdog.conf 파일 수정
이제 Watchdog이 빠른 스크립트를 호출하도록 test-binary 경로를 수정합니다.

sudo nano /etc/watchdog.conf

코드 스니펫

# ... 기존 설정 ...

# Watchdog이 10초마다 실행할 테스트 바이너리를 '빠른 확인 스크립트'로 변경
test-binary            = /etc/watchdog.d/quick_heartbeat_check.sh

# 빠른 확인 스크립트의 타임아웃은 넉넉하게 5초로 설정
test-timeout           = 5

# 메인 루프 주기는 그대로 10초
interval               = 10

# 하드웨어 타임아웃도 그대로 15초
watchdog-timeout       = 15

# ... 나머지 설정 ...
## ✅ 최종 적용 및 요약
모든 파일 수정이 끝났으면 Watchdog 서비스를 재시작하여 최종 적용합니다.

Bash

sudo systemctl restart watchdog
새로운 작동 방식 요약:

long-checker.service가 백그라운드에서 3분짜리 실제 검사를 계속 수행하며, 성공 시 /tmp/checker_heartbeat 파일의 시간을 갱신합니다.

watchdog 서비스는 10초마다 quick_heartbeat_check.sh를 실행합니다.

quick_heartbeat_check.sh는 /tmp/checker_heartbeat 파일의 수정 시간이 5분 이내인지 순식간에 확인하고 종료합니다.

만약 long-checker.service가 멈추면, heartbeat 파일은 더 이상 갱신되지 않습니다.

결국 heartbeat 파일의 수정 시간은 5분을 넘게 되고, quick_heartbeat_check.sh가 exit 1 (실패)을 반환하여 Watchdog이 시스템을 재부팅시킵니다.