읽기 시작 및 종료를 제어하며, 읽은 값을 메인 UI에 표시하는 기능을 구현할 수 있습니다.

다음은 그에 맞는 WPF 프로젝트의 코드 예시입니다.

1. MainWindow.xaml (UI 설정)
4개의 텍스트 박스를 추가하여 각 레지스터 값(R520 ~ R524)을 표시할 수 있습니다. 그리고, 읽기 시작 및 중지 버튼을 추가하여 소켓 통신을 시작하고 중지할 수 있게 합니다.

xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
    <Grid>
        <StackPanel>
            <TextBlock Text="R520:" />
            <TextBox Text="{Binding R520}" IsReadOnly="True" />
            
            <TextBlock Text="R521:" />
            <TextBox Text="{Binding R521}" IsReadOnly="True" />
            
            <TextBlock Text="R522:" />
            <TextBox Text="{Binding R522}" IsReadOnly="True" />
            
            <TextBlock Text="R523:" />
            <TextBox Text="{Binding R523}" IsReadOnly="True" />
            
            <TextBlock Text="R524:" />
            <TextBox Text="{Binding R524}" IsReadOnly="True" />
            
            <Button Content="실시간 읽기 시작" Command="{Binding StartReadingCommand}" />
            <Button Content="실시간 읽기 종료" Command="{Binding StopReadingCommand}" />
        </StackPanel>
    </Grid>
</Window>
2. MainViewModel.cs (뷰모델)
MainViewModel에서는 1초마다 R520 ~ R524의 값을 읽고, 이 값을 UI에 바인딩된 속성에 업데이트합니다.

csharp
코드 복사
using System;
using System.ComponentModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input;

namespace WpfApp
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private string r520, r521, r522, r523, r524;
        private CancellationTokenSource _cancellationTokenSource;
        private ComportManager comportManager;

        public string R520
        {
            get => r520;
            set
            {
                r520 = value;
                OnPropertyChanged(nameof(R520));
            }
        }

        public string R521
        {
            get => r521;
            set
            {
                r521 = value;
                OnPropertyChanged(nameof(R521));
            }
        }

        public string R522
        {
            get => r522;
            set
            {
                r522 = value;
                OnPropertyChanged(nameof(R522));
            }
        }

        public string R523
        {
            get => r523;
            set
            {
                r523 = value;
                OnPropertyChanged(nameof(R523));
            }
        }

        public string R524
        {
            get => r524;
            set
            {
                r524 = value;
                OnPropertyChanged(nameof(R524));
            }
        }

        public ICommand StartReadingCommand { get; }
        public ICommand StopReadingCommand { get; }

        public event PropertyChangedEventHandler PropertyChanged;

        public MainViewModel()
        {
            comportManager = ComportManager.GetInstance();
            StartReadingCommand = new RelayCommand(StartReading);
            StopReadingCommand = new RelayCommand(StopReading);
        }

        private void StartReading()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ReadRegistersAsync(_cancellationTokenSource.Token));
        }

        private void StopReading()
        {
            _cancellationTokenSource?.Cancel();
        }

        private async Task ReadRegistersAsync(CancellationToken token)
        {
            while (!token.IsCancellationRequested)
            {
                // PLC에서 R520 ~ R524 값을 읽습니다.
                R520 = await comportManager.ReadRegisterAsync("R520");
                R521 = await comportManager.ReadRegisterAsync("R521");
                R522 = await comportManager.ReadRegisterAsync("R522");
                R523 = await comportManager.ReadRegisterAsync("R523");
                R524 = await comportManager.ReadRegisterAsync("R524");

                await Task.Delay(1000); // 1초 대기
            }
        }

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
3. ComportManager.cs (COM 포트 관리)
ComportManager는 R520 ~ R524 값을 읽기 위해 사용됩니다. 각 레지스터 값은 ReadRegisterAsync 메서드를 통해 비동기적으로 읽을 수 있습니다.

csharp
코드 복사
using System.Threading.Tasks;

namespace WpfApp
{
    public class ComportManager
    {
        private static ComportManager _instance;

        private ComportManager() { }

        public static ComportManager GetInstance()
        {
            if (_instance == null)
                _instance = new ComportManager();
            return _instance;
        }

        public async Task<string> ReadRegisterAsync(string registerAddress)
        {
            // 실제 MEWTOCOL 프로토콜을 통해 PLC와 통신하여 레지스터 값을 읽음
            await Task.Delay(50);  // 통신 지연을 시뮬레이션
            return $"Value of {registerAddress}";  // 예시로 반환된 값
        }
    }
}
4. RelayCommand.cs (MVVM 패턴의 명령)
명령 패턴을 구현하는 RelayCommand는 버튼을 클릭할 때 실행될 메서드를 정의합니다.

csharp
코드 복사
using System;
using System.Windows.Input;

namespace WpfApp
{
    public class RelayCommand : ICommand
    {
        private readonly Action _execute;
        private readonly Func<bool> _canExecute;

        public RelayCommand(Action execute, Func<bool> canExecute = null)
        {
            _execute = execute;
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter) => _canExecute == null || _canExecute();
        public void Execute(object parameter) => _execute();
        public event EventHandler CanExecuteChanged;
    }
}
5. 종합 설명
UI: MainWindow.xaml에서 각 레지스터(R520 ~ R524) 값을 표시할 텍스트 박스를 만들고, 시작 및 종료 버튼을 통해 읽기 작업을 제어합니다.
뷰모델: MainViewModel에서 1초마다 PLC의 R520 ~ R524 값을 읽고, 그 값을 UI에 바인딩된 속성에 업데이트합니다. StartReadingCommand와 StopReadingCommand를 통해 읽기 작업을 시작 및 종료할 수 있습니다.
통신: ComportManager는 실제로 MEWTOCOL 프로토콜을 사용하여 PLC와 통신하고, 레지스터 값을 읽어옵니다. 여기서는 통신 지연을 시뮬레이션하기 위해 Task.Delay를 사용하였습니다.
MVVM: RelayCommand를 사용하여 MVVM 패턴을 유지하면서, UI와 뷰모델 간의 명령을 연결합니다.
이 코드를 사용하면 PLC의 R520 ~ R524 값을 1초마다 읽고, 읽은 값을 UI에 실시간으로 표시할 수 있으며, 버튼을 통해 읽기 작업을 시작/종료할