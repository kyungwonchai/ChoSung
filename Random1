래는 WPF 순수 기능만 사용하여 그룹과 라인을 계층적으로 표시하고, 체크박스를 통해 그룹 및 하위 항목의 선택 상태를 동기화하는 완전한 코드입니다. DevExpress 없이 구현되었습니다.

XAML 코드
xml
코드 복사
<Window x:Class="TreeViewCheckboxExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="TreeView with Checkboxes" Height="600" Width="400">
    <Grid>
        <TreeView x:Name="treeView" ItemsSource="{Binding Groups}" Margin="10">
            <TreeView.ItemTemplate>
                <HierarchicalDataTemplate ItemsSource="{Binding Children}">
                    <StackPanel Orientation="Horizontal">
                        <CheckBox IsChecked="{Binding IsChecked, Mode=TwoWay}" 
                                  Checked="CheckBox_Checked" Unchecked="CheckBox_Unchecked" />
                        <TextBlock Text="{Binding Name}" Margin="5,0,0,0" />
                    </StackPanel>
                </HierarchicalDataTemplate>
            </TreeView.ItemTemplate>
        </TreeView>
    </Grid>
</Window>
C# 코드
csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Linq;
using System.Windows;

namespace TreeViewCheckboxExample
{
    public partial class MainWindow : Window
    {
        public ObservableCollection<Group> Groups { get; set; }

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;

            // 예제 데이터 로드
            Groups = new ObservableCollection<Group>
            {
                new Group
                {
                    Name = "Group A",
                    Children = new ObservableCollection<Group>
                    {
                        new Group { Name = "Line 1.1" },
                        new Group { Name = "Line 1.2" }
                    }
                },
                new Group
                {
                    Name = "Group B",
                    Children = new ObservableCollection<Group>
                    {
                        new Group { Name = "Line 2.1" },
                        new Group { Name = "Line 2.2" }
                    }
                }
            };
        }

        private void CheckBox_Checked(object sender, RoutedEventArgs e)
        {
            if (treeView.SelectedItem is Group group)
            {
                SetChildrenCheckState(group, true);
                UpdateParentCheckState(group);
            }
        }

        private void CheckBox_Unchecked(object sender, RoutedEventArgs e)
        {
            if (treeView.SelectedItem is Group group)
            {
                SetChildrenCheckState(group, false);
                UpdateParentCheckState(group);
            }
        }

        private void SetChildrenCheckState(Group group, bool isChecked)
        {
            foreach (var child in group.Children)
            {
                child.IsChecked = isChecked;
                SetChildrenCheckState(child, isChecked);
            }
        }

        private void UpdateParentCheckState(Group child)
        {
            var parent = Groups.FirstOrDefault(g => g.Children.Contains(child));
            if (parent != null)
            {
                parent.IsChecked = parent.Children.All(c => c.IsChecked);
                UpdateParentCheckState(parent);
            }
        }
    }

    public class Group : INotifyPropertyChanged
    {
        private bool _isChecked;
        public string Name { get; set; }
        public ObservableCollection<Group> Children { get; set; } = new ObservableCollection<Group>();

        public bool IsChecked
        {
            get => _isChecked;
            set
            {
                if (_isChecked != value)
                {
                    _isChecked = value;
                    OnPropertyChanged(nameof(IsChecked));
                }
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
구현 설명
데이터 구조:

Group 클래스는 그룹 및 라인을 나타냅니다.
Children 속성을 통해 하위 노드를 계층적으로 관리합니다.
체크박스 동기화:

CheckBox_Checked, CheckBox_Unchecked 이벤트를 통해 부모-자식 간 선택 상태를 동기화합니다.
그룹을 선택하면 모든 하위 라인이 선택되며, 하위 라인의 선택 상태에 따라 그룹의 상태도 변경됩니다.
TreeView 구성:

ItemsSource: Groups 데이터 바인딩.
HierarchicalDataTemplate: 계층 구조 데이터를 표시하며, 체크박스를 포함한 UI를 구성합니다.
INotifyPropertyChanged:

Group 클래스에 선택 상태 변경을 반영하기 위해 INotifyPropertyChanged를 구현했습니다.
결과
계층 구조:

그룹 (Group A, Group B)과 라인 (Line 1.1, Line 1.2)이 계층적으로 표시됩니다.
체크박스 동기화:

그룹 체크박스를 선택하면 모든 하위 라인이 선택됩니다.
하위 라인의 선택 상태에 따라 그룹 체크박스 상태도 업데이트됩니다.
추가 SQL 데이터 연동
만약 MSSQL 데이터베이스에서 데이터를 가져오려면, 아래와 같이 데이터를 로드합니다.

SQL 테이블
sql
코드 복사
CREATE TABLE LineTable (
    GroupName NVARCHAR(100),
    LineName NVARCHAR(100)
);

INSERT INTO LineTable (GroupName, LineName)
VALUES 
    ('Group A', 'Line 1.1'),
    ('Group A', 'Line 1.2'),
    ('Group B', 'Line 2.1'),
    ('Group B', 'Line 2.2');
데이터 로드
csharp
코드 복사
private void LoadDataFromDatabase()
{
    Groups = new ObservableCollection<Group>();
    string connectionString = "YourConnectionStringHere";

    using (SqlConnection connection = new SqlConnection(connectionString))
    {
        connection.Open();
        string query = "SELECT GroupName, LineName FROM LineTable ORDER BY GroupName, LineName";

        using (SqlCommand command = new SqlCommand(query, connection))
        using (SqlDataReader reader = command.ExecuteReader())
        {
            while (reader.Read())
            {
                string groupName = reader.GetString(0);
                string lineName = reader.GetString(1);

                var group = Groups.FirstOrDefault(g => g.Name == groupName);
                if (group == null)
                {
                    group = new Group { Name = groupName };
                    Groups.Add(group);
                }

                group.Children.Add(new Group { Name = lineName });
            }
        }
    }
}