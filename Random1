// MGSPMonitorControl/Services/BrokerClientService.cs
using System;
using System.IO;
using System.Net; 
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorControl.SharedModels; 
using Newtonsoft.Json;
using System.Configuration;     

namespace MGSPMonitorControl.Services
{
    public interface IBrokerClientService // 인터페이스는 변경 없음
    {
        bool IsConnected { get; }
        Task<Tuple<bool, string>> ConnectAsync();
        Task DisconnectAsync();
        Task SendMessageAsync(BrokerMessage message);

        event Action<BrokerMessage> MessageReceived;
        event Action Connected;
        event Action<string> Disconnected;
    }

    public class BrokerClientService : IBrokerClientService, IDisposable
    {
        private TcpClient _tcpClient; // ConnectAsync 시작 시 new TcpClient() 할당
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;
        private volatile bool _isConnecting = false;
        private volatile bool _explicitlyDisconnected = false;

        private readonly string _brokerIp = "127.0.0.1"; 
        private readonly int _brokerPort = 9001;      
        private readonly bool _configValid = false; // 생성자에서 최종 결정됨

        public bool IsConnected => !_isDisposed && _tcpClient != null && _tcpClient.Connected && 
                                  _networkStream != null && _streamReader != null && _streamWriter != null;

        public event Action<BrokerMessage> MessageReceived;
        public event Action Connected;
        public event Action<string> Disconnected;

        public BrokerClientService()
        {
            SafeConsoleLog("BrokerClientService: Constructor - Initializing...");
            string brokerAddressSetting = null;
            bool configReadSuccess = false;
            try
            {
                var appSettings = ConfigurationManager.AppSettings;
                brokerAddressSetting = appSettings["BrokerAddress"];
                configReadSuccess = true; // AppSettings 자체는 읽혔다고 가정
            }
            catch (ConfigurationErrorsException confEx)
            {
                SafeConsoleLog($"[CRITICAL_CONFIG_ERROR] Failed to load App.config or AppSettings: {confEx.Message}. Broker address will use default and may fail.");
                // _configValid는 아래에서 최종 결정됨
            }
            catch (Exception ex) // 기타 예외
            {
                SafeConsoleLog($"[ERROR] Unexpected error reading BrokerAddress from App.config: {ex.Message}. Broker address will use default.");
            }

            string addressToParse = (configReadSuccess && !string.IsNullOrWhiteSpace(brokerAddressSetting)) ? brokerAddressSetting : $"{_brokerIp}:{_brokerPort}";
            
            if (configReadSuccess && string.IsNullOrWhiteSpace(brokerAddressSetting))
            {
                 SafeConsoleLog($"[CONFIG_WARN] 'BrokerAddress' not found or empty in App.config. Using default: {addressToParse}");
            }

            var parts = addressToParse.Split(':');
            if (parts.Length == 2 && 
                IPAddress.TryParse(parts[0], out IPAddress ip) && 
                int.TryParse(parts[1], System.Globalization.NumberStyles.None, System.Globalization.CultureInfo.InvariantCulture, out int port) &&
                port > 0 && port <= 65535)
            {
                _brokerIp = ip.ToString(); // 유효한 값으로 업데이트
                _brokerPort = port;
                _configValid = true; 
                SafeConsoleLog($"BrokerClientService: Target Broker configured to {_brokerIp}:{_brokerPort}");
            }
            else
            {
                SafeConsoleLog($"[CONFIG_ERROR] Invalid 'BrokerAddress' format ('{addressToParse}'). Using compiled default: {_brokerIp}:{_brokerPort}. Connection may fail if this is not intended.");
                // _configValid는 false로 설정하여 연결 시도를 막거나, 기본값이 유효하다고 믿고 true로 둘 수 있음.
                // 여기서는 기본값이 설정되어 있으므로, 일단 true로 두어 연결 시도 자체는 해보도록 함.
                _configValid = true; // 기본값으로 시도라도 해보도록.
            }
        }

        public async Task<Tuple<bool, string>> ConnectAsync()
        {
            if (!_configValid) // 설정 파일 로드/파싱 실패 시 연결 시도 안 함
            {
                string errMsg = "Broker configuration is invalid or unreadable (check App.config). Cannot connect.";
                SafeConsoleLog($"BrokerClientService: {errMsg}");
                Disconnected?.Invoke(errMsg); // ViewModel에 알림
                return Tuple.Create(false, errMsg);
            }
            if (IsConnected)
            {
                SafeConsoleLog("BrokerClientService: Already connected.");
                return Tuple.Create(true, "Already connected.");
            }
            if (_isDisposed)
            {
                string errMsg = "BrokerClientService is disposed. Cannot connect."; SafeConsoleLog(errMsg); return Tuple.Create(false, errMsg);
            }
            if (_isConnecting)
            {
                SafeConsoleLog("BrokerClientService: Connection attempt already in progress."); return Tuple.Create(false, "Connection attempt in progress.");
            }

            _isConnecting = true;
            _explicitlyDisconnected = false;
            
            _cts?.CancelAfter(TimeSpan.FromMilliseconds(100));
            _cts?.Dispose();
            _cts = new CancellationTokenSource();
            var token = _cts.Token;

            // !!! _tcpClient 인스턴스 생성 위치 변경 !!!
            // ConnectAsync 호출 시마다 새 TcpClient를 생성하여 이전 상태의 영향을 받지 않도록 함.
            // 그리고 ConnectAsync 호출 *전에* null이 아님을 보장.
            _tcpClient = new TcpClient(); 
            SafeConsoleLog($"BrokerClientService: New TcpClient created. Target: {_brokerIp}:{_brokerPort}");

            string connectResultMessage = "Connection attempt failed with an unknown issue.";
            try
            {
                if (string.IsNullOrEmpty(_brokerIp)) // IP가 여전히 null이거나 비어있다면 (생성자 로직 문제)
                {
                    throw new InvalidOperationException("Broker IP address is null or empty. Cannot connect.");
                }

                SafeConsoleLog($"BrokerClientService: Attempting _tcpClient.ConnectAsync to {_brokerIp}:{_brokerPort}...");
                
                var connectTask = _tcpClient.ConnectAsync(_brokerIp, _brokerPort);
                var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(7), token); // 7초 연결 타임아웃

                Task completedTask = await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false);

                if (token.IsCancellationRequested)
                {
                    connectResultMessage = "Connection attempt cancelled by token.";
                    SafeConsoleLog($"BrokerClientService: {connectResultMessage}");
                    // _tcpClient?.Close()는 finally에서 처리
                    throw new OperationCanceledException(connectResultMessage, token);
                }

                if (completedTask == timeoutDelayTask || !connectTask.IsCompleted) 
                {
                    connectResultMessage = $"Timeout connecting to Broker {_brokerIp}:{_brokerPort} after 7 seconds.";
                    SafeConsoleLog($"BrokerClientService: {connectResultMessage}");
                    throw new TimeoutException(connectResultMessage);
                }
                
                // connectTask가 완료됨, 예외가 있었다면 여기서 던져짐
                await connectTask; 

                // 이 시점에서 connectTask는 성공적으로 완료되어야 함 (예외 없음)
                if (_tcpClient.Connected) // 연결 성공
                {
                    _networkStream = _tcpClient.GetStream();
                    if (_networkStream == null) throw new NullReferenceException("CRITICAL: NetworkStream is null after TcpClient successfully connected.");
                    
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    
                    connectResultMessage = "Successfully connected to Broker. Streams initialized.";
                    SafeConsoleLog($"BrokerClientService: {connectResultMessage}");
                    
                    _isConnecting = false; 
                    Connected?.Invoke();   

                    _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(token), token); 
                    return Tuple.Create(true, connectResultMessage);
                }
                else 
                {
                    connectResultMessage = "Connection task completed but TcpClient is not in a connected state.";
                    SafeConsoleLog($"[ERROR] BrokerClientService: {connectResultMessage}");
                    throw new SocketException((int)SocketError.NotConnected);
                }
            }
            catch (OperationCanceledException opCancelledEx) // Task.Delay 또는 외부 CancellationToken에 의해
            {
                connectResultMessage = $"Connection operation was cancelled: {opCancelledEx.Message}";
                SafeConsoleLog($"BrokerClientService: {connectResultMessage}");
            }
            catch (SocketException sockEx) 
            {
                 connectResultMessage = $"SocketException (Network Error) connecting to Broker: {sockEx.Message} (ErrorCode: {sockEx.SocketErrorCode}).\nBroker may not be running at {_brokerIp}:{_brokerPort} or firewall is blocking.";
                 SafeConsoleLog($"[ERROR] BrokerClientService: {connectResultMessage}");
            }
            catch (Exception ex) 
            {
                connectResultMessage = $"General error during ConnectAsync: {ex.ToString()}"; // 스택 트레이스 포함
                SafeConsoleLog($"[ERROR] BrokerClientService: {connectResultMessage}");
            }
            finally // try 블록이 어떻게 끝나든 _isConnecting은 false로
            {
                _isConnecting = false;
                if (!IsConnected) // 연결 성공하지 못했다면 (예외 발생 포함)
                {
                    _tcpClient?.Close(); // 사용한 TcpClient 정리
                    _tcpClient = null;   // null로 설정하여 IsConnected가 false가 되도록
                }
            }

            // 여기까지 왔다면 연결 실패
            // CleanupConnectionResourcesInternal(false); // 여기서 호출하면 Connected 이벤트 후 바로 Disconnected 호출 가능성
            Disconnected?.Invoke(connectResultMessage); // 실패 사유와 함께 Disconnected 이벤트 발생
            return Tuple.Create(false, connectResultMessage);
        }

        // ReceiveMessagesAsync, SendMessageAsync, HandleSendErrorInternal, DisconnectAsync,
        // CleanupConnectionResourcesInternal, Dispose, SafeConsoleLog 메서드들은
        // 이전 답변("열받네,,,,,야 씨발 이에러에 집중해서...")에서 제공한 최종본과 동일하게 유지합니다.
        // (해당 메서드들은 이미 안정성 및 로깅이 강화되어 있습니다.)
        // 아래는 해당 메서드들의 전체 코드입니다.

        private async Task ReceiveMessagesAsync(CancellationToken token)
        {
            SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync loop started.");
            try
            {
                while (!token.IsCancellationRequested && IsConnected) 
                {
                    string messageJson = null;
                    try
                    {
                        messageJson = await _streamReader.ReadLineAsync().ConfigureAwait(false);
                    }
                    catch (ObjectDisposedException) when (token.IsCancellationRequested || _isDisposed) { SafeConsoleLog("BrokerClientService: StreamReader disposed in ReceiveMessagesAsync."); break; }
                    catch (IOException) when (token.IsCancellationRequested || !IsConnected) { SafeConsoleLog("BrokerClientService: IOException in ReceiveMessagesAsync (connection likely lost or cancelled)."); break; }

                    if (messageJson == null) { SafeConsoleLog("BrokerClientService: Broker disconnected (ReadLineAsync returned null)."); break; } 
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null) { SafeConsoleLog($"BrokerClientService: Message received: Type={message.Type}, CorrId={message.CorrelationId}"); MessageReceived?.Invoke(message); }
                        else { SafeConsoleLog($"[WARNING] BrokerClientService: Failed to deserialize message: {messageJson}"); }
                    }
                    catch (JsonException jsonEx) { SafeConsoleLog($"[ERROR] BrokerClientService: JSON deserialization error: {jsonEx.Message}. Received: {messageJson}"); }
                }
            }
            catch (OperationCanceledException) { SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync cancelled."); }
            catch (Exception ex) { if(!token.IsCancellationRequested && !_isDisposed) SafeConsoleLog($"[ERROR] BrokerClientService: Unexpected error in ReceiveMessagesAsync: {ex.ToString()}"); }
            finally
            {
                SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync loop ended.");
                if (!_isDisposed && !token.IsCancellationRequested && !_explicitlyDisconnected)
                {
                    CleanupConnectionResourcesInternal(false);
                    Disconnected?.Invoke("Receive loop ended or connection lost.");
                }
            }
        }

        public async Task SendMessageAsync(BrokerMessage message)
        {
            if (!IsConnected || _streamWriter == null || _isDisposed || (_cts != null && _cts.IsCancellationRequested))
            { SafeConsoleLog($"BrokerClientService: Cannot send message. Invalid state. Type: {message.Type}"); return; }

            string messageJson = "";
            try
            {
                messageJson = JsonConvert.SerializeObject(message);
                bool sent = false;
                lock (_sendLock)
                {
                    if (IsConnected && _streamWriter != null && !_isDisposed && (_cts == null || !_cts.IsCancellationRequested))
                    {
                        _streamWriter.WriteLine(messageJson); 
                        sent = true;
                    }
                }
                if (sent) { SafeConsoleLog($"BrokerClientService: Message sent: {message.Type}, CorrId: {message.CorrelationId}");}
                else { SafeConsoleLog($"[WARNING] BrokerClientService: Send cancelled or not possible for {message.Type} inside lock."); }
            }
            catch (ObjectDisposedException) { SafeConsoleLog($"[WARNING] BrokerClientService: Attempted to send {message.Type} on a disposed object."); HandleSendErrorInternal("Stream/Writer disposed."); }
            catch (IOException ioEx) { SafeConsoleLog($"[ERROR] BrokerClientService: IOException sending {message.Type}: {ioEx.Message}"); HandleSendErrorInternal($"IO Error: {ioEx.Message}"); }
            catch (JsonException jsonEx) { SafeConsoleLog($"[ERROR] BrokerClientService: Error serializing {message.Type}: {jsonEx.Message}. Payload: {message.Payload}"); }
            catch (Exception ex) { SafeConsoleLog($"[ERROR] BrokerClientService: Error sending {message.Type}: {ex.ToString()}"); HandleSendErrorInternal($"General Send Error: {ex.Message}"); }
        }
        
        private void HandleSendErrorInternal(string reason)
        {
            if (!_isDisposed) { CleanupConnectionResourcesInternal(false); Disconnected?.Invoke($"Send failed: {reason}"); }
        }

        public Task DisconnectAsync()
        {
            SafeConsoleLog("BrokerClientService: DisconnectAsync called by user.");
            if (_isDisposed) return Task.FromResult(false); 
            _explicitlyDisconnected = true; 
            _cts?.CancelAfter(TimeSpan.FromMilliseconds(100)); 
            
            CleanupConnectionResourcesInternal(false); 
            Disconnected?.Invoke("User requested disconnect."); 
            return Task.FromResult(true);
        }

        private void CleanupConnectionResourcesInternal(bool calledFromDispose)
        {
            if (!calledFromDispose && _isDisposed) return; 
            if (calledFromDispose && _isDisposed && _tcpClient == null && _networkStream == null) return;

            SafeConsoleLog($"BrokerClientService: Cleaning up connection resources. Called from Dispose: {calledFromDispose}");
            _isConnecting = false;

            lock(_sendLock)
            {
                try { _streamWriter?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing StreamWriter: {ex.Message}"); }
                _streamWriter = null;
            }
            try { _streamReader?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing StreamReader: {ex.Message}"); }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing NetworkStream: {ex.Message}"); }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch (Exception ex){ SafeConsoleLog($"Error closing TcpClient: {ex.Message}"); }
            _tcpClient = null;
            
            if (calledFromDispose && _cts != null) // Dispose 시에만 CancellationTokenSource 정리
            {
                if(!_cts.IsCancellationRequested) _cts.Cancel();
                _cts.Dispose();
                _cts = null;
            }
            
            if (!calledFromDispose) SafeConsoleLog("BrokerClientService: Connection resources released (not from Dispose).");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            SafeConsoleLog("BrokerClientService: Disposing...");
            _explicitlyDisconnected = true; 

            _cts?.CancelAfter(TimeSpan.FromMilliseconds(100)); 
            
            if (_receiveLoopTask != null && !_receiveLoopTask.IsCompleted && !_receiveLoopTask.IsCanceled && !_receiveLoopTask.IsFaulted)
            {
               SafeConsoleLog("BrokerClientService: Waiting briefly for receive loop to complete during Dispose...");
               try { _receiveLoopTask.Wait(TimeSpan.FromMilliseconds(200)); } 
               catch { /* 무시 */ }
            }

            CleanupConnectionResourcesInternal(true); 

            _cts?.Dispose(); // 여기서도 확실히 정리
            _cts = null;
            
            SafeConsoleLog("BrokerClientService: Disposed.");
            GC.SuppressFinalize(this);
        }

        private void SafeConsoleLog(string message)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] {message}");
        }
    }
}