네, 좋습니다. 그럼 솔루션 SControlSuite의 첫 번째 프로젝트인 SControl.Common (클래스 라이브러리) 의 코드부터 제공해 드리겠습니다.

이 SControl.Common 라이브러리는 SControlM (제어 프로그램)과 SAgentM (에이전트) 모두에서 공유되어 사용될 핵심 데이터 구조와 유틸리티 함수들을 포함하게 됩니다.

SControl.Common 프로젝트 코드
1. Enums.cs

통신 및 동작에 사용될 주요 열거형들을 정의합니다.
<!-- end list -->

C#

// SControl.Common/Enums.cs
namespace SControl.Common
{
    /// <summary>
    /// 명령 패킷의 처리 방식을 정의합니다. SAgentM이 수신한 패킷을 어떻게 처리할지 결정합니다.
    /// </summary>
    public enum CommandInstruction
    {
        /// <summary>
        /// 명령을 현재 SAgentM에서 직접 실행합니다.
        /// </summary>
        DirectExecute,

        /// <summary>
        /// 명령을 지정된 다음 대상 SAgentM으로 중계(릴레이)합니다.
        /// </summary>
        RelayToTarget
    }

    /// <summary>
    /// 실행 또는 중계될 명령의 고유한 이름들을 정의하는 상수 클래스입니다.
    /// </summary>
    public static class CommandNames
    {
        /// <summary>
        /// 모니터 제어 관련 명령을 나타냅니다.
        /// </summary>
        public const string MonitorControl = "MONITOR_CONTROL";

        // --- 향후 확장 가능한 명령 이름 예시 ---
        // /// <summary>
        // /// 시스템 종료 관련 명령을 나타냅니다.
        // /// </summary>
        // public const string SystemShutdown = "SYSTEM_SHUTDOWN";
    }

    /// <summary>
    /// 모니터 제어 동작의 종류를 정의합니다. (Windows SC_MONITORPOWER 메시지 값 기준)
    /// </summary>
    public enum MonitorAction
    {
        /// <summary>
        /// 모니터를 켭니다 (SC_MONITORPOWER: -1).
        /// </summary>
        On = -1,

        /// <summary>
        /// 모니터를 절전 모드로 전환합니다 (SC_MONITORPOWER: 1).
        /// </summary>
        Standby = 1,

        /// <summary>
        /// 모니터를 끕니다 (SC_MONITORPOWER: 2).
        /// </summary>
        Off = 2
    }
}
2. Payloads.cs

각 명령어(CommandNames)에 대한 구체적인 데이터를 담는 클래스들을 정의합니다.
<!-- end list -->

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    /// <summary>
    /// 모니터 제어 명령(CommandNames.MonitorControl)을 위한 페이로드입니다.
    /// 어떤 모니터 동작을 수행할지 지정합니다.
    /// </summary>
    public class MonitorControlPayload
    {
        /// <summary>
        /// 수행할 모니터 동작 (On, Off, Standby) 입니다.
        /// </summary>
        public MonitorAction Action { get; set; }
    }

    // --- 다른 명령에 대한 페이로드 클래스 예시 (필요시 주석 해제 및 구체화) ---
    // /// <summary>
    // /// 시스템 종료 명령(CommandNames.SystemShutdown)을 위한 페이로드입니다.
    // /// </summary>
    // public class SystemShutdownPayload
    // {
    //     /// <summary>
    //     /// 종료 전 대기 시간(초)입니다. 0이면 즉시 종료를 의미합니다.
    //     /// </summary>
    //     public int DelaySeconds { get; set; }
    //
    //     /// <summary>
    //     /// 실행 중인 애플리케이션을 강제로 종료할지 여부입니다.
    //     /// </summary>
    //     public bool ForceShutdown { get; set; }
    // }
}
3. CommandPacket.cs

SControlM과 SAgentM 간에 주고받을 실제 통신 데이터 패킷의 구조를 정의합니다.
<!-- end list -->

C#

// SControl.Common/CommandPacket.cs
using System;

namespace SControl.Common
{
    /// <summary>
    /// SControlM과 SAgentM 간 통신에 사용될 기본 명령 패킷입니다.
    /// 이 패킷은 일반적으로 JSON 형태로 직렬화되어 소켓을 통해 전송됩니다.
    /// </summary>
    public class CommandPacket
    {
        /// <summary>
        /// 패킷의 고유 식별자입니다. 요청 추적, 로깅 등에 사용될 수 있습니다.
        /// </summary>
        public Guid PacketId { get; set; }

        /// <summary>
        /// 이 패킷을 수신한 SAgentM이 취해야 할 주된 행동(지시)입니다.
        /// </summary>
        public CommandInstruction Instruction { get; set; }

        /// <summary>
        /// 실행되거나 중계될 실제 명령의 이름입니다 (예: CommandNames.MonitorControl).
        /// 이 이름에 따라 PayloadJson의 내용을 적절한 페이로드 타입으로 역직렬화해야 합니다.
        /// </summary>
        public string CommandName { get; set; }

        /// <summary>
        /// CommandName에 해당하는 명령의 실제 인자(데이터)들을 JSON 문자열로 직렬화한 값입니다.
        /// 예: MonitorControlPayload 객체를 JSON으로 변환한 문자열.
        /// (System.Text.Json.JsonSerializer 사용 권장)
        /// </summary>
        public string? PayloadJson { get; set; } // 페이로드가 없는 명령도 있을 수 있으므로 nullable

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용됨]
        /// 이 명령 패킷(CommandName, PayloadJson)을 최종적으로 전달받아 실행할 SAgentM의 IP 주소입니다.
        /// 중계 SAgentM은 이 주소로 새로운 DirectExecute 패킷을 생성하여 전송합니다.
        /// </summary>
        public string? FinalTargetIpForRelayedCommand { get; set; }

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용됨]
        /// FinalTargetIpForRelayedCommand의 SAgentM 포트 번호입니다.
        /// </summary>
        public int? FinalTargetPortForRelayedCommand { get; set; }

        /// <summary>
        /// 이 패킷이 생성된 시간 (UTC 기준)입니다.
        /// 타임아웃 처리, 순서 보정 등에 활용될 수 있습니다.
        /// </summary>
        public DateTime TimestampUtc { get; set; }

        /// <summary>
        /// 응답을 기대하는 경우, SControlM 또는 요청 SAgentM의 IP 주소.
        /// (단방향 명령의 경우 null일 수 있음)
        /// </summary>
        public string? ResponseAddress { get; set; }

        /// <summary>
        /// 응답을 기대하는 경우, SControlM 또는 요청 SAgentM의 포트.
        /// (단방향 명령의 경우 null일 수 있음)
        /// </summary>
        public int? ResponsePort { get; set; }


        /// <summary>
        /// 기본 생성자. PacketId와 TimestampUtc를 자동으로 초기화합니다.
        /// </summary>
        public CommandPacket()
        {
            PacketId = Guid.NewGuid();
            TimestampUtc = DateTime.UtcNow;
        }
    }
}
CommandPacket.cs 변경점:

PayloadJson을 nullable (string?)로 변경했습니다. 페이로드가 없는 단순 명령(예: Ping)도 있을 수 있기 때문입니다.
ResponseAddress와 ResponsePort를 추가하여, 필요시 SAgentM이 SControlM (또는 다른 SAgentM)에게 응답을 보낼 수 있는 경로를 제공합니다. 이는 양방향 통신이나 상태 피드백에 유용합니다.
4. LocalDeviceControl.cs

P/Invoke를 사용하여 로컬 PC의 하드웨어(여기서는 모니터)를 제어하는 함수를 제공합니다.
<!-- end list -->

C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 사용

namespace SControl.Common
{
    /// <summary>
    /// P/Invoke를 사용하여 로컬 장치를 제어하는 유틸리티 클래스입니다.
    /// 현재는 모니터 전원 제어 기능을 제공합니다.
    /// </summary>
    public static class LocalDeviceControl
    {
        // Windows API 상수 정의
        private const int HWND_BROADCAST = 0xFFFF;    // 메시지를 모든 최상위 창에 브로드캐스트
        private const uint WM_SYSCOMMAND = 0x0112;    // 시스템 명령 메시지 ID
        private const uint SC_MONITORPOWER = 0xF170;  // 모니터 전원 관련 시스템 명령 ID

        // SC_MONITORPOWER의 lParam 값 (MonitorAction enum 값과 일치시킴)
        // private const int MONITOR_ON = -1;       // 모니터 켜기
        // private const int MONITOR_STANDBY = 1;   // 모니터 절전
        // private const int MONITOR_OFF = 2;       // 모니터 끄기

        // user32.dll의 SendMessageTimeout 함수 선언
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,                     // 메시지를 받을 창의 핸들. HWND_BROADCAST 사용 가능.
            uint Msg,                        // 보낼 메시지 (WM_SYSCOMMAND).
            UIntPtr wParam,                  // 메시지의 첫 번째 파라미터 (SC_MONITORPOWER).
            IntPtr lParam,                   // 메시지의 두 번째 파라미터 (모니터 상태 코드). MonitorAction enum 값을 IntPtr로 변환하여 사용.
            SendMessageTimeoutFlags fuFlags, // 메시지 전송 방법 플래그.
            uint uTimeout,                   // 타임아웃 시간 (밀리초).
            out UIntPtr lpdwResult);         // 메시지 처리 결과 (거의 사용되지 않음).

        /// <summary>
        /// SendMessageTimeout 함수의 동작 방식을 지정하는 플래그입니다.
        /// </summary>
        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,            // 기본 동작.
            SMTO_BLOCK = 0x1,             // 호출 스레드는 메시지 처리 완료까지 대기.
            SMTO_ABORTIFHUNG = 0x2,       // 대상 프로세스가 응답하지 않으면 타임아웃 후 즉시 반환.
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8, // 대상이 응답 중이면 타임아웃 적용 안 함 (주의해서 사용).
            SMTO_ERRORONEXIT = 0x20       // (Windows Vista 이상) 함수가 반환되기 전에 발생한 오류를 GetLastError로 확인 가능하게 함.
        }

        /// <summary>
        /// 로컬 PC의 모니터 전원 상태를 변경합니다.
        /// </summary>
        /// <param name="action">수행할 모니터 동작 (On, Off, Standby).</param>
        /// <exception cref="Win32Exception">Windows API 호출 실패 시 발생합니다.</exception>
        /// <exception cref="ArgumentOutOfRangeException">제공된 action이 유효하지 않을 때 발생합니다.</exception>
        public static void SetMonitorState(MonitorAction action)
        {
            // MonitorAction enum 값이 SC_MONITORPOWER의 lParam으로 직접 사용됨.
            // enum의 기본 타입이 int이므로 IntPtr로 캐스팅 가능.
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }

            IntPtr lParam = (IntPtr)action;
            UIntPtr commandResult; // SendMessageTimeout의 결과는 크게 중요하지 않음.

            // SendMessageTimeout 호출
            // SMTO_ABORTIFHUNG 플래그를 사용하면 응답 없는 창에 대해 빠르게 타임아웃 처리 가능.
            IntPtr apiResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,
                WM_SYSCOMMAND,
                (UIntPtr)SC_MONITORPOWER,
                lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, // 1초 타임아웃
                out commandResult);

            if (apiResult == IntPtr.Zero) // API 호출 자체에 실패했거나 타임아웃 발생
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0) // 0이 아니면 오류 발생
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (코:{action}). Win32 오류 코드: {errorCode}");
                }
                // errorCode가 0인데 apiResult가 IntPtr.Zero인 경우는 타임아웃일 가능성이 높음 (SMTO_ABORTIFHUNG)
                // 또는 메시지를 처리할 창이 없는 경우 등. 이 경우도 실패로 간주할 수 있음.
                // 여기서는 명시적 오류 코드가 없으면 일단 경고만 남기거나, 상황에 따라 예외를 던질 수 있습니다.
                // System.Diagnostics.Debug.WriteLine($"SetMonitorState: SendMessageTimeout may have timed out for action {action}, but no explicit error code.");
            }
            // API 호출이 성공적으로 '전송'되었다고 해서 모니터가 즉시 반응한다는 보장은 없음.
            // 이 함수는 명령을 시스템에 전달하는 역할.
        }
    }
}
LocalDeviceControl.cs 변경점:

MonitorAction enum의 값을 P/Invoke 호출 시 lParam으로 직접 사용하도록 변경하고, lParam의 타입을 IntPtr로 유지했습니다. 이렇게 하면 enum 정의와 실제 Windows API 값이 일치하게 됩니다.
SendMessageTimeout 호출 후 Marshal.GetLastWin32Error()를 통해 오류 코드를 확인하고, 오류 발생 시 Win32Exception을 발생시켜 호출 측에서 오류를 인지하고 처리할 수 있도록 개선했습니다. SMTO_ERRORONEXIT 플래그도 추가했습니다.
apiResult == IntPtr.Zero 일 때, errorCode가 0인 경우 (주로 타임아웃)에 대한 주석을 추가했습니다.
여기까지가 SControl.Common 라이브러리의 핵심 코드입니다. 이 코드들은 SControlM과 SAgentM 프로젝트에서 공통으로 사용될 기반이 됩니다.