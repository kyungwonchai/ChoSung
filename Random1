래는 모든 반환값을 OK로 초기화한 후 각 조건에 따라 값을 변경하는 구조로 구현한 코드입니다. 이 방식은 함수가 많아질 경우에도 확장성이 높고, 조건 스위칭에도 대응할 수 있도록 설계되었습니다.

코드 구현
csharp
코드 복사
private async Task<string> ProcessMESOI(string val)
{
    // 모든 결과를 OK로 초기화
    string magnoResult = "OK";
    string forceSaveResult = "OK";

    // SendtoMergeOI_MAGNO 실행
    string tempMagnoResult = await SendtoMergeOI_MAGNO(val);
    if (tempMagnoResult != "OK")
    {
        magnoResult = $"NG: SendtoMergeOI_MAGNO ({tempMagnoResult})";
    }

    // SendtoMergeOI_ForceSave 실행
    string tempForceSaveResult = await SendtoMergeOI_ForceSave(val);
    if (tempForceSaveResult != "OK")
    {
        forceSaveResult = $"NG: SendtoMergeOI_ForceSave ({tempForceSaveResult})";
    }

    // 최종 결과 결정
    if (magnoResult == "OK" && forceSaveResult == "OK")
    {
        return "OK"; // 모든 결과가 OK인 경우
    }
    else
    {
        // NG가 발생한 함수와 결과를 반환
        return $"{magnoResult} {forceSaveResult}".Trim();
    }
}

// 예제 함수: SendtoMergeOI_MAGNO
private async Task<string> SendtoMergeOI_MAGNO(string val)
{
    // 실제 로직 대신 샘플 코드
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "MAGNO" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

// 예제 함수: SendtoMergeOI_ForceSave
private async Task<string> SendtoMergeOI_ForceSave(string val)
{
    // 실제 로직 대신 샘플 코드
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "ForceSave" ? "OK" : "MG"; // 조건에 따라 결과 반환
}
확장 가능한 구조
위 코드를 기반으로, 추가적인 함수를 쉽게 추가할 수 있습니다. 예를 들어 SendtoMergeOI_NewFunction 같은 새로운 비즈니스 로직 함수가 추가된다면 다음과 같이 처리합니다.

csharp
코드 복사
// 새로운 함수 추가
private async Task<string> SendtoMergeOI_NewFunction(string val)
{
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "NewValue" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

// ProcessMESOI 확장
private async Task<string> ProcessMESOI(string val)
{
    string magnoResult = "OK";
    string forceSaveResult = "OK";
    string newFunctionResult = "OK";

    // 기존 함수 실행
    string tempMagnoResult = await SendtoMergeOI_MAGNO(val);
    if (tempMagnoResult != "OK")
    {
        magnoResult = $"NG: SendtoMergeOI_MAGNO ({tempMagnoResult})";
    }

    string tempForceSaveResult = await SendtoMergeOI_ForceSave(val);
    if (tempForceSaveResult != "OK")
    {
        forceSaveResult = $"NG: SendtoMergeOI_ForceSave ({tempForceSaveResult})";
    }

    // 새로운 함수 실행
    string tempNewFunctionResult = await SendtoMergeOI_NewFunction(val);
    if (tempNewFunctionResult != "OK")
    {
        newFunctionResult = $"NG: SendtoMergeOI_NewFunction ({tempNewFunctionResult})";
    }

    // 최종 결과 결정
    if (magnoResult == "OK" && forceSaveResult == "OK" && newFunctionResult == "OK")
    {
        return "OK"; // 모든 결과가 OK인 경우
    }
    else
    {
        // NG가 발생한 함수와 결과를 반환
        return $"{magnoResult} {forceSaveResult} {newFunctionResult}".Trim();
    }
}
주요 동작 설명
초기화:

모든 결과 변수를 "OK"로 초기화하여 기본값으로 설정합니다.
조건 처리:

각 함수의 결과를 임시 변수에 담아 확인하고, 조건에 따라 결과 값을 업데이트합니다.
확장성:

새로운 함수를 추가해도 기존 구조를 그대로 유지하며 쉽게 확장할 수 있습니다.
최종 결과 조합:

모든 결과가 OK일 경우 최종적으로 "OK"를 반환하며, 하나라도 NG가 있으면 해당 내용을 포함한 결과를 반환합니다.
결과 예제
예제 1: 모든 함수 정상
csharp
코드 복사
string result = await ProcessMESOI("MAGNO");
/* 결과:
"OK"
*/
예제 2: SendtoMergeOI_MAGNO 실패
csharp
코드 복사
string result = await ProcessMESOI("INVALID");
/* 결과:
"NG: SendtoMergeOI_MAGNO (MG)"
*/
예제 3: 두 함수 모두 실패
csharp
코드 복사
string result = await ProcessMESOI("INVALID_ALL");
/* 결과:
"NG: SendtoMergeOI_MAGNO (MG) NG: SendtoMergeOI_ForceSave (MG)"