라 로그를 효율적으로 분기하여 각 UI 요소에 반영되도록 코드를 작성하겠습니다.

1. LogItem 구조체
이 부분은 변동이 없습니다. LogItem은 로그 데이터를 담는 구조체입니다.

csharp
코드 복사
public struct LogItem
{
    public DateTime Timestamp { get; set; }
    public string Message { get; set; }
    public string LogType { get; set; }

    public LogItem(DateTime timestamp, string message, string logType)
    {
        Timestamp = timestamp;
        Message = message;
        LogType = logType;
    }
}
2. LogHelper 클래스
LogHelper는 사용자가 AddLog를 호출하면 로그를 해당 타입에 맞게 분기하여 처리하고, 필요한 UI에 이벤트로 전달합니다.

csharp
코드 복사
using System;
using System.IO;

public class LogHelper
{
    private static LogHelper _instance;
    private static readonly string logFilePath = "logfile.txt";  // 로그 파일 경로

    private LogHelper() 
    {
        if (!File.Exists(logFilePath))
        {
            using (var sw = File.CreateText(logFilePath))
            {
                sw.WriteLine("===== Log Started =====");
            }
        }
    }

    public static LogHelper Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new LogHelper();
            }
            return _instance;
        }
    }

    // 각각의 로그 타입별로 이벤트 정의
    public event EventHandler<LogItem> InfoLogGenerated;
    public event EventHandler<LogItem> ErrorLogGenerated;
    public event EventHandler<LogItem> WarningLogGenerated;

    // 로그를 파일에 기록하는 메서드
    private void LogToFile(LogItem logItem)
    {
        using (StreamWriter sw = File.AppendText(logFilePath))
        {
            sw.WriteLine($"{logItem.Timestamp:yyyy-MM-dd HH:mm:ss} [{logItem.LogType}] {logItem.Message}");
        }
    }

    // 새로운 로그 추가 메서드
    public void AddLog(string message, string logType)
    {
        // LogItem 생성
        var logItem = new LogItem(DateTime.Now, message, logType);

        // 파일에 로그 기록
        LogToFile(logItem);

        // 로그 타입에 따라 이벤트 발생
        switch (logType.ToLower())
        {
            case "info":
                OnInfoLogGenerated(logItem);  // Info 로그를 위한 이벤트 발생
                break;
            case "error":
                OnErrorLogGenerated(logItem);  // Error 로그를 위한 이벤트 발생
                break;
            case "warning":
                OnWarningLogGenerated(logItem);  // Warning 로그를 위한 이벤트 발생
                break;
        }
    }

    // 이벤트 발생 함수들
    protected virtual void OnInfoLogGenerated(LogItem logItem)
    {
        InfoLogGenerated?.Invoke(this, logItem);
    }

    protected virtual void OnErrorLogGenerated(LogItem logItem)
    {
        ErrorLogGenerated?.Invoke(this, logItem);
    }

    protected virtual void OnWarningLogGenerated(LogItem logItem)
    {
        WarningLogGenerated?.Invoke(this, logItem);
    }
}
3. MainViewModel 클래스
여기서는 **각 로그 타입에 따른 ObservableCollection**을 분리하고, DataGrid나 ListBox에 각각의 로그 타입만 바인딩합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;

public class MainViewModel : INotifyPropertyChanged
{
    private const int MaxLogCount = 50;

    // 로그 타입별로 별도의 ObservableCollection 정의
    public ObservableCollection<LogItem> InfoLogs { get; set; }
    public ObservableCollection<LogItem> ErrorLogs { get; set; }
    public ObservableCollection<LogItem> WarningLogs { get; set; }

    public MainViewModel()
    {
        // 각 로그 컬렉션 초기화
        InfoLogs = new ObservableCollection<LogItem>();
        ErrorLogs = new ObservableCollection<LogItem>();
        WarningLogs = new ObservableCollection<LogItem>();

        // LogHelper 이벤트 구독
        LogHelper.Instance.InfoLogGenerated += OnInfoLogGenerated;
        LogHelper.Instance.ErrorLogGenerated += OnErrorLogGenerated;
        LogHelper.Instance.WarningLogGenerated += OnWarningLogGenerated;
    }

    // 50개 이상 로그가 쌓이면 첫 번째 항목 삭제하는 로직
    private void AddLogItem(ObservableCollection<LogItem> logCollection, LogItem logItem)
    {
        if (logCollection.Count >= MaxLogCount)
        {
            logCollection.RemoveAt(0);  // 첫 번째 항목 삭제
        }
        logCollection.Add(logItem);  // 새로운 로그 추가
    }

    // 각각의 이벤트 핸들러
    private void OnInfoLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(InfoLogs, logItem);  // Info 로그만 처리
    }

    private void OnErrorLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(ErrorLogs, logItem);  // Error 로그만 처리
    }

    private void OnWarningLogGenerated(object sender, LogItem logItem)
    {
        AddLogItem(WarningLogs, logItem);  // Warning 로그만 처리
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
4. MainWindow.xaml (UI: DataGrid 및 ListBox 구성)
여러 UI 요소(DataGrid 및 ListBox)에서 각각의 로그 타입만을 표시하도록 설정합니다.

xml
코드 복사
<Window x:Class="LogApplication.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Log Viewer" Height="600" Width="800">
    <Grid>
        <StackPanel>
            <!-- Info 로그를 위한 DataGrid -->
            <TextBlock Text="Info Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <DataGrid ItemsSource="{Binding InfoLogs}" AutoGenerateColumns="False" CanUserAddRows="False" 
                      IsReadOnly="True" Height="150" Margin="5">
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="*"/>
                    <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*"/>
                    <DataGridTextColumn Header="Log Type" Binding="{Binding LogType}" Width="*"/>
                </DataGrid.Columns>
            </DataGrid>

            <!-- Error 로그를 위한 ListBox -->
            <TextBlock Text="Error Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <ListBox ItemsSource="{Binding ErrorLogs}" Height="150" Margin="5">
                <ListBox.ItemTemplate>
                    <DataTemplate>
                        <StackPanel>
                            <TextBlock Text="{Binding Timestamp}" FontWeight="Bold"/>
                            <TextBlock Text="{Binding Message}"/>
                            <TextBlock Text="{Binding LogType}" FontStyle="Italic"/>
                        </StackPanel>
                    </DataTemplate>
                </ListBox.ItemTemplate>
            </ListBox>

            <!-- Warning 로그를 위한 DataGrid -->
            <TextBlock Text="Warning Logs" FontWeight="Bold" FontSize="14" Margin="5"/>
            <DataGrid ItemsSource="{Binding WarningLogs}" AutoGenerateColumns="False" CanUserAddRows="False" 
                      IsReadOnly="True" Height="150" Margin="5">
                <DataGrid.Columns>
                    <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="*"/>
                    <DataGridTextColumn Header="Message" Binding="{Binding Message}" Width="*"/>
                    <DataGridTextColumn Header="Log Type" Binding="{Binding LogType}" Width="*"/>
                </DataGrid.Columns>
            </DataGrid>
        </StackPanel>
    </Grid>
</Window>
설명:
DataGrid와 ListBox 각각에 로그 타입별로 바인딩: InfoLogs, ErrorLogs, WarningLogs 각각을 바인딩하여, UI에서 로그를 타입별로 분리해 표시합니다.
5. MainWindow.xaml.cs (로그 추가)
여기서는 LogHelper를 통해 다양한 로그를 추가하는 방식입니다.

csharp
코드 복사
using System.Windows;

namespace LogApplication
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // MainViewModel을 DataContext로 설정
            this.DataContext = new MainViewModel();

            // 로그 추가
            LogHelper.Instance.AddLog("시스템이 정상적으로 시작되었습니다.", "Info");
            LogHelper.Instance.AddLog("파일을 찾을 수 없습니다.", "Error");
            LogHelper.Instance.AddLog("디스크 공간이 부족합니다.", "Warning");
        }
    }
}
6. 전체 흐름 요약
LogHelper 클래스에서 로그가 추가될 때, 각 로그 타입에 따라 이벤트가 분기됩니다. (Info, Error, Warning)

MainViewModel 클래스는 각 로그 타입별로 별도의 ObservableCollection(InfoLogs, ErrorLogs, WarningLogs)을 관리하고, 이벤트가 발생할 때 해당 컬렉션에 로그를 추가합니다.

UI (XAML): 각 DataGrid 및 ListBox는 로그 타입별로 분리된 컬렉션에 바인딩되어, 각각의 로그 타입에 해당하는 항목만 표시합니다.

MainWindow.xaml.cs: LogHelper를 통해 로그를 추가할 때, 로그의 타입에 따라 각각 다른 UI 요소로 분기됩니다.

이제 여러 개의 UI 컨트롤(DataGrid, ListBox 등)에