죄송합니다. 말씀하신 대로, Resume 시 특정 행부터 작업을 다시 시작하도록 기능을 수정하겠습니다. 또한, 작업 리스트에서 내가 선택한 행부터 다시 작업이 시작되고, 그 이후 작업들이 순차적으로 대기 상태로 들어가도록 구현하겠습니다.

수정해야 할 부분:
Resume 작업을 내가 지정한 행부터 다시 시작하도록 수정.
해당 행 이후의 작업들은 모두 대기 상태로 변경.
Resume 시 파일 감지 멈추고, 작업이 완료되면 파일 감지를 다시 시작.
MainViewModel.cs (Resume 시 선택한 작업부터 실행)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel이다.
/// 로그 파일을 감지하고, 작업 큐에 작업을 추가하며, 작업이 완료되면 다음 작업을 자동으로 실행한다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection (UI에서 표시될 작업 목록)
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 선택한 작업의 인덱스를 저장하는 프로퍼티
    private TaskModel _selectedTask;
    public TaskModel SelectedTask
    {
        get => _selectedTask;
        set
        {
            _selectedTask = value;
            OnPropertyChanged(nameof(SelectedTask));
        }
    }

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 선택한 작업부터 재개
    public ICommand ResumeSelectedCommand { get; }

    public MainViewModel()
    {
        // TaskList는 UI에서 데이터 바인딩될 ObservableCollection (실시간 변경 반영)
        TaskList = new ObservableCollection<TaskModel>();

        // TaskQueue를 초기화 (작업을 관리하는 큐)
        _taskQueue = new TaskQueue();

        // 파일 감지기를 초기화하고, 새 파일이 감지되었을 때 작업을 추가
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 모든 작업을 일시정지하는 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);

        // 선택한 작업부터 재개하는 명령어 설정
        ResumeSelectedCommand = new RelayCommand(ResumeSelectedTask);
    }

    /// <summary>
    /// 로그 파일이 감지되었을 때 호출된다.
    /// LogEntry 데이터를 기반으로 새로운 TaskModel을 생성하고, 작업 큐에 추가한다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            // TaskModel을 생성하고, 작업 큐에 추가
            var task = new TaskModel(logEntry, _taskQueue);

            // 작업이 완료되면 다음 작업을 실행하도록 설정
            task.StartNextTask = StartNextTask;

            // 작업 목록에 추가 (UI에 표시됨)
            TaskList.Add(task);

            // 작업 큐가 실행 중이 아니면 즉시 작업 실행
            if (!_taskQueue.IsRunning)
            {
                task.StartTask();
            }
        });
    }

    /// <summary>
    /// 현재 작업이 완료되면 다음 작업을 실행하는 메서드.
    /// </summary>
    /// <param name="currentTask">완료된 TaskModel</param>
    private void StartNextTask(TaskModel currentTask)
    {
        // 현재 작업의 인덱스를 찾고, 그 다음 작업이 존재하면 실행
        int currentIndex = TaskList.IndexOf(currentTask);
        if (currentIndex + 1 < TaskList.Count)
        {
            var nextTask = TaskList[currentIndex + 1];
            nextTask.StartTask(); // 다음 작업 실행
        }

        // 작업이 완료되면 최대 18개의 작업만 남기고 이전 작업 삭제
        if (TaskList.Count > 18)
        {
            TaskList.RemoveAt(0); // 가장 오래된 작업 삭제
        }
    }

    /// <summary>
    /// 모든 작업을 일시정지하는 메서드.
    /// TaskQueue의 Pause 메서드를 호출하며, 파일 감지도 멈춘다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause(); // 작업 큐를 일시정지
        _fileProcessor.StopProcessing(); // 파일 감지 멈춤
    }

    /// <summary>
    /// 선택한 작업부터 작업을 재개하는 메서드.
    /// 해당 작업부터 이후의 모든 작업을 대기 상태로 만들고 다시 시작.
    /// </summary>
    private void ResumeSelectedTask()
    {
        if (SelectedTask != null)
        {
            // 선택한 작업의 인덱스 이후 작업들을 리셋하고 대기 상태로 전환
            int startIndex = TaskList.IndexOf(SelectedTask);

            for (int i = startIndex; i < TaskList.Count; i++)
            {
                var task = TaskList[i];
                task.ResetTask(); // 작업을 리셋하고 다시 대기 상태로 전환

                // 선택한 작업부터 다시 시작
                if (i == startIndex)
                {
                    task.StartTask();
                }
            }

            _taskQueue.Resume(); // 작업 큐를 재개
            _fileProcessor.StartProcessing(); // 파일 감지 다시 시작
        }
        else
        {
            MessageBox.Show("먼저 시작할 작업을 선택해주세요."); // 선택이 없을 때 알림
        }
    }
}
주요 수정 사항:
ResumeSelectedTask():

선택한 작업부터 그 이후 모든 작업을 리셋하고 대기 상태로 만듭니다.
선택된 작업부터 다시 시작합니다.
파일 감지는 재개될 때 함께 다시 시작됩니다.
SelectedTask 프로퍼티:

사용자가 선택한 작업을 추적합니다. 이 작업이 재개될 작업입니다.
TaskModel.cs (작업 리셋 및 상태 전환)
csharp
코드 복사
using System.Threading.Tasks;

public class TaskModel : ViewModelBase
{
    public string Status { get; set; }
    private TaskQueue _taskQueue;

    public Action<TaskModel> StartNextTask { get; set; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        _taskQueue = taskQueue;
        Status = "Pending"; // 기본 상태는 대기
    }

    /// <summary>
    /// 작업을 시작하는 메서드.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 추가
    }

    /// <summary>
    /// 작업을 리셋하고 다시 대기 상태로 만든다.
    /// </summary>
    public void ResetTask()
    {
        Status = "Pending"; // 작업 상태를 대기 상태로 초기화
    }

    private async Task ExecuteTaskSequence()
    {
        // 비동기 작업 로직 (실제 작업 처리)
        await Task.Delay(1000); // 작업이 1초간 실행되는 시뮬레이션

        // 작업 완료 처리
        Status = "Completed";
        StartNextTask?.Invoke(this); // 다음 작업 실행
    }
}
주요 수정 사항:
ResetTask():

작업을 대기 상태로 리셋하는 메서드입니다. 선택한 작업부터 리셋된 상태로 다시 대기하게 만듭니다.
StartTask():

작업이 다시 Running 상태로 변하며 큐에 작업을 추가해 재실행됩니다.
TaskQueue.cs (변경 없음, Resume 로직)
이전에 제공했던 TaskQueue.cs는 그대로 사용됩니다. **Pause()**와 Resume() 로직을 사용하여 작업이 일시정지되고, 다시 재개됩니다.

이제 이 구조에서는 선택한 작업부터 작업을 다시 시작하고, 그 이후의 작업들은 모두 대기 상태로 들어가게 됩니다. 또한, 파일 감지도 함께 멈추었다가 재개됩니다