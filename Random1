
import React from 'react';
import CodeBlock from './CodeBlock';
import PdfDownloadButton from './PdfDownloadButton';

const nodeInstallCode = `
# 1. nvm(Node Version Manager) 설치 스크립트 다운로드 및 실행
curl -o- https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash

# 2. 터미널 재시작 또는 아래 명령 실행으로 nvm 환경 변수 로드
export NVM_DIR="$HOME/.nvm"
[ -s "$NVM_DIR/nvm.sh" ] && \\. "$NVM_DIR/nvm.sh"

# 3. 최신 LTS 버전의 Node.js 설치
nvm install --lts

# 4. 설치 확인 (버전 정보 출력)
node -v
npm -v
`;

const projectSetupCode = `
# 1. 프로젝트 폴더 생성 및 이동
mkdir maskrack-api-server
cd maskrack-api-server

# 2. npm 프로젝트 초기화
npm init -y

# 3. Express 라이브러리 설치
npm install express
`;

const serverJsCode = `
const express = require('express');
const net = require('net');

const app = express();
const API_PORT = process.env.API_PORT || 3000;

app.use(express.json());

// --- 바코드와 물리적 위치 정보 매핑 ---
// 실제 시스템에서는 이 정보를 DB 또는 설정 파일에서 관리합니다.
// key: 바코드, value: { 컨트롤러 IP, 포트, RS485 주소, 랙 ID, 레벨, 슬롯 }
const barcodeLocationMap = new Map([
    ['MMF10A01A01', { ip: '192.168.0.101', port: 8888, rs485Addr: 1, rack: 'A01', level: 'A', slot: 1 }],
    ['MMF10A01B11', { ip: '192.168.0.101', port: 8888, rs485Addr: 1, rack: 'A01', level: 'B', slot: 11 }],
    ['MMF10B14C12', { ip: '192.168.0.114', port: 8888, rs485Addr: 14, rack: 'B14', level: 'C', slot: 12 }],
    // 로컬 테스트용 (테스트 가이드 참고)
    ['MMF10TEST01', { ip: '127.0.0.1', port: 8888, rs485Addr: 99, rack: 'T01', level: 'A', slot: 1 }],
]);

/**
 * 바코드 위치 정보를 RS485 제어 명령어로 변환합니다.
 * @param {object} location - { rs485Addr, level, slot }
 * @returns {string} - 아두이노로 전송할 명령어. e.g., "<1,22>"
 */
function convertToCommand(location) {
    const levelBase = { 'A': 0, 'B': 12, 'C': 24 }[location.level];
    const ledIndex = levelBase + (location.slot - 1);
    // <RS485주소, LED인덱스> 형식
    return '<' + location.rs485Addr + ',' + ledIndex + '>';
}

// MES로부터 바코드 위치 조회 요청을 받는 API 엔드포인트
app.post('/api/v1/locate', (req, res) => {
    const { barcode } = req.body;

    if (!barcode) {
        return res.status(400).json({ error: 'Barcode is required' });
    }
    
    console.log('[HTTP-RECV] ' + new Date().toISOString() + ' | Barcode request: ' + barcode);
    const location = barcodeLocationMap.get(barcode.toUpperCase());

    if (!location) {
        console.warn('[WARN] Barcode not found in map: ' + barcode);
        // 바코드가 없어도 요청은 정상 처리되었음을 알림
        return res.status(202).json({ status: 'Request accepted, but barcode not found.' });
    }
    
    // MES에 즉시 응답 (Fire-and-Forget)
    res.status(202).json({ status: 'Request accepted, processing command.', location });

    // 백그라운드에서 아두이노에 TCP 명령 전송
    sendTcpCommand(location);
});

// 아두이노 컨트롤러에 TCP 소켓으로 명령어를 전송하는 함수
function sendTcpCommand(location) {
    const command = convertToCommand(location);
    const client = new net.Socket();

    client.connect(location.port, location.ip, () => {
        console.log('[TCP-SEND] Connected to Arduino at ' + location.ip + ':' + location.port);
        client.write(command);
    });

    client.on('data', (data) => {
        console.log('[TCP-RECV] Received from Arduino: ' + data);
        client.destroy(); // 데이터 수신 후 연결 종료
    });

    client.on('close', () => {
        console.log('[TCP-SEND] Connection closed.');
    });

    client.on('error', (err) => {
        console.error('[TCP-ERROR] Could not connect to Arduino: ' + err.message);
    });
}

app.listen(API_PORT, () => {
    console.log('MaskRack API Server listening on port ' + API_PORT);
});
`;

const pm2InstallCode = `npm install pm2 -g`;
const pm2StartCode = `pm2 start server.js --name "maskrack-api"`;
const pm2ManageCode = `
# 실행 중인 프로세스 목록 확인
pm2 list

# 실시간 로그 확인 (Ctrl+C로 빠져나옴)
pm2 logs maskrack-api

# 프로세스 중지
pm2 stop maskrack-api

# 프로세스 재시작
pm2 restart maskrack-api

# 프로세스 목록에서 제거
pm2 delete maskrack-api
`;
const pm2StartupCode = `
# 현재 프로세스 목록을 기반으로 부팅 시 실행 스크립트를 생성
pm2 startup

# 위 명령을 실행하면 현재 OS에 맞는 스크립트 실행 명령이 화면에 나타납니다.
# (예: sudo env PATH=$PATH:/home/user/.nvm/versions/node/vXX.X.X/bin ...)
# 화면에 나타난 명령을 복사하여 실행합니다.

# 현재 실행 중인 프로세스 목록을 저장하여, 재부팅 후 pm2가 복원할 수 있도록 합니다.
pm2 save
`;

const APIServerSetupGuide: React.FC = () => {
    const viewId = 'api-server-setup-guide-view';
    const fileName = "API_Server_Setup_Guide.pdf";

    return (
        <div id={viewId} className="text-gray-300 leading-relaxed">
            <div className="flex justify-between items-start mb-2">
                <div>
                    <h1 className="text-3xl font-bold text-white mb-2">API 서버 구축 가이드 (Ubuntu + Arduino 연동)</h1>
                    <p className="text-lg text-orange-400 mb-6">
                        Node.js 개발 환경 설정부터 유선랜으로 연결된 아두이노와 TCP/IP 소켓 통신을 하는 API 서버 구축 과정을 안내합니다.
                    </p>
                </div>
                <PdfDownloadButton viewId={viewId} fileName={fileName} />
            </div>

            <div className="space-y-12">
                <section>
                    <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">1단계: Node.js 개발 환경 설정</h2>
                    <p>nvm(Node Version Manager)을 사용하여 최신 LTS 버전의 Node.js를 설치합니다. nvm을 사용하면 권한 문제 없이 버전을 쉽게 관리할 수 있습니다.</p>
                    <CodeBlock code={nodeInstallCode} language="bash" />
                </section>

                <section>
                    <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">2단계: 프로젝트 생성 및 라이브러리 설치</h2>
                    <p>API 서버를 위한 프로젝트 폴더를 만들고, 웹 서버(Express) 라이브러리를 설치합니다.</p>
                    <CodeBlock code={projectSetupCode} language="bash" />
                </section>
                
                <section>
                    <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">3단계: API 서버 코드 작성</h2>
                    <p>프로젝트 폴더 안에 <code className="bg-gray-700 px-1 rounded">server.js</code> 파일을 생성하고 아래의 전체 코드를 붙여넣습니다. 이 코드는 아두이노 컨트롤러의 IP와 포트로 직접 TCP 소켓 통신을 수행합니다.</p>
                    <CodeBlock code={serverJsCode} language="javascript" />
                    <div className="bg-yellow-900/50 border border-yellow-700 text-yellow-200 p-4 rounded-lg mt-4">
                        <strong className="font-bold">중요:</strong> 코드 상단의 <code className="bg-gray-700 px-1 rounded">barcodeLocationMap</code>에 실제 아두이노 컨트롤러들의 **고정 IP 주소와 포트, RS485 주소**를 정확하게 입력해야 합니다.
                    </div>
                </section>
                
                <section>
                    <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">4단계: 서버 실행 (테스트용)</h2>
                    <p>터미널에서 아래 명령으로 서버를 실행합니다. "MaskRack API Server listening on port 3000" 메시지가 출력되면 정상적으로 실행된 것입니다. 이 방식은 개발 및 테스트에 적합합니다.</p>
                    <CodeBlock code={`node server.js`} language="bash" />
                </section>

                <section>
                    <h2 className="text-2xl font-semibold text-white border-b-2 border-orange-500 pb-3 mb-6">5단계: 프로세스 매니저(PM2)를 이용한 서비스 배포</h2>
                    <p><code className="bg-gray-700 px-1 rounded">node server.js</code>로 직접 실행하는 방식은 개발 중에는 편리하지만, 터미널 세션이 종료되면 서버도 함께 중단됩니다. 실제 운영 환경에서는 예기치 않은 오류로 서버가 종료되거나, 시스템이 재부팅되었을 때 자동으로 서버를 재시작해주는 프로세스 매니저가 필수적입니다.</p>
                    <p className="mt-2">PM2는 Node.js 애플리케이션을 위한 가장 인기있는 프로세스 매니저이며, 다음과 같은 주요 기능을 제공합니다:</p>
                     <ul className="list-disc list-inside mt-2 space-y-1 bg-gray-800/50 p-4 rounded-md">
                        <li>백그라운드 실행 및 프로세스 모니터링</li>
                        <li>오류 발생 시 자동 재시작</li>
                        <li>서버 재부팅 시 자동 실행</li>
                        <li>클러스터 모드를 통한 성능 향상</li>
                        <li>로그 관리</li>
                    </ul>

                    <h3 className="text-xl font-semibold text-white mt-6 mb-2">PM2 설치</h3>
                    <CodeBlock code={pm2InstallCode} language="bash" />

                    <h3 className="text-xl font-semibold text-white mt-6 mb-2">PM2로 서버 시작</h3>
                    <p>아래 명령어로 서버를 시작합니다. <code className="bg-gray-700 px-1 rounded">--name</code> 옵션으로 프로세스에 식별하기 쉬운 이름을 부여하면 관리가 용이합니다.</p>
                    <CodeBlock code={pm2StartCode} language="bash" />

                    <h3 className="text-xl font-semibold text-white mt-6 mb-2">주요 관리 명령어</h3>
                    <p>자주 사용되는 PM2 명령어입니다. 서버 상태를 확인하고 관리하는 데 사용됩니다.</p>
                    <CodeBlock code={pm2ManageCode} language="bash" />

                    <h3 className="text-xl font-semibold text-white mt-6 mb-2">시스템 재부팅 시 자동 실행 설정</h3>
                    <p>시스템이 재부팅되어도 API 서버가 자동으로 실행되도록 설정합니다.</p>
                    <CodeBlock code={pm2StartupCode} language="bash" />
                     <div className="bg-blue-900/50 border border-blue-700 text-blue-200 p-4 rounded-lg mt-4">
                        <strong className="font-bold">중요:</strong> <code className="bg-gray-700 px-1 rounded">pm2 startup</code> 명령 실행 후 화면에 나타나는 가이드라인(보통 <code className="bg-gray-700 px-1 rounded">sudo</code>로 시작하는 긴 명령)을 반드시 복사하여 실행해야 설정이 완료됩니다. 그 후에 <code className="bg-gray-700 px-1 rounded">pm2 save</code>를 실행하여 현재 프로세스 목록을 저장하세요.
                    </div>
                </section>

                <section>
                    <h2 className="text-2xl font-semibold text-white border-b border-gray-600 pb-2 mb-4">6단계: 테스트 및 검증</h2>
                    <p>서버가 올바르게 동작하는지, 아두이노와 정상적으로 통신하는지 확인하는 과정은 <strong className="text-cyan-400">"테스트 및 검증 가이드"</strong> 문서를 참고하여 진행하십시오.</p>
                    <p className="mt-4">이제 PM2를 통해 서버가 안정적으로 운영되므로, 다음 단계인 통합 테스트를 진행할 준비가 되었습니다.</p>
                </section>
            </div>
        </div>
    );
};

export default APIServerSetupGuide;
