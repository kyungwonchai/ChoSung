네, 이해했습니다. 모니터가 잠금 화면 등으로 꺼진 상태에서 "모니터 켜기" 명령을 보냈을 때, SC_MONITORPOWER만으로는 화면이 지속적으로 켜지지 않는 문제를 해결하기 위해, SendInput API를 사용하여 마우스를 아주 미세하게 움직여서 시스템에 실제 사용자 활동이 있는 것처럼 인식시켜 모니터를 확실하게 깨우는 기능을 추가하겠습니다.

다음 두 개의 C# 파일을 수정해야 합니다:

SControl.Common/LocalDeviceControl.cs (수정): SendInput P/Invoke 선언 및 관련 구조체를 추가하고, 마우스 미세 이동을 위한 새로운 메서드를 만듭니다.
SAgentM.App/Services/AgentCoreService.cs (수정): MonitorControl 명령으로 "모니터 켜기"(MonitorAction.On)가 요청되었을 때, 기존의 SetMonitorState(MonitorAction.On) 호출 이후에 새로 추가된 마우스 이동 시뮬레이션 메서드를 호출합니다.
1. 수정: SControl.Common/LocalDeviceControl.cs (전체 파일)
SendInput 관련 P/Invoke 코드와 SimulateSmallMouseMovement() 메서드를 추가합니다.

C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 클래스 사용
using System.Threading;     // Thread.Sleep 사용

namespace SControl.Common
{
    public static class LocalDeviceControl
    {
        // --- 기존 모니터 전원 제어 관련 코드 ---
        private const int HWND_BROADCAST = 0xFFFF;   
        private const uint WM_SYSCOMMAND = 0x0112;   
        private const uint SC_MONITORPOWER = 0xF170; 

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, IntPtr Msg, UIntPtr wParam, IntPtr lParam,
            SendMessageTimeoutFlags fuFlags, uint uTimeout, out UIntPtr lpdwResult);

        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0, SMTO_BLOCK = 0x1, SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8, SMTO_ERRORONEXIT = 0x20
        }

        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }
            IntPtr lParam = (IntPtr)action;
            UIntPtr commandResultPlaceholder;
            IntPtr apiCallResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST, (uint)WM_SYSCOMMAND, (UIntPtr)SC_MONITORPOWER, lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, out commandResultPlaceholder);

            if (apiCallResult == IntPtr.Zero) 
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0) 
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (요청 동작: {action}). Win32 오류 코드: {errorCode}");
                }
            }
        }

        // --- SendInput 관련 P/Invoke 선언 및 구조체 (신규 추가) ---
        [StructLayout(LayoutKind.Sequential)]
        private struct MOUSEINPUT
        {
            public int dx;
            public int dy;
            public uint mouseData;
            public uint dwFlags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct KEYBDINPUT
        {
            public ushort wVk;
            public ushort wScan;
            public uint dwFlags;
            public uint time;
            public IntPtr dwExtraInfo;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct HARDWAREINPUT
        {
            public uint uMsg;
            public ushort wParamL;
            public ushort wParamH;
        }

        [StructLayout(LayoutKind.Explicit)]
        private struct MOUSEKEYBDHARDWAREINPUT
        {
            [FieldOffset(0)]
            public MOUSEINPUT mi;

            [FieldOffset(0)]
            public KEYBDINPUT ki;

            [FieldOffset(0)]
            public HARDWAREINPUT hi;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct INPUT
        {
            public uint type; // INPUT_MOUSE, INPUT_KEYBOARD, INPUT_HARDWARE
            public MOUSEKEYBDHARDWAREINPUT mkhi; // union
        }

        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);

        private const uint INPUT_MOUSE = 0;
        private const uint MOUSEEVENTF_MOVE = 0x0001;
        // --- SendInput 관련 끝 ---


        /// <summary>
        /// 모니터를 깨우기 위해 마우스를 미세하게 움직이는 것을 시뮬레이션합니다.
        /// (예: 오른쪽으로 1픽셀 이동 후 다시 왼쪽으로 1픽셀 이동)
        /// </summary>
        public static void SimulateSmallMouseMovement()
        {
            INPUT[] inputs = new INPUT[2];

            // 첫 번째 움직임: 오른쪽으로 1픽셀
            inputs[0] = new INPUT
            {
                type = INPUT_MOUSE,
                mkhi = new MOUSEKEYBDHARDWAREINPUT
                {
                    mi = new MOUSEINPUT
                    {
                        dx = 1, // X 상대 이동량
                        dy = 0, // Y 상대 이동량
                        mouseData = 0,
                        dwFlags = MOUSEEVENTF_MOVE, // 마우스 이동 이벤트
                        time = 0,
                        dwExtraInfo = IntPtr.Zero
                    }
                }
            };

            // 두 번째 움직임: 왼쪽으로 1픽셀 (원위치)
            inputs[1] = new INPUT
            {
                type = INPUT_MOUSE,
                mkhi = new MOUSEKEYBDHARDWAREINPUT
                {
                    mi = new MOUSEINPUT
                    {
                        dx = -1, // X 상대 이동량
                        dy = 0,  // Y 상대 이동량
                        mouseData = 0,
                        dwFlags = MOUSEEVENTF_MOVE,
                        time = 0,
                        dwExtraInfo = IntPtr.Zero
                    }
                }
            };
            
            // SendInput 호출. 보통 2개의 INPUT 구조체를 보냄.
            uint inputsSent = SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
            if (inputsSent < inputs.Length)
            {
                // 모든 입력이 성공적으로 보내지지 않은 경우 오류 처리 (선택적)
                // throw new Win32Exception(Marshal.GetLastWin32Error(), "SendInput API 호출 실패 또는 일부 실패.");
                // 여기서는 간단히 예외를 던지지 않고 진행. 필요시 로깅.
                Console.WriteLine($"SimulateSmallMouseMovement: SendInput sent {inputsSent} of {inputs.Length} inputs. LastError: {Marshal.GetLastWin32Error()}");
            }
             // 약간의 딜레이를 주어 시스템이 입력을 처리할 시간을 줄 수 있음 (선택적)
            Thread.Sleep(50); 
        }
    }
}
LocalDeviceControl.cs 주요 변경 사항:

SendInput API 및 관련 구조체들(INPUT, MOUSEINPUT 등)과 상수들(INPUT_MOUSE, MOUSEEVENTF_MOVE)을 P/Invoke로 선언했습니다.
SimulateSmallMouseMovement() 공개 static 메서드를 새로 추가했습니다. 이 메서드는 SendInput을 사용하여 마우스 커서를 오른쪽으로 1픽셀 이동시킨 후 즉시 다시 왼쪽으로 1픽셀 이동시켜, 실제 커서 위치는 거의 변하지 않지만 시스템에는 사용자 입력이 있었던 것으로 인식시킵니다.
2. 수정: SAgentM.App/Services/AgentCoreService.cs (전체 파일)
ExecuteDirectCommandAsync 메서드 내에서 CommandNames.MonitorControl 명령과 MonitorAction.On 액션을 처리할 때, LocalDeviceControl.SetMonitorState(MonitorAction.On) 호출 후에 LocalDeviceControl.SimulateSmallMouseMovement()를 호출하도록 수정합니다.

C#

// SAgentM.App/Services/AgentCoreService.cs
using Newtonsoft.Json;
using SControl.Common; // CommandPacket, Enums, Payloads, LocalDeviceControl 사용
using System;
using System.Configuration;
using System.Diagnostics;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.ComponentModel;

namespace SAgentM.App.Services
{
    public interface IAgentCoreService { void Start(); void Stop(); bool IsRunning { get; } }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026;
                _loggingService.UiWarn($"ListenPort 설정 누락/오류. 기본값 {_port} 사용.");
            }
        }

        public void Start()
        {
            if (_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 실행 중."); return; }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 중지됨."); return; }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5))) { _loggingService.UiWarn("리스닝 스레드 시간 내 종료 안됨."); }
            }
            _cancellationTokenSource?.Dispose(); _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning) {
                    try {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se) { if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted)) { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; } _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se); if (!_isRunning) break; Thread.Sleep(100); }
                    catch (InvalidOperationException ioe) when (!_isRunning) { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex) { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally { if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); } _loggingService.UiInfo("ListenLoop 종료됨."); }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try {
                _loggingService.UiDebug($"[{clientIpInfo}] 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true }) {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested) {
                        string requestJson = null;
                        try {
                            var readTask = reader.ReadLineAsync();
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask) { if (token.IsCancellationRequested) token.ThrowIfCancellationRequested(); requestJson = await readTask; }
                            else { token.ThrowIfCancellationRequested(); }
                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 연결 종료됨."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}");
                            CommandPacket requestPacket = null;
                            try { requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson); receivedRequestPacket = requestPacket; }
                            catch (JsonException jsonEx) { _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx); await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON: {jsonEx.Message}"))); continue; }
                            if (requestPacket != null) {
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null) {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                                    await writer.WriteLineAsync(responseJson);
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답: {responseJson}");
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] IO오류: {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체해제오류: {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 처리 작업 취소됨."); break; }
                        catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 오류.", ex); if (client.Connected && stream.CanWrite) { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}}
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request?.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl) {
                MonitorControlPayload originalPayload = null;
                try { if(!string.IsNullOrEmpty(request.PayloadJson)) originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch {}
                if (originalPayload?.Action == MonitorAction.Off) { // "끄기" 명령의 후처리 (조기응답 후 실제 끄기)
                    bool earlyConfirmSuccess = false;
                    if (response?.PayloadJson != null) { try { var genericResp = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if(genericResp != null) earlyConfirmSuccess = genericResp.Success; } catch {} }
                    if(earlyConfirmSuccess) { _loggingService.UiInfo($"[{clientIp}] 조기 응답 후 실제 모니터 끄기 실행. ID: {request.PacketId}"); Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료. ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); }
                    else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패/페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            try {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.Instruction) {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token); 
                    default: return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { return CreateErrorResponse(requestPacket, "Processing canceled."); }
            catch (Exception ex) { return CreateErrorResponse(requestPacket, $"Error processing '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            bool success = false; string message = "Execution failed."; 
            try {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName) {
                    case CommandNames.MonitorControl:
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "MonitorControl payload missing.");
                        MonitorControlPayload monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
                        if (monitorPayload == null) throw new ArgumentException("Cannot deserialize MonitorControlPayload.");
                        
                        _loggingService.UiInfo($"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");
                        if (monitorPayload.Action == MonitorAction.Off) { 
                            success = true; message = $"Monitor Off command acknowledged. Monitor will turn off shortly."; 
                            // 실제 끄기 동작은 HandleMonitorOffPostProcessing에서 응답 전송 후 수행
                        }
                        else { 
                            LocalDeviceControl.SetMonitorState(monitorPayload.Action); 
                            if(monitorPayload.Action == MonitorAction.On) // ▼▼▼ 모니터 켜기 시 마우스 이동 추가 ▼▼▼
                            {
                                Thread.Sleep(100); // 모니터가 켜질 약간의 시간 부여 (선택적)
                                LocalDeviceControl.SimulateSmallMouseMovement();
                                message = $"Monitor state set to {monitorPayload.Action} and mouse nudged.";
                                _loggingService.UiInfo($"[{clientIp}] {message}");
                            } // ▲▲▲ 모니터 켜기 시 마우스 이동 추가 ▲▲▲
                            else 
                            {
                                message = $"Monitor state set to {monitorPayload.Action}.";
                            }
                            success = true; 
                        }
                        _loggingService.UiInfo($"[{clientIp}] {message} (Cmd: MonitorControl, Action: {monitorPayload.Action})");
                        break;
                    
                    case CommandNames.SetDisplayTimeout: 
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "SetDisplayTimeout payload missing.");
                        SetDisplayTimeoutPayload timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson);
                        if (timeoutPayload == null) throw new ArgumentException("Cannot deserialize SetDisplayTimeoutPayload.");
                        
                        int timeoutValueInMinutes = timeoutPayload.TimeoutMinutes;
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutValueInMinutes}분");
                        
                        string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
                        string acArgs = $"/change monitor-timeout-ac {timeoutValueInMinutes}";
                        string dcArgs = $"/change monitor-timeout-dc {timeoutValueInMinutes}";

                        RunPowerCfgCommand(acArgs, out outputAc, out errorAc, out exitCodeAc);
                        RunPowerCfgCommand(dcArgs, out outputDc, out errorDc, out exitCodeDc);
                        
                        if (exitCodeAc == 0 && exitCodeDc == 0) { success = true; message = $"Display timeout set to {timeoutValueInMinutes} min for AC/DC."; }
                        else { success = false; string acErrClean = string.IsNullOrEmpty(errorAc)?"":errorAc.Trim().Replace("\r\n"," ").Replace("\n"," "); string dcErrClean = string.IsNullOrEmpty(errorDc)?"":errorDc.Trim().Replace("\r\n"," ").Replace("\n"," "); message = $"Failed display timeout. AC Exit:{exitCodeAc}, DC Exit:{exitCodeDc}."; if (!string.IsNullOrEmpty(acErrClean)) message += $" AC Err: {acErrClean}"; if (!string.IsNullOrEmpty(dcErrClean)) message += $" DC Err: {dcErrClean}"; }
                        _loggingService.UiInfo($"[{clientIp}] {message}");
                        break;
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; success = false; break;
                }
            }
            catch (OperationCanceledException opEx) { message = $"Cmd {requestPacket.CommandName} canceled: {opEx.Message}"; success = false; _loggingService.UiWarn($"[{clientIp}] {message}");}
            catch (ArgumentNullException argEx) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx.ParamName} - {argEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx); }
            catch (ArgumentException argEx2) { message = $"Cmd {requestPacket.CommandName} arg error: {argEx2.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", argEx2); }
            catch (JsonException jsonEx) { message = $"Cmd {requestPacket.CommandName} JSON payload error: {jsonEx.Message}"; success = false; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); }
            catch (Exception ex) { message = $"Error executing {requestPacket.CommandName}: {ex.Message}"; success = false; _loggingService.UiError($"[{clientIp}] ExecuteDirectCmd Error: {message}", ex); }
            return CreateExecutionResponse(requestPacket, success, message);
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = ""; error = ""; exitCode = -1;
            try {
                _loggingService.UiDebug($"Executing: powercfg.exe {arguments}");
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") { Arguments = arguments, UseShellExecute = false, RedirectStandardOutput = true, RedirectStandardError = true, CreateNoWindow = true, Verb = "runas" };
                using (Process process = Process.Start(startInfo)) {
                    if (process == null) { error = "Failed to start powercfg.exe."; exitCode = -100; _loggingService.UiError(error); return; }
                    output = process.StandardOutput.ReadToEnd(); error = process.StandardError.ReadToEnd(); 
                    if (!process.WaitForExit(7000)) { process.Kill(); error += $"\npowercfg '{arguments}' timeout (7s)."; exitCode = -99;  _loggingService.UiWarn(error); }
                    else { exitCode = process.ExitCode; }
                    if(!string.IsNullOrWhiteSpace(output)) _loggingService.UiDebug($"powercfg output: {output.Trim()}");
                    if(!string.IsNullOrWhiteSpace(error) && exitCode != 0) _loggingService.UiWarn($"powercfg error output: {error.Trim()}");
                }
            } 
            catch (Win32Exception w32Ex) { error = $"powercfg Win32Ex (UAC denied?): {w32Ex.Message}"; exitCode = w32Ex.NativeErrorCode; _loggingService.UiError(error, w32Ex); } 
            catch (Exception ex) { error = $"powercfg Ex: {ex.Message}"; exitCode = -2; _loggingService.UiError(error, ex); }
        }

        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue) { return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP/Port missing."); }
            var packetForFinalTarget = new CommandPacket { Instruction = CommandInstruction.DirectExecute, CommandName = originalRelayRequest.CommandName, PayloadJson = originalRelayRequest.PayloadJson, ResponseAddress = originalRelayRequest.ResponseAddress, ResponsePort = originalRelayRequest.ResponsePort, PacketId = Guid.NewGuid() };
            string relayStatusMessage = $"Relay: {packetForFinalTarget.CommandName} to {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}.";
            bool relayCommSuccess = false; CommandPacket responseFromFinalTarget = null;
            try {
                token.ThrowIfCancellationRequested();
                using (var targetClient = new TcpClient()) {
                    var connectTask = targetClient.ConnectAsync(originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand.Value);
                    if (await Task.WhenAny(connectTask, Task.Delay(TimeSpan.FromSeconds(5), token)) != connectTask || token.IsCancellationRequested) { token.ThrowIfCancellationRequested(); targetClient.Close(); throw new TimeoutException("Relay target connection timed out."); }
                    await connectTask; _loggingService.UiDebug($"[{clientIp}] 릴레이 대상 연결 성공.");
                    using (NetworkStream rS = targetClient.GetStream()) using (StreamWriter rW = new StreamWriter(rS, Encoding.UTF8){AutoFlush=true}) using (StreamReader rR = new StreamReader(rS, Encoding.UTF8)){
                        string jsonToRelay = JsonConvert.SerializeObject(packetForFinalTarget); if(token.IsCancellationRequested) token.ThrowIfCancellationRequested(); await rW.WriteLineAsync(jsonToRelay); _loggingService.UiDebug($"[{clientIp}] 릴레이 데이터 전송: {jsonToRelay}");
                        var targetResponseTask = rR.ReadLineAsync();
                        if (await Task.WhenAny(targetResponseTask, Task.Delay(TimeSpan.FromSeconds(10), token)) == targetResponseTask && !token.IsCancellationRequested){
                            string targetJson = await targetResponseTask; if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                            if (!string.IsNullOrEmpty(targetJson)){ _loggingService.UiInfo($"[{clientIp}] 릴레이 대상 응답: {targetJson}"); responseFromFinalTarget = JsonConvert.DeserializeObject<CommandPacket>(targetJson); relayCommSuccess = true; }
                            else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 빈 응답."); relayStatusMessage = "Relay sent, empty response from final target."; }
                        } else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 응답 시간 초과/취소."); relayStatusMessage = "Relay sent, no response/timeout/canceled from final target."; }
                    }
                }
            }
            catch (OperationCanceledException) { relayStatusMessage = $"Relay of {originalRelayRequest.CommandName} canceled."; _loggingService.UiInfo($"[{clientIp}] {relayStatusMessage}"); }
            catch (TimeoutException tex) { relayStatusMessage = $"Relay failed: Timeout - {tex.Message}"; _loggingService.UiWarn($"[{clientIp}] {relayStatusMessage}"); }
            catch (SocketException se) { relayStatusMessage = $"Relay failed: Socket error - {se.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", se); }
            catch (Exception ex) { relayStatusMessage = $"Relay failed: Unexpected error - {ex.Message}"; _loggingService.UiError($"[{clientIp}] {relayStatusMessage}", ex); }
            if (responseFromFinalTarget != null) { responseFromFinalTarget.PacketId = originalRelayRequest.PacketId; return responseFromFinalTarget; }
            else { return CreateExecutionResponse(originalRelayRequest, relayCommSuccess, relayStatusMessage); }
        }

        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null) { Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN"; return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_Response", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort }; }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg) { Guid pId = req?.PacketId ?? Guid.NewGuid(); string cmdName = req?.CommandName ?? "UNKNOWN"; _loggingService.UiError($"Error response for PktID {pId} (Cmd: {cmdName}): {errorMsg}"); return new CommandPacket { PacketId = pId, Instruction = CommandInstruction.DirectExecute, CommandName = $"{cmdName}_ErrorResponse", PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }), ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort }; }
    }
}
AgentCoreService.cs의 ExecuteDirectCommandAsync 메서드 내 MonitorControl 처리 부분 변경점:

C#

// ... 기존 switch 문 내부 ...
case CommandNames.MonitorControl:
    if (string.IsNullOrEmpty(requestPacket.PayloadJson)) throw new ArgumentNullException("PayloadJson", "MonitorControl payload missing.");
    MonitorControlPayload monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
    if (monitorPayload == null) throw new ArgumentException("Cannot deserialize MonitorControlPayload.");
    
    _loggingService.UiInfo($"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");
    if (monitorPayload.Action == MonitorAction.Off) 
    { 
        success = true; 
        message = $"Monitor Off command acknowledged. Monitor will turn off shortly."; 
        // 실제 끄기 동작은 HandleMonitorOffPostProcessing에서 응답 전송 후 수행됨
    }
    else 
    { 
        LocalDeviceControl.SetMonitorState(monitorPayload.Action); // 모니터 상태 변경 (예: On 또는 Standby)
        
        if(monitorPayload.Action == MonitorAction.On) // "켜기" 명령인 경우에만 추가 동작
        {
            _loggingService.UiInfo($"[{clientIp}] MonitorAction.On: 잠시 후 마우스 입력 시뮬레이션 시도.");
            Thread.Sleep(100); // 모니터가 켜질 물리적인 시간을 약간 기다립니다 (선택적).
            try
            {
                LocalDeviceControl.SimulateSmallMouseMovement(); // 마우스 미세 이동 호출
                message = $"Monitor state set to {monitorPayload.Action} and simulated mouse input to ensure wake-up.";
                _loggingService.UiInfo($"[{clientIp}] {message}");
            }
            catch (Exception simEx)
            {
                message = $"Monitor state set to {monitorPayload.Action}, but mouse simulation failed: {simEx.Message}";
                _loggingService.UiError($"[{clientIp}] 마우스 입력 시뮬레이션 실패: {simEx.Message}", simEx);
                // 성공 여부는 SetMonitorState 기준으로 하므로 success는 true 유지 가능
            }
        }
        else // Standby 등 다른 MonitorAction의 경우
        {
            message = $"Monitor state set to {monitorPayload.Action}.";
        }
        success = true; 
    }
    _loggingService.UiInfo($"[{clientIp}] 최종 메시지 (Cmd: MonitorControl, Action: {monitorPayload.Action}): {message}");
    break;
// ... 나머지 코드 ...
주요 변경 사항:

SControl.Common/LocalDeviceControl.cs:
SendInput API와 관련 구조체 및 상수를 P/Invoke로 선언했습니다.
SimulateSmallMouseMovement() 메서드를 추가하여 마우스를 아주 약간 (1픽셀 이동 후 복귀) 움직이는 입력을 생성합니다. 이는 시스템에 사용자 활동으로 인식되어 잠금 화면 등에서 모니터가 다시 꺼지는 것을 방지하는 데 도움이 될 수 있습니다. Thread.Sleep(50)을 추가하여 입력이 처리될 시간을 약간 줍니다.
SAgentM.App/Services/AgentCoreService.cs:
ExecuteDirectCommandAsync 메서드 내에서 CommandNames.MonitorControl 명령을 처리할 때:
monitorPayload.Action == MonitorAction.On (즉, 모니터 켜기 명령)인 경우:
기존처럼 LocalDeviceControl.SetMonitorState(MonitorAction.On)을 호출하여 모니터에 켜짐 신호를 보냅니다.
그 직후에 LocalDeviceControl.SimulateSmallMouseMovement()를 호출하여 마우스 입력을 시뮬레이션합니다.
성공 메시지에 마우스 입력 시뮬레이션에 대한 내용도 포함될 수 있도록 수정했습니다.
MonitorAction.Off의 경우는 이전과 동일하게 "조기 확인 응답" 로직을 유지하며, 실제 모니터 끄기는 HandleMonitorOffPostProcessing에서 처리됩니다 (여기서는 마우스 이동 시뮬레이션 불필요).
위 수정된 파일들을 프로젝트에 적용하시고, SAgentM.App.exe를 (관리자 권한으로) 재빌드 및 실행한 후, Flask 웹 UI에서 "켜기" 명령을 다시 테스트해 보십시오.

테스트 시나리오:

대상 Windows PC의 모니터가 꺼져 있고, 화면이 잠겨 있는 상태를 만듭니다 (예: "1분 후 끄기" 설정을 통해 자동으로 꺼지게 한 후).
Flask 웹 UI에서 해당 PC에 대해 "켜기" 명령을 보냅니다.
모니터가 켜지고, 잠금 해제 화면(로그인 화면)이 표시된 후에도 모니터가 다시 바로 꺼지지 않고 유지되는지 확인합니다.
SAgentM.App의 로그에 "마우스 입력 시뮬레이션 시도" 및 관련 성공/실패 로그가 남는지 확인합니다.
이 방법이 모든 시스템 환경에서 100% 동작한다고 보장할 수는 없지만 (특히 특정 보안 소프트웨어가 가상 입력을 차단하는 경우 등), 잠금 화면에서 모니터를 안정적으로 깨우는 데 도움이 될 수 있는 일반적인 접근 방식입니다.