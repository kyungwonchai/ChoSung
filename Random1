skModel과 CommandQueueViewModel을 결합하여 혁신적인 코드 구조를 만드는 것은 복잡한 작업이지만, 두 시스템을 융합함으로써 비동기 작업 실행, 작업 큐 관리, 명령과 함수의 상태 제어 기능을 모두 갖춘 시스템을 구축할 수 있습니다.

아래에서는 TaskModel과 CommandQueueViewModel의 핵심 역할을 결합한 예제 코드를 제공합니다. 이 코드에서는 작업 단위로 비동기 함수를 큐에 넣고, **명령(Command)**을 통해 작업을 관리하고, 작업 상태를 UI에 반영하며, 도형 색상으로 각 함수의 상태를 시각적으로 표현합니다.

1. TaskQueue 클래스 - 작업 큐 관리
이 클래스는 여러 작업을 관리하고 순차적으로 실행하는 역할을 합니다. CommandQueueViewModel의 명령(Command) 기능을 녹여넣어 작업을 큐에 추가하고 순차적으로 실행합니다.

csharp
코드 복사
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;  // 작업 실행 여부
    private bool _isPaused = false;   // 작업 일시정지 여부

    public bool IsRunning => _isRunning;
    public bool IsPaused => _isPaused;

    // 작업을 큐에 추가하고 실행
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);
        if (!_isRunning && !_isPaused)
        {
            RunNextTask();  // 실행 중이 아니면 실행
        }
    }

    // 작업 큐에서 다음 작업을 실행
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused) return;

        _isRunning = true;
        var task = _tasks.Dequeue();
        await task();
        _isRunning = false;

        if (!_isPaused)
        {
            RunNextTask();  // 다음 작업 실행
        }
    }

    // 작업 일시정지
    public void Pause()
    {
        _isPaused = true;
    }

    // 작업 재개
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false;
            if (!_isRunning)
            {
                RunNextTask();  // 재개 후 다음 작업 실행
            }
        }
    }
}
2. TaskModel 클래스 - 개별 작업 관리
TaskModel 클래스는 비동기 작업을 관리하고, 각 함수(Task A, B, C 등)의 상태를 도형으로 표시합니다. 여기서는 함수를 순차적으로 실행하며, 상태 변화에 따라 도형 색상을 업데이트합니다.

csharp
코드 복사
public partial class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }
    public string Status { get; set; }

    private Stopwatch _stopwatch;
    private TaskQueue _taskQueue;

    // PLC 클래스 인스턴스
    private PLCClass _plcInstance;

    public TaskModel(PLCClass plcInstance, TaskQueue taskQueue)
    {
        _plcInstance = plcInstance;
        _taskQueue = taskQueue;
        FunctionStatusList = new ObservableCollection<FunctionStatus>();
        Status = "Pending";
        _stopwatch = new Stopwatch();

        // 함수 추가 (비동기 작업)
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
    }

    // 작업 시작
    public async Task StartTask()
    {
        _stopwatch.Restart();
        Status = "Running";
        await ExecuteTaskSequence();
        Status = "Completed";
        _stopwatch.Stop();
    }

    // 작업 순차 실행
    private async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            Stopwatch functionStopwatch = new Stopwatch();
            functionStopwatch.Start();
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);
            functionStopwatch.Stop();
            functionStatus.ExecutionTime = $"{functionStopwatch.Elapsed.TotalSeconds:F2} seconds";
        }
    }

    // 함수 실행 및 색상 변경
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 작업 진행 중
        });

        await task();  // 비동기 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 시 색상 변경
        });
    }

    // 비동기 함수 (PLC 통신과 연결)
    private async Task ExecuteTaskA() { await Task.Delay(1000); await _plcInstance.SendSignalAsync("Task A 실행"); }
    private async Task ExecuteTaskB() { await Task.Delay(1500); await _plcInstance.SendSignalAsync("Task B 실행"); }
    private async Task ExecuteTaskC() { await Task.Delay(2000); await _plcInstance.SendSignalAsync("Task C 실행"); }

    // 함수 추가
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        FunctionStatusList.Add(new FunctionStatus(functionName, task, initialColor));
    }
}
3. CommandQueueViewModel (명령 큐 뷰모델)
CommandQueueViewModel과 TaskModel을 결합하여 작업을 순차적으로 실행하면서 상태를 관리합니다. 작업이 추가되면 도형의 상태가 즉시 반영되며, 버튼을 통해 일시정지, 재개가 가능합니다.

csharp
코드 복사
public class CommandQueueViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }
    public TaskQueue TaskQueue { get; set; }

    // 명령어 (일시정지, 재개)
    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }

    public CommandQueueViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        TaskQueue = new TaskQueue();

        // 일시정지 및 재개 명령어
        PauseCommand = new RelayCommand(PauseAllTasks);
        ResumeCommand = new RelayCommand(ResumeAllTasks);

        // 예시 작업 추가
        InitializeTasks();
    }

    // 작업 초기화 (예시로 TaskModel 추가)
    private void InitializeTasks()
    {
        var plcInstance = new PLCClass();
        for (int i = 0; i < 3; i++)
        {
            var taskModel = new TaskModel(plcInstance, TaskQueue);
            TaskList.Add(taskModel);
        }
    }

    // 모든 작업 일시정지
    private void PauseAllTasks()
    {
        TaskQueue.Pause();
    }

    // 모든 작업 재개
    private void ResumeAllTasks()
    {
        TaskQueue.Resume();
    }

    // 전체 작업 시작
    public void StartAllTasks()
    {
        foreach (var task in TaskList)
        {
            task.StartTask();
        }
    }
}
4. XAML 코드 - 도형과 상태 표시
UI에서 도형으로 작업의 상태를 시각적으로 표현하고, 각 작업을 클릭하여 개별 작업을 실행할 수 있도록 합니다.

xml
코드 복사
<DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False">
    <DataGrid.Columns>
        <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" />
        <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" />
        <DataGridTextColumn Header="Status" Binding="{Binding Status}" />

        <DataGridTemplateColumn Header="Function Status">
            <DataGridTemplateColumn.CellTemplate>
                <DataTemplate>
                    <ItemsControl ItemsSource="{Binding FunctionStatusList}">
                        <ItemsControl.ItemTemplate>
                            <DataTemplate>
                                <StackPanel Orientation="Horizontal">
                                    <!-- 함수 상태 도형 -->
                                    <Ellipse Width="30" Height="30" Fill="{Binding StatusColor}" 
                                             MouseLeftButtonDown="Ellipse_MouseLeftButtonDown">
                                        <Ellipse.ToolTip>
                                            <TextBlock Text="{Binding FunctionName}" />
                                        </Ellipse.ToolTip>
                                    </Ellipse>
                                </StackPanel>
                            </DataTemplate>
                        </ItemsControl.ItemTemplate>
                    </ItemsControl>
                </DataTemplate>
            </DataGridTemplateColumn.CellTemplate>
        </DataGridTemplateColumn>
    </DataGrid.Columns>
</DataGrid>
5. 코드 설명
1. TaskQueue의 역할:
작업 큐를 관리하며, 각 작업을 순차적으로 실행합니다.
일시정지 및 재개 기능을 통해 작업의 흐름을 제어합니다.
2. TaskModel의 역할:
각 작업의 상태를 관리하며, 비동기 함수를 실행합니다.
PLC 통신을 수행하고, 함수가 완료되면 해당 함수의 상태(도형 색상)를 변경합니다.
3. CommandQueueViewModel의 역할:
UI와 작업 시스템을 연결합니다.
명령(Command)으로 작업의 일시정지 및 재개를 제어하며, 모든 작업