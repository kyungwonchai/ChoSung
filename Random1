EWTOCOL 프로토콜에서 STX와 ETX를 처리하는 방법을 이해하고, 코드를 수정하는 방법에 대해 설명드리겠습니다.
MEWTOCOL 프로토콜에서는 STX와 ETX 대신에 다음과 같은 형식이 사용됩니다:

시작 문자 (STX 대체): % 또는 <가 메세지의 시작을 나타냅니다.
종료 문자 (ETX 대체): CR (캐리지 리턴, ASCII 0x0D)이 메세지의 종료를 나타냅니다.
정상 응답: 응답 메세지는 $로 시작하며, CR로 끝납니다.
에러 응답: 응답 메세지가 에러일 경우 !로 시작하며, CR로 끝납니다.
따라서, MEWTOCOL 프로토콜에서는 % 또는 <로 시작하는 메세지를 읽고, CR로 끝나는 메세지를 처리해야 합니다.

코드 수정: STX, ETX 처리에서 MEWTOCOL에 맞게 변경
기존의 STX(시작 문자), ETX(종료 문자) 처리를 MEWTOCOL의 **시작 문자(%)**와 종료 문자(CR) 처리로 변경한 코드를 제공하겠습니다. 아래 코드는 PLC에서 응답을 받을 때 %로 시작하고 CR로 끝나는 메세지를 읽는 방식입니다.

코드 예시 (C#):
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

public class PLCCommunication
{
    private SerialPort _serialPort;
    private const char START_CHAR = '%';  // 시작 문자 (MEWTOCOL에서 % 또는 < 사용)
    private const char NORMAL_RESPONSE_START = '$';  // 정상 응답 시작
    private const char ERROR_RESPONSE_START = '!';   // 에러 응답 시작
    private const char END_CHAR = '\r';   // 종료 문자 (CR, ASCII 0x0D)

    public PLCCommunication(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);
        _serialPort.Encoding = Encoding.ASCII;
        _serialPort.Open();
    }

    // 명령을 보내고 응답을 기다리는 함수
    public async Task<string> SendCommandAndWaitForResponseAsync(string command)
    {
        // 1. 명령을 PLC에 전송한다.
        await SendCommandAsync(command);

        // 2. PLC의 응답을 받는다. 응답은 %로 시작하고 CR로 끝난다.
        string response = await ReadUntilEndAsync();

        return response;
    }

    // 명령을 전송하는 함수
    private async Task SendCommandAsync(string command)
    {
        if (_serialPort.IsOpen)
        {
            byte[] commandBytes = Encoding.ASCII.GetBytes(command);
            await _serialPort.BaseStream.WriteAsync(commandBytes, 0, commandBytes.Length);
            await _serialPort.BaseStream.FlushAsync();  // 명령 전송 후 플러시
        }
        else
        {
            throw new InvalidOperationException("Serial port is not open.");
        }
    }

    // 응답을 읽는 함수 (시작 문자 % 또는 <, 종료 문자 CR)
    private async Task<string> ReadUntilEndAsync()
    {
        var buffer = new byte[256];
        var stringBuilder = new StringBuilder();
        bool isReading = false;  // 응답 시작 체크 플래그
        int bytesRead;

        while (true)
        {
            // 1. 데이터를 읽는다.
            bytesRead = await _serialPort.BaseStream.ReadAsync(buffer, 0, buffer.Length);

            // 2. 읽은 데이터를 문자로 변환하고 처리한다.
            for (int i = 0; i < bytesRead; i++)
            {
                char receivedChar = (char)buffer[i];

                if (receivedChar == START_CHAR)
                {
                    // 시작 문자를 감지하면 응답 시작
                    isReading = true;
                    stringBuilder.Clear();  // 이전 응답 데이터는 지운다.
                }
                else if (receivedChar == END_CHAR && isReading)
                {
                    // 종료 문자를 만나면 읽기를 종료하고 데이터를 반환
                    isReading = false;
                    return stringBuilder.ToString();  // 응답 데이터를 반환
                }
                else if (isReading)
                {
                    // 시작 문자 이후부터 종료 문자 전까지 데이터를 수집
                    stringBuilder.Append(receivedChar);
                }
            }
        }
    }

    public void Close()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }
}
주요 코드 변경 사항:
START_CHAR와 END_CHAR 설정:

시작 문자는 %로 설정되었습니다. 이는 MEWTOCOL 프로토콜에서 메세지의 시작을 나타내는 문자입니다.
종료 문자는 CR (캐리지 리턴, ASCII 0x0D)로 설정하였습니다. 이는 메세지의 끝을 나타냅니다.
ReadUntilEndAsync 함수:

%로 시작하고 CR로 끝나는 데이터를 읽습니다.
정상 응답($) 또는 에러 응답(!)이 올 때까지 데이터를 읽어 반환합니다.
사용 예시:
csharp
코드 복사
public async Task MainAsync()
{
    // 시리얼 포트 설정 (COM 포트 이름과 속도는 PLC에 맞게 설정)
    var plcCommunication = new PLCCommunication("COM1", 9600);

    try
    {
        // PLC에 명령을 전송하고 응답을 기다림
        string command = "YOUR_COMMAND";  // 전송할 명령
        string response = await plcCommunication.SendCommandAndWaitForResponseAsync(command);

        // 응답 출력
        Console.WriteLine($"응답: {response}");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"오류 발생: {ex.Message}");
    }
    finally
    {
        // 시리얼 포트 닫기
        plcCommunication.Close();
    }
}
추가로 고려해야 할 점:
MEWTOCOL 프로토콜에서의 명령 구조: 사용 중인 PLC의 MEWTOCOL 명령 형식을 확인하고, 이를 기반으로 명령을 정확하게 전송해야 합니다.
에러 처리: 응답이 에러(!로 시작)일 경우, 에러 처리를 추가하는 것이 좋습니다.
타임아웃 처리: 응답이 너무 오래 걸릴 경우 타임아웃을 설정해 통신 오류를 처리할 수 있습니다.
이 코드로 MEWTOCOL 프로토콜을 통해 PLC와의 통신을 수행할 수 있으며, %로 시작