opyMemory는 데이터를 메모리 간에 복사하는 함수로, 일반적으로 Windows API를 통해 사용할 수 있는 함수입니다. 이 함수는 데이터를 클립보드에 복사하거나 메모리 블록 간에 데이터를 이동할 때 사용됩니다. VBA에서는 CopyMemory 대신 WinAPI 호출을 사용해 동일한 작업을 수행할 수 있습니다.

엑셀 VBA에서 CopyMemory를 사용하는 이유는 텍스트 데이터를 정확히 메모리에 복사하고 클립보드에 설정하기 위해서입니다.
하지만 CopyMemory 함수는 최신 VBA 버전에서 명시적으로 지원되지 않으므로 안정성을 위해 대체 방법을 사용할 수 있습니다.

대체 방법: RtlMoveMemory 사용
RtlMoveMemory는 CopyMemory와 동일한 기능을 제공하며, 최신 VBA 환경에서도 안정적으로 작동합니다.

아래는 CopyMemory를 사용하는 대신 RtlMoveMemory를 사용하는 방식으로 수정한 코드입니다:

수정된 WinAPI 기반 코드
vba
코드 복사
#If VBA7 Then
    Private Declare PtrSafe Sub RtlMoveMemory Lib "kernel32" (ByVal Destination As LongPtr, ByVal Source As LongPtr, ByVal Length As LongPtr)
    Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
#Else
    Private Declare Sub RtlMoveMemory Lib "kernel32" (ByVal Destination As Long, ByVal Source As Long, ByVal Length As Long)
    Private Declare Function OpenClipboard Lib "user32" (ByVal hwnd As Long) As Long
    Private Declare Function EmptyClipboard Lib "user32" () As Long
    Private Declare Function CloseClipboard Lib "user32" () As Long
    Private Declare Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As Long) As Long
    Private Declare Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As Long) As Long
    Private Declare Function GlobalLock Lib "kernel32" (ByVal hMem As Long) As Long
    Private Declare Function GlobalUnlock Lib "kernel32" (ByVal hMem As Long) As Long
#End If

Const CF_TEXT As Long = 1
Const GMEM_MOVEABLE As Long = &H2

Sub CopyTextToClipboard(Text As String)
    Dim hGlobal As LongPtr
    Dim lpGlobal As LongPtr
    
    ' 클립보드 열기
    If OpenClipboard(0&) Then
        EmptyClipboard
        
        ' 메모리 할당 및 데이터 복사
        hGlobal = GlobalAlloc(GMEM_MOVEABLE, Len(Text) + 1)
        lpGlobal = GlobalLock(hGlobal)
        If lpGlobal Then
            ' RtlMoveMemory로 텍스트 데이터를 메모리로 복사
            RtlMoveMemory ByVal lpGlobal, ByVal StrPtr(Text), Len(Text)
            GlobalUnlock hGlobal
            SetClipboardData CF_TEXT, hGlobal
        End If
        
        ' 클립보드 닫기
        CloseClipboard
    End If
End Sub

Sub CopySheetWithoutQuotes()
    Dim ws As Worksheet
    Dim rng As Range
    Dim row As Range
    Dim cell As Range
    Dim clipboardData As String
    
    ' 현재 시트와 범위 지정
    Set ws = ThisWorkbook.Sheets(1)
    Set rng = ws.UsedRange ' 시트의 데이터가 있는 전체 범위
    
    ' 시트 내용 읽기
    clipboardData = ""
    For Each row In rng.Rows
        For Each cell In row.Cells
            clipboardData = clipboardData & cell.Value & vbTab
        Next cell
        clipboardData = Left(clipboardData, Len(clipboardData) - 1) & vbCrLf ' 마지막 탭 제거 + 줄바꿈 추가
    Next row
    
    ' 클립보드에 복사
    CopyTextToClipboard clipboardData
    
    MsgBox "시트 내용이 따옴표 없이 클립보드에 복사되었습니다!", vbInformation
End Sub
변경점
RtlMoveMemory 사용

CopyMemory 대신 RtlMoveMemory를 사용합니다.
이 함수는 데이터를 메모리 블록 간에 복사하는 안정적인 API입니다.
클립보드 작업
