네, 알겠습니다. SControl.Common 라이브러리의 최종 전체 코드를 한국어 설명과 함께 다시 제공해 드리겠습니다.

SAgentM.App 프로젝트에서 SetDisplayTimeout 또는 SetDisplayTimeoutPayload 관련 오류가 발생한다면, 이 SControl.Common 라이브러리가 SAgentM.App 프로젝트에 올바르게 참조되어 있고, SControl.Common 내의 코드(특히 Enums.cs와 Payloads.cs)에 해당 정의들이 정확히 포함되어 있는지 확인하는 것이 중요합니다.

SControl.Common 라이브러리 전체 최종 코드 (.NET Framework 4.6)
1. 프로젝트 파일 (SControl.Common.csproj)
대상 프레임워크: .NET Framework 4.6
프로젝트 종류: 클래스 라이브러리
특별한 NuGet 패키지 의존성 없음.
<!-- end list -->

XML

<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
    <ProjectGuid>{YOUR-UNIQUE-PROJECT-GUID-HERE}</ProjectGuid> <OutputType>Library</OutputType>
    <AppDesignerFolder>Properties</AppDesignerFolder>
    <RootNamespace>SControl.Common</RootNamespace>
    <AssemblyName>SControl.Common</AssemblyName>
    <TargetFrameworkVersion>v4.6</TargetFrameworkVersion> <FileAlignment>512</FileAlignment>
    <Deterministic>true</Deterministic>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
    <DebugSymbols>true</DebugSymbols>
    <DebugType>full</DebugType>
    <Optimize>false</Optimize>
    <OutputPath>bin\Debug\</OutputPath>
    <DefineConstants>DEBUG;TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
    <DebugType>pdbonly</DebugType>
    <Optimize>true</Optimize>
    <OutputPath>bin\Release\</OutputPath>
    <DefineConstants>TRACE</DefineConstants>
    <ErrorReport>prompt</ErrorReport>
    <WarningLevel>4</WarningLevel>
  </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CommandPacket.cs" />
    <Compile Include="Enums.cs" />
    <Compile Include="LocalDeviceControl.cs" />
    <Compile Include="Payloads.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
</Project>
2. Enums.cs
시스템 전반에서 사용될 주요 열거형(Enumerations)을 정의합니다.
CommandInstruction: 에이전트가 명령을 처리하는 방식 (직접 실행, 릴레이).
CommandNames: 사용될 명령어의 종류 (모니터 즉시 제어, 디스플레이 타임아웃 설정).
MonitorAction: 모니터 즉시 제어 시 사용될 동작 (켜기, 끄기, 대기).
<!-- end list -->

C#

// SControl.Common/Enums.cs
namespace SControl.Common
{
    /// <summary>
    /// SAgentM 에이전트가 수신된 명령 패킷을 처리하는 방식을 정의합니다.
    /// </summary>
    public enum CommandInstruction
    {
        /// <summary>
        /// 현재 SAgentM 에이전트에서 명령을 직접 실행합니다.
        /// </summary>
        DirectExecute,

        /// <summary>
        /// 명령을 지정된 다른 SAgentM 에이전트 대상으로 중계(릴레이)합니다.
        /// </summary>
        RelayToTarget
    }

    /// <summary>
    /// 실행 또는 중계될 수 있는 명령어들의 고유한 이름을 정의하는 상수 클래스입니다.
    /// </summary>
    public static class CommandNames
    {
        /// <summary>
        /// 모니터의 전원 상태(켜기, 끄기, 대기)를 즉시 제어하는 명령입니다.
        /// Windows API의 SC_MONITORPOWER 메시지를 사용합니다.
        /// </summary>
        public const string MonitorControl = "MONITOR_CONTROL";

        /// <summary>
        /// Windows 전원 옵션의 "디스플레이 끄기 시간" 설정을 변경하는 명령입니다.
        /// powercfg.exe 유틸리티를 사용합니다.
        /// </summary>
        public const string SetDisplayTimeout = "SET_DISPLAY_TIMEOUT"; // <<--- 이 상수가 정의되어 있어야 합니다.
    }

    /// <summary>
    /// 모니터 전원 상태 제어 동작의 종류를 정의합니다.
    /// (Windows SC_MONITORPOWER 메시지의 lParam 값 기준)
    /// </summary>
    public enum MonitorAction
    {
        /// <summary>
        /// 모니터를 켭니다 (SC_MONITORPOWER lParam 값: -1).
        /// </summary>
        On = -1,

        /// <summary>
        /// 모니터를 절전 모드(저전력 상태)로 전환합니다 (SC_MONITORPOWER lParam 값: 1).
        /// </summary>
        Standby = 1,

        /// <summary>
        /// 모니터를 끕니다 (SC_MONITORPOWER lParam 값: 2).
        /// </summary>
        Off = 2
    }
}
3. Payloads.cs
각 명령어에 필요한 구체적인 데이터를 담는 페이로드(Payload) 클래스들을 정의합니다.
<!-- end list -->

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    /// <summary>
    /// MonitorControl 명령을 위한 페이로드입니다.
    /// 원하는 모니터 전원 상태 동작을 지정합니다.
    /// </summary>
    public class MonitorControlPayload
    {
        public MonitorAction Action { get; set; }
    }

    /// <summary>
    /// SetDisplayTimeout 명령을 위한 페이로드입니다.
    /// 디스플레이가 꺼지기까지의 시간(분 단위)을 지정합니다.
    /// </summary>
    public class SetDisplayTimeoutPayload // <<--- 이 클래스가 정의되어 있어야 합니다.
    {
        /// <summary>
        /// 디스플레이 끄기 시간(분)입니다. 0은 "사용 안 함(Never)"을 의미합니다.
        /// </summary>
        public int TimeoutMinutes { get; set; }
    }

    /// <summary>
    /// SAgentM 에이전트로부터의 응답에 사용될 수 있는 일반적인 페이로드 구조입니다.
    /// 명령어 실행의 성공/실패 여부와 메시지 등을 포함할 수 있습니다.
    /// </summary>
    public class GenericResponsePayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string ErrorCode { get; set; } // 선택적인 오류 코드
        public object Data { get; set; }      // 선택적인 추가 데이터
    }
}
4. CommandPacket.cs
제어 프로그램(Flask 웹 앱)과 SAgentM.App 에이전트 간에 주고받을 기본 통신 데이터 패킷의 구조를 정의합니다.
<!-- end list -->

C#

// SControl.Common/CommandPacket.cs
using System;

namespace SControl.Common
{
    /// <summary>
    /// 제어 프로그램과 SAgentM 에이전트 간 통신에 사용될 기본 명령 패킷입니다.
    /// 일반적으로 JSON으로 직렬화되어 전송됩니다.
    /// </summary>
    public class CommandPacket
    {
        public Guid PacketId { get; set; }
        public CommandInstruction Instruction { get; set; }
        public string CommandName { get; set; }
        public string PayloadJson { get; set; } // Newtonsoft.Json 등으로 직렬화된 JSON 문자열

        public string FinalTargetIpForRelayedCommand { get; set; }
        public int? FinalTargetPortForRelayedCommand { get; set; } // 고정 포트 4026 사용 예정

        public DateTime TimestampUtc { get; set; }

        public string ResponseAddress { get; set; } // 응답을 받을 주소 (Flask 앱 IP 등)
        public int? ResponsePort { get; set; }      // 응답을 받을 포트 (Flask 앱 포트 등)

        public CommandPacket()
        {
            PacketId = Guid.NewGuid();
            TimestampUtc = DateTime.UtcNow;
        }
    }
}
5. LocalDeviceControl.cs
Windows API 호출(P/Invoke)을 사용하여 로컬 PC의 모니터 전원을 즉시 제어하는 함수를 제공합니다.
<!-- end list -->

C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 클래스 사용

namespace SControl.Common
{
    public static class LocalDeviceControl
    {
        private const int HWND_BROADCAST = 0xFFFF;   
        private const uint WM_SYSCOMMAND = 0x0112;   
        private const uint SC_MONITORPOWER = 0xF170; 

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd, IntPtr Msg, UIntPtr wParam, IntPtr lParam,
            SendMessageTimeoutFlags fuFlags, uint uTimeout, out UIntPtr lpdwResult);

        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0, SMTO_BLOCK = 0x1, SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8, SMTO_ERRORONEXIT = 0x20
        }

        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }
            IntPtr lParam = (IntPtr)action;
            UIntPtr commandResultPlaceholder;
            IntPtr apiCallResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST, (uint)WM_SYSCOMMAND, (UIntPtr)SC_MONITORPOWER, lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, out commandResultPlaceholder);

            if (apiCallResult == IntPtr.Zero) 
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0) 
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (요청 동작: {action}). Win32 오류 코드: {errorCode}");
                }
            }
        }
    }
}
6. Properties/AssemblyInfo.cs (기본 템플릿)
어셈블리의 메타데이터를 정의합니다.
<!-- end list -->

C#

// SControl.Common/Properties/AssemblyInfo.cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

[assembly: AssemblyTitle("SControl.Common")]
[assembly: AssemblyDescription("SControl 시스템 공용 라이브러리")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("YourCompany")] // 사용자 회사명으로 변경
[assembly: AssemblyProduct("SControl Suite")]
[assembly: AssemblyCopyright("Copyright © YourCompany 2025")] // 연도 및 회사명 변경
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]
[assembly: ComVisible(false)]
[assembly: Guid("YOUR-UNIQUE-GUID-FOR-SCONTROL-COMMON-PROJECT")] // <<--- 새 GUID로 교체하거나 프로젝트 생성 시 자동 할당된 값 사용
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
중요: AssemblyInfo.cs 파일의 Guid 부분은 사용자님의 SControl.Common 프로젝트에 맞게 고유한 값으로 설정되어 있어야 합니다 (Visual Studio에서 프로젝트 생성 시 보통 자동으로 할당됩니다).

이것이 SControl.Common 라이브러리의 전체 최종 코드입니다.
SAgentM.App 프로젝트에서 이 SControl.Common 프로젝트를 참조하고, AgentCoreService.cs 파일 상단에 using SControl.Common; 지시문이 있는지 다시 한번 확인해주십시오.