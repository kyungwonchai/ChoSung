이제 확실히 이해했습니다. 요청에 따라:

MAG_NO가 PO_NO의 첫 파일이면 1, 마지막 파일이면 (PO_PLAN_QTY == PO_PROD_QTY) 3, 그 외에는 2로 처리.
처음 실행 시 10개의 로그 파일 목록을 추가하고, 각 로그 항목에 1, 2, 3 중 하나의 값을 추가하여 해당 컬럼에 표시.
새로 들어오는 로그 파일에 대해서는 해당 파라미터를 임의 함수로 넘겨주고 실행.
작업 목록에 8개의 인자를 표시하고, 상태에 따라 행 배경색을 다음과 같이 설정:
완료: 녹색
대기: 스카이블루
기존 파일: 회색
에러: 빨간색
파일 구조
plaintext
코드 복사
ProjectRoot/
│
├── Models/
│   ├── LogEntry.cs        # 로그 파일에서 읽어온 데이터를 담는 모델
│   ├── TaskModel.cs       # 작업 모델
│   └── TaskQueue.cs       # 작업 큐
│
├── Services/
│   ├── FileProcessor.cs   # 파일 처리 및 감시
│   └── PlcCommunication.cs # PLC 통신
│
├── ViewModels/
│   └── MainViewModel.cs   # 메인 뷰모델
│
├── Views/
│   ├── MainWindow.xaml    # 메인 윈도우 UI
│   └── MainWindow.xaml.cs # 메인 윈도우 코드비하인드
│
├── App.xaml               # WPF 애플리케이션 설정
└── App.xaml.cs            # 애플리케이션 시작 코드
LogEntry.cs (로그 파일에서 데이터를 읽어오는 모델)
Models/LogEntry.cs

csharp
코드 복사
public class LogEntry
{
    public string FileName { get; set; }  // 파일명
    public string MAG_NO { get; set; }    // MAG_NO (고유)
    public string PO_NO { get; set; }     // PO_NO
    public int PO_PLAN_QTY { get; set; }  // 계획 수량
    public int PO_PROD_QTY { get; set; }  // 생산 수량
    public int MAG_QTY { get; set; }      // MAG_NO별 수량
    public string BASIC_MODEL { get; set; }  // 기본 모델
    public string MODEL_CODE { get; set; }   // 모델 코드
    public int SequenceFlag { get; set; }    // 1: 첫 파일, 2: 중간 파일, 3: 마지막 파일
}
FileProcessor.cs (파일 처리 및 감시)
Services/FileProcessor.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Timers;

public class FileProcessor
{
    private readonly string _logFolder;  // 로그 파일이 저장된 폴더 경로
    private readonly PlcCommunication _plcCommunication;  // PLC 통신 클래스 참조
    private List<string> _processedFiles = new List<string>();  // 이미 처리한 파일명 저장
    private DateTime _lastProcessedFileTime;  // 마지막으로 처리한 파일의 시간
    private Timer _fileCheckTimer;
    private Dictionary<string, List<LogEntry>> _poFiles = new Dictionary<string, List<LogEntry>>(); // PO별 파일 관리

    public event Action<LogEntry> NewFileDetected;  // 파일이 감지되면 발생하는 이벤트

    public FileProcessor(string logFolder, PlcCommunication plcCommunication)
    {
        _logFolder = logFolder;
        _plcCommunication = plcCommunication;
        _lastProcessedFileTime = DateTime.MinValue;  // 기본값으로 설정

        // 5초마다 파일을 감시하는 타이머 설정
        _fileCheckTimer = new Timer(5000);
        _fileCheckTimer.Elapsed += CheckForNewFiles;
        _fileCheckTimer.Start();
    }

    /// <summary>
    /// 파일명에서 연월일시분초.fff 값을 추출하여 DateTime으로 변환합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var datePart = Path.GetFileNameWithoutExtension(fileName).Split('_')[1];
        return DateTime.ParseExact(datePart, "yyyyMMddHHmmssfff", CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 마지막 파일 시간 이후에 생성된 파일만 처리합니다.
    /// </summary>
    private void CheckForNewFiles(object sender, ElapsedEventArgs e)
    {
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderBy(f => ExtractDateTimeFromFileName(f))
            .ToList();

        foreach (var file in files)
        {
            var fileTime = ExtractDateTimeFromFileName(file);

            if (fileTime > _lastProcessedFileTime)
            {
                // 로그 파일을 파싱하여 LogEntry 생성
                var logEntry = ParseFile(file);

                // 시퀀스 플래그 설정: 첫 파일(1), 중간 파일(2), 마지막 파일(3)
                logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

                // 이벤트 발생 및 PLC 통신 트리거
                NewFileDetected?.Invoke(logEntry);

                // PLC 신호 전송
                _plcCommunication.SendSignalForFile(file);

                // 마지막 처리 시간 업데이트
                _lastProcessedFileTime = fileTime;

                // 처리된 파일 기록
                _processedFiles.Add(Path.GetFileName(file));

                // PO별로 파일을 관리 (시퀀스 관리)
                if (!_poFiles.ContainsKey(logEntry.PO_NO))
                {
                    _poFiles[logEntry.PO_NO] = new List<LogEntry>();
                }
                _poFiles[logEntry.PO_NO].Add(logEntry);
            }
        }
    }

    /// <summary>
    /// 로그 파일을 읽어 LogEntry 모델로 변환합니다.
    /// </summary>
    private LogEntry ParseFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);

        var logEntry = new LogEntry
        {
            FileName = Path.GetFileName(filePath),
            MAG_NO = GetValueFromLine(lines, "MAG_NO"),
            PO_NO = GetValueFromLine(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(GetValueFromLine(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(GetValueFromLine(lines, "PO_PROD_QTY")),
            MAG_QTY = int.Parse(GetValueFromLine(lines, "MAG_QTY")),
            BASIC_MODEL = GetValueFromLine(lines, "BASIC_MODEL"),
            MODEL_CODE = GetValueFromLine(lines, "MODEL_CODE")
        };

        return logEntry;
    }

    /// <summary>
    /// 파일에서 특정 키에 해당하는 값을 추출합니다.
    /// </summary>
    private string GetValueFromLine(string[] lines, string key)
    {
        var line = lines.FirstOrDefault(l => l.Contains(key));
        return line?.Split('=')[1].Trim('\'');
    }

    /// <summary>
    /// PO_NO별 첫 파일(1), 마지막 파일(3), 중간 파일(2) 판단
    /// </summary>
    private int DetermineSequenceFlag(LogEntry logEntry)
    {
        if (!_poFiles.ContainsKey(logEntry.PO_NO))
        {
            // 첫 파일이면 1 반환
            return 1;
        }

        // 이미 파일이 있는 경우, 생산 수량과 계획 수량이 같으면 마지막 파일로 처리 (3)
        var poFiles = _poFiles[logEntry.PO_NO];
        if (logEntry.PO_PLAN_QTY == logEntry.PO_PROD_QTY)
        {
            return 3; // 마지막 파일
        }

        return 2; // 중간 파일
    }
}
TaskModel.cs (작업 모델)
Models/TaskModel.cs

csharp
코드 복사
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsCancelled { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand CancelCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        StartCommand = new RelayCommand(StartTask);
        CancelCommand = new RelayCommand(CancelTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;

        var success = await _taskQueue.ExecuteTaskQueue(PONumber);

        Status = success ? "Completed" : "Failed";
        IsCompleted = success;
        IsError = !success;
        IsRunning = false;
    }

    private void CancelTask()
    {
        _taskQueue.Cancel();
        Status = "Cancelled";
        IsCancelled = true;
    }
}
MainWindow.xaml (UI 변경)
Views/MainWindow.xaml

xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />

                <!-- 작업 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Task Status" Binding="{Binding Status}" Width="2*" />
            </DataGrid.Columns>

            <!-- DataGrid Row 스타일을 변경하여 작업 상태에 따른 배경 색상을 지정합니다 -->
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Style.Triggers>
                        <!-- 완료된 작업은 녹색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCompleted}" Value="True">
                            <Setter Property="Background" Value="LightGreen"/>
                        </DataTrigger>
                        <!-- 에러가 발생한 작업은 빨간색 배경으로 -->
                        <DataTrigger Binding="{Binding IsError}" Value="True">
                            <Setter Property="Background" Value="Red"/>
                        </DataTrigger>
                        <!-- 취소된 작업은 흰색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCancelled}" Value="True">
                            <Setter Property="Background" Value="White"/>
                        </DataTrigger>
                        <!-- 진행 중인 작업은 스카이블루 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="True">
                            <Setter Property="Background" Value="SkyBlue"/>
                        </DataTrigger>
                        <!-- 초기 10개는 회색 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="False">
                            <Setter Property="Background" Value="LightGray"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>

        <!-- 모든 작업을 취소하는 버튼 -->
        <Button Content="Cancel All" Command="{Binding CancelAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
    </Grid>
</Window>
MainViewModel.cs (ViewModel)
ViewModels/MainViewModel.cs

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;
    private FileProcessor _fileProcessor;

    public ICommand CancelAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        _taskQueue = new TaskQueue();

        // PLC 통신 클래스 생성
        var plcCommunication = new PlcCommunication();

        // 파일 처리 클래스 생성 (경로와 PLC 통신 클래스 전달)
        _fileProcessor = new FileProcessor(@"C:\Logs", plcCommunication);

        // 파일 감지 이벤트 연결
        _fileProcessor.NewFileDetected += OnNewFileDetected;

        CancelAllCommand = new RelayCommand(CancelAllTasks);
    }

    /// <summary>
    /// 새로운 파일이 감지되었을 때 호출되는 메서드.
    /// </summary>
    private void OnNewFileDetected(LogEntry logEntry)
    {
        var taskModel = new TaskModel(logEntry, _taskQueue, true);
        TaskList.Add(taskModel);
    }

    /// <summary>
    /// 모든 작업을 취소합니다.
    /// </summary>
    private void CancelAllTasks()
    {
        _taskQueue.CancelAll();
        foreach (var task in TaskList)
        {
            task.Status = "Cancelled";
        }
    }
}
요약:
**FileProcessor.cs**에서 PO_NO에 대한 첫 파일(1), 중간 파일(2), 마지막 파일(3)을 계산해 SequenceFlag로 추가.
**TaskModel.cs**에서 작업 상태와 함께 MAG_NO, PO_NO를 포함한 모든 정보를 DataGrid에 표시.
**MainViewModel.cs**에서는 파일이 감지될 때마다 작업이 추가되고, 해당 작업의 상태에 따라 행 배경색이 변경됨.
DataGrid는 완료된 작업은 녹색, 대기 중인 작업은 스카이블루, 에러가 발생한 작업은 빨간색, 그리고 처음 10개의 작업은 회색으로 표시됨