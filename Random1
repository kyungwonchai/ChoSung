네, 알겠습니다. SAgentM (에이전트) 프로그램을 WPF 애플리케이션으로 구성하고, 최근 로그 (최대 50개)를 UI에 표시하는 기능을 포함하여 이어서 진행하겠습니다.

SAgentM이 WPF 애플리케이션이 되면 다음과 같은 특징을 가집니다:

사용자 인터페이스 (UI): 에이전트가 실행 중인 PC에 UI가 표시됩니다. 이 UI를 통해 현재 상태, 연결 정보, 로그 등을 보여줄 수 있고, 필요한 경우 간단한 로컬 제어 기능을 넣을 수도 있습니다.
실행 컨텍스트: 일반적으로 사용자가 로그인한 세션에서 실행됩니다. 자동 시작을 위해서는 시작 프로그램 등록 등의 방법이 필요합니다.
리소스: 콘솔 앱이나 Windows Service에 비해 UI로 인해 약간의 리소스를 더 사용할 수 있습니다.
이러한 변경 사항을 고려하여 SAgentM의 구조와 코드를 설계하겠습니다.

우선, SAgentM_Configurations 데이터베이스 테이블 DDL 재확인
SAgentM의 구체적인 구현에 앞서, SControlM이 이 SAgentM들을 관리하기 위해 사용할 데이터베이스 테이블 스키마를 다시 한번 확인하고 넘어가겠습니다. 이전에 제안드렸던 DDL입니다.

SQL

-- SAgentM_Configurations 테이블 생성 (SQL Server 기준)
IF OBJECT_ID('dbo.SAgentM_Configurations', 'U') IS NOT NULL
    DROP TABLE dbo.SAgentM_Configurations;
GO

CREATE TABLE dbo.SAgentM_Configurations (
    ConfigID INT IDENTITY(1,1) PRIMARY KEY,             -- 고유 식별자 (자동 증가)
    DisplayName NVARCHAR(100) NOT NULL,                 -- UI에 표시될 PC(SAgentM)의 이름 (예: "개발팀 모니터 1")
    
    -- 직접 연결 또는 첫 번째 릴레이 SAgentM 정보
    PrimaryIPAddress VARCHAR(50) NOT NULL,              -- 직접 제어 SAgentM의 IP 또는 첫 번째 릴레이 SAgentM의 IP
    PrimaryPort INT NOT NULL,                           -- PrimaryIPAddress의 SAgentM 포트

    -- 릴레이를 사용하는 경우 최종 목적지 SAgentM 정보
    IsRelay BIT NOT NULL DEFAULT 0,                     -- 이 SAgentM 설정이 릴레이를 사용하는지 여부 (0: 직접, 1: 릴레이)
    FinalTargetIPAddress VARCHAR(50) NULL,              -- (IsRelay=1 일 때) 최종 목적지 SAgentM의 IP
    FinalTargetPort INT NULL,                           -- (IsRelay=1 일 때) 최종 목적지 SAgentM의 포트

    Description NVARCHAR(255) NULL,                     -- 추가 설명
    IsEnabled BIT NOT NULL DEFAULT 1,                   -- 이 설정의 사용 여부 (기본값: 사용)
    DateCreated DATETIME2 NOT NULL DEFAULT GETUTCDATE(),  -- 레코드 생성일 (UTC)
    LastModified DATETIME2 NOT NULL DEFAULT GETUTCDATE()  -- 레코드 최종 수정일 (UTC)
);

-- 인덱스 추가 (조회 성능 향상 목적)
-- 활성화된 설정 중 이름은 고유해야 할 경우 등에 사용
IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'UQ_SAgentM_DisplayName_Enabled' AND object_id = OBJECT_ID('dbo.SAgentM_Configurations'))
BEGIN
    CREATE UNIQUE INDEX UQ_SAgentM_DisplayName_Enabled ON dbo.SAgentM_Configurations (DisplayName) WHERE IsEnabled = 1;
END

IF NOT EXISTS (SELECT * FROM sys.indexes WHERE name = 'IX_SAgentM_PrimaryIPAddress' AND object_id = OBJECT_ID('dbo.SAgentM_Configurations'))
BEGIN
    CREATE INDEX IX_SAgentM_PrimaryIPAddress ON dbo.SAgentM_Configurations (PrimaryIPAddress);
END

-- 테이블 설명 추가 (SQL Server)
IF NOT EXISTS (SELECT * FROM sys.fn_listextendedproperty(N'MS_Description', N'SCHEMA', N'dbo', N'TABLE', N'SAgentM_Configurations', NULL, NULL))
BEGIN
    EXEC sys.sp_addextendedproperty 
        @name=N'MS_Description', @value=N'SControlM에서 제어할 SAgentM PC들의 설정 정보',
        @level0type=N'SCHEMA', @level0name=N'dbo', 
        @level1type=N'TABLE',  @level1name=N'SAgentM_Configurations';
END
GO
변경점:

RelayToFinalTarget 컬럼명을 IsRelay로 좀 더 명확하게 변경했습니다.
인덱스 및 테이블 설명 추가 시 IF NOT EXISTS 구문을 사용하여 반복 실행 시 오류가 발생하지 않도록 했습니다.
이 DDL에 동의하시면, 이제 SAgentM WPF 애플리케이션의 기본 구조와 로그 기능을 포함한 코드를 작성 시작하겠습니다.

SAgentM (WPF 애플리케이션) 프로젝트
이 프로젝트는 SControl.Common 프로젝트를 참조합니다.

1. LogEntry.cs (로그 항목 데이터 모델)

로그에 표시될 각 항목의 구조를 정의합니다.
<!-- end list -->

C#

// SAgentM/Models/LogEntry.cs (Models 폴더를 만들어 관리하는 것을 권장)
using System;

namespace SAgentM.Models
{
    public class LogEntry
    {
        public DateTime Timestamp { get; }
        public string Message { get; }
        public LogLevel Level { get; } // 정보, 경고, 오류 등을 구분하기 위한 LogLevel (아래 정의)

        public LogEntry(string message, LogLevel level = LogLevel.Information)
        {
            Timestamp = DateTime.Now;
            Message = message;
            Level = level;
        }

        public override string ToString()
        {
            return $"[{Timestamp:yyyy-MM-dd HH:mm:ss.fff}] [{Level}] {Message}";
        }
    }

    public enum LogLevel
    {
        Debug,
        Information,
        Warning,
        Error,
        Fatal
    }
}
2. LoggingService.cs (로그 관리 서비스)

로그를 수집하고, 최근 50개 로그만 유지하며, UI 바인딩을 위한 ObservableCollection을 제공합니다.
<!-- end list -->

C#

// SAgentM/Services/LoggingService.cs (Services 폴더를 만들어 관리하는 것을 권장)
using SAgentM.Models; // LogEntry, LogLevel 사용
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Data; // BindingOperations 사용

namespace SAgentM.Services
{
    public class LoggingService : INotifyPropertyChanged
    {
        private const int MaxLogEntries = 50;
        private readonly ObservableCollection<LogEntry> _logEntries = new ObservableCollection<LogEntry>();
        private readonly object _lock = new object(); // 멀티스레드 환경에서 컬렉션 접근 동기화

        public ObservableCollection<LogEntry> LogEntries => _logEntries;

        public LoggingService()
        {
            // UI 스레드에서 컬렉션 변경이 일어나도록 설정 (WPF 필수)
            BindingOperations.EnableCollectionSynchronization(_logEntries, _lock);
        }

        public void AddLog(string message, LogLevel level = LogLevel.Information)
        {
            AddLog(new LogEntry(message, level));
        }

        public void AddLog(LogEntry logEntry)
        {
            lock (_lock)
            {
                if (_logEntries.Count >= MaxLogEntries)
                {
                    _logEntries.RemoveAt(0); // 가장 오래된 로그 제거
                }
                _logEntries.Add(logEntry);
            }
            // PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(nameof(LogEntries))); // ObservableCollection은 자동으로 UI 업데이트
        }

        // INotifyPropertyChanged 구현 (필요한 경우 다른 속성 알림용)
        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
3. MainViewModel.cs (WPF 주 창의 ViewModel)

UI에 표시될 데이터(상태, 로그)와 UI 관련 로직을 담당합니다. (MVVM 패턴)
<!-- end list -->

C#

// SAgentM/ViewModels/MainViewModel.cs (ViewModels 폴더를 만들어 관리하는 것을 권장)
using SAgentM.Models; // LogEntry 사용
using SAgentM.Services; // LoggingService 사용
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows; // Application.Current.Dispatcher 사용

namespace SAgentM.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private string _statusMessage = "Initializing...";
        private string _listeningAddress = "Not listening";
        private int _listeningPort = 0; // 실제 포트 번호

        public LoggingService Logger { get; }

        public string StatusMessage
        {
            get => _statusMessage;
            set => SetField(ref _statusMessage, value);
        }

        public string ListeningAddress
        {
            get => _listeningAddress;
            set => SetField(ref _listeningAddress, value);
        }
        
        public int ListeningPort
        {
            get => _listeningPort;
            set => SetField(ref _listeningPort, value);
        }

        public ObservableCollection<LogEntry> Logs => Logger.LogEntries;

        public MainViewModel()
        {
            Logger = new LoggingService(); // LoggingService 인스턴스 생성
            // 초기 로그
            Logger.AddLog("SAgentM ViewModel initialized.", LogLevel.Debug);
        }
        
        // UI 스레드에서 안전하게 속성을 업데이트하기 위한 메서드
        public void UpdateStatusOnUiThread(string message)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                StatusMessage = message;
            });
        }

        public void UpdateListeningInfoOnUiThread(string address, int port)
        {
             Application.Current.Dispatcher.Invoke(() =>
            {
                ListeningAddress = address;
                ListeningPort = port;
                Logger.AddLog($"Now listening on {address}:{port}", LogLevel.Information);
            });
        }


        // INotifyPropertyChanged 구현
        public event PropertyChangedEventHandler? PropertyChanged;
        protected virtual void OnPropertyChanged([CallerMemberName] string? propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
        protected bool SetField<T>(ref T field, T value, [CallerMemberName] string? propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
4. MainWindow.xaml (WPF 주 창 UI 정의)

에이전트 상태와 로그를 표시합니다.
<!-- end list -->

XML

<Window x:Class="SAgentM.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:SAgentM"
        xmlns:viewModels="clr-namespace:SAgentM.ViewModels"
        mc:Ignorable="d"
        Title="SAgentM - Agent Application" Height="450" Width="800"
        WindowStartupLocation="CenterScreen">
    <Window.DataContext>
        <viewModels:MainViewModel/>
    </Window.DataContext>
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>

        <StackPanel Grid.Row="0" Orientation="Vertical" Margin="0,0,0,10">
            <TextBlock Text="SAgentM Status" FontSize="18" FontWeight="Bold"/>
            <StackPanel Orientation="Horizontal">
                 <TextBlock Text="Listening on: " FontWeight="SemiBold"/>
                 <TextBlock Text="{Binding ListeningAddress}"/>
                 <TextBlock Text=":"/>
                 <TextBlock Text="{Binding ListeningPort}"/>
            </StackPanel>
            <TextBlock Text="{Binding StatusMessage}" Margin="0,5,0,0"/>
        </StackPanel>
        
        <TextBlock Grid.Row="1" Text="Recent Logs (Max 50)" FontWeight="SemiBold" Margin="0,0,0,5"/>
        <ListView Grid.Row="2" ItemsSource="{Binding Logs}" AlternationCount="2" BorderThickness="1" BorderBrush="LightGray">
            <ListView.ItemContainerStyle>
                <Style TargetType="ListViewItem">
                    <Setter Property="HorizontalContentAlignment" Value="Stretch"/>
                </Style>
            </ListView.ItemContainerStyle>
            <ListView.ItemTemplate>
                <DataTemplate>
                    <Grid Margin="2">
                        <Grid.ColumnDefinitions>
                            <ColumnDefinition Width="Auto"/> <ColumnDefinition Width="Auto"/> <ColumnDefinition Width="*"/>    </Grid.ColumnDefinitions>
                        <TextBlock Grid.Column="0" Text="{Binding Timestamp, StringFormat='{}{0:yyyy-MM-dd HH:mm:ss.fff}'}" Margin="0,0,10,0" Foreground="DarkGray"/>
                        <TextBlock Grid.Column="1" FontWeight="SemiBold" Margin="0,0,10,0">
                            <TextBlock.Style>
                                <Style TargetType="TextBlock">
                                    <Setter Property="Text" Value="{Binding Level, StringFormat='[{0}]'}"/>
                                    <Style.Triggers>
                                        <DataTrigger Binding="{Binding Level}" Value="Error">
                                            <Setter Property="Foreground" Value="Red"/>
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding Level}" Value="Warning">
                                            <Setter Property="Foreground" Value="OrangeRed"/>
                                        </DataTrigger>
                                         <DataTrigger Binding="{Binding Level}" Value="Fatal">
                                            <Setter Property="Foreground" Value="DarkRed"/>
                                            <Setter Property="FontWeight" Value="Bold"/>
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding Level}" Value="Information">
                                            <Setter Property="Foreground" Value="DarkGreen"/>
                                        </DataTrigger>
                                        <DataTrigger Binding="{Binding Level}" Value="Debug">
                                            <Setter Property="Foreground" Value="DarkSlateGray"/>
                                        </DataTrigger>
                                    </Style.Triggers>
                                </Style>
                            </TextBlock.Style>
                        </TextBlock>
                        <TextBlock Grid.Column="2" Text="{Binding Message}" TextWrapping="Wrap"/>
                    </Grid>
                </DataTemplate>
            </ListView.ItemTemplate>
        </ListView>
    </Grid>
</Window>
5. MainWindow.xaml.cs (WPF 주 창 코드 비하인드)

ViewModel 초기화 및 창 관련 로직 (예: 종료 시 리소스 정리).
<!-- end list -->

C#

// SAgentM/MainWindow.xaml.cs
using SAgentM.ViewModels; // MainViewModel 사용
using System.ComponentModel; // CancelEventArgs 사용
using System.Windows;

namespace SAgentM
{
    public partial class MainWindow : Window
    {
        // 소켓 리스너 등 백그라운드 서비스 객체 (추후 구현)
        private AgentCoreService? _agentCoreService; // AgentCoreService는 소켓 리스닝, 명령 처리 등을 담당할 클래스 (다음 단계에서 설계)

        public MainWindow()
        {
            InitializeComponent();
            // DataContext는 XAML에서 설정했으므로 여기서 ViewModel을 직접 참조하려면 아래와 같이 할 수 있습니다.
            // var viewModel = DataContext as MainViewModel;
            // if (viewModel != null)
            // {
            //    // ViewModel을 사용하는 초기화 로직
            // }
        }

        protected override async void OnContentRendered(EventArgs e)
        {
            base.OnContentRendered(e);
            if (DataContext is MainViewModel viewModel)
            {
                // 여기에 SAgentM의 핵심 로직(소켓 리스닝 시작 등)을 초기화하고 시작하는 코드를 넣습니다.
                // 예: _agentCoreService = new AgentCoreService(viewModel.Logger, viewModel);
                //     await _agentCoreService.StartAsync(port: 12345); // 설정 파일에서 포트 번호 읽어오도록 변경 필요
                
                // 임시로 상태 업데이트 및 로그 추가
                viewModel.UpdateStatusOnUiThread("Agent core service starting...");
                viewModel.Logger.AddLog("Agent UI rendered. Attempting to start core services.", Models.LogLevel.Information);
                // 다음 단계: AgentCoreService 구현 및 여기서 시작
            }
        }
        
        protected override async void OnClosing(CancelEventArgs e)
        {
            // 애플리케이션 종료 시 리소스 정리 (예: 소켓 닫기)
            if (DataContext is MainViewModel viewModel)
            {
                viewModel.Logger.AddLog("SAgentM is shutting down...", Models.LogLevel.Information);
            }

            if (_agentCoreService != null)
            {
                // e.Cancel = true; // 필요한 경우 비동기 종료 작업 동안 창 닫기를 막음
                // await _agentCoreService.StopAsync();
                // e.Cancel = false;
            }
            base.OnClosing(e);
        }
    }
}
6. App.xaml.cs (애플리케이션 시작 지점)

전역 예외 처리 등을 설정할 수 있습니다. (기본 생성된 코드에서 크게 수정할 필요는 없을 수 있음)
<!-- end list -->

C#

// SAgentM/App.xaml.cs
using System.Windows;

namespace SAgentM
{
    public partial class App : Application
    {
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // 전역 예외 처리기 설정 (옵션)
            // Current.DispatcherUnhandledException += App_DispatcherUnhandledException;
            // AppDomain.CurrentDomain.UnhandledException += CurrentDomain_UnhandledException;
        }

        // private void CurrentDomain_UnhandledException(object sender, UnhandledExceptionEventArgs e)
        // {
        //     // 비 UI 스레드에서 발생하는 처리되지 않은 예외
        //     // 여기서 로깅하거나 사용자에게 알릴 수 있음
        //     // var viewModel = (MainWindow.DataContext as MainViewModel);
        //     // viewModel?.Logger.AddLog($"FATAL (Non-UI Thread): {e.ExceptionObject}", Models.LogLevel.Fatal);
        //     // MessageBox.Show($"Unhandled non-UI exception: {e.ExceptionObject}", "Critical Error", MessageBoxButton.OK, MessageBoxImage.Error);
        // }

        // private void App_DispatcherUnhandledException(object sender, System.Windows.Threading.DispatcherUnhandledExceptionEventArgs e)
        // {
        //     // UI 스레드에서 발생하는 처리되지 않은 예외
        //     // var viewModel = (MainWindow.DataContext as MainViewModel);
        //     // viewModel?.Logger.AddLog($"FATAL (UI Thread): {e.Exception.Message}", Models.LogLevel.Fatal);
        //     // MessageBox.Show($"Unhandled UI exception: {e.Exception.Message}", "Application Error", MessageBoxButton.OK, MessageBoxImage.Error);
        //     // e.Handled = true; // true로 설정하면 애플리케이션이 강제 종료되지 않을 수 있음 (주의)
        // }
    }
}
다음 단계:
위 코드는 SAgentM WPF 애플리케이션의 UI와 로깅을 위한 기본 골격입니다.
이제 가장 중요한 부분인 실제 네트워크 통신(AgentSocketListener.cs) 및 명령 처리(CommandHandler.cs 또는 이 둘을 합친 AgentCoreService.cs) 로직을 설계하고 구현해야 합니다. 이 부분에서 SControl.Common의 CommandPacket을 수신하고, LocalDeviceControl을 사용하며, LoggingService를 통해 로그를 남기게 됩니다.
