네, 맞습니다. models.py를 수정하고 데이터베이스를 초기화한 것은 카테고리 기능을 위한 '기반 공사'를 한 것이고, 아직 화면에 보이거나 실제로 카테고리를 추가하고 게시글에 연결하는 '상부 구조물'(애플리케이션 로직 및 UI)은 만들지 않았기 때문에 기존과 동일하게 보이는 것이 정상입니다.

이제부터 카테고리를 실제로 추가하고 관리하며, 게시글 작성/수정 시 카테고리를 선택하고, 카테고리별로 게시글을 볼 수 있도록 관련 파일들을 수정하고 새로운 파일들을 추가해 나가겠습니다.

가장 먼저, 애플리케이션의 로직을 담당하는 app.py 파일을 수정하겠습니다. 여기에 카테고리 관리(생성, 수정, 삭제)를 위한 라우트, 게시글 작성/수정 시 카테고리 정보를 처리하는 로직, 그리고 카테고리별 게시글을 보여주는 라우트 등을 추가합니다.

flask_board/app.py (카테고리 기능 추가된 전체 코드)

Python

import os
from flask import (
    Flask, render_template, request, redirect, url_for, flash, session, jsonify, abort
)
from werkzeug.utils import secure_filename
from datetime import datetime, timezone, timedelta
import uuid
import re # re 모듈 임포트 확인
from functools import wraps

# 사용자 정의 모듈 임포트
from config import Config
from models import db, Post, Category # Category 모델 임포트 추가

app = Flask(__name__)
app.config.from_object(Config)
db.init_app(app)

upload_folder_path = app.config['UPLOAD_FOLDER']
if not os.path.exists(upload_folder_path):
    try:
        os.makedirs(upload_folder_path)
        print(f"Created upload folder: {upload_folder_path}")
    except OSError as e:
        app.logger.error(f"Error creating upload folder {upload_folder_path}: {e}")

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

# --- 인증 관련 ---
def is_admin_logged_in():
    return session.get('is_admin_logged_in', False)

@app.context_processor
def inject_admin_status_and_global_vars():
    all_categories = Category.query.order_by(Category.name).all()
    return dict(
        is_admin=is_admin_logged_in(),
        now=datetime.now(timezone.utc),
        all_categories=all_categories # 모든 템플릿에서 카테고리 목록 사용 가능
    )

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin_logged_in():
            flash('이 작업을 수행하려면 로그인이 필요합니다.', 'warning')
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    if is_admin_logged_in():
        return redirect(url_for('index'))
    if request.method == 'POST':
        password = request.form.get('password')
        if password == app.config['ADMIN_PASSWORD']:
            session['is_admin_logged_in'] = True
            session.permanent = True
            app.permanent_session_lifetime = timedelta(days=7)
            flash('로그인되었습니다.', 'success')
            next_url = request.args.get('next')
            return redirect(next_url or url_for('index'))
        else:
            flash('잘못된 비밀번호입니다.', 'danger')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('is_admin_logged_in', None)
    flash('로그아웃되었습니다.', 'info')
    return redirect(url_for('index'))

# --- 게시판 라우트 ---
@app.route('/')
def index():
    page = request.args.get('page', 1, type=int)
    posts_pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination)

@app.route('/post/<string:slug>')
def view_post(slug):
    post_instance = Post.query.filter_by(slug=slug).first_or_404()
    return render_template('view_post.html', post=post_instance)

@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    categories = Category.query.order_by(Category.name).all() # 카테고리 목록 가져오기
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        category_id = request.form.get('category_id') # category_id 값 받기

        if not title or not content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content, categories=categories, post=None, selected_category_id=category_id)

        # category_id가 빈 문자열인 경우 None으로 처리 (카테고리 선택 안 함)
        processed_category_id = int(category_id) if category_id and category_id.isdigit() else None

        try:
            new_post_obj = Post(title=title, content=content, category_id=processed_category_id)
            db.session.add(new_post_obj)
            db.session.commit()
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating post: {e}")
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', title=title, content=content, categories=categories, post=None, selected_category_id=category_id)

    return render_template('edit_post.html', categories=categories, post=None, selected_category_id=None)

@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()
    categories = Category.query.order_by(Category.name).all() # 카테고리 목록 가져오기
    
    # GET 요청 시 현재 게시글의 카테고리 ID를 selected_category_id로 설정
    selected_category_id = post_to_edit.category_id if request.method == 'GET' else None

    if request.method == 'POST':
        original_title = post_to_edit.title
        
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content')
        category_id = request.form.get('category_id') # category_id 값 받기
        selected_category_id = category_id # POST 요청 시 사용자가 선택한 값을 유지

        if not post_to_edit.title or not post_to_edit.content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', post=post_to_edit, categories=categories, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

        processed_category_id = int(category_id) if category_id and category_id.isdigit() else None
        post_to_edit.category_id = processed_category_id

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title) # slugify 호출 방식 수정
        
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit()
            flash('게시글이 성공적으로 수정되었습니다.', 'success')
            return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing post {slug}: {e}")
            flash(f'게시글 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', post=post_to_edit, categories=categories, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

    return render_template('edit_post.html', post=post_to_edit, categories=categories, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

@app.route('/delete/<string:slug>', methods=['POST'])
@admin_required
def delete_post(slug):
    post_to_delete = Post.query.filter_by(slug=slug).first_or_404()
    try:
        db.session.delete(post_to_delete)
        db.session.commit()
        flash('게시글이 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting post {slug}: {e}")
        flash(f'게시글 삭제 중 오류가 발생했습니다: {str(e)}', 'danger')
    return redirect(url_for('index'))

# --- 이미지 업로드 ---
@app.route('/upload_image', methods=['POST'])
@admin_required
def upload_image():
    if 'file' not in request.files:
        return jsonify({'error': {'message': 'No file part in the request'}}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': {'message': 'No file selected for uploading'}}), 400

    if file and allowed_file(file.filename):
        original_filename = secure_filename(file.filename)
        filename_prefix = str(uuid.uuid4())[:8]
        base, ext = os.path.splitext(original_filename)
        safe_base = re.sub(r'[^\w-]', '', base)[:50] # 정규식 re 임포트 필요
        filename = f"{filename_prefix}_{safe_base}{ext}"
        
        # 파일명 중복 방지 로직 강화
        counter = 1
        temp_filename_to_check = filename 
        while os.path.exists(os.path.join(app.config['UPLOAD_FOLDER'], temp_filename_to_check)):
            temp_filename_to_check = f"{filename_prefix}_{safe_base}_{counter}{ext}"
            counter += 1
        filename = temp_filename_to_check
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)

        try:
            file.save(filepath)
            # Flask 2.x 이상에서는 _external=True 가 상대 경로로 url_for를 사용할 때 필요할 수 있습니다.
            # 일반적으로 static 파일은 상대경로로도 잘 동작합니다.
            image_url = url_for('static', filename=f'uploads/{filename}') # _external=True 제거 또는 상황에 맞게 사용
            return jsonify({'location': image_url})
        except Exception as e:
            app.logger.error(f"Image upload failed: {e}")
            return jsonify({'error': {'message': f'Image upload failed: {str(e)}'}}), 500
    else:
        return jsonify({'error': {'message': f'Allowed file types are {app.config["ALLOWED_EXTENSIONS"]}'}}), 400

# --- 카테고리 관리 라우트 ---
@app.route('/admin/categories')
@admin_required
def admin_categories():
    # 카테고리 목록은 context_processor에서 all_categories로 이미 전달됨
    # return render_template('admin_categories.html', categories=categories)
    return render_template('admin_categories.html') # context_processor 사용

@app.route('/admin/category/new', methods=['GET', 'POST'])
@admin_required
def new_category():
    if request.method == 'POST':
        name = request.form.get('name')
        if not name:
            flash('카테고리 이름을 입력해주세요.', 'warning')
        else:
            try:
                # 중복 카테고리 이름 체크
                existing_category = Category.query.filter_by(name=name).first()
                if existing_category:
                    flash('이미 존재하는 카테고리 이름입니다.', 'warning')
                else:
                    category = Category(name=name)
                    db.session.add(category)
                    db.session.commit()
                    flash(f'카테고리 "{name}"이(가) 성공적으로 추가되었습니다.', 'success')
                    return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error creating category: {e}")
                flash(f'카테고리 추가 중 오류가 발생했습니다: {str(e)}', 'danger')
        # POST 요청에서 오류 발생 시, 입력값을 유지하며 폼을 다시 보여주기 위해 name 전달
        return render_template('edit_category.html', category_name=name, category=None) # category=None으로 새 카테고리임을 명시

    return render_template('edit_category.html', category=None, category_name='') # GET 요청 시

@app.route('/admin/category/edit/<int:category_id>', methods=['GET', 'POST'])
@admin_required
def edit_category(category_id):
    category_to_edit = Category.query.get_or_404(category_id)
    if request.method == 'POST':
        new_name = request.form.get('name')
        if not new_name:
            flash('카테고리 이름을 입력해주세요.', 'warning')
        elif new_name == category_to_edit.name: # 이름 변경이 없을 경우
             flash('변경된 내용이 없습니다.', 'info')
             return redirect(url_for('admin_categories'))
        else:
            try:
                # 변경하려는 이름이 다른 카테고리에 이미 사용 중인지 확인 (자기 자신 제외)
                existing_category = Category.query.filter(Category.name == new_name, Category.id != category_id).first()
                if existing_category:
                    flash('이미 존재하는 카테고리 이름입니다.', 'warning')
                else:
                    original_name = category_to_edit.name
                    category_to_edit.name = new_name
                    category_to_edit.slug = category_to_edit._generate_unique_slug(new_name) # 슬러그 재생성
                    db.session.commit()
                    flash(f'카테고리 "{original_name}"이(가) "{new_name}"(으)로 성공적으로 수정되었습니다.', 'success')
                    return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error editing category {category_id}: {e}")
                flash(f'카테고리 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
        # POST 요청에서 오류 발생 시, 입력값을 유지하며 폼을 다시 보여주기 위해 new_name 전달
        return render_template('edit_category.html', category=category_to_edit, category_name=new_name)

    return render_template('edit_category.html', category=category_to_edit, category_name=category_to_edit.name) # GET 요청 시

@app.route('/admin/category/delete/<int:category_id>', methods=['POST'])
@admin_required
def delete_category(category_id):
    category_to_delete = Category.query.get_or_404(category_id)
    if category_to_delete.posts_in_category.count() > 0: # 카테고리에 속한 게시글이 있는지 확인
        flash(f'카테고리 "{category_to_delete.name}"에 속한 게시글이 있어 삭제할 수 없습니다. 해당 게시글들의 카테고리를 먼저 변경해주세요.', 'danger')
        return redirect(url_for('admin_categories'))
    try:
        db.session.delete(category_to_delete)
        db.session.commit()
        flash(f'카테고리 "{category_to_delete.name}"이(가) 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting category {category_id}: {e}")
        flash(f'카테고리 삭제 중 오류가 발생했습니다: {str(e)}', 'danger')
    return redirect(url_for('admin_categories'))

# --- 카테고리별 게시글 보기 ---
@app.route('/category/<string:slug>')
def posts_by_category(slug):
    category = Category.query.filter_by(slug=slug).first_or_404()
    page = request.args.get('page', 1, type=int)
    # 카테고리에 속한 게시글들을 시간 역순으로 정렬하여 페이지네이션
    # Post 모델의 'category' 관계(relationship)를 사용하여 필터링
    # posts_pagination = Post.query.filter_by(category_id=category.id).order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    # 또는 Category 모델의 'posts_in_category' 관계를 사용하여 접근
    posts_pagination = category.posts_in_category.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    
    # index.html 템플릿을 재사용하되, 카테고리 정보를 추가로 전달
    return render_template('index.html', posts_pagination=posts_pagination, current_category=category)


# --- 데이터베이스 초기화 CLI 명령어 ---
@app.cli.command('init-db')
def init_db_cli_command():
    """Clear existing data and create new tables."""
    with app.app_context():
        db.drop_all()
        db.create_all()
    print('Initialized the database.')

_db_initialized_flag = False
@app.before_request
def ensure_tables_exist():
    global _db_initialized_flag
    if not _db_initialized_flag:
        with app.app_context():
            db.create_all()
        _db_initialized_flag = True


if __name__ == '__main__':
    # 앱 컨텍스트 내에서 db.create_all() 호출은 @app.before_request 에서 처리하므로 중복될 수 있음.
    # 다만, CLI로 직접 실행 시 명시적으로 호출하는 것은 나쁘지 않음.
    with app.app_context():
        db.create_all()
    app.run(debug=True, host='0.0.0.0', port=5000)
app.py 변경 사항 요약:

Category 모델 임포트.
@app.context_processor 수정: all_categories를 모든 템플릿에 전달하여 카테고리 목록을 어디서든 쉽게 표시할 수 있게 함.
new_post 및 edit_post 라우트:
DB에서 모든 카테고리를 가져와 edit_post.html 템플릿으로 전달합니다.
폼에서 전송된 category_id를 받아 게시글 저장 시 반영합니다.
카테고리가 선택되지 않은 경우(None 또는 빈 문자열)를 처리합니다.
카테고리 관리 라우트 추가 (모두 @admin_required 적용):
/admin/categories: 카테고리 목록 및 관리 페이지.
/admin/category/new: 새 카테고리 생성.
/admin/category/edit/<int:category_id>: 기존 카테고리 수정.
/admin/category/delete/<int:category_id>: 카테고리 삭제 (단, 해당 카테고리에 속한 게시물이 없을 경우에만 삭제).
카테고리별 게시글 보기 라우트 추가:
/category/<string:slug>: 특정 카테고리에 속한 게시글들을 보여줍니다. index.html 템플릿을 재활용할 수 있도록 구성.
upload_image에서 url_for의 _external=True를 제거하거나 필요에 따라 사용 (일반적으로 static 파일에는 불필요). re 모듈 임포트 확인.
이 app.py 파일은 카테고리 기능의 핵심 로직을 담고 있습니다.
다음으로 이 로직들과 상호작용할 템플릿 파일들 (.html) 을 수정하고 새로 만들어야 합니다.
