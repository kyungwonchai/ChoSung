해했습니다. **FNL^**은 묶음 작업의 완료를 나타내며, FNL^ 이후에 PLAN Selected 또는 **JD^**가 어떤 순서로 오는지에 따라 배출(out) 또는 적재(stack) 상태로 주문을 처리해야 한다는 점을 분명히 하겠습니다.

구현 내용:
FNL^ 이후:
PLAN Selected가 먼저 감지되면 이전 주문을 배출(out) 처리하고, 새로운 주문은 wait 상태로 추가합니다.
**JD^**가 먼저 감지되면 이전 주문을 적재(stack) 처리합니다.
새로운 주문이 감지되면, 항상 wait 상태로 추가되고, FNL^ 이후의 처리가 완료될 때까지 기다려야 합니다.
수정된 코드 (FileCheckerMES20.cs)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileCheckerMES20
    {
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 위치한 디렉토리 경로
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$"; // 파일명 패턴 정의
        private DispatcherTimer _timer; // 주기적으로 파일을 체크하기 위한 타이머
        private string _currentMonitoredFile; // 현재 감시 중인 파일 경로
        private DateTime _lastPlanSelectedDate; // 마지막으로 PLAN Selected가 감지된 시간
        private DateTime _lastWriteTime; // 마지막으로 파일이 수정된 시간
        private ProductOrderModel _currentProductOrder; // 현재 처리 중인 주문 정보
        private ProductOrderModel _previousProductOrder; // 배출할 주문 정보 (이전 주문)
        private ObservableCollection<ProductOrderModel> _productOrders; // 주문 목록을 저장하는 컬렉션
        private long _lastPlanSelectedPosition; // 파일에서 마지막 PLAN Selected 위치
        private bool _isFirstExecution; // 프로그램의 첫 실행 여부를 나타내는 플래그
        private ComportManager _comPortPLC; // ComportManager 객체
        private DateTime _programStartTime; // 프로그램이 시작된 시간

        // 추가: FNL^ 이후의 처리 순서를 위한 플래그
        private bool _isFNLDetected; // FNL^이 감지되었는지 여부
        private bool _pendingAction; // FNL^ 이후 PLAN Selected나 JD^을 기다리는 플래그

        // 생성자: FileCheckerMES20 객체를 생성하고 초기화
        public FileCheckerMES20(ObservableCollection<ProductOrderModel> productOrders, ComportManager comPortManager)
        {
            _productOrders = productOrders; // 주문 목록 컬렉션을 받아 초기화
            _comPortPLC = comPortManager; // ComportManager 인스턴스를 초기화
            _isFirstExecution = true; // 첫 실행 여부를 true로 설정
            _programStartTime = DateTime.Now; // 프로그램 시작 시간을 현재 시간으로 설정
            _isFNLDetected = false; // FNL^ 감지 여부 초기화
            _pendingAction = false; // PLAN Selected 또는 JD^ 대기 상태로 설정

            // 타이머를 1초마다 실행되도록 설정
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 타이머가 작동할 때마다 CheckFiles 실행
            _timer.Start(); // 타이머 시작

            // 로그 출력: 타이머가 시작되었음을 알림
            msgvs.Instance.LogT2("FileCheckerMES20: 타이머가 시작되었습니다.");

            // 현재 감시할 가장 최신 로그 파일을 설정
            _currentMonitoredFile = GetLatestLogFile();
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 시간을 MinValue로 설정

            // 로그 출력: 파일 감시 시작 알림
            msgvs.Instance.LogT2($"FileCheckerMES20: {_currentMonitoredFile} 파일 감시를 시작합니다.");
            _lastPlanSelectedDate = DateTime.Now; // 마지막 PLAN Selected 시간을 현재 시간으로 설정
            _lastPlanSelectedPosition = 0; // 파일의 위치를 0으로 초기화
        }

        // 타이머에 의해 1초마다 호출되어 파일의 변경 여부를 확인
        private void CheckFiles(object sender, EventArgs e)
        {
            // 가장 최신 로그 파일을 가져옴
            string latestFile = GetLatestLogFile();

            // 현재 감시 중인 파일이 없거나 새로운 파일이 감지되면 변경
            if (_currentMonitoredFile == null || latestFile != _currentMonitoredFile)
            {
                _currentMonitoredFile = latestFile; // 새로운 파일을 감시하도록 설정
                _lastWriteTime = File.GetLastWriteTime(_currentMonitoredFile); // 파일의 마지막 수정 시간을 업데이트

                // 로그 출력: 새로운 파일 감시 시작
                msgvs.Instance.LogT2($"FileCheckerMES20: 새로운 파일 감시 시작 -> {_currentMonitoredFile}");
            }

            // 첫 실행일 경우, 파일에서 마지막 PLAN Selected 위치를 찾음
            if (_isFirstExecution)
            {
                FindLastPlanSelected(_currentMonitoredFile); // PLAN Selected 위치 찾기
                _isFirstExecution = false; // 첫 실행 플래그를 false로 설정

                // 로그 출력: PLAN Selected 탐색 완료 알림
                msgvs.Instance.LogT2("FileCheckerMES20: PLAN Selected 탐색 완료.");
            }

            // 현재 감시 중인 파일의 마지막 수정 시간을 가져옴
            DateTime latestWriteTime = File.GetLastWriteTime(_currentMonitoredFile);

            // 파일이 수정되었을 경우 파일을 다시 읽음
            if (latestWriteTime > _lastWriteTime)
            {
                _lastWriteTime = latestWriteTime; // 마지막 수정 시간을 업데이트
                ReadLogFileFromPosition(_currentMonitoredFile); // 수정된 파일을 읽고 처리

                // 로그 출력: 파일 수정 감지 알림
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 수정 감지 -> {_currentMonitoredFile}");
            }
        }

        // 로그 파일 디렉토리에서 가장 최신 로그 파일을 반환
        private string GetLatestLogFile()
        {
            // 로그 출력: 최신 로그 파일 검색 중
            msgvs.Instance.LogT2("FileCheckerMES20: 최신 로그 파일 검색 중...");

            // 디렉토리 내의 로그 파일 목록을 필터링하고 최신 파일을 선택
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 파일 패턴과 일치하는 파일만 선택
                .OrderByDescending(f => f.LastWriteTime) // 최근 수정된 파일을 기준으로 정렬
                .ToList();

            return logFiles.FirstOrDefault()?.FullName; // 가장 최신 파일 경로 반환
        }

        // 파일을 처음부터 읽고, 마지막으로 나오는 PLAN Selected의 위치를 찾음
        private void FindLastPlanSelected(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 실행 중단

            try
            {
                // 파일을 읽기 전용 모드로 열고 다른 프로세스가 쓸 수 있도록 공유 설정
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    string line;
                    long currentPosition = 0; // 현재 파일의 위치를 추적
                    _lastPlanSelectedPosition = 0; // PLAN Selected 위치 초기화

                    // 파일의 각 줄을 읽음
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        currentPosition = fileStream.Position; // 파일 포인터 위치 저장

                        // PLAN Selected를 찾으면 해당 위치 저장
                        if (line.Contains("PLAN Selected"))
                        {
                            _lastPlanSelectedPosition = currentPosition; // PLAN Selected 위치 저장

                            // 로그 출력: PLAN Selected 감지
                            msgvs.Instance.LogT2($"FileCheckerMES20: PLAN Selected 감지 (위치: {currentPosition})");
                        }

                        // 로그 줄 처리
                        ProcessLogLine(line, filePath, false); // 첫 실행 시 배출 동작은 하지 않고 표에만 표시
                    }
                }
            }
            catch (IOException ex)
            {
                // 파일 읽기 오류가 발생하면 로그 출력
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 읽기 중 오류 발생 -> {ex.Message}");
            }
        }

        // PLAN Selected 이후부터 파일을 읽고 처리 (새로운 로그 처리만 수행)
        private void ReadLogFileFromPosition(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 실행 중단

            try
            {
                // 파일을 읽기 모드로 열고 공유 설정
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    // 파일 포인터를 마지막 PLAN Selected 위치로 이동
                    fileStream.Seek(_lastPlanSelectedPosition, SeekOrigin.Begin);

                    string line;
                    
                    // 파일의 각 줄을 읽음
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        // 새로운 로그가 현재 시간 이후에 기록된 것만 처리
                        if (File.GetLastWriteTime(filePath) > _programStartTime)
                        {
                            ProcessLogLine(line, filePath, true); // 새로운 로그에 대해서는 동작 수행
                        }
                    }

                    _lastPlanSelectedPosition = fileStream.Position; // 파일의 최신 위치 저장

                    // 로그 출력: 파일 처리 완료
                    msgvs.Instance.LogT2($"FileCheckerMES20: 파일 처리 완료 -> {_currentMonitoredFile}");
                }
            }
            catch (IOException ex)
            {
                // 파일 읽기 오류 발생 시 로그 출력
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 읽기 중 오류 발생 -> {ex.Message}");
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        private void ProcessLogLine(string line, string filePath, bool shouldProcessOut)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath); // 파일명에서 확장자를 제외한 이름을 가져옴
            string dayString = fileName.Substring(fileName.Length - 2); // 파일명의 마지막 두 자리를 날짜로 사용
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도와 월을 가져옴 (yyyyMM 형식)
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 연월일을 조합

            // 로그 행에서 시간값(시분초.밀리초)을 추출
            string timestamp = ExtractTimestamp(line);

            // PLAN Selected 감지 시 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 분리하여 PLAN Selected 뒤의 주문 번호를 추출
                string productOrder = splitLine[1]; // 주문 번호

                if (timestamp != null)
                {
                    // 시분초.밀리초 값을 연월일과 결합하여 최종 시간값을 생성 (yyyyMMdd HH:mm:ss.밀리초)
                    string fullDateTime = fullDate + " " + timestamp;

                    // 로그 출력: PLAN Selected 감지 및 시간값 출력
                    msgvs.Instance.LogT2($"FileCheckerMES20: PLAN Selected 감지 (주문 번호: {productOrder}, 시간: {fullDateTime})");

                    // 새로운 주문이거나 다른 주문일 경우 처리
                    if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                    {
                        // **이전 주문을 배출 처리**
                        if (_previousProductOrder != null)
                        {
                            if (shouldProcessOut) // 프로그램 실행 이후의 로그만 배출 처리
                            {
                                _previousProductOrder.POStatus = "out"; // 이전 주문의 상태를 배출로 설정
                                ExecuteOutFunction(_previousProductOrder); // 배출 함수 호출
                                msgvs.Instance.LogT2($"FileCheckerMES20: 이전 주문 배출 처리 -> 주문 번호: {_previousProductOrder.ProductOrder}");
                            }
                            else
                            {
                                // 프로그램 실행 전에 읽은 로그는 배출하지 않고 표에만 표시
                                _previousProductOrder.POStatus = "out (이미 배출됨)";
                                msgvs.Instance.LogT2($"FileCheckerMES20: 이미 배출된 주문 -> 주문 번호: {_previousProductOrder.ProductOrder}");
                            }
                        }

                        // 새로운 ProductOrderModel 생성
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder, // 주문 번호 설정
                            PDate = fullDateTime, // 생성된 날짜와 시간 설정
                            POStatus = "wait" // **새로운 주문은 항상 wait 상태로 시작**
                        };

                        _previousProductOrder = _currentProductOrder; // 현재 주문을 이전 주문으로 설정

                        // 주문 정보를 주문 목록에 추가
                        _productOrders.Add(_currentProductOrder);

                        // 로그 출력: 새로운 주문 추가 및 UI 갱신
                        msgvs.Instance.LogT2($"FileCheckerMES20: 새로운 주문 추가 -> 주문 번호: {productOrder}");
                        msgvs.Instance.LogT2("FileCheckerMES20: 표를 갱신합니다.");
                    }
                }

                // FNL^ 이후 PLAN Selected가 먼저 감지되었을 경우에도 현재 주문은 wait 상태로 유지
                _isFNLDetected = false; // FNL^ 플래그 초기화
                _pendingAction = false; // PLAN Selected 또는 JD^ 대기 상태 초기화
                _lastPlanSelectedDate = DateTime.Now; // 마지막 PLAN Selected 시간을 현재 시간으로 설정
            }
            // FNL^ 감지 시 처리
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                _isFNLDetected = true; // FNL^ 감지 플래그 설정
                _pendingAction = true; // PLAN Selected 또는 JD^ 대기 상태로 설정

                // 로그 출력: FNL^ 감지 알림
                msgvs.Instance.LogT2("FileCheckerMES20: FNL^ 감지");

                // **현재 주문은 여전히 wait 상태로 유지** (배출/적재 조건에 따라 변경 예정)
            }
            // JD^ 감지 시 처리
            else if (line.Contains("JD^") && _currentProductOrder != null)
            {
                if (_isFNLDetected && _pendingAction) // FNL^ 이후 JD^가 먼저 감지됨
                {
                    _previousProductOrder.POStatus = "stack"; // 이전 주문 상태를 적재(stack)로 변경
                    ExecuteStackFunction(_previousProductOrder); // 적재 함수 호출
                    msgvs.Instance.LogT2("FileCheckerMES20: JD^ 이후 적재 처리.");
                    _isFNLDetected = false;
                    _pendingAction = false; // 플래그 초기화
                }
            }
            // BasicModel 감지 시 처리
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                var modelData = line.Split(':')[1].Trim(); // BasicModel 데이터를 추출
                _currentProductOrder.BasicModel = modelData; // 주문의 BasicModel 설정

                // 로그 출력: BasicModel 처리 알림
                msgvs.Instance.LogT2($"FileCheckerMES20: BasicModel 처리 -> {modelData}");
            }
            // MB^ 감지 시 처리
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                var mbData = line.Split('^'); // MB^ 데이터를 처리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 설정
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 수량 설정

                // 로그 출력: MB^ 처리 알림
                msgvs.Instance.LogT2($"FileCheckerMES20: MB^ 처리 -> 잔여 수량: {_currentProductOrder.PORemain}, 매거진 수량: {_currentProductOrder.MGCount}");
            }
            // JB^ 감지 시 처리
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가

                // 로그 출력: JB^ 처리 알림
                msgvs.Instance.LogT2($"FileCheckerMES20: JB^ 처리 -> 생산된 제품 개수: {_currentProductOrder.PCount}");
            }
        }

        // 시간값을 추출하는 함수 (6자리 시분초와 3자리 밀리초 형태를 분리)
        private string ExtractTimestamp(string line)
        {
            // 정규식을 통해 [000041.089] 형태의 시간값을 추출
            var match = Regex.Match(line, @"\[(\d{6})\.(\d{3})\]");
            if (match.Success)
            {
                string timePart = match.Groups[1].Value; // 시분초 (000041)
                string millisPart = match.Groups[2].Value; // 밀리초 (089)

                // 시분초를 시:분:초 형식으로 변환 (000041 -> 00:00:41)
                string hours = timePart.Substring(0, 2); // 시
                string minutes = timePart.Substring(2, 2); // 분
                string seconds = timePart.Substring(4, 2); // 초

                // 최종 형식: HH:mm:ss.밀리초
                return $"{hours}:{minutes}:{seconds}.{millisPart}";
            }
            return null; // 시간값이 없을 경우 null 반환
        }

        // 배출 처리를 위한 함수
        private void ExecuteOutFunction(ProductOrderModel order)
        {
            // 배출 처리 로직 구현
            msgvs.Instance.LogT2($"FileCheckerMES20: 배출 처리 완료 -> 주문 번호: {order.ProductOrder}");
        }

        // 적재 처리를 위한 함수
        private void ExecuteStackFunction(ProductOrderModel order)
        {
            // 적재 처리 로직 구현
            msgvs.Instance.LogT2($"FileCheckerMES20: 적재 처리 완료 -> 주문 번호: {order.ProductOrder}");
        }
    }

    // 제품 주문 정보를 저장하는 모델 클래스 (INotifyPropertyChanged 구현)
    public class ProductOrderModel : INotifyPropertyChanged
    {
        private string _productOrder;
        private string _basicModel;
        private int _poRemain;
        private int _mgCount;
        private int _pCount;
        private string _poStatus;
        private string _pDate;

        public string ProductOrder
        {
            get => _productOrder;
            set
            {
                _productOrder = value;
                OnPropertyChanged(nameof(ProductOrder));
            }
        }

        public string BasicModel
        {
            get => _basicModel;
            set
            {
                _basicModel = value;
                OnPropertyChanged(nameof(BasicModel));
            }
        }

        public int PORemain
        {
            get => _poRemain;
            set
            {
                _poRemain = value;
                OnPropertyChanged(nameof(PORemain));
            }
        }

        public int MGCount
        {
            get => _mgCount;
            set
            {
                _mgCount = value;
                OnPropertyChanged(nameof(MGCount));
            }
        }

        public int PCount
        {
            get => _pCount;
            set
            {
                _pCount = value;
                OnPropertyChanged(nameof(PCount));
            }
        }

        public string POStatus
        {
            get => _poStatus;
            set
            {
                _poStatus = value;
                OnPropertyChanged(nameof(POStatus));
            }
        }

        public string PDate
        {
            get => _pDate;
            set
            {
                _pDate = value;
                OnPropertyChanged(nameof(PDate));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // 프로퍼티가 변경될 때마다 UI에 알림을 보냄
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항:
FNL^ 이후 처리 로직:

PLAN Selected가 감지되면 이전 주문을 배출하고, 새로운 주문은 wait 상태로 추가합니다.
**JD^**가 먼저 감지되면 이전 주문을 적재(stack) 처리합니다.
wait 상태:

새로운 주문이 추가되면 항상 wait 상태로 시작하고, 배출/적재 여부는 FNL^ 이후의 처리에 따라 결정됩니다.
이제 FNL^ 이후 PLAN Selected 또는 **JD^**의 감지에 따라 정확하게 배출 또는 적재가 처리됩