텍스트 위치를 일치시키기 위해 TextBox의 텍스트와 TextBlock의 텍스트를 동일하게 유지하면서, TextBlock의 배경 색상을 변경하여 일치하지 않는 부분을 강조하는 방법을 사용해보겠습니다. 이렇게 하면 입력된 텍스트와 비교 결과가 정확히 동일한 위치에 표시될 수 있습니다.

1. XAML 설정
TextBox와 TextBlock을 겹쳐 놓기 위해 Grid를 사용합니다. TextBox는 입력을 받고, TextBlock은 배경 색상 변경을 위한 텍스트를 표시합니다.

xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        mc:Ignorable="d"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <TextBox Name="g_searchTextBox1" Width="200" Margin="10" VerticalAlignment="Top" HorizontalAlignment="Left"/>
        <Grid Width="200" Height="100" Margin="10,50,0,0" VerticalAlignment="Top" HorizontalAlignment="Left">
            <TextBox Name="g_textBoxA" TextChanged="TextBoxA_TextChanged"/>
            <TextBlock Name="g_textBlockOverlay" Background="Transparent" IsHitTestVisible="False" TextWrapping="Wrap" />
        </Grid>
        <Button Name="g_loadButton1" Content="Load Data" Width="100" Height="30" Margin="220,10,0,0" VerticalAlignment="Top" HorizontalAlignment="Left" Click="LoadButton_Click"/>
        <dxg:GridControl Name="g_gridControl1" AutoGenerateColumns="False" ItemsSource="{Binding}" Margin="0,150,0,0">
            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="Column1" Header="Column 1" Width="100"/>
                <dxg:GridColumn FieldName="Column2" Header="Column 2" Width="150"/>
                <dxg:GridColumn FieldName="Column3" Header="Column 3" Width="200"/>
                <!-- 필요한 만큼 열 추가 -->
            </dxg:GridControl.Columns>
            <dxg:GridControl.View>
                <dxg:TableView AutoWidth="False" CellValueChanged="TableView_CellValueChanged"/>
            </dxg:GridControl.View>
        </dxg:GridControl>
    </Grid>
</Window>
2. C# 코드 설정
TextBox의 값을 변경할 때 TextBlock에 배경 색상을 설정하여 비교 결과를 표시합니다.

csharp
코드 복사
using System;
using System.Data;
using System.Data.SqlClient;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Documents;
using System.Windows.Media;
using DevExpress.Xpf.Grid;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private DataTable g_dataTable1;
        private SqlDataAdapter g_dataAdapter1;
        private SqlCommandBuilder g_commandBuilder1;
        private string g_connectionString1 = "your_connection_string_here";
        private string g_selectQuery1 = "SELECT * FROM Table_UFS_DRAM";

        public MainWindow()
        {
            InitializeComponent();
            g_searchTextBox1.TextChanged += SearchTextBox_TextChanged;
            (g_gridControl1.View as TableView).RowUpdated += TableView_RowUpdated;
        }

        private void LoadButton_Click(object sender, RoutedEventArgs e)
        {
            LoadData();
        }

        private void LoadData()
        {
            using (SqlConnection g_connection1 = new SqlConnection(g_connectionString1))
            {
                g_dataAdapter1 = new SqlDataAdapter(g_selectQuery1, g_connection1);
                g_commandBuilder1 = new SqlCommandBuilder(g_dataAdapter1);

                g_dataTable1 = new DataTable();
                g_dataAdapter1.Fill(g_dataTable1);

                // 명령을 명시적으로 설정
                g_dataAdapter1.UpdateCommand = g_commandBuilder1.GetUpdateCommand();
                g_dataAdapter1.InsertCommand = g_commandBuilder1.GetInsertCommand();
                g_dataAdapter1.DeleteCommand = g_commandBuilder1.GetDeleteCommand();

                g_gridControl1.ItemsSource = g_dataTable1.DefaultView;
            }
        }

        private void TableView_CellValueChanged(object sender, CellValueChangedEventArgs e)
        {
            UpdateDatabase();
        }

        private void UpdateDatabase()
        {
            try
            {
                using (SqlConnection g_connection1 = new SqlConnection(g_connectionString1))
                {
                    g_dataAdapter1.UpdateCommand.Connection = g_connection1;
                    g_dataAdapter1.InsertCommand.Connection = g_connection1;
                    g_dataAdapter1.DeleteCommand.Connection = g_connection1;

                    g_connection1.Open();
                    g_dataAdapter1.Update(g_dataTable1);
                }
            }
            catch (Exception ex)
            {
                MessageBox.Show("Error updating database: " + ex.Message);
            }
        }

        private void SearchTextBox_TextChanged(object sender, TextChangedEventArgs e)
        {
            if (g_dataTable1 != null)
            {
                string g_filter1 = g_searchTextBox1.Text;
                (g_gridControl1.ItemsSource as DataView).RowFilter = $"ColumnName LIKE '%{g_filter1}%'";
            }
        }

        private void TextBoxA_TextChanged(object sender, TextChangedEventArgs e)
        {
            string inputText = g_textBoxA.Text;
            string dbValue = GetUFSMARKFromDatabase(g_searchTextBox1.Text);

            if (!string.IsNullOrEmpty(dbValue))
            {
                CompareAndHighlightText(g_textBoxA, g_textBlockOverlay, inputText, dbValue);
            }
            else
            {
                g_textBlockOverlay.Text = string.Empty; // 데이터베이스 값이 없으면 오버레이 초기화
            }
        }

        private string GetUFSMARKFromDatabase(string input)
        {
            string result = string.Empty;
            string query = "SELECT UFSMARK FROM Table_UFS_DRAM WHERE SomeColumn = @input";

            using (SqlConnection connection = new SqlConnection(g_connectionString1))
            {
                SqlCommand command = new SqlCommand(query, connection);
                command.Parameters.AddWithValue("@input", input);

                connection.Open();
                object dbResult = command.ExecuteScalar();
                if (dbResult != null)
                {
                    result = dbResult.ToString();
                }
            }

            return result;
        }

        private void CompareAndHighlightText(TextBox textBox, TextBlock textBlock, string inputText, string dbValue)
        {
            textBlock.Text = inputText;
            textBlock.Inlines.Clear();
            int minLength = Math.Min(inputText.Length, dbValue.Length);

            for (int i = 0; i < minLength; i++)
            {
                if (inputText[i] == dbValue[i])
                {
                    textBlock.Inlines.Add(new Run(inputText[i].ToString()));
                }
                else
                {
                    textBlock.Inlines.Add(new Run(inputText[i].ToString()) { Background = Brushes.Yellow });
                }
            }

            // 남은 문자 처리
            if (inputText.Length > dbValue.Length)
            {
                for (int i = dbValue.Length; i < inputText.Length; i++)
                {
                    textBlock.Inlines.Add(new Run(inputText[i].ToString()) { Background = Brushes.Yellow });
                }
            }
        }
    }
}
주요 변경 사항
XAML: TextBox와 TextBlock을 겹쳐 놓기 위해 Grid를 사용합니다. TextBox는 입력을 받고, TextBlock은 배경 색상을 통해 텍스트를 강조합니다.
TextBoxA_TextChanged: TextBox의 값이 변경될 때마다 TextBlock에 결과를 표시합니다.
CompareAndHighlightText: TextBox의 텍스트를 가져와 TextBlock에 배경 색상을 설정하여 일치하지 않는 부분을 강조합니다.
이 변경 사항을 통해 TextBox에서 입력을 받을 수 있으며, 동시에 TextBlock을 사용하여 텍스트를 서식화하고 일치하지 않는 부분의 배경을 강조할 수 있습니다. 이를 통해 텍스트의 위치가 일치하면서도 서식