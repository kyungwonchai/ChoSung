래는 **TreeListControl**을 사용하여 MSSQL2014에서 데이터를 가져와 트리 구조를 표시하고, 기존의 LineGroup, LineName을 바탕으로 구현한 코드입니다. 구역과 라인의 체크박스를 동기화하도록 설계되었습니다.

XAML 코드
xml
코드 복사
<Window x:Class="TreeListExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
        Title="Line Group Viewer" Height="600" Width="800">
    <Grid>
        <dxg:TreeListControl x:Name="treeListControl"
                             AutoExpandAllNodes="True"
                             AutoGenerateColumns="None"
                             KeyFieldName="LineId"
                             ParentFieldName="GroupId"
                             ItemsSource="{Binding LineData}">
            <dxg:TreeListControl.Columns>
                <!-- 체크박스 컬럼 -->
                <dxg:TreeListColumn FieldName="IsChecked" Header="선택">
                    <dxg:TreeListColumn.EditSettings>
                        <dxg:CheckEditSettings />
                    </dxg:TreeListColumn.EditSettings>
                </dxg:TreeListColumn>

                <!-- 그룹 또는 라인 이름 -->
                <dxg:TreeListColumn FieldName="DisplayName" Header="구역/라인 이름" />
            </dxg:TreeListControl.Columns>
        </dxg:TreeListControl>
    </Grid>
</Window>
C# 코드
csharp
코드 복사
using DevExpress.Xpf.Grid;
using System;
using System.Collections.ObjectModel;
using System.Data.SqlClient;
using System.Linq;
using System.Windows;

namespace TreeListExample
{
    public partial class MainWindow : Window
    {
        public ObservableCollection<LineItem> LineData { get; set; }

        public MainWindow()
        {
            InitializeComponent();
            DataContext = this;

            // MSSQL 데이터 가져오기
            LoadLineData();

            // 이벤트 핸들러 등록
            treeListControl.CellValueChanged += TreeListControl_CellValueChanged;
        }

        private void LoadLineData()
        {
            LineData = new ObservableCollection<LineItem>();

            string connectionString = "YourConnectionStringHere";
            string query = @"
                SELECT LineId, GroupId, DisplayName, IsGroup
                FROM LineTable
                ORDER BY GroupId, LineId";

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();
                using (SqlCommand command = new SqlCommand(query, connection))
                using (SqlDataReader reader = command.ExecuteReader())
                {
                    while (reader.Read())
                    {
                        LineData.Add(new LineItem
                        {
                            LineId = reader.GetInt32(0),
                            GroupId = reader.GetInt32(1),
                            DisplayName = reader.GetString(2),
                            IsGroup = reader.GetBoolean(3),
                            IsChecked = false
                        });
                    }
                }
            }

            treeListControl.ItemsSource = LineData;
        }

        private void TreeListControl_CellValueChanged(object sender, CellValueChangedEventArgs e)
        {
            if (e.Column.FieldName == "IsChecked")
            {
                var changedItem = e.Row as LineItem;
                if (changedItem != null)
                {
                    // 자식 항목 동기화
                    UpdateChildCheckState(changedItem);

                    // 부모 항목 동기화
                    UpdateParentCheckState(changedItem);
                }
            }
        }

        private void UpdateChildCheckState(LineItem parentItem)
        {
            var childItems = LineData.Where(x => x.GroupId == parentItem.LineId).ToList();
            foreach (var child in childItems)
            {
                child.IsChecked = parentItem.IsChecked;
                UpdateChildCheckState(child);
            }
        }

        private void UpdateParentCheckState(LineItem childItem)
        {
            var parentItem = LineData.FirstOrDefault(x => x.LineId == childItem.GroupId);
            if (parentItem != null)
            {
                parentItem.IsChecked = LineData.Where(x => x.GroupId == parentItem.LineId).All(x => x.IsChecked);
                UpdateParentCheckState(parentItem);
            }
        }
    }

    public class LineItem
    {
        public int LineId { get; set; }       // 라인 ID
        public int GroupId { get; set; }     // 그룹 ID (부모 ID)
        public string DisplayName { get; set; } // 구역/라인 이름
        public bool IsGroup { get; set; }    // 그룹 여부
        public bool IsChecked { get; set; }  // 체크 상태
    }
}
SQL 테이블 구조
다음은 LineTable의 샘플 구조입니다. 이 테이블에서 그룹과 라인 데이터를 가져옵니다.

sql
코드 복사
CREATE TABLE LineTable (
    LineId INT PRIMARY KEY,         -- 라인 또는 그룹 ID
    GroupId INT,                    -- 부모 그룹 ID (최상위 그룹의 경우 0)
    DisplayName NVARCHAR(100),      -- 이름 (구역 또는 라인)
    IsGroup BIT                     -- 그룹 여부 (1: 그룹, 0: 라인)
);
데이터 예시
sql
코드 복사
INSERT INTO LineTable (LineId, GroupId, DisplayName, IsGroup)
VALUES 
    (1, 0, 'Group A', 1),
    (2, 1, 'Line 1.1', 0),
    (3, 1, 'Line 1.2', 0),
    (4, 0, 'Group B', 1),
    (5, 4, 'Line 2.1', 0),
    (6, 4, 'Line 2.2', 0);
핵심 변경 사항
네이밍 개선:

Name 대신 DisplayName을 사용하여 예약어 충돌 방지.
LineId와 GroupId로 계층 관계를 표현.
MSSQL 데이터 연동:

LoadLineData 메서드에서 데이터베이스와 연결해 데이터를 가져옴.
체크박스 동기화:

TreeListControl_CellValueChanged 이벤트에서 체크박스 상태 변경 시 자식/부모 항목의 상태를 동기화.
SQL 구조에 맞춤 설계:

IsGroup 컬럼을 통해 그룹과 라인을 구분.
실행 결과
TreeListControl에 MSSQL 데이터가 계층적으로 표시됩니다.
그룹 체크박스를 선택하면 해당 그룹의 모든 라인이 선택됩니다.