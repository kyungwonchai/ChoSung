니다. WPF MVVM에서 단순히 bool 변수 값을 다른 클래스로 주입할 경우, 그 변수 값이 변경되더라도 연동되지 않습니다. 이는 일반적인 C# 변수는 변경 통지 기능이 없기 때문입니다. 그러나 단일 값을 주입해야 한다면 INotifyPropertyChanged 인터페이스를 활용하거나, 값을 바인딩하는 방식으로 처리할 수 있습니다. 아래에서 두 가지 방법을 안내드립니다.

1. INotifyPropertyChanged를 활용한 값 연동
bool 값을 단일 변수로 주입하면서 값 변경을 감지하려면, INotifyPropertyChanged를 구현해야 합니다.

예제 코드
MainViewModel.cs

csharp
코드 복사
public class MainViewModel : INotifyPropertyChanged
{
    private bool _isTaskRunning;
    public bool IsTaskRunning
    {
        get => _isTaskRunning;
        set
        {
            if (_isTaskRunning != value)
            {
                _isTaskRunning = value;
                OnPropertyChanged(nameof(IsTaskRunning));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
AnotherClass.cs

csharp
코드 복사
public class AnotherClass
{
    private readonly MainViewModel _mainViewModel;

    public AnotherClass(MainViewModel mainViewModel)
    {
        _mainViewModel = mainViewModel;

        // MainViewModel의 IsTaskRunning 속성 변경을 감지
        _mainViewModel.PropertyChanged += (sender, args) =>
        {
            if (args.PropertyName == nameof(MainViewModel.IsTaskRunning))
            {
                Console.WriteLine($"IsTaskRunning 상태 변경됨: {_mainViewModel.IsTaskRunning}");
            }
        };
    }
}
사용 방식
csharp
코드 복사
var mainViewModel = new MainViewModel();
var anotherClass = new AnotherClass(mainViewModel);

mainViewModel.IsTaskRunning = true; // 변경 이벤트가 트리거됨
2. Dependency Injection으로 값 주입
값이 자주 변경되지 않는 경우, 생성자나 메서드를 통해 단순히 값을 전달할 수도 있습니다.

예제 코드
MainViewModel.cs

csharp
코드 복사
public class MainViewModel
{
    public bool IsTaskRunning { get; set; } = false;
}
AnotherClass.cs

csharp
코드 복사
public class AnotherClass
{
    private bool _isTaskRunning;

    public void UpdateTaskStatus(bool isTaskRunning)
    {
        _isTaskRunning = isTaskRunning;
        Console.WriteLine($"업데이트된 Task 상태: {_isTaskRunning}");
    }
}
사용 방식
csharp
코드 복사
var mainViewModel = new MainViewModel();
var anotherClass = new AnotherClass();

// 값 전달
anotherClass.UpdateTaskStatus(mainViewModel.IsTaskRunning);

// 값 변경 후 다시 주입
mainViewModel.IsTaskRunning = true;
anotherClass.UpdateTaskStatus(mainViewModel.IsTaskRunning);
3. 옵저버블 패턴 대체: 이벤트를 사용한 값 연동
옵저버블 패턴 대신 이벤트를 활용해 값 변경 시 알림을 보낼 수도 있습니다.

예제 코드
MainViewModel.cs

csharp
코드 복사
public class MainViewModel
{
    public event Action<bool> TaskStatusChanged;

    private bool _isTaskRunning;
    public bool IsTaskRunning
    {
        get => _isTaskRunning;
        set
        {
            if (_isTaskRunning != value)
            {
                _isTaskRunning = value;
                TaskStatusChanged?.Invoke(_isTaskRunning);
            }
        }
    }
}
AnotherClass.cs

csharp
코드 복사
public class AnotherClass
{
    public void Subscribe(MainViewModel viewModel)
    {
        viewModel.TaskStatusChanged += OnTaskStatusChanged;
    }

    private void OnTaskStatusChanged(bool isTaskRunning)
    {
        Console.WriteLine($"Task 상태 변경됨: {isTaskRunning}");
    }
}
사용 방식
csharp
코드 복사
var mainViewModel = new MainViewModel();
var anotherClass = new AnotherClass();

anotherClass.Subscribe(mainViewModel);

mainViewModel.IsTaskRunning = true; // 이벤트 발생
권장 방법
값이 자주 변경되고 여러 클래스에서 감지해야 한다면 **1번 방법 (INotifyPropertyChanged)**을 사용하세요.
단순히 단일 값 주입 및 변경만 필요하면 **2번 방법 (Dependency Injection)**을 선택하세요.