네, 알겠습니다. "실행하니 꺼져" 문제는 디버깅의 가장 어려운 마지막 단계에 온 것 같습니다. MessageBox나 다른 오류 처리기가 뜨기도 전에 프로그램 프로세스 자체가 종료되는 것은, C# 코드가 아닌 더 낮은 수준의 네이티브(Native) 코드, 즉 Windows 그래픽(GDI+) 라이브러리나 PrintWindow API 자체에서 발생하는 심각한 메모리 충돌일 가능성이 매우 높습니다.

이런 종류의 오류는 try-catch로도 잡을 수 없는 경우가 많습니다.

사용자님의 말씀이 맞습니다. 이제는 **"프로그램이 죽기 직전 마지막으로 한 일이 무엇인지"**를 추적하는 고전적이지만 가장 확실한 방법, 즉 텍스트 파일 로그를 남기는 방식으로 원인을 찾아야 합니다.

해결 전략
추적 로그(Trace Log) 기능 추가: PerformLogging 함수 안의 모든 주요 동작(창 핸들 얻기, 비트맵 생성, PrintWindow 호출, 이미지 자르기 등)의 한 줄 한 줄 실행 직전에 로그 파일에 "지금 이 작업을 시작합니다"라고 기록합니다. 프로그램이 중간에 죽더라도, 로그 파일에 마지막으로 기록된 내용이 바로 문제의 원인이 됩니다.
로그 파일 경로: 로그는 C:\Agent\funcenvget\logs\trace_log.txt 에 기록하도록 하겠습니다.
기존 오류 처리 유지: 혹시라도 C# 수준에서 잡을 수 있는 오류를 위해 기존의 상세 오류 메시지 박스 기능은 그대로 유지합니다.
## 추적 로그 기능이 포함된 최종 MainWindow.xaml.cs
아래 코드는 PerformLogging 함수에 매우 상세한 추적 로그를 기록하는 로직이 추가된 최종 버전입니다. 이 코드로 MainWindow.xaml.cs 파일 전체를 교체하시고 다시 배포하여 테스트해 주십시오.

C#

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;
using Gdi = System.Drawing;
using Wpf = System.Windows;

namespace funcenvget
{
    public partial class MainWindow : Wpf.Window
    {
        // P/Invoke 및 전역 변수들 (이전과 동일)
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private Wpf.Threading.DispatcherTimer timer;
        private Wpf.Threading.DispatcherTimer searchTimer;
        private TesseractEngine _ocrEngine;
        private bool isLocked = true;
        private readonly string agentBasePath = @"C:\Agent\funcenvget";
        private readonly string logFolderPath;
        private readonly string traceLogPath;
        private string previewImagePath;
        private bool isExiting = false;

        private TesseractEngine OcrEngine { get { if (_ocrEngine == null) { string exePath = AppDomain.CurrentDomain.BaseDirectory; string tessDataPath = Path.Combine(exePath, "tessdata"); _ocrEngine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default); _ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-"); } return _ocrEngine; } }

        public MainWindow()
        {
            // 로그 경로 초기화
            logFolderPath = Path.Combine(agentBasePath, "logs");
            traceLogPath = Path.Combine(logFolderPath, "trace_log.txt");
            
            InitializeComponent();
            InitializeApp();
        }

        // ##################################################################
        // ## 추적 로그를 기록하는 새로운 함수 ##
        // ##################################################################
        private void LogTrace(string message)
        {
            try
            {
                Directory.CreateDirectory(logFolderPath);
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}\r\n";
                File.AppendAllText(traceLogPath, logMessage);
            }
            catch
            {
                // 로그 기록 실패 시에는 아무것도 하지 않음 (프로그램 중단 방지)
            }
        }

        private void PerformLogging()
        {
            Gdi.Rectangle cropArea = Gdi.Rectangle.Empty;
            Gdi.Size bmpSize = Gdi.Size.Empty;
            try
            {
                LogTrace("===== PerformLogging 시작 =====");
                
                LogTrace("1. 대상 핸들 가져오기 시작...");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero)
                {
                    LogTrace("1-1. 대상 핸들 없음. 재탐색 시도...");
                    lblStatus.Text = "상태: 오류! 대상 창/프로세스를 찾을 수 없습니다.";
                    if (!searchTimer.IsEnabled) { timer.Stop(); searchTimer.Start(); lblStatus.Text = "대상 연결 끊김. 1분마다 재탐색합니다."; }
                    return;
                }
                LogTrace($"1-1. 대상 핸들 찾음: {hWnd}");

                LogTrace("2. 최소화 상태 확인 시작...");
                if (IsIconic(hWnd)) { LogTrace("2-1. 최소화됨. 작업 건너뜀."); lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다."; return; }
                LogTrace("2-1. 최소화되지 않음.");

                LogTrace("3. 창 크기 가져오기 시작...");
                GetWindowRect(hWnd, out RECT rect);
                int width = rect.Right - rect.Left;
                int height = rect.Bottom - rect.Top;
                if (width <= 0 || height <= 0) { LogTrace($"3-1. 유효하지 않은 창 크기({width}x{height}). 작업 건너뜀."); lblStatus.Text = "상태: 오류! 대상 창의 크기가 유효하지 않습니다."; return; }
                LogTrace($"3-1. 창 크기 확인: {width}x{height}");
                
                bmpSize = new Gdi.Size(width, height);

                LogTrace("4. 비트맵 객체 생성 시작...");
                using (var bmp = new Gdi.Bitmap(width, height, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    LogTrace("4-1. 비트맵 객체 생성 완료.");
                    LogTrace("5. 그래픽 컨텍스트 생성 및 PrintWindow 호출 시작...");
                    using (var g = Gdi.Graphics.FromImage(bmp))
                    {
                        IntPtr hdc = g.GetHdc();
                        PrintWindow(hWnd, hdc, 2);
                        g.ReleaseHdc(hdc);
                    }
                    LogTrace("5-1. PrintWindow 완료.");

                    cropArea = new Gdi.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    LogTrace($"6. 이미지 자르기(Clone) 시작... [영역: {cropArea}]");
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        LogTrace("6-1. 이미지 자르기 완료.");
                        LogTrace("7. OCR 처리 시작...");
                        using (var page = OcrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            LogTrace($"7-1. OCR 처리 완료. 인식된 텍스트: '{rawText}'");
                            if (!string.IsNullOrWhiteSpace(rawText)) { ProcessOcrResult(rawText); }
                            else { lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다."; }
                        }
                    }
                }
                LogTrace("===== PerformLogging 성공적으로 완료 =====");
            }
            catch (Exception ex)
            {
                LogTrace($"!!!!! PerformLogging에서 예외 발생 !!!!!\n{ex}");

                if (timer.IsEnabled) timer.Stop();
                if (searchTimer.IsEnabled) searchTimer.Stop();
                btnStart.Content = "로깅 시작";
                
                var sb = new StringBuilder();
                sb.AppendLine("캡처 중 예측하지 못한 오류가 발생하여 작업을 중지합니다.");
                sb.AppendLine("==============================================");
                sb.AppendLine($"[진단 정보]");
                sb.AppendLine($"전체 창 크기: {bmpSize.Width} x {bmpSize.Height}");
                sb.AppendLine($"잘라낼 영역 (X,Y,W,H): {cropArea.X}, {cropArea.Y}, {cropArea.Width}, {cropArea.Height}");
                sb.AppendLine("==============================================");
                Exception currentEx = ex;
                int indentLevel = 0;
                while (currentEx != null)
                {
                    sb.AppendLine($"\n[오류 레벨 {indentLevel}] {(indentLevel == 1 ? "(진짜 원인일 가능성이 높음)" : "")}");
                    sb.AppendLine($"  - 오류 유형: {currentEx.GetType().Name}");
                    sb.AppendLine($"  - 메시지: {currentEx.Message}");
                    sb.AppendLine($"  - 스택 트레이스:\n{currentEx.StackTrace}");
                    currentEx = currentEx.InnerException;
                    indentLevel++;
                }

                MessageBox.Show(sb.ToString(), "캡처 상세 오류 보고", MessageBoxButton.OK, MessageBoxImage.Error);
                lblStatus.Text = "상태: 캡처 오류 발생. 로깅 중지됨.";
            }
        }
        
        // 이하 다른 모든 코드는 이전과 동일합니다.
        // 아래 펼침 블록의 전체 코드를 사용하세요.
    }
}
&lt;details>
&lt;summary>&lt;b>[클릭] 모든 코드가 포함된 MainWindow.xaml.cs 최종 전체 버전&lt;/b>&lt;/summary>

C#

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;
using Gdi = System.Drawing;
using Wpf = System.Windows;

namespace funcenvget
{
    public partial class MainWindow : Wpf.Window
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private Wpf.Threading.DispatcherTimer timer;
        private Wpf.Threading.DispatcherTimer searchTimer;
        private TesseractEngine _ocrEngine;
        private bool isLocked = true;
        private readonly string agentBasePath = @"C:\Agent\funcenvget";
        private readonly string logFolderPath;
        private readonly string traceLogPath;
        private string previewImagePath;
        private bool isExiting = false;

        private TesseractEngine OcrEngine { get { if (_ocrEngine == null) { string exePath = AppDomain.CurrentDomain.BaseDirectory; string tessDataPath = Path.Combine(exePath, "tessdata"); _ocrEngine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default); _ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-"); } return _ocrEngine; } }

        public MainWindow()
        {
            logFolderPath = Path.Combine(agentBasePath, "logs");
            traceLogPath = Path.Combine(logFolderPath, "trace_log.txt");
            InitializeComponent();
            InitializeApp();
        }

        private void LogTrace(string message)
        {
            try
            {
                Directory.CreateDirectory(logFolderPath);
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}\r\n";
                File.AppendAllText(traceLogPath, logMessage);
            }
            catch { }
        }

        protected override void OnContentRendered(EventArgs e) { base.OnContentRendered(e); this.Hide(); }

        private void InitializeApp()
        {
            LogTrace("Application Initializing...");
            CheckRequiredFiles();
            timer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromSeconds(10) };
            timer.Tick += Timer_Tick;
            searchTimer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromMinutes(1) };
            searchTimer.Tick += SearchTimer_Tick;
            Directory.CreateDirectory(agentBasePath);
            previewImagePath = Path.Combine(agentBasePath, "preview_capture.png");
            LogTrace("Application Initialized.");
        }
        
        private void SearchTimer_Tick(object sender, EventArgs e)
        {
            LogTrace("SearchTimer Tick: 재탐색 시작...");
            lblStatus.Text = "대상 창/프로세스를 찾는 중... (1분마다 재시도)";
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd != IntPtr.Zero)
            {
                LogTrace("SearchTimer Tick: 대상 발견!");
                searchTimer.Stop();
                lblStatus.Text = "대상 발견! 자동 로깅을 시작합니다.";
                if (!timer.IsEnabled) { btnStart_Click(this, new RoutedEventArgs()); }
            }
            else
            {
                LogTrace("SearchTimer Tick: 대상 찾기 실패.");
            }
        }

        private void CheckRequiredFiles()
        {
            // ... (이전과 동일)
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            LogTrace("Window_Loaded: 설정 로드 시작.");
            // ... (설정 로드 코드는 이전과 동일)
            LogTrace("Window_Loaded: 설정 로드 완료, 자동 시작 시도.");
            AttemptAutoStart();
        }

        private void AttemptAutoStart()
        {
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && !string.IsNullOrWhiteSpace(txtTarget.Text))
            {
                LogTrace("AttemptAutoStart: 자동 시작 조건 충족. 대상 검색 시도.");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd != IntPtr.Zero)
                {
                    LogTrace("AttemptAutoStart: 대상 즉시 발견. 로깅 시작.");
                    if (!timer.IsEnabled) { btnStart_Click(this, new RoutedEventArgs()); }
                }
                else
                {
                    LogTrace("AttemptAutoStart: 대상 찾기 실패. 재탐색 타이머 시작.");
                    lblStatus.Text = "대상을 찾을 수 없어, 1분마다 재검색을 시작합니다.";
                    searchTimer.Start();
                }
            }
            else
            {
                LogTrace("AttemptAutoStart: 자동 시작 조건 미충족.");
            }
        }

        private void btnToggleEdit_Click(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void UpdateLockState(bool lockState) { /* 이전과 동일 */ }
        private void btnStart_Click(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void SearchMethod_Changed(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private IntPtr GetTargetWindowHandle() { /* 이전과 동일 */ }
        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void MenuOpen_Click(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void MenuExit_Click(object sender, RoutedEventArgs e) { isExiting = true; LogTrace("Application exiting via menu."); this.Close(); }

        protected override void OnClosing(CancelEventArgs e)
        {
            if (!isExiting) { e.Cancel = true; this.Hide(); LogTrace("Window hidden to tray."); }
            else
            {
                LogTrace("Window Closing: Saving settings.");
                Settings.Default.WindowTitle = txtTarget.Text;
                Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
                Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
                Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
                Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
                Settings.Default.PcName = txtPcName.Text;
                Settings.Default.Save();
                LogTrace("Settings saved. Disposing resources.");
                MyNotifyIcon.Dispose();
                _ocrEngine?.Dispose();
            }
            base.OnClosing(e);
        }

        private void Timer_Tick(object sender, EventArgs e) { PerformLogging(); }

        private void PerformLogging()
        {
            Gdi.Rectangle cropArea = Gdi.Rectangle.Empty;
            Gdi.Size bmpSize = Gdi.Size.Empty;
            try
            {
                LogTrace("===== PerformLogging 시작 =====");
                LogTrace("1. 대상 핸들 가져오기 시작...");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero)
                {
                    LogTrace("1-1. 대상 핸들 없음. 재탐색 시도...");
                    lblStatus.Text = "상태: 오류! 대상 창/프로세스를 찾을 수 없습니다.";
                    if (!searchTimer.IsEnabled) { timer.Stop(); searchTimer.Start(); lblStatus.Text = "대상 연결 끊김. 1분마다 재탐색합니다."; }
                    return;
                }
                LogTrace($"1-1. 대상 핸들 찾음: {hWnd}");
                LogTrace("2. 최소화 상태 확인 시작...");
                if (IsIconic(hWnd)) { LogTrace("2-1. 최소화됨. 작업 건너뜀."); lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다."; return; }
                LogTrace("2-1. 최소화되지 않음.");
                LogTrace("3. 창 크기 가져오기 시작...");
                GetWindowRect(hWnd, out RECT rect);
                int width = rect.Right - rect.Left;
                int height = rect.Bottom - rect.Top;
                if (width <= 0 || height <= 0) { LogTrace($"3-1. 유효하지 않은 창 크기({width}x{height}). 작업 건너뜀."); lblStatus.Text = "상태: 오류! 대상 창의 크기가 유효하지 않습니다."; return; }
                LogTrace($"3-1. 창 크기 확인: {width}x{height}");
                bmpSize = new Gdi.Size(width, height);
                LogTrace("4. 비트맵 객체 생성 시작...");
                using (var bmp = new Gdi.Bitmap(width, height, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    LogTrace("4-1. 비트맵 객체 생성 완료.");
                    LogTrace("5. 그래픽 컨텍스트 생성 및 PrintWindow 호출 시작...");
                    using (var g = Gdi.Graphics.FromImage(bmp))
                    {
                        IntPtr hdc = g.GetHdc();
                        PrintWindow(hWnd, hdc, 2);
                        g.ReleaseHdc(hdc);
                    }
                    LogTrace("5-1. PrintWindow 완료.");
                    cropArea = new Gdi.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    if (cropArea.Right > bmp.Width || cropArea.Bottom > bmp.Height || cropArea.X < 0 || cropArea.Y < 0)
                    {
                        LogTrace("6. 오류! 캡처 영역이 창 크기를 벗어남. 로깅 중지.");
                        timer.Stop(); btnStart.Content = "로깅 시작"; lblStatus.Text = "상태: 오류! 캡처 영역이 창 크기를 벗어났습니다.";
                        MessageBox.Show("캡처 영역 설정이 잘못되었습니다.\n대상 창의 크기나 위치가 변경되었을 수 있습니다.\n프로그램을 열어 영역을 다시 설정해주세요.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    LogTrace($"6. 이미지 자르기(Clone) 시작... [영역: {cropArea}]");
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        LogTrace("6-1. 이미지 자르기 완료.");
                        LogTrace("7. OCR 처리 시작...");
                        using (var page = OcrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            LogTrace($"7-1. OCR 처리 완료. 인식된 텍스트: '{rawText}'");
                            if (!string.IsNullOrWhiteSpace(rawText)) { ProcessOcrResult(rawText); } else { lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다."; }
                        }
                    }
                }
                LogTrace("===== PerformLogging 성공적으로 완료 =====");
            }
            catch (Exception ex)
            {
                LogTrace($"!!!!! PerformLogging에서 예외 발생 !!!!!\n{ex}");
                if (timer.IsEnabled) timer.Stop();
                if (searchTimer.IsEnabled) searchTimer.Stop();
                btnStart.Content = "로깅 시작";
                var sb = new StringBuilder();
                sb.AppendLine("캡처 중 예측하지 못한 오류가 발생하여 작업을 중지합니다.");
                sb.AppendLine("==============================================");
                sb.AppendLine($"[진단 정보]");
                sb.AppendLine($"전체 창 크기: {bmpSize.Width} x {bmpSize.Height}");
                sb.AppendLine($"잘라낼 영역 (X,Y,W,H): {cropArea.X}, {cropArea.Y}, {cropArea.Width}, {cropArea.Height}");
                sb.AppendLine("==============================================");
                Exception currentEx = ex;
                int indentLevel = 0;
                while (currentEx != null)
                {
                    sb.AppendLine($"\n[오류 레벨 {indentLevel}] {(indentLevel == 1 ? "(진짜 원인일 가능성이 높음)" : "")}");
                    sb.AppendLine($"  - 오류 유형: {currentEx.GetType().Name}");
                    sb.AppendLine($"  - 메시지: {currentEx.Message}");
                    sb.AppendLine($"  - 스택 트레이스:\n{currentEx.StackTrace}");
                    currentEx = currentEx.InnerException;
                    indentLevel++;
                }
                MessageBox.Show(sb.ToString(), "캡처 상세 오류 보고", MessageBoxButton.OK, MessageBoxImage.Error);
                lblStatus.Text = "상태: 캡처 오류 발생. 로깅 중지됨.";
            }
        }
        
        // 이하 다른 모든 함수는 이전 버전과 동일
        private void ProcessOcrResult(string rawText) { /* ... */ }
        private void UploadToDatabase(decimal temp, decimal humid) { /* ... */ }
        private void btnSelectArea_Click(object sender, RoutedEventArgs e) { /* ... */ }
        private void UpdatePreviewImage() { /* ... */ }
        private Wpf.Media.Imaging.BitmapImage BitmapToImageSource(Gdi.Bitmap bitmap) { /* ... */ }
    }
}
&lt;/details>

다음 단계 - 원인 분석
위 코드로 교체 후, 다시 클릭원스로 **게시(Publish)**하고 설치합니다.
프로그램을 실행하고, 의도적으로 충돌을 발생시킵니다. (로깅을 시작하면 됩니다)
프로그램이 종료되면, C:\Agent\funcenvget\logs 폴더로 이동합니다.
그 안에 생성된 trace_log.txt 파일을 엽니다.
파일의 맨 마지막에 기록된 로그가 무엇인지 저에게 알려주세요.
예를 들어, 로그 파일의 마지막 줄이 6. 이미지 자르기(Clone) 시작... 이라면, bmp.Clone(...) 함수에서 치명적인 오류가 발생하여 프로그램이 응답할 기회도 없이 종료되었다는 뜻입니다.