습니다! **"MacroPackages"**가 예약어라면 **"MacroActions"**로 변경하겠습니다.
("Action"은 예약어가 아니고, 의미도 매크로 동작과 잘 맞음)

📂 1. 새로운 프로젝트 구조 (MacroActions)
scss
코드 복사
📦 AutoHandleSolution
 ┣ 📂 AAutoHandle
 ┃ ┣ 📂 Commands
 ┃ ┃ ┣ 📜 IMacroCommand.cs
 ┃ ┃ ┣ 📜 KeyboardCommand.cs
 ┃ ┃ ┣ 📜 MouseClickCommand.cs
 ┃ ┃ ┣ 📜 DelayCommand.cs
 ┃ ┃ ┣ 📜 ScreenCaptureCommand.cs
 ┃ ┃ ┗ 📜 CVCommand.cs
 ┃ ┣ 📂 Core
 ┃ ┃ ┣ 📜 MacroExecutor.cs
 ┃ ┃ ┣ 📜 MacroManager.cs
 ┃ ┃ ┗ 📜 MacroLogger.cs
 ┃ ┣ 📂 Database
 ┃ ┃ ┣ 📜 MySqlHelper.cs
 ┃ ┃ ┣ 📜 MsSqlHelper.cs
 ┃ ┃ ┗ 📜 DatabaseReader.cs
 ┃ ┣ 📂 MacroActions  ★ 매크로 동작 정의 (예약어 피함)
 ┃ ┃ ┣ 📜 MacroActionA.cs
 ┃ ┃ ┣ 📜 MacroActionB.cs
 ┃ ┃ ┗ 📜 MacroActionC.cs
 ┃ ┣ 📂 Forms
 ┃ ┃ ┗ 📜 MainForm.cs
 ┃ ┣ 📜 Program.cs
 ┃ ┗ 📜 AAutoHandle.csproj
 ┗ 📜 AutoHandleSolution.sln
✅ MacroActions → 매크로 실행 패키지를 포함하는 폴더 (예약어 회피)

📜 2. 비동기 데이터 조회 및 패키지 기반 처리
🔹 1️⃣ MacroActionA.cs (매크로 동작 A)
csharp
코드 복사
namespace AAutoHandle.MacroActions
{
    using System;
    using System.Data;
    using System.Threading.Tasks;
    using AAutoHandle.Core;
    using AAutoHandle.Commands;

    public class MacroActionA
    {
        public async Task ExecuteAsync(DataRow row)
        {
            var macroManager = MacroManager.Instance;

            int x = Convert.ToInt32(row["x"]);
            int y = Convert.ToInt32(row["y"]);
            string capturePath = row["capturePath"].ToString();

            macroManager.AddCommand(new MouseClickCommand(x, y));
            macroManager.AddCommand(new DelayCommand(500));
            macroManager.AddCommand(new ScreenCaptureCommand(capturePath));

            await macroManager.StartExecutionAsync();
        }
    }
}
✅ 예약어 문제 없음 → "MacroActions" 내부에 "MacroActionA" 저장
✅ 다른 동작도 쉽게 추가 가능 (MacroActionB, MacroActionC 등)

🔹 2️⃣ MainForm.cs (UI에서 실행)
csharp
코드 복사
using System;
using System.Data;
using System.Threading.Tasks;
using System.Windows.Forms;
using AAutoHandle.Database;
using AAutoHandle.MacroActions;
using MySql.Data.MySqlClient;
using System.Data.SqlClient;

namespace AAutoHandle
{
    public partial class MainForm : Form
    {
        private DatabaseReader _dbReader;
        private MacroActionA _macroActionA;

        public MainForm()
        {
            InitializeComponent();

            string mysqlConn = "Server=localhost;Database=mydb;User=root;Password=1234;";
            string mssqlConn = "Server=myserver;Database=mydb;User Id=myuser;Password=mypassword;";

            _dbReader = new DatabaseReader(mysqlConn, mssqlConn);
            _macroActionA = new MacroActionA();
        }

        private async void btnLoadMySqlData_Click(object sender, EventArgs e)
        {
            listBoxLogs.Items.Clear();
            await _dbReader.ReadMySqlDataAsync("sp_GetData",
                async row =>
                {
                    listBoxLogs.Items.Add($"{row["id"]}: {row["name"]}");
                    await _macroActionA.ExecuteAsync(row);
                });
        }

        private async void btnLoadMsSqlData_Click(object sender, EventArgs e)
        {
            listBoxLogs.Items.Clear();
            await _dbReader.ReadMsSqlDataAsync("sp_GetData",
                async row =>
                {
                    listBoxLogs.Items.Add($"{row["id"]}: {row["name"]}");
                    await _macroActionA.ExecuteAsync(row);
                });
        }
    }
}
✅ 예약어 문제 해결, 비동기 데이터 처리 유지
✅ MacroActions 내에서 개별 Action을 선택적으로 실행 가능

📜 3. 실행 흐름
✅ btnLoadMySqlData_Click() 실행 →
MySQL sp_GetData 프로시저 실행 → DataRow 가져오기
MacroActionA.ExecuteAsync(row) 비동기 실행
마우스 클릭 → 0.5초 딜레이 → 화면 캡처 실행
ListBox에 데이터도 추가됨
📜 4. 결론
✅ 예약어 피함 (MacroPackages → MacroActions)
✅ 데이터를 비동기로 받아서 즉시 실행 가능 (async Task)
✅ 유지보수성 증가 (새로운 MacroAction 쉽게 추가 가능)
✅ UI에서 필요한 MacroAction만 실행 가능
