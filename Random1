네, 그럼요! 기기 IP 주소를 함께 수집하는 것은 여러 장비를 관리할 때 매우 유용한 기능입니다.

가장 좋은 소식은, 안드로이드 앱 코드는 전혀 수정할 필요가 없다는 것입니다. 기기의 공인 IP 주소는 서버 측에서 요청을 받는 순간에 가장 정확하게 파악할 수 있기 때문입니다. 앱에서 직접 IP를 알아내려고 하면 내부 사설 IP(192.168.x.x 등)를 가져오는 등 부정확할 수 있습니다.

따라서 우분투 서버(server.js) 코드만 수정하면 모든 것이 해결됩니다.

## 1단계: MSSQL 데이터베이스 테이블 수정
먼저, IP 주소를 저장할 컬럼을 기존 테이블들에 추가해야 합니다. SQL Server Management Studio에서 아래 ALTER TABLE 쿼리들을 실행하여 각 테이블에 DeviceIP 컬럼을 추가해 주세요.

SQL

-- 1. 실시간 조도 상태 테이블에 IP 컬럼 추가
ALTER TABLE Table_Lux2 ADD DeviceIP VARCHAR(50);

-- 2. 1분 평균 조도 로그 테이블에 IP 컬럼 추가
ALTER TABLE Table_Lux1min ADD DeviceIP VARCHAR(50);

-- 3. 10분 폰 상태 로그 테이블에 IP 컬럼 추가
ALTER TABLE PhoneStatusLog ADD DeviceIP VARCHAR(50);

-- 4. 진동 감지 로그 테이블에 IP 컬럼 추가
ALTER TABLE VibrationLog ADD DeviceIP VARCHAR(50);
## 2단계: API 서버 코드 수정 (server.js)
이제 서버가 요청을 받을 때마다 요청자의 IP 주소를 추출해서 DB에 함께 저장하도록 server.js 파일을 수정합니다.

파일 위치: 우분투 서버의 light-api 폴더

수정 방법: 기존 server.js 파일의 내용을 모두 지우고 아래 코드로 완전히 덮어쓰세요.

JavaScript

const express = require('express');
const sql = require('mssql');

const app = express();
// [추가] 프록시 서버 뒤에 있는 경우 실제 IP를 가져오기 위한 설정
app.set('trust proxy', true);
app.use(express.json());

const SECRET_API_KEY = "LightMeter-Secret-Key-1234";

const apiKeyMiddleware = (req, res, next) => {
    const apiKey = req.get('x-api-key');
    if (!apiKey || apiKey !== SECRET_API_KEY) {
        return res.status(401).send('Unauthorized');
    }
    next();
};

const dbConfig = {
    user: '사용자ID',
    password: '비밀번호',
    server: '내서버IP',
    database: '데이터베이스이름',
    pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
    options: { encrypt: false, trustServerCertificate: true }
};

const poolPromise = new sql.ConnectionPool(dbConfig)
    .connect()
    .then(pool => {
        console.log('✅ DB 연결 풀 생성 완료');
        return pool;
    })
    .catch(err => console.error('DB 연결 풀 생성 실패', err));


// --- [수정] 실시간 조도 UPDATE: IP 주소 추가 ---
app.post('/log', apiKeyMiddleware, async (req, res) => {
    const { deviceId, lux } = req.body;
    const ip = req.ip; // 요청자의 IP 주소 추출
    if (deviceId === undefined || lux === undefined) return res.status(400).send('값이 없습니다.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('LuxValue', sql.Float, lux)
            .input('DeviceId', sql.VarChar, deviceId)
            .input('DeviceIP', sql.VarChar, ip) // IP 파라미터 추가
            .query('UPDATE Table_Lux2 SET lux1 = @LuxValue, DeviceIP = @DeviceIP WHERE ip1 = @DeviceId');
        res.status(200).send('실시간 데이터 업데이트 성공');
    } catch (err) {
        console.error('DB 오류 (실시간 UPDATE):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// --- [수정] 1분 평균 조도 INSERT: IP 주소 추가 ---
app.post('/log1min', apiKeyMiddleware, async (req, res) => {
    const { deviceId, avgLux } = req.body;
    const ip = req.ip; // 요청자의 IP 주소 추출
    if (deviceId === undefined || avgLux === undefined) return res.status(400).send('값이 없습니다.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('LuxValue', sql.Float, avgLux)
            .input('DeviceIP', sql.VarChar, ip) // IP 파라미터 추가
            .query('INSERT Table_Lux1min (ip1, lux1, DeviceIP) VALUES (@DeviceId, @LuxValue, @DeviceIP)');
        console.log(`[1분 평균] 데이터 저장 성공: ${deviceId} (${ip}) - ${avgLux} lux`);
        res.status(200).send('1분 평균 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (1분 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// --- [수정] 10분 폰 상태 INSERT: IP 주소 추가 ---
app.post('/logStatus', apiKeyMiddleware, async (req, res) => {
    const { deviceId, batteryLevel, batteryTemp, isCharging, chargeType, batteryHealth, apTemp } = req.body;
    const ip = req.ip; // 요청자의 IP 주소 추출
    if (deviceId === undefined) return res.status(400).send('deviceId가 없습니다.');
    
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('BatteryLevel', sql.Int, batteryLevel)
            .input('BatteryTemp', sql.Float, batteryTemp)
            .input('IsCharging', sql.Bit, isCharging)
            .input('ChargeType', sql.VarChar, chargeType)
            .input('BatteryHealth', sql.VarChar, batteryHealth)
            .input('ApTemp', sql.Float, apTemp)
            .input('DeviceIP', sql.VarChar, ip) // IP 파라미터 추가
            .query('INSERT INTO PhoneStatusLog (DeviceId, BatteryLevel, BatteryTemp, IsCharging, ChargeType, BatteryHealth, ApTemp, DeviceIP) VALUES (@DeviceId, @BatteryLevel, @BatteryTemp, @IsCharging, @ChargeType, @BatteryHealth, @ApTemp, @DeviceIP)');
        
        console.log(`[10분 상태] 데이터 저장 성공: ${deviceId} (${ip})`);
        res.status(200).send('10분 상태 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (10분 상태 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// --- [수정] 진동 감지 INSERT: IP 주소 추가 ---
app.post('/logVibration', apiKeyMiddleware, async (req, res) => {
    const { deviceId, x, y, z } = req.body;
    const ip = req.ip; // 요청자의 IP 주소 추출
    if (deviceId === undefined) return res.status(400).send('deviceId가 없습니다.');

    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('AccelX', sql.Float, x)
            .input('AccelY', sql.Float, y)
            .input('AccelZ', sql.Float, z)
            .input('DeviceIP', sql.VarChar, ip) // IP 파라미터 추가
            .query('INSERT INTO VibrationLog (DeviceId, AccelX, AccelY, AccelZ, DeviceIP) VALUES (@DeviceId, @AccelX, @AccelY, @AccelZ, @DeviceIP)');
        
        console.log(`[진동 감지] 데이터 저장 성공: ${deviceId} (${ip})`);
        res.status(200).send('진동 감지 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (진동 감지 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});


const PORT = 3000;
app.listen(PORT, () => {
    console.log(`API 서버가 ${PORT}번 포트에서 실행 중입니다.`);
});
적용 방법:

위 코드로 server.js 파일을 덮어쓴 후 저장합니다.

우분투 터미널에서 pm2 restart server 명령어로 서버를 재시작합니다.

## 3단계: 안드로이드 앱 코드 (MainActivity.kt) - 변경 없음
앞서 설명드렸듯이, 앱 코드는 IP 주소 수집을 위해 수정할 필요가 전혀 없습니다. 서버가 알아서 IP를 추가해 주기 때문입니다.

하지만 요청하신 대로, 완전성을 위해 수정되지 않은 최종 MainActivity.kt 전체 코드를 다시 드립니다.

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.BatteryManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.WindowManager
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST
import java.io.File
import kotlin.math.sqrt

// 데이터 클래스 (변경 없음)
data class RealtimeLog(val deviceId: String, val lux: Float)
data class MinuteLog(val deviceId: String, val avgLux: Float)
data class PhoneStatusLog(val deviceId: String, val batteryLevel: Int, val batteryTemp: Float, val isCharging: Boolean, val chargeType: String, val batteryHealth: String, val apTemp: Float)
data class VibrationLog(val deviceId: String, val x: Float, val y: Float, val z: Float)

// API 인터페이스 (변경 없음)
interface ApiService {
    @POST("log")
    fun postRealtimeLog(@Body data: RealtimeLog): Call<String>
    @POST("log1min")
    fun postMinuteLog(@Body data: MinuteLog): Call<String>
    @POST("logStatus")
    fun postPhoneStatus(@Body data: PhoneStatusLog): Call<String>
    @POST("logVibration")
    fun postVibration(@Body data: VibrationLog): Call<String>
}

class MainActivity : AppCompatActivity(), SensorEventListener {

    private val API_KEY = "LightMeter-Secret-Key-1234"

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null
    private var accelerometer: Sensor? = null
    private lateinit var apiService: ApiService
    private lateinit var sharedPreferences: SharedPreferences
    private var currentDeviceId: String = ""
    private var latestLuxValue: Float = 0.0f
    
    private val handlerRealtime = Handler(Looper.getMainLooper())
    private val handlerMinute = Handler(Looper.getMainLooper())
    private val handlerStatus = Handler(Looper.getMainLooper())
    private val minuteLuxReadings = mutableListOf<Float>()

    private val VIBRATION_THRESHOLD = 20.0f
    private val VIBRATION_LOG_COOLDOWN = 30000L
    private var lastVibrationLogTime = 0L

    private val runnableRealtime = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) sendRealtimeDataToServer(currentDeviceId, latestLuxValue)
            minuteLuxReadings.add(latestLuxValue)
            handlerRealtime.postDelayed(this, 1000)
        }
    }

    private val runnableMinute = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty() && minuteLuxReadings.isNotEmpty()) {
                val avgLux = minuteLuxReadings.average().toFloat()
                sendMinuteDataToServer(currentDeviceId, avgLux)
                minuteLuxReadings.clear()
            }
            handlerMinute.postDelayed(this, 60000)
        }
    }
    
    private val runnableStatus = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) {
                val status = getPhoneStatus()
                sendPhoneStatusToServer(status)
            }
            handlerStatus.postDelayed(this, 600000)
        }
    }

    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        sharedPreferences = getSharedPreferences("LightMeterPrefs", Context.MODE_PRIVATE)
        setupUI()
        loadDeviceId()
        setupSensor()
        setupNetwork()
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        
        if (lightSensor == null) {
            binding.tvLuxValue.text = "조도 센서 없음"
            binding.tvUnit.text = ""
        }
    }

    override fun onResume() {
        super.onResume()
        sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_UI)
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)
        handlerRealtime.post(runnableRealtime)
        handlerMinute.post(runnableMinute)
        handlerStatus.post(runnableStatus)
    }

    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
        handlerRealtime.removeCallbacks(runnableRealtime)
        handlerMinute.removeCallbacks(runnableMinute)
        handlerStatus.removeCallbacks(runnableStatus)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        when (event?.sensor?.type) {
            Sensor.TYPE_LIGHT -> {
                val luxValue = event.values[0]
                binding.tvLuxValue.text = "%.1f".format(luxValue)
                latestLuxValue = luxValue
                val colorResId = when {
                    luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                    luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                    else -> R.color.spec_in_black
                }
                binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
            }
            Sensor.TYPE_ACCELEROMETER -> {
                val x = event.values[0]
                val y = event.values[1]
                val z = event.values[2]
                val acceleration = sqrt(x * x + y * y + z * z) - SensorManager.GRAVITY_EARTH

                if (acceleration > VIBRATION_THRESHOLD) {
                    val currentTime = System.currentTimeMillis()
                    if (currentTime - lastVibrationLogTime > VIBRATION_LOG_COOLDOWN) {
                        lastVibrationLogTime = currentTime
                        Log.d("VibrationDetector", "강한 진동 감지! 값: $acceleration")
                        if (currentDeviceId.isNotEmpty()) {
                            sendVibrationDataToServer(currentDeviceId, x, y, z)
                        }
                    }
                }
            }
        }
    }

    private fun getPhoneStatus(): PhoneStatusLog {
        val batteryIntent: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter ->
            applicationContext.registerReceiver(null, filter)
        }
        val level = batteryIntent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale = batteryIntent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        val batteryPct = if (level != -1 && scale != -1) (level * 100 / scale.toFloat()).toInt() else -1
        val temp = batteryIntent?.getIntExtra(BatteryManager.EXTRA_TEMPERATURE, -1)?.toFloat()?.div(10) ?: -1.0f
        val status = batteryIntent?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1
        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL
        val chargePlug = batteryIntent?.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1) ?: -1
        val chargeType = when (chargePlug) {
            BatteryManager.BATTERY_PLUGGED_AC -> "AC"
            BatteryManager.BATTERY_PLUGGED_USB -> "USB"
            BatteryManager.BATTERY_PLUGGED_WIRELESS -> "Wireless"
            else -> "Unplugged"
        }
        val health = batteryIntent?.getIntExtra(BatteryManager.EXTRA_HEALTH, -1) ?: -1
        val batteryHealth = when (health) {
            BatteryManager.BATTERY_HEALTH_GOOD -> "Good"
            BatteryManager.BATTERY_HEALTH_OVERHEAT -> "Overheat"
            BatteryManager.BATTERY_HEALTH_DEAD -> "Dead"
            BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE -> "Over Voltage"
            BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE -> "Failure"
            else -> "Unknown"
        }
        val apTemp = getApTemperature()
        return PhoneStatusLog(currentDeviceId, batteryPct, temp, isCharging, chargeType, batteryHealth, apTemp)
    }

    private fun getApTemperature(): Float {
        val thermalPaths = listOf(
            "/sys/class/thermal/thermal_zone1/temp", "/sys/class/thermal/thermal_zone2/temp",
            "/sys/class/thermal/thermal_zone3/temp", "/sys/class/thermal/thermal_zone4/temp",
            "/sys/class/thermal/thermal_zone5/temp", "/sys/class/thermal/thermal_zone6/temp"
        )
        for (path in thermalPaths) {
            try {
                val tempStr = File(path).readText()
                val temp = tempStr.trim().toFloat()
                if (temp > 0 && temp < 200000) return temp / 1000.0f
            } catch (e: Exception) { /* Continue */ }
        }
        return -1.0f
    }

    private fun sendPhoneStatusToServer(status: PhoneStatusLog) {
        apiService.postPhoneStatus(status).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "10분 상태 전송 성공")
                else Log.e("NetworkError", "10분 상태 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "10분 상태 네트워크 오류: ${t.message}")
            }
        })
    }

    private fun sendVibrationDataToServer(deviceId: String, x: Float, y: Float, z: Float) {
        val logData = VibrationLog(deviceId, x, y, z)
        apiService.postVibration(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "진동 데이터 전송 성공")
                else Log.e("NetworkError", "진동 데이터 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "진동 데이터 네트워크 오류: ${t.message}")
            }
        })
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) { /* Do nothing */ }
    private fun setupNetwork() {
        val apiKeyInterceptor = Interceptor { chain ->
            chain.proceed(chain.request().newBuilder().header("x-api-key", API_KEY).build())
        }
        val okHttpClient = OkHttpClient.Builder().addInterceptor(apiKeyInterceptor).build()
        val retrofit = Retrofit.Builder()
            .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/")
            .client(okHttpClient)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        apiService = retrofit.create(ApiService::class.java)
    }
    private fun setupUI() {
        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)
        binding.btnSaveDeviceId.setOnClickListener {
            val deviceId = binding.etDeviceId.text.toString().trim()
            if (deviceId.isNotEmpty()) saveDeviceId(deviceId)
        }
    }
    private fun loadDeviceId() {
        val savedId = sharedPreferences.getString("DEVICE_ID", "") ?: ""
        currentDeviceId = savedId
        binding.tvCurrentDeviceId.text = if (savedId.isNotEmpty()) getString(R.string.current_device_id_label, savedId) else getString(R.string.current_device_id_label, getString(R.string.device_id_not_set))
    }
    private fun saveDeviceId(deviceId: String) {
        sharedPreferences.edit().putString("DEVICE_ID", deviceId).apply()
        currentDeviceId = deviceId
        binding.tvCurrentDeviceId.text = getString(R.string.current_device_id_label, deviceId)
        Toast.makeText(this, getString(R.string.device_id_saved_message), Toast.LENGTH_SHORT).show()
    }
    private fun sendRealtimeDataToServer(deviceId: String, lux: Float) {
        val logData = RealtimeLog(deviceId = deviceId, lux = lux)
        apiService.postRealtimeLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (!response.isSuccessful) Log.e("NetworkError", "실시간 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "실시간 네트워크 오류: ${t.message}")
            }
        })
    }
    private fun sendMinuteDataToServer(deviceId: String, avgLux: Float) {
        val logData = MinuteLog(deviceId = deviceId, avgLux = avgLux)
        apiService.postMinuteLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "1분 평균 전송 성공")
                else Log.e("NetworkError", "1분 평균 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "1분 평균 네트워크 오류: ${t.message}")
            }
        })