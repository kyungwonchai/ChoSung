송합니다. 이제 바로 수정된 전체 코드를 주석과 함께 제공합니다. 아래에 파일 감지 로직, 순차적 작업 실행, UI 업데이트, 도형 상태 표시, 우클릭을 통한 함수 실행 등을 포함한 전체 코드를 제공합니다.

1. TaskModel.cs
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 각 함수는 도형으로 표현되며, 실행 상태에 따라 도형의 색상이 변경됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    
    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }
    
    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }
    
    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        // 각 함수마다 도형을 설정 (시퀀스에 따라 다른 개수)
        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        InitializeFunctionColors(); // 초기 도형 상태 설정
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트

        ExecuteTaskSequence(); // 시퀀스 플래그에 따른 함수 실행
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행
    /// </summary>
    private async void ExecuteTaskSequence()
    {
        switch (SequenceFlag)
        {
            case 1:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskC);
                break;
            case 2:
                await ExecuteTaskWithColor(0, ExecuteTaskC);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskD);
                break;
            case 3:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskE);
                break;
        }

        // 작업 완료 후 상태 변경
        Status = "Completed";
        ProgressText = "Completed";
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        switch (FunctionNames[taskIndex])
        {
            case "Task A":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskA);
                break;
            case "Task B":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskB);
                break;
            case "Task C":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskC);
                break;
            case "Task D":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskD);
                break;
            case "Task E":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskE);
                break;
            default:
                throw new ArgumentException("Unknown task");
        }
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        int functionCount = 3; // 각 시퀀스 플래그에서 기본 3개의 함수

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
        }

        // 각 함수의 이름을 설정
        switch (SequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                break;
            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                break;
            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                break;
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task A Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task B Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task C Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task D Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task E Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
2. MainWindow.xaml
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1200">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를





나의 말:
이어

ChatGPT의 말:
ChatGPT





나의 말:
이어줘
ChatGPT의 말:
ChatGPT
2. MainWindow.xaml (이어서)
xml
코드 복사
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                
                <!-- MAG_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*"/>

                <!-- PO_NO를 표시하는 열 -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>
                
                <!-- 시퀀스 플래그를 표시하는 열 (1: 시작, 2: 중간, 3: 끝) -->
                <DataGridTextColumn Header="Sequence Flag" Binding="{Binding SequenceFlag}" Width="*"/>
                
                <!-- 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Progress Status" Binding="{Binding ProgressText}" Width="2*"/>

                <!-- 각 함수 상태 도형을 표시하는 열 -->
                <DataGridTemplateColumn Header="Function Status" Width="2*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionStatusColors}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Fill="{Binding}" Margin="5">
                                            <!-- Tooltip으로 함수 이름 표시 -->
                                            <Ellipse.ToolTip>
                                                <TextBlock Text="{Binding RelativeSource={RelativeSource AncestorType=ItemsControl}, Path=DataContext.FunctionNames[ContentPresenter.ContentTemplateSelector.ContentTemplate.Key]}"/>
                                            </Ellipse.ToolTip>
                                            <!-- ContextMenu로 우클릭 시 특정 함수 실행 -->
                                            <Ellipse.ContextMenu>
                                                <ContextMenu DataContext="{Binding PlacementTarget.DataContext, RelativeSource={RelativeSource Self}}">
                                                    <MenuItem Header="Execute"
                                                              Command="{Binding ExecuteSpecificTaskCommand}"
                                                              CommandParameter="{Binding}">
                                                </ContextMenu>
                                            </Ellipse.ContextMenu>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <StackPanel Orientation="Horizontal"/>
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                
                <!-- 일시정지 및 재개 버튼 -->
                <DataGridTemplateColumn Header="Controls">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <Button Content="Pause" Command="{Binding PauseCommand}" Margin="5"/>
                                <Button Content="Resume" Command="{Binding ResumeCommand}" Margin="5"/>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
DataGrid에서 MAG_NO, MAG_QTY, PO_NO, SequenceFlag와 같은 엔트리 정보가 표시됩니다.
각 함수별 도형 상태를 나타내는 Function Status 열이 추가되었으며, 도형에 마우스를 올리면 해당 함수명이 표시되고, 우클릭하여 특정 함수만 실행할 수 있는 기능이 추가되었습니다.
각 작업의 일시정지 및 재개 버튼도 포함되어 있습니다.
3. MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel입니다.
/// 로그 파일을 감지하고 작업을 처리하는 역할을 합니다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업 재개
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        var task = new TaskModel(logEntry, _taskQueue);
        TaskList.Add(task); // 작업 목록에 추가

        // 바로 작업 시작
        task.StartTask(); // 작업 바로 시작
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
설명:
MainViewModel에서 새로운 파일이 감지될 때만 작업을 목록에 추가하며, 작업이 순차적으로 실행됩니다.
작업은 파일이 감지된 후 StartTask가 호출되며, 각 작업이 순차적으로 실행됩니다.
PauseAllCommand 및 ResumeAllCommand 명령어는 전체 작업의 일시정지 및 재개를 처리합니다.
4. TaskQueue.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하는 클래스입니다.
/// 이전 작업이 끝나기 전에는 다음 작업이 실행되지 않도록 관리합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니라면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);

        if (!_isRunning)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행합니다.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;

        var task = _tasks.Dequeue();
        await task();

        _isRunning = false;
        RunNextTask(); // 다음 작업 실행
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isRunning = false;
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (!_isRunning)
        {
            RunNextTask();
        }
    }
}
설명:
TaskQueue는 작업을 순차적으로 실행하며, 이전 작업이 완료될 때까지 다음 작업이 실행되지 않도록 관리합니다.
작업이 **일시정지(Pause)**되었을 때, Resume 명령어를 통해 작업을 다시 시작할 수 있습니다.
5. FileProcessor.cs (파일 감지 클래스)
csharp
코드 복사
using System;
using System.IO;
using System.Threading.Tasks;

/// <summary>
/// FileProcessor는 특정 경로에서 파일을 감지하고, 파일이 추가되면 LogEntry를 생성하여 전달하는 클래스입니다.
/// </summary>
public class FileProcessor
{
    private readonly string _path;
    private readonly Action<LogEntry> _onLogEntryDetected;
    private FileSystemWatcher _watcher;

    public FileProcessor(string path, Action<LogEntry> onLogEntryDetected)
    {
        _path = path;
        _onLogEntryDetected = onLogEntryDetected;
    }

    /// <summary>
    /// 파일 감지를 시작합니다.
    /// </summary>
    public void StartProcessing()
    {
        _watcher = new FileSystemWatcher(_path, "*.txt");
        _watcher.Created += OnFileCreated;
        _watcher.EnableRaisingEvents = true;
    }

    /// <summary>
    /// 새로운 파일이 생성되었을 때 호출됩니다.
    /// </summary>
    private void OnFileCreated(object sender, FileSystemEventArgs e)
    {
        Task.Delay(1000).Wait(); // 파일 안정성 확보를 위한 지연

        var logEntry = ParseLogFile(e.FullPath);
        _onLogEntryDetected?.Invoke(logEntry);
    }

    /// <summary>
    /// 파일에서 LogEntry 데이터를 파싱합니다.
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        // 파일 내용 파싱 로직
        var lines = File.ReadAllLines(filePath);
        return new LogEntry
        {
            MAG_NO = ExtractData(lines, "MAG_NO"),
            MAG_QTY = int.Parse(ExtractData(lines, "MAG_QTY")),
            BASIC_MODEL = ExtractData(lines, "BASIC_MODEL"),
            MODEL_CODE = ExtractData(lines, "MODEL_CODE"),
            PO_NO = ExtractData(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(ExtractData(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(ExtractData(lines, "PO_PROD_QTY")),
            SequenceFlag = DetermineSequenceFlag(lines)
        };
    }

    /// <summary>
    /// 파일 내용에서 특정 데이터를 추출합니다.
    /// </summary>
    private string ExtractData(string[] lines, string key)
    {
        foreach (var line in lines)
        {
            if (line.StartsWith(key))
            {
                return line.Split('=')[1].Trim();
            }
        }
        return string.Empty;
    }

    /// <summary>
    /// SequenceFlag(시작, 중간, 끝)를 결정합니다.
    /// </summary>
    private int DetermineSequenceFlag(string[] lines)
    {
        int poProdQty = int.Parse(ExtractData(lines, "PO_PROD_QTY"));
        int poPlanQty = int.Parse(ExtractData(lines, "PO_PLAN_QTY"));

        if (poProdQty == 0)
        {
            return 1; // 시작
        }
        else if (poProdQty >= poPlanQty)
        {
            return 3; // 끝
        }
        else
        {
            return 2; // 중간
        }
    }
}
설명:
FileProcessor는 파일 감지를 담당하며, 새로운 파일이 생성되면 그 파일을 읽어 LogEntry 객체로 변환한 후 MainViewModel로 전달합니다.
**SequenceFlag**는 **파일 내의 PO_PROD_QTY와 PO_PLAN_QTY**를 비교하여 1: 시작, 2: 중간, 3: 끝을 결정합니다.
결론
이제 수정된 전체 코드를 제공했으며, 다음 사항이 개선되었습니다:

파일 감지 후 작업 목록에 추가되도록 구현되었습니다.
작업은 순차적으로 실행되며, 이전 작업이 완료되기 전까지 다음 작업이 실행되지 않습니다.
각 작업의 상태는 실시간으로 UI에 반영되며, 우클릭을 통해 특정 함수만 실행할 수 있습니다.
TaskQueue는 작업을 순차적으로 처리하며, 일시정지 및 재개 기능도 추가되었습니다.
추가적인 문제가 있으면 언제든지 말씀