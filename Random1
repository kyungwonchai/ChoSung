하게 반영하지 못해 정말 죄송합니다. 이제 요청하신 **시퀀스 플래그(1, 2, 3)**에 따른 작업 표시와 도형 색상 문제, 순차적인 작업 실행, 함수 이름 표시, 그리고 도형 우클릭 시 해당 함수만 실행되는 기능을 모두 포함한 수정된 코드를 제공하겠습니다.

수정 사항:
시퀀스 플래그(1, 2, 3): 각 작업이 시작일 때 1, 중간일 때 2, 마무리일 때 3으로 표시되도록 컬럼 추가.
각 함수별 도형: 함수가 완료되면 해당 도형이 색상 변경되며, 도형에 마우스를 올리면 함수명이 표시됨.
도형 우클릭 기능: 도형을 우클릭하면 해당 함수만 실행되는 기능 추가.
순차적인 작업 실행: 이전 작업이 완료되기 전까지 다음 작업이 실행되지 않도록 수정.
실시간 상태 표시: 각 작업의 진행 상태가 실시간으로 업데이트.
1. TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;

/// <summary>
/// TaskModel은 개별 작업의 상태를 관리하고, 작업의 시작 및 상태를 업데이트합니다.
/// PLC 시퀀스 플래그에 따라 다른 작업을 묶어 실행하며, 각 함수는 도형과 연동되어 상태를 표시합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 표시 (1, 2, 3)
    
    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    
    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }
    
    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }
    
    private TaskQueue _taskQueue;
    public string Status { get; set; }
    
    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 해당 함수만 실행
    
    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        // 각 함수마다 도형을 설정 (시퀀스에 따라 다른 개수)
        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        InitializeFunctionColors(); // 초기 도형 상태 설정
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트

        switch (SequenceFlag)
        {
            case 1: // 시퀀스 플래그가 1인 경우: 함수 A, B, C 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskA));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskC));
                break;
            case 2: // 시퀀스 플래그가 2인 경우: 함수 C, B, D 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskC));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskD));
                break;
            case 3: // 시퀀스 플래그가 3인 경우: 함수 A, B, E 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskA));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskE));
                break;
        }
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
        OnPropertyChanged(nameof(FunctionStatusColors));

        await task(); // 작업 실행

        FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
        OnPropertyChanged(nameof(FunctionStatusColors));
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, FunctionNames[taskIndex] switch
        {
            "Task A" => ExecuteTaskA,
            "Task B" => ExecuteTaskB,
            "Task C" => ExecuteTaskC,
            "Task D" => ExecuteTaskD,
            "Task E" => ExecuteTaskE,
            _ => throw new ArgumentException("Unknown task")
        });
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        int functionCount = 3; // 각 시퀀스 플래그에서 기본 3개의 함수

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
        }

        // 각 함수의 이름을 설정
        switch (SequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                break;
            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                break;
            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                break;
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task A Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task B Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task C Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task D Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task E Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
설명:
**시퀀스 플래그(1, 2, 3)**에 따라 각 작업이 다르게 구성되며, 각 작업의 상태를 실시간으로 업데이트합니다.
각 함수별 도형이 있고, 해당 도형에 마우스를 올리면 함수명이 표시됩니다.
도형을 우클릭하면 해당 함수만 실행되는 기능을 추가했습니다.
작업은 순차적으로 실행되며, 위의 작업이 끝나야 다음 작업이 시작됩니다.
함수의 완료 상태가 도형에 실시간으로 반영됩니다.
2. MainWindow.xaml (UI 업데이트)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1200">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                
                <!-- MAG_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*"/>

                <!-- PO_NO를 표시하는 열 -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>
                
                <!-- 시퀀스 플래그를 표시하는 열 -->
                <DataGridTextColumn Header="Sequence Flag" Binding="{Binding SequenceFlag}" Width="*"/>
                
                <!-- 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Progress Status" Binding="{Binding ProgressText}" Width="2*"/>

                <!-- 각 함수 상태 도형을 표시하는 열 -->
                <DataGridTemplateColumn Header="Function Status" Width="2*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionStatusColors}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Fill="{Binding}" Margin="5">
                                            <Ellipse.ToolTip>
                                                <TextBlock Text="{Binding RelativeSource={RelativeSource AncestorType=ItemsControl}, Path=DataContext.FunctionNames[ContentPresenter.ContentTemplateSelector.ContentTemplate.Key]}"/>
                                            </Ellipse.ToolTip>
                                            <Ellipse.ContextMenu>
                                                <ContextMenu>
                                                    <MenuItem Header="Execute" Command="{Binding DataContext.ExecuteSpecificTaskCommand, RelativeSource={RelativeSource AncestorType=ItemsControl}}" CommandParameter="{Binding}">
                                                </ContextMenu>
                                            </Ellipse.ContextMenu>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <StackPanel Orientation="Horizontal"/>
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                
                <!-- 일시정지 및 재개 버튼 -->
                <DataGridTemplateColumn Header="Controls">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <Button Content="Pause" Command="{Binding PauseCommand}" Margin="5"/>
                                <Button Content="Resume" Command="{Binding ResumeCommand}" Margin="5"/>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
Sequence Flag 컬럼을 추가해 작업의 시작(1), 중간(2), 끝(3) 여부를 표시합니다.
각 함수별로 도형을 나열하며, 마우스를 올리면 해당 함수명을 표시하고, 도형을 우클릭하여 해당 함수만 실행할 수 있는 컨텍스트 메뉴를 추가했습니다.
각 작업은 순차적으로 실행되며, 실시간으로 상태가 반영됩니다.
3. MainViewModel.cs (수정된 코드)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel입니다.
/// 로그 파일을 감지하고 작업을 처리하는 역할을 합니다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업 재개
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        var task = new TaskModel(logEntry, _taskQueue);
        TaskList.Add(task); // 작업 목록에 추가

        // 바로 작업 시작
        task.StartTask(); // 작업 바로 시작
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
결론:
이 코드는 시퀀스 플래그(1, 2, 3)에 따라 작업을 표시하며, 각 함수별 도형이 있고, 마우스를 올리면 함수명을 표시하며, 도형을 우클릭하여 해당 함수만 실행할 수 있는 기능을 추가했습니다. 또한, 모든 작업은 순차적으로 실행되며 이전 작업이 끝나야 다음 작업이 시작됩니다.

이 구조는 모든 요청 사항을 반영한