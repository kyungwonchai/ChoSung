로그를 처리하는 클래스입니다.

csharp
코드 복사
using System;
using System.IO;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class Logger
    {
        private readonly string logDirectory;
        private readonly Dispatcher dispatcher;
        private readonly Action<string> logRecentActivity;
        private readonly Action<string> logDeletionActivity;

        public Logger(string logDirectory, Dispatcher dispatcher, Action<string> logRecentActivity, Action<string> logDeletionActivity)
        {
            this.logDirectory = logDirectory;
            this.dispatcher = dispatcher;
            this.logRecentActivity = logRecentActivity;
            this.logDeletionActivity = logDeletionActivity;
        }

        public void LogRecentActivity(string message)
        {
            dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                logRecentActivity(logMessage);
            });
        }

        public void LogDeletionActivity(string message)
        {
            dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                logDeletionActivity(logMessage);
            });
        }

        public void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                dispatcher.Invoke(() =>
                {
                    logRecentActivity(logMessage);
                });
            }
            catch (Exception ex)
            {
                Console.WriteLine("Error logging failed: " + ex.Message);
            }
        }
    }
}
FileCleaner.cs
파일 청소 기능을 담당하는 클래스입니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;
        private readonly Logger logger;
        private readonly Action<long, string> updateFolderStatistics;

        public FileCleaner(string logDirectory, MLModelBuilder mlModelBuilder, Dispatcher dispatcher, Logger logger, Action<long, string> updateFolderStatistics)
        {
            this.logDirectory = logDirectory;
            this.mlModelBuilder = mlModelBuilder;
            this.dispatcher = dispatcher;
            this.logger = logger;
            this.updateFolderStatistics = updateFolderStatistics;
        }

        public long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get drive free space: " + ex.Message);
                return 0;
            }
        }

        public List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                var filesToDelete = files.Where(file => mlModelBuilder.Predict(file)).ToList();

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(files.Sum(f => f.Length), folderPath);
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get files to delete: " + ex.Message);
                return new List<FileInfo>();
            }
        }

        private IEnumerable<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                logger.LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        public async Task DeleteFilesAsync(List<FileInfo> files)
        {
            foreach (var file in files)
            {
                try
                {
                    // 실제 파일 삭제
                    // file.Delete();
                    logger.LogDeletionActivity(file.FullName);
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                }
                catch (Exception ex)
                {
                    logger.LogError("Failed to delete file: " + ex.Message);
                }
            }
        }

        public void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(totalSize, folderPath);
                });
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to update folder statistics: " + ex.Message);
            }
        }
    }
}
수정된 MainWindow.xaml.cs
메인 윈도우 클래스입니다. 필요한 기능들을 위의 클래스로 분리하고, 남은 메인 윈도우 기능을 제공합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private const int MinimumSampleSize = 10; // 최소 샘플 수
        private string logDirectory = @"C:\Agent\SMDClean\Logs";
        private string settingsDirectory = @"C:\Agent\SMDClean";
        private MLModelBuilder _mlModelBuilder;
        private SettingsManager _settingsManager;
        private FileCleaner _fileCleaner;
        private Logger _logger;
        private List<FileRecord> _trainingData;

        public MainWindow()
        {
            InitializeComponent();
            _mlModelBuilder = new MLModelBuilder();
            _settingsManager = new SettingsManager(settingsDirectory);
            _logger = new Logger(logDirectory, Dispatcher, LogRecentActivity, LogDeletionActivity);
            _fileCleaner = new FileCleaner(logDirectory, _mlModelBuilder, Dispatcher, _logger, UpdateFolderStatistics);
            LoadSettings();
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                SaveSettings();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex.Message);
            }
        }

        private void btnLoadSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                LoadSettings();
            }
            catch (Exception ex)
            {
                _logger.LogError(ex.Message);
            }
        }

        private void btnSelectFolder_Click(object sender, RoutedEventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                dialog.SelectedPath = txtFolderPath.Text;
                if (dialog.ShowDialog() == DialogResult.OK)
                {
                    txtFolderPath.Text = dialog.SelectedPath;
                }
            }
        }

        private void SaveSettings()
        {
            try
            {
                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = cmbFileExtension.Text,
                    DriveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\"
                });
            }
            catch (Exception ex)
            {
                _logger.LogError(ex.Message);
            }
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "D:\\";
                    cmbFileExtension.Text = settings.FileExtension ?? ".jpg";
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex.Message);
            }
        }

        private async void btnStart_Click(object sender, RoutedEventArgs e)
        {
            string folderPath = txtFolderPath.Text;
            string fileExtension = cmbFileExtension.Text;
            string driveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\";

            if (string.IsNullOrEmpty(folderPath) || folderPath == "폴더 경로 입력" ||
                string.IsNullOrEmpty(fileExtension))
            {
                System.Windows.Forms.MessageBox.Show("모든 입력값을 제공해주세요.");
                return;
            }

            try
            {
                Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 중..."; });

                _trainingData = await Task.Run(() => CollectInitialFileData(folderPath, fileExtension));
                if (_trainingData.Count < MinimumSampleSize)
                {
                    System.Windows.Forms.MessageBox.Show($"학습 모델을 훈련시키기에 샘플이 충분하지 않습니다. 최소 샘플 수: {MinimumSampleSize}");
                    Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: 샘플 부족"; });
                    return;
                }

                _mlModelBuilder.TrainModel(_trainingData);

                Dispatcher.Invoke(() =>
                {
                    dataGridTrainingData.ItemsSource = _trainingData;
                    txtTrainingStatus.Text = "학습 완료";
                    txtCurrentPatterns.Text = string.Join(", ", _mlModelBuilder.GetRegexPatterns().Select(p => p.ToString()));
                });

                await Task.Run(() => MonitorAndDisplayFilesToDelete(folderPath, fileExtension, driveName));
            }
            catch (Exception ex)
            {
                _logger.LogError("모델 훈련 실패: " + ex.Message);
                Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: " + ex.Message); });
            }
        }

        private List<FileRecord> CollectInitialFileData(string folderPath, string fileExtension)
        {
            var fileDataList = new List<FileRecord>();
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                if (files != null && files.Count > 0)
                {
                    fileDataList = files.Select(f => new FileRecord
                    {
                        FilePath = f.FullName,
                        Extension = f.Extension,
                        Size = (float)f.Length, // float 형식으로 변환
                        FolderPath = f.DirectoryName
                    }).ToList();

                    Dispatcher.Invoke(() =>
                    {
                        txtCurrentPatterns.Text = $"학습 중인 파일 수: {files.Count}개";
                    });
                }
                else
                {
                    Dispatcher.Invoke(() =>
                    {
                        txtCurrentPatterns.Text = "학습할 파일이 없습니다.";
                    });
                }
            }
            catch (Exception ex)
            {
                _logger.LogError("파일 데이터 수집 실패: " + ex.Message);
                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = "파일 데이터 수집 오류.";
                });
            }
            return fileDataList;
        }

        private List<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                _logger.LogError("폴더 접근 거부됨: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = await Task.Run(() => _fileCleaner.GetDriveFreeSpace(driveName));
                    List<FileInfo> filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension));

                    Dispatcher.Invoke(() => DisplayFilesToDelete(filesToDelete));

                    //await _fileCleaner.DeleteFilesAsync(filesToDelete); // 실제 삭제 코드 (주석 처리)

                    await Task.Run(() => _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension));
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    _logger.LogError("모니터링 중 오류 발생: " + ex.Message);
                }
            }
        }

        private void DisplayFilesToDelete(List<FileInfo> filesToDelete)
        {
            Dispatcher.Invoke(() =>
            {
                lstPriorityFiles.Items.Clear();
                foreach (var file in filesToDelete)
                {
                    lstPriorityFiles.Items.Add(file.FullName);
                }
                dataGridTrainingResults.ItemsSource = filesToDelete.Select(f => new { f.Name, f.CreationTime });
            });
        }

        private void LogRecentActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                lstRecentLogs.Items.Add(logMessage);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogDeletionActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: {message}";
                lstDeletionLogs.Items.Add(logMessage);
                if (lstDeletionLogs.Items.Count > 200)
                {
                    lstDeletionLogs.Items.RemoveAt(0);
                }
            });
        }

        private void UpdateFolderStatistics(long totalSize, string folderPath)
        {
            Dispatcher.Invoke(() =>
            {
                string logMessage = $"{DateTime.Now}: 폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB";
                lstRecentLogs.Items.Add(logMessage);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }
    }
}
이제 MainWindow.xaml.cs는 간결하게 유지되며, 로그 처리와 파일 청소 기능이 각각의 클래스로 분리되었습니다. 이렇게 하면 코드 유지보수가 쉬워지고, 각 클래스가 명확한 역할을 갖게 