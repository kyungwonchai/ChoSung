드백이 혼란을 줬다면 사과드립니다. CopyMemory가 기본적으로 작동하지 않는 상황을 이미 말씀하셨으니, 완전히 CopyMemory 없이 동작하는 코드를 제공하겠습니다. 이 코드는 RtlMoveMemory 같은 다른 대안을 사용하지 않고도 클립보드 작업을 처리할 수 있습니다.

VBA7 최신 기준: CopyMemory 없이 클립보드 복사
이 코드는 데이터를 문자 단위로 처리해 클립보드에 안전하게 복사합니다.

vba
코드 복사
#If VBA7 Then
    Private Declare PtrSafe Function OpenClipboard Lib "user32" (ByVal hwnd As LongPtr) As Long
    Private Declare PtrSafe Function EmptyClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function CloseClipboard Lib "user32" () As Long
    Private Declare PtrSafe Function SetClipboardData Lib "user32" (ByVal wFormat As Long, ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalAlloc Lib "kernel32" (ByVal wFlags As Long, ByVal dwBytes As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalLock Lib "kernel32" (ByVal hMem As LongPtr) As LongPtr
    Private Declare PtrSafe Function GlobalUnlock Lib "kernel32" (ByVal hMem As LongPtr) As Long
#End If

Const CF_TEXT As Long = 1
Const GMEM_MOVEABLE As Long = &H2

Sub CopySheetToClipboardWithoutCopyMemory()
    Dim ws As Worksheet
    Dim rng As Range
    Dim row As Range
    Dim cell As Range
    Dim clipboardText As String
    
    ' 현재 시트와 범위 설정
    Set ws = ThisWorkbook.Sheets(1) ' 필요한 경우 시트 번호를 조정하세요
    Set rng = ws.UsedRange          ' 데이터가 있는 범위 전체 선택
    
    ' 범위의 내용을 문자열로 변환
    clipboardText = ""
    For Each row In rng.Rows
        For Each cell In row.Cells
            clipboardText = clipboardText & cell.Value & vbTab ' 각 셀 값을 탭으로 구분
        Next cell
        clipboardText = Left(clipboardText, Len(clipboardText) - 1) & vbCrLf ' 줄바꿈 추가
    Next row
    
    ' 클립보드에 복사
    CopyTextToClipboardWithoutCopyMemory clipboardText
    
    MsgBox "시트 내용이 클립보드에 복사되었습니다! 따옴표 없이 확인해보세요.", vbInformation
End Sub

Private Sub CopyTextToClipboardWithoutCopyMemory(ByVal Text As String)
    Dim hGlobal As LongPtr
    Dim lpGlobal As LongPtr
    Dim i As Long
    Dim charArray() As Byte
    
    ' 문자열을 바이트 배열로 변환
    charArray = StrConv(Text, vbFromUnicode)
    
    ' 클립보드 열기
    If OpenClipboard(0&) Then
        EmptyClipboard ' 기존 클립보드 데이터 비우기
        
        ' 메모리 할당 (텍스트 길이 + 1)
        hGlobal = GlobalAlloc(GMEM_MOVEABLE, UBound(charArray) + 2) ' NULL 종료 추가
        
        ' 메모리에 텍스트 저장
        lpGlobal = GlobalLock(hGlobal)
        For i = 0 To UBound(charArray)
            PtrSafeAssign lpGlobal, i, charArray(i)
        Next i
        
        ' NULL 종료 문자 추가
        PtrSafeAssign lpGlobal, UBound(charArray) + 1, 0
        
        GlobalUnlock hGlobal
        
        ' 클립보드에 데이터 설정
        SetClipboardData CF_TEXT, hGlobal
        
        ' 클립보드 닫기
        CloseClipboard
    Else
        MsgBox "클립보드를 열 수 없습니다. 다른 프로그램에서 클립보드를 점유 중일 수 있습니다.", vbCritical
    End If
End Sub

Private Sub PtrSafeAssign(lpBase As LongPtr, offset As Long, value As Byte)
    Dim pTarget As LongPtr
    pTarget = lpBase + offset
    Call WriteMemoryByte(pTarget, value)
End Sub

Private Sub WriteMemoryByte(lpAddress As LongPtr, value As Byte)
    Dim arr(0 To 0) As Byte
    arr(0) = value
    Call CopyByteToMemory(lpAddress, arr)
End Sub

Private Sub CopyByteToMemory(lpAddress As LongPtr, arr() As Byte)
    Dim hGlobal As LongPtr
    Dim lpGlobal As LongPtr

    hGlobal = GlobalAlloc(GMEM_MOVEABLE, UBound(arr) - LBound(arr) + 1)
    lpGlobal = GlobalLock(hGlobal)

    CopyMemoryByElement lpGlobal, arr, LBound(arr), UBound(arr)
    GlobalUnlock hGlobal
End Sub