저장 오류 지속: 사물함 관리 표에서 행을 추가하거나 수정하고 저장 시 여전히 오류 발생 (이전의 "UserName 필드 필요" 오류 외 다른 오류일 가능성 높음). 코드 양이 줄었다는 느낌은 아마 여러 번 수정본을 드리면서 특정 파일만 제공했기 때문일 수 있습니다. 전체적인 구조는 유지되고 있습니다.
종료 시 로그 로딩 오류: 메인 창을 닫을 때 "로그 로딩 오류" 발생.
종료 시 마스터 데이터 로딩 오류: 메인 창을 닫을 때 "마스터 데이터 로딩 중 예기치 않은 오류" 발생.
원인 분석 및 해결 방향:

저장 오류: base.SaveChanges()에서 오류가 발생한다면, 이는 데이터베이스 제약 조건 위반(NULL 불가, UNIQUE 위반, 길이 초과 등) 또는 로그 기록 중 예외 발생 가능성이 높습니다. 가장 중요한 것은 정확한 오류 메시지를 확인하는 것입니다. DbContext와 MainViewModel의 오류 처리 로직을 강화하여 더 상세한 오류 내용을 파악하도록 하겠습니다. 또한, LockerAssignment 모델 정의를 다시 확인하여 [Required] 등이 잘못 적용되지 않았는지 보겠습니다.
종료 시 로딩 오류 (로그/마스터 데이터): 이는 창이 닫히는 시점에 MainViewModel과 LogViewModel의 Dispose 메서드가 호출되어 DbContext가 해제되는데, 이때 아직 완료되지 않은 비동기 데이터 로딩 작업(LoadLogsAsync, LoadAssignmentsAsync 등)이 해제된 DbContext에 접근하려고 하면서 발생하는 ObjectDisposedException일 가능성이 높습니다. 이를 해결하기 위해 각 ViewModel에 CancellationTokenSource를 추가하고, 비동기 작업 시 CancellationToken을 전달하며, Dispose 시 작업을 취소하도록 수정합니다.
수정해야 할 파일 목록:

ViewModels/MainViewModel.cs (CancellationToken 추가, 오류 처리 강화)
ViewModels/LogViewModel.cs (CancellationToken 추가)
Data/LockerDbContext.cs (오류 처리 강화 확인용)
추가 확인 필요: Models/LockerAssignment.cs ([Required] 등 확인)
요청하신 대로 위 3개 파일(MainViewModel.cs, LogViewModel.cs, LockerDbContext.cs)의 수정된 전체 코드를 여기에 바로 작성합니다.

1. ViewModels/MainViewModel.cs (수정)

CancellationTokenSource 추가 및 관리.
LoadAssignmentsAsync에서 CancellationToken 사용.
Dispose 메서드에서 CancellationToken 취소.
오류 처리 메시지 상세화 유지.
C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Security;
using System.Threading; // CancellationTokenSource 사용
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics; // Debug 사용

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel (종료 시 오류 방지 - CancellationToken 추가)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }

        // *** 수정: 비동기 작업 취소를 위한 CancellationTokenSource 추가 ***
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        #region Public Properties (이전과 동일)
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands (이전과 동일)
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel(); // LogViewModel도 CancellationToken 처리 필요 (다음 파일 참고)
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync()); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync()); AddNewCommand = new RelayCommand(AddNewLocker); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync()); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        /// <summary>
        /// 초기 데이터 로드
        /// </summary>
        private async Task LoadInitialDataAsync()
        {
            // 취소 요청 확인
            if (_cts.IsCancellationRequested) return;
            await LoadMasterDataAsync();
            if (_cts.IsCancellationRequested) return;
            await LoadAssignmentsAsync();
        }

        /// <summary>
        /// 사물함 배정 목록 로드 (CancellationToken 사용)
        /// </summary>
        private async Task LoadAssignmentsAsync()
        {
            if (_context == null || _cts.IsCancellationRequested) return;
            StatusBarText = "사물함 목록 로딩 중...";
            try
            {
                // *** 수정: ToListAsync에 CancellationToken 전달 ***
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation)
                                               .ToListAsync(_cts.Token); // 취소 토큰 전달

                // 작업이 취소되지 않았을 경우에만 UI 업데이트
                if (!_cts.IsCancellationRequested)
                {
                    LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                    StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료.";
                }
            }
            catch (OperationCanceledException) // 작업 취소 시 예외 처리
            {
                Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨.");
                StatusBarText = "사물함 목록 로딩 취소됨.";
            }
            catch (Exception ex)
            {
                // 작업 취소 외 다른 예외 발생 시
                if (!_cts.IsCancellationRequested) // 취소된게 아니라면 오류 처리
                {
                    HandleGenericException("사물함 목록 로딩", ex);
                }
            }
        }

        /// <summary>
        /// 마스터 데이터 목록 로드 (임시 DbContext 사용, CancellationToken 사용)
        /// </summary>
        private async Task LoadMasterDataAsync()
        {
            // 이 메서드는 여러 DB 호출을 포함하므로 CancellationToken을 각 호출에 전달
            if (_cts.IsCancellationRequested) return;
            StatusBarText = "마스터 데이터(콤보박스용) 로딩 중...";
            LockerDbContext tempContext = null;
            try
            {
                using (tempContext = new LockerDbContext())
                {
                    // *** 수정: 각 ToListAsync에 CancellationToken 전달 ***
                    AllLockerTypes = new ObservableCollection<LockerType>(await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token));
                    if (_cts.IsCancellationRequested) return;
                    AllFloors = new ObservableCollection<Floor>(await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token));
                    if (_cts.IsCancellationRequested) return;
                    AllZones = new ObservableCollection<Zone>(await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token));
                    if (_cts.IsCancellationRequested) return;
                    AllSubParts = new ObservableCollection<SubPart>(await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token));
                    if (_cts.IsCancellationRequested) return;
                    AllAdministrators = new ObservableCollection<Administrator>(await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token));

                    if (!_cts.IsCancellationRequested)
                    {
                        StatusBarText = "마스터 데이터(콤보박스용) 로드 완료.";
                    }
                }
            }
            catch (OperationCanceledException)
            {
                Debug.WriteLine("LoadMasterDataAsync 작업 취소됨.");
                StatusBarText = "마스터 데이터 로딩 취소됨.";
            }
            catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { if (!_cts.IsCancellationRequested) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } }
            catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("마스터 데이터 로딩", ex); }
        }

        // CheckMasterPassword 메서드 (이전과 동일)
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; StatusBarText = "마스터 모드 활성화."; MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        // OpenMasterDataWindow 메서드 (이전과 동일 - 내부에서 새 VM 생성 및 Dispose)
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드 (이전과 동일)
        private async Task SaveChangesAsync() { if (_context == null || _cts.IsCancellationRequested) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); /* CancellationToken 전달 */ StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null || _cts.IsCancellationRequested) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); /* CancellationToken 전달 */ LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (!_cts.IsCancellationRequested) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Helper Methods (오류 메시지 상세화)
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현 (CancellationToken 취소 추가)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    // *** 수정: CancellationTokenSource 취소 호출 ***
                    _cts?.Cancel(); // 진행 중인 비동기 작업 취소 요청
                    _cts?.Dispose();

                    _context?.Dispose(); // DbContext 해제
                    LogVM?.Dispose();    // LogViewModel 해제
                }
                disposed = true;
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
2. ViewModels/LogViewModel.cs (수정)

CancellationTokenSource 추가 및 관리.
LoadLogsAsync에서 CancellationToken 사용.
Dispose 메서드에서 CancellationToken 취소.
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Diagnostics; // Debug 사용
using System.Linq;
using System.Threading; // CancellationTokenSource 사용
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 감사 로그 조회 ViewModel (종료 시 오류 방지 - CancellationToken 추가)
    /// </summary>
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        public ObservableCollection<AuditLog> AuditLogs { get; set; }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        // *** 수정: 비동기 작업 취소를 위한 CancellationTokenSource 추가 ***
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();

        public LogViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[Log] DB 연결 오류!"; AuditLogs = new ObservableCollection<AuditLog>(); LoadLogsCommand = new RelayCommand(_ => { }, _ => false); return; }

            AuditLogs = new ObservableCollection<AuditLog>();
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync());

            if (_context != null) { _ = LoadLogsAsync(); }
        }

        /// <summary>
        /// 감사 로그를 비동기적으로 로드합니다. (CancellationToken 사용)
        /// </summary>
        public async Task LoadLogsAsync()
        {
            if (_context == null || _cts.IsCancellationRequested) return; // 취소 확인
            StatusMessage = "로그 로딩 중...";
            try
            {
                // *** 수정: ToListAsync에 CancellationToken 전달 ***
                var logs = await _context.AuditLogs
                                         .OrderByDescending(log => log.Timestamp)
                                         .Take(1000)
                                         .AsNoTracking()
                                         .ToListAsync(_cts.Token); // 취소 토큰 전달

                // 작업이 취소되지 않았을 경우에만 UI 업데이트
                if (!_cts.IsCancellationRequested)
                {
                    AuditLogs.Clear();
                    logs.ForEach(AuditLogs.Add);
                    StatusMessage = $"총 {AuditLogs.Count}개 로그 로드.";
                }
            }
            catch (OperationCanceledException) // 작업 취소 시 예외 처리
            {
                Debug.WriteLine("LoadLogsAsync 작업 취소됨.");
                StatusMessage = "로그 로딩 취소됨.";
            }
            catch (Exception ex)
            {
                // 작업 취소 외 다른 예외 발생 시
                if (!_cts.IsCancellationRequested)
                {
                    StatusMessage = $"로그 로딩 오류: {ex.Message}";
                    MessageBox.Show($"{StatusMessage}\n\n데이터베이스 연결 및 로그 테이블 상태를 확인하세요.", "로그 로딩 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        #region IDisposable 구현 (CancellationToken 취소 추가)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    // *** 수정: CancellationTokenSource 취소 호출 ***
                    _cts?.Cancel(); // 진행 중인 비동기 작업 취소 요청
                    _cts?.Dispose();

                    _context?.Dispose(); // DbContext 해제
                }
                disposed = true;
            }
        }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
3. Data/LockerDbContext.cs (수정)

(이전 최종 버전과 동일 - Newtonsoft.Json 사용 및 오류 처리 강화 확인)

C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation; // DbEntityValidationException 사용
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json; // Newtonsoft.Json 사용 (NuGet 패키지 설치 필요)
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (SaveChanges 오류 처리 및 로깅 개선)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- DbSets (이전과 동일) ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        public LockerDbContext() : base("name=LockerDbConnection") { }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // LockerAssignment의 Nullable 문자열 속성 설정
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();

            base.OnModelCreating(modelBuilder);
        }

        #region SaveChanges Overrides for Audit Logging (Revised Error Handling)

        public override int SaveChanges()
        {
            List<AuditLog> auditEntries = null;
            // --- 로그 생성 (오류 발생 시 Debug 출력) ---
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            // --- 로그 추가 (오류 발생해도 계속 진행) ---
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }

            try { return base.SaveChanges(); } // 실제 저장 시도
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
        }

        public override async Task<int> SaveChangesAsync()
        {
             List<AuditLog> auditEntries = null;
            // --- 로그 생성 (오류 발생 시 Debug 출력) ---
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            // --- 로그 추가 (오류 발생해도 계속 진행) ---
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }

            try { return await base.SaveChangesAsync(); } // 실제 저장 시도 (비동기)
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
        }

        /// <summary>
        /// 감사 로그 엔트리 생성 (Newtonsoft.Json 사용)
        /// </summary>
        private List<AuditLog> CreateAuditEntries()
        {
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();
            var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) continue;
                var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() };
                try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();
                if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Modified) { foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (affectedColumns.Any()) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else continue; }
                auditEntries.Add(auditEntry);
            }
            UpdateLockerAssignmentTimestamps(changedEntries); return auditEntries;
        }

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; } }

        #endregion

        #region Error Logging Helpers (이전과 동일)
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.Message}"); var innerEx = dbEx.InnerException; while (innerEx != null) { Debug.WriteLine($"  InnerException: {innerEx.Message}"); innerEx = innerEx.InnerException; } foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
핵심 변경 사항:

MainViewModel.cs / LogViewModel.cs:
CancellationTokenSource 멤버 변수를 추가했습니다.
Dispose 메서드에서 _cts.Cancel()과 _cts.Dispose()를 호출하여 ViewModel이 해제될 때 진행 중인 비동기 작업을 취소하도록 했습니다.
LoadAssignmentsAsync, LoadMasterDataAsync, LoadLogsAsync, SaveChangesAsync, DeleteSelectedAsync 등 DbContext를 사용하는 주요 비동기 메서드에서 ToListAsync 또는 SaveChangesAsync 호출 시 _cts.Token을 전달하도록 수정했습니다.
해당 비동기 메서드들에 OperationCanceledException을 처리하는 catch 블록을 추가하여 작업 취소 시 오류 대신 정상적으로 처리되도록 했습니다.
LockerDbContext.cs:
SaveChanges/SaveChangesAsync 메서드에서 로그 생성 및 추가 로직을 감싸는 try-catch를 추가하여 로깅 자체의 오류가 발생해도 일단 Debug 창에 기록만 하고, 주 저장 로직은 계속 시도하도록 변경했습니다 (단, 저장 자체에서 오류 발생 시 예외는 다시 던짐).
JSON 직렬화를 JavaScriptSerializer 대신 Newtonsoft.Json의 JsonConvert.SerializeObject를 사용하도록 변경했습니다. NuGet에서 Newtonsoft.Json 패키지를 설치해야 합니다.