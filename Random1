형의 개수가 고정되어 있습니다. 각 시퀀스마다 3개의 함수가 실행되며, 3개의 도형만 표시되도록 설정되어 있습니다.

만약 함수의 개수에 따라 도형이 자동으로 추가되기를 원한다면, 각 작업마다 추가한 함수의 개수에 맞춰 도형을 동적으로 생성하도록 수정해야 합니다.

1. 함수 개수에 따라 도형을 자동으로 생성하는 방법
FunctionStatusColors와 FunctionNames 리스트의 크기를 함수 개수에 맞춰 동적으로 설정합니다.
각 함수가 동적으로 추가될 때마다 해당 함수에 맞는 도형과 이름을 자동으로 할당합니다.
TaskModel.cs (도형 개수를 함수 개수에 맞게 자동으로 생성하도록 수정)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics; // Stopwatch 사용

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 실행된 함수가 몇 초 동안 실행되었는지 경과 시간을 표시하며, 함수의 개수에 따라 도형을 동적으로 생성합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    
    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }
    
    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    // 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _stopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    // 동적으로 추가된 함수의 개수 (사용자 정의)
    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending"; // 처음엔 대기 상태
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        _stopwatch = new Stopwatch(); // Stopwatch 초기화

        FunctionStatusColors = new ObservableCollection<Brush>(); // 도형 상태 리스트 초기화
        FunctionNames = new ObservableCollection<string>(); // 함수 이름 리스트 초기화

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        // 동적으로 함수 개수 설정 (예: 5개의 함수가 있는 작업일 경우)
        _functionCount = GetFunctionCount(); // 동적으로 함수 개수를 가져옴
        InitializeFunctionColors(_functionCount); // 함수 개수에 맞게 도형 초기화
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트
        _stopwatch.Restart(); // Stopwatch를 시작하여 경과 시간을 기록

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        // 동적으로 할당된 함수 수에 따라 함수 실행
        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, ExecuteDynamicTask(i)); // 각 함수에 맞는 도형 및 경과 시간 업데이트
        }

        // 작업 완료 후 상태 변경 및 경과 시간 표시
        Status = "Completed";
        ProgressText = $"Completed in {_stopwatch.Elapsed.Seconds} seconds"; // 경과 시간을 ProgressText에 표시

        // 현재 작업이 끝났으므로 다음 작업 행을 실행
        StartNextTask?.Invoke(this);
    }

    /// <summary>
    /// 동적으로 추가된 함수 실행 (예: Task A, Task B, Task C 등)
    /// </summary>
    private Func<Task> ExecuteDynamicTask(int index)
    {
        return async () =>
        {
            await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
            ProgressText = $"Task {FunctionNames[index]} Completed in {_stopwatch.Elapsed.Seconds} seconds"; // 진행 상태 및 경과 시간 업데이트
        };
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// 작업 완료 시 경과 시간을 갱신합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            ProgressText = $"Running... ({_stopwatch.Elapsed.Seconds} seconds elapsed)"; // 경과 시간 실시간 갱신
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, ExecuteDynamicTask(taskIndex));
    }

    /// <summary>
    /// 동적으로 함수 개수를 결정하는 메서드 (사용자가 정의할 수 있음).
    /// </summary>
    private int GetFunctionCount()
    {
        // 예: 5개의 함수를 실행하는 작업이라고 가정 (여기서 함수 개수를 설정)
        return 5; // 필요한 경우 동적으로 함수 개수를 계산하거나, 설정 값을 불러올 수 있음
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors(int functionCount)
    {
        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
            FunctionNames.Add($"Task {i + 1}"); // 동적으로 함수 이름 추가
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
변경된 부분 설명:
동적으로 함수 개수를 설정:
_functionCount 변수를 사용하여 각 작업에 맞는 함수 개수를 동적으로 설정할 수 있도록 했습니다.
GetFunctionCount() 메서드를 통해 동적으로 실행해야 할 함수의 개수를 반환하며, 필요한 경우 함수 개수를 외부 입력이나 설정 값을