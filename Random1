import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

// ============================================================
// == 실행을 위한 메인 클래스
// ============================================================
public class TrackingSystemRunner {

    public static void main(String[] args) {
        System.out.println("====== 수배자 추적 시스템 시뮬레이션 시작 ======");

        // --- 시스템 전체의 구성요소(Component) 생성 (DI 컨테이너 역할) ---
        I로깅서비스 logger = new ConsoleLogger();
        I추적데이터저장_AI trackingHistoryRepo = new TrackingHistoryRepository();
        ResultPublisher resultPublisher = new ResultPublisher();
        I분석파이프라인 pipeline = new AnalysisPipeline(resultPublisher);
        I추적상태및전략관리 strategyPlanner = new StrategyPlannerFacade(trackingHistoryRepo);
        TrackingMissionManager missionManager = new TrackingMissionManager(pipeline, strategyPlanner);
        TaskReceiver taskReceiver = new TaskReceiver(missionManager);
        VirtualMessageBroker messageBroker = new VirtualMessageBroker(taskReceiver, strategyPlanner);
        resultPublisher.setMessageBroker(messageBroker);
        I비동기이벤트발행_App mqGw = new MqGateway(messageBroker);
        커맨드실행기 invoker = new 커맨드실행기();
        
        // --- 시나리오 1: 일반 추적 모드 ---
        System.out.println("\n\n--- [시나리오 1] S-001 '일반 추적 모드' 임무 수행 ---");
        I임무명령팩토리 realTimeFactory = new 실시간추적명령팩토리(new CctvGateway(), mqGw);
        I임무오케스트레이션 realTimeService = new 임무오케스트레이션서비스(realTimeFactory, invoker, logger);
        
        // 1. '일반' 임무 요청
        임무요청DTO standardRequest = new 임무요청DTO("실시간 추적", "강남역 일대", TrackingMode.STANDARD);
        String standardJobId = realTimeService.임무요청처리(standardRequest).join();
        
        // 2. 발견 -> 추적중 상태로
        resultPublisher.publishAnalysisResult(new AnalysisResult(standardJobId, "FOUND", "강남역 11번 출구"));
        
        // 3. 놓침 -> '놓침' 상태로 전환되고 '반경확대전략' 사용
        resultPublisher.publishAnalysisResult(new AnalysisResult(standardJobId, "LOST", "CGV 뒷골목"));


        System.out.println("\n\n----------------------------------------------------");


        // --- 시나리오 2: 총력 추적 모드 ---
        System.out.println("\n\n--- [시나리오 2] S-007 '총력 추적 모드' 임무 수행 ---");
        
        // 1. '총력' 임무 요청
        임무요청DTO aggressiveRequest = new 임무요청DTO("실시간 추적", "신촌역 일대", TrackingMode.AGGRESSIVE);
        String aggressiveJobId = realTimeService.임무요청처리(aggressiveRequest).join();
        
        // 2. 발견 -> 추적중 상태로
        resultPublisher.publishAnalysisResult(new AnalysisResult(aggressiveJobId, "FOUND", "신촌역 3번 출구"));
        
        // 3. 놓침 -> '재탐색강화' 상태로 전환되고 '드론지원탐색전략' 사용
        resultPublisher.publishAnalysisResult(new AnalysisResult(aggressiveJobId, "LOST", "현대백화점 인근"));
        
        System.out.println("\n====== 시뮬레이션 종료 ======");
    }
}

// ============================================================
// == 가상 메시지 브로커
// ============================================================
class VirtualMessageBroker {
    private TaskReceiver taskReceiver; private I추적상태및전략관리 strategyPlanner;
    public VirtualMessageBroker(TaskReceiver r, I추적상태및전략관리 p) { this.taskReceiver = r; this.strategyPlanner = p; }
    public void publishTask(String topic, 분석데이터 data) {
        System.out.println("\n[Virtual MQ] 작업 수신 (Priority: "+ data.priority +"). AI 서버 TaskReceiver에게 전달...");
        taskReceiver.onMessageReceived(data);
    }
    public void publishResult(String topic, AnalysisResult result) {
        System.out.println("\n[Virtual MQ] 결과 수신. AI 서버 StrategyPlanner에게 전달...");
        strategyPlanner.handleEvent(result.jobId(), new EventData(result.status(), result.location()));
    }
}

// ============================================================
// == 공통 DTO 및 로깅
// ============================================================
enum TrackingMode { STANDARD, AGGRESSIVE }
record 임무요청DTO(String missionType, String target, TrackingMode mode) {}
record EventData(String type, String location) {}
record AnalysisResult(String jobId, String status, String location) {}
class 분석데이터 { public String jobId; public TrackingMode mode; public String priority; }
interface I로깅서비스 { void log(String message); }
class ConsoleLogger implements I로깅서비스 {
    @Override public void log(String message) { System.out.println("[LOG] " + message); }
}

// ============================================================
// == Node 2: 추적 및 관리 서비스 노드 (App Server)
// ============================================================
interface I임무오케스트레이션 { CompletableFuture<String> 임무요청처리(임무요청DTO 요청); }
class 임무오케스트레이션서비스 implements I임무오케스트레이션 {
    private final I임무명령팩토리 _commandFactory; private final 커맨드실행기 _commandInvoker; private final I로깅서비스 _logger;
    public 임무오케스트레이션서비스(I임무명령팩토리 f, 커맨드실행기 i, I로깅서비스 l) {
        this._commandFactory = f; this._commandInvoker = i; this._logger = l;
    }
    @Override
    public CompletableFuture<String> 임무요청처리(임무요청DTO 요청) {
        _logger.log(요청.missionType() + " 임무 요청 수신 (대상: " + 요청.target() + ", 모드: " + 요청.mode() + ")");
        String 작업ID = "job-" + UUID.randomUUID().toString().substring(0, 8);
        분석데이터 data = new 분석데이터(); data.jobId = 작업ID; data.mode = 요청.mode();
        data.priority = (요청.mode() == TrackingMode.AGGRESSIVE) ? "HIGH" : "NORMAL";

        I명령 primaryCommand = _commandFactory.주요명령생성(요청.target());
        I명령 secondaryCommand = _commandFactory.보조명령생성(data);
        _commandInvoker.커맨드추가및실행(primaryCommand);
        _commandInvoker.커맨드추가및실행(secondaryCommand);
        return CompletableFuture.completedFuture(작업ID);
    }
}
interface I명령 { CompletableFuture<Void> 실행하기(); }
class 커맨드실행기 {
    private final Queue<I명령> _commandQueue = new ConcurrentLinkedQueue<>();
    public void 커맨드추가및실행(I명령 명령) { _commandQueue.add(명령); 명령.실행하기(); }
}
class 영상요청명령 implements I명령 {
    private final I영상소스제공 _receiver; private final String _area;
    public 영상요청명령(I영상소스제공 r, String a) { this._receiver = r; this._area = a; }
    @Override public CompletableFuture<Void> 실행하기() { return CompletableFuture.runAsync(() -> _receiver.requestStream(_area)); }
}
class AI분석요청명령 implements I명령 {
    private final I이벤트발행 _receiver; private final 분석데이터 _data;
    public AI분석요청명령(I이벤트발행 r, 분석데이터 d) { this._receiver = r; this._data = d; }
    @Override public CompletableFuture<Void> 실행하기() { return CompletableFuture.runAsync(() -> _receiver.publishEvent(_data)); }
}
interface I임무명령팩토리 { I명령 주요명령생성(String p); I명령 보조명령생성(분석데이터 d); }
class 실시간추적명령팩토리 implements I임무명령팩토리 {
    private final I영상소스제공 _videoProvider; private final I이벤트발행 _eventPublisher;
    public 실시간추적명령팩토리(I영상소스제공 v, I이벤트발행 e) { this._videoProvider = v; this._eventPublisher = e; }
    @Override public I명령 주요명령생성(String p) { return new 영상요청명령(_videoProvider, p); }
    @Override public I명령 보조명령생성(분석데이터 d) { return new AI분석요청명령(_eventPublisher, d); }
}
interface I영상소스제공 { void requestStream(String area); }
interface I이벤트발행 { void publishEvent(분석데이터 data); }
class CctvGateway implements I영상소스제공 {
    @Override public void requestStream(String area) { System.out.println("  > [CctvGateway] " + area + " 실시간 영상 요청"); }
}
class MqGateway implements I이벤트발행 {
    private final VirtualMessageBroker messageBroker;
    public MqGateway(VirtualMessageBroker broker) { this.messageBroker = broker; }
    @Override public void publishEvent(분석데이터 data) {
        System.out.println("  > [MqGateway] AI 분석 작업 발행");
        messageBroker.publishTask("Analysis_Tasks", data);
    }
}

// ============================================================
// == Node 3: 지능형 영상 분석 노드 (AI Server) - 구현체 다양화
// ============================================================
class TaskReceiver {
    private final TrackingMissionManager _missionManager;
    public TaskReceiver(TrackingMissionManager m) { this._missionManager = m; }
    public void onMessageReceived(분석데이터 message) {
        _missionManager.startNewMission(message);
    }
}
class ResultPublisher {
    private VirtualMessageBroker messageBroker;
    public void setMessageBroker(VirtualMessageBroker b) { this.messageBroker = b; }
    public void publishAnalysisResult(AnalysisResult result) {
        System.out.println("  > [ResultPublisher] 분석 결과 발행");
        messageBroker.publishResult("Analysis_Results", result);
    }
}
class TrackingMissionManager {
    private final I분석파이프라인 _pipeline; private final I추적상태및전략관리 _strategyPlanner;
    public TrackingMissionManager(I분석파이프라인 p, I추적상태및전략관리 s) { this._pipeline = p; this._strategyPlanner = s; }
    public void startNewMission(분석데이터 missionData) {
        System.out.println("[AI-Server] " + missionData.jobId + " 임무 관리자: 새로운 임무 시작 (모드: " + missionData.mode + ")");
        _strategyPlanner.initializeContext(missionData.jobId, missionData.mode);
        _pipeline.process(missionData.jobId, "videostream-example");
    }
}
interface I분석파이프라인 { void process(String jobId, Object videoStream); }
class AnalysisPipeline implements I분석파이프라인 {
    private final ResultPublisher _resultPublisher;
    public AnalysisPipeline(ResultPublisher p) { this._resultPublisher = p; }
    @Override public void process(String jobId, Object videoStream) {
        System.out.println("  > [Pipeline] " + jobId + " 영상 처리 시작...");
    }
}
interface I추적상태및전략관리 {
    void initializeContext(String jobId, TrackingMode mode);
    void handleEvent(String jobId, EventData event);
    void printHistory(String jobId);
}
class StrategyPlannerFacade implements I추적상태및전략관리 {
    private final Map<String, 추적작업맥락> _contextMap = new ConcurrentHashMap<>();
    private final I추적데이터저장_AI _repo;
    public StrategyPlannerFacade(I추적데이터저장_AI repo) { this._repo = repo; }
    private 추적작업맥락 getContext(String jobId) { return _contextMap.get(jobId); }
    @Override
    public void initializeContext(String jobId, TrackingMode mode) {
        _contextMap.put(jobId, new 추적작업맥락(jobId, mode, _repo));
    }
    @Override
    public void handleEvent(String jobId, EventData event) {
        추적작업맥락 context = getContext(jobId);
        if (context == null) return;
        System.out.println("[AI-Server] " + jobId + "에 " + event.type() + " 이벤트 발생 ("+ event.location() +")");
        context.handle(event);
    }
    @Override public void printHistory(String jobId) { getContext(jobId).printHistory(); }
}

// --- Memento Pattern ---
class 추적상태메멘토 {
    private final String stateName; private final String location;
    public 추적상태메멘토(String s, String l) { this.stateName = s; this.location = l; }
    @Override public String toString() { return LocalDateTime.now() + " | 상태: " + stateName + " | 위치: " + location; }
}
class 이력관리자 {
    private final List<추적상태메멘토> _mementos = new ArrayList<>();
    public 이력관리자() {}
    public void saveState(추적작업맥락 originator) { _mementos.add(originator.createMemento()); }
    public void printHistory(String jobId) {
        System.out.println("--- 추적 이력 (" + jobId + ") ---");
        _mementos.forEach(m -> System.out.println("  " + m));
    }
}

// --- State & Strategy Pattern (구현체 다양화) ---
class 추적작업맥락 {
    private I추적상태 _currentState; private final 이력관리자 _caretaker; public String lastKnownLocation; public final TrackingMode mode;
    public 추적작업맥락(String jobId, TrackingMode mode, I추적데이터저장_AI repo) {
        this.mode = mode; this._caretaker = new 이력관리자(); this._currentState = new 탐색중상태();
        System.out.println("  >> " + jobId + " 작업 맥락 생성. [추적 모드: " + mode + "] [초기 상태: 탐색중]");
        saveState();
    }
    public void setState(I추적상태 newState) { this._currentState = newState; }
    public void handle(EventData event) { this.lastKnownLocation = event.location(); _currentState.handle(this, event); saveState(); }
    public 추적상태메멘토 createMemento() { return new 추적상태메멘토(_currentState.getClass().getSimpleName(), lastKnownLocation); }
    public void saveState() { _caretaker.saveState(this); }
    public void printHistory() { _caretaker.printHistory(); }
}
interface I추적상태 { void handle(추적작업맥락 context, EventData event); }
class 탐색중상태 implements I추적상태 {
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("FOUND".equals(event.type())) {
            System.out.println("  >> [탐색중] -> [추적중] 상태로 변경!");
            context.setState(new 추적중상태());
        }
    }
}
class 추적중상태 implements I추적상태 {
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("LOST".equals(event.type())) {
            // [핵심] 추적 모드에 따라 다음 상태를 다르게 결정
            if (context.mode == TrackingMode.AGGRESSIVE) {
                System.out.println("  >> [추적중] -> [재탐색강화] 상태로 변경! (총력 모드)");
                context.setState(new 재탐색강화상태());
            } else {
                System.out.println("  >> [추적중] -> [놓침] 상태로 변경! (일반 모드)");
                context.setState(new 놓침상태());
            }
        } else if ("FOUND".equals(event.type())) { /* 위치 업데이트 생략 */ }
    }
}
class 놓침상태 implements I추적상태 { // 일반 모드용
    private I재탐색전략 _strategy = new 반경확대전략();
    public 놓침상태() { System.out.println("    - (일반 놓침 상태. 재탐색 전략: '" + _strategy.getClass().getSimpleName() + "')"); }
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("FOUND".equals(event.type())) { context.setState(new 추적중상태()); } 
        else { _strategy.execute(context.lastKnownLocation); }
    }
}
/**
 * [코드 리뷰] 신규 상태 클래스 (총력 모드용)
 * '총력 추적 모드'에서만 사용되는 특수한 상태입니다.
 * 더 강력하고 다양한 재탐색 전략을 사용할 수 있습니다.
 */
class 재탐색강화상태 implements I추적상태 {
    private I재탐색전략 _strategy = new 드론지원탐색전략(); // 더 강력한 전략을 기본으로 사용
    public 재탐색강화상태() { System.out.println("    - (총력 놓침 상태. 재탐색 전략: '" + _strategy.getClass().getSimpleName() + "')"); }
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("FOUND".equals(event.type())) { context.setState(new 추적중상태()); } 
        else {
            // 여러 전략을 동시에 사용하거나 더 복잡한 로직 수행 가능
            _strategy.execute(context.lastKnownLocation);
            new 과거동선기반전략().execute(context.lastKnownLocation);
        }
    }
}

interface I재탐색전략 { void execute(String lastKnownLocation); }
class 반경확대전략 implements I재탐색전략 {
    @Override public void execute(String loc) { System.out.println("    - [전략 실행] '" + loc + "' 주변 반경 확대 재탐색"); }
}
class 과거동선기반전략 implements I재탐색전략 {
    @Override public void execute(String loc) { System.out.println("    - [전략 실행] '" + loc + "'에서 과거 동선 기반 재탐색"); }
}
/**
 * [코드 리뷰] 신규 전략 클래스
 * '총력 추적 모드'에서 사용할 수 있는 새로운 알고리즘입니다.
 * 이처럼 전략(알고리즘)을 클래스로 분리하면, 새로운 전략을 계속 추가해도 기존 코드에 영향을 주지 않습니다.
 */
class 드론지원탐색전략 implements I재탐색전략 {
    @Override public void execute(String loc) { System.out.println("    - [전략 실행] ★★★ '" + loc + "'에 드론을 급파하여 긴급 항공 수색 실시 ★★★"); }
}

// --- Repository (Infrastructure) ---
interface I추적데이터저장_AI { }
class TrackingHistoryRepository implements I추적데이터저장_AI { }