ilelog.txt에 남기도록 수정한 코드를 작성하겠습니다. 오류 발생 시에도 F:\filelog.txt에 로그를 남기도록 하겠습니다.

XAML 파일 (MainWindow.xaml):
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="File Copier" Height="350" Width="525">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <StackPanel Orientation="Horizontal" Margin="10">
            <CheckBox x:Name="IndividualFolderCheckBox" Content="Individual Folders" Margin="5"/>
        </StackPanel>

        <ListBox x:Name="LogListBox" Grid.Row="1" Margin="10" MaxHeight="200"/>

        <Button x:Name="StartButton" Content="Start" Grid.Row="2" Click="StartButton_Click" Margin="10"/>
    </Grid>
</Window>
C# 코드 (MainWindow.xaml.cs):
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace WpfApp
{
    public partial class MainWindow : Window
    {
        private ObservableCollection<string> _logMessages = new ObservableCollection<string>();
        private readonly string _sourceFilePath = @"C:\Agent\1.jpg";
        private readonly string _destinationRootPath = @"F:\ABC";
        private readonly string _logFilePath = @"F:\filelog.txt";
        private bool _isRunning = false;

        public MainWindow()
        {
            InitializeComponent();
            LogListBox.ItemsSource = _logMessages;
        }

        private void StartButton_Click(object sender, RoutedEventArgs e)
        {
            if (_isRunning)
            {
                MessageBox.Show("Process is already running.");
                return;
            }

            _isRunning = true;
            Task.Run(() => CopyFilesAsync());
        }

        private async Task CopyFilesAsync()
        {
            while (_isRunning)
            {
                var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
                var fileName = $"{timestamp}file.jpg";
                var destinationPath = IndividualFolderCheckBox.IsChecked == true
                    ? Path.Combine(_destinationRootPath, timestamp, fileName)
                    : Path.Combine(_destinationRootPath, DateTime.Now.ToString("yyyyMMdd"), fileName);

                try
                {
                    var folderPath = Path.GetDirectoryName(destinationPath);
                    if (!Directory.Exists(folderPath))
                    {
                        Directory.CreateDirectory(folderPath);
                    }

                    File.Copy(_sourceFilePath, destinationPath, true);
                    AddLog($"File copied to: {destinationPath}");
                    LogToFile($"File copied to: {destinationPath}");

                    if (_logMessages.Count > 200)
                    {
                        Dispatcher.Invoke(() => _logMessages.RemoveAt(0));
                    }
                }
                catch (Exception ex)
                {
                    var errorMessage = $"Error: {ex.Message}";
                    AddLog(errorMessage);
                    LogToFile(errorMessage);
                    Debug.WriteLine($"Error: {ex}");
                }

                await Task.Delay(2000); // 2초 대기
            }
        }

        private void AddLog(string message)
        {
            Dispatcher.Invoke(() => _logMessages.Add($"{DateTime.Now:HH:mm:ss} - {message}"));
        }

        private void LogToFile(string message)
        {
            try
            {
                using (StreamWriter writer = new StreamWriter(_logFilePath, true))
                {
                    writer.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
                }
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"Log file writing error: {ex.Message}");
            }
        }
    }
}
주요 포인트
고정 경로 사용: _destinationRootPath와 _logFilePath를 각각 F:\ABC와 F:\filelog.txt로 고정하여 사용합니다.
비동기 작업: Task.Run과 async/await를 사용하여 비동기적으로 파일을 복사하고 UI가 항상 반응하도록 합니다.
UI 업데이트: Dispatcher.Invoke를 사용하여 UI 요소를 업데이트합니다.
폴더 및 파일 구조: 사용자의 선택에 따라 개별 폴더 또는 그룹 폴더 구조를 만듭니다.
로그 관리: ObservableCollection을 사용하여 로그 메시지를 관리하고, 최대 200개의 항목만 유지합니다.
파일 로그 관리: StreamWriter를 사용하여 파일 복사 이력을 F:\filelog.txt에 기록합니다.
에러 로깅: 오류 발생 시 Debug.WriteLine을 통해 디버그 로그에 오류 메시지를 남깁니다.
이 코드를 실행하면 지정된 경로로 파일을 복사하고, 설정 옵션에 따라 파일과 폴더 구조를 관리하며, F:\filelog.txt 파일에 복사 이력과 오류 로그를 남기는 WPF 응용 프로그램을 얻을 수 있