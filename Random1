네, 알겠습니다. DatabaseService.cs 수정에 이어, 이제 Agent 설정을 위한 창의 ViewModel과 코드 비하인드를 수정하겠습니다.

로그인 시스템이 없어졌으므로, AgentConfigViewModel은 더 이상 currentUserId를 받지 않고, 대신 어떤 모드(예: "AdminMode")에서 이 작업이 수행되었는지 나타내는 간단한 문자열 정보(modifierInfo)를 MainViewModel로부터 전달받아 DB에 기록 시 사용합니다.

2. ViewModels/AgentConfigViewModel.cs (수정된 전체 코드)

C#

// MGSPMonitorControl/ViewModels/AgentConfigViewModel.cs
using System;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using MGSPMonitorControl.Models;
using MGSPMonitorControl.Services;
// 네임스페이스 MonitorControl.SharedModels를 사용한다고 가정 (MessageContract.cs)
// using MonitorControl.SharedModels; 

namespace MGSPMonitorControl.ViewModels
{
    public class AgentConfigViewModel : ObservableObject
    {
        private readonly IDatabaseService _databaseService;
        private readonly string _modifierInfo; // 예: "AdminMode", "System" 등 DB에 기록될 수정자 정보
        private ManagedAgentDisplay _agentToConfigure;
        private bool _isEditMode;

        public ManagedAgentDisplay Agent
        {
            get => _agentToConfigure;
            set => SetProperty(ref _agentToConfigure, value);
        }

        private string _windowTitle;
        public string WindowTitle
        {
            get => _windowTitle;
            set => SetProperty(ref _windowTitle, value);
        }

        private string _errorMessage;
        public string ErrorMessage
        {
            get => _errorMessage;
            set => SetProperty(ref _errorMessage, value);
        }
        
        public ObservableCollection<string> ControlTypes { get; } = new ObservableCollection<string> { "Direct", "Gatewayed" };

        public ICommand SaveCommand { get; }
        
        // 새 Agent 추가용 생성자
        public AgentConfigViewModel(IDatabaseService databaseService, string modifierInfo)
        {
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _modifierInfo = modifierInfo ?? "UnknownModifier"; // 수정자 정보 (예: 현재 모드)
            _isEditMode = false;
            WindowTitle = "Add New Agent Configuration";
            Agent = new ManagedAgentDisplay 
            { 
                AgentGuid = Guid.NewGuid(),
                IsEnabled = true,
                ControlType = "Direct", 
                PrimaryPort = 4099, // Agent의 기본 리슨 포트 (사용자 입력 가능)
                // GatewayAgentPort도 기본적으로 Agent 리슨 포트와 동일할 수 있음
                GatewayAgentPort = 4099 
            }; 
            SaveCommand = new RelayCommand(async () => await ExecuteSaveAsync(), CanExecuteSave);
        }

        // 기존 Agent 수정용 생성자
        public AgentConfigViewModel(IDatabaseService databaseService, string modifierInfo, ManagedAgentDisplay agentToEdit)
        {
            _databaseService = databaseService ?? throw new ArgumentNullException(nameof(databaseService));
            _modifierInfo = modifierInfo ?? "UnknownModifier";
            _isEditMode = true;
            
            // 원본 객체를 직접 수정하지 않도록 복사본 생성 또는 주요 속성만 복사
            Agent = new ManagedAgentDisplay 
            {
                AgentGuid = agentToEdit.AgentGuid,
                AgentIdProvidedByApp = agentToEdit.AgentIdProvidedByApp,
                AgentName = agentToEdit.AgentName,
                Description = agentToEdit.Description,
                ControlType = agentToEdit.ControlType,
                PrimaryIpAddress = agentToEdit.PrimaryIpAddress,
                PrimaryPort = agentToEdit.PrimaryPort,
                GatewayAgentIpAddress = agentToEdit.GatewayAgentIpAddress,
                GatewayAgentPort = agentToEdit.GatewayAgentPort,
                IsEnabled = agentToEdit.IsEnabled
                // 실시간 상태 정보는 여기서는 편집 대상이 아님
            };
            WindowTitle = $"Edit Agent - {Agent.AgentName}";
            SaveCommand = new RelayCommand(async () => await ExecuteSaveAsync(), CanExecuteSave);
        }

        private bool CanExecuteSave()
        {
            ErrorMessage = string.Empty; // 유효성 검사 전 에러 메시지 초기화
            bool isValid = true;
            var errorMessages = new List<string>();

            if (string.IsNullOrWhiteSpace(Agent.AgentIdProvidedByApp)) { errorMessages.Add("- Agent ID (IP or Unique Identifier provided by agent) is required."); isValid = false; }
            if (string.IsNullOrWhiteSpace(Agent.AgentName)) { errorMessages.Add("- Agent Name is required."); isValid = false; }
            if (string.IsNullOrWhiteSpace(Agent.ControlType)) { errorMessages.Add("- Control Type is required."); isValid = false; } // ComboBox이므로 보통 선택됨
            if (string.IsNullOrWhiteSpace(Agent.PrimaryIpAddress)) { errorMessages.Add("- Primary IP Address is required."); isValid = false; }
            if (Agent.PrimaryPort <= 0 || Agent.PrimaryPort > 65535) { errorMessages.Add("- Primary Port must be between 1 and 65535."); isValid = false; }

            if (Agent.ControlType == "Gatewayed")
            {
                if (string.IsNullOrWhiteSpace(Agent.GatewayAgentIpAddress)) { errorMessages.Add("- Gateway Agent IP Address (or ID) is required for Gatewayed control."); isValid = false; }
                if (!Agent.GatewayAgentPort.HasValue || Agent.GatewayAgentPort.Value <= 0 || Agent.GatewayAgentPort.Value > 65535) 
                    { errorMessages.Add("- Gateway Agent Port must be between 1 and 65535."); isValid = false; }
                
                // 게이트웨이 IP와 최종 타겟 IP가 동일한지 체크 (선택적)
                if (Agent.PrimaryIpAddress == Agent.GatewayAgentIpAddress && Agent.PrimaryPort == Agent.GatewayAgentPort)
                {
                    errorMessages.Add("- Gateway cannot be the same as the final target agent with the same port."); isValid = false;
                }
            }
            
            if (!isValid)
            {
                ErrorMessage = string.Join(Environment.NewLine, errorMessages);
            }
            return isValid;
        }

        private async Task ExecuteSaveAsync()
        {
            if (!CanExecuteSave()) // 최종 유효성 검사
            {
                // ErrorMessage는 CanExecuteSave에서 이미 설정됨
                return;
            }

            try
            {
                bool success;
                if (_isEditMode)
                {
                    success = await _databaseService.UpdateManagedAgentAsync(Agent, _modifierInfo);
                }
                else
                {
                    // 새 Agent 추가 시, 동일한 AgentIdProvidedByApp가 이미 DB에 있는지 확인
                    var existingAgent = await _databaseService.GetManagedAgentByProvidedIdAsync(Agent.AgentIdProvidedByApp);
                    if (existingAgent != null)
                    {
                        ErrorMessage = $"An agent configuration with ID (IP) '{Agent.AgentIdProvidedByApp}' already exists in the database.";
                        return;
                    }
                    success = await _databaseService.AddManagedAgentAsync(Agent, _modifierInfo);
                }

                if (success)
                {
                    RaiseSaveSuccess(); // 저장 성공 시 View에 알림 (창 닫기용)
                }
                else
                {
                    ErrorMessage = "Failed to save agent configuration to the database. Please check logs or try again.";
                }
            }
            catch (Exception ex)
            {
                ErrorMessage = $"Error saving agent configuration: {ex.Message}";
                Console.WriteLine($"[AgentConfigViewModel ERROR] Error saving agent: {ex.ToString()}");
                // 실제 애플리케이션에서는 파일 로깅 서비스 사용
            }
        }

        public event Action SaveSuccess;
        private void RaiseSaveSuccess() => SaveSuccess?.Invoke();
    }
}
AgentConfigViewModel.cs 주요 변경점:

생성자에서 int currentUserId 대신 string modifierInfo를 받도록 변경했습니다. 이 modifierInfo는 DB의 ManagedAgents.LastModifiedByInfo 컬럼에 기록될 값입니다 (예: "AdminMode").
ExecuteSaveAsync 메서드에서 _databaseService.AddManagedAgentAsync 및 UpdateManagedAgentAsync 호출 시 _modifierInfo를 전달합니다.
CanExecuteSave 메서드에 간단한 유효성 검사 로직 및 ErrorMessage 업데이트를 추가했습니다.
새 Agent 추가 시, AgentIdProvidedByApp (주로 IP)가 DB에 이미 존재하는지 확인하는 로직을 추가했습니다 (중복 방지).
Agent 객체 초기화 시 PrimaryPort 및 GatewayAgentPort의 기본값을 AgentConfigViewModel.AppConstants (임시 내부 클래스)에서 가져오도록 했던 부분을, Agent 프로그램의 고정 리슨 포트(예: 4099)를 사용자가 인지하고 직접 입력하거나 기본값으로 설정되도록 변경했습니다. (DB 스키마의 ManagedAgents.PrimaryPort는 UI가 Broker에게 "이 Agent의 이 포트로 접속해"라고 알려줄 정보이고, Agent 프로그램은 AppConstants.AgentListenPort에서 항상 리슨합니다. 이 두 값이 일치해야 합니다.)
3. Views/AgentConfigWindow.xaml.cs (Agent 추가/수정 창 코드 비하인드 - 수정됨)

ViewModel 생성자에 modifierInfo를 전달하도록 변경합니다. MainViewModel에서 이 창을 열 때 현재 활성화된 모드 정보를 이 생성자로 넘겨주어야 합니다.

C#

// MGSPMonitorControl/Views/AgentConfigWindow.xaml.cs
using System.Windows;
using MGSPMonitorControl.ViewModels; // AgentConfigViewModel

namespace MGSPMonitorControl.Views
{
    public partial class AgentConfigWindow : Window
    {
        private AgentConfigViewModel _viewModel;

        // ViewModel을 생성자에서 주입받습니다.
        public AgentConfigWindow(AgentConfigViewModel viewModel)
        {
            InitializeComponent();
            _viewModel = viewModel;
            DataContext = _viewModel;

            // ViewModel의 저장 성공 이벤트 구독
            _viewModel.SaveSuccess += OnSaveSuccess;
        }

        private void OnSaveSuccess()
        {
            DialogResult = true; // 모달 다이얼로그의 결과 설정 (저장 성공)
            // Close(); // DialogResult = true로 설정하면 ShowDialog() 호출 시 자동으로 닫힘
        }

        // Cancel 버튼은 XAML에서 IsCancel="True"로 설정하면 자동으로 DialogResult = false가 됨.
        // 별도의 Click 이벤트 핸들러는 필요 없을 수 있음.

        // 창이 닫힐 때 이벤트 구독 해제 (메모리 누수 방지)
        protected override void OnClosed(System.EventArgs e)
        {
            if (_viewModel != null)
            {
                _viewModel.SaveSuccess -= OnSaveSuccess;
            }
            base.OnClosed(e);
        }
    }
}
AgentConfigWindow.xaml.cs 주요 변경점:

생성자에서 AgentConfigViewModel을 직접 만들지 않고, 외부(보통 MainViewModel)에서 생성된 인스턴스를 주입받도록 변경했습니다. 이렇게 하면 MainViewModel이 현재 활성화된 모드(modifierInfo)를 AgentConfigViewModel 생성 시 전달할 수 있습니다.
Views/AgentConfigWindow.xaml (Agent 추가/수정 창 XAML - 이전 답변과 동일)
이 파일의 XAML 코드는 이전 답변에서 제공한 것과 동일하게 사용하시면 됩니다. (DataBinding은 ViewModel의 프로퍼티 이름 변경이 없다면 그대로 작동합니다.)