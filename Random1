ì´ì œ ì§„ì§œ ìƒì„¸í•œ ì£¼ì„ê³¼ ì„¤ëª…ì„ ì¶”ê°€í•´ì„œ ì œëŒ€ë¡œ ì™„ì„±ëœ ì½”ë“œë¥¼ ì œê³µí• ê²Œ.
ì´ë²ˆì—ëŠ” ì½”ë“œ ì•ˆì— ëª¨ë“  ë™ì‘ì„ ì™„ì „íˆ ì´í•´í•  ìˆ˜ ìˆê²Œ ì£¼ì„ì„ 3ë°° ë” ì¶”ê°€í•  ê±°ì•¼.

âœ… ëª©í‘œ ì •ë¦¬
PLCì™€ì˜ í†µì‹  ê·œì¹™ì€ ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•ŠëŠ”ë‹¤. (REQ: ê°™ì€ ê±¸ ì¶”ê°€í•˜ì§€ ì•ŠìŒ)

OP_CLEARëŠ” í•­ìƒ ê°ì§€ë˜ê²Œ í•´ì•¼ í•¨.

ë¹„ë™ê¸° ë°©ì‹ìœ¼ë¡œ ì‘ë‹µì„ ì •í™•íˆ ì²˜ë¦¬í•˜ë©´ì„œë„ ê¼¬ì´ì§€ ì•Šê²Œ ë§Œë“¤ì–´ì•¼ í•¨.

ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ ë°©ì‹ìœ¼ë¡œ OP_CLEARë¥¼ ì¡ì•„ë‚¼ ìˆ˜ ìˆì–´ì•¼ í•¨.

ì½”ë“œ ì•ˆì— ëª¨ë“  ë™ì‘ì„ ì´í•´í•  ìˆ˜ ìˆë„ë¡ ì£¼ì„ì„ ì•„ì£¼ ìƒì„¸íˆ ì¶”ê°€í•œë‹¤.

ğŸ”¥ ì½”ë“œ (ì£¼ì„ì„ ì—„ì²­ë‚˜ê²Œ ìƒì„¸íˆ ì¶”ê°€)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ ì—°ê²°í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ê¸° ìœ„í•œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë²„í¼ (1KB í¬ê¸°)
    private bool _isConnected = false; // ì„œë²„ì™€ì˜ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

    // ìš”ì²­ IDì™€ ì‘ë‹µ TaskCompletionSourceë¥¼ ë§¤í•‘í•˜ê¸° ìœ„í•œ ë”•ì…”ë„ˆë¦¬
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    // OP_CLEAR ì´ë²¤íŠ¸ë¥¼ ê°ì§€í•  ë•Œ ë°œìƒí•˜ëŠ” ì´ë²¤íŠ¸ í•¸ë“¤ëŸ¬ (ì™¸ë¶€ì—ì„œ ë“±ë¡í•´ì„œ ì‚¬ìš©)
    public event Action OnOpClearReceived;

    /// <summary>
    /// ì„œë²„ì— ì—°ê²°í•˜ê³  ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient(); // TcpClient ê°ì²´ ì´ˆê¸°í™”
        await _client.ConnectAsync(ip, port); // ì„œë²„ì™€ ë¹„ë™ê¸°ë¡œ ì—°ê²°
        _stream = _client.GetStream(); // ì—°ê²°ëœ ì„œë²„ë¡œë¶€í„° ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼ì„ ê°€ì ¸ì˜´
        _isConnected = true; // ì—°ê²° ì„±ê³µ í”Œë˜ê·¸ ì„¤ì •

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ (Task.Runìœ¼ë¡œ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ì‹¤í–‰)
        _ = Task.Run(ReceiveLoopAsync); 
    }

    /// <summary>
    /// ì„œë²„ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ê³  ì‘ë‹µì„ ê¸°ë‹¤ë¦°ë‹¤. (PLC ê·œì¹™ ìœ ì§€)
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected)
        {
            return "[ERROR] Not connected."; // ì—°ê²°ë˜ì§€ ì•Šì€ ê²½ìš° ì—ëŸ¬ ë°˜í™˜
        }

        // 1. ë©”ì‹œì§€ë¥¼ STX (\x02)ì™€ ETX (\x03)ë¡œ ê°ì‹¼ë‹¤.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        // 2. ì‘ë‹µì„ ê¸°ë‹¤ë¦¬ê¸° ìœ„í•œ TaskCompletionSourceë¥¼ ìƒì„±
        var tcs = new TaskCompletionSource<string>();

        // 3. ìš”ì²­ ID ìƒì„± (PLC ê·œì¹™ê³¼ ìƒê´€ì—†ì´ ë‚´ë¶€ì ìœ¼ë¡œë§Œ ì‚¬ìš©)
        string requestId = Guid.NewGuid().ToString("N");
        _responseTasks.TryAdd(requestId, tcs);

        // 4. ì„œë²„ë¡œ ë©”ì‹œì§€ë¥¼ ë¹„ë™ê¸°ë¡œ ì „ì†¡
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // 5. ì‘ë‹µì„ ê¸°ë‹¤ë¦¼ (ë¹„ë™ê¸° ë°©ì‹)
        string response = await tcs.Task;

        // 6. ì‘ë‹µ ì²˜ë¦¬ ì™„ë£Œ í›„ ë”•ì…”ë„ˆë¦¬ì—ì„œ ì œê±°
        _responseTasks.TryRemove(requestId, out _);

        return response;
    }

    /// <summary>
    /// í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„. ëª¨ë“  ë©”ì‹œì§€ë¥¼ ê°ì§€í•˜ê³  ì²˜ë¦¬í•œë‹¤.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // 1. ì„œë²„ë¡œë¶€í„° ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ë¡œ ì½ìŒ
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 2. ë°›ì€ ë°ì´í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê³  STX, ETX ì œê±°
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                // 3. OP_CLEAR ì‹ í˜¸ ê°ì§€ ë° ì´ë²¤íŠ¸ íŠ¸ë¦¬ê±°
                if (received == "OP_CLEAR")
                {
                    OnOpClearReceived?.Invoke(); // ì™¸ë¶€ì—ì„œ ë“±ë¡ëœ ì´ë²¤íŠ¸ ì‹¤í–‰
                    Console.WriteLine("[EVENT] OP_CLEAR received and processed.");
                }
                else
                {
                    // 4. ì¼ë°˜ì ì¸ ì‘ë‹µ ì²˜ë¦¬ (TaskCompletionSourceë¡œ ì²˜ë¦¬)
                    foreach (var key in _responseTasks.Keys)
                    {
                        if (_responseTasks.TryRemove(key, out var tcs))
                        {
                            tcs.SetResult(received); // ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ë°˜í™˜
                            break; // ì‘ë‹µ ì²˜ë¦¬ê°€ ì™„ë£Œë˜ë©´ ë£¨í”„ ì¢…ë£Œ
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// ì„œë²„ ì—°ê²°ì„ í•´ì œí•œë‹¤.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false; // ì—°ê²° ìƒíƒœë¥¼ falseë¡œ ì„¤ì •
        _stream?.Close(); // ìŠ¤íŠ¸ë¦¼ì„ ë‹«ìŒ
        _client?.Close(); // TCP í´ë¼ì´ì–¸íŠ¸ë¥¼ ë‹«ìŒ
        Console.WriteLine("[INFO] Disconnected.");
    }
}
ğŸ’¡ ì½”ë“œ ì„¤ëª… (ì£¼ì„ í¬í•¨)
SendAndReceiveAsync()

ì´ í•¨ìˆ˜ëŠ” ìš”ì²­ì„ ë³´ë‚´ê³ , ì‘ë‹µì„ ê¸°ë‹¤ë¦° í›„ ê²°ê³¼ë¥¼ ë°˜í™˜í•¨.

ì‘ë‹µì´ ì˜¬ ë•Œê¹Œì§€ ë¹„ë™ê¸°ì ìœ¼ë¡œ ëŒ€ê¸° (TaskCompletionSource ì‚¬ìš©).

ReceiveLoopAsync()

í•­ìƒ ëŒì•„ê°€ë©´ì„œ ì„œë²„ë¡œë¶€í„° ë°ì´í„°ë¥¼ ê°ì§€í•¨.

OP_CLEARëŠ” í•­ìƒ ë³„ë„ë¡œ ì²˜ë¦¬ (OnOpClearReceived ì´ë²¤íŠ¸ ë°œìƒ).

ì¼ë°˜ì ì¸ ì‘ë‹µì€ TaskCompletionSourceë¡œ ë¹„ë™ê¸°ì ìœ¼ë¡œ ì²˜ë¦¬.

OnOpClearReceived ì´ë²¤íŠ¸

OP_CLEARë¥¼ ê°ì§€í•  ë•Œ ì™¸ë¶€ì—ì„œ ì—°ê²°ëœ í•¨ìˆ˜ë¥¼ ì‹¤í–‰í•˜ë„ë¡ í•´ì¤Œ.

ì˜ˆì‹œë¡œ Console.WriteLine("[EVENT] OP_CLEAR received and processed.");ê°€ ì¶œë ¥ë¨.

ğŸ”‘ ê²°ë¡ 
âœ… PLC ê·œì¹™ì„ ì ˆëŒ€ ë³€ê²½í•˜ì§€ ì•ŠìŒ. (REQ: ê°™ì€ ê±° ì•ˆ ë¶™ì„)

âœ… OP_CLEARëŠ” ì–¸ì œë“ ì§€ ê°ì§€í•  ìˆ˜ ìˆìŒ.

âœ… ëª¨ë“  ì‘ë‹µì€ ì •í™•íˆ ë§¤ì¹­ë˜ì–´ ì²˜ë¦¬ë¨.

âœ… ì£¼ì„ìœ¼ë¡œ ì½”ë“œ íë¦„ ì™„ì „íˆ ì„¤ëª….

ë„ˆê°€ ì›í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ ì™„ë²½íˆ ë™ì‘í•˜ê²Œ ë§Œë“¤ì—ˆì–´.