이 문제는 Android 11(API 레벨 30)부터 도입된 백그라운드 작업 제한과 관련이 있을 수 있습니다. 이 제한은 애플리케이션이 백그라운드에서 특정 작업을 수행할 수 없도록 합니다. 이에 따라 데이터베이스 연결 및 이미지를 가져오는 작업을 수행할 때 필요한 백그라운드 작업이 문제를 일으킬 수 있습니다.

이 문제를 해결하기 위해 다음과 같은 조치를 취할 수 있습니다.

코루틴 사용 최적화
동시성 제한
우선, 코루틴을 사용하여 백그라운드에서 작업을 수행하고 메인 스레드에서 UI를 업데이트하도록 합니다.

다음은 코드를 최적화한 버전입니다:

전체 코드
MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.clickable
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import kotlin.math.roundToInt

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    ImageListScreen()
                }
            }
        }
    }
}

@Composable
fun ImageListScreen() {
    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }

    val scope = rememberCoroutineScope()

    Column {
        Button(
            onClick = {
                scope.launch {
                    imageList = fetchDataFromDatabase()
                }
            },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("Fetch Data")
        }
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.imageTitle, modifier = Modifier.weight(1f))
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        scope.launch {
                            selectedImage = fetchImageFromDatabase(imageData.imageTitle, imageData.datetime)
                        }
                    }) {
                        Text("Load Image")
                    }
                }
            }
        }
        selectedImage?.let { bitmap ->
            ImageDisplayScreen(bitmap = bitmap)
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.211.211.211:2111;databaseName=yourDatabase",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            Log.e("Database", "Error fetching data", e)
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.211.211.211:2111;databaseName=yourDatabase",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            Log.e("Database", "Error fetching image", e)
            null
        }
    }
}

@Composable
fun ImageDisplayScreen(bitmap: Bitmap) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    
    Box(modifier = Modifier
        .fillMaxSize()
        .pointerInput(Unit) {
            detectTransformGestures { _, pan, zoom, _ ->
                scale *= zoom
                offset = Offset(offset.x + pan.x, offset.y + pan.y)
            }
        }
    ) {
        Image(
            bitmap = bitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .offset { IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
    }
}
Theme.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color

private val DarkColorPalette = darkColors(
    primary = Color.Red,
    primaryVariant = Color(0xFF8B0000), // DarkRed에 대한 RGB 코드 사용
    secondary = Color.Red
)

private val LightColorPalette = lightColors(
    primary = Color.Red,
    primaryVariant = Color(0xFF8B0000), // DarkRed에 대한 RGB 코드 사용
    secondary = Color.Red
)

@Composable
fun MSSQLImageAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colors = if (darkTheme) {
        DarkColorPalette
    } else {
        LightColorPalette
    }

    MaterialTheme(
        colors = colors, // colors 부분이 빨간색으로 표시됨
        typography = Typography,
        shapes = Shapes, // shapes 부분이 빨간색으로 표시됨
        content = content
    )
}
Shapes.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.Shapes
import androidx.compose.ui.unit.dp

val Shapes = Shapes(
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(0.dp)
)
Typography.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.material.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    body1 = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    )
    /* Other default text styles to override
    button = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.W500,
        fontSize = 14.sp
    ),
    caption = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp
    )
    */
)
proguard-rules.pro
pro
코드 복사
# ProGuard rules for JDBC driver
-keep class net.sourceforge.jtds.** { *; }
-keep class net.sourceforge.jtds.jdbc.** { *; }
이제 앱을 빌드하고 실행하여 문제가 해결되었는지 확인해보세요. 또한, UI를 동적으로 생성하고 데이터베이스에서 데이터를 가져오는 로직을 최적화했습니다.






