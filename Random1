ertyChanged를 사용한 일반 속성 역시 기본적으로 참조 타입이라면 참조로 전달됩니다. 따라서, MainViewModel에서 넘겨준 객체를 다른 클래스에서 수정하면, 원본 객체도 영향을 받습니다.

하지만, 일반 속성은 ObservableCollection처럼 컬렉션 내부 변경을 자동으로 감지하지 못하기 때문에, 값을 변경할 때 반드시 OnPropertyChanged를 호출해야 UI가 업데이트됩니다.

코드 예제
다음은 OnPropertyChanged로 구현된 일반 속성을 다른 클래스에 전달하는 상황을 보여줍니다.

MailViewModel 클래스
csharp
코드 복사
using System.ComponentModel;

public class MailViewModel : INotifyPropertyChanged
{
    private string _email;

    public string Email
    {
        get => _email;
        set
        {
            if (_email != value)
            {
                _email = value;
                OnPropertyChanged(nameof(Email));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
MainViewModel 클래스
csharp
코드 복사
public class MainViewModel
{
    private MailViewModel _mailViewModel;

    public string Email
    {
        get => _mailViewModel.Email;
        set => _mailViewModel.Email = value; // MailViewModel의 값을 직접 수정
    }

    public MainViewModel(MailViewModel mailViewModel)
    {
        _mailViewModel = mailViewModel;
    }
}
동작 확인
csharp
코드 복사
MailViewModel mailViewModel = new MailViewModel();
MainViewModel mainViewModel = new MainViewModel(mailViewModel);

// MainViewModel에서 값 변경
mainViewModel.Email = "newemail@example.com";

// MailViewModel에서 값 확인
Console.WriteLine(mailViewModel.Email); // newemail@example.com
결론
일반 속성도 참조 타입이기 때문에, 객체가 전달되면 동일한 인스턴스를 참조합니다.
따라서 값을 변경하면 원본 객체에도 변경이 반영됩니다.
주의사항
OnPropertyChanged는 UI 업데이트에 필요:

값이 변경되었을 때 UI에 반영하려면, OnPropertyChanged 호출이 필수입니다.
이를 누락하면 UI는 변경된 값을 감지하지 못합니다.
값 타입은 복사:

참조 타입이 아닌 경우(예: int, double)는 값이 복사되어 전달되므로, 변경해도 원본은 영향을 받지 않습니다.
요약
참조 타입 변수는 넘겨도 참조로 전달되므로, 값을 변경하면 원본도 영향을 받습니다.