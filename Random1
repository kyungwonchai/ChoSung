알겠습니다. originalBitmapImage가 함수 실행으로 계속 바뀌는 상황이군요. 두 번째 파일을 선택했을 때 에러가 나는 것은 이전 이미지의 정보(특히 자르기 영역)가 초기화되지 않고 남아있기 때문입니다.

예를 들어,

첫 번째로 2000x2000 크기의 큰 이미지를 불러와서 (1500, 1500) 지점을 자릅니다. -> 성공

두 번째로 800x800 크기의 작은 이미지를 불러옵니다. originalBitmapImage는 새 이미지로 잘 바뀌었습니다.

하지만 프로그램은 여전히 (1500, 1500)이라는 좌표를 기억하고 있습니다.

이 좌표로 800x800 이미지를 자르려고 하니, 이미지 크기를 벗어나므로 "값이 예상 범위를 벗어났습니다" 에러가 발생하는 것입니다.

## 해결 방법: 새 파일 선택 시 상태를 완벽하게 초기화하기
파일을 새로 선택하고 originalBitmapImage를 교체할 때, 관련된 모든 변수와 컨트롤을 완전히 초기 상태로 되돌려야 합니다.

핵심은 LoadImage와 같은 함수에서 이미지 로딩과 함께 "초기화" 로직을 반드시 실행하는 것입니다.

올바른 코드 구조 예시:

C#

// 클래스 멤버 변수들
private BitmapImage originalBitmapImage;
private Int32Rect cropArea; // 자르기 영역을 저장하는 변수
// private Point startPoint, endPoint; // 마우스 드래그로 영역을 선택한다면 관련 변수들

// --- 파일 선택 버튼 ---
private void SelectFileButton_Click(object sender, RoutedEventArgs e)
{
    var openFileDialog = new Microsoft.Win32.OpenFileDialog();
    openFileDialog.Filter = "Image files (*.png;*.jpeg;*.jpg)|*.png;*.jpeg;*.jpg|All files (*.*)|*.*";
    if (openFileDialog.ShowDialog() == true)
    {
        // 새 파일을 로드하고 모든 상태를 초기화하는 함수를 호출합니다.
        LoadNewImage(openFileDialog.FileName);
    }
}

// ★★★ 새 이미지를 로드하고 모든 상태를 초기화하는 핵심 함수 ★★★
private void LoadNewImage(string filePath)
{
    try
    {
        // 1. 새 BitmapImage 객체를 생성하여 로드합니다.
        originalBitmapImage = new BitmapImage();
        originalBitmapImage.BeginInit();
        originalBitmapImage.UriSource = new Uri(filePath);
        originalBitmapImage.CacheOption = BitmapCacheOption.OnLoad; // 메모리 누수 방지
        originalBitmapImage.EndInit();
        originalBitmapImage.Freeze();

        // 2. 화면의 Image 컨트롤 소스를 새 원본 이미지로 설정합니다.
        //    (이전의 CroppedBitmap 결과가 남아있지 않도록)
        imageControl.Source = originalBitmapImage;

        // 3. (가장 중요) 이전에 사용했던 모든 관련 변수를 초기화합니다.
        cropArea = Int32Rect.Empty; // 자르기 영역 초기화
        // startPoint = new Point();    // 마우스 좌표 등도 모두 초기화
        // endPoint = new Point();

        // TODO: 화면에 사각형을 그리는 등 UI 요소가 있다면 그것도 제거/초기화해야 합니다.
        // (예: selectionRectangle.Visibility = Visibility.Collapsed;)
    }
    catch (Exception ex)
    {
        MessageBox.Show($"이미지 로드 실패: {ex.Message}");
        originalBitmapImage = null; // 실패 시 변수를 null로 설정
    }
}

// --- 자르기 버튼 ---
private void CropButton_Click(object sender, RoutedEventArgs e)
{
    if (originalBitmapImage == null)
    {
        MessageBox.Show("먼저 이미지를 선택해주세요.");
        return;
    }

    // 이 시점에서 cropArea는 마우스 드래그 등으로 새로 계산되어야 합니다.
    // 여기서는 예시로 고정된 값을 사용합니다.
    cropArea = new Int32Rect(10, 10, 100, 100);

    // 유효성 검사
    if (cropArea.X + cropArea.Width > originalBitmapImage.PixelWidth ||
        cropArea.Y + cropArea.Height > originalBitmapImage.PixelHeight)
    {
        MessageBox.Show("자르기 영역이 이미지 크기를 벗어났습니다.");
        return;
    }

    // 항상 현재의 originalBitmapImage에서 자릅니다.
    CroppedBitmap croppedResult = new CroppedBitmap(originalBitmapImage, cropArea);
    imageControl.Source = croppedResult;
}
요약 체크리스트
파일을 새로 선택하는 함수(LoadNewImage) 안에서 아래 3가지 작업이 모두 이루어지는지 확인하세요.

originalBitmapImage를 새 이미지로 교체했는가?

Image 컨트롤의 Source를 이전의 잘린 결과(CroppedBitmap)가 아닌, 새로 로드한 originalBitmapImage로 되돌렸는가?