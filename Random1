네, "AttributeError: module 'app.scheduler_tasks' has no attribute 'scheduled_task_monitor_on'" 오류는 app/__init__.py 파일에서 APScheduler에 작업을 등록하려고 할 때, app/scheduler_tasks.py 모듈 내에서 scheduled_task_monitor_on이라는 이름의 함수(또는 변수/클래스 등)를 찾을 수 없다는 의미입니다.

이 오류의 일반적인 원인은 다음과 같습니다:

함수 이름 오타: app/scheduler_tasks.py 파일에 정의된 함수 이름과 app/__init__.py에서 호출하는 함수 이름이 정확히 일치하지 않을 수 있습니다 (대소문자 포함).
함수 미정의 또는 주석 처리: app/scheduler_tasks.py 파일에 해당 함수가 실제로 정의되지 않았거나, 실수로 주석 처리되었을 수 있습니다.
잘못된 임포트 또는 파일 문제: app/scheduler_tasks.py 파일 자체에 다른 오류가 있거나, Python이 해당 파일을 모듈로 제대로 인식하지 못했을 수 있습니다 (이 경우는 AttributeError보다는 ImportError가 먼저 발생할 가능성이 높지만, 모듈은 로드되었으나 특정 이름만 없는 경우 AttributeError가 발생합니다).
이 문제를 해결하기 위해, app/scheduler_tasks.py 파일의 전체 내용과 app/__init__.py 파일에서 해당 작업을 등록하는 부분의 코드를 다시 한번 확인하여 제공해 드리겠습니다. 사용자님의 코드와 비교하여 함수 이름 등이 정확한지 확인해 주십시오.

1. 수정/확인: app/scheduler_tasks.py (전체 코드)
이 파일에 scheduled_task_monitor_on와 scheduled_task_monitor_off 함수가 올바르게 정의되어 있는지 확인합니다. (이전 답변 #38에서 제공된 코드입니다.)

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date, time # time은 현재 직접 사용 안함
import holidays # 한국 공휴일 확인용
from flask import current_app # 로깅 및 DB 연결에 app 컨텍스트 필요
from .db_utils import get_db_connection # pymssql 직접 사용
from .socket_client import send_command_to_agent # SAgentM 통신용
import json
import uuid
from datetime import datetime as dt, timezone # dt로 별칭 부여, timezone 사용

# --- 날짜 판단 로직 ---
def is_operational_day(target_date):
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            current_app.logger.error("is_operational_day: DB 연결 실패. 기본값(가동일)으로 처리합니다.")
            return True 

        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"
            cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),))
            exception_day = cursor.fetchone()
            if exception_day:
                is_op = bool(exception_day['is_operational'])
                current_app.logger.info(f"{target_date}는 사용자 지정 예외일: {'가동일' if is_op else '비가동일'}")
                return is_op

        if target_date.weekday() >= 5: # 토요일(5) 또는 일요일(6)
            current_app.logger.info(f"{target_date}는 주말(비가동일)입니다.")
            return False

        kr_holidays = holidays.KR(years=target_date.year) 
        if target_date in kr_holidays:
            current_app.logger.info(f"{target_date}는 공휴일('{kr_holidays.get(target_date)}')입니다. (비가동일)")
            return False
            
        current_app.logger.info(f"{target_date}는 평일(가동일)입니다.")
        return True

    except Exception as e:
        current_app.logger.error(f"is_operational_day 함수 실행 중 오류: {e}", exc_info=True)
        return True 
    # finally:
        # conn은 teardown_appcontext에서 자동으로 닫힙니다.

# --- 실제 명령 전송 로직 ---
def _send_display_timeout_to_all_pcs(timeout_minutes, action_description):
    conn = None
    pcs_to_control = []
    try:
        conn = get_db_connection()
        if not conn:
            current_app.logger.error(f"_send_display_timeout_to_all_pcs: DB 연결 실패. 명령을 보낼 수 없습니다.")
            return

        with conn.cursor() as cursor:
            cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs")
            pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"스케줄 작업 중 PC 목록 조회 오류: {e}", exc_info=True)
        return 

    if not pcs_to_control:
        current_app.logger.info("스케줄 작업: 제어할 PC가 등록되어 있지 않습니다.")
        return

    current_app.logger.info(f"스케줄 작업 시작: '{action_description}'을(를) {len(pcs_to_control)}대의 PC에 전송합니다.")
    payload_obj = {'TimeoutMinutes': timeout_minutes}
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        command_packet = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': common_command_name,
            'PayloadJson': json.dumps(payload_obj),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            command_packet['Instruction'] = "RelayToTarget"
            command_packet['FinalTargetIpForRelayedCommand'] = pc_data['address2']
            command_packet['FinalTargetPortForRelayedCommand'] = 4026
            target_ip_for_command = pc_data['address1']
        else:
            command_packet['Instruction'] = "DirectExecute"
            target_ip_for_command = pc_data['address1']

        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip_for_command})]" # pc_name 없을 경우 대비
        current_app.logger.info(f"{log_prefix} - '{action_description}' 명령 전송 시도. PktID: {command_packet['PacketId']}")
        try:
            agent_response = send_command_to_agent(target_ip_for_command, command_packet)
            if agent_response.get('success'):
                raw_resp_packet = agent_response.get('raw_response')
                if raw_resp_packet and isinstance(raw_resp_packet, dict) and raw_resp_packet.get('PayloadJson'):
                    resp_payload = json.loads(raw_resp_packet['PayloadJson'])
                    if resp_payload.get('Success'): current_app.logger.info(f"{log_prefix} - 명령 성공: {resp_payload.get('Message', 'OK')}")
                    else: current_app.logger.error(f"{log_prefix} - 명령 실패 (에이전트 응답): {resp_payload.get('Message', 'Agent error')}")
                else: current_app.logger.warning(f"{log_prefix} - 명령 전송 성공, 에이전트 상세 응답 확인 불가. Raw: {raw_resp_packet}")
            else: current_app.logger.error(f"{log_prefix} - 명령 전송 실패: {agent_response.get('message', 'Unknown socket error')}")
        except Exception as e_send:
            current_app.logger.error(f"{log_prefix} - 명령 전송 중 예외 발생: {e_send}", exc_info=True)

# --- APScheduler가 호출할 실제 작업 함수들 ---
def scheduled_task_monitor_on(): # <<--- 이 함수 이름이 정확해야 합니다.
    """매일 아침 6시에 실행될 작업: 가동일이면 모든 PC 모니터 켜기 설정."""
    with current_app.app_context(): 
        today = date.today()
        current_app.logger.info(f"[Scheduler] 모니터 켜기 작업 실행 (예정 시간: 06:00), 오늘 날짜: {today}")
        if is_operational_day(today):
            current_app.logger.info(f"[Scheduler] 오늘은 가동일. 모든 PC에 '모니터 켜기(타임아웃 해제)' 명령 전송.")
            _send_display_timeout_to_all_pcs(0, "디스플레이 항상 켜기 설정 (타임아웃 0분)")
        else:
            current_app.logger.info(f"[Scheduler] 오늘은 비가동일. '모니터 켜기' 명령 미실행.")

def scheduled_task_monitor_off(): # <<--- 이 함수 이름이 정확해야 합니다.
    """매일 아침 7시에 실행될 작업: 비가동일이면 모든 PC 모니터 끄기 설정."""
    with current_app.app_context():
        today = date.today()
        current_app.logger.info(f"[Scheduler] 모니터 끄기 작업 실행 (예정 시간: 07:00), 오늘 날짜: {today}")
        if not is_operational_day(today): 
            current_app.logger.info(f"[Scheduler] 오늘은 비가동일. 모든 PC에 '모니터 끄기(1분 후 타임아웃)' 명령 전송.")
            _send_display_timeout_to_all_pcs(1, "디스플레이 1분 후 자동 꺼짐 설정")
        else:
            current_app.logger.info(f"[Scheduler] 오늘은 가동일. '모니터 끄기' 명령 미실행.")
2. 수정/확인: app/__init__.py (스케줄러 작업 등록 부분)
create_app 함수 내에서 scheduler_tasks 모듈을 임포트하고, scheduler.add_job을 호출할 때 함수 이름이 정확한지 확인합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app
from config import config
import datetime
import os
from flask_apscheduler import APScheduler 

scheduler = APScheduler()

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # ... (Jinja2 필터, 컨텍스트 프로세서 등록은 이전과 동일) ...
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)

    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 

    if not scheduler.running:
        scheduler.init_app(app)
        
        from . import scheduler_tasks # <<--- scheduler_tasks.py 임포트

        if app.debug:
            # 기존 작업 ID와 동일한 ID로 add_job을 시도하면 APScheduler가 오류를 발생시킬 수 있으므로,
            # ID를 사용하여 기존 작업을 가져오고, 있다면 제거 후 다시 추가하거나, replace_existing=True 옵션 사용 고려.
            # 또는 ID를 매번 다르게 하거나, 앱 시작 시 한 번만 등록되도록 보장.
            # 여기서는 간단히 ID를 지정하고, 앱 재시작 시 기존 동일 ID 작업은 무시되거나 덮어쓰여질 수 있음 (스케줄러 설정에 따라 다름).
            # 더 확실하게 하려면 시작 시 remove_job 후 add_job.
            if scheduler.get_job('scheduled_task_monitor_on_daily'): # 기존 ID로 확인
                 scheduler.remove_job('scheduled_task_monitor_on_daily')
            if scheduler.get_job('scheduled_task_monitor_off_daily'):
                 scheduler.remove_job('scheduled_task_monitor_off_daily')
            app.logger.info("기존 스케줄러 작업들 (ID 기준) 제거 시도됨 (디버그 모드).")

        # 작업 등록 시 func 인자에 정확한 함수 이름 전달
        scheduler.add_job(id='scheduled_task_monitor_on_daily', # ID 변경 (이전 테스트용 ID와 구분)
                          func=scheduler_tasks.scheduled_task_monitor_on, # <<--- 이 부분 이름 확인!
                          trigger='cron', hour=6, minute=0, misfire_grace_time=3600) # 1시간 유예
        app.logger.info("스케줄 작업 'scheduled_task_monitor_on_daily' 매일 06:00 등록됨.")

        scheduler.add_job(id='scheduled_task_monitor_off_daily', # ID 변경
                          func=scheduler_tasks.scheduled_task_monitor_off, # <<--- 이 부분 이름 확인!
                          trigger='cron', hour=7, minute=0, misfire_grace_time=3600)
        app.logger.info("스케줄 작업 'scheduled_task_monitor_off_daily' 매일 07:00 등록됨.")
        
        # 테스트용 인터벌 트리거 (필요시 주석 해제)
        # scheduler.add_job(id='scheduled_task_monitor_on_test', func=scheduler_tasks.scheduled_task_monitor_on, trigger='interval', minutes=1, next_run_time=datetime.datetime.now() + datetime.timedelta(seconds=10))
        # scheduler.add_job(id='scheduled_task_monitor_off_test', func=scheduler_tasks.scheduled_task_monitor_off, trigger='interval', minutes=1, seconds=30, next_run_time=datetime.datetime.now() + datetime.timedelta(seconds=20))

        try:
            scheduler.start()
            app.logger.info("APScheduler 시작됨.")
        except Exception as e:
            app.logger.error(f"APScheduler 시작 실패: {e}", exc_info=True)

    app.logger.info("Flask application (with APScheduler) 생성 및 설정 완료.")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")

    return app
app/__init__.py 주요 변경/확인 사항:

from . import scheduler_tasks: app/scheduler_tasks.py 파일을 현재 패키지에서 임포트합니다.
func=scheduler_tasks.scheduled_task_monitor_on: add_job 메서드의 func 인자에 scheduler_tasks 모듈 내의 scheduled_task_monitor_on 함수를 정확히 지정합니다. scheduled_task_monitor_off도 마찬가지입니다.
작업 ID 및 중복 방지: add_job에 id를 부여했습니다. Flask 개발 서버가 재시작될 때 작업이 중복 등록되는 것을 막기 위해, app.debug 모드일 때 기존에 같은 ID로 등록된 작업이 있다면 scheduler.remove_job()을 통해 먼저 제거하는 로직을 추가했습니다. (APScheduler의 replace_existing=True 옵션을 사용하는 것도 방법입니다.) misfire_grace_time은 작업이 예정된 시간에 실행되지 못했을 때 얼마나 기다렸다가 실행할지 설정하는 유예시간입니다(초 단위).
위 두 파일 (app/scheduler_tasks.py 와 app/__init__.py)의 코드를 사용자님의 프로젝트와 주의 깊게 비교하여, 특히 함수 이름이 정확히 일치하는지, 그리고 app/scheduler_tasks.py 파일에 해당 함수들이 module-level (즉, 다른 함수나 클래스 내부에 정의되지 않고 파일의 최상위 레벨)에 정의되어 있는지 확인해주십시오.