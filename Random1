네, 사용자님 말씀처럼 에이전트(SAgentM.App)는 정상적으로 동작하고 응답까지 생성해서 보냈는데, Flask 웹 앱(SControlM)에서 그 응답을 올바르게 처리하지 못해 "JSON 형식 오류"가 발생하고 있을 가능성도 충분히 있습니다. 특히 powercfg 명령어 실행 결과처럼 여러 줄일 수 있거나 특수 문자가 포함될 수 있는 메시지를 PayloadJson 내부에 담아 전달할 때 문제가 생길 수 있습니다.

가장 의심되는 부분:

SAgentM.App (AgentCoreService.cs): GenericResponsePayload 객체를 JsonConvert.SerializeObject()를 통해 PayloadJson 문자열로 만들 때, 이 문자열이 Python의 json.loads()에서 문제를 일으키는 미묘한 형식 차이가 있을 수 있습니다. (예: 이스케이프 처리 방식, 특정 제어 문자 등)
Flask 웹 앱 (app/routes_user.py): SAgentM.App으로부터 받은 PayloadJson 문자열을 json.loads()로 다시 파싱할 때, 이 문자열이 Python 기준에서 유효한 JSON이 아닐 경우 오류가 발생합니다.
문제 해결을 위한 접근:

Flask 앱 (app/routes_user.py)에서 정확히 어떤 PayloadJson 문자열을 받았는지 로깅하여 확인합니다. (이전 답변에서 이 로깅 코드를 이미 추가했습니다.)
SAgentM.App (AgentCoreService.cs)에서 보내는 PayloadJson의 Message 부분을 최대한 단순화하여 테스트해봅니다. 이렇게 하면 powercfg의 복잡한 오류 메시지 내용 때문에 JSON 파싱 오류가 나는 것인지 확인할 수 있습니다.
먼저, Flask 앱의 app/routes_user.py 파일에서 PayloadJson을 파싱하는 부분의 로깅을 다시 한번 확인하고, Python의 JSONDecodeError 발생 시 좀 더 상세한 정보를 로깅하도록 수정하겠습니다.

1. 수정: app/routes_user.py (JSON 파싱 오류 로깅 강화)
send_batch_command 함수 내에서 에이전트 응답의 PayloadJson을 파싱하는 try-except 블록을 다음과 같이 수정합니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection
from app.auth import ip_auth_required
from app.socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime, timezone
import math

user_bp = Blueprint('user', __name__)

# control_panel 함수는 이전 답변과 동일하게 유지 (DB 조회 로직 등)
@user_bp.route('/control_panel')
@ip_auth_required('user')
def control_panel():
    page = request.args.get('page', 1, type=int)
    per_page = 20
    offset = (page - 1) * per_page
    pcs_on_current_page = []
    total_pcs = 0
    conn = None
    pagination_data = {'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 
                       'items': [], 'has_prev': False, 'has_next': False, 
                       'prev_num': 1, 'next_num': 1} 

    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute("SELECT COUNT(*) AS total FROM dbo.target_pcs")
            total_pcs_result = cursor.fetchone()
            if total_pcs_result: total_pcs = total_pcs_result['total']
            if total_pcs > 0:
                query = "SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY"
                cursor.execute(query, (offset, per_page))
                pcs_on_current_page = cursor.fetchall()
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({'total_items': total_pcs, 'total_pages': total_pages, 'items': pcs_on_current_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1, 'next_num': page + 1})
    except Exception as e:
        current_app.logger.error(f"제어판 PC 목록 조회 오류: {e}", exc_info=True)
        flash("PC 목록을 불러오는 중 오류가 발생했습니다. DB 연결을 확인하세요.", "error")
        
    title = "원격 제어판"; 
    if g.current_user_role == 'admin': title = "원격 제어판 (관리자 모드)"
    return render_template('user/control_panel.html', pcs=pcs_on_current_page, pagination=pagination_data, title=title)

@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    selected_pc_ids_str = request.form.getlist('selected_pcs')
    command_action_str = request.form.get('command_action')

    if not selected_pc_ids_str: flash("제어할 PC를 하나 이상 선택해주세요.", 'warning'); return redirect(url_for('user.control_panel'))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]: flash("수행할 명령(켜기/끄기)이 올바르게 지정되지 않았습니다.", 'warning'); return redirect(url_for('user.control_panel'))

    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]
    timeout_minutes_for_command = 0 if command_action_str == "켜기" else 1
    action_description_log = "디스플레이 항상 켜기 설정(타임아웃 0분)" if command_action_str == "켜기" else "디스플레이 1분 후 자동 꺼짐 설정"
    payload_for_agent = {'TimeoutMinutes': timeout_minutes_for_command}

    conn = None; target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids:
                placeholders = ', '.join(['%s'] * len(selected_pc_ids))
                sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"
                cursor.execute(sql_select_pcs, tuple(selected_pc_ids))
                target_pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True); flash("명령 대상 PC 정보를 DB에서 조회하는 중 오류가 발생했습니다.", "error"); return redirect(url_for('user.control_panel'))
    if not target_pcs_to_control: flash("선택된 PC 정보를 찾을 수 없습니다.", "warning"); return redirect(url_for('user.control_panel'))

    for pc_data in target_pcs_to_control:
        command_packet_to_send = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': "SET_DISPLAY_TIMEOUT", 'PayloadJson': json.dumps(payload_for_agent),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command_send = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            command_packet_to_send['Instruction'] = "RelayToTarget"; command_packet_to_send['FinalTargetIpForRelayedCommand'] = pc_data['address2']
            command_packet_to_send['FinalTargetPortForRelayedCommand'] = 4026; target_ip_for_command_send = pc_data['address1']
        else:
            command_packet_to_send['Instruction'] = "DirectExecute"; target_ip_for_command_send = pc_data['address1']
        
        log_msg_prefix = f"PC '{pc_data['pc_name']}' ({target_ip_for_command_send})"
        flash(f"{log_msg_prefix}에 '{action_description_log}' 명령 전송 시도...", 'info')
        current_app.logger.info(f"{log_msg_prefix} - 명령 전송: {action_description_log}, PktID: {command_packet_to_send['PacketId']}")
        agent_response = send_command_to_agent(target_ip_for_command_send, command_packet_to_send)
        
        if agent_response.get('success'):
            raw_resp_packet = agent_response.get('raw_response')
            if raw_resp_packet and isinstance(raw_resp_packet, dict) and 'PayloadJson' in raw_resp_packet: # PayloadJson 키 존재 여부 확인
                payload_json_str_from_agent = raw_resp_packet.get('PayloadJson')
                current_app.logger.info(f"{log_msg_prefix} - 수신된 PayloadJson 문자열: >>>{payload_json_str_from_agent}<<<")
                if payload_json_str_from_agent is not None: # None이 아닌 경우에만 파싱 시도
                    try:
                        resp_payload = json.loads(payload_json_str_from_agent) 
                        if resp_payload.get('Success'):
                            flash(f"{log_msg_prefix}: 성공 - {resp_payload.get('Message', 'OK')}", 'success')
                        else:
                            flash(f"{log_msg_prefix}: 실패 (에이전트 응답) - {resp_payload.get('Message', 'Agent error')}", 'error')
                    except json.JSONDecodeError as je: # <<--- JSONDecodeError 명시적 처리
                        flash(f"{log_msg_prefix}: 에이전트 응답 페이로드 JSON 형식 오류 - {je.msg} (at pos {je.pos})", 'error')
                        current_app.logger.error(f"{log_msg_prefix} - PayloadJson 파싱 오류: {je.msg} at pos {je.pos}. 원본: {payload_json_str_from_agent}", exc_info=True)
                    except Exception as e: # 기타 예외
                        flash(f"{log_msg_prefix}: 에이전트 응답 페이로드 처리 중 알 수 없는 오류 - {e}", 'error')
                        current_app.logger.error(f"{log_msg_prefix} - PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_json_str_from_agent}", exc_info=True)
                else: # PayloadJson이 None인 경우
                    flash(f"{log_msg_prefix}: 에이전트 응답에 PayloadJson이 없습니다.", 'warning')
                    current_app.logger.warning(f"{log_msg_prefix} - 에이전트 응답에 PayloadJson이 null입니다. RawPkt: {raw_resp_packet}")
            else: 
                flash(f"{log_msg_prefix}: 전송 성공 (에이전트 상세 응답/페이로드 없음)", 'warning')
                current_app.logger.warning(f"{log_msg_prefix} - 전송 성공, 그러나 에이전트 상세 응답/페이로드 없음. RawPkt: {raw_resp_packet}")
        else: 
            flash(f"{log_msg_prefix}: 전송 실패 - {agent_response.get('message', 'Unknown socket error')}", 'error')

    return redirect(url_for('user.control_panel'))
app/routes_user.py 주요 변경 사항:

send_batch_command 함수 내에서 raw_resp_packet.get('PayloadJson') 호출 전에 raw_resp_packet이 None이 아니고 PayloadJson 키를 가지고 있는지 확인하는 조건을 추가했습니다 ('PayloadJson' in raw_resp_packet).
payload_json_str_from_agent가 None이 아닌 경우에만 json.loads()를 시도하도록 변경했습니다.
json.loads()에서 발생하는 json.JSONDecodeError를 명시적으로 except 블록에서 잡아서, 오류 메시지(je.msg)와 오류 위치(je.pos)를 로그와 flash 메시지에 포함하도록 하여 디버깅에 더 용이하게 했습니다.
2. (테스트용) SAgentM.App/Services/AgentCoreService.cs의 응답 메시지 단순화
Flask 쪽 로그를 통해 원본 PayloadJson 문자열을 확인하는 것이 우선이지만, 동시에 SAgentM.App에서 보내는 메시지 자체를 매우 단순하게 만들어 테스트해볼 수 있습니다. 이렇게 하면 powercfg의 복잡한 오류 출력이 JSON 문제를 일으키는지 아닌지 판단하는 데 도움이 됩니다.

SAgentM.App/Services/AgentCoreService.cs의 ExecuteDirectCommandAsync 메서드에서 SetDisplayTimeout 부분만 임시로 다음과 같이 수정하여 테스트해볼 수 있습니다.

C#

// SAgentM.App/Services/AgentCoreService.cs - ExecuteDirectCommandAsync 메서드 내
// ...
case CommandNames.SetDisplayTimeout: 
    // ... (payload 역직렬화 로직은 그대로 둡니다) ...
    if (timeoutPayload == null) { /* ... 기존 오류 처리 ... */ break; }
    
    _loggingService.UiInfo($"[{clientIp}] (테스트 모드) 디스플레이 타임아웃 설정 시도: {timeoutPayload.TimeoutMinutes}분");
    
    // 실제 powercfg 호출 대신, 항상 고정된 단순 메시지로 응답 테스트
    success = true; // 또는 false로 테스트
    message = "Test response for SetDisplayTimeout, no special chars or newlines.";
    
    // string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
    // RunPowerCfgCommand(acArgs, out outputAc, out errorAc, out exitCodeAc);
    // RunPowerCfgCommand(dcArgs, out outputDc, out errorDc, out exitCodeDc);
    // if (exitCodeAc == 0 && exitCodeDc == 0) { ... } else { ... }
    
    responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
    break;
// ...
위 테스트용 수정의 의미:

powercfg를 실제로 호출하는 부분을 주석 처리하고, 대신 항상 success = true (또는 false)와 함께 아주 단순한 message 문자열로 응답을 만듭니다.
만약 이 단순화된 메시지로는 Flask에서 JSON 파싱 오류가 발생하지 않는다면, 문제는 원래의 powercfg 오류 메시지 문자열에 포함된 특정 내용(개행, 특수문자 등)이 원인일 가능성이 높습니다.
만약 이 단순화된 메시지로도 Flask에서 동일한 JSON 파싱 오류가 발생한다면, 문제는 메시지 내용보다는 전체적인 JSON 직렬화/역직렬화 과정이나 소켓 통신으로 전달되는 데이터 자체에 다른 문제가 있을 수 있습니다 (예: 인코딩, 데이터 잘림 등).
테스트 순서:

먼저, 수정된 app/routes_user.py만 Flask 앱에 적용하고, SAgentM.App은 이전 버전(개행 문자 제거 로직이 들어간 버전)을 그대로 사용합니다.
"끄기" 명령을 실행하여 오류를 재현합니다.
Flask 개발 서버 터미널 로그에 찍힌 에이전트로부터 받은 PayloadJson 문자열: >>>...<<< 내용 전체를 복사해서 저에게 알려주세요. 이것이 가장 중요합니다.
만약 위 3번 로그를 통해 원인 파악이 어렵거나, PayloadJson 문자열이 너무 복잡하여 분석이 힘들다면, 그때 SAgentM.App의 AgentCoreService.cs를 위 테스트용 코드(응답 메시지 단순화) 로 수정하여 다시 테스트해보고 그 결과를 알려주세요.
사용자님의 로그 정보가 있으면 정확한 원인 진단에 큰 도움이 됩니다!

