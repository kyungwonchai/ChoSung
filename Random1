아래는 FileSystemWatcher를 완전히 제거하고, 타이머만을 사용하여 주기적으로 파일을 체크하는 방식으로 구현된 코드입니다. 클래스 이름도 **FileChecker**로 변경했습니다. 이 코드는 특정 주기로 디렉토리 내의 로그 파일을 확인하고, 가장 최신 파일의 변경 사항을 감지하여 처리합니다.

수정된 코드 (FileChecker.cs)
csharp
코드 복사
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileChecker
    {
        // 로그 파일이 위치한 디렉토리 경로
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 정규식 패턴: 파일 이름 규칙을 정의 (IP 주소 형식 + "_M4OI"로 시작)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 타이머: 주기적으로 파일 변경을 확인하기 위한 타이머
        private DispatcherTimer _timer;

        // 현재 감시 중인 파일 경로 (가장 최근 파일)
        private string _currentMonitoredFile;

        // 마지막 감지된 PLAN Selected 시간
        private DateTime _lastPlanSelectedDate;

        // 마지막으로 감시 중인 파일의 수정 시간
        private DateTime _lastWriteTime;

        // 현재 처리 중인 ProductOrder 객체
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (주문 목록을 실시간으로 갱신)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // 생성자: 타이머를 초기화하고 설정하는 작업
        public FileChecker(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders;

            // 타이머 초기화 및 설정 (1초마다 파일 상태를 확인)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 주기적으로 디렉토리 내 파일들을 확인
            _timer.Start(); // 타이머 시작

            // 처음 실행할 때 가장 최근 파일을 감시 대상으로 설정
            _currentMonitoredFile = GetLatestLogFile(); // 최근 파일을 가져옴
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 초기값 설정

            // 마지막 PLAN Selected 감지 시간을 현재 시간으로 초기화
            _lastPlanSelectedDate = DateTime.Now;
        }

        // 주기적으로 디렉토리 내 파일을 확인하는 메소드 (타이머에 의해 1초마다 호출)
        private void CheckFiles(object sender, EventArgs e)
        {
            // 현재 디렉토리에서 가장 최신 파일을 확인
            string latestFile = GetLatestLogFile();

            // 새로운 파일이 감지되었거나 현재 감시 중인 파일이 변경된 경우
            if (_currentMonitoredFile == null || latestFile != _currentMonitoredFile)
            {
                // 새로운 파일로 감시 대상을 변경
                _currentMonitoredFile = latestFile;
                _lastWriteTime = File.GetLastWriteTime(_currentMonitoredFile); // 마지막 수정 시간 업데이트
            }

            // 현재 감시 중인 파일의 마지막 수정 시간을 확인
            DateTime latestWriteTime = File.GetLastWriteTime(_currentMonitoredFile);

            // 파일이 수정된 경우에만 파일을 읽고 처리
            if (latestWriteTime > _lastWriteTime)
            {
                _lastWriteTime = latestWriteTime; // 마지막 수정 시간 업데이트
                ReadLogFile(_currentMonitoredFile); // 파일을 읽고 처리
            }
        }

        // 지정된 경로에서 가장 최근에 수정된 파일을 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 로그 파일 디렉토리에서 파일 목록을 가져와 패턴에 맞는 파일만 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일 필터링
                .OrderByDescending(f => f.LastWriteTime) // 수정 시간을 기준으로 내림차순 정렬
                .ToList();

            // 가장 최근에 수정된 파일의 경로 반환 (없을 경우 null 반환)
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일을 읽어 각 로그 라인을 처리하는 메소드
        private void ReadLogFile(string filePath)
        {
            // 파일의 모든 줄을 읽어 각 줄을 처리
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                ProcessLogLine(line, filePath);
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 날짜를 추출하여 yyyyMMdd 형식으로 변환
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 파일 이름의 마지막 두 글자를 날짜로 사용
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도와 월을 yyyyMM 형식으로 가져옴
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 날짜 조합

            // "PLAN Selected" 라인을 감지했을 때 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 분리하여 제품 주문 번호를 가져옴
                string productOrder = splitLine[1]; // 두 번째 값이 제품 주문 번호

                // 새로운 주문이거나 다른 주문일 경우 처리
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    // 최근 2일 이내에 PLAN Selected가 감지되지 않은 경우 처리
                    if (DateTime.Now.Subtract(_lastPlanSelectedDate).TotalDays > 2)
                    {
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder,
                            PDate = fullDate, // yyyyMMdd 형식으로 날짜 설정
                            POStatus = "wait" // 주문 상태를 "대기(wait)"로 설정
                        };
                        _productOrders.Add(_currentProductOrder); // 새로운 주문을 목록에 추가
                    }

                    // 마지막 PLAN Selected 감지 시간을 현재 시간으로 업데이트
                    _lastPlanSelectedDate = DateTime.Now;
                }
            }
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                var modelData = line.Split(':')[1].Trim(); // BasicModel 데이터를 추출
                _currentProductOrder.BasicModel = modelData; // 모델 데이터 저장
            }
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                var mbData = line.Split('^'); // MB^ 데이터를 처리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 설정
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 수량 설정
            }
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가
            }
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "stack"; // 상태를 "적재(stack)"로 변경
            }
            else if (line.Contains("JD^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "out"; // 상태를 "배출(out)"로 변경
                ExecuteOutFunction(); // 배출 처리 호출
            }
        }

        // 배출 처리를 위한 메소드
        private void ExecuteOutFunction()
        {
            // 배출 처리 로직 구현
        }
    }

    // ProductOrderModel 클래스: 제품 주문 정보를 저장하는 모델 클래스
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; } // 제품 주문 번호
        public string BasicModel { get; set; } // 제품 모델 정보
        public int PORemain { get; set; } // 잔여 수량
        public int MGCount { get; set; } // 매거진 당 제품 수량
        public int PCount { get; set; } // 생산된 제품 개수
        public string POStatus { get; set; } // 주문 상태 (대기, 적재, 배출 등)
        public string PDate { get; set; } // 제품 주문 날짜 (yyyyMMdd 형식)
    }
}
주요 변경 사항
FileSystemWatcher 제거: FileSystemWatcher를 완전히 제거하고, 주기적으로 디렉토리 내 파일을 체크하는 방식으로 변경했습니다.
타이머를 통한 주기적 파일 체크: DispatcherTimer를 사용하여 1초마다 디렉토리에서 가장 최근에 수정된 파일을 찾아내고, 수정된 파일이 있으면 그 파일을 읽어 처리합니다.
최신 파일 추적 및 처리: 가장 최신의 로그 파일만을 주기적으로 감시하며, 새로운 파일이 생성되거나 기존 파일이 수정되면 자동으로 해당 파일을 읽어 처리합니다.
설명
CheckFiles: 주기적으로 디렉토리 내 파일을 확인하고, 최신 파일을 감시하며, 수정된 경우 파일을 읽습니다.
GetLatestLogFile: 로그 파일 디렉토리에서 가장 최근에 수정된 파일을 찾아내는 메소드입니다.
타이머 사용 이유: 파일이 계속해서 쓰여질 때 주기적으로 파일의 변경 사항을 감시하고, 변경되면 해당 내용을 즉시 처리할 수 있도록 하기 위해 타이머를 사용합니다.
이제 FileChecker는 파일 시스템 이벤트를 감지하지 않고, 주기적으로 디렉토리를 확인하여 최신 파일을 처리합니다