Back 버튼을 눌렀을 때 데이터를 갱신하려면, MainActivity에서 상태를 관리하여 ImageListScreen이 다시 보여질 때 데이터가 새로 고쳐지도록 할 수 있습니다. 이를 위해 ImageListScreen 컴포저블을 재구성할 때마다 데이터를 자동으로 가져오도록 설정하겠습니다.

MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MSSQLImageAppTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background) {
                    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
                    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }
                    var selectedImageTitle by remember { mutableStateOf("") }
                    var selectedDatetime by remember { mutableStateOf("") }

                    val fetchData: () -> Unit = {
                        val scope = rememberCoroutineScope()
                        scope.launch {
                            imageList = fetchDataFromDatabase()
                        }
                    }

                    if (selectedImage == null) {
                        ImageListScreen(
                            imageList = imageList,
                            selectedImage = selectedImage,
                            selectedImageTitle = selectedImageTitle,
                            selectedDatetime = selectedDatetime,
                            onFetchData = fetchData,
                            onImageSelected = { title, datetime ->
                                val scope = rememberCoroutineScope()
                                scope.launch {
                                    selectedImage = fetchImageFromDatabase(title, datetime)
                                    selectedImageTitle = title
                                    selectedDatetime = datetime
                                }
                            },
                            onBack = {
                                selectedImage = null
                            },
                            onFit = {
                                // No-op
                            },
                            isRefreshing = false,
                            onToggleRefresh = {}
                        )
                    } else {
                        ImageDisplayScreen(
                            bitmap = selectedImage,
                            imageTitle = selectedImageTitle,
                            datetime = selectedDatetime,
                            onBack = {
                                selectedImage = null
                                fetchData()
                            },
                            onFit = {
                                selectedImage = selectedImage
                            },
                            isRefreshing = false,
                            onToggleRefresh = {}
                        )
                    }
                }
            }
        }
    }

    suspend fun fetchDataFromDatabase(): List<ImageData> {
        return withContext(Dispatchers.IO) {
            try {
                val connection: Connection = DriverManager.getConnection(
                    "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                    "yourUsername",
                    "yourPassword"
                )
                val statement = connection.createStatement()
                val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

                val imageList = mutableListOf<ImageData>()
                while (resultSet.next()) {
                    val imageTitle = resultSet.getString("imagetitle")
                    val datetime = resultSet.getString("datetime1")
                    imageList.add(ImageData(imageTitle, datetime))
                }
                connection.close()
                imageList
            } catch (e: Exception) {
                emptyList()
            }
        }
    }

    suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
        return withContext(Dispatchers.IO) {
            try {
                val connection: Connection = DriverManager.getConnection(
                    "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                    "yourUsername",
                    "yourPassword"
                )
                val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
                statement.setString(1, imageTitle)
                statement.setString(2, datetime)
                val resultSet: ResultSet = statement.executeQuery()

                var bitmap: Bitmap? = null
                if (resultSet.next()) {
                    val blob = resultSet.getBlob("imageColumn")
                    val byteArray = blob.binaryStream.readBytes()
                    bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
                }
                connection.close()
                bitmap
            } catch (e: Exception) {
                null
            }
        }
    }
}
ImageListScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Paint
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    val scope = rememberCoroutineScope()

    LaunchedEffect(Unit) {
        scope.launch {
            onFetchData()
        }
    }

    Column {
        LazyColumn(modifier = Modifier.weight(1f).padding(horizontal = 20.dp)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            ImageDisplayScreen(
                bitmap = it,
                imageTitle = selectedImageTitle,
                datetime = selectedDatetime,
                onBack = onBack,
                onFit = onFit,
                isRefreshing = isRefreshing,
                onToggleRefresh = onToggleRefresh
            )
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        if (drawMode) {
            Canvas(modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { offset -> currentPathPoints = listOf(offset) },
                        onDragEnd = {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                            currentPathPoints = listOf()
                        },
                        onDrag = { change, _ ->
                            currentPathPoints = currentPathPoints + change.position
                            change.consume()
                        }
                    )
                }
            ) {
                for (path in drawingPaths) {
                    for (i in 1 until path.points.size) {
                        drawLine(
                            color = path.color,
                            start = path.points[i - 1],
                            end = path.points[i],
                            strokeWidth = 3f
                        )
                    }
                }
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(20.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    scope.launch {
                        val bitmapWithDrawing = mergeBitmapWithDrawing(currentBitmap!!, drawingPaths)
                        uploadBitmap(bitmapWithDrawing)
                    }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

suspend fun mergeBitmapWithDrawing(bitmap: Bitmap, drawingPaths: List<DrawingPath>): Bitmap {
    return withContext(Dispatchers.Default) {
        val resultBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true)
        val canvas = Canvas(resultBitmap)
        val paint = Paint().apply {
            isAntiAlias = true
            style = Paint.Style.STROKE
            strokeWidth = 3f
        }

        drawingPaths.forEach { path ->
            paint.color = path.color.toArgb()
            for (i in 1 until path.points.size) {
                val startX = path.points[i - 1].x
                val startY = path.points[i - 1].y
                val stopX = path.points[i].x
                val stopY = path.points[i].y
                canvas.drawLine(startX, startY, stopX, stopY, paint)
            }
        }

        resultBitmap
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
주요 변경 사항
MainActivity에서 fetchData 함수를 onBack 버튼 클릭 시 호출하여 데이터를 갱신합니다.
ImageListScreen이 처음 시작될 때와 돌아왔을 때 데이터를 자동으로 가져오도록 수정했습니다.
이제 홈으로 돌아오거나 처음 진입할 때 Fetch Data가 자동으로 호출되어 목록이 새로 고쳐집니다.


2