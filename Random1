. 이제 너가 요구한 모든 조건을 정확히 반영한 MSSQL 2014 전용 쿼리를 아주 상세한 주석과 함께 줄게.

요약
최근 5시간 이내 데이터만 사용

각 행에서:

ACT2_1~8 → 0 이상만, Q1~Q3 범위 이내 값 중 최대값 → max_act2_row

ACT2BEST_1~8 → 동일 방식으로 max_act2best_row

그 후:

line1, model1, type1, ecn1, edition1 별로:

max_act2_row 들 중 가장 작은 값 → max_act2

max_act2best_row 들 중 가장 작은 값 → max_act2best

ctdiff = max_act2 - max_act2best

최종 MSSQL 2014 쿼리 (with 상세 주석)
sql
코드 복사
-- Step 1. 최근 5시간 이내 데이터 필터링
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- Step 2. ACT2 데이터를 세로로 펼침 (0 초과 값만)
ACT2_Expanded AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM RawData
    CROSS APPLY (VALUES
        (ACT2_1), (ACT2_2), (ACT2_3), (ACT2_4),
        (ACT2_5), (ACT2_6), (ACT2_7), (ACT2_8)
    ) AS V(val)
    WHERE val > 0
),

-- Step 3. ACT2 이상치 경계값 계산 (Q1, Q3)
ACT2_Stats AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2_Expanded
),

-- Step 4. ACT2 Q1~Q3 범위 내 값만 남김
ACT2_Filtered AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM ACT2_Stats
    WHERE val BETWEEN Q1 AND Q3
),

-- Step 5. ACT2 행별 최대값
ACT2_RowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1,
           MAX(val) AS max_act2_row
    FROM ACT2_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- Step 6. ACT2BEST 동일 처리
ACT2BEST_Expanded AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM RawData
    CROSS APPLY (VALUES
        (ACT2BEST_1), (ACT2BEST_2), (ACT2BEST_3), (ACT2BEST_4),
        (ACT2BEST_5), (ACT2BEST_6), (ACT2BEST_7), (ACT2BEST_8)
    ) AS V(val)
    WHERE val > 0
),

ACT2BEST_Stats AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY val) OVER (PARTITION BY line1, model1, type1, ecn1, edition1) AS Q3
    FROM ACT2BEST_Expanded
),

ACT2BEST_Filtered AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, val
    FROM ACT2BEST_Stats
    WHERE val BETWEEN Q1 AND Q3
),

ACT2BEST_RowMax AS (
    SELECT line1, model1, type1, ecn1, edition1, time1,
           MAX(val) AS max_act2best_row
    FROM ACT2BEST_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- Step 7. 모델별 최소 max값 추출
ACT2_MinMax AS (
    SELECT line1, model1, type1, ecn1, edition1,
           MIN(max_act2_row) AS max_act2
    FROM ACT2_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1
),

ACT2BEST_MinMax AS (
    SELECT line1, model1, type1, ecn1, edition1,
           MIN(max_act2best_row) AS max_act2best
    FROM ACT2BEST_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1
)

-- Step 8. 결과 병합 및 ctdiff 계산
SELECT
    A.line1, A.model1, A.type1, A.ecn1, A.edition1,
    A.max_act2,
    B.max_act2best,
    A.max_act2 - B.max_act2best AS ctdiff
FROM ACT2_MinMax A
JOIN ACT2BEST_MinMax B
  ON A.line1 = B.line1 AND A.model1 = B.model1 AND A.type1 = B.type1
 AND A.ecn1 = B.ecn1 AND A.edition1 = B.edition1
ORDER BY line1, model1, type1, ecn1, edition1;
이 쿼리는:
모델별로 ACT2, ACT2BEST 각각 따로 이상치 제거

각 시간대별 최대값 구한 후

모델 단위로 그 중 가장 작은 max값만 남김

그 차이를 ctdiff로 구해서 비교
