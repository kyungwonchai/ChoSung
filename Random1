app/__init__.py, run.py).
pymssql 연결을 위한 유틸리티 추가 (app/db_utils.py).
데이터베이스를 사용하는 모든 라우트 및 함수들을 pymssql 직접 호출 방식으로 변경.
가장 먼저, 실행 진입점인 run.py부터 시작하겠습니다.

수정: scontrol_flask_web/run.py
Python

# scontrol_flask_web/run.py
import os
from app import create_app

config_name = os.getenv('FLASK_CONFIG') or 'default'
app_instance = create_app(config_name)

if __name__ == '__main__':
    app_instance.run(host='0.0.0.0', port=5000)
다음으로 config.py 파일을 수정합니다. (주석 최소화)

Python

# scontrol_flask_web/config.py
import os
from dotenv import load_dotenv

basedir = os.path.abspath(os.path.dirname(__file__))
load_dotenv(os.path.join(basedir, '.env'))

class Config:
    SECRET_KEY = os.environ.get('SECRET_KEY') or 'flask-애플리케이션-비밀키-변경필수!'
    DB_SERVER = os.environ.get('DB_SERVER_ADDRESS') or '10.22.22.22'
    DB_PORT = os.environ.get('DB_PORT') or '2222'
    DB_DATABASE = os.environ.get('DB_NAME') or 'SControlFlaskDB'
    DB_USER = os.environ.get('DB_USER') or 'aaaaa'
    DB_PASSWORD = os.environ.get('DB_PASSWORD') or 'bbbbb'
    ADMIN_IPS = ['127.0.0.1', '::1', '10.22.22.22'] # 예시: 실제 관리자 IP로 수정

    @staticmethod
    def init_app(app):
        pass

class DevelopmentConfig(Config):
    DEBUG = True

class ProductionConfig(Config):
    DEBUG = False

config = {
    'development': DevelopmentConfig,
    'production': ProductionConfig,
    'default': DevelopmentConfig
}
다음은 app/__init__.py 파일입니다. (주석 최소화)

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask
from config import config
import datetime
import os

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils
    app.teardown_appcontext(db_utils.close_db)

    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str):
            original_value_for_log = value
            try:
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None:
                    app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'")
                    return original_value_for_log
                value = parsed_dt
            except Exception as e_parse:
                app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}")
                return original_value_for_log
        if not isinstance(value, (datetime.datetime, datetime.date)): return value
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime

    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}

    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)

    from .routes_main import main_bp
    app.register_blueprint(main_bp)
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin')
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user')

    app.logger.info("Flask application (direct pymssql) created.")
    if app.debug:
        app.logger.debug(f"DB Connection (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")
    return app
다음은 app/db_utils.py 파일입니다. (주석 최소화)

Python

# scontrol_flask_web/app/db_utils.py
import pymssql
from flask import current_app, g

def get_db_connection():
    if 'db_conn' not in g or g.db_conn is None or getattr(g.db_conn, '_closed', True):
        try:
            g.db_conn = pymssql.connect(
                server=current_app.config['DB_SERVER'],
                port=str(current_app.config['DB_PORT']),
                user=current_app.config['DB_USER'],
                password=current_app.config['DB_PASSWORD'],
                database=current_app.config['DB_DATABASE'],
                as_dict=True, # 결과를 딕셔너리 형태로 받음
                timeout=5,
                login_timeout=5
            )
        except Exception as e:
            current_app.logger.error(f"Database connection error (pymssql): {e}", exc_info=True)
            g.db_conn = None
            raise
    return g.db_conn

def close_db_connection(e=None):
    db_conn = g.pop('db_conn', None)
    if db_conn is not None and not getattr(db_conn, '_closed', True):
        try:
            db_conn.close()
        except Exception as e:
            current_app.logger.error(f"Error closing DB connection: {e}", exc_info=True)
여기까지가 Flask 앱 실행 및 DB 연결 설정에 관련된 핵심 파일들의 수정된 전체 코드입니다. 이 파일들에는 SQLAlchemy 관련 내용이 모두 제거되었고, pymssql을 직접 사용하며 요청별로 DB 연결을 관리하도록 구성되었습니다.