네, 알겠습니다. 먼저 요청하신 대로 솔루션의 전체 트리 구조를 다시 보여드리고, 그 다음 SAgentM.Service (Windows Service)의 "이벤트부터 실제 완성 코드"에 가깝도록, 핵심 로직을 포함한 코드를 상세히 제공해 드리겠습니다.

"이벤트부터 실제 완성 코드"라는 말씀은 서비스의 생명주기(시작, 실행, 중지), 네트워크 연결 수신, 명령어 패킷 처리, 로깅 등 주요 이벤트 흐름에 따른 구체적인 코드 구현을 원하시는 것으로 이해했습니다. 최대한 상세하고 기능적으로 동작하는 코드를 제공하도록 노력하겠지만, 앞서 말씀드린 것처럼 실제 프로덕션 환경에 적용하기 전에는 반드시 충분한 테스트, 예외 처리 강화, 보안 검토 및 환경에 따른 최적화가 필요합니다.

솔루션 전체 트리 구조
SControlSuite (솔루션 루트)
├───SControl.Common (클래스 라이브러리 - .NET 6+)
│   │   SControl.Common.csproj
│   ├───CommandPacket.cs        (명령어 패킷 구조)
│   ├───Enums.cs                (각종 열거형: CommandInstruction, MonitorAction 등)
│   ├───Payloads.cs             (명령어별 데이터 페이로드: MonitorControlPayload 등)
│   └───LocalDeviceControl.cs   (P/Invoke를 사용한 로컬 장치 제어: 모니터 제어)
│
├───SAgentM.Service (Worker Service -> Windows Service - .NET 6+)
│   │   SAgentM.Service.csproj
│   ├───Program.cs              (서비스 호스트 설정, 로깅 설정, 의존성 주입)
│   ├───SAgentWorker.cs         (BackgroundService 상속, 주 서비스 로직 실행)
│   ├───AgentSocketListener.cs  (TCP 소켓 리스닝 및 클라이언트 연결 관리)
│   ├───ClientHandler.cs        (개별 클라이언트와의 통신 및 패킷 수신/송신 처리)
│   ├───CommandHandler.cs       (수신된 CommandPacket 분석 및 실제 명령 실행/릴레이)
│   ├───appsettings.json        (서비스 설정: 리스닝 포트 등)
│   └───Properties
│       └───launchSettings.json
│
├───SControlM (WPF 애플리케이션 - .NET 6+)
│   │   SControlM.csproj
│   ├───App.xaml / App.xaml.cs
│   ├───MainWindow.xaml / MainWindow.xaml.cs
│   ├───ViewModels/             (MVVM 패턴 ViewModels)
│   ├───Views/                  (WPF Views/UserControls)
│   ├───Services/               (SControlM 내부 서비스: DB 연동, SAgentM 통신 등)
│   └───appsettings.json        (SControlM 설정)
│
└───(SAgentM.Installer - 개념적 구성요소, 실제 프로젝트는 WiX 등으로 별도 생성)
    │   (예: WiX Toolset 프로젝트 파일들 - .wxs, .wixproj 등)
SAgentM.Service 코드 (Windows Service)
이제 SAgentM.Service의 코드를 제공하겠습니다. 이 서비스는 SControl.Common 프로젝트를 참조합니다.
로깅 라이브러리로는 Serilog를 사용하여 파일 로깅을 구성하는 예시를 포함합니다.

1. SAgentM.Service.csproj 에 필요한 NuGet 패키지 추가:

프로젝트 생성 후, 다음 NuGet 패키지들을 설치해야 합니다:

Microsoft.Extensions.Hosting.WindowsServices (Windows Service로 실행하기 위해)
Serilog.AspNetCore (Serilog를 .NET Core 호스팅 환경에 쉽게 통합. Serilog.Extensions.Hosting도 유사)
Serilog.Sinks.File (파일 로깅용)
Serilog.Sinks.Console (개발 중 콘솔 출력용)
System.Text.Json (CommandPacket 직렬화/역직렬화 - .NET Core에 기본 포함이지만 명시)
.csproj 파일에 아래와 같이 <ItemGroup> 내에 추가될 수 있습니다 (버전은 최신 안정 버전으로):

XML

 <ItemGroup>
     <PackageReference Include="Microsoft.Extensions.Hosting.WindowsServices" Version="6.0.0" />
     <PackageReference Include="Serilog.AspNetCore" Version="6.0.0" /> <PackageReference Include="Serilog.Sinks.Console" Version="4.1.0" />
     <PackageReference Include="Serilog.Sinks.File" Version="5.0.0" />
 </ItemGroup>
```

**2. `appsettings.json` (서비스 설정 파일)**

  - 리스닝 포트 및 로그 파일 경로 등을 설정합니다.

<!-- end list -->

```json
// SAgentM.Service/appsettings.json
{
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft.Hosting.Lifetime": "Information"
    }
  },
  "Serilog": {
    "MinimumLevel": {
      "Default": "Information",
      "Override": {
        "Microsoft": "Warning",
        "System": "Warning"
      }
    },
    "WriteTo": [
      {
        "Name": "Console"
      },
      {
        "Name": "File",
        "Args": {
          "path": "Logs/SAgentM-.log", // 로그 파일 경로 및 이름 패턴
          "rollingInterval": "Day",     // 매일 새 로그 파일 생성
          "retainedFileCountLimit": 7,  // 최대 7개 로그 파일 유지
          "buffered": true,             // 성능을 위해 버퍼링 사용
          "flushToDiskInterval": "00:00:05" // 5초마다 디스크에 플러시
        }
      }
    ],
    "Enrich": [ "FromLogContext", "WithMachineName", "WithThreadId" ]
  },
  "AgentSettings": {
    "ListenPort": 12345 // SAgentM이 리스닝할 기본 포트
  }
}
3. Program.cs (서비스 호스트 설정)

C#

// SAgentM.Service/Program.cs
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using SAgentM.Service; // SAgentWorker 등 현재 프로젝트 네임스페이스
using Serilog;

// Serilog 초기 설정 (appsettings.json과 코드 기반 설정을 혼합 가능)
// 호스트 빌더 외부에서 정적 로거를 설정하여, 호스트 빌드 과정 자체의 로그도 캡처할 수 있도록 합니다.
Log.Logger = new LoggerConfiguration()
    .Enrich.FromLogContext()
    .WriteTo.Console() // 개발 중에는 콘솔에도 출력
    .CreateBootstrapLogger(); // 초기 부트스트랩용 로거

Log.Information("SAgentM.Service: Application starting up...");

try
{
    IHost host = Host.CreateDefaultBuilder(args)
        .UseWindowsService(options => // Windows Service로 실행되도록 구성
        {
            options.ServiceName = "SControl Agent Service (SAgentM)";
        })
        .ConfigureLogging(logging => // Microsoft.Extensions.Logging 제거 또는 최소화
        {
            logging.ClearProviders();
        })
        .UseSerilog((context, services, configuration) => configuration // Serilog 통합
            .ReadFrom.Configuration(context.Configuration) // appsettings.json에서 Serilog 설정 읽기
            .ReadFrom.Services(services) // DI 컨테이너의 서비스 사용 가능 (예: IHttpContextAccessor)
            .Enrich.FromLogContext()
            .Enrich.WithMachineName()
            .Enrich.WithThreadId()
        //  .WriteTo.Console() // appsettings.json에서 이미 설정했다면 중복 불필요
        //  .WriteTo.File(...) // appsettings.json에서 이미 설정했다면 중복 불필요
        )
        .ConfigureServices((hostContext, services) =>
        {
            // AgentSettings를 IOptions<AgentSettings>로 주입 가능하도록 설정
            services.Configure<AgentSettings>(hostContext.Configuration.GetSection("AgentSettings"));

            // 서비스의 핵심 로직을 담당하는 Worker 등록
            services.AddHostedService<SAgentWorker>();

            // 필요한 다른 서비스들 등록
            // 예: services.AddSingleton<ICommandHandler, CommandHandler>();
            //     services.AddSingleton<IAgentSocketListener, AgentSocketListener>();
            // SAgentWorker가 직접 이들을 new() 할 수도 있고, DI를 통해 주입받을 수도 있습니다.
            // 여기서는 SAgentWorker가 직접 생성하거나, 더 작은 단위로 분리하여 주입하는 방식을 택할 수 있습니다.
            // 간결성을 위해 우선 SAgentWorker 내에서 관련 객체들을 관리하도록 하겠습니다.
            // 좀 더 복잡한 시나리오에서는 각각을 싱글톤 등으로 등록하는 것이 좋습니다.
            services.AddSingleton<CommandHandler>(); // CommandHandler 등록
        })
        .Build();

    await host.RunAsync();
}
catch (Exception ex)
{
    Log.Fatal(ex, "SAgentM.Service: Application terminated unexpectedly.");
}
finally
{
    Log.Information("SAgentM.Service: Application shutting down.");
    await Log.CloseAndFlushAsync(); // 애플리케이션 종료 시 Serilog 버퍼 비우기
}

// AgentSettings 클래스 정의 (appsettings.json 매핑용)
public class AgentSettings
{
    public int ListenPort { get; set; } = 12345; // 기본값 설정
}
4. SAgentWorker.cs (주 서비스 로직 실행)

BackgroundService를 상속받아 서비스의 주 실행 루프를 담당합니다.
AgentSocketListener를 시작하고 관리합니다.
<!-- end list -->

C#

// SAgentM.Service/SAgentWorker.cs
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options; // IOptions 사용
using SControl.Common; // LocalDeviceControl 등 공용 라이브러리
using System;
using System.Threading;
using System.Threading.Tasks;

namespace SAgentM.Service
{
    public class SAgentWorker : BackgroundService
    {
        private readonly ILogger<SAgentWorker> _logger;
        private readonly AgentSettings _agentSettings;
        private readonly CommandHandler _commandHandler; // CommandHandler 주입
        private AgentSocketListener? _socketListener;

        public SAgentWorker(ILogger<SAgentWorker> logger, 
                            IOptions<AgentSettings> agentSettings,
                            CommandHandler commandHandler) // CommandHandler 주입
        {
            _logger = logger;
            _agentSettings = agentSettings.Value; // 설정 값 가져오기
            _commandHandler = commandHandler;
            _logger.LogInformation("SAgentWorker: Service instance created. Listening port from config: {Port}", _agentSettings.ListenPort);
        }

        public override Task StartAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("SAgentWorker: Service starting at: {time}", DateTimeOffset.Now);
            
            // LocalDeviceControl 클래스가 사용 가능한지 간단히 확인 (예시)
            try
            {
                _logger.LogInformation("SAgentWorker: Attempting to access LocalDeviceControl (P/Invoke check).");
                // LocalDeviceControl.SetMonitorState(MonitorAction.On); // 실제 모니터를 켜버리므로 테스트 시 주의
                // LocalDeviceControl.SetMonitorState(MonitorAction.Off);
                _logger.LogInformation("SAgentWorker: LocalDeviceControl seems accessible.");
            }
            catch (Exception ex)
            {
                _logger.LogWarning(ex, "SAgentWorker: LocalDeviceControl (P/Invoke) might not be fully accessible. This is okay if not all features are used or if running in a restricted environment.");
            }

            return base.StartAsync(cancellationToken);
        }

        protected override async Task ExecuteAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("SAgentWorker: ExecuteAsync started. Initializing socket listener.");

            try
            {
                // CommandHandler에 Logger 주입 (만약 CommandHandler가 ILogger를 필요로 한다면)
                // _commandHandler.SetLogger(_loggerFactory.CreateLogger<CommandHandler>()); // CommandHandler가 직접 로거를 받는다면

                _socketListener = new AgentSocketListener(_agentSettings.ListenPort, _commandHandler, _logger);
                await _socketListener.StartListeningAsync(stoppingToken); // 취소 토큰 전달
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("SAgentWorker: ExecuteAsync was cancelled. Listener stopping.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "SAgentWorker: An unhandled exception occurred in ExecuteAsync.");
            }
            finally
            {
                _logger.LogInformation("SAgentWorker: ExecuteAsync finished. Listener should be stopped.");
            }
        }

        public override async Task StopAsync(CancellationToken cancellationToken)
        {
            _logger.LogInformation("SAgentWorker: Service stopping at: {time}", DateTimeOffset.Now);
            
            if (_socketListener != null)
            {
                _logger.LogInformation("SAgentWorker: Instructing socket listener to stop.");
                // _socketListener.StopListening(); // StopListening 메서드 필요 (내부적으로 CancellationTokenSource 사용 또는 플래그)
                // ExecuteAsync의 stoppingToken에 의해 _socketListener의 StartListeningAsync 루프가 종료되도록 설계하는 것이 더 일반적입니다.
            }
            
            await base.StopAsync(cancellationToken);
            _logger.LogInformation("SAgentWorker: Service stopped successfully.");
        }
    }
}
5. AgentSocketListener.cs (TCP 소켓 리스닝 및 클라이언트 연결 관리)

C#

// SAgentM.Service/AgentSocketListener.cs
using Microsoft.Extensions.Logging;
using SControl.Common; // CommandPacket 등
using System;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;

namespace SAgentM.Service
{
    public class AgentSocketListener
    {
        private readonly int _port;
        private readonly TcpListener _listener;
        private readonly CommandHandler _commandHandler;
        private readonly ILogger _logger; // ILogger<AgentSocketListener> 대신 범용 ILogger 사용 가능

        public AgentSocketListener(int port, CommandHandler commandHandler, ILogger logger)
        {
            _port = port;
            _commandHandler = commandHandler;
            _logger = logger;
            _listener = new TcpListener(IPAddress.Any, _port);
            _logger.LogInformation("AgentSocketListener: Initialized for port {Port}.", _port);
        }

        public async Task StartListeningAsync(CancellationToken stoppingToken)
        {
            try
            {
                _listener.Start();
                _logger.LogInformation("AgentSocketListener: Started listening on port {Port}.", _port);

                // 서비스 중지 요청 시 리스너 중지
                stoppingToken.Register(() =>
                {
                    _listener.Stop();
                    _logger.LogInformation("AgentSocketListener: Listening stopped due to cancellation request.");
                });

                while (!stoppingToken.IsCancellationRequested)
                {
                    _logger.LogDebug("AgentSocketListener: Waiting for a client connection...");
                    TcpClient client = await _listener.AcceptTcpClientAsync(stoppingToken); // CancellationToken 사용
                    
                    // 클라이언트 IP 정보 로깅
                    string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                    _logger.LogInformation("AgentSocketListener: Client connected from {ClientIP}.", clientIp);

                    // 각 클라이언트에 대한 처리를 별도의 작업으로 실행 (리소스 유출 방지 중요)
                    // Task.Run을 사용하거나, 더 정교한 Task 관리가 필요할 수 있음.
                    // 여기서는 ClientHandler 인스턴스를 만들고 HandleClientAsync를 호출합니다.
                    ClientHandler clientHandler = new ClientHandler(client, _commandHandler, _logger);
                    _ = Task.Run(() => clientHandler.HandleClientAsync(stoppingToken), stoppingToken); // fire and forget, but log exceptions within HandleClientAsync
                }
            }
            catch (OperationCanceledException)
            {
                // stoppingToken에 의해 AcceptTcpClientAsync가 취소될 때 발생
                _logger.LogInformation("AgentSocketListener: Listening was cancelled via CancellationToken.");
            }
            catch (SocketException se) when (se.SocketErrorCode == SocketError.Interrupted)
            {
                // _listener.Stop() 호출 시 AcceptTcpClientAsync에서 발생할 수 있는 예외
                _logger.LogInformation("AgentSocketListener: Socket listener was interrupted, likely by StopListening call.");
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "AgentSocketListener: An error occurred while listening for clients.");
            }
            finally
            {
                if (_listener.Server.IsBound) // Server.IsBound로 확인 (netcoreapp3.1 이상) 또는 Active 속성 (구버전)
                {
                    _listener.Stop();
                }
                _logger.LogInformation("AgentSocketListener: Listener definitively stopped.");
            }
        }
    }
}
6. ClientHandler.cs (개별 클라이언트 통신 및 패킷 처리)

각 클라이언트 연결을 담당하고, CommandPacket을 수신하여 CommandHandler에 전달합니다.
참고: 네트워크 스트림에서 완전한 JSON 메시지를 안정적으로 읽는 것은 중요합니다. 간단한 예시로, 각 JSON 메시지가 개행 문자(\n)로 끝난다고 가정합니다. 실제로는 길이 접두사 방식 등을 고려하는 것이 더 견고합니다.
<!-- end list -->

C#

// SAgentM.Service/ClientHandler.cs
using Microsoft.Extensions.Logging;
using SControl.Common; // CommandPacket
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Text.Json; // JsonSerializer
using System.Threading;
using System.Threading.Tasks;

namespace SAgentM.Service
{
    public class ClientHandler
    {
        private readonly TcpClient _client;
        private readonly CommandHandler _commandHandler;
        private readonly ILogger _logger;
        private readonly string _clientIp;

        public ClientHandler(TcpClient client, CommandHandler commandHandler, ILogger logger)
        {
            _client = client;
            _commandHandler = commandHandler;
            _logger = logger;
            _clientIp = _client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
        }

        public async Task HandleClientAsync(CancellationToken stoppingToken)
        {
            _logger.LogInformation("ClientHandler [{ClientIP}]: Handling new client connection.", _clientIp);
            NetworkStream stream = _client.GetStream();
            // StreamReader/Writer를 사용하여 텍스트 기반 프로토콜(예: JSON Lines) 처리
            // 여기서는 각 CommandPacket JSON이 한 줄로 전송된다고 가정
            using var reader = new StreamReader(stream, Encoding.UTF8, leaveOpen: true); // stream은 client 닫을때 같이 닫힘
            using var writer = new StreamWriter(stream, Encoding.UTF8, leaveOpen: true) { AutoFlush = true };

            try
            {
                while (_client.Connected && !stoppingToken.IsCancellationRequested)
                {
                    _logger.LogDebug("ClientHandler [{ClientIP}]: Waiting for data from client...", _clientIp);
                    string? jsonRequest = await reader.ReadLineAsync().WaitAsync(stoppingToken); // ReadLineAsync도 CancellationToken 지원 고려 (net7+)

                    if (jsonRequest == null) // 클라이언트 연결 종료 (스트림 끝)
                    {
                        _logger.LogInformation("ClientHandler [{ClientIP}]: Client disconnected (stream closed).", _clientIp);
                        break;
                    }

                    _logger.LogInformation("ClientHandler [{ClientIP}]: Received raw data: {Data}", _clientIp, jsonRequest);

                    CommandPacket? requestPacket = null;
                    try
                    {
                        requestPacket = JsonSerializer.Deserialize<CommandPacket>(jsonRequest,
                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.LogError(jsonEx, "ClientHandler [{ClientIP}]: Failed to deserialize CommandPacket. Raw: {RawJson}", _clientIp, jsonRequest);
                        // 선택: 클라이언트에게 오류 응답을 보낼 수 있음
                        // await writer.WriteLineAsyncSafe("{\"error\":\"Invalid JSON format\"}", stoppingToken);
                        continue; // 다음 메시지 대기
                    }

                    if (requestPacket != null)
                    {
                        _logger.LogInformation("ClientHandler [{ClientIP}]: Successfully deserialized CommandPacket ID: {PacketId}, Command: {CommandName}", 
                            _clientIp, requestPacket.PacketId, requestPacket.CommandName);

                        // CommandHandler를 통해 명령 처리
                        // CommandHandler는 응답을 직접 보내거나, 결과를 반환하여 여기서 보낼 수 있음
                        CommandPacket? responsePacket = await _commandHandler.HandleCommandAsync(requestPacket, _clientIp);

                        if (responsePacket != null) // CommandHandler가 응답 패킷을 생성한 경우
                        {
                            try
                            {
                                string jsonResponse = JsonSerializer.Serialize(responsePacket);
                                await writer.WriteLineAsync(jsonResponse); // WriteLineAsync도 CancellationToken 지원 고려 (net7+)
                                _logger.LogInformation("ClientHandler [{ClientIP}]: Sent response packet ID: {PacketId}", _clientIp, responsePacket.PacketId);
                            }
                            catch (JsonException jsonEx)
                            {
                                _logger.LogError(jsonEx, "ClientHandler [{ClientIP}]: Failed to serialize response CommandPacket ID: {PacketId}", _clientIp, responsePacket.PacketId);
                            }
                            catch (IOException ioEx) // 네트워크 쓰기 오류
                            {
                                _logger.LogError(ioEx, "ClientHandler [{ClientIP}]: IOException while sending response. Client might have disconnected.", _clientIp);
                                break; // 연결 오류로 간주하고 루프 종료
                            }
                        }
                    }
                }
            }
            catch (OperationCanceledException)
            {
                _logger.LogInformation("ClientHandler [{ClientIP}]: Operation cancelled for client.", _clientIp);
            }
            catch (IOException ioEx) // 네트워크 읽기/쓰기 오류 (연결 갑자기 끊김 등)
            {
                _logger.LogWarning(ioEx, "ClientHandler [{ClientIP}]: IOException. Client connection likely lost.", _clientIp);
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "ClientHandler [{ClientIP}]: An unexpected error occurred while handling client.", _clientIp);
            }
            finally
            {
                _logger.LogInformation("ClientHandler [{ClientIP}]: Closing client connection.", _clientIp);
                _client.Close(); // 반드시 TcpClient를 닫아 리소스 해제
            }
        }
    }

    // StreamWriter 확장 메서드 예시 (CancellationToken 지원을 위해) - .NET 7 미만 버전용
    // public static class StreamWriterExtensions
    // {
    //     public static async Task WriteLineAsyncSafe(this StreamWriter writer, string value, CancellationToken token = default)
    //     {
    //         // .NET 7 이전에는 WriteLineAsync가 CancellationToken을 직접 받지 않음.
    //         // Task.Run 등으로 감싸거나, 주기적으로 token.IsCancellationRequested를 확인해야 함.
    //         // 또는, WriteAsync와 NewLineChars를 조합.
    //         if (token.IsCancellationRequested) token.ThrowIfCancellationRequested();
    //         await writer.WriteLineAsync(value); // 이 자체는 CancellationToken을 지원하지 않음
    //     }
    // }
}
ClientHandler.cs 중요 참고사항:

메시지 프레이밍: 위 코드는 클라이언트가 각 CommandPacket JSON을 한 줄로 보내고 (\n으로 종료) 서버도 그렇게 응답한다고 가정합니다. 이는 가장 간단한 프레이밍 방식 중 하나입니다. 더 견고한 시스템에서는 메시지 길이를 먼저 보내는 길이-접두사(Length-Prefixing) 방식을 사용하는 것이 좋습니다. BinaryReader/BinaryWriter를 사용하거나, 직접 바이트 버퍼를 관리하여 이를 구현할 수 있습니다.
ReadLineAsync()와 WriteLineAsync()는 .NET 7부터 CancellationToken을 직접 지원합니다. 이전 버전을 사용한다면, 취소 확인 로직을 수동으로 추가하거나 다른 방식을 고려해야 합니다.
7. CommandHandler.cs (수신된 명령 분석 및 실제 처리)

CommandPacket을 받아 실제 동작을 수행하거나 다른 SAgentM으로 릴레이합니다.
<!-- end list -->

C#

// SAgentM.Service/CommandHandler.cs
using Microsoft.Extensions.Logging; // CommandHandler가 직접 로거를 주입받도록 변경
using SControl.Common; // CommandPacket, MonitorControlPayload, LocalDeviceControl 등
using System;
using System.Net.Sockets;
using System.Text;
using System.Text.Json;
using System.Threading.Tasks;

namespace SAgentM.Service
{
    public class CommandHandler
    {
        private readonly ILogger<CommandHandler> _logger;
        // private readonly IHttpClientFactory _httpClientFactory; // HTTP 기반 릴레이 시 필요

        public CommandHandler(ILogger<CommandHandler> logger /*, IHttpClientFactory httpClientFactory*/)
        {
            _logger = logger;
            // _httpClientFactory = httpClientFactory;
            _logger.LogInformation("CommandHandler: Initialized.");
        }

        public async Task<CommandPacket?> HandleCommandAsync(CommandPacket requestPacket, string-clientIp)
        {
            _logger.LogInformation("CommandHandler [{ClientIP}]: Processing command '{CommandName}' (ID: {PacketId}) with instruction '{Instruction}'.", 
                clientIp, requestPacket.CommandName, requestPacket.PacketId, requestPacket.Instruction);

            CommandPacket? responsePacket = null; // 기본적으로 응답 없음

            try
            {
                if (requestPacket.Instruction == CommandInstruction.DirectExecute)
                {
                    responsePacket = await ExecuteDirectCommandAsync(requestPacket, clientIp);
                }
                else if (requestPacket.Instruction == CommandInstruction.RelayToTarget)
                {
                    responsePacket = await RelayCommandAsync(requestPacket, clientIp);
                }
                else
                {
                    _logger.LogWarning("CommandHandler [{ClientIP}]: Unknown instruction '{Instruction}' for packet ID: {PacketId}.",
                        clientIp, requestPacket.Instruction, requestPacket.PacketId);
                    responsePacket = CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "CommandHandler [{ClientIP}]: Error processing command ID {PacketId}.", clientIp, requestPacket.PacketId);
                responsePacket = CreateErrorResponse(requestPacket, $"Error processing command: {ex.Message}");
            }
            
            // 요청 패킷에 응답 주소가 있으면 응답 패킷에 해당 정보 설정 (단, 여기서는 ClientHandler가 직접 응답하므로 불필요할 수 있음)
            // if (responsePacket != null && !string.IsNullOrEmpty(requestPacket.ResponseAddress) && requestPacket.ResponsePort.HasValue)
            // {
            //     // responsePacket.IsResponse = true; // 응답임을 명시하는 플래그가 CommandPacket에 있다면
            // }

            return responsePacket;
        }

        private async Task<CommandPacket?> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp)
        {
            _logger.LogInformation("CommandHandler [{ClientIP}]: Executing direct command '{CommandName}'.", clientIp, requestPacket.CommandName);
            bool success = false;
            string executionMessage = "Command executed.";

            switch (requestPacket.CommandName)
            {
                case CommandNames.MonitorControl:
                    if (string.IsNullOrEmpty(requestPacket.PayloadJson))
                    {
                        executionMessage = "MonitorControl command failed: PayloadJson is missing.";
                        _logger.LogWarning("CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                        break;
                    }
                    try
                    {
                        var payload = JsonSerializer.Deserialize<MonitorControlPayload>(requestPacket.PayloadJson, 
                            new JsonSerializerOptions { PropertyNameCaseInsensitive = true });
                        
                        if (payload == null)
                        {
                             executionMessage = "MonitorControl command failed: Payload deserialization resulted in null.";
                            _logger.LogWarning("CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                            break;
                        }

                        _logger.LogInformation("CommandHandler [{ClientIP}]: Attempting to set monitor state to {Action}.", clientIp, payload.Action);
                        LocalDeviceControl.SetMonitorState(payload.Action); // P/Invoke 호출
                        success = true;
                        executionMessage = $"Monitor state set to {payload.Action} successfully.";
                        _logger.LogInformation("CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                    }
                    catch (JsonException jsonEx)
                    {
                        executionMessage = $"MonitorControl command failed: Payload JSON deserialization error - {jsonEx.Message}";
                        _logger.LogError(jsonEx, "CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                    }
                    catch (Exception ex) // P/Invoke 등에서 발생할 수 있는 예외
                    {
                        executionMessage = $"MonitorControl command execution error: {ex.Message}";
                        _logger.LogError(ex, "CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                    }
                    break;

                // --- 다른 직접 실행 명령들 ---
                // case CommandNames.SystemShutdown:
                //     // ... SystemShutdownPayload 처리 ...
                //     break;

                default:
                    executionMessage = $"Unknown direct command: {requestPacket.CommandName}";
                    _logger.LogWarning("CommandHandler [{ClientIP}]: {Message}", clientIp, executionMessage);
                    break;
            }

            // 직접 실행 명령에 대한 기본 응답 생성 (SControlM이 요청한 경우 등)
            if (!string.IsNullOrEmpty(requestPacket.ResponseAddress) && requestPacket.ResponsePort.HasValue)
            {
                 return CreateExecutionResponse(requestPacket, success, executionMessage);
            }
            return null; // 단방향 명령이거나 응답 불필요 시
        }

        private async Task<CommandPacket?> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp)
        {
            _logger.LogInformation("CommandHandler [{ClientIP}]: Relaying command '{CommandName}' to {FinalTargetIP}:{FinalTargetPort}.",
                clientIp, originalRelayRequest.CommandName, originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand);

            if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) ||
                !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue)
            {
                _logger.LogError("CommandHandler [{ClientIP}]: Relay failed. Final target IP or Port is missing. Packet ID: {PacketId}", 
                    clientIp, originalRelayRequest.PacketId);
                return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP or Port missing.");
            }

            // 릴레이할 새로운 패킷 생성 (DirectExecute로 변경)
            var packetToSendToFinalTarget = new CommandPacket
            {
                // PacketId = Guid.NewGuid(), // 새 ID를 발급하거나, 원래 ID를 추적용으로 전달할 수도 있음 (별도 필드 추가)
                Instruction = CommandInstruction.DirectExecute, // 최종 목적지에서는 직접 실행
                CommandName = originalRelayRequest.CommandName,
                PayloadJson = originalRelayRequest.PayloadJson,
                // 중요: 최종 목적지로부터 응답을 받아 다시 원 요청자에게 전달해야 한다면, ResponseAddress/Port를 이 SAgentM으로 설정해야 함
                // 여기서는 단순 릴레이 후, 최종 목적지의 응답을 직접 원 요청자에게 보내도록 가정하지 않음 (복잡도 증가)
                // 또는, 이 릴레이 작업 자체의 성공/실패만 원 요청자에게 응답할 수 있음.
                ResponseAddress = originalRelayRequest.ResponseAddress, // 원 요청자에게 최종 응답을 전달해야 한다면.
                ResponsePort = originalRelayRequest.ResponsePort,
            };
            // packetToSendToFinalTarget.OriginalPacketId = originalRelayRequest.PacketId; // 추적용 필드 예시

            string relayStatusMessage = $"Relay attempt for command '{packetToSendToFinalTarget.CommandName}' to {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}.";
            bool relaySuccess = false;

            try
            {
                using var targetClient = new TcpClient();
                // 타임아웃을 설정하는 것이 좋음
                await targetClient.ConnectAsync(originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand.Value)
                                  .WaitAsync(TimeSpan.FromSeconds(5)); // 5초 연결 타임아웃 예시

                if (targetClient.Connected)
                {
                    _logger.LogInformation("CommandHandler [{ClientIP}]: Successfully connected to final relay target {TargetIP}:{TargetPort}.", 
                        clientIp, originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand);

                    NetworkStream targetStream = targetClient.GetStream();
                    using var writer = new StreamWriter(targetStream, Encoding.UTF8, leaveOpen: true) { AutoFlush = true };
                    using var reader = new StreamReader(targetStream, Encoding.UTF8, leaveOpen: true);
                    
                    string jsonPayloadForTarget = JsonSerializer.Serialize(packetToSendToFinalTarget);
                    await writer.WriteLineAsync(jsonPayloadForTarget);
                    _logger.LogDebug("CommandHandler [{ClientIP}]: Sent relayed packet to final target. Waiting for response from target...", clientIp);

                    // 최종 목적지로부터 응답 수신 (타임아웃 필요)
                    string? jsonResponseFromTarget = await reader.ReadLineAsync().WaitAsync(TimeSpan.FromSeconds(10)); // 10초 응답 타임아웃 예시

                    if (jsonResponseFromTarget != null)
                    {
                        _logger.LogInformation("CommandHandler [{ClientIP}]: Received response from final target: {Response}", clientIp, jsonResponseFromTarget);
                        // 받은 응답을 그대로 원 요청자(SControlM 또는 이전 릴레이)에게 전달하기 위해 파싱 및 재구성
                        // 여기서 responsePacket은 ClientHandler가 원 요청자에게 보낼 최종 응답이 됨
                        // 받은 jsonResponseFromTarget을 CommandPacket으로 역직렬화하여 반환
                        try
                        {
                            var relayedResponsePacket = JsonSerializer.Deserialize<CommandPacket>(jsonResponseFromTarget);
                            // 필요시 응답 출처 등 정보 추가
                            relaySuccess = true; // 최종 타겟으로부터 응답을 받았으므로 릴레이 자체는 성공
                            // relayStatusMessage = "Relay successful. Response received from final target.";
                            return relayedResponsePacket; // 이 응답이 ClientHandler를 통해 원래 요청자에게 감
                        }
                        catch (JsonException jEx)
                        {
                             _logger.LogError(jEx, "CommandHandler [{ClientIP}]: Failed to deserialize response from final target.", clientIp);
                             relayStatusMessage = "Relay failed: Could not deserialize response from final target.";
                             // return CreateErrorResponse(originalRelayRequest, relayStatusMessage); // 이 SAgentM이 오류 응답 생성
                        }
                    }
                    else
                    {
                        _logger.LogWarning("CommandHandler [{ClientIP}]: No response received from final target (or target disconnected).", clientIp);
                        relayStatusMessage = "Relay successful (sent), but no response received from final target.";
                        // 이 경우, 릴레이 '시도'는 성공했지만 최종 결과를 알 수 없음. 
                        // 원 요청자에게 어떤 응답을 줄지 정책 결정 필요.
                        // 여기서는 일단 null 반환 (응답 없음) 또는 릴레이 시도 성공 메시지 반환 가능
                    }
                }
                else
                {
                     _logger.LogError("CommandHandler [{ClientIP}]: Failed to connect to final relay target.", clientIp);
                     relayStatusMessage = "Relay failed: Could not connect to final target.";
                }
            }
            catch (TimeoutException tex)
            {
                _logger.LogWarning(tex, "CommandHandler [{ClientIP}]: Timeout during relay operation to {TargetIP}:{TargetPort}.", 
                    clientIp, originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand);
                relayStatusMessage = $"Relay failed: Timeout connecting or waiting for response from {originalRelayRequest.FinalTargetIpForRelayedCommand}.";
            }
            catch (SocketException sockEx)
            {
                 _logger.LogError(sockEx, "CommandHandler [{ClientIP}]: SocketException during relay operation to {TargetIP}:{TargetPort}.", 
                    clientIp, originalRelayRequest.FinalTargetIpForRelayedCommand, originalRelayRequest.FinalTargetPortForRelayedCommand);
                 relayStatusMessage = $"Relay failed: Network error ({sockEx.SocketErrorCode}) connecting to {originalRelayRequest.FinalTargetIpForRelayedCommand}.";
            }
            catch (Exception ex)
            {
                _logger.LogError(ex, "CommandHandler [{ClientIP}]: Unexpected error during relay operation.", clientIp);
                relayStatusMessage = $"Relay failed: Unexpected error - {ex.Message}.";
            }

            // 릴레이 작업 자체의 성공/실패를 원 요청자에게 알릴 필요가 있다면 여기서 응답 생성
            // 위에서는 최종 타겟의 응답을 그대로 전달하려 했으므로, 이 부분은 최종 타겟 응답이 없을 때의 대체 응답이 됨.
            if (!string.IsNullOrEmpty(originalRelayRequest.ResponseAddress) && originalRelayRequest.ResponsePort.HasValue)
            {
                 return CreateExecutionResponse(originalRelayRequest, relaySuccess, relayStatusMessage);
            }
            return null;
        }

        // 응답 패킷 생성 헬퍼 메서드들
        private CommandPacket CreateExecutionResponse(CommandPacket requestPacket, bool success, string message)
        {
            // 실제 응답 페이로드가 필요하면 여기에 구성
            // var responsePayload = new BasicResponsePayload { Success = success, Message = message };
            // string payloadJson = JsonSerializer.Serialize(responsePayload);

            return new CommandPacket
            {
                PacketId = requestPacket.PacketId, // 원본 요청의 ID를 사용하여 응답 추적
                Instruction = CommandInstruction.DirectExecute, // 응답은 항상 DirectExecute로 간주 (또는 새로운 Instruction.Response)
                CommandName = $"{requestPacket.CommandName}_Response", // 응답임을 나타내는 CommandName 규칙
                PayloadJson = JsonSerializer.Serialize(new { Success = success, Message = message }), // 간단한 익명 타입 또는 전용 DTO 사용
                // ResponseAddress/Port는 ClientHandler가 이 패킷을 보내는 대상이 되므로 설정 불필요.
                // 원한다면 IsResponse = true 같은 플래그를 CommandPacket에 추가할 수 있음.
            };
        }
        
        private CommandPacket CreateErrorResponse(CommandPacket requestPacket, string errorMessage)
        {
             _logger.LogError("CommandHandler: Creating error response for Packet ID {PacketId}: {ErrorMessage}", requestPacket.PacketId, errorMessage);
             return CreateExecutionResponse(requestPacket, false, errorMessage);
        }
    }

    // public class BasicResponsePayload // 응답 페이로드 예시
    // {
    //     public bool Success { get; set; }
    //     public string Message { get; set; }
    // }
}

CommandHandler.cs 주요 변경 및 고려사항:

로거 주입: ILogger<CommandHandler>를 생성자에서 주입받도록 변경했습니다 (Program.cs에서 services.AddSingleton<CommandHandler>() 등록 필요).
릴레이 로직:
최종 목적지로 새 TcpClient를 생성하여 연결하고, DirectExecute 명령으로 변경된 패킷을 전송합니다.
최종 목적지로부터 응답을 수신하고, 이 응답을 원래 요청자에게 전달하기 위해 반환합니다. 이 부분은 동기적으로 처리하면 릴레이 에이전트가 블로킹될 수 있으므로, 비동기 처리가 중요합니다.
연결 및 응답 타임아웃을 추가했습니다 (WaitAsync).
응답 생성: CreateExecutionResponse 및 CreateErrorResponse 헬퍼 메서드를 사용하여 응답 CommandPacket을 생성합니다. 응답 패킷에는 원래 요청의 PacketId를 사용하여 추적하고, 성공 여부와 메시지를 페이로드에 담습니다. CommandName에 _Response 접미사를 붙이는 규칙을 사용할 수 있습니다.
릴레이 시 응답 처리 복잡성: 다단계 릴레이에서 각 단계의 응답을 어떻게 처리하고 최종 사용자에게 전달할지는 중요한 설계 결정 사항입니다. 위 코드는 1단계 릴레이 후 최종 목적지의 응답을 받아와서 전달하는 시나리오를 가정합니다.
위 코드들은 SAgentM.Service의 주요 골격을 형성합니다. SControl.Common의 클래스들과 함께 사용되어 실제 명령을 처리하고 릴레이하는 기능을 수행할 수 있는 기반이 됩니다.

다시 한번 강조하지만, 이 코드는 "완성된 프로덕션 코드"라기보다는 상세한 "기능 구현 예시"입니다.

메시지 프레이밍: ClientHandler의 ReadLineAsync는 JSON 메시지가 개행으로 구분된다고 가정합니다. 실제로는 더 강력한 메시지 경계 처리가 필요합니다 (예: 메시지 길이 정보 전송).
오류 처리 및 복원력: 네트워크 오류, 예외 상황에 대한 더욱 견고한 처리가 필요합니다.
보안: SSL/TLS를 사용한 통신 암호화, 인증/인가 메커니즘 등이 실제 환경에서는 고려되어야 합니다.
설정 관리: 포트 번호 외에 다양한 설정을 appsettings.json 또는 다른 방식으로 관리해야 할 수 있습니다.