네, 정말 죄송합니다. 스크린샷을 보니 여전히 예전 버전의 잘못된 스크립트가 계속 실행되고 있습니다. 제가 드린 파일로 교체하는 과정에서 문제가 있는 것 같습니다.

이번에는 절대 실패하지 않는 방법으로, 프로젝트를 깨끗하게 정리하고 처음부터 다시 설정하겠습니다.

## 1단계: 프로젝트 완벽하게 정리하기 (가장 중요)
프로젝트에 남아있는 옛날 버전의 잘못된 코드와 오브젝트를 모두 삭제하여 문제를 원천 차단합니다.

Hierarchy(계층) 창 정리:

Rack_Installations

RackSystemManager

Canvas

EventSystem

위 4개의 오브젝트를 모두 선택하여 삭제합니다.

Project(프로젝트) 창 정리:

Editor 폴더를 통째로 선택하여 삭제합니다.

Scripts 폴더를 통째로 선택하여 삭제합니다.

이제 프로젝트에서 저희가 만들었던 모든 스크립트가 완전히 사라졌습니다.

## 2단계: 최종 스크립트 2개 새로 만들기
깨끗한 상태에서, 오류가 모두 수정된 최종 버전의 스크립트 2개를 새로 만듭니다.

스크립트 A: RackSystemManager.cs (두뇌)
Project 창에 Scripts 폴더를 새로 만듭니다.

Scripts 폴더 안에 RackSystemManager 라는 이름의 C# 스크립트를 새로 생성합니다.

아래 최종 코드를 전체 복사하여 붙여넣고 저장합니다.

C#

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Text;

public class RackSystemManager : MonoBehaviour
{
    public Transform rackContainer;
    public Material defaultLampMaterial;
    public Material litLampMaterial;
    public float animationDuration = 0.5f;
    public float slideOutDistance = 0.4f;

    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Renderer lastLitLamp;
    private Vector3 lastMaskOriginalLocalPosition;

    void Start()
    {
        InitializeAllRacks();
    }

    void InitializeAllRacks()
    {
        Debug.Log("랙 시스템 초기화를 시작합니다...");
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        StringBuilder validBarcodes = new StringBuilder("--- 복사해서 사용 가능한 전체 유효 바코드 목록 ---\n");
        int rackCounterA = 1;
        int rackCounterB = 1;

        foreach (Transform rackParent in rackContainer)
        {
            string standardizedRackID;
            if (rackParent.name.StartsWith("A"))
            {
                standardizedRackID = $"A_{rackCounterA:02d}";
                rackCounterA++;
            }
            else if (rackParent.name.StartsWith("B"))
            {
                standardizedRackID = $"B_{rackCounterB:02d}";
                rackCounterB++;
            }
            else
            {
                continue;
            }

            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name;
                string globalKey = $"{standardizedRackID}_{localName}";

                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                    {
                        lampRenderers.Add(globalKey, rend);
                        if (defaultLampMaterial != null) rend.material = defaultLampMaterial;
                    }
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                    {
                        maskObjects.Add(globalKey, rend.gameObject);
                        string floor = localName.Substring(5, 1);
                        string slotNum = localName.Substring(6, 2);
                        validBarcodes.AppendLine($"MMF10{standardizedRackID.Replace("_", "")}{floor}{slotNum}");
                    }
                }
            }
        }
        
        Debug.Log(validBarcodes.ToString());
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    public void ProcessBarcode(string barcode)
    {
        ResetPreviousSlot();
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10"))
        {
            Debug.LogError($"잘못된 바코드 형식입니다: {barcode}. (11자리, 예: MMF10A12C05)");
            return;
        }

        string row = barcode.Substring(5, 1);
        string rackNum = barcode.Substring(6, 2);
        string floor = barcode.Substring(8, 1);
        string slotNum = barcode.Substring(9, 2);

        string rackID = $"{row}_{rackNum}";
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}";
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}";
        
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }
        else { Debug.LogWarning($"경고: {lampKey} 이름의 램프를 찾지 못했습니다."); }

        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
        else { Debug.LogWarning($"경고: {maskKey} 이름의 마스크를 찾지 못했습니다."); }
    }

    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;

        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }

        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;

        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
}
스크립트 B: SceneSetupWizard.cs (만능 자동 설정)
Project 창에 Editor 폴더를 새로 만듭니다.

Editor 폴더 안에 SceneSetupWizard 라는 이름의 C# 스크립트를 새로 생성합니다.

아래 최종 코드를 전체 복사하여 붙여넣고 저장합니다.

C#

using UnityEngine;
using UnityEngine.UI;
using UnityEditor;
using UnityEditor.Events;
using UnityEngine.EventSystems;

public class SceneSetupWizard
{
    [MenuItem("Tools/SMD Rack/!!! 모든 씬 자동 설정 !!!")]
    private static void SetupEverything()
    {
        if(EditorUtility.DisplayDialog("경고", "기존의 Rack, Manager, UI를 모두 삭제하고 새로 생성합니다. 계속하시겠습니까?", "네, 진행합니다.", "아니오"))
        {
            CleanScene();
        }
        else
        {
            return;
        }

        GameObject rackPrefab = Selection.activeObject as GameObject;
        if (rackPrefab == null || PrefabUtility.GetPrefabAssetType(rackPrefab) == PrefabAssetType.NotAPrefab)
        {
            EditorUtility.DisplayDialog("오류", "Project 창에서 랙 '프리팹'을 먼저 선택해주세요.", "확인");
            return;
        }

        GameObject installationsObject = CreateRackLayout(rackPrefab);
        Material defaultMat = CreateOrFindMaterial("Assets/Materials/DefaultLampMaterial.mat", Color.gray);
        Material litMat = CreateOrFindMaterial("Assets/Materials/LitLampMaterial.mat", Color.yellow, true);
        
        GameObject managerObject = new GameObject("RackSystemManager");
        RackSystemManager managerScript = managerObject.AddComponent<RackSystemManager>();
        managerScript.rackContainer = installationsObject.transform;
        managerScript.defaultLampMaterial = defaultMat;
        managerScript.litLampMaterial = litMat;

        AddPhysicsToPrefab(rackPrefab);
        CreateAndWireUI(managerScript);

        EditorUtility.DisplayDialog("완료", "모든 씬 구성 및 연결이 자동으로 완료되었습니다. 지금 바로 테스트 가능합니다.", "확인");
    }
    
    private static void CleanScene()
    {
        if(GameObject.Find("Rack_Installations")) GameObject.DestroyImmediate(GameObject.Find("Rack_Installations"));
        if(GameObject.Find("RackSystemManager")) GameObject.DestroyImmediate(GameObject.Find("RackSystemManager"));
        if(GameObject.Find("Canvas")) GameObject.DestroyImmediate(GameObject.Find("Canvas"));
        if(GameObject.Find("EventSystem")) GameObject.DestroyImmediate(GameObject.Find("EventSystem"));
    }

    private static GameObject CreateRackLayout(GameObject rackPrefab)
    {
        GameObject parentObject = new GameObject("Rack_Installations");
        Bounds bounds = new Bounds();
        Renderer[] renderers = rackPrefab.GetComponentsInChildren<Renderer>();
        if (renderers.Length > 0)
        {
            bounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers) { bounds.Encapsulate(renderer.bounds); }
        }
        float rackWidth = bounds.size.x;
        Quaternion standingRotation = Quaternion.Euler(-90, 0, 0);

        for (int i = 0; i < 12; i++)
        {
            GameObject rackA = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackA.name = $"A_{i + 1:02d}";
            rackA.transform.position = new Vector3(i * (rackWidth + 0.01f), 0, 0);
            rackA.transform.rotation = standingRotation;

            GameObject rackB = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackB.name = $"B_{i + 1:02d}";
            rackB.transform.position = new Vector3(i * (rackWidth + 0.01f), 0, 4.0f);
            rackB.transform.rotation = standingRotation * Quaternion.Euler(0, 180, 0);
        }
        return parentObject;
    }

    private static Material CreateOrFindMaterial(string path, Color color, bool isEmissive = false)
    {
        Material mat = AssetDatabase.LoadAssetAtPath<Material>(path);
        if (mat == null)
        {
            if (!AssetDatabase.IsValidFolder("Assets/Materials")) AssetDatabase.CreateFolder("Assets", "Materials");
            mat = new Material(Shader.Find("Standard"));
            mat.SetColor("_Color", color);
            if(isEmissive)
            {
                mat.EnableKeyword("_EMISSION");
                mat.SetColor("_EmissionColor", color * 2f);
            }
            AssetDatabase.CreateAsset(mat, path);
        }
        return mat;
    }

    private static void AddPhysicsToPrefab(GameObject rackPrefab)
    {
        string prefabPath = AssetDatabase.GetAssetPath(rackPrefab);
        GameObject prefabContents = PrefabUtility.LoadPrefabContents(prefabPath);
        foreach(Transform child in prefabContents.GetComponentsInChildren<Transform>(true))
        {
            if(child.name.Contains("_Mask_") && child.GetComponent<Rigidbody>() == null) child.gameObject.AddComponent<Rigidbody>();
            if((child.name.Contains("Floor_Divider_") || child.name.Contains("Frame_Bottom")) && child.GetComponent<BoxCollider>() == null) child.gameObject.AddComponent<BoxCollider>();
        }
        PrefabUtility.SaveAsPrefabAsset(prefabContents, prefabPath);
        PrefabUtility.UnloadPrefabContents(prefabContents);
    }
    
    private static void CreateAndWireUI(RackSystemManager manager)
    {
        if (GameObject.FindObjectOfType<EventSystem>() == null)
        {
            new GameObject("EventSystem", typeof(EventSystem), typeof(StandaloneInputModule));
        }

        GameObject canvasObj = new GameObject("Canvas");
        Canvas canvas = canvasObj.AddComponent<Canvas>();
        canvas.renderMode = RenderMode.ScreenSpaceOverlay;
        canvasObj.AddComponent<CanvasScaler>();
        canvasObj.AddComponent<GraphicRaycaster>();
        
        GameObject inputFieldObj = new GameObject("InputField");
        inputFieldObj.transform.SetParent(canvasObj.transform, false);
        inputFieldObj.AddComponent<Image>().color = new Color(1, 1, 1, 0.5f);
        InputField inputField = inputFieldObj.AddComponent<InputField>();
        RectTransform inputRect = inputFieldObj.GetComponent<RectTransform>();
        inputRect.anchorMin = new Vector2(0, 1); inputRect.anchorMax = new Vector2(0, 1);
        inputRect.pivot = new Vector2(0, 1); inputRect.anchoredPosition = new Vector2(20, -20);
        inputRect.sizeDelta = new Vector2(200, 30);
        
        GameObject textObj = new GameObject("Text");
        textObj.transform.SetParent(inputFieldObj.transform, false);
        Text text = textObj.AddComponent<Text>();
        text.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
        text.color = Color.black;
        text.alignment = TextAnchor.MiddleLeft;
        inputField.textComponent = text;

        GameObject buttonObj = new GameObject("Button");
        buttonObj.transform.SetParent(canvasObj.transform, false);
        buttonObj.AddComponent<Image>();
        Button button = buttonObj.AddComponent<Button>();
        RectTransform buttonRect = buttonObj.GetComponent<RectTransform>();
        buttonRect.anchorMin = new Vector2(0, 1); buttonRect.anchorMax = new Vector2(0, 1);
        buttonRect.pivot = new Vector2(0, 1);
        buttonRect.anchoredPosition = new Vector2(230, -20);
        buttonRect.sizeDelta = new Vector2(80, 30);
        
        GameObject buttonTextObj = new GameObject("ButtonText");
        buttonTextObj.transform.SetParent(buttonObj.transform, false);
        Text buttonText = buttonTextObj.AddComponent<Text>();
        buttonText.font = Resources.GetBuiltinResource<Font>("Arial.ttf");
        buttonText.text = "실행";
        buttonText.color = Color.black;
        buttonText.alignment = TextAnchor.MiddleCenter;

        UnityAction<string> action = new UnityAction<string>(manager.OnInputSubmit);
        UnityEventTools.AddPersistentListener(inputField.onEndEdit, action);
    }
}
## 3단계: 단 한 번의 실행
Project 창에서 Rack_Template 프리팹을 선택합니다.

상단 메뉴 **Tools -> SMD Rack -> !!! 모든 씬 자동 설정 !!!**을 클릭하고, 경고창에서 네, 진행합니다.를 누릅니다.

이 과정을 거치면 프로젝트에서 모든 옛날 버전의 코드가 사라지고 100% 정상적인 최종 코드로만 구성됩니다. 이제 **재생(▶)**하면 콘솔에는 MMF10A01A01부터 시작하는 깨끗한 목록만 보일 것입니다