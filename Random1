해했습니다. Resume 버튼을 각 행마다 배치하고, 그 행의 작업부터 시작할 수 있도록 구현하겠습니다. 즉, 각 TaskModel 행에 Resume 버튼이 있고, 이 버튼을 누르면 그 행부터 작업을 재개하는 방식입니다.

수정 사항 요약:
각 DataGrid 행마다 Resume 버튼을 추가.
각 행의 Resume 버튼을 누르면, 그 행부터 작업이 재개되고, 이후의 작업들은 순차적으로 실행.
TaskQueue는 계속해서 작업을 순차적으로 실행하며, 일시정지된 상태는 TaskModel에서 처리.
1. TaskModel Class 수정 (Resume 처리 추가)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows;

public class TaskModel : ViewModelBase
{
    // 로그 엔트리 정보
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 비동기 함수 리스트
    public List<Func<Task>> FunctionTasks { get; set; }

    // 각 함수 상태를 도형으로 표현 (도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 현재 작업이 대기, 실행, 완료 상태인지 나타냄
    public string Status { get; set; }

    // Resume 명령어 (행마다 존재)
    public ICommand ResumeCommand { get; }

    // 작업 큐와 연결
    private TaskQueue _taskQueue;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;

        _taskQueue = taskQueue;  // TaskQueue를 받아옴

        // 비동기 함수 리스트 초기화 및 함수 추가
        FunctionTasks = new List<Func<Task>>
        {
            ExecuteTaskA,
            ExecuteTaskB,
            ExecuteTaskC
        };

        // FunctionStatusColors 리스트 초기화 (각 함수의 상태를 색상으로 표현)
        FunctionStatusColors = new ObservableCollection<Brush>
        {
            Brushes.Gray,  // Task A 초기 상태
            Brushes.Gray,  // Task B 초기 상태
            Brushes.Gray   // Task C 초기 상태
        };

        // 상태 초기화
        Status = "Pending";

        // Resume 버튼 명령어 설정
        ResumeCommand = new RelayCommand(ResumeTask);
    }

    /// <summary>
    /// 특정 행부터 작업을 재개하는 함수 (Resume 버튼 클릭 시 호출)
    /// </summary>
    private async void ResumeTask()
    {
        if (Status == "Paused" || Status == "Pending")
        {
            Status = "Running";  // 상태를 Running으로 변경
            await ExecuteTaskSequence();  // 작업 시퀀스를 순차적으로 실행
        }
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        for (int i = 0; i < FunctionTasks.Count; i++)
        {
            if (FunctionStatusColors[i] == Brushes.Green)  // 이미 완료된 작업은 스킵
            {
                continue;
            }

            await FunctionTasks[i]();  // 비동기 작업 실행

            // 함수 실행 후 색상 변경
            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[i] = Brushes.Green;
            });
        }
        Status = "Completed";  // 완료 상태로 변경
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}
설명:
ResumeCommand: 각 행에 있는 Resume 버튼을 클릭하면, 그 행의 작업을 재개하는 명령어입니다.
ResumeTask: Resume 버튼을 클릭했을 때 호출되며, 그 행의 작업을 재개하고 이후 작업을 순차적으로 실행합니다.
ExecuteTaskSequence: 각 작업(Task A, B, C)을 순차적으로 실행하며, 이미 완료된 작업은 스킵하고 나머지 작업을 실행합니다.
2. MainViewModel Class 수정
csharp
코드 복사
using System.Collections.ObjectModel;

public class MainViewModel : ViewModelBase
{
    // 작업 목록 (TaskModel 리스트)
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;

    public MainViewModel()
    {
        _taskQueue = new TaskQueue();  // TaskQueue 인스턴스 생성

        // 작업 목록 초기화
        TaskList = new ObservableCollection<TaskModel>
        {
            new TaskModel(new LogEntry { MAG_NO = "MAG001", PO_NO = "PO12345" }, _taskQueue),
            new TaskModel(new LogEntry { MAG_NO = "MAG002", PO_NO = "PO67890" }, _taskQueue)
        };
    }
}
설명:
TaskQueue는 여전히 작업을 순차적으로 처리하는 역할을 맡습니다.
각 TaskModel은 ResumeCommand를 통해 작업을 재개할 수 있으며, 각 작업은 TaskQueue에 의해 순차적으로 실행됩니다.
3. XAML (Resume 버튼 추가)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Task Queue Example" Height="400" Width="800">
    <Grid>
        <!-- DataGrid to display TaskModels -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO Column -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                
                <!-- PO_NO Column -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*" />

                <!-- 상태 표시 -->
                <DataGridTextColumn Header="Status" Binding="{Binding Status}" Width="*" />

                <!-- Resume 버튼 -->
                <DataGridTemplateColumn Header="Resume">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Button Content="Resume" Command="{Binding ResumeCommand}" />
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
Resume 버튼이 각 행에 추가되었습니다. 각 행에 있는 Resume 버튼을 누르면 그 행의 작업을 재개하고, 이후 작업들이 순차적으로 실행됩니다.
Status 컬럼에서 각 작업의 상태(대기, 실행 중, 완료)를 표시합니다.
최종 요약:
각 DataGrid 행마다 Resume 버튼이 추가되었으며, 각 행의 Resume 버튼을 클릭하면 해당 작업이 재개됩니다.
TaskModel에서 각 작업의 상태를 관리하며, 완료된 작업은 건너뛰고 나머지 작업이 실행됩니다.
TaskQueue는 여전히 순차적인 작업 처리를 담당하고 있지만, 일시정지나 재개는 TaskModel에서 관리됩니다.
이 구조로 각 작업을 독립적으로 재개할 수 있으며, 전체 일시정지나 재개도 쉽게 확