Bitmap 오류와 함께 메모리 부족이 발생한다면, 두 문제는 깊은 연관이 있을 가능성이 높습니다. 버튼을 반복해서 누를 때마다 메모리 누수(Memory Leak)가 발생하고, 이로 인해 프로그램이 불안정해지면서 좌표 계산 오류나 예외를 일으키는 것입니다.

핵심 원인: 메모리 누수
가장 유력한 원인은 버튼을 클릭할 때마다 BitmapImage와 같은 무거운 그래픽 리소스를 새로 생성하면서, 이전에 사용했던 리소스를 제대로 해제하지 않기 때문입니다. 가비지 컬렉터(GC)가 제때 수거하지 못하는 참조가 남아있으면 메모리 사용량이 계속해서 증가하여 결국 OutOfMemoryException을 유발합니다.

잘못된 코드 패턴의 예:

C#

// 버튼 클릭 이벤트 핸들러
private void OnButtonClick(object sender, RoutedEventArgs e)
{
    // !!! 나쁜 예: 매번 파일을 읽어 BitmapImage를 생성 !!!
    // 이렇게 하면 이전 BitmapImage 객체가 메모리에 계속 쌓일 수 있습니다.
    var bitmapImage = new BitmapImage(new Uri("C:\\path\\to\\your\\image.jpg"));

    // 자르기 로직...
    // CroppedBitmap croppedBitmap = new CroppedBitmap(bitmapImage, ...);
}
해결 방안: 리소스 관리 및 방어 코드
메모리 누수를 막고 CroppedBitmap 오류를 근본적으로 해결하기 위한 두 가지 핵심 전략은 다음과 같습니다.

1. BitmapImage를 올바르게 로드하고 재사용하기
이미지 데이터는 한 번만 로드하여 멤버 변수에 저장해두고, 버튼 클릭 시에는 이 변수를 재사용하는 것이 좋습니다. 로드 시에는 BitmapCacheOption.OnLoad 옵션을 사용하여 이미지 데이터를 즉시 메모리에 모두 올리고 원본 파일/스트림과의 연결을 끊는 것이 안전합니다.

C#

// (클래스 멤버 변수)
private BitmapImage originalBitmapImage;

// 이미지 초기 로딩 (생성자나 별도의 초기화 메소드에서 호출)
private void LoadImage()
{
    // originalBitmapImage가 null일 때만 새로 로드
    if (originalBitmapImage == null)
    {
        originalBitmapImage = new BitmapImage();
        originalBitmapImage.BeginInit();
        originalBitmapImage.UriSource = new Uri("C:\\path\\to\\your\\image.jpg");
        // ★★★
        // OnLoad 옵션: 이미지 데이터를 모두 메모리에 로드하고 파일 핸들을 즉시 해제합니다.
        // 메모리 누수 및 파일 잠금 문제를 방지하는 핵심 옵션입니다.
        // ★★★
        originalBitmapImage.CacheOption = BitmapCacheOption.OnLoad;
        originalBitmapImage.EndInit();
        originalBitmapImage.Freeze(); // UI 스레드가 아닌 곳에서 접근해야 할 경우 필수
    }
}

// 버튼 클릭 이벤트 핸들러
private void OnCropButtonClick(object sender, RoutedEventArgs e)
{
    try
    {
        // 1. 원본 이미지가 로드되었는지 확인
        LoadImage(); // 필요시 로드
        if (this.originalBitmapImage == null) return;

        // 2. 자를 영역(cropArea) 계산
        Int32Rect cropArea = new Int32Rect(/* x, y, width, height 계산 */);

        // 3. (중요) 자를 영역이 원본 이미지의 경계 내에 있는지 반드시 확인
        if (cropArea.X < 0 || cropArea.Y < 0 ||
            cropArea.X + cropArea.Width > this.originalBitmapImage.PixelWidth ||
            cropArea.Y + cropArea.Height > this.originalBitmapImage.PixelHeight)
        {
            MessageBox.Show("자르기 영역이 이미지 범위를 벗어났습니다.");
            return;
        }

        // 4. ★항상 원본 이미지(originalBitmapImage)로부터 자르기★
        CroppedBitmap croppedBitmap = new CroppedBitmap(this.originalBitmapImage, cropArea);

        // 결과 표시
        imageControl.Source = croppedBitmap;
    }
    catch (Exception ex)
    {
        MessageBox.Show($"오류 발생: {ex.Message}");
    }
}
2. CroppedBitmap 오류와 메모리 문제의 연관성
잘못된 원본 참조: 두 번째 버튼 클릭 시, originalBitmapImage 변수가 이전에 잘라낸 CroppedBitmap을 가리키고 있을 수 있습니다. CroppedBitmap은 크기가 더 작으므로, 기존의 cropArea 값은 당연히 범위를 벗어나게 됩니다. 항상 원본 전체 이미지에서 잘라내야 합니다.

리소스 고갈로 인한 오작동: 메모리가 부족해지면 GDI+ 같은 내부 시스템에서 비트맵 핸들을 할당하지 못하는 등 예기치 않은 오류가 발생하며, 이것이 "값이 예상 범위를 벗어났습니다"라는 예외로 나타날 수도 있습니다.

요약 및 체크리스트
메모리 누수 해결: BitmapImage 생성 시 **BitmapCacheOption.OnLoad**를 사용하고, 이미지는 한 번만 로드하여 재사용하세요.

원본 이미지 보존: CroppedBitmap을 생성할 때 참조하는 소스는 항상 맨 처음 로드한 원본 이미지여야 합니다. 잘린 이미지를 다시 자르려 하면 좌표 오류가 발생합니다.