현재 화면을 캡처하여 DB에 업로드하는 방법을 구현하겠습니다. 이를 위해 ImageDisplayScreen에서 화면을 캡처하고 그 이미지를 데이터베이스에 업로드하는 기능을 추가합니다.

MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material.MaterialTheme
import androidx.compose.material.Surface
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.platform.LocalDensity
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet

class MainActivity : ComponentActivity() {
    private lateinit var hubConnection: HubConnection

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MSSQLImageAppTheme {
                Surface(modifier = Modifier.fillMaxSize(), color = MaterialTheme.colors.background) {
                    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
                    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }
                    var selectedImageTitle by remember { mutableStateOf("") }
                    var selectedDatetime by remember { mutableStateOf("") }

                    val scope = rememberCoroutineScope()

                    val fetchData: () -> Unit = {
                        scope.launch {
                            imageList = fetchDataFromDatabase()
                        }
                    }

                    LaunchedEffect(Unit) {
                        fetchData()
                        setupSignalR()
                    }

                    if (selectedImage == null) {
                        ImageListScreen(
                            imageList = imageList,
                            selectedImage = selectedImage,
                            selectedImageTitle = selectedImageTitle,
                            selectedDatetime = selectedDatetime,
                            onFetchData = fetchData,
                            onImageSelected = { title, datetime ->
                                scope.launch {
                                    selectedImage = fetchImageFromDatabase(title, datetime)
                                    selectedImageTitle = title
                                    selectedDatetime = datetime
                                }
                            },
                            onBack = {
                                selectedImage = null
                                fetchData()
                            },
                            onFit = {
                                // No-op
                            },
                            isRefreshing = false,
                            onToggleRefresh = {}
                        )
                    } else {
                        ImageDisplayScreen(
                            bitmap = selectedImage,
                            imageTitle = selectedImageTitle,
                            datetime = selectedDatetime,
                            onBack = {
                                selectedImage = null
                                fetchData()
                            },
                            onFit = {
                                selectedImage = selectedImage
                            },
                            isRefreshing = false,
                            onToggleRefresh = {}
                        )
                    }
                }
            }
        }
    }

    private fun setupSignalR() {
        hubConnection = HubConnectionBuilder.create("https://yourserver/signalrhub")
            .build()

        hubConnection.on("UpdateImage", { imageTitle: String, datetime: String ->
            runOnUiThread {
                updateImage(imageTitle, datetime)
            }
        }, String::class.java, String::class.java)

        hubConnection.start().blockingAwait()
    }

    private fun updateImage(imageTitle: String, datetime: String) {
        val scope = CoroutineScope(Dispatchers.Main)
        scope.launch {
            val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
            if (newBitmap != null) {
                // 갱신된 이미지 처리 로직
            }
        }
    }

    override fun onDestroy() {
        hubConnection.stop().blockingAwait()
        super.onDestroy()
    }

    suspend fun fetchDataFromDatabase(): List<ImageData> {
        return withContext(Dispatchers.IO) {
            try {
                val connection: Connection = DriverManager.getConnection(
                    "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                    "yourUsername",
                    "yourPassword"
                )
                val statement = connection.createStatement()
                val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

                val imageList = mutableListOf<ImageData>()
                while (resultSet.next()) {
                    val imageTitle = resultSet.getString("imagetitle")
                    val datetime = resultSet.getString("datetime1")
                    imageList.add(ImageData(imageTitle, datetime))
                }
                connection.close()
                imageList
            } catch (e: Exception) {
                emptyList()
            }
        }
    }

    suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
        return withContext(Dispatchers.IO) {
            try {
                val connection: Connection = DriverManager.getConnection(
                    "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                    "yourUsername",
                    "yourPassword"
                )
                val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
                statement.setString(1, imageTitle)
                statement.setString(2, datetime)
                val resultSet: ResultSet = statement.executeQuery()

                var bitmap: Bitmap? = null
                if (resultSet.next()) {
                    val blob = resultSet.getBlob("imageColumn")
                    val byteArray = blob.binaryStream.readBytes()
                    bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
                }
                connection.close()
                bitmap
            } catch (e: Exception) {
                null
            }
        }
    }
}
ImageListScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Paint
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import androidx.core.graphics.applyCanvas
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    LaunchedEffect(Unit) {
        onFetchData()
    }

    Column {
        LazyColumn(modifier = Modifier.weight(1f).padding(horizontal = 20.dp)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            ImageDisplayScreen(
                bitmap = it,
                imageTitle = selectedImageTitle,
                datetime = selectedDatetime,
                onBack = onBack,
                onFit = onFit,
                isRefreshing = isRefreshing,
                onToggleRefresh = onToggleRefresh
            )
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        if (drawMode) {
            Canvas(modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { offset -> currentPathPoints = listOf(offset) },
                        onDragEnd = {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                            currentPathPoints = listOf()
                        },
                        onDrag = { change, _ ->
                            currentPathPoints = currentPathPoints + change.position
                            change.consume()
                        }
                    )
                }
            ) {
                for (path in drawingPaths) {
                    for (i in 1 until path.points.size) {
                        drawLine(
                            color = path.color,
                            start = path.points[i - 1],
                            end = path.points[i],
                            strokeWidth = 3f
                        )
                    }
                }
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(20.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    scope.launch {
                        val bitmapWithDrawing = mergeBitmapWithDrawing(currentBitmap!!, drawingPaths)
                        uploadBitmap(bitmapWithDrawing)
                    }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

suspend fun mergeBitmapWithDrawing(bitmap: Bitmap, drawingPaths: List<DrawingPath>): Bitmap {
    return withContext(Dispatchers.Default) {
        val resultBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true)
        val canvas = Canvas(resultBitmap)
        val paint = Paint().apply {
            isAntiAlias = true
            style = Paint.Style.STROKE
            strokeWidth = 3f
        }

        drawingPaths.forEach { path ->
            paint.color = path.color.toArgb()
            for (i in 1 until path.points.size) {
                val startX = path.points[i - 1].x
                val startY = path.points[i - 1].y
                val stopX = path.points[i].x
                val stopY = path.points[i].y
                canvas.drawLine(startX, startY, stopX, stopY, paint)
            }
        }

        resultBitmap
    }
}

fun captureBitmapFromScreen(drawingCanvas: @Composable () -> Unit, width: Int, height: Int): Bitmap {
    val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
    val density = LocalDensity.current

    bitmap.applyCanvas {
        with(density) {
            drawingCanvas()
        }
    }

    return bitmap
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
위의 ImageDisplayScreen 함수에서 captureBitmapFromScreen 함수를 사용하여 화면을 캡처하고, 해당 비트맵을 데이터베이스에 업로드하는 uploadBitmap 함수를 호출합니다.

이제 Upload 버튼을 클릭하면 현재 화면을 캡처하여 데이터베이스에 업로드됩니다.