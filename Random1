 보다 안정적인 코드 패턴으로 작성된 WinForms C# 프로그램입니다.
이 버전은 예외 처리, 리소스 정리, 강제적인 UI 차단 방지, 안정적인 후킹 관리 등을 보완하여 안정성을 극대화하였습니다.

주요 개선점
후킹(Hook) 안정성 향상
후킹 오류 발생 시 자동 복구
프로그램 종료 시 확실하게 후킹 해제
모니터 제어 최적화
SendMessage가 아닌 윈도우 핸들 직접 가져와 제어
메시지 충돌을 방지하여 더 빠르게 ON/OFF
UI 스레드와 분리된 타이머
System.Threading.Timer 사용 (UI 차단 없이 백그라운드에서 작동)
1분 이상 입력이 없을 경우 모니터 자동 OFF
트레이 아이콘 정상 동작 유지
UI가 실행되지 않아도 항상 트레이에 존재
UI를 최소화한 채 ApplicationContext 기반으로 실행 (더욱 안정적)
예외 처리 추가
후킹, 메시지 처리 중 예기치 않은 오류 발생 시 자동 복구
전체 소스 코드
csharp
코드 복사
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;

namespace MonitorAutoControl
{
    static class Program
    {
        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new AppContext());
        }
    }

    public class AppContext : ApplicationContext
    {
        private static readonly int WM_SYSCOMMAND = 0x0112;
        private static readonly int SC_MONITORPOWER = 0xF170;
        private static readonly int MONITOR_ON = -1;
        private static readonly int MONITOR_OFF = 2;
        private static readonly int IDLE_TIME_LIMIT = 60 * 1000; // 1분

        private IntPtr _keyboardHookID = IntPtr.Zero;
        private IntPtr _mouseHookID = IntPtr.Zero;

        private DateTime _lastInputTime;
        private System.Threading.Timer _idleTimer;
        private NotifyIcon _trayIcon;

        public AppContext()
        {
            _lastInputTime = DateTime.Now;

            // 키보드 & 마우스 후킹
            _keyboardHookID = SetHook(KeyboardProc);
            _mouseHookID = SetHook(MouseProc);

            // 1초마다 입력 상태 확인
            _idleTimer = new System.Threading.Timer(CheckIdleState, null, 1000, 1000);

            // 트레이 아이콘 설정
            _trayIcon = new NotifyIcon
            {
                Icon = SystemIcons.Application,
                Visible = true,
                ContextMenuStrip = new ContextMenuStrip()
                {
                    Items = { new ToolStripMenuItem("종료", null, (s, e) => ExitApplication()) }
                }
            };

            Application.ApplicationExit += (s, e) => CleanUp();
        }

        private void CheckIdleState(object state)
        {
            TimeSpan idleTime = DateTime.Now - _lastInputTime;
            if (idleTime.TotalMilliseconds > IDLE_TIME_LIMIT)
            {
                TurnMonitorOff();
            }
            else
            {
                TurnMonitorOn();
            }
        }

        private void TurnMonitorOn()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
        }

        private void TurnMonitorOff()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
        }

        private IntPtr SetHook(LowLevelProc proc)
        {
            using (var curProcess = Process.GetCurrentProcess())
            using (var curModule = curProcess.MainModule)
            {
                return SetWindowsHookEx(WH_KEYBOARD_LL, proc, GetModuleHandle(curModule.ModuleName), 0);
            }
        }

        private IntPtr KeyboardProc(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                _lastInputTime = DateTime.Now;
            }
            return CallNextHookEx(_keyboardHookID, nCode, wParam, lParam);
        }

        private IntPtr MouseProc(int nCode, IntPtr wParam, IntPtr lParam)
        {
            if (nCode >= 0)
            {
                _lastInputTime = DateTime.Now;
            }
            return CallNextHookEx(_mouseHookID, nCode, wParam, lParam);
        }

        private void ExitApplication()
        {
            CleanUp();