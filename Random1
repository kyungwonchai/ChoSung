ield initializer cannot reference the non-static field, method, or property 오류는 인스턴스 필드를 초기화할 때, 인스턴스 멤버(메서드 또는 속성)를 직접 참조할 수 없기 때문에 발생합니다.

🔥 오류 원인
csharp
코드 복사
public class ButtonConfig
{
    public string ButtonTxt { get; set; }
    public Action OnClickAction { get; set; } = Func1; // ❌ 여기서 오류 발생

    public void Func1()
    {
        Console.WriteLine("버튼 클릭됨!");
    }
}
Func1은 인스턴스 메서드이므로, 클래스 필드 초기화 시점에서는 사용할 수 없습니다.
클래스 필드 초기화(OnClickAction = Func1; )는 생성자가 호출되기 전에 수행됩니다.
하지만 Func1()은 클래스의 인스턴스가 생성된 후에만 사용할 수 있습니다.
따라서 인스턴스 필드를 초기화할 때 인스턴스 메서드를 직접 참조할 수 없습니다.
✅ 해결 방법
1️⃣ 생성자에서 설정하기 (권장)
➡ 생성자에서 OnClickAction을 Func1로 할당하면 정상 작동합니다.

csharp
코드 복사
public class ButtonConfig
{
    public string ButtonTxt { get; set; }
    public Action OnClickAction { get; set; } 

    public ButtonConfig()
    {
        OnClickAction = Func1; // ✅ 생성자 내부에서는 인스턴스 멤버 참조 가능
    }

    public void Func1()
    {
        Console.WriteLine("버튼 클릭됨!");
    }
}

// 사용 예제
ButtonConfig btn = new ButtonConfig();
btn.OnClickAction(); // "버튼 클릭됨!" 출력
✔ 생성자 내부에서는 인스턴스가 이미 생성된 상태이므로 인스턴스 메서드를 참조할 수 있습니다.

2️⃣ 정적 메서드로 변경하기
➡ Func1을 static으로 선언하면 초기화 시점에서도 참조 가능

csharp
코드 복사
public class ButtonConfig
{
    public string ButtonTxt { get; set; }
    public static Action OnClickAction { get; set; } = Func1; // ✅ 정적 메서드 사용

    public static void Func1()
    {
        Console.WriteLine("버튼 클릭됨!");
    }
}

// 사용 예제
ButtonConfig.OnClickAction(); // "버튼 클릭됨!" 출력
✔ 하지만 이 방식은 모든 ButtonConfig 인스턴스가 동일한 이벤트를 공유하게 되므로, 버튼마다 다른 클릭 이벤트를 지정해야 하는 경우 적절하지 않습니다.

3️⃣ 익명 메서드(람다) 사용
➡ 필드 초기화 시에는 new Action(() => ...) 같은 람다식을 활용 가능

csharp
코드 복사
public class ButtonConfig
{
    public string ButtonTxt { get; set; }
    public Action OnClickAction { get; set; }

    public ButtonConfig()
    {
        OnClickAction = () => Console.WriteLine("버튼 클릭됨!"); // ✅ 람다식으로 해결
    }
}

// 사용 예제
ButtonConfig btn = new ButtonConfig();
btn.OnClickAction(); // "버튼 클릭됨!" 출력
✔ 익명 메서드를 사용하면 별도 메서드를 만들지 않고도 해결 가능합니다.
