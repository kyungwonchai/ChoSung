하였습니다.

수정된 CommandQueueViewModel C# 코드
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

/// <summary>
/// 비동기 작업 관리와 실행을 담당하는 ViewModel
/// </summary>
public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>(); // 에러 메시지를 표시할 리스트
    public event PropertyChangedEventHandler PropertyChanged;

    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    private bool _isProcessing; // 현재 작업 처리 중인지 상태 표시
    private bool _isQueueStopped; // 큐 작업이 중지되었는지 상태 표시
    private readonly DatabaseHelper _dbHelper; // 데이터베이스 도우미 클래스

    public int RetryLimit { get; set; } = 3; // 재시도 횟수
    public int RetryInterval { get; set; } = 3000; // 재시도 간격 (ms)
    public int ResponseTimeout { get; set; } = 5000; // 응답 제한 시간 (ms)
    public int MaximumQueueSize { get; set; } = 10; // 최대 큐 사이즈

    private int _progress; // 진행 상태를 나타내는 프로그레스 바 값
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress)); // 프로그레스 상태 변경 알림
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false;
        _isQueueStopped = false;
        Progress = 0;
    }

    /// <summary>
    /// 외부에서 작업을 큐에 추가하는 함수
    /// </summary>
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("큐가 가득 찼거나 작업이 중지되었습니다. 추가 작업은 불가능합니다.");
            return;
        }

        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    /// <summary>
    /// 큐에 작업을 추가하고 비동기로 처리하는 함수
    /// </summary>
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem
        {
            CommandText = commandText,
            Status = "대기 중",
            MaxRetryLimit = RetryLimit,
            RetryCount = 0
        };

        App.Current.Dispatcher.Invoke(() => RemainingCommands.Add(newCommand));

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "처리 중";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch();

            _isProcessing = true;

            while (retryCount < RetryLimit)
            {
                stopwatch.Restart();
                string result = await taskFunc();
                stopwatch.Stop();

                int responseTime = (int)stopwatch.ElapsedMilliseconds;
                newCommand.ResponseTime = responseTime;

                if (responseTime > ResponseTimeout)
                {
                    newCommand.Status = "시간 초과";
                    ShowAlarm("응답 시간 초과로 모든 작업이 중단되었습니다.");
                    newCommand.Result = 0;
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "실패", newCommand.Result, retryCount, responseTime, "Response Timeout");
                    StopQueueProcessing(newCommand);
                    return new CommandResult { Success = false, Message = "Response Timeout" };
                }

                if (responseValidator(result))
                {
                    newCommand.Status = "완료";
                    newCommand.Result = 1;
                    UpdateProgress();
                    return new CommandResult { Success = true, Message = result };
                }

                retryCount++;
                newCommand.RetryCount = retryCount;
                newCommand.Status = $"{retryCount}/{RetryLimit} 재시도 중";
                if (retryCount >= RetryLimit)
                {
                    newCommand.Status = "실패";
                    ShowAlarm("최대 재시도 횟수를 초과하여 작업이 중단됩니다.");
                    StopQueueProcessing(newCommand);
                    return new CommandResult { Success = false, Message = "Failed after retries" };
                }
                await Task.Delay(RetryInterval);
            }

            UpdateProgress();
            return new CommandResult { Success = false, Message = "Failed" };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }
    }

    /// <summary>
    /// 큐에서 작업을 순차적으로 처리
    /// </summary>
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue();
            await command();
            UpdateProgress();
        }
        _isProcessing = false;
    }

    /// <summary>
    /// 큐 처리 중단 및 추가 작업 차단
    /// </summary>
    private void StopQueueProcessing(CommandItem errorCommand)
    {
        _isQueueStopped = true;
        App.Current.Dispatcher.Invoke(() => ErrorCommands.Add(errorCommand));
        ShowAlarm("큐가 멈춰서 추가 작업을 수행할 수 없습니다.");
    }

    /// <summary>
    /// 에러 메시지 표시
    /// </summary>
    private void ShowAlarm(string message)
    {
        var errorCommand = new CommandItem
        {
            CommandText = message,
            Status = "오류",
            Result = 0,
            RetryCount = 0,
            ResponseTime = 0
        };

        App.Current.Dispatcher.Invoke(() => ErrorCommands.Add(errorCommand));
    }

    /// <summary>
    /// 프로그레스바 상태 업데이트
    /// </summary>
    private void UpdateProgress()
    {
        Progress = commandQueue.Count;
    }

    /// <summary>
    /// 속성 변경 알림 이벤트 트리거
    /// </summary>
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
이 코드는 당신의 요구사항에 맞게 수정되었으며, 각 기능과 상태 변경 시 적절한 한글 주석을 추가하여 코드 이해를 돕습니다.