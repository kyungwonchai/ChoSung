존 도형 기반 작업 흐름을 다시 구현하는 방식으로 이해했습니다.
당신이 원했던 것은:

도형 기반 UI에서 도형을 클릭하거나 제어하여 해당 도형과 연결된 함수가 실행되도록 구현하는 것.
각 도형이 특정 작업이나 함수와 연결되어 있으며, 이를 클릭하면 개별 함수가 실행되고, 작업이 완료되면 도형의 색상이 녹색으로 바뀌는 방식.
컨트롤 키를 누르면서 도형을 클릭하면, 그 도형에 연결된 함수만 실행될 수 있도록 구현.
기본적으로 해야 할 작업:
도형과 함수 연결: 각 도형은 하나의 함수와 연결되어 있어야 하고, 이 도형이 클릭되면 해당 함수가 실행됩니다.
컨트롤 키 클릭 기능: 도형을 클릭할 때 Ctrl 키가 눌려 있으면 개별 함수가 실행되어야 하므로, 키보드 상태를 확인한 뒤, 그 도형에 연결된 함수만 실행되도록 해야 합니다.
도형의 상태 업데이트: 함수 실행이 완료되면 도형의 색상이 변화하여 완료 상태를 시각적으로 표시하도록 구현해야 합니다.
구현 예시
1. 도형과 함수 연결 및 클릭 이벤트 처리
각 도형은 FunctionItem 객체와 연결되며, 도형을 클릭할 때 그 함수를 실행하도록 처리합니다. 또한, Ctrl 키를 누른 상태에서 클릭한 경우 해당 도형의 함수만 실행되도록 구현할 수 있습니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 각 함수별 상태를 도형으로 시각화하는 ObservableCollection
    public ObservableCollection<FunctionItem> FunctionItems { get; set; }

    public ICommand FunctionClickCommand { get; }

    public TaskModel(string magNo, string poNo)
    {
        MAG_NO = magNo;
        PO_NO = poNo;

        // 도형별로 각 함수 연결
        FunctionItems = new ObservableCollection<FunctionItem>
        {
            new FunctionItem { Name = "Task A", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskA },
            new FunctionItem { Name = "Task B", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskB },
            new FunctionItem { Name = "Task C", Status = Brushes.Gray, ExecuteFunction = ExecuteTaskC }
        };

        // 도형 클릭 명령어 연결
        FunctionClickCommand = new RelayCommand<FunctionItem>(ExecuteFunctionClick);
    }

    /// <summary>
    /// 도형을 클릭했을 때 함수 실행 로직
    /// Ctrl 키를 누르면 해당 함수만 실행하고, 그렇지 않으면 모든 작업 실행.
    /// </summary>
    private void ExecuteFunctionClick(FunctionItem function)
    {
        // Ctrl 키가 눌린 상태에서 클릭된 경우 해당 함수만 실행
        if (Keyboard.IsKeyDown(Key.LeftCtrl) || Keyboard.IsKeyDown(Key.RightCtrl))
        {
            ExecuteSpecificFunction(function);
        }
        else
        {
            // Ctrl 키가 안 눌렸을 경우 전체 작업을 순차적으로 실행
            StartTaskSequence();
        }
    }

    /// <summary>
    /// 개별 함수 실행 (Ctrl 클릭 시)
    /// </summary>
    private async void ExecuteSpecificFunction(FunctionItem function)
    {
        await function.ExecuteFunction();
        Application.Current.Dispatcher.Invoke(() =>
        {
            function.Status = Brushes.Green; // 완료 시 녹색으로 변경
        });
    }

    /// <summary>
    /// 작업 시퀀스를 순차적으로 실행
    /// </summary>
    private async void StartTaskSequence()
    {
        foreach (var function in FunctionItems)
        {
            await function.ExecuteFunction();
            Application.Current.Dispatcher.Invoke(() =>
            {
                function.Status = Brushes.Green; // 완료 시 녹색으로 변경
            });
        }
    }

    // 각각의 함수 실행 (1초 대기 후 완료로 가정)
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 작업 실행
    }

    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}
FunctionItem Class
csharp
코드 복사
public class FunctionItem
{
    public string Name { get; set; }  // 함수 이름 (Task A, Task B, Task C)
    public Brush Status { get; set; } // 도형의 색상 상태 (Gray, Green 등)
    public Func<Task> ExecuteFunction { get; set; } // 실행할 함수
}
2. MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>
        {
            new TaskModel("MAG001", "PO12345"),
            new TaskModel("MAG002", "PO67890")
        };
    }
}
3. XAML (UI with Ellipse Shapes for Functions)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Task Queue Example" Height="400" Width="600">
    <Grid>
        <!-- DataGrid to display TaskModels -->
        <DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO Column -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                
                <!-- PO_NO Column -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*" />
                
                <!-- Functions Column with Ellipses -->
                <DataGridTemplateColumn Header="Functions">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionItems}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Fill="{Binding Status}" 
                                                 Stroke="Black" StrokeThickness="1">
                                            <!-- 클릭 시 함수 실행 (FunctionClickCommand) -->
                                            <Ellipse.InputBindings>
                                                <MouseBinding Command="{Binding DataContext.FunctionClickCommand, 
                                                                        RelativeSource={RelativeSource AncestorType=DataGrid}}" 
                                                              CommandParameter="{Binding}" 
                                                              MouseAction="LeftClick"/>
                                            </Ellipse.InputBindings>
                                        </Ellipse>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
구현 설명:
FunctionItem: 각 도형이 담당할 함수와 상태를 정의하는 클래스입니다. 각 함수는 ExecuteFunction으로 연결되어 실행됩니다.
TaskModel: 각 작업(PO_NO, MAG_NO)은 여러 **도형(FunctionItems)**으로 구성됩니다. 이 도형은 각각 하나의 함수와 연결되며, 도형을 클릭하면 그 함수가 실행됩니다.
도형 클릭 이벤트: 각 Ellipse 도형은 MouseBinding을 통해 클릭 이벤트가 바인딩됩니다. 클릭하면 FunctionClickCommand가 실행되어, 해당 도형에 연결된 함수를 실행합니다.
Ctrl 키가 눌린 상태에서 클릭하면, 해당 도형의 함수만 실행됩니다.
Ctrl 키 없이 클릭하면, **전체 작업(시퀀스)**이 순차적으로 실행됩니다.
UI (XAML): DataGrid에 MAG_NO와 PO_NO를 표시하고, Ellipse 도형을 통해 각 작업에 포함된 함수들의 상태를 시각적으로 보여줍니다. 도형 클릭으로 함수 실행이 가능합니다.
추가 설명:
작업 흐름은 도형을 통해 시각적으로 보여지고, 개별 도형을 클릭하여 해당 작업의 함수만 실행할 수 있습니다.
도형 색상은 작업이 완료되면 녹색으로 변경되며, 함수 실행 상태를 실시간으로 반영합니다.
Ctrl 키 사용 여부에 따라 개별 함수만 실행할지, 전체 작업 흐름을 실행할지를 결정합니다.
이 구조는 간단하고 직관적이며, 도형을 통한 함수 제어를 가능하게 해 줍니다. 추가적으로 설명이나 구현이 필요한 부분이 있으면 언제든지 말씀해 주세요