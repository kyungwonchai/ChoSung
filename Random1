알겠습니다. "켜기" 명령을 실행했을 때, 현재처럼 "디스플레이 타임아웃 해제"(SetDisplayTimeout 명령으로 TimeoutMinutes = 0 설정)와 더불어, 실제로 마우스를 흔들어 깨우는 것처럼 즉시 모니터를 켜는 동작까지 추가하고 싶으시군요.

이 기능을 구현하려면 두 가지 종류의 명령을 조합해야 합니다:

디스플레이 타임아웃 설정 변경: powercfg를 사용하는 SetDisplayTimeout 명령 (이미 구현됨).
즉시 모니터 켜기: SC_MONITORPOWER를 사용하는 MonitorControl 명령 (이것도 SControl.Common 및 SAgentM.App에 로직이 이미 있음).
수정해야 할 주요 파일은 Flask 웹 애플리케이션에서 명령을 구성하고 전송하는 부분과, 경우에 따라 SAgentM.App 에이전트가 두 가지 동작을 순차적으로 또는 병렬적으로 처리하는 부분입니다.

가장 간단한 접근 방식은 Flask 웹 애플리케이션 (SControlM)에서 두 개의 명령을 순차적으로 또는 거의 동시에 SAgentM.App 에이전트로 보내는 것입니다. 또는 SAgentM.App에 새로운 복합 명령 (예: "SetTimeoutAndWakeMonitor")을 만들 수도 있지만, 기존 명령을 조합하는 것이 더 간단할 수 있습니다.

여기서는 Flask 웹 앱에서 두 가지 명령을 보내는 방식으로 설명드리겠습니다.

1. 수정: scontrol_flask_web/app/routes_user.py
send_batch_command 함수 내에서 "켜기" 동작을 처리할 때, SetDisplayTimeout 명령을 보낸 후, 추가로 MonitorControl (켜기) 명령을 보내도록 수정합니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection
from app.auth import ip_auth_required
from app.socket_client import send_command_to_agent # 이 함수를 계속 사용
import json
import uuid
from datetime import datetime, timezone
import math
# SControl.Common의 C# 상수/열거형 이름과 일치시키기 위한 문자열 값 사용
# 예: COMMAND_NAME_SET_DISPLAY_TIMEOUT = "SET_DISPLAY_TIMEOUT"
#     COMMAND_NAME_MONITOR_CONTROL = "MONITOR_CONTROL"
#     MONITOR_ACTION_ON = -1 # 또는 "On" 문자열 등 SAgentM.App과 약속된 값
#     INSTRUCTION_DIRECT_EXECUTE = "DirectExecute"
#     INSTRUCTION_RELAY_TO_TARGET = "RelayToTarget"


user_bp = Blueprint('user', __name__)

# control_panel 라우트는 이전과 동일하게 유지
@user_bp.route('/control_panel')
@ip_auth_required('user')
def control_panel():
    # ... (이전 control_panel 코드와 동일) ...
    page = request.args.get('page', 1, type=int)
    per_page = 20; offset = (page - 1) * per_page
    pcs_on_current_page = []; total_pcs = 0; conn = None
    pagination_data = {'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 
                       'items': [], 'has_prev': False, 'has_next': False, 
                       'prev_num': 1, 'next_num': 1} 
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute("SELECT COUNT(*) AS total FROM dbo.target_pcs")
            total_pcs_result = cursor.fetchone()
            if total_pcs_result: total_pcs = total_pcs_result['total']
            if total_pcs > 0:
                query = "SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY"
                cursor.execute(query, (offset, per_page)); pcs_on_current_page = cursor.fetchall()
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({'total_items': total_pcs, 'total_pages': total_pages, 'items': pcs_on_current_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1, 'next_num': page + 1})
    except Exception as e:
        current_app.logger.error(f"제어판 PC 목록 조회 오류: {e}", exc_info=True)
        flash("PC 목록을 불러오는 중 오류가 발생했습니다. DB 연결을 확인하세요.", "error")
    title = "원격 제어판"; 
    if g.current_user_role == 'admin': title = "원격 제어판 (관리자 모드)"
    return render_template('user/control_panel.html', pcs=pcs_on_current_page, pagination=pagination_data, title=title)


@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    selected_pc_ids_str = request.form.getlist('selected_pcs')
    command_action_str = request.form.get('command_action') # "켜기" 또는 "끄기"

    if not selected_pc_ids_str: flash("제어할 PC를 하나 이상 선택해주세요.", 'warning'); return redirect(url_for('user.control_panel'))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]: flash("수행할 명령(켜기/끄기)이 올바르게 지정되지 않았습니다.", 'warning'); return redirect(url_for('user.control_panel'))

    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]
    
    conn = None; target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids:
                placeholders = ', '.join(['%s'] * len(selected_pc_ids))
                sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"
                cursor.execute(sql_select_pcs, tuple(selected_pc_ids))
                target_pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True); flash("명령 대상 PC 정보를 DB에서 조회 중 오류.", "error"); return redirect(url_for('user.control_panel'))
    if not target_pcs_to_control: flash("선택된 PC 정보를 찾을 수 없습니다.", "warning"); return redirect(url_for('user.control_panel'))

    for pc_data in target_pcs_to_control:
        pc_name_log = pc_data['pc_name']
        is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        first_hop_ip = pc_data['address1']
        final_dest_ip = pc_data['address2'] if is_relay else None
        
        log_msg_prefix = f"PC '{pc_name_log}' ({first_hop_ip}{f' -> {final_dest_ip}' if is_relay else ''})"

        # 1. SetDisplayTimeout 명령 (항상 실행)
        timeout_minutes_for_command = 0 if command_action_str == "켜기" else 1
        action_desc_timeout = "디스플레이 항상 켜기(타임아웃 0분)" if command_action_str == "켜기" else "디스플레이 1분 후 자동 꺼짐"
        payload_timeout = {'TimeoutMinutes': timeout_minutes_for_command}
        
        packet_set_timeout = {
            'PacketId': str(uuid.uuid4()), 'TimestampUtc': datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': "SET_DISPLAY_TIMEOUT", 'PayloadJson': json.dumps(payload_timeout),
            'ResponseAddress': None, 'ResponsePort': None,
            'Instruction': "RelayToTarget" if is_relay else "DirectExecute",
            'FinalTargetIpForRelayedCommand': final_dest_ip,
            'FinalTargetPortForRelayedCommand': 4026 if is_relay else None
        }
        
        flash(f"{log_msg_prefix}에 '{action_desc_timeout}' 명령 전송 시도...", 'info')
        current_app.logger.info(f"{log_msg_prefix} - 명령 전송: {action_desc_timeout}, PktID: {packet_set_timeout['PacketId']}")
        agent_response_timeout = send_command_to_agent(first_hop_ip, packet_set_timeout)
        _process_agent_response(agent_response_timeout, log_msg_prefix, "타임아웃 설정")


        # 2. "켜기" 명령일 때만 추가로 MonitorControl (On) 명령 전송
        if command_action_str == "켜기":
            action_desc_monitor_on = "모니터 즉시 켜기"
            # MonitorAction.On에 해당하는 값은 -1 (SControl.Common.MonitorAction 참조)
            payload_monitor_on = {'Action': -1} # 또는 "On" 문자열 등 SAgentM.App과 약속된 값 사용 가능
                                               # 현재 SAgentM.App은 int 값을 기대합니다.
            
            packet_monitor_on = {
                'PacketId': str(uuid.uuid4()), 'TimestampUtc': datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
                'CommandName': "MONITOR_CONTROL", 'PayloadJson': json.dumps(payload_monitor_on),
                'ResponseAddress': None, 'ResponsePort': None,
                'Instruction': "RelayToTarget" if is_relay else "DirectExecute",
                'FinalTargetIpForRelayedCommand': final_dest_ip,
                'FinalTargetPortForRelayedCommand': 4026 if is_relay else None
            }

            flash(f"{log_msg_prefix}에 '{action_desc_monitor_on}' 명령 추가 전송 시도...", 'info')
            current_app.logger.info(f"{log_msg_prefix} - 명령 전송: {action_desc_monitor_on}, PktID: {packet_monitor_on['PacketId']}")
            agent_response_monitor_on = send_command_to_agent(first_hop_ip, packet_monitor_on)
            _process_agent_response(agent_response_monitor_on, log_msg_prefix, "즉시 모니터 켜기")

    return redirect(url_for('user.control_panel'))


def _process_agent_response(agent_response, log_prefix, command_description):
    """에이전트 응답을 처리하고 flash 메시지와 로그를 남기는 헬퍼 함수"""
    if agent_response.get('success'):
        raw_resp_packet = agent_response.get('raw_response')
        if raw_resp_packet and isinstance(raw_resp_packet, dict) and 'PayloadJson' in raw_resp_packet:
            payload_json_str = raw_resp_packet.get('PayloadJson')
            current_app.logger.info(f"{log_prefix} - '{command_description}' 응답 PayloadJson: >>>{payload_json_str}<<<")
            if payload_json_str is not None:
                try:
                    resp_payload = json.loads(payload_json_str)
                    if resp_payload.get('Success'):
                        flash(f"{log_prefix} ({command_description}): 성공 - {resp_payload.get('Message', 'OK')}", 'success')
                        current_app.logger.info(f"{log_prefix} ({command_description}) - 성공: {resp_payload.get('Message')}")
                    else:
                        flash(f"{log_prefix} ({command_description}): 실패 (에이전트) - {resp_payload.get('Message', 'Agent error')}", 'error')
                        current_app.logger.error(f"{log_prefix} ({command_description}) - 에이전트 실패: {resp_payload.get('Message')}")
                except json.JSONDecodeError as je:
                    flash(f"{log_prefix} ({command_description}): 응답 페이로드 JSON 형식 오류 - {je.msg}", 'error')
                    current_app.logger.error(f"{log_prefix} ({command_description}) - PayloadJson 파싱 오류: {je.msg}. 원본: {payload_json_str}", exc_info=True)
                except Exception as e:
                    flash(f"{log_prefix} ({command_description}): 응답 페이로드 처리 중 알 수 없는 오류 - {e}", 'error')
                    current_app.logger.error(f"{log_prefix} ({command_description}) - PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_json_str}", exc_info=True)
            else:
                flash(f"{log_prefix} ({command_description}): 전송 성공 (에이전트 페이로드 없음)", 'warning')
                current_app.logger.warning(f"{log_prefix} ({command_description}) - 전송 성공, 페이로드 없음. RawPkt: {raw_resp_packet}")
        else:
            flash(f"{log_prefix} ({command_description}): 전송 성공 (에이전트 상세 응답 확인 불가)", 'warning')
            current_app.logger.warning(f"{log_prefix} ({command_description}) - 전송 성공, 상세 응답/페이로드 없음. RawPkt: {raw_resp_packet}")
    else:
        flash(f"{log_prefix} ({command_description}): 전송 실패 - {agent_response.get('message', 'Unknown socket error')}", 'error')
        current_app.logger.error(f"{log_prefix} ({command_description}) - 전송 실패: {agent_response.get('message')}")

app/routes_user.py 주요 변경 사항:

send_batch_command 함수 수정:
command_action_str == "켜기"인 경우:
먼저 기존과 동일하게 SetDisplayTimeout 명령 (페이로드: {'TimeoutMinutes': 0})을 전송합니다.
그 다음, 추가적으로 MonitorControl 명령 (페이로드: {'Action': -1})을 전송하여 모니터를 즉시 켭니다. SControl.Common의 MonitorAction.On은 -1 값을 가집니다. (SAgentM.App의 AgentCoreService.cs는 이 Action 값을 정수로 기대합니다.)
command_action_str == "끄기"인 경우: 기존과 동일하게 SetDisplayTimeout 명령 (페이로드: {'TimeoutMinutes': 1})만 전송합니다. (즉시 끄기 명령은 보내지 않습니다.)
_process_agent_response 헬퍼 함수 추가:
send_command_to_agent로부터 받은 응답을 처리하고 flash 메시지를 표시하며 로깅하는 중복 코드를 이 함수로 분리했습니다.
각 명령(타임아웃 설정, 즉시 켜기)에 대한 응답을 개별적으로 처리하고 사용자에게 피드백을 줍니다.
SAgentM.App/Services/AgentCoreService.cs 변경 필요 없음 (중요):

이전 답변에서 SAgentM.App의 AgentCoreService.cs는 이미 CommandNames.MonitorControl (페이로드: MonitorControlPayload)과 CommandNames.SetDisplayTimeout (페이로드: SetDisplayTimeoutPayload) 두 가지 명령을 모두 처리하도록 구현되어 있습니다. 따라서 SAgentM.App의 코드는 변경할 필요가 없습니다. Flask 웹 앱에서 보내는 명령의 종류와 페이로드만 정확히 맞춰주면 됩니다.

테스트 방법:

위 수정된 app/routes_user.py 코드를 Flask 프로젝트에 적용합니다.
SAgentM.App.exe (WPF 에이전트)를 관리자 권한으로 Windows PC에서 실행합니다.
Flask 개발 서버를 재시작합니다.
웹 UI의 "원격 제어판"에서 PC를 선택하고 "선택 PC 일괄 켜기" 버튼을 클릭합니다.
결과 확인:
Flask UI의 알림 메시지를 통해 두 가지 명령(타임아웃 해제, 모니터 즉시 켜기)에 대한 각각의 성공/실패 여부를 확인합니다.
Flask 개발 서버 터미널 로그를 확인합니다.
SAgentM.App의 UI 로그를 통해 두 명령이 모두 수신되고 처리되었는지 확인합니다.
대상 PC의 Windows 전원 옵션에서 "디스플레이 끄기" 시간이 "해당 없음(Never)"으로 변경되었는지, 그리고 모니터가 실제로 즉시 켜졌는지 확인합니다.
이렇게 하면 "켜기" 버튼이 디스플레이 타임아웃 설정 변경과 함께 즉시 모니터를 깨우는 동작을 수행하게 됩니다.


소스

야 누락된걸주면어덕해 routes_admin.py 이거전체껄로 다시줘 최종
