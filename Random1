정말 죄송합니다. **시퀀스 플래그(SequenceFlag)**는 파일이 PO_NO의 시작, 중간, 끝인지에 따라 달라지는 것으로 이해했습니다. 이제 그 부분을 반영해서 수정된 전체 코드를 제공하겠습니다.

시퀀스 플래그는 다음과 같이 처리될 것입니다:
1: PO_NO의 첫 파일.
2: 중간 파일.
3: PO_NO의 마지막 파일(생산 완료 시점).
PO_NO의 전체 생산 수량과 파일에서 처리된 수량을 고려하여, 파일이 시작인지 중간인지 끝인지 판별합니다.

수정된 FileProcessor.cs
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;

/// <summary>
/// FileProcessor는 지정된 폴더에서 로그 파일을 감지하고, 새로운 파일이 있을 때 LogEntry로 변환하여 처리합니다.
/// 날짜 정보를 추출하여 파일을 정렬하고, 새로 추가된 파일만 처리합니다.
/// 시퀀스 플래그는 해당 파일이 PO_NO의 시작, 중간 또는 끝 파일인지 판별합니다.
/// </summary>
public class FileProcessor
{
    private readonly string _logDirectory; // 로그 파일 경로
    private Action<LogEntry> _onFileDetected; // 파일이 감지되었을 때 호출될 콜백
    private DateTime _lastProcessedFileDateTime = DateTime.MinValue; // 마지막으로 처리된 파일의 시간
    private const int PO_PLAN_QTY = 400; // 예시로 PO 계획 수량을 400으로 가정

    public FileProcessor(string logDirectory, Action<LogEntry> onFileDetected)
    {
        _logDirectory = logDirectory;
        _onFileDetected = onFileDetected;
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 새로운 파일이 있으면 날짜 순으로 정렬 후 처리합니다.
    /// </summary>
    public async void StartProcessing()
    {
        while (true)
        {
            // 지정된 디렉토리에서 모든 파일을 가져옵니다.
            var files = Directory.GetFiles(_logDirectory, "*.txt");

            // 파일 이름에서 날짜를 추출하고 날짜 순으로 정렬합니다.
            var sortedFiles = files
                .Where(f => TryExtractDateTimeFromFileName(f, out _))
                .OrderBy(f => ExtractDateTimeFromFileName(f))
                .ToList();

            // 새로운 파일이 있는지 확인하고 처리
            foreach (var file in sortedFiles)
            {
                DateTime fileDateTime = ExtractDateTimeFromFileName(file);

                // 새로 추가된 파일만 처리 (마지막으로 처리된 파일 이후의 파일)
                if (fileDateTime > _lastProcessedFileDateTime)
                {
                    var logEntry = ParseLogFile(file);

                    // 파일이 PO_NO의 첫 번째, 중간 또는 마지막 파일인지 결정하는 시퀀스 플래그 설정
                    logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

                    _onFileDetected?.Invoke(logEntry); // 새로운 로그 엔트리를 콜백에 전달
                    _lastProcessedFileDateTime = fileDateTime; // 마지막 처리 시간 업데이트
                }
            }

            await Task.Delay(5000); // 5초마다 폴더를 확인
        }
    }

    /// <summary>
    /// PO_NO에 따라 시퀀스 플래그를 설정합니다.
    /// 1: 첫 파일, 2: 중간 파일, 3: 마지막 파일.
    /// </summary>
    private int DetermineSequenceFlag(LogEntry logEntry)
    {
        if (logEntry.PO_PROD_QTY == logEntry.MAG_QTY)
        {
            // 생산된 수량이 파일 내의 물류 수량과 같으면 첫 파일로 간주
            return 1;
        }
        else if (logEntry.PO_PROD_QTY + logEntry.MAG_QTY == PO_PLAN_QTY)
        {
            // 생산된 수량 + 현재 파일의 물류 수량이 계획 수량과 같으면 마지막 파일로 간주
            return 3;
        }
        else
        {
            // 나머지는 중간 파일로 간주
            return 2;
        }
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출하여 DateTime으로 변환합니다.
    /// 파일명 형식은 "W_test_yyyyMMddHHmmss.txt" 형식으로 가정합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName); // 확장자를 제외한 파일 이름만 가져옴
        var dateTimePart = baseFileName.Split('_')[1]; // 파일명에서 날짜 부분 추출

        // "yyyyMMddHHmmss" 형식을 DateTime으로 변환
        DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out DateTime fileDateTime);
        return fileDateTime;
    }

    /// <summary>
    /// 파일 이름에서 날짜 정보를 추출할 수 있는지 확인합니다.
    /// </summary>
    private bool TryExtractDateTimeFromFileName(string fileName, out DateTime fileDateTime)
    {
        var baseFileName = Path.GetFileNameWithoutExtension(fileName);
        var dateTimePart = baseFileName.Split('_')[1];

        // 날짜 형식이 올바른지 검증
        return DateTime.TryParseExact(dateTimePart, "yyyyMMddHHmmss", null, System.Globalization.DateTimeStyles.None, out fileDateTime);
    }

    /// <summary>
    /// 로그 파일을 읽어서 LogEntry 객체로 변환합니다.
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);
        return new LogEntry
        {
            PO_NO = lines[0],
            MAG_NO = lines[1],
            BASIC_MODEL = lines[2],
            MODEL_CODE = lines[3],
            PO_PLAN_QTY = int.Parse(lines[4]),
            PO_PROD_QTY = int.Parse(lines[5]),
            MAG_QTY = int.Parse(lines[6]),
            // SequenceFlag는 파일 처리 후 결정
        };
    }
}
주요 수정 사항:
시퀀스 플래그:

DetermineSequenceFlag 메서드를 추가하여 PO_NO의 시작, 중간, 끝 파일을 구분합니다.
시퀀스 플래그는 다음과 같이 설정됩니다:
1: 첫 번째 파일 (생산 수량과 물류 수량이 같을 때).
2: 중간 파일.
3: 마지막 파일 (생산된 수량과 파일 내 물류 수량의 합이 계획 수량과 일치할 때).
PO_NO 생산 완료 여부:

**PO_PLAN_QTY**와 MAG_QTY, PO_PROD_QTY 값을 기반으로 생산 완료 여부를 판별합니다.
마지막 파일에서는 계획된 수량을 모두 생산했는지 확인합니다.
새로운 파일 감지 및 정렬:

이전에 처리된 마지막 파일 이후의 파일만 감지하여 처리합니다.
전체 파일 구조 설명:
파일 감지 및 시퀀스 처리:
지정된 폴더에서 로그 파일을 감지하고, 날짜 정보를 기준으로 정렬하여 새로운 파일만 처리합니다.
PO_NO와 MAG_NO를 기반으로 **시퀀스 플래그(1, 2, 3)**를 결정하여 작업 큐로 넘깁니다.
이제 이 코드를 기반으로 로그 파일이 PO_NO의 시작인지, 중간인지, 끝인지를 정확히 구분할 수 있습니다.

추가적인 요청