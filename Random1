비스 측에서 소켓 서버가 제대로 작동하지 않는 이유는 여러 가지가 있을 수 있습니다. CancellationToken의 사용으로 인해 문제가 발생할 가능성도 있지만, 그 외에도 다른 이유들이 있을 수 있습니다. 다음은 소켓 서버가 제대로 작동하지 않는 일반적인 원인과 이를 해결하기 위한 몇 가지 방법입니다.

1. CancellationToken의 사용
CancellationToken은 작업을 취소할 수 있도록 도와주는 도구입니다. 이를 올바르게 사용하지 않으면 예상치 못한 동작을 유발할 수 있습니다. 예를 들어, CancellationToken이 잘못 설정되었거나, 필요 이상으로 자주 체크되어 작업이 중단될 수 있습니다.

해결 방법
CancellationToken이 올바르게 설정되어 있는지 확인: cancellationToken.IsCancellationRequested를 적절히 확인하고 필요한 곳에서만 사용하세요. 또한, 토큰이 정말 취소되어야 할 때만 취소되도록 논리를 설정하세요.
2. 포트 충돌 또는 방화벽 문제
서버가 사용하는 포트가 다른 애플리케이션에서 이미 사용 중이거나, 방화벽이 해당 포트를 차단하고 있을 수 있습니다.

해결 방법
포트 변경: 다른 포트를 사용해보세요. 예를 들어, 포트를 9000에서 9001로 변경하는 식으로 수정할 수 있습니다.
방화벽 설정 확인: 해당 포트가 열려 있는지, 방화벽에서 차단하고 있는지 확인하고, 필요하면 방화벽 설정을 변경하세요.
3. 소켓 서버 코드 오류
코드 자체에 오류가 있을 수 있습니다. 예를 들어, TcpListener가 제대로 시작되지 않았거나, 클라이언트 연결을 처리하는 부분에서 문제가 발생할 수 있습니다.

해결 방법
소켓 서버 코드 디버깅: 소켓 서버 코드가 올바르게 작동하는지 디버깅합니다. 예를 들어, TcpListener.Start()가 제대로 호출되고 있는지, 클라이언트 연결 수락 및 데이터 수신 코드가 올바르게 작성되어 있는지 확인합니다.
수정된 LogService.cs 예제
아래는 수정된 LogService.cs 예제로, CancellationToken을 올바르게 사용하고, 소켓 서버 코드에서 발생할 수 있는 잠재적인 문제를 해결하기 위한 조치를 포함합니다.

csharp
코드 복사
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        private static LogService _instance;
        private readonly string _logDirectory;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private TcpListener _tcpListener;
        private string _serverIp = "127.0.0.1"; // 메인 UI 서버 IP
        private int _serverPort = 9000; // 메인 UI 서버 포트
        private CancellationTokenSource _cancellationTokenSource;
        private bool _isConnected = false;
        private ComPortManager _comPortManager;

        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        private LogService()
        {
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory);

            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");
        }

        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ConnectToMainUIServer(_cancellationTokenSource.Token)); // 메인 UI 서버 연결을 시작
            Task.Run(() => StartTcpListener(_cancellationTokenSource.Token)); // TCP 서버 시작
        }

        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _networkStream?.Close();
            _tcpClient?.Close();
            _tcpListener?.Stop();
        }

        private async Task ConnectToMainUIServer(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                if (!_isConnected)
                {
                    try
                    {
                        _tcpClient = new TcpClient();
                        await _tcpClient.ConnectAsync(_serverIp, _serverPort); // 서버에 연결
                        _networkStream = _tcpClient.GetStream();
                        _isConnected = true;
                        Console.WriteLine("Connected to main UI server.");
                        
                        // 재연결 후 로그 큐에 저장된 메시지 전송
                        await SendQueuedLogs();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error connecting to server: {ex.Message}");
                        _isConnected = false;
                        await Task.Delay(5000); // 5초 후 재연결 시도
                    }
                }
                else
                {
                    await Task.Delay(1000); // 연결이 되어 있을 때 1초마다 상태 체크
                }
            }
        }

        private async Task StartTcpListener(CancellationToken cancellationToken)
        {
            try
            {
                _tcpListener = new TcpListener(IPAddress.Any, _serverPort);
                _tcpListener.Start();
                Console.WriteLine("TCP server started, listening for connections...");

                while (!cancellationToken.IsCancellationRequested)
                {
                    try
                    {
                        TcpClient client = await _tcpListener.AcceptTcpClientAsync();
                        Console.WriteLine("Client connected.");
                        _ = Task.Run(() => HandleClient(client, cancellationToken));
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error accepting client: {ex.Message}");
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error starting TCP server: {ex.Message}");
            }
            finally
            {
                _tcpListener?.Stop();
            }
        }

        private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)
        {
            using (client)
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;

                while (!cancellationToken.IsCancellationRequested && (bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) != 0)
                {
                    string message = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    _comPortManager.SendDataToPLC(message); // ComPortManager를 통해 메시지를 PLC로 전송
                }
            }
        }

        public async Task LogMessage(string message)
        {
            try
            {
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
                string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");

                File.AppendAllText(logFilePath, logEntry + Environment.NewLine);

                if (_isConnected && _tcpClient != null && _tcpClient.Connected)
                {
                    await SendLogMessage(logEntry); // 연결된 경우 바로 전송
                }
                else
                {
                    Console.WriteLine("Unable to send log message; not connected.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }

        private async Task SendLogMessage(string message)
        {
            try
            {
                if (_networkStream != null && _tcpClient != null && _tcpClient.Connected)
                {
                    byte[] data = Encoding.UTF8.GetBytes(message + "\n");
                    await _networkStream.WriteAsync(data, 0, data.Length);
                    Console.WriteLine("Log message sent to main UI server.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending log message: {ex.Message}");
                _isConnected = false;
            }
        }

        private async Task SendQueuedLogs()
        {
            while (_isConnected)
            {
                // 로그 큐에서 메시지를 가져와 전송
                // ...
            }
        }
    }
}
주요 변경 사항 및 추가 설명
TCP 서버 시작 오류 처리:

StartTcpListener 메서드에서 try-catch 블록을 사용하여 서버 시작 중 발생할 수 있는 예외를 처리합니다.
예외가 발생할 경우 서버를 중지하고 로그 메시지를 출력합니다.
CancellationToken 사용:

while 루프에서 cancellationToken.IsCancellationRequested를 확인하여 토큰이 취소된 경우 작업을 중단하도록 합니다.
각 비동기 작업 호출에서 cancellationToken을 전달하여, 취소 요청이 있을 때 작업이 안전하게 중지될 수 있도록 합니다.
클라이언트 연결 처리:

HandleClient 메서드에서 클라이언트와의 통신을 관리하고, 예외 발생 시 클라이언트를 안전하게 종료합니다.
추가 팁
디버깅: 코드에서 어디가 잘못되는지 확인하기 위해, 중요한 지점에 Console.WriteLine 또는 로그 메시지를 추가하여 디버깅하세요.
네트워크 문제 해결: 방화벽, 포트 사용, 네트워크 설정 등을 점검하여 네트워크 연결 문제가 없는지 확인하세요.
에러 로그 확인: 모든 예외를 로