네, 오류 내용을 자세히 알려주셔서 감사합니다! MainControlViewModel.cs에서 RaiseCanExecuteChanged와 async 람다 표현식 (=> await) 관련 오류가 발생하는 부분을 수정하겠습니다.

오류 원인 및 해결 방안:

RaiseCanExecuteChanged 오류:

SAgentM.App의 MainViewModel.cs 내에 RelayCommandExtensions로 RaiseCanExecuteChanged 확장 메서드를 정의했었습니다. 이 확장 메서드가 SControlM 프로젝트에 없거나, ICommand 타입으로 선언된 속성을 RelayCommand로 형변환하는 부분에서 문제가 생겼을 수 있습니다.
해결: async 명령을 더 잘 지원하는 AsyncRelayCommand 클래스를 새로 만들고, 이 클래스 내에 RaiseCanExecuteChanged 메서드를 포함시키겠습니다. 이렇게 하면 형변환이나 확장 메서드 누락 문제가 해결됩니다.
=> await (async 람다) 오류:

기존 RelayCommand는 Action<object>를 인자로 받아 async void 형태로 실행되므로, 명령 실행 완료를 기다리지 않고 IsBusy 플래그가 즉시 해제될 수 있는 문제가 있었습니다. 또한, async Task를 직접 지원하지 않아 사용에 불편함이 있었습니다.
해결: 새로 만들 AsyncRelayCommand는 Func<Task> 또는 Func<object, Task>를 인자로 받아 비동기 작업을 올바르게 지원하도록 설계합니다. 이 커맨드는 자체적으로 실행 중인 상태(_isExecuting)를 관리하여 CanExecute 상태를 정확하게 반영합니다.
수정 단계:

SControlM/Utils/ 폴더에 새로운 AsyncRelayCommand.cs 파일을 추가합니다.
SControlM/ViewModels/MainControlViewModel.cs에서 이 AsyncRelayCommand를 사용하도록 수정합니다.
1. SControlM/Utils/AsyncRelayCommand.cs 파일 추가

C#

// SControlM/Utils/AsyncRelayCommand.cs
using System;
using System.Threading.Tasks;
using System.Windows.Input;

namespace SControlM.Utils
{
    public class AsyncRelayCommand : ICommand
    {
        private readonly Func<object, Task> _executeAsync;
        private readonly Predicate<object> _canExecutePredicate;
        private bool _isExecuting;

        /// <summary>
        /// 파라미터가 없는 비동기 작업을 위한 생성자입니다.
        /// </summary>
        /// <param name="executeAsync">실행할 비동기 작업입니다.</param>
        /// <param name="canExecutePredicate">명령 실행 가능 여부를 결정하는 함수입니다.</param>
        public AsyncRelayCommand(Func<Task> executeAsync, Func<bool> canExecutePredicate = null)
            : this(async _ => await executeAsync(), // object 파라미터를 무시하고 Func<Task> 실행
                   canExecutePredicate == null ? (Predicate<object>)null : _ => canExecutePredicate()) // object 파라미터를 무시하고 Func<bool> 실행
        {
            // 이 생성자는 Func<object, Task> 및 Predicate<object>를 사용하는 주 생성자에 위임합니다.
        }

        /// <summary>
        /// 파라미터가 있는 비동기 작업을 위한 주 생성자입니다.
        /// </summary>
        /// <param name="executeAsync">실행할 비동기 작업 (object 파라미터 사용 가능).</param>
        /// <param name="canExecutePredicate">명령 실행 가능 여부를 결정하는 함수 (object 파라미터 사용 가능).</param>
        public AsyncRelayCommand(Func<object, Task> executeAsync, Predicate<object> canExecutePredicate = null)
        {
            _executeAsync = executeAsync ?? throw new ArgumentNullException(nameof(executeAsync));
            _canExecutePredicate = canExecutePredicate;
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public bool CanExecute(object parameter)
        {
            // 명령이 현재 실행 중이 아니어야 하고,
            // 외부에서 제공된 실행 조건(canExecutePredicate)도 만족해야 합니다.
            return !_isExecuting && (_canExecutePredicate == null || _canExecutePredicate(parameter));
        }

        public async void Execute(object parameter) // ICommand.Execute는 void 반환이므로 async void 사용
        {
            if (CanExecute(parameter)) // 실행 전 한 번 더 확인
            {
                _isExecuting = true;
                RaiseCanExecuteChanged(); // 명령이 바빠졌음을 알려 UI 갱신 (예: 버튼 비활성화)

                try
                {
                    await _executeAsync(parameter); // 실제 비동기 작업 실행
                }
                finally
                {
                    _isExecuting = false;
                    RaiseCanExecuteChanged(); // 명령이 완료되었음을 알려 UI 갱신 (예: 버튼 활성화)
                }
            }
        }

        /// <summary>
        /// CanExecute 상태가 변경되었음을 명시적으로 알립니다.
        /// ViewModel의 다른 속성 변경으로 인해 명령의 실행 가능 상태가 바뀔 때 호출될 수 있습니다.
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
AsyncRelayCommand.cs 설명:

Func<Task> (파라미터 없는 비동기 메서드용)와 Func<object, Task> (파라미터 있는 비동기 메서드용) 생성자를 모두 제공하여 사용 편의성을 높였습니다.
_isExecuting 플래그를 통해 명령 자체가 실행 중인지 여부를 관리합니다.
CanExecute 메서드는 _isExecuting 상태와 ViewModel에서 전달된 _canExecutePredicate 조건을 모두 확인합니다.
Execute 메서드는 async void로 선언되지만, 내부적으로 _executeAsync Task를 await합니다. 실행 전후로 _isExecuting 상태를 변경하고 RaiseCanExecuteChanged를 호출하여 UI가 올바르게 갱신되도록 합니다.
RaiseCanExecuteChanged 메서드가 클래스 내에 포함되어 있어 외부 확장 메서드가 필요 없습니다.
2. SControlM/ViewModels/MainControlViewModel.cs 수정

이전에 제공해 드린 MainControlViewModel.cs에서 다음 부분을 수정합니다.

C#

// SControlM/ViewModels/MainControlViewModel.cs
using Newtonsoft.Json;
using SControl.Common; 
using SControlM.Models; 
using SControlM.Services; 
using SControlM.Utils;    // ObservableObject, AsyncRelayCommand 사용
using System;
using System.Collections.ObjectModel;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Input; // ICommand 사용

namespace SControlM.ViewModels
{
    public class MainControlViewModel : ObservableObject
    {
        private readonly ILoggingService _loggingService;
        private readonly ICommandSendService _commandSendService;

        private AgentTarget _currentAgentTarget;
        public AgentTarget CurrentAgentTarget
        {
            get => _currentAgentTarget;
            set => SetProperty(ref _currentAgentTarget, value);
        }

        public ObservableCollection<LogEntry> LogEntries => _loggingService.LogEntries;

        private string _responseText;
        public string ResponseText
        {
            get => _responseText;
            set => SetProperty(ref _responseText, value);
        }

        private bool _isBusy; // ViewModel 전체의 작업 중 상태 (여러 커맨드에 영향)
        public bool IsBusy
        {
            get => _isBusy;
            set
            {
                if (SetProperty(ref _isBusy, value))
                {
                    // IsBusy 상태가 변경되면 모든 AsyncRelayCommand의 CanExecute 상태 갱신 요청
                    // 각 Command의 CanExecutePredicate가 이 IsBusy 값을 참조하므로,
                    // CommandManager.InvalidateRequerySuggested()를 통해 UI가 CanExecute를 다시 확인하게 함.
                    // AsyncRelayCommand 내부의 RaiseCanExecuteChanged()를 직접 호출해도 동일한 효과.
                    (SendCommandMonitorOnCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendCommandMonitorOffCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendCommandMonitorStandbyCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                    (SendRelayMonitorOnCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
                }
            }
        }

        private readonly TimeSpan _commandTimeout = TimeSpan.FromSeconds(10);
        private CancellationTokenSource _cancellationTokenSource;

        // ICommand 타입으로 선언하고, 실제로는 AsyncRelayCommand 인스턴스를 할당합니다.
        public ICommand SendCommandMonitorOnCommand { get; }
        public ICommand SendCommandMonitorOffCommand { get; }
        public ICommand SendCommandMonitorStandbyCommand { get; }
        public ICommand SendRelayMonitorOnCommand { get; }

        public MainControlViewModel(ILoggingService loggingService, ICommandSendService commandSendService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            _commandSendService = commandSendService ?? throw new ArgumentNullException(nameof(commandSendService));

            CurrentAgentTarget = new AgentTarget();

            // AsyncRelayCommand 생성 시, Func<Task> 와 Func<bool> (CanExecute 조건) 을 전달합니다.
            // CanExecuteCommands (또는 CanExecuteRelayCommands)가 ViewModel의 IsBusy를 참조합니다.
            SendCommandMonitorOnCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.On), 
                CanExecuteDirectCommands // CanExecute 조건 함수 전달
            );
            SendCommandMonitorOffCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.Off),
                CanExecuteDirectCommands
            );
            SendCommandMonitorStandbyCommand = new AsyncRelayCommand(
                async () => await ExecuteMonitorControlCommand(MonitorAction.Standby),
                CanExecuteDirectCommands
            );
            
            SendRelayMonitorOnCommand = new AsyncRelayCommand(
                async () => await ExecuteRelayMonitorControlCommand(MonitorAction.On),
                CanExecuteRelayCommands // 릴레이 명령을 위한 별도 CanExecute 조건 함수
            );

            _loggingService.Info("MainControlViewModel 초기화 완료 (AsyncRelayCommand 사용).");
        }

        // 직접 명령을 위한 CanExecute 조건 (ViewModel의 IsBusy 상태만 확인)
        private bool CanExecuteDirectCommands() => !IsBusy;

        // 릴레이 명령을 위한 CanExecute 조건 (IsBusy 및 릴레이 타겟 정보 유효성 확인)
        private bool CanExecuteRelayCommands()
        {
            return !IsBusy &&
                   !string.IsNullOrWhiteSpace(CurrentAgentTarget.RelayIpAddress) &&
                   CurrentAgentTarget.RelayPort.HasValue && CurrentAgentTarget.RelayPort > 0;
        }
        
        // ExecuteMonitorControlCommand 메서드는 변경 없음 (async Task 반환)
        private async Task ExecuteMonitorControlCommand(MonitorAction action)
        {
            // IsBusy 플래그는 SendCommandAsync 메서드 내부에서 관리하므로 여기서는 직접 설정하지 않아도 됨.
            // AsyncRelayCommand가 자체적으로 실행 중 상태를 관리합니다.
            // 다만, ViewModel의 IsBusy는 여전히 '글로벌' 작업 중 상태를 나타낼 수 있습니다.
            // 여기서는 SendCommandAsync가 IsBusy를 설정/해제하도록 둡니다.

            var payload = new MonitorControlPayload { Action = action };
            var commandPacket = new CommandPacket
            {
                Instruction = CommandInstruction.DirectExecute,
                CommandName = CommandNames.MonitorControl,
                PayloadJson = JsonConvert.SerializeObject(payload)
            };
            await SendCommandAsync(commandPacket, $"모니터 상태 '{action}' 직접 실행");
        }

        // ExecuteRelayMonitorControlCommand 메서드는 변경 없음 (async Task 반환)
        private async Task ExecuteRelayMonitorControlCommand(MonitorAction action)
        {
            // CanExecuteRelayCommands에서 이미 유효성 검사를 하지만, 여기서 한 번 더 방어적으로 검사할 수 있습니다.
            if (string.IsNullOrWhiteSpace(CurrentAgentTarget.RelayIpAddress) ||
                !CurrentAgentTarget.RelayPort.HasValue || CurrentAgentTarget.RelayPort <= 0)
            {
                _loggingService.Warn("릴레이 대상 IP 또는 포트가 유효하지 않습니다.");
                ResponseText = "릴레이 대상 IP 또는 포트를 올바르게 입력해주세요.";
                return; // CanExecute 조건에서 이미 걸러졌어야 함
            }

            var payload = new MonitorControlPayload { Action = action };
            var commandPacket = new CommandPacket
            {
                Instruction = CommandInstruction.RelayToTarget,
                CommandName = CommandNames.MonitorControl,
                PayloadJson = JsonConvert.SerializeObject(payload),
                FinalTargetIpForRelayedCommand = CurrentAgentTarget.RelayIpAddress,
                FinalTargetPortForRelayedCommand = CurrentAgentTarget.RelayPort
            };
            await SendCommandAsync(commandPacket, $"모니터 상태 '{action}' 릴레이 실행 -> {CurrentAgentTarget.RelayIpAddress}:{CurrentAgentTarget.RelayPort}");
        }

        // SendCommandAsync 메서드는 변경 없음 (IsBusy 플래그 관리 포함)
        private async Task SendCommandAsync(CommandPacket commandPacket, string logPrefix)
        {
            if (IsBusy && _cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested ) // 이미 다른 명령이 IsBusy를 설정한 경우
            {
                _loggingService.Warn("다른 명령이 이미 실행 중입니다.");
                // 원한다면 여기서 현재 실행 중인 작업을 취소하거나, 새 명령을 무시할 수 있습니다.
                // 여기서는 새 명령을 무시하지 않고, IsBusy 플래그를 공유하는 형태로 진행합니다.
                // AsyncRelayCommand는 각자 _isExecuting으로 개별 실행 상태를 관리합니다.
            }

            IsBusy = true; // ViewModel의 '글로벌' 작업 중 상태 시작
            ResponseText = string.Empty;
            
            // 이전 CancellationTokenSource가 있다면 취소하고 새로 만듭니다.
            _cancellationTokenSource?.Cancel();
            _cancellationTokenSource = new CancellationTokenSource();

            try
            {
                _loggingService.Sent($"{logPrefix} 명령 전송 시도 -> SAgentM: {CurrentAgentTarget.IpAddress}:{CurrentAgentTarget.Port}");
                _loggingService.Debug($"전송 패킷: {JsonConvert.SerializeObject(commandPacket, Formatting.Indented)}");

                CommandPacket response = await _commandSendService.SendCommandAsync(
                    CurrentAgentTarget, 
                    commandPacket, 
                    _commandTimeout, 
                    _cancellationTokenSource.Token); // 새로운 CancellationToken 전달

                if (response != null)
                {
                    _loggingService.Received($"응답 수신 (ID: {response.PacketId}): {response.CommandName}");
                    _loggingService.Debug($"수신 패킷: {JsonConvert.SerializeObject(response, Formatting.Indented)}");

                    if (!string.IsNullOrEmpty(response.PayloadJson))
                    {
                        var genericResponse = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson);
                        if (genericResponse != null)
                        {
                            ResponseText = $"성공: {genericResponse.Success}, 메시지: {genericResponse.Message}";
                            if (genericResponse.Success)
                                _loggingService.Info($"명령 성공: {genericResponse.Message}");
                            else
                                _loggingService.Warn($"명령 실패: {genericResponse.Message}");
                        }
                        else
                        {
                            ResponseText = "수신된 페이로드를 해석할 수 없습니다.";
                            _loggingService.Warn(ResponseText);
                        }
                    }
                    else
                    {
                        ResponseText = "응답 페이로드가 비어있습니다.";
                        _loggingService.Warn(ResponseText);
                    }
                }
                else
                {
                    ResponseText = "SAgentM으로부터 응답이 없습니다 (null).";
                    _loggingService.Error(ResponseText);
                }
            }
            catch (OperationCanceledException) // SendCommandAsync 또는 CommandSendService 내에서 발생
            {
                ResponseText = "명령 전송이 취소되었습니다.";
                _loggingService.Warn(ResponseText);
            }
            catch (ApplicationException appEx) 
            {
                ResponseText = $"오류: {appEx.Message}";
                _loggingService.Error(ResponseText, appEx.InnerException ?? appEx);
            }
            catch (Exception ex)
            {
                ResponseText = $"예기치 않은 오류 발생: {ex.Message}";
                _loggingService.Error(ResponseText, ex);
            }
            finally
            {
                IsBusy = false; // ViewModel의 '글로벌' 작업 중 상태 종료
                if(_cancellationTokenSource != null)
                {
                   _cancellationTokenSource.Dispose();
                   _cancellationTokenSource = null;
                }
            }
        }

        public void Cleanup()
        {
            _loggingService.Info("MainControlViewModel 정리 중...");
            if (_cancellationTokenSource != null && !_cancellationTokenSource.IsCancellationRequested)
            {
                _cancellationTokenSource.Cancel(); // 진행 중인 작업 취소 시도
            }
            // _cancellationTokenSource는 SendCommandAsync의 finally 블록에서 Dispose됨
        }
    }
}
MainControlViewModel.cs 수정 사항 요약:

RelayCommand 대신 새로 만든 AsyncRelayCommand를 사용하도록 변경했습니다.
AsyncRelayCommand 생성자에는 async () => await ... 형태의 람다와 CanExecute 조건을 위한 Func<bool> 람다를 전달합니다.
IsBusy 속성의 setter에서는 각 ICommand 속성을 AsyncRelayCommand로 형변환한 후 RaiseCanExecuteChanged()를 호출합니다. 이는 ViewModel의 IsBusy 상태가 변경될 때 각 커맨드의 실행 가능 상태(주로 CanExecuteDirectCommands 또는 CanExecuteRelayCommands Predicate를 통해)를 다시 평가하도록 하기 위함입니다.
CanExecuteDirectCommands와 CanExecuteRelayCommands 메서드를 분리하여 각 명령 그룹에 맞는 실행 조건을 명확히 했습니다. 이 메서드들은 AsyncRelayCommand의 canExecutePredicate로 전달됩니다.
SendCommandAsync 메서드에서 _cancellationTokenSource를 각 명령 호출 시 새로 생성하고, 이전 것이 있다면 취소하도록 수정하여 동시 실행 시의 문제를 방지하고 취소 가능성을 높였습니다.
이제 SControlM 프로젝트의 Utils 폴더에 AsyncRelayCommand.cs를 추가하고, ViewModels 폴더의 MainControlViewModel.cs를 위 코드로 교체한 후 다시 빌드해 보시면 오류가 해결될 것으로 기대합니다.