WPF에서 ObservableCollection의 특정 인덱스 값을 각각 TextBox에 바인딩하려면, ObservableCollection의 값을 변환하거나 중계하여 XAML에서 바인딩할 수 있도록 해야 합니다. 이를 위해, Converter 또는 Index별 속성을 제공하는 ViewModel을 사용할 수 있습니다.

방법: Index별 속성을 제공하는 ViewModel
MainViewModel 클래스
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;

public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<int> ForceEjectNumbers { get; set; }

    public MainViewModel()
    {
        // 초기 값 설정
        ForceEjectNumbers = new ObservableCollection<int> { 10, 20, 30 };

        // ForceEjectNumbers 변경 감지
        ForceEjectNumbers.CollectionChanged += (s, e) =>
        {
            // 값이 변경될 때 각 인덱스 속성을 업데이트
            OnPropertyChanged(nameof(ValueAtIndex0));
            OnPropertyChanged(nameof(ValueAtIndex1));
            OnPropertyChanged(nameof(ValueAtIndex2));
        };
    }

    public int ValueAtIndex0
    {
        get => ForceEjectNumbers.Count > 0 ? ForceEjectNumbers[0] : 0;
        set
        {
            if (ForceEjectNumbers.Count > 0 && ForceEjectNumbers[0] != value)
            {
                ForceEjectNumbers[0] = value;
                OnPropertyChanged(nameof(ValueAtIndex0));
            }
        }
    }

    public int ValueAtIndex1
    {
        get => ForceEjectNumbers.Count > 1 ? ForceEjectNumbers[1] : 0;
        set
        {
            if (ForceEjectNumbers.Count > 1 && ForceEjectNumbers[1] != value)
            {
                ForceEjectNumbers[1] = value;
                OnPropertyChanged(nameof(ValueAtIndex1));
            }
        }
    }

    public int ValueAtIndex2
    {
        get => ForceEjectNumbers.Count > 2 ? ForceEjectNumbers[2] : 0;
        set
        {
            if (ForceEjectNumbers.Count > 2 && ForceEjectNumbers[2] != value)
            {
                ForceEjectNumbers[2] = value;
                OnPropertyChanged(nameof(ValueAtIndex2));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
XAML
xml
코드 복사
<Window x:Class="ObservableExample.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="200" Width="300">
    <Grid>
        <StackPanel>
            <!-- ForceEjectNumbers의 0번째 값 바인딩 -->
            <TextBox Text="{Binding ValueAtIndex0, UpdateSourceTrigger=PropertyChanged}" />

            <!-- ForceEjectNumbers의 1번째 값 바인딩 -->
            <TextBox Text="{Binding ValueAtIndex1, UpdateSourceTrigger=PropertyChanged}" />

            <!-- ForceEjectNumbers의 2번째 값 바인딩 -->
            <TextBox Text="{Binding ValueAtIndex2, UpdateSourceTrigger=PropertyChanged}" />
        </StackPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        DataContext = new MainViewModel(); // ViewModel 바인딩
    }
}
동작 설명
MainViewModel의 역할:

ForceEjectNumbers를 관리하며, 0, 1, 2번째 인덱스의 값을 각각 ValueAtIndex0, ValueAtIndex1, ValueAtIndex2로 제공.
각 속성 변경 시 OnPropertyChanged를 호출하여 UI에 업데이트.
XAML에서 바인딩:

ValueAtIndex0, ValueAtIndex1, ValueAtIndex2를 각각 TextBox의 Text 속성에 바인딩.
값이 변경되면 UI에 즉시 반영.
UI 동작:

TextBox에서 값을 수정하면, 해당 인덱스 값이 ForceEjectNumbers에 반영.
출력 예제
초기 값: TextBox 3개에 각각 10, 20, 30 표시.
TextBox에서 값을 수정하면 ForceEjectNumbers의 해당 값이 업데이트.
예를 들어:
