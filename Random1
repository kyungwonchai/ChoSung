bservableCollection에 UI 스레드 외부에서 직접 접근하면 스레드 오류가 발생할 수 있습니다. 이 문제를 해결하기 위해 Dispatcher를 사용하여 UI 스레드에서 컬렉션을 업데이트하도록 수정하겠습니다.

아래는 FileDistributor 클래스의 MoveFileToLaneAsync 메서드에서 UI 업데이트를 위한 Dispatcher를 적용한 코드입니다.

수정된 코드: FileDistributor.cs
Dispatcher.Invoke를 사용하여 resultFiles 컬렉션을 UI 스레드에서 업데이트하도록 변경했습니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Data.SqlClient;
using System.IO;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace ProFileProcessor
{
    public class FileDistributor
    {
        private const string DataDirectory = @"C:\proviewer\data";
        private readonly Action<string> _logResult;

        // Dispatcher를 생성자에서 받아서 UI 업데이트에 사용
        private readonly Dispatcher _dispatcher;

        public FileDistributor(Action<string> logResult, Dispatcher dispatcher)
        {
            _logResult = logResult;
            _dispatcher = dispatcher;
        }

        public async Task DistributeFilesAsync(ObservableCollection<FileResult> resultFiles)
        {
            var machineFolders = Directory.GetDirectories(DataDirectory, "Machine*");

            foreach (var machineFolder in machineFolders)
            {
                var stage1Folder = Path.Combine(machineFolder, "Stage1");
                if (Directory.Exists(stage1Folder))
                {
                    var proFiles = Directory.GetFiles(stage1Folder, "*.pro");

                    foreach (var filePath in proFiles)
                    {
                        var codeValue = ExtractCodeValue(filePath);
                        if (codeValue != null)
                        {
                            var targetLane = GetTargetLaneFromDatabase(codeValue, stage1Folder);
                            if (targetLane != null)
                            {
                                await MoveFileToLaneAsync(filePath, targetLane, codeValue, resultFiles);
                            }
                        }
                    }
                }
            }

            _logResult("All files have been processed.");
        }

        private string ExtractCodeValue(string filePath)
        {
            foreach (var line in File.ReadLines(filePath))
            {
                if (line.StartsWith("Code="))
                {
                    return line.Substring(5).Trim();
                }
            }
            return null;
        }

        private string GetTargetLaneFromDatabase(string code, string stage1Folder)
        {
            string connectionString = "Server=your_server_name;Database=your_database_name;User Id=your_user_id;Password=your_password;";
            string targetLane = null;

            using (SqlConnection connection = new SqlConnection(connectionString))
            {
                connection.Open();

                string query = "SELECT TOP 1 szmodelname FROM View_SPI_barcode WHERE szbarcode LIKE @code + '%'";

                using (SqlCommand command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@code", code);
                    var result = command.ExecuteScalar() as string;

                    if (!string.IsNullOrEmpty(result))
                    {
                        if (result.Contains("_TM_"))
                        {
                            targetLane = Path.Combine(stage1Folder, "Lane2");
                        }
                        else if (result.Contains("_BM_"))
                        {
                            targetLane = Path.Combine(stage1Folder, "Lane1");
                        }
                    }
                }
            }

            return targetLane;
        }

        private async Task MoveFileToLaneAsync(string filePath, string targetLane, string barcode, ObservableCollection<FileResult> resultFiles)
        {
            if (string.IsNullOrEmpty(targetLane))
            {
                _logResult($"No target lane found for file: {filePath}");
                return;
            }

            try
            {
                if (!Directory.Exists(targetLane))
                {
                    Directory.CreateDirectory(targetLane);
                }

                string fileName = Path.GetFileName(filePath);
                string targetPath = Path.Combine(targetLane, fileName);

                File.Move(filePath, targetPath);

                var fileResult = new FileResult
                {
                    FileName = fileName,
                    Barcode = barcode,
                    Lane = targetLane.Contains("Lane1") ? "Lane1" : "Lane2"
                };

                // UI 스레드에서 ObservableCollection에 추가
                _dispatcher.Invoke(() =>
                {
                    resultFiles.Add(fileResult);
                });

                _logResult($"File moved to {targetLane}: {fileName}");
            }
            catch (Exception ex)
            {
                _logResult($"Error moving file {filePath}: {ex.Message}");
            }
        }
    }
}
MainWindow.xaml.cs 변경 사항
FileDistributor 객체를 생성할 때 Dispatcher를 전달해야 합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows;

namespace ProFileProcessor
{
    public partial class MainWindow : Window
    {
        public ObservableCollection<FileResult> ResultFiles { get; set; }
        private FileDistributor _fileDistributor;

        public MainWindow()
        {
            InitializeComponent();
            ResultFiles = new ObservableCollection<FileResult>();
            ResultDataGrid.ItemsSource = ResultFiles;
            _fileDistributor = new FileDistributor(LogResult, Dispatcher); // Dispatcher 전달
        }

        private async void OnDistributeFilesButtonClick(object sender, RoutedEventArgs e)
        {
            ResultFiles.Clear();
            await Task.Run(() => _fileDistributor.DistributeFilesAsync(ResultFiles));
        }

        private void LogResult(string message)
        {
            Dispatcher.Invoke(() => Console.WriteLine(message));
        }
    }
}
요약: