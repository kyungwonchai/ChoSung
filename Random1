네, 알겠습니다. "새 글 작성" 시 TINYMCE_API_KEY 관련 에러가 발생하신다면, app.py 파일에서 edit_post.html 템플릿으로 해당 키 값을 전달하려는 로직이 아직 남아있기 때문일 가능성이 매우 큽니다. config.py에서 해당 키를 주석 처리했기 때문에, app.py에서 app.config['TINYMCE_API_KEY']를 읽으려고 하면 KeyError가 발생합니다.

이전에 안내해 드린 대로, TinyMCE를 셀프 호스팅 방식으로 변경했으므로 app.py에서 더 이상 TINYMCE_API_KEY를 render_template 함수에 전달할 필요가 없습니다.

아래는 이 부분이 확실하게 수정된 app.py 파일의 전체 코드입니다. 이 코드로 기존 app.py 파일을 완전히 대체해 주십시오.

flask_board/app.py (수정된 전체 코드)

Python

import os
from flask import (
    Flask, render_template, request, redirect, url_for, flash, session, jsonify, abort
)
from werkzeug.utils import secure_filename
from datetime import datetime, timezone, timedelta # timedelta 임포트 확인
import uuid
from functools import wraps

# 사용자 정의 모듈 임포트
from config import Config
from models import db, Post # models.py 로부터 db와 Post 클래스를 정확히 임포트

app = Flask(__name__)
app.config.from_object(Config)
db.init_app(app) # SQLAlchemy 초기화

# 이미지 업로드 폴더가 존재하는지 확인하고 없으면 생성
upload_folder_path = app.config['UPLOAD_FOLDER']
if not os.path.exists(upload_folder_path):
    try:
        os.makedirs(upload_folder_path)
        print(f"Created upload folder: {upload_folder_path}")
    except OSError as e:
        app.logger.error(f"Error creating upload folder {upload_folder_path}: {e}")

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config['ALLOWED_EXTENSIONS']

# --- 인증 관련 ---
def is_admin_logged_in():
    return session.get('is_admin_logged_in', False)

@app.context_processor
def inject_admin_status_and_now():
    return dict(is_admin=is_admin_logged_in(), now=datetime.now(timezone.utc))

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin_logged_in():
            flash('이 작업을 수행하려면 로그인이 필요합니다.', 'warning')
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    if is_admin_logged_in():
        return redirect(url_for('index'))
    if request.method == 'POST':
        password = request.form.get('password')
        if password == app.config['ADMIN_PASSWORD']:
            session['is_admin_logged_in'] = True
            session.permanent = True
            app.permanent_session_lifetime = timedelta(days=7)
            flash('로그인되었습니다.', 'success')
            next_url = request.args.get('next')
            return redirect(next_url or url_for('index'))
        else:
            flash('잘못된 비밀번호입니다.', 'danger')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('is_admin_logged_in', None)
    flash('로그아웃되었습니다.', 'info')
    return redirect(url_for('index'))

# --- 게시판 라우트 ---
@app.route('/')
def index():
    page = request.args.get('page', 1, type=int)
    posts_pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination)

@app.route('/post/<string:slug>')
def view_post(slug):
    post_instance = Post.query.filter_by(slug=slug).first_or_404()
    return render_template('view_post.html', post=post_instance)

@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')

        if not title or not content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            # API 키 전달 제거
            return render_template('edit_post.html', title=title, content=content, post=None)

        try:
            new_post_obj = Post(title=title, content=content)
            db.session.add(new_post_obj)
            db.session.commit()
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating post: {e}")
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            # API 키 전달 제거
            return render_template('edit_post.html', title=title, content=content, post=None)

    # GET 요청 시: API 키 전달 제거
    return render_template('edit_post.html', post=None)

@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()

    if request.method == 'POST':
        original_title = post_to_edit.title
        
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content')

        if not post_to_edit.title or not post_to_edit.content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            # API 키 전달 제거
            return render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content)

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title)
        
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit()
            flash('게시글이 성공적으로 수정되었습니다.', 'success')
            return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing post {slug}: {e}")
            flash(f'게시글 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
            # API 키 전달 제거
            return render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content)

    # GET 요청 시: API 키 전달 제거
    return render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content)

@app.route('/delete/<string:slug>', methods=['POST'])
@admin_required
def delete_post(slug):
    post_to_delete = Post.query.filter_by(slug=slug).first_or_404()
    try:
        db.session.delete(post_to_delete)
        db.session.commit()
        flash('게시글이 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting post {slug}: {e}")
        flash(f'게시글 삭제 중 오류가 발생했습니다: {str(e)}', 'danger')
    return redirect(url_for('index'))

@app.route('/upload_image', methods=['POST'])
@admin_required
def upload_image():
    if 'file' not in request.files:
        return jsonify({'error': {'message': 'No file part in the request'}}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': {'message': 'No file selected for uploading'}}), 400

    if file and allowed_file(file.filename):
        original_filename = secure_filename(file.filename)
        filename_prefix = str(uuid.uuid4())[:8]
        
        base, ext = os.path.splitext(original_filename)
        safe_base = re.sub(r'[^\w-]', '', base)[:50]
        
        filename = f"{filename_prefix}_{safe_base}{ext}"
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)
        
        counter = 1
        temp_filename_to_check = filename 
        while os.path.exists(os.path.join(app.config['UPLOAD_FOLDER'], temp_filename_to_check)):
            temp_filename_to_check = f"{filename_prefix}_{safe_base}_{counter}{ext}"
            counter += 1
        filename = temp_filename_to_check
        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)

        try:
            file.save(filepath)
            image_url = url_for('static', filename=f'uploads/{filename}', _external=True)
            return jsonify({'location': image_url})
        except Exception as e:
            app.logger.error(f"Image upload failed: {e}")
            return jsonify({'error': {'message': f'Image upload failed: {str(e)}'}}), 500
    else:
        return jsonify({'error': {'message': f'Allowed file types are {app.config["ALLOWED_EXTENSIONS"]}'}}), 400

# --- 데이터베이스 초기화 CLI 명령어 ---
@app.cli.command('init-db')
def init_db_cli_command():
    """Clear existing data and create new tables."""
    with app.app_context():
        db.drop_all()
        db.create_all()
    print('Initialized the database.')

# --- 앱 실행 전 테이블 생성 (개발 편의용) ---
_db_initialized_flag = False

@app.before_request
def ensure_tables_exist():
    global _db_initialized_flag
    if not _db_initialized_flag:
        with app.app_context():
            db.create_all()
            print("Database tables checked/created via before_request.")
        _db_initialized_flag = True

if __name__ == '__main__':
    with app.app_context():
        db.create_all()
        print("Database tables checked/created via __main__.")
    app.run(debug=True, host='0.0.0.0', port=5000)
핵심 변경 사항 (이전 답변에서 이미 안내되었으나, 다시 한번 확인):

new_post 함수:
GET 요청 시 render_template('edit_post.html', post=None): tinymce_api_key 전달 부분 삭제.
POST 요청에서 유효성 검사 실패 시 render_template('edit_post.html', title=title, content=content, post=None): tinymce_api_key 전달 부분 삭제.
POST 요청에서 데이터베이스 저장 실패 시 render_template('edit_post.html', title=title, content=content, post=None): tinymce_api_key 전달 부분 삭제.
edit_post 함수:
GET 요청 시 render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content): tinymce_api_key 전달 부분 삭제.
POST 요청에서 유효성 검사 실패 시 render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content): tinymce_api_key 전달 부분 삭제.
POST 요청에서 데이터베이스 저장 실패 시 render_template('edit_post.html', post=post_to_edit, title=post_to_edit.title, content=post_to_edit.content): tinymce_api_key 전달 부분 삭제.