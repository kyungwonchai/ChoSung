# Python MDB 파일 뷰어 및 부품 코드 검색기
# 이 스크립트를 실행하기 전, 32비트 Python 환경에 pyodbc를 설치해야 합니다.
# 터미널/CMD: py32 -m pip install pyodbc (py32는 32비트 Python 실행 파일 예시)

import pyodbc
import os

def get_mdb_connection(mdb_file_path):
    """
    주어진 MDB 파일 경로에 대한 pyodbc 연결을 생성하고 반환합니다.
    32비트 Microsoft Access Database Engine이 설치되어 있어야 합니다.
    """
    if not os.path.exists(mdb_file_path):
        print(f"오류: 파일 경로를 찾을 수 없습니다 -> '{mdb_file_path}'")
        return None

    # 구형 MDB 파일(.mdb)을 위한 연결 문자열입니다.
    # 최신 .accdb 파일도 지원하는 드라이버입니다.
    # 이 드라이버가 없다는 오류가 발생하면, 32비트 버전의
    # 'Microsoft Access Database Engine 2010 Redistributable' 또는 2016 버전을 설치해야 합니다.
    connection_string = (
        r'DRIVER={Microsoft Access Driver (*.mdb, *.accdb)};'
        r'DBQ=' + mdb_file_path + r';'
    )
    
    try:
        conn = pyodbc.connect(connection_string)
        print(f"'{os.path.basename(mdb_file_path)}' 파일에 성공적으로 연결되었습니다.")
        return conn
    except pyodbc.Error as ex:
        sqlstate = ex.args[0]
        print(f"데이터베이스 연결 오류가 발생했습니다: {sqlstate}")
        print("스크립트를 32비트 Python 환경에서 실행하고 있는지,")
        print("그리고 32비트 Microsoft Access 드라이버가 설치되었는지 확인하세요.")
        return None

def list_all_tables_and_data(conn):
    """
    데이터베이스의 모든 테이블 이름과 각 테이블의 모든 데이터를 출력합니다.
    """
    if not conn:
        return
        
    try:
        cursor = conn.cursor()
        print("\n--- 모든 테이블 목록 ---")
        
        # 데이터베이스의 모든 'TABLE' 타입의 객체 이름을 가져옵니다.
        table_names = [table.table_name for table in cursor.tables(tableType='TABLE')]
        
        if not table_names:
            print("데이터베이스에서 테이블을 찾을 수 없습니다.")
            return

        for table_name in table_names:
            print(f"\n--- 테이블: [{table_name}] 의 데이터 ---")
            try:
                # 테이블 이름에 공백이 있을 수 있으므로 대괄호로 감쌉니다.
                cursor.execute(f"SELECT * FROM [{table_name}]")
                
                # 컬럼 이름 가져오기
                columns = [column[0] for column in cursor.description]
                print(" | ".join(columns))
                print("-" * (len(" | ".join(columns)) + 2))

                # 데이터 행 가져오기
                rows = cursor.fetchall()
                if not rows:
                    print("(데이터 없음)")
                else:
                    for row in rows:
                        # 각 행의 데이터를 문자열로 변환하여 출력
                        print(" | ".join([str(field) for field in row]))
            except pyodbc.Error as e:
                print(f"테이블 [{table_name}] 조회 중 오류 발생: {e}")

    except pyodbc.Error as e:
        print(f"데이터 조회 중 오류 발생: {e}")
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()

def search_part_code_globally(conn, part_code):
    """
    데이터베이스의 모든 테이블, 모든 컬럼에서 주어진 부품 코드를 검색합니다.
    'PartName' 컬럼을 우선적으로 검색하고, 관련된 모든 정보를 출력합니다.
    """
    if not conn:
        return
        
    print(f"\n--- '{part_code}' 부품 코드 전체 검색 결과 ---")
    
    try:
        cursor = conn.cursor()
        table_names = [table.table_name for table in cursor.tables(tableType='TABLE')]
        
        found_results = False
        
        for table_name in table_names:
            try:
                # 1. 테이블의 컬럼 정보 가져오기
                cursor.execute(f"SELECT TOP 1 * FROM [{table_name}]")
                columns = [column[0] for column in cursor.description]
                
                # 2. 'PartName' 컬럼이 있는지 확인하고, 있다면 우선 검색
                part_name_column = next((col for col in columns if 'partname' in col.lower()), None)
                
                search_columns = []
                if part_name_column:
                    search_columns.append(part_name_column)
                # 그 외 모든 텍스트 기반 컬럼도 검색 대상에 포함
                # (여기서는 단순화를 위해 모든 컬럼을 대상으로 함)
                search_columns.extend([col for col in columns if col not in search_columns])

                # 3. 각 검색 대상 컬럼에 대해 쿼리 실행
                for col in search_columns:
                    try:
                        # SQL Injection을 방지하기 위해 파라미터화된 쿼리 사용
                        query = f"SELECT * FROM [{table_name}] WHERE [{col}] = ?"
                        cursor.execute(query, part_code)
                        rows = cursor.fetchall()
                        
                        if rows:
                            found_results = True
                            print(f"\n>>> 테이블 [{table_name}], 컬럼 [{col}] 에서 결과 발견:")
                            
                            # 컬럼 이름 출력
                            header = [c[0] for c in cursor.description]
                            print(" | ".join(header))
                            print("-" * (len(" | ".join(header)) + 2))
                            
                            # 결과 데이터 출력
                            for row in rows:
                                print(" | ".join([str(field) for field in row]))

                    except pyodbc.Error:
                        # 데이터 타입이 맞지 않는 경우 등 오류가 발생할 수 있으므로 무시하고 계속 진행
                        continue
            except pyodbc.Error as e:
                print(f"테이블 [{table_name}] 검색 중 오류 발생: {e}")

        if not found_results:
            print("해당 부품 코드를 찾을 수 없습니다.")
            
    except pyodbc.Error as e:
        print(f"부품 코드 검색 중 오류 발생: {e}")
    finally:
        if 'cursor' in locals() and cursor:
            cursor.close()


# --- 메인 실행 부분 ---
if __name__ == "__main__":
    # 여기에 MDB 파일의 전체 경로를 입력하세요.
    # 예: r"C:\Users\YourUser\Documents\database.mdb"
    # r""'는 경로 문자열의 백슬래시를 이스케이프 처리하지 않도록 합니다.
    mdb_path = r"C:\path\to\your\database.mdb"

    connection = get_mdb_connection(mdb_path)

    if connection:
        # 1. 모든 테이블과 내용 출력하기
        list_all_tables_and_data(connection)
        
        # 2. 특정 부품 코드(11자리)로 관련 정보 모두 검색하기
        # 아래에 검색하고 싶은 부품 코드를 입력하세요.
        part_code_to_search = "12345678901" # 예시 부품 코드
        search_part_code_globally(connection, part_code_to_search)
        
        # 연결 종료
        connection.close()
        print("\n데이터베이스 연결을 닫았습니다.")

