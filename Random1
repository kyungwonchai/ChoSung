, 당연히 가능합니다. 그 방법이 주변을 실제로 밝히는, 훨씬 사실적인 조명 효과를 만듭니다.

작업은 1) 프리팹에 조명 부품을 미리 추가하고, 2) 스크립트가 재질 대신 조명 자체를 켜고 끄도록 수정하는 두 단계로 나뉩니다.

## 1단계: 프리팹(Prefab) 수정 (조명 부품 추가)
먼저 모든 램프 모델에 실제 Light 컴포넌트를 달아줍니다.

Project 창에서 Rack_Template 프리팹을 더블클릭하여 프리팹 편집 모드로 들어갑니다.

Hierarchy 창에서 프리팹 안의 모든 Lamp_... 오브젝트를 전부 선택합니다.

Inspector 창에서 Add Component 버튼을 누르고 **Light**를 검색하여 추가합니다.

추가된 Light 컴포넌트의 설정을 아래와 같이 변경합니다.

Type: Point (전구처럼 사방으로 퍼지는 빛)

Range: 빛이 도달할 거리 (예: 1 또는 2)

Color: 원하는 램프 색 (예: 연한 노란색)

Intensity: 빛의 세기 (예: 5 또는 10 정도로 시작)

가장 중요: 설정이 끝났으면, Light 컴포넌트 이름 옆의 체크박스를 클릭하여 비활성화합니다. 모든 램프가 꺼진 상태로 시작해야 합니다.

프리팹 편집 모드를 빠져나옵니다.

## 2단계: 스크립트 수정 (RackSystemManager.cs)
이제 스크립트가 머티리얼을 교체하는 대신, 방금 추가한 Light 컴포넌트를 직접 켜고 끄도록 수정합니다.

Scripts 폴더의 RackSystemManager.cs 파일 내용을 아래 코드로 완전히 덮어쓰고 저장하세요.

C#

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

public class RackSystemManager : MonoBehaviour
{
    [Header("핵심 연결 대상")]
    public Transform rackContainer;

    // ★★★ 머티리얼 변수들이 더 이상 필요 없으므로 삭제되었습니다 ★★★

    [Header("애니메이션")]
    public float animationDuration = 0.5f;
    public float slideOutDistance = 0.4f;

    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    // ★★★ 램프의 Renderer 대신 Light 컴포넌트를 저장하도록 변경 ★★★
    private Dictionary<string, Light> lampLights = new Dictionary<string, Light>();
    
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    // ★★★ 마지막으로 켜진 Light를 기억하도록 변수 타입 변경 ★★★
    private Light lastActiveLight;
    private Vector3 lastMaskOriginalLocalPosition;
    private string currentActiveBarcode = "";

    void Start()
    {
        InitializeAllRacks();
    }

    void InitializeAllRacks()
    {
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name;
            
            // ★★★ 이제 Light 컴포넌트를 직접 찾습니다 ★★★
            Light[] childLights = rackParent.GetComponentsInChildren<Light>(true);
            foreach(Light light in childLights)
            {
                string localName = light.gameObject.name; // Light가 붙어있는 게임오브젝트의 이름
                if (localName.StartsWith("Lamp_"))
                {
                    string globalKey = $"{rackName}_{localName}";
                    if (!lampLights.ContainsKey(globalKey))
                    {
                        lampLights.Add(globalKey, light);
                        light.enabled = false; // 모든 램프를 꺼진 상태로 초기화
                    }
                }
            }

            // 마스크는 기존과 동일하게 찾습니다.
            MaskIdentifier[] childMasks = rackParent.GetComponentsInChildren<MaskIdentifier>(true);
            foreach(MaskIdentifier mask in childMasks)
            {
                 string localName = mask.gameObject.name;
                 string globalKey = $"{rackName}_{localName}";
                 if (!maskObjects.ContainsKey(globalKey))
                    maskObjects.Add(globalKey, mask.gameObject);
            }
        }
        Debug.Log($"초기화 완료: {lampLights.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    public void ProcessBarcode(string barcode)
    {
        if (barcode == currentActiveBarcode) return;
        ResetPreviousSlot();
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10")) return;

        string rackID = barcode.Substring(5, 3);
        string floor = barcode.Substring(8, 1);
        string slotNum = barcode.Substring(9, 2);
        
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}";
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}";
        
        // ★★★ 머티리얼 교체 대신 Light 컴포넌트를 활성화(enabled = true)하여 켭니다 ★★★
        if (lampLights.TryGetValue(lampKey, out Light targetLight))
        {
            targetLight.enabled = true;
            lastActiveLight = targetLight;
        }

        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
        currentActiveBarcode = barcode;
    }
    
    #region Helper Functions 
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        
        // ★★★ 머티리얼 복구 대신 Light 컴포넌트를 비활성화(enabled = false)하여 끕니다 ★★★
        if (lastActiveLight != null)
        {
            lastActiveLight.enabled = false;
            lastActiveLight = null;
        }

        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
        currentActiveBarcode = "";
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;
        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }
        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;
        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
    #endregion
}

// 이 식별용 스크립트들은 그대로 유지합니다.
public class MaskIdentifier : MonoBehaviour { }