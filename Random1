네, 알겠습니다. 상황을 정확히 이해했습니다. 수정 작업 시에는 로그가 정상적으로 기록되는데, 추가 작업 시에만 로그가 기록되지 않는 문제군요. 디버그 출력 상으로는 저장이 완료된 것처럼 보이지만 실제 로그 테이블에는 Added 로그가 누락되는 현상입니다.

이 문제는 로그 기록 로직의 핵심인 Infrastructure/AuditLogInterceptor.cs 파일 내, 특히 Added 상태의 엔티티를 처리하는 부분(GenerateAuditLogs 메서드) 또는 생성된 로그를 최종 저장하는 부분(SaveAuditLogs 메서드)에 문제가 있을 가능성이 높습니다.

진단 및 해결 방향:

GenerateAuditLogs 메서드에서 Added 상태의 엔티티를 감지했을 때, 로그 객체(AuditLog)가 정상적으로 생성되고 임시 목록(auditEntries)에 추가되는지 상세히 추적합니다.
SaveAuditLogs 메서드가 호출될 때, GenerateAuditLogs에서 생성된 로그 목록(auditEntries)이 interceptionContext.UserState를 통해 제대로 전달되는지 확인합니다.
로그 저장(logContext.SaveChanges()) 호출 전후의 상태를 확인합니다.
수정해야 할 파일 목록:

Infrastructure/AuditLogInterceptor.cs
아래는 위 진단 방향에 따라 디버그 출력을 추가하여 수정한 AuditLogInterceptor.cs 파일 전체 코드(주석 제외)입니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects;

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}";

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { GenerateAuditLogs(interceptionContext); }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext) { SaveAuditLogs(interceptionContext); }
        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }

        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            foreach (var context in interceptionContext.DbContexts)
            {
                if (!(context is LockerDbContext dbContext) || !dbContext.ChangeTracker.HasChanges()) continue;

                bool isMaster = dbContext.IsMasterSave;
                string currentPrincipalName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name;
                string userNameForLog = $"{(isMaster ? "[마스터]" : "[일반]")}{currentPrincipalName ?? "UnknownUser"}";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList();

                if (!changedEntries.Any()) continue;
                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.GenerateAuditLogs: Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨 (isMaster={isMaster}).");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = userNameForLog, TableName = GetTableName(entry), Action = entry.State.ToString() };
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();

                    if (entry.State == EntityState.Added)
                    {
                        Debug.WriteLine($"    - Added 상태 감지됨: {auditEntry.TableName}");
                        foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn];
                        try
                        {
                             auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings);
                             Debug.WriteLine($"    - Added 로그 NewValues 직렬화 성공.");
                        }
                        catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; }
                    }
                    else if (entry.State == EntityState.Deleted) { Debug.WriteLine($"    - Deleted 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } Debug.WriteLine($"    - Deleted 로그 데이터 생성 완료."); }
                    else if (entry.State == EntityState.Modified) { Debug.WriteLine($"    - Modified 상태 감지됨: {auditEntry.TableName}, ID: {auditEntry.RecordId}"); bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } Debug.WriteLine($"    - Modified 로그 데이터 생성 완료."); } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }

                    if (auditEntry != null)
                    {
                        auditEntries.Add(auditEntry);
                        Debug.WriteLine($"    - 로그 생성됨 (List 추가 완료): {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}, User: {auditEntry.UserName}");
                    } else { Debug.WriteLine($"    !!! 로그 객체 생성 실패? ({entry.Entity.GetType().Name})"); }
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any())
                {
                    string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode());
                    interceptionContext.UserState = auditEntries;
                    Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장.");
                }
                 dbContext.IsMasterSave = false;
            }
        }

        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            // *** 추가: UserState에서 로그 가져오는지 확인 ***
            List<AuditLog> auditEntries = interceptionContext.UserState as List<AuditLog>;
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges 시작. UserState에서 가져온 로그 수 = {auditEntries?.Count ?? 0}");

            if (interceptionContext.Exception == null && auditEntries != null && auditEntries.Any())
            {
                try
                {
                    using (var logContext = new Data.LockerDbContext())
                    {
                        Debug.WriteLine($"  -> {auditEntries.Count}개 로그 저장 시도 (새 Context 사용)...");
                        logContext.AuditLogs.AddRange(auditEntries);
                        int logResult = logContext.SaveChanges();
                        Debug.WriteLine($"  -> 로그 저장 완료. 결과 = {logResult}");
                    }
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"  -> 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"  -> 저장할 로그 없음."); }
            interceptionContext.UserState = null;
        }

        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) { try { var objectContext = ((IObjectContextAdapter)context).ObjectContext; var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity); if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0) { return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value)); } if (entry.State == EntityState.Added) return "New"; } catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); } return "N/A"; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }
    }
}
핵심 변경 사항:

GenerateAuditLogs 메서드:
if (entry.State == EntityState.Added) 블록 내부에 Debug.WriteLine을 추가하여, Added 상태 감지, 직렬화 성공, 리스트 추가 완료 시점을 명확히 출력합니다.
SaveAuditLogs 메서드:
메서드 시작 시 interceptionContext.UserState에서 가져온 로그 목록(auditEntries)의 개수를 출력하여, GenerateAuditLogs에서 생성된 로그가 제대로 전달되었는지 확인합니다.
로그 저장(logContext.SaveChanges()) 후 결과(영향받은 행 수)를 출력합니다.
다음 단계:

NuGet 패키지: Newtonsoft.Json 패키지가 설치되어 있는지 확인합니다.
코드 적용 및 빌드: 위 코드로 AuditLogInterceptor.cs 파일을 업데이트하고 솔루션을 다시 빌드합니다.
테스트 및 디버그 출력 확인:
메인 화면(사물함 관리) 에서 새로운 행을 추가하고 저장 버튼을 클릭합니다.
Visual Studio의 출력(Output) 창을 주의 깊게 확인합니다.
GenerateAuditLogs 메서드 로그:
Added 상태 감지됨: LockerAssignment 메시지가 나타나나요?
Added 로그 NewValues 직렬화 성공. 메시지가 나타나나요? (만약 "직렬화 오류"가 뜨면 알려주세요.)
로그 생성됨 (List 추가 완료): LockerAssignment, Action: Added... 메시지가 나타나나요?
UserState에 저장. 메시지에 올바른 로그 개수(최소 1개)가 표시되나요?
SaveAuditLogs 메서드 로그:
SavedChanges 시작. UserState에서 가져온 로그 수 = ... 메시지에 올바른 로그 개수(최소 1개)가 표시되나요?
로그 저장 시도... 메시지가 나타나나요?
로그 저장 완료. 결과 = ... 메시지가 나타나고, 결과 숫자가 0보다 큰가요?