import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentLinkedQueue;

// ============================================================
// == 실행을 위한 메인 클래스
// ============================================================
/**
 * 이 클래스는 전체 수배자 추적 시스템의 동작을 시뮬레이션하는 시작점입니다.
 * 실제 애플리케이션에서는 스프링(Spring)과 같은 프레임워크가 담당하는
 * 객체 생성 및 의존성 주입(DI) 과정을 main 메서드 안에서 수동으로 보여줍니다.
 */
public class TrackingSystemRunner {

    public static void main(String[] args) {
        System.out.println("====== 수배자 추적 시스템 시뮬레이션 시작 ======");

        // --- 시나리오 1: 실시간 추적 요청 ---
        System.out.println("\n--- [시나리오 1] 실시간 추적 요청 처리 ---");
        
        /*
         * [코드 리뷰] DI 컨테이너 역할 시뮬레이션 (1)
         * 실제 서버 환경에서는 DI 컨테이너가 이 역할을 자동으로 수행합니다.
         * 여기서는 '실시간 추적'이라는 시나리오에 필요한 부품(객체)들을 수동으로 생성하고 조립합니다.
         * '실시간추적명령팩토리'를 생성하여 'TrackingOrchestrationService'에 "주입"하는 것이 핵심입니다.
         */
        I영상소스제공_App realTimeCctvGw = new CctvGateway();
        I비동기이벤트발행_App realTimeMqGw = new MqGateway();
        I명령팩토리 realTimeFactory = new 실시간추적명령팩토리(realTimeCctvGw, realTimeMqGw);
        커맨드실행기 realTimeInvoker = new 커맨드실행기();
        
        // '실시간용' 팩토리가 주입된 서비스 객체 생성
        I추적오케스트레이션 realTimeService = new TrackingOrchestrationService(realTimeFactory, realTimeInvoker);

        // 서비스 실행
        추적요청DTO realTimeRequest = new 추적요청DTO("S-001", "강남역 일대", "officerA");
        realTimeService.추적요청처리(realTimeRequest);

        System.out.println("\n--------------------------------------------");

        // --- 시나리오 2: 저장된 영상 배치 분석 요청 ---
        System.out.println("\n--- [시나리오 2] 저장된 영상 배치 분석 요청 처리 ---");
        
        /*
         * [코드 리뷰] DI 컨테이너 역할 시뮬레이션 (2)
         * 이번에는 '배치 분석' 시나리오에 필요한 부품들을 조립합니다.
         * 가장 중요한 점은, 'TrackingOrchestrationService' 코드는 전혀 변경되지 않았다는 것입니다.
         * 단지 주입되는 '팩토리'의 구현체만 '배치분석명령팩토리'로 바꿨을 뿐입니다.
         * 이처럼 내용물을 교체하여 서비스의 행동을 바꾸는 것이 Abstract Factory 패턴의 핵심 장점입니다.
         */
        I저장된영상소스_App batchStorageGw = new StorageGateway(); // CCTV 대신 스토리지 게이트웨이 사용
        I비동기이벤트발행_App batchMqGw = new MqGateway();
        I명령팩토리 batchFactory = new 배치분석명령팩토리(batchStorageGw, batchMqGw); // <-- 교체된 부분!
        커맨드실행기 batchInvoker = new 커맨드실행기();

        // '배치 분석용' 팩토리가 주입된 똑같은 서비스 객체 생성
        I추적오케스트레이션 batchService = new TrackingOrchestrationService(batchFactory, batchInvoker);

        // 서비스 실행 (메서드 호출 방식은 시나리오 1과 동일)
        추적요청DTO batchRequest = new 추적요청DTO("S-002", "/videos/archive-01.mp4", "officerB");
        batchService.추적요청처리(batchRequest);

        System.out.println("\n====== 시뮬레이션 종료 ======");
    }
}


// ============================================================
// == 공통 DTO (Data Transfer Objects)
// ============================================================
/**
 * [코드 리뷰] record 키워드
 * Java 17의 record는 데이터를 담는 용도의 클래스를 간편하게 만들기 위해 사용됩니다.
 * 아래처럼 한 줄만 써도 생성자, getter, equals(), toString() 등이 자동으로 만들어집니다.
 * 계층 간에 데이터를 전달할 때 주로 사용합니다.
 */
record 추적요청DTO(String suspectId, String area, String requestedBy) {}
class 분석데이터 {}


// ============================================================
// == Node 2: 추적 및 관리 서비스 노드 (App Server)
// ============================================================

// --- Service (Business Logic Layer) ---
interface I추적오케스트레이션 {
    CompletableFuture<String> 추적요청처리(추적요청DTO 요청);
}

/**
 * [코드 리뷰] Facade 패턴 + DI
 * 이 서비스는 '추적 요청 처리'라는 복잡한 과정을 외부에는 '추적요청처리()'라는 단순한 창구 하나만 노출합니다. (퍼사드 패턴)
 * 또한, 이 클래스는 'new' 키워드로 다른 객체를 직접 생성하지 않습니다.
 * 필요한 객체들(I명령팩토리, 커맨드실행기)을 생성자를 통해 외부에서 전달받습니다(의존성 주입, DI).
 * 이로 인해 서비스는 어떤 종류의 팩토리가 들어오는지 신경 쓸 필요 없이 자신의 핵심 로직에만 집중할 수 있습니다.
 */
class TrackingOrchestrationService implements I추적오케스트레이션 {
    private final I명령팩토리 _commandFactory; //어떤 종류의 명령을 만들지는 이 팩토리가 결정
    private final 커맨드실행기 _commandInvoker; //생성된 명령을 실행시키는 역할

    public TrackingOrchestrationService(I명령팩토리 commandFactory, 커맨드실행기 commandInvoker) {
        this._commandFactory = commandFactory;
        this._commandInvoker = commandInvoker;
    }

    @Override
    public CompletableFuture<String> 추적요청처리(추적요청DTO 요청) {
        String 작업ID = "job-" + UUID.randomUUID().toString().substring(0, 8);
        System.out.println(작업ID + ": [" + 요청.area() + "]에 대한 요청 처리 시작...");

        // 서비스는 '어떤' 명령이 생성되는지 전혀 모릅니다.
        // 단지 주입받은 팩토리에게 "영상 요청 명령 만들어줘", "AI 분석 명령 만들어줘" 라고 요청할 뿐입니다.
        I명령 영상요청 = _commandFactory.영상요청명령생성(요청.area());
        I명령 AI분석요청 = _commandFactory.AI분석요청명령생성(new 분석데이터());

        // 실행기 또한 '어떤' 명령이 들어왔는지 신경쓰지 않고 그냥 '실행하기()' 메서드를 호출할 뿐입니다.
        _commandInvoker.커맨드추가및실행(영상요청);
        _commandInvoker.커맨드추가및실행(AI분석요청);
        
        System.out.println(작업ID + ": 관련 명령들이 실행기에 전달됨.");
        return CompletableFuture.completedFuture(작업ID);
    }
}

// --- Command & Factory Pattern ---

/**
 * [코드 리뷰] Command 패턴 (I명령 인터페이스)
 * 실행될 모든 작업을 '실행하기()'라는 동일한 규격으로 통일시키는 역할을 합니다.
 * "실시간 영상 요청"이든 "배치 영상 요청"이든 모두 이 인터페이스를 구현하므로,
 * 커맨드실행기는 어떤 작업이든 동일한 방식으로 처리할 수 있습니다.
 */
interface I명령 {
    String get작업ID();
    CompletableFuture<Void> 실행하기();
}

/**
 * [코드 리뷰] Command 패턴 (Invoker 역할)
 * 요청을 받아서 해당 요청을 수행할 객체(Receiver)에게 직접 전달하는 것이 아니라,
 * I명령 객체를 큐에 담아두고 순차적으로 실행하는 역할을 합니다. (요청과 실행을 분리)
 */
class 커맨드실행기 {
    private final Queue<I명령> _commandQueue = new ConcurrentLinkedQueue<>();
    public void 커맨드추가및실행(I명령 명령) {
        _commandQueue.add(명령);
        명령.실행하기();
    }
}

/**
 * [코드 리뷰] ConcreteCommand 역할
 * '실시간 영상 요청'이라는 작업을 캡슐화한 클래스입니다.
 * 작업에 필요한 모든 정보(receiver, area)를 생성 시점에 가지고 있습니다.
 */
class 영상요청명령 implements I명령 {
    private final I영상소스제공_App _receiver;
    private final String _area;
    private final String 작업ID = "cmd-realtime-video-" + UUID.randomUUID().toString().substring(0, 4);

    public 영상요청명령(I영상소스제공_App receiver, String area) { this._receiver = receiver; this._area = area; }
    @Override public CompletableFuture<Void> 실행하기() {
        return CompletableFuture.runAsync(() -> {
            System.out.println("  > " + get작업ID() + ": " + _area + " 실시간 영상 소스 요청 실행");
            _receiver.requestStream(_area);
        });
    }
    @Override public String get작업ID() { return 작업ID; }
}

class AI분석요청명령 implements I명령 {
    private final I비동기이벤트발행_App _receiver;
    private final 분석데이터 _analysisData;
    private final String 작업ID = "cmd-realtime-ai-" + UUID.randomUUID().toString().substring(0, 4);

    public AI분석요청명령(I비동기이벤트발행_App receiver, 분석데이터 d) { this._receiver = receiver; this._analysisData = d; }
    @Override public CompletableFuture<Void> 실행하기() {
        return CompletableFuture.runAsync(() -> {
            System.out.println("  > " + get작업ID() + ": 실시간 AI 분석 요청 발행 실행");
            _receiver.publishAnalysisRequest(_analysisData);
        });
    }
    @Override public String get작업ID() { return 작업ID; }
}

// --- <<새로 추가된 명령 구현체들>> ---
class 저장된영상요청명령 implements I명령 {
    private final I저장된영상소스_App _receiver;
    private final String _filePath;
    private final String 작업ID = "cmd-batch-video-" + UUID.randomUUID().toString().substring(0, 4);

    public 저장된영상요청명령(I저장된영상소스_App receiver, String filePath) { this._receiver = receiver; this._filePath = filePath; }
    @Override public CompletableFuture<Void> 실행하기() {
        return CompletableFuture.runAsync(() -> {
            System.out.println("  > " + get작업ID() + ": " + _filePath + " 파일 영상 소스 요청 실행");
            _receiver.requestFile(_filePath);
        });
    }
    @Override public String get작업ID() { return 작업ID; }
}

class 고급AI분석요청명령 implements I명령 {
    private final I비동기이벤트발행_App _receiver;
    private final 분석데이터 _analysisData;
    private final String 작업ID = "cmd-batch-ai-" + UUID.randomUUID().toString().substring(0, 4);
    
    public 고급AI분석요청명령(I비동기이벤트발행_App receiver, 분석데이터 d) { this._receiver = receiver; this._analysisData = d; }
    @Override public CompletableFuture<Void> 실행하기() {
        return CompletableFuture.runAsync(() -> {
             System.out.println("  > " + get작업ID() + ": 고오급 AI 분석 요청 발행 실행");
            _receiver.publishAnalysisRequest(_analysisData);
        });
    }
    @Override public String get작업ID() { return 작업ID; }
}

/**
 * [코드 리뷰] Abstract Factory 패턴 (추상 팩토리 인터페이스)
 * 관련된 객체들의 '군(family)'을 생성하기 위한 인터페이스입니다.
 * 여기서는 '영상 요청 명령'과 'AI 분석 요청 명령'이라는 한 쌍의 명령군을 생성하는 규칙을 정의합니다.
 */
interface I명령팩토리 {
    I명령 영상요청명령생성(String 지역또는경로);
    I명령 AI분석요청명령생성(분석데이터 데이터);
}

/**
 * [코드 리뷰] ConcreteFactory 1
 * '실시간 추적' 시나리오에 맞는 명령군을 생성하는 실제 공장(구현체)입니다.
 * '영상요청명령'과 'AI분석요청명령'을 생성합니다.
 */
class 실시간추적명령팩토리 implements I명령팩토리 {
    private final I영상소스제공_App _videoProvider;
    private final I비동기이벤트발행_App _eventPublisher;

    public 실시간추적명령팩토리(I영상소스제공_App v, I비동기이벤트발행_App e) { this._videoProvider = v; this._eventPublisher = e; }
    @Override public I명령 영상요청명령생성(String 지역) { return new 영상요청명령(_videoProvider, 지역); }
    @Override public I명령 AI분석요청명령생성(분석데이터 데이터) { return new AI분석요청명령(_eventPublisher, 데이터); }
}

/**
 * [코드 리뷰] ConcreteFactory 2
 * '배치 분석' 시나리오에 맞는 명령군을 생성하는 실제 공장(구현체)입니다.
 * '저장된영상요청명령'과 '고급AI분석요청명령'을 생성합니다.
 */
class 배치분석명령팩토리 implements I명령팩토리 {
    private final I저장된영상소스_App _storageProvider;
    private final I비동기이벤트발행_App _eventPublisher;

    public 배치분석명령팩토리(I저장된영상소스_App s, I비동기이벤트발행_App e) { this._storageProvider = s; this._eventPublisher = e; }
    @Override public I명령 영상요청명령생성(String 지역또는경로) { return new 저장된영상요청명령(_storageProvider, 지역또는경로); }
    @Override public I명령 AI분석요청명령생성(분석데이터 데이터) { return new 고급AI분석요청명령(_eventPublisher, 데이터); }
}


// --- Gateways (Infrastructure Layer) ---
/**
 * [코드 리뷰] Gateway (또는 Adapter) 역할
 * 외부 시스템(CCTV 플랫폼, 메시지큐, 파일 스토리지 등)과의 통신처럼 복잡하고 변하기 쉬운 로직을
 * 별도의 클래스로 분리하여 캡슐화하는 역할입니다.
 * 덕분에 핵심 비즈니스 로직은 외부 시스템의 상세한 통신 방법을 몰라도 됩니다.
 */
interface I영상소스제공_App { void requestStream(String area); }
interface I비동기이벤트발행_App { void publishAnalysisRequest(분석데이터 data); }
interface I저장된영상소스_App { void requestFile(String filePath); }

class CctvGateway implements I영상소스제공_App {
    @Override public void requestStream(String area) {
        System.out.println("    - [CctvGateway] " + area + "의 CCTV 플랫폼에 영상 스트림 요청 전송");
    }
}

class MqGateway implements I비동기이벤트발행_App {
    @Override public void publishAnalysisRequest(분석데이터 data) {
        System.out.println("    - [MqGateway] Analysis_Tasks 토픽으로 AI 분석 작업 메시지 발행");
    }
}

class StorageGateway implements I저장된영상소스_App {
    @Override public void requestFile(String filePath) {
        System.out.println("    - [StorageGateway] " + filePath + " 경로의 저장된 영상 파일 요청");
    }
}