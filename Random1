네, 알겠습니다. 요청하신 요구사항은 생산자-소비자 패턴과 옵저버 패턴을 데이터베이스를 중심으로 구현하는 전형적인 시나리오입니다. **Windows 서비스(생산자)**가 파일 시스템의 변경 사항을 감지하여 DB에 지속적으로 업데이트하고, **WPF 애플리케이션(소비자/옵저버)**은 사용자가 원하는 데이터를 선택적으로 구독하여 실시간으로 화면을 갱신하는 전체 솔루션을 상세히 제공해 드리겠습니다.

아래 단계에 따라 전체 시스템을 구축할 수 있습니다.

데이터베이스 설정: 테이블 생성 및 SQL Server Broker 활성화

Windows 서비스 (생산자): 주기적으로 폴더를 스캔하여 DB에 업데이트

WPF 애플리케이션 (소비자): MVVM 패턴을 사용하여 선택적 데이터 구독 및 실시간 UI 갱신

## 1단계: 데이터베이스 설정
가장 먼저 데이터베이스에 데이터를 저장하고 알림을 중계할 테이블과 환경을 설정해야 합니다.

1. 테이블 생성
아래 SQL 쿼리를 실행하여 필요한 테이블 2개를 생성합니다.

SQL

-- 라인 이름과 서비스가 실행되는 서버 IP를 매핑하는 테이블
CREATE TABLE LineTable (
    IPAddress VARCHAR(50) PRIMARY KEY,
    LineName VARCHAR(100) NOT NULL UNIQUE
);
GO

-- 각 라인의 머신별 최신 타임스탬프를 저장하는 테이블
CREATE TABLE MachineData (
    LineName VARCHAR(100) PRIMARY KEY,
    mc1 BIGINT NULL,
    mc2 BIGINT NULL,
    mc3 BIGINT NULL,
    mc4 BIGINT NULL,
    mc5 BIGINT NULL,
    mc6 BIGINT NULL,
    mc7 BIGINT NULL,
    mc8 BIGINT NULL,
    mc9 BIGINT NULL,
    mc10 BIGINT NULL,
    mc11 BIGINT NULL,
    mc12 BIGINT NULL,
    mc13 BIGINT NULL,
    mc14 BIGINT NULL,
    mc15 BIGINT NULL,
    LastUpdated DATETIME DEFAULT GETDATE(),
    CONSTRAINT FK_MachineData_LineName FOREIGN KEY (LineName) REFERENCES LineTable(LineName)
);
GO
2. 테스트 데이터 삽입
서비스와 WPF 앱을 테스트하기 위해 샘플 데이터를 삽입합니다. 192.168.1.10 부분은 Windows 서비스가 실행될 PC의 IP 주소로 변경하세요.

SQL

-- 서비스가 실행될 PC의 IP와 라인 이름을 정의
INSERT INTO LineTable (IPAddress, LineName) VALUES ('192.168.1.10', 'LINE_A');
GO

-- 해당 라인의 초기 데이터 행을 생성
INSERT INTO MachineData (LineName) VALUES ('LINE_A');
GO
3. SQL Server Broker 활성화 (매우 중요)
SqlDependency가 동작하려면 반드시 데이터베이스에서 Service Broker를 활성화하고, 접속 계정에 알림 구독 권한을 부여해야 합니다.

SQL

-- 1. 데이터베이스의 Service Broker 활성화
-- (만약 활성 연결이 있어 오류가 나면, DB를 single user 모드로 변경 후 실행하고 다시 multi user 모드로 돌려야 합니다)
ALTER DATABASE [데이터베이스_이름] SET ENABLE_BROKER;
GO

-- 2. 접속할 DB 유저에게 알림 구독 권한 부여
-- (YOUR_DB_USER를 실제 DB 접속 유저 이름으로 변경)
GRANT SUBSCRIBE QUERY NOTIFICATIONS TO [YOUR_DB_USER];
GO
## 2단계: Windows 서비스 (생산자) 프로젝트
이 서비스는 주기적으로 machine1부터 machine15 폴더를 스캔하여 MachineData 테이블의 해당 mc 컬럼을 업데이트합니다.

1. 프로젝트 생성
Visual Studio에서 'Windows 서비스(.NET Framework)' 프로젝트를 생성합니다. (이전 답변 참고)

프로젝트 이름은 TimestampUpdaterService 등으로 지정합니다.

2. 서비스 전체 코드 (TimestampService.cs)
아래 코드로 Service1.cs 파일의 내용을 모두 대체합니다. 상단의 CONFIG 섹션을 본인 환경에 맞게 반드시 수정하세요.

C#

// TimestampService.cs

using System;
using System.Data.SqlClient;
using System.IO;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.ServiceProcess;
using System.Text;
using System.Threading.Tasks;
using System.Timers;

namespace TimestampUpdaterService
{
    public partial class TimestampService : ServiceBase
    {
        #region CONFIGURATION
        private static class Config
        {
            public const string DbServer = "YOUR_DB_SERVER_ADDRESS";
            public const string DbName = "YOUR_DB_NAME";
            public const string DbUser = "YOUR_DB_USERNAME";
            public const string DbPassword = "YOUR_DB_PASSWORD";
            
            // 공유 폴더가 있는 원격 시스템 IP를 가져오기 위한 설정 (원래 요구사항)
            public const string TargetSystemDbTable = "tableccc"; 
            
            // 스캔할 공유 폴더 경로 정보
            public const string RemoteBaseFolder = "othersystem";
            public const string ProviewerFolder = "proviewer";
            public const string DataFolder = "data";
            public const string MachinePrefix = "machine";
            public const string LanePrefix = "Lane";

            public const double CheckIntervalSeconds = 30.0; // 스캔 주기
        }
        #endregion

        private System.Timers.Timer _timer;
        private string _myLineName;
        private string _connectionString;

        public TimestampService()
        {
            InitializeComponent();
            this.ServiceName = "TimestampUpdaterService";
            _connectionString = $"Server={Config.DbServer};Database={Config.DbName};User Id={Config.DbUser};Password={Config.DbPassword};";
        }

        protected override void OnStart(string[] args)
        {
            try
            {
                // 1. 자신의 IP를 기준으로 LineName을 찾음
                _myLineName = GetMyLineName();
                if (string.IsNullOrEmpty(_myLineName))
                {
                    EventLog.WriteEntry(this.ServiceName, "LineTable에서 이 서버의 IP에 해당하는 LineName을 찾을 수 없습니다. 서비스를 중지합니다.", EventLogEntryType.Error);
                    this.Stop();
                    return;
                }

                // 2. MachineData 테이블에 내 라인 데이터가 없으면 초기화
                EnsureMachineDataRowExists();

                EventLog.WriteEntry(this.ServiceName, $"서비스가 '{_myLineName}' 라인으로 시작됩니다.", EventLogEntryType.Information);
                
                // 3. 타이머 설정 및 시작
                _timer = new System.Timers.Timer(Config.CheckIntervalSeconds * 1000);
                _timer.Elapsed += OnTimerElapsed;
                _timer.AutoReset = true;
                _timer.Start();

                // 서비스 시작 시 즉시 한 번 실행
                Task.Run(() => UpdateAllMachineTimestamps());
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry(this.ServiceName, $"서비스 시작 중 심각한 오류 발생: {ex.Message}\n{ex.StackTrace}", EventLogEntryType.Error);
                throw;
            }
        }

        protected override void OnStop()
        {
            _timer?.Stop();
            _timer?.Dispose();
            EventLog.WriteEntry(this.ServiceName, "서비스가 중지되었습니다.", EventLogEntryType.Information);
        }

        private void OnTimerElapsed(object sender, ElapsedEventArgs e)
        {
            UpdateAllMachineTimestamps();
        }

        private void UpdateAllMachineTimestamps()
        {
            try
            {
                // 원격 시스템의 IP 주소를 가져옴 (이 부분은 기존 로직 유지)
                string targetIp = GetTargetSystemIp(GetLocalIPAddress());
                if (string.IsNullOrEmpty(targetIp))
                {
                    EventLog.WriteEntry(this.ServiceName, "대상 시스템 IP를 찾을 수 없습니다.", EventLogEntryType.Warning);
                    return;
                }

                var timestamps = new long?[15];
                for (int i = 1; i <= 15; i++)
                {
                    timestamps[i - 1] = FindLatestTimestampForMachine(targetIp, i);
                }

                // DB에 한번에 업데이트
                UpdateDatabase(timestamps);
            }
            catch (Exception ex)
            {
                EventLog.WriteEntry(this.ServiceName, $"타임스탬프 업데이트 주기 실행 중 오류: {ex.Message}", EventLogEntryType.Warning);
            }
        }
        
        private long? FindLatestTimestampForMachine(string targetIp, int machineNumber)
        {
            try
            {
                var machinePath = new DirectoryInfo($"\\\\{targetIp}\\{Config.RemoteBaseFolder}\\{Config.ProviewerFolder}\\{Config.DataFolder}\\{Config.MachinePrefix}{machineNumber}");
                if (!machinePath.Exists) return null;

                var latestLaneDir = machinePath.EnumerateDirectories(Config.LanePrefix + "*", SearchOption.AllDirectories)
                    .OrderByDescending(d => d.LastWriteTimeUtc)
                    .FirstOrDefault();

                if (latestLaneDir != null)
                {
                    return new DateTimeOffset(latestLaneDir.LastWriteTimeUtc).ToUnixTimeSeconds();
                }
                return null;
            }
            catch (Exception)
            {
                // 특정 폴더 접근 오류는 무시하고 다음으로 넘어갈 수 있도록 로그만 남기고 null 반환
                return null;
            }
        }

        private void UpdateDatabase(long?[] timestamps)
        {
            var sb = new StringBuilder();
            sb.Append($"UPDATE MachineData SET LastUpdated = GETDATE(), ");
            
            using (var command = new SqlCommand())
            {
                for (int i = 0; i < 15; i++)
                {
                    string paramName = $"@p{i + 1}";
                    sb.Append($"mc{i + 1} = {paramName}, ");
                    command.Parameters.AddWithValue(paramName, (object)timestamps[i] ?? DBNull.Value);
                }

                // 마지막 쉼표와 공백 제거
                sb.Length -= 2;
                sb.Append($" WHERE LineName = @LineName");

                command.CommandText = sb.ToString();
                command.Parameters.AddWithValue("@LineName", _myLineName);

                using (var connection = new SqlConnection(_connectionString))
                {
                    command.Connection = connection;
                    connection.Open();
                    command.ExecuteNonQuery();
                }
            }
        }
        
        // --- Helper Methods ---
        private string GetMyLineName()
        {
            string localIp = GetLocalIPAddress();
            using (var connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                string query = "SELECT LineName FROM LineTable WHERE IPAddress = @LocalIP";
                using (var command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@LocalIP", localIp);
                    return command.ExecuteScalar()?.ToString();
                }
            }
        }

        private void EnsureMachineDataRowExists()
        {
            using (var connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                string query = "IF NOT EXISTS (SELECT 1 FROM MachineData WHERE LineName = @LineName) " +
                               "INSERT INTO MachineData (LineName) VALUES (@LineName)";
                using (var command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@LineName", _myLineName);
                    command.ExecuteNonQuery();
                }
            }
        }

        private string GetTargetSystemIp(string localIp)
        {
            // 이 부분은 원래 요구사항에 맞게 구현합니다.
            // 여기서는 예시로 고정된 IP를 반환하거나 다른 DB 테이블을 조회합니다.
            return "TARGET_SYSTEM_IP_ADDRESS"; // 실제 타겟 시스템 IP를 가져오는 로직 필요
        }

        private string GetLocalIPAddress()
        {
            var host = Dns.GetHostEntry(Dns.GetHostName());
            foreach (var ip in host.AddressList)
            {
                if (ip.AddressFamily == AddressFamily.InterNetwork) return ip.ToString();
            }
            return "127.0.0.1";
        }
    }
}
3. 서비스 설치 및 실행
프로젝트에 설치 관리자를 추가하고 속성을 설정합니다. (이전 답변 참고)

프로젝트를 빌드한 후, 관리자 권한의 개발자 명령 프롬프트에서 InstallUtil.exe YourService.exe로 설치하고 net start YourServiceName로 시작합니다.

## 3단계: WPF 애플리케이션 (소비자) 프로젝트
이 WPF 앱은 MVVM 패턴을 사용하여 사용자가 선택한 mc 컬럼의 값 변경을 실시간으로 감지하고 UI에 반영합니다.

1. 프로젝트 생성
Visual Studio에서 'WPF 앱(.NET Framework)' 프로젝트를 생성합니다.

프로젝트 이름은 MachineDataViewer 등으로 지정합니다.

2. Model: MachineInfo.cs
데이터 한 항목(mc1, mc2 등)을 나타내는 모델 클래스입니다. INotifyPropertyChanged를 구현하여 값 변경 시 UI가 자동으로 업데이트되도록 합니다.

C#

// MachineInfo.cs
using System.ComponentModel;
using System.Runtime.CompilerServices;

public class MachineInfo : INotifyPropertyChanged
{
    public string MachineName { get; set; }

    private bool _isSubscribed;
    public bool IsSubscribed
    {
        get => _isSubscribed;
        set { _isSubscribed = value; OnPropertyChanged(); }
    }

    private string _lastUpdated;
    public string LastUpdated
    {
        get => _lastUpdated;
        set { _lastUpdated = value; OnPropertyChanged(); }
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
3. ViewModel: MainViewModel.cs
UI의 모든 로직과 상태를 관리하는 핵심 클래스입니다. SqlDependency를 여기서 관리합니다.

C#

// MainViewModel.cs
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data;
using System.Data.SqlClient;
using System.Runtime.CompilerServices;
using System.Windows;

public class MainViewModel : INotifyPropertyChanged
{
    private string _connectionString = "Server=YOUR_DB_SERVER;Database=YOUR_DB_NAME;User Id=YOUR_DB_USER;Password=YOUR_DB_PASSWORD;";
    public ObservableCollection<MachineInfo> Machines { get; set; }
    private string _lineNameToWatch = "LINE_A"; // UI에서 입력받을 수 있도록 변경 가능

    public MainViewModel()
    {
        Machines = new ObservableCollection<MachineInfo>();
        for (int i = 1; i <= 15; i++)
        {
            var machineInfo = new MachineInfo { MachineName = $"mc{i}", IsSubscribed = false, LastUpdated = "N/A" };
            machineInfo.PropertyChanged += MachineInfo_PropertyChanged;
            Machines.Add(machineInfo);
        }
    }

    private void MachineInfo_PropertyChanged(object sender, PropertyChangedEventArgs e)
    {
        if (e.PropertyName == nameof(MachineInfo.IsSubscribed))
        {
            var machine = sender as MachineInfo;
            if (machine.IsSubscribed)
            {
                StartSubscription(machine);
            }
            // 구독 취소 로직은 생략 (필요 시 구현)
        }
    }

    private void StartSubscription(MachineInfo machine)
    {
        // 기존 값 먼저 한번 가져오기
        UpdateMachineValue(machine);

        // SqlDependency 설정
        using (var connection = new SqlConnection(_connectionString))
        {
            connection.Open();
            // 중요: 알림을 받으려면 SELECT 쿼리는 특정 규칙을 지켜야 함 (예: 'SELECT *' 사용 불가, 정규화된 이름 사용)
            string query = $"SELECT {machine.MachineName} FROM dbo.MachineData WHERE LineName = @LineName";
            using (var command = new SqlCommand(query, connection))
            {
                command.Parameters.AddWithValue("@LineName", _lineNameToWatch);
                
                var dependency = new SqlDependency(command);
                dependency.OnChange += (s, ev) => OnDependencyChange(s, ev, machine);

                // 이 command는 SqlDependency를 등록하기 위한 것이므로, 실제로 데이터를 읽을 필요는 없음
                command.ExecuteNonQuery();
            }
        }
    }
    
    private void OnDependencyChange(object sender, SqlNotificationEventArgs e, MachineInfo machine)
    {
        // 중요: SqlDependency는 일회성이므로, 알림을 받은 후 즉시 재구독해야 함
        Application.Current.Dispatcher.Invoke(() => {
            if (machine.IsSubscribed)
            {
                StartSubscription(machine);
            }
        });
    }

    private void UpdateMachineValue(MachineInfo machine)
    {
        string value = "Error";
        try
        {
            using (var connection = new SqlConnection(_connectionString))
            {
                connection.Open();
                string query = $"SELECT {machine.MachineName} FROM dbo.MachineData WHERE LineName = @LineName";
                using (var command = new SqlCommand(query, connection))
                {
                    command.Parameters.AddWithValue("@LineName", _lineNameToWatch);
                    object result = command.ExecuteScalar();
                    if (result != null && result != DBNull.Value)
                    {
                        long unixTimestamp = (long)result;
                        value = DateTimeOffset.FromUnixTimeSeconds(unixTimestamp).LocalDateTime.ToString("yyyy-MM-dd HH:mm:ss");
                    }
                    else
                    {
                        value = "No Data";
                    }
                }
            }
        }
        catch (Exception ex)
        {
            value = ex.Message;
        }

        // UI 스레드에서 업데이트
        Application.Current.Dispatcher.Invoke(() => machine.LastUpdated = value);
    }
    
    // INotifyPropertyChanged 구현
    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
4. View: MainWindow.xaml
사용자 인터페이스입니다. ViewModel의 데이터와 상태를 바인딩하여 보여줍니다.

XML

<Window x:Class="MachineDataViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:MachineDataViewer"
        mc:Ignorable="d"
        Title="Machine Data Viewer" Height="500" Width="400">
    <Window.DataContext>
        <local:MainViewModel/>
    </Window.DataContext>
    <Grid Margin="10">
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        
        <StackPanel Orientation="Horizontal" Margin="0,0,0,10">
            <TextBlock Text="Line to Watch: " VerticalAlignment="Center"/>
            <TextBox Text="LINE_A" Width="150" VerticalAlignment="Center"/>
            </StackPanel>
        
        <ScrollViewer Grid.Row="1" VerticalScrollBarVisibility="Auto">
            <ItemsControl ItemsSource="{Binding Machines}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Border BorderBrush="Gray" BorderThickness="1" Padding="5" Margin="2">
                            <Grid>
                                <Grid.ColumnDefinitions>
                                    <ColumnDefinition Width="Auto"/>
                                    <ColumnDefinition Width="*"/>
                                    <ColumnDefinition Width="Auto"/>
                                </Grid.ColumnDefinitions>
                                
                                <CheckBox IsChecked="{Binding IsSubscribed, Mode=TwoWay}" VerticalAlignment="Center"/>
                                <TextBlock Grid.Column="1" Text="{Binding MachineName}" FontWeight="Bold" Margin="10,0" VerticalAlignment="Center"/>
                                <TextBlock Grid.Column="2" Text="{Binding LastUpdated}" Foreground="DarkSlateBlue" VerticalAlignment="Center"/>
                            </Grid>
                        </Border>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </ScrollViewer>
    </Grid>
</Window>
5. App.xaml.cs 수정 (SqlDependency 시작/종료)
애플리케이션 시작 시 SqlDependency.Start()를, 종료 시 Stop()를 호출해야 합니다.

C#

// App.xaml.cs
using System.Data.SqlClient;
using System.Windows;

namespace MachineDataViewer
{
    public partial class App : Application
    {
        private string _connectionString = "Server=YOUR_DB_SERVER;Database=YOUR_DB_NAME;User Id=YOUR_DB_USER;Password=YOUR_DB_PASSWORD;";

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // 애플리케이션 전체에서 SqlDependency 리스너 시작
            SqlDependency.Start(_connectionString);
        }

        protected override void OnExit(ExitEventArgs e)
        {
            // 애플리케이션 종료 시 리스너 중지
            SqlDependency.Stop(_connectionString);
            base.OnExit(e);
        }
    }
}
MainWindow.xaml.cs 에서는 InitializeComponent();만 남기고 다 지우거나 그대로 두면 됩니다.

## 4단계: 전체 시스템 실행 및 테스트
서비스 실행: TimestampUpdaterService를 설치하고 시작합니다. 서비스가 정상적으로 실행되면 service.log나 Windows 이벤트 뷰어에 로그가 남고, MachineData 테이블의 mc 컬럼들이 주기적으로 업데이트되기 시작합니다.

WPF 앱 실행: MachineDataViewer를 실행합니다.

구독 테스트: 앱에서 특정 머신(예: mc3, mc7)의 체크박스를 클릭합니다.

실시간 갱신 확인: 서비스에 의해 DB 값이 변경되는 순간, 체크한 항목의 시간 값이 WPF 앱 화면에서 다른 항목에 영향 없이 개별적으로 갱신되는 것을 확인할 수 있습니다.






Deep Research
