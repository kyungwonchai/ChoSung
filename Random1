 작업이 추가될 때, 그 작업이 Pending 상태로 남는 문제는 다음과 같은 이유일 수 있습니다:

큐에 새 작업이 추가되었을 때 작업이 실행 중이 아니면 바로 실행해야 하는데, 큐가 비어 있거나 실행 중이 아니더라도 Pending 상태에서 제대로 처리되지 않았을 수 있습니다.
작업이 완료된 후, 새 파일이 감지되었을 때 작업이 추가되자마자 즉시 실행되어야 하는 로직이 제대로 동작하지 않았습니다.
문제 해결 방향:
작업 큐가 비어 있거나 작업이 완료된 상태에서 새로운 작업이 감지되었을 때, 작업을 즉시 실행하도록 수정하겠습니다.
새로운 작업이 작업 목록에 추가된 후, 작업이 Pending 상태로 남지 않고 바로 실행되도록 작업 큐의 실행 흐름을 수정하겠습니다.
수정된 TaskQueue.cs (새 작업 감지 시 즉시 실행)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하며, 작업이 완료되면 다음 작업을 실행합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false; // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;  // 작업이 일시정지 상태인지 여부

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        // 현재 작업이 실행 중이 아니고 일시정지가 아니라면 즉시 실행
        if (!_isRunning && !_isPaused)
        {
            RunNextTask(); // 즉시 다음 작업 실행
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused) // 큐에 작업이 없거나 일시정지 상태라면 리턴
        {
            _isRunning = false;  // 작업이 실행 중이지 않음
            return;
        }

        _isRunning = true; // 현재 작업 실행 중

        var task = _tasks.Dequeue(); // 큐에서 작업을 가져와 실행
        await task(); // 작업 실행 (비동기)

        _isRunning = false; // 작업이 완료되었으므로 실행 중 상태 해제

        // 다음 작업 실행 (재귀 호출)
        if (_tasks.Count > 0) // 큐에 작업이 남아 있을 경우
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true; // 작업 일시정지 상태로 변경
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        if (_isPaused)
        {
            _isPaused = false; // 일시정지 해제
            if (!_isRunning)  // 작업이 실행 중이 아니면 다음 작업 실행
            {
                RunNextTask(); // 즉시 다음 작업 실행
            }
        }
    }
}
수정된 MainViewModel.cs (파일 감지 시 작업 즉시 실행)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel입니다.
/// 로그 파일을 감지하고 작업을 처리하는 역할을 합니다.
/// 작업이 완료되면 자동으로 다음 작업이 실행됩니다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업 재개
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(logEntry, _taskQueue);
            task.StartNextTask = StartNextTask; // 현재 작업이 끝나면 다음 작업을 실행하도록 설정
            TaskList.Add(task); // UI 스레드에서 작업 목록에 추가

            if (TaskList.Count == 1 || TaskList.All(t => t.Status == "Completed")) // 첫 번째 작업일 때 바로 시작
            {
                task.StartTask(); // 첫 번째 작업 또는 모든 작업이 완료된 후 새로운 작업은 즉시 실행
            }
        });
    }

    /// <summary>
    /// 다음 작업을 실행하는 메서드.
    /// 현재 작업이 완료되면 호출됩니다.
    /// </summary>
    private void StartNextTask(TaskModel currentTask)
    {
        // 현재 작업이 완료된 후 다음 작업을 찾음
        int currentIndex = TaskList.IndexOf(currentTask);
        if (currentIndex + 1 < TaskList.Count)
        {
            var nextTask = TaskList[currentIndex + 1];
            nextTask.StartTask(); // 다음 작업 시작
        }
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
수정 내용 설명:
새로운 작업이 감지되었을 때 즉시 실행:

새로운 작업이 감지되면 첫 번째 작업이거나 모든 작업이 완료된 경우 즉시 실행됩니다.
기존 작업이 실행 중이지 않은 경우에도 새로운 작업이 감지되면 바로 실행할 수 있도록 했습니다.
TaskQueue 개선:

작업이 순차적으로 실행되고, 큐에 새 작업이 들어왔을 때 실행 중이지 않으면 즉시 실행되도록 수정했습니다.
RunNextTask()가 자동으로 다음 작업을 확인하고 실행하게 되어, Pending 상태로 멈추는 문제가 발생하지 않도록 했습니다.
새 파일이 감지된 후 작업이 Pending으로 남지 않음:

작업이 완료된 후 새 파일이 감지되면 작업 목록에 추가된 작업이 바로 실행됩니다.
기존 작업이 끝난 후에 새로운 작업이 Pending 상태로 남지 않고 즉시 실행되도록 수정했습니다.
이제 새로운 작업이 감지되었을 때 기존 작업이 완료되었으면 즉시 실행될 것입니다. 문제가 해결되지 않거나 추가적인 수정이 필요하다면, 알려주시면 바로 도와드리겠습니