# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app, render_template, g, request # <<--- g, request 임포트 추가!
from config import config
import datetime
import os
from flask_apscheduler import APScheduler 

scheduler = APScheduler()

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # --- Jinja2 필터 및 컨텍스트 프로세서 ---
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}

    from .auth import inject_user_info_to_templates # 이 함수는 내부적으로 g와 request 사용
    app.context_processor(inject_user_info_to_templates)


    # --- 블루프린트 등록 ---
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 
    from .routes_logs import logs_bp 
    app.register_blueprint(logs_bp, url_prefix='/history')


    # --- 403 에러 핸들러 등록 ---
    @app.errorhandler(403)
    def forbidden_page(error): # error 인자는 Flask가 자동으로 전달
        # inject_user_info_to_templates 컨텍스트 프로세서가 먼저 실행되어 g.user_ip를 설정했을 것임
        # 만약 설정되지 않았다면 'IP 확인 불가'로 표시됨
        client_ip_for_log = getattr(g, 'user_ip', 'IP 확인 불가')
        # request 객체는 이 컨텍스트에서 사용 가능해야 함 (Flask가 관리)
        requested_path = request.path if request else '경로 확인 불가'
        
        app.logger.warning(f"403 Forbidden error handled for IP: {client_ip_for_log}, Path: {requested_path}")
        return render_template('errors/403.html'), 403
    # --- 403 에러 핸들러 등록 끝 ---


    # --- APScheduler 초기화 및 작업 등록 ---
    if not scheduler.running:
        scheduler.init_app(app)
        app.logger.info("APScheduler init_app(app) 호출됨.")
        from . import scheduler_tasks 
        current_flask_app_for_scheduler = app 
        job_id_on = 'scheduled_task_monitor_on_daily'; job_id_off = 'scheduled_task_monitor_off_daily'
        try:
            scheduler.add_job(id=job_id_on, func=scheduler_tasks.scheduled_task_monitor_on, args=[current_flask_app_for_scheduler], trigger='cron', hour=6, minute=0, misfire_grace_time=3600, replace_existing=True)
            app.logger.info(f"스케줄 작업 '{job_id_on}' 매일 06:00 등록/대체됨.")
            scheduler.add_job(id=job_id_off, func=scheduler_tasks.scheduled_task_monitor_off, args=[current_flask_app_for_scheduler], trigger='cron', hour=7, minute=0, misfire_grace_time=3600, replace_existing=True )
            app.logger.info(f"스케줄 작업 '{job_id_off}' 매일 07:00 등록/대체됨.")
            if not app.config.get('TESTING', False): scheduler.start(); app.logger.info("APScheduler 시작됨.")
            else: app.logger.info("TESTING 모드: APScheduler 자동 시작 안 함.")
        except Exception as e: app.logger.error(f"APScheduler 작업 등록 또는 시작 실패: {e}", exc_info=True)
    else: app.logger.info("APScheduler가 이미 실행 중이거나 다른 방식으로 초기화됨.")

    app.logger.info("Flask application 생성 및 설정 완료 (커스텀 403 핸들러 포함).")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")
        if scheduler.running: app.logger.debug(f"등록된 스케줄러 작업: {scheduler.get_jobs()}")

    return app