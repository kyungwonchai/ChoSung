래는 파일을 분리한 구조입니다. MainWindow.xaml, MainViewModel.cs, 그리고 FileWatcher.cs로 분리된 WPF 프로젝트 코드입니다.

1. MainWindow.xaml (메인 UI)
xml
코드 복사
<Window x:Class="GumiWatcher.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Gumi Watcher" Height="350" Width="525">
    <Grid>
        <DataGrid ItemsSource="{Binding ProductOrders}" AutoGenerateColumns="False" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="Product Order" Binding="{Binding ProductOrder}" />
                <DataGridTextColumn Header="Basic Model" Binding="{Binding BasicModel}" />
                <DataGridTextColumn Header="PO Remain" Binding="{Binding PORemain}" />
                <DataGridTextColumn Header="MG Count" Binding="{Binding MGCount}" />
                <DataGridTextColumn Header="P Count" Binding="{Binding PCount}" />
                <DataGridTextColumn Header="Status" Binding="{Binding POStatus}" />
                <DataGridTextColumn Header="Date" Binding="{Binding PDate}" />
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
2. MainWindow.xaml.cs (MainWindow 코드비하인드)
csharp
코드 복사
using System.Windows;

namespace GumiWatcher
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            // MainViewModel을 DataContext로 설정하여 바인딩합니다.
            DataContext = new MainViewModel();
        }
    }
}
3. MainViewModel.cs (메인 ViewModel)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace GumiWatcher
{
    public class MainViewModel : INotifyPropertyChanged
    {
        // 이벤트 핸들러
        public event PropertyChangedEventHandler PropertyChanged;

        // DataGrid에 바인딩할 ObservableCollection
        public ObservableCollection<ProductOrderModel> ProductOrders { get; set; }

        // FileWatcher 인스턴스
        private FileWatcher _fileWatcher;

        public MainViewModel()
        {
            // ProductOrderModel 컬렉션을 초기화
            ProductOrders = new ObservableCollection<ProductOrderModel>();

            // FileWatcher 클래스 초기화 및 데이터 바인딩
            _fileWatcher = new FileWatcher(ProductOrders);
        }

        // PropertyChanged 이벤트 호출 메소드
        protected void OnPropertyChanged(string name)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
        }
    }
}
4. FileWatcher.cs (파일 감시 클래스)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiWatcher
{
    public class FileWatcher
    {
        private FileSystemWatcher _fileWatcher;
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";
        private DispatcherTimer _timer;
        private string _lastMonitoredFile;
        private ProductOrderModel _currentProductOrder;
        private ObservableCollection<ProductOrderModel> _productOrders;

        public FileWatcher(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders;

            // 파일 시스템 감시기 초기화
            _fileWatcher = new FileSystemWatcher
            {
                Path = _logDirectory,
                Filter = "*.log",
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size
            };
            _fileWatcher.Changed += OnChanged;
            _fileWatcher.Created += OnChanged;
            _fileWatcher.EnableRaisingEvents = true;

            // 주기적으로 최근 파일을 감시
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _timer.Tick += CheckLatestFile;
            _timer.Start();
        }

        // 파일이 변경되었을 때 발생하는 이벤트
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            // 파일 이름이 지정된 정규식 패턴에 맞는지 확인
            if (!Regex.IsMatch(e.Name, _filePattern)) return;

            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile);
            }
        }

        // 가장 최근에 수정된 파일을 반환
        private string GetLatestLogFile()
        {
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern))
                .OrderByDescending(f => f.LastWriteTime)
                .ToList();

            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일 내용을 읽고 로그를 처리
        private void ReadLogFile(string filePath)
        {
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                ProcessLogLine(line);
            }
        }

        // 로그의 각 줄을 처리
        private void ProcessLogLine(string line)
        {
            // PLAN Selected 라인 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' ');
                string productOrder = splitLine[1];

                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    _currentProductOrder = new ProductOrderModel
                    {
                        ProductOrder = productOrder,
                        PDate = DateTime.Now.ToString("yyyyMMdd"),
                        POStatus = "wait"
                    };
                    _productOrders.Add(_currentProductOrder);
                }
            }

            // BasicModel 라인 처리
            else if (line.Contains("BasicModel"))
            {
                var modelData = line.Split(':')[1].Trim();
                _currentProductOrder.BasicModel = modelData;
            }

            // MB^ 라인 처리
            else if (line.Contains("MB^"))
            {
                var mbData = line.Split('^');
                _currentProductOrder.PORemain = int.Parse(mbData[1]);
                _currentProductOrder.MGCount = int.Parse(mbData[2]);
            }

            // JB^ 라인 처리
            else if (line.Contains("JB^"))
            {
                _currentProductOrder.PCount++;
            }

            // FNL^ 라인 처리
            else if (line.Contains("FNL^"))
            {
                _currentProductOrder.POStatus = "stack";
            }

            // JD^ 라인 처리
            else if (line.Contains("JD^"))
            {
                _currentProductOrder.POStatus = "out";
                ExecuteOutFunction();
            }
        }

        // 배출 함수 (구현 필요)
        private void ExecuteOutFunction()
        {
            // 배출 함수 구현
        }

        // 주기적으로 파일을 체크하는 메소드
        private void CheckLatestFile(object sender, EventArgs e)
        {
            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile);
            }
        }
    }

    // 데이터 모델 클래스
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; }
        public string BasicModel { get; set; }
        public int PORemain { get; set; }
        public int MGCount { get; set; }
        public int PCount { get; set; }
        public string POStatus { get; set; }
        public string PDate { get; set; }
    }
}
주요 파일 설명
MainWindow.xaml: 데이터 그리드를 통해 ProductOrderModel 객체를 실시간으로 UI에 표시합니다.
MainViewModel.cs: FileWatcher 클래스를 사용하여 데이터를 감시하고, 이를 데이터 그리드에 반영하는 역할을 합니다.
FileWatcher.cs: 파일 변경을 감시하고, 로그 파일을 처리하며, 로그 내용에 따라 데이터를 갱신하는 역할을 합니다. ProductOrderModel 클래스를 사용하여 데이터를 관리합니다.
각각의 파일이 분리되어 있으며, 주석을 포함한 코드로 각 역할이 명확하게 나뉘어져 있습니다.






나의 말:
주석을 파일와처쪽에는 아주상세히 달아줘보세요 맞나보게
ChatGPT의 말:
ChatGPT
아래는 FileWatcher.cs에 주석을 매우 상세하게 달아 설명한 코드입니다. 각 부분이 어떤 역할을 하는지, 구체적으로 어떤 로직이 동작하는지 쉽게 이해할 수 있도록 작성했습니다.

FileWatcher.cs (상세 주석 추가)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiWatcher
{
    // FileWatcher 클래스는 파일 시스템 감시를 수행하고 로그 파일의 변화를 처리하는 역할을 합니다.
    public class FileWatcher
    {
        // 파일 시스템 감시기(FileSystemWatcher)를 위한 객체 선언
        private FileSystemWatcher _fileWatcher;

        // 감시할 로그 파일의 디렉토리 경로 설정
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 파일 이름이 지정된 규칙(정규식)에 맞는지 확인하기 위한 패턴
        // 예시: "xxx.xxx.xxx.xxx_M4OIxxxxx_gumixxxx_12.log" 와 같은 파일명을 감시함 (마지막 두 자리는 날짜)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 주기적으로 파일 변화를 체크하기 위한 타이머 (1초 간격)
        private DispatcherTimer _timer;

        // 마지막으로 감시된 파일 경로 저장 (중복 처리를 방지하기 위함)
        private string _lastMonitoredFile;

        // 현재 처리 중인 ProductOrder 객체를 저장
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (ProductOrder 정보를 담고 있음)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // FileWatcher 생성자, 외부에서 ObservableCollection을 받아와서 초기화합니다.
        public FileWatcher(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders; // MainViewModel에서 전달된 ObservableCollection과 바인딩
            
            // FileSystemWatcher 초기화 및 설정
            _fileWatcher = new FileSystemWatcher
            {
                Path = _logDirectory, // 감시할 디렉토리 설정
                Filter = "*.log", // 로그 파일만 감시 (확장자가 .log인 파일)
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size // 감시할 변경 사항: 파일의 수정, 생성, 크기 변화
            };

            // 파일이 변경되거나 생성될 때 OnChanged 메소드 호출
            _fileWatcher.Changed += OnChanged;
            _fileWatcher.Created += OnChanged;
            _fileWatcher.EnableRaisingEvents = true; // 파일 시스템 감시기 시작

            // 주기적으로 파일 변화를 체크할 타이머 설정 (1초마다 Tick 이벤트 발생)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _timer.Tick += CheckLatestFile; // 매 Tick마다 CheckLatestFile 메소드 실행
            _timer.Start(); // 타이머 시작
        }

        // 파일 변경(생성 또는 수정)이 발생하면 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            // 파일 이름이 정규식 패턴에 맞는지 확인
            if (!Regex.IsMatch(e.Name, _filePattern)) return; // 패턴에 맞지 않으면 종료

            // 가장 최근에 수정된 파일의 경로를 가져옴
            string latestFile = GetLatestLogFile();
            
            // 최근 감시한 파일과 다른 파일이라면 그 파일을 처리
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile; // 감시 파일 경로 업데이트
                ReadLogFile(latestFile); // 파일 내용을 읽어서 처리
            }
        }

        // 지정된 디렉토리 내에서 가장 최근에 수정된 파일을 찾는 메소드
        private string GetLatestLogFile()
        {
            // 지정된 경로에서 파일 목록을 가져오고, 정규식 패턴에 맞는 파일을 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일만 선택
                .OrderByDescending(f => f.LastWriteTime) // 수정 시간 기준으로 내림차순 정렬 (가장 최근 파일이 먼저 옴)
                .ToList();

            // 가장 최근의 파일을 반환 (없을 경우 null 반환)
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 지정된 파일의 내용을 읽어서 각 라인을 처리하는 메소드
        private void ReadLogFile(string filePath)
        {
            // 파일의 모든 라인을 읽어서 각 라인을 처리
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                ProcessLogLine(line); // 각 줄을 처리하는 메소드 호출
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드 (로그 내용에 따라 데이터 모델을 업데이트)
        private void ProcessLogLine(string line)
        {
            // "PLAN Selected" 라인이 발견되었는지 확인 (주문이 선택된 시점)
            if (line.Contains("PLAN Selected"))
            {
                // 라인을 공백으로 나누고 두 번째 항목(제품 주문 번호)을 가져옴
                var splitLine = line.Split(' ');
                string productOrder = splitLine[1];

                // 현재 주문이 없거나 이전 주문과 다른 경우 새로운 주문을 생성
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    _currentProductOrder = new ProductOrderModel
                    {
                        ProductOrder = productOrder, // 제품 주문 번호 설정
                        PDate = DateTime.Now.ToString("yyyyMMdd"), // 현재 날짜를 yyyyMMdd 형식으로 저장
                        POStatus = "wait" // 주문 상태를 "대기(wait)"로 설정
                    };
                    _productOrders.Add(_currentProductOrder); // 새로운 주문을 컬렉션에 추가 (UI에 반영됨)
                }
            }

            // "BasicModel" 라인이 발견되면 제품 모델 정보를 처리
            else if (line.Contains("BasicModel"))
            {
                var modelData = line.Split(':')[1].Trim(); // ":" 기준으로 나눠서 두 번째 값(모델 정보)을 추출
                _currentProductOrder.BasicModel = modelData; // 제품 주문 모델 정보 업데이트
            }

            // "MB^" 라인이 발견되면 잔여 수량(PORemain)과 매거진 구성 수량(MGCount)을 처리
            else if (line.Contains("MB^"))
            {
                var mbData = line.Split('^'); // "^" 기준으로 데이터를 분리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 두 번째 값(잔여 수량)을 정수로 변환하여 저장
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 세 번째 값(매거진 수량)을 정수로 변환하여 저장
            }

            // "JB^" 라인이 발견되면 생산된 개수를 증가
            else if (line.Contains("JB^"))
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 카운트를 1 증가
            }

            // "FNL^" 라인이 발견되면 적재 상태로 변경
            else if (line.Contains("FNL^"))
            {
                _currentProductOrder.POStatus = "stack"; // 적재 상태로 주문 상태를 업데이트
            }

            // "JD^" 라인이 발견되면 배출 처리
            else if (line.Contains("JD^"))
            {
                _currentProductOrder.POStatus = "out"; // 배출 상태로 주문 상태를 업데이트
                ExecuteOutFunction(); // 배출 함수 호출
            }
        }

        // 배출 함수 (현재는 구현 필요)
        private void ExecuteOutFunction()
        {
            // 배출 처리에 대한 실제 로직을 여기에 구현
            // 예: 물류 시스템과 연동되어 배출 신호를 전송할 수 있음
        }

        // 타이머에 의해 주기적으로 호출되어 가장 최근 파일을 체크하는 메소드
        private void CheckLatestFile(object sender, EventArgs e)
        {
            // 가장 최근에 수정된 파일의 경로를 가져옴
            string latestFile = GetLatestLogFile();
            
            // 최근 감시한 파일과 다른 파일이라면 그 파일을 처리
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile; // 감시 파일 경로 업데이트
                ReadLogFile(latestFile); // 파일 내용을 읽어서 처리
            }
        }
    }

    // ProductOrderModel 클래스는 각 제품 주문의 정보를 저장하는 데이터 모델입니다.
    public class ProductOrderModel
    {
        // 제품 주문 번호
        public string ProductOrder { get; set; }
        
        // 제품의 모델 정보
        public string BasicModel { get; set; }

        // 주문의 잔여 수량
        public int PORemain { get; set; }

        // 매거진 당 제품 수량
        public int MGCount { get; set; }

        // 생산된 제품 수량
        public int PCount { get; set; }

        // 주문 상태 (대기, 적재, 배출 상태 등)
        public string POStatus { get; set; }

        // 주문 날짜 (yyyyMMdd 형식)
        public string PDate { get; set; }
    }
}
상세 주석 설명
FileWatcher 클래스: 주어진 경로에서 파일 변경을 감시하고, 규칙에 맞는 파일을 찾고, 변경된 파일을 처리하는 전체적인 흐름을 담당합니다.
정규식 사용: 파일 이름이 규칙에 맞는지 확인하고, FileSystemWatcher를 통해 파일 변경을 감시합니다.
파일 내용 처리: 파일의 각 줄을 읽어 PLAN Selected, BasicModel, MB^, JB^, FNL^, JD^와 같은 패턴을 감지하여 적절하게 데이터를 처리하고 업데이트합니다.
주기적인 파일 체크: 주기적으로 가장 최근에 수정된 파일을 확인하고, 해당 파일을 처리합니다.
ProductOrderModel: 제품 주문과 관련된 데이터를 저장하는 데이터 모델입니다. DataGrid에 바인딩되어 UI에 표시됩니다.
이 코드에는 매우 상세한 주석이 포함되어 있어 각 메소드와 변수의 역할을 쉽게 이해할 수 있습니다.






나의 말:
파일 이름의 마지막 두 글자(확장자 앞) 그게 날짜의 day 값이야. 지금 연 월과 day를 조합해.
ChatGPT의 말:
ChatGPT
아래는 파일 이름의 마지막 두 글자(확장자 앞)에서 day 값을 추출하고, 현재 연도와 월을 조합하여 yyyyMMdd 형식으로 날짜를 만드는 방법을 적용한 코드입니다.

수정된 FileWatcher.cs (날짜 조합 추가)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiWatcher
{
    public class FileWatcher
    {
        private FileSystemWatcher _fileWatcher;
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";
        private DispatcherTimer _timer;
        private string _lastMonitoredFile;
        private ProductOrderModel _currentProductOrder;
        private ObservableCollection<ProductOrderModel> _productOrders;

        public FileWatcher(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders;

            _fileWatcher = new FileSystemWatcher
            {
                Path = _logDirectory,
                Filter = "*.log",
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size
            };
            _fileWatcher.Changed += OnChanged;
            _fileWatcher.Created += OnChanged;
            _fileWatcher.EnableRaisingEvents = true;

            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _timer.Tick += CheckLatestFile;
            _timer.Start();
        }

        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            if (!Regex.IsMatch(e.Name, _filePattern)) return;

            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile);
            }
        }

        private string GetLatestLogFile()
        {
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern))
                .OrderByDescending(f => f.LastWriteTime)
                .ToList();

            return logFiles.FirstOrDefault()?.FullName;
        }

        private void ReadLogFile(string filePath)
        {
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                ProcessLogLine(line, filePath);
            }
        }

        // 로그의 각 줄을 처리하는 메소드, 파일 경로에서 날짜(day)를 추출하여 yyyyMMdd 형식으로 저장
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 마지막 두 글자를 추출하여 day 값을 가져옴
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 마지막 두 글자 추출

            // 현재 연도와 월을 구해서 yyyyMMdd 형식으로 조합
            string currentYearMonth = DateTime.Now.ToString("yyyyMM");
            string fullDate = currentYearMonth + dayString; // 예: "20230901" (2023년 9월 1일)

            // PLAN Selected 라인 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' ');
                string productOrder = splitLine[1];

                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    _currentProductOrder = new ProductOrderModel
                    {
                        ProductOrder = productOrder,
                        PDate = fullDate, // yyyyMMdd 형식으로 날짜 저장
                        POStatus = "wait"
                    };
                    _productOrders.Add(_currentProductOrder);
                }
            }
            // 나머지 처리 로직은 그대로 유지
            else if (line.Contains("BasicModel"))
            {
                var modelData = line.Split(':')[1].Trim();
                _currentProductOrder.BasicModel = modelData;
            }
            else if (line.Contains("MB^"))
            {
                var mbData = line.Split('^');
                _currentProductOrder.PORemain = int.Parse(mbData[1]);
                _currentProductOrder.MGCount = int.Parse(mbData[2]);
            }
            else if (line.Contains("JB^"))
            {
                _currentProductOrder.PCount++;
            }
            else if (line.Contains("FNL^"))
            {
                _currentProductOrder.POStatus = "stack";
            }
            else if (line.Contains("JD^"))
            {
                _currentProductOrder.POStatus = "out";
                ExecuteOutFunction();
            }
        }

        private void ExecuteOutFunction()
        {
            // 배출 처리에 대한 실제 로직을 여기에 구현
        }

        private void CheckLatestFile(object sender, EventArgs e)
        {
            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile);
            }
        }
    }

    public class ProductOrderModel
    {
        public string ProductOrder { get; set; }
        public string BasicModel { get; set; }
        public int PORemain { get; set; }
        public int MGCount { get; set; }
        public int PCount { get; set; }
        public string POStatus { get; set; }
        public string PDate { get; set; }
    }
}
변경 사항
날짜 조합 로직 추가: 파일 이름에서 마지막 두 글자(dayString)를 추출하고, 현재 연도와 월(yyyyMM)을 가져와 이를 조합하여 yyyyMMdd 형식의 날짜(fullDate)를 생성했습니다.
PDate에 저장: PLAN Selected가 감지되었을 때 생성되는 ProductOrderModel 객체의 PDate 필드에 yyyyMMdd 형식으로 조합된 날짜를 저장했습니다.
이제 파일 이름의 마지막 두 자리를 day 값으로 사용하고, 현재 연도와 월을 조합하여 정확한 날짜를 PDate 필드에 저장할 수 있습니다