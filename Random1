 WPF MVVM ê¸°ë°˜ ëª¨ë‹ˆí„° ìë™ ON/OFF + ë‹¬ë ¥ íœ´ì¼ ì„¤ì • ê¸°ëŠ¥
âœ… WPF + MVVM íŒ¨í„´ ì¤€ìˆ˜
âœ… ë‹¬ë ¥ì—ì„œ ì‰¬ëŠ” ë‚  ì„¤ì • ê°€ëŠ¥ (ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œ)
âœ… í† ìš”ì¼, ì¼ìš”ì¼, ê³µíœ´ì¼ì€ ê¸°ë³¸ì ìœ¼ë¡œ ë…¸ë€ìƒ‰ (ì‰¬ëŠ” ë‚ )
âœ… ì‰¬ëŠ” ë‚ ì´ë©´ ëª¨ë‹ˆí„° ìë™ ON/OFF ê¸°ëŠ¥ í™œì„±í™”
âœ… ì¼í•˜ëŠ” ë‚ ì´ë©´ ëª¨ë‹ˆí„° í•­ìƒ ì¼œì§ (ìë™ OFF ê¸°ëŠ¥ ë¹„í™œì„±í™”)

ğŸ“Œ í”„ë¡œì íŠ¸ êµ¬ì¡°
scss
ì½”ë“œ ë³µì‚¬
ğŸ“‚ MonitorControlApp
 â”œâ”€â”€ ğŸ“‚ ViewModels
 â”‚    â”œâ”€â”€ MainViewModel.cs (ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§)
 â”œâ”€â”€ ğŸ“‚ Views
 â”‚    â”œâ”€â”€ MainWindow.xaml (UI)
 â”œâ”€â”€ ğŸ“‚ Models
 â”‚    â”œâ”€â”€ HolidayModel.cs (íœ´ì¼ ë°ì´í„° ê´€ë¦¬)
 â”œâ”€â”€ App.xaml
 â”œâ”€â”€ MainWindow.xaml.cs (MainViewModelê³¼ ì—°ê²°)
 â”œâ”€â”€ Program.cs (ì§„ì…ì )
ğŸ”¥ 1ï¸âƒ£ MainViewModel.cs (MVVM íŒ¨í„´ ë¡œì§)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.InteropServices;
using System.Windows;
using System.Windows.Input;

namespace MonitorControlApp.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private static readonly int WM_SYSCOMMAND = 0x0112;
        private static readonly int SC_MONITORPOWER = 0xF170;
        private static readonly int MONITOR_ON = -1;
        private static readonly int MONITOR_OFF = 2;
        private bool _isMonitorOff = false;

        public ObservableCollection<DateTime> Holidays { get; set; }
        public ICommand ToggleHolidayCommand { get; }
        public ICommand CheckMonitorCommand { get; }

        public MainViewModel()
        {
            Holidays = new ObservableCollection<DateTime>(GetDefaultHolidays());
            ToggleHolidayCommand = new RelayCommand<DateTime>(ToggleHoliday);
            CheckMonitorCommand = new RelayCommand(CheckMonitorState);
        }

        private List<DateTime> GetDefaultHolidays()
        {
            var holidays = new List<DateTime>();

            // ê¸°ë³¸ì ìœ¼ë¡œ í† ìš”ì¼, ì¼ìš”ì¼ì€ ë…¸ë€ìƒ‰ (ì‰¬ëŠ” ë‚ )
            for (int i = 0; i < 365; i++)
            {
                DateTime date = DateTime.Today.AddDays(i);
                if (date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday)
                {
                    holidays.Add(date);
                }
            }

            // ê³µíœ´ì¼ ì¶”ê°€ (ì˜ˆì œ: 1ì›” 1ì¼, 12ì›” 25ì¼)
            holidays.Add(new DateTime(DateTime.Today.Year, 1, 1));
            holidays.Add(new DateTime(DateTime.Today.Year, 12, 25));

            return holidays;
        }

        private void ToggleHoliday(DateTime date)
        {
            if (Holidays.Contains(date))
            {
                Holidays.Remove(date);
            }
            else
            {
                Holidays.Add(date);
            }
            OnPropertyChanged(nameof(Holidays));
        }

        private void CheckMonitorState()
        {
            if (Holidays.Contains(DateTime.Today))
            {
                if (!_isMonitorOff)
                {
                    TurnMonitorOff();
                }
            }
            else
            {
                if (_isMonitorOff)
                {
                    TurnMonitorOn();
                }
            }
        }

        private void TurnMonitorOn()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
            _isMonitorOff = false;
        }

        private void TurnMonitorOff()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
            _isMonitorOff = true;
        }

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
ğŸ”¥ 2ï¸âƒ£ MainWindow.xaml (UI)
xml
ì½”ë“œ ë³µì‚¬
<Window x:Class="MonitorControlApp.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MonitorControlApp.ViewModels"
        Title="ëª¨ë‹ˆí„° ìë™ ON/OFF" Height="400" Width="600">
    <Window.DataContext>
        <local:MainViewModel/>
    </Window.DataContext>

    <Grid>
        <Calendar Name="CalendarControl" 
                  SelectedDatesChanged="CalendarControl_SelectedDatesChanged"
                  DisplayMode="Month"/>
    </Grid>
</Window>
ğŸ”¥ 3ï¸âƒ£ MainWindow.xaml.cs (ë‹¬ë ¥ ì´ë²¤íŠ¸ ì—°ê²°)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using MonitorControlApp.ViewModels;

namespace MonitorControlApp.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel ViewModel => DataContext as MainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            HighlightHolidays();
        }

        private void HighlightHolidays()
        {
            foreach (var date in ViewModel.Holidays)
            {
                CalendarControl.SelectedDates.Add(date);
            }
        }

        private void CalendarControl_SelectedDatesChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (var date in e.AddedItems.OfType<DateTime>())
            {
                ViewModel.ToggleHoliday(date);
            }

            HighlightHolidays();
        }
    }
}
ğŸ”¥ 4ï¸âƒ£ RelayCommand.cs (MVVMìš© ëª…ë ¹ì–´ ë°”ì¸ë”©)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Windows.Input;

namespace MonitorControlApp
{
    public class RelayCommand<T> : ICommand
    {
        private readonly Action<T> _execute;
        private readonly Func<T, bool> _canExecute;

        public RelayCommand(Action<T> execute, Func<T, bool> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute((T)parameter);
        }

        public void Execute(object parameter)
        {
            _execute((T)parameter);
        }

        public event EventHandler CanExecuteChanged;
        public void RaiseCanExecuteChanged() => CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }

    public class RelayCommand : RelayCommand<object>
    {
        public RelayCommand(Action execute, Func<bool> canExecute = null)
            : base(_ => execute(), canExecute == null ? (Func<object, bool>)null : _ => canExecute()) { }
    }
}
ğŸ“Œ ì£¼ìš” ê¸°ëŠ¥ ì •ë¦¬
âœ… ë‹¬ë ¥ì—ì„œ ë‚ ì§œ í´ë¦­ ì‹œ ë…¸ë€ìƒ‰ â†’ ì‰¬ëŠ” ë‚  ì„¤ì •ë¨
âœ… í† ìš”ì¼, ì¼ìš”ì¼, ê³µíœ´ì¼ ê¸°ë³¸ì ìœ¼ë¡œ ì‰¬ëŠ” ë‚  (ë…¸ë€ìƒ‰)
âœ… ì‰¬ëŠ” ë‚ ì´ë©´ ìë™ ëª¨ë‹ˆí„° OFF / ì…ë ¥ ì‹œ ON
âœ… ì¼í•˜ëŠ” ë‚ (í‰ì¼)ì´ë©´ ëª¨ë‹ˆí„° í•­ìƒ ì¼œì§
âœ… MVVM íŒ¨í„´ ì™„ë²½ ì¤€ìˆ˜ (ViewModel + Command ì‚¬ìš©)

ğŸš€ ìµœì¢… í…ŒìŠ¤íŠ¸ ì²´í¬ë¦¬ìŠ¤íŠ¸
 ë‹¬ë ¥ì—ì„œ í´ë¦­í•˜ë©´ ë…¸ë€ìƒ‰ìœ¼ë¡œ í‘œì‹œë¨
 í† /ì¼ìš”ì¼ & ê³µíœ´ì¼ ê¸°ë³¸ì ìœ¼ë¡œ ë…¸ë€ìƒ‰
 ì‰¬ëŠ” ë‚ ì´ë©´ ëª¨ë‹ˆí„° ìë™ OFF
 ì¼í•˜ëŠ” ë‚ ì´ë©´ ëª¨ë‹ˆí„° í•­ìƒ ON
 ì…ë ¥í•˜ë©´ ëª¨ë‹ˆí„° ì¦‰ì‹œ ON