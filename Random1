알겠습니다! TaskModel 내부의 복잡한 함수를 분할하여 각각의 파티(별도 클래스로) 나누어 관리하는 방식으로 변경하는 방법을 제안드립니다.

목표:
TaskModel 내부에 있는 복잡한 함수들을 별도의 TaskAction 클래스로 분리합니다.
각 TaskAction 클래스는 인터페이스를 구현하여 동일한 구조로 관리됩니다.
TaskQueue는 그대로 사용하여 순차적으로 작업을 실행합니다.
1. ITaskAction 인터페이스 정의
모든 작업(함수)을 공통의 인터페이스로 관리하기 위한 인터페이스를 정의합니다.

csharp
코드 복사
public interface ITaskAction
{
    Task ExecuteAsync(TaskModel taskModel, PLCClass plcInstance);  // 비동기 작업 실행
    string GetTaskName();  // 작업 이름을 반환 (툴팁 등에 사용)
}
2. 각 작업을 담당하는 클래스 정의
ITaskAction 인터페이스를 구현하여 각 작업을 별도의 클래스로 분리합니다.

csharp
코드 복사
public class TaskA : ITaskAction
{
    public async Task ExecuteAsync(TaskModel taskModel, PLCClass plcInstance)
    {
        // TaskModel의 변수를 변경
        taskModel.MAG_NO = "Task A - MAG_NO updated";

        // PLC 클래스를 통해 비동기 작업 실행
        await plcInstance.SendSignalAsync("Task A Signal Sent");

        // Task A 작업 처리
        await Task.Delay(1000);  // 작업 시뮬레이션
    }

    public string GetTaskName()
    {
        return "Task A";
    }
}

public class TaskB : ITaskAction
{
    public async Task ExecuteAsync(TaskModel taskModel, PLCClass plcInstance)
    {
        // TaskModel의 변수를 변경
        taskModel.PO_NO = "Task B - PO_NO updated";

        // PLC 클래스를 통해 비동기 작업 실행
        await plcInstance.SendSignalAsync("Task B Signal Sent");

        // Task B 작업 처리
        await Task.Delay(1500);  // 작업 시뮬레이션
    }

    public string GetTaskName()
    {
        return "Task B";
    }
}

// TaskC, TaskD, TaskE도 유사한 방식으로 구현
3. TaskModel에서 작업들을 관리
TaskModel에서 여러 작업을 초기화하고, 각각의 작업을 순차적으로 실행하는 방식으로 수정합니다.

csharp
코드 복사
public class TaskModel : ViewModelBase
{
    private PLCClass _plcInstance;  // PLC 인스턴스
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }  // 함수 상태 리스트
    public string Status { get; set; }   // 전체 작업 상태 (Pending, Running, Completed)
    private Stopwatch _stopwatch;  // 총 실행 시간 측정용
    public int TotalSeconds { get; set; }  // 총 소요 시간을 표시할 컬럼

    public TaskModel(PLCClass plcInstance)
    {
        _plcInstance = plcInstance;
        FunctionStatusList = new ObservableCollection<FunctionStatus>();  // 함수 상태 리스트 초기화
        Status = "Pending";
        _stopwatch = new Stopwatch();

        // 작업 시퀀스를 초기화
        InitializeFunctions(1);  // SequenceFlag = 1 (예시)
    }

    // 시퀀스 플래그에 따라 작업을 초기화
    private void InitializeFunctions(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                AddFunction(new TaskA(), Brushes.Gray);
                AddFunction(new TaskB(), Brushes.Gray);
                AddFunction(new TaskC(), Brushes.Gray);
                break;
            case 2:
                AddFunction(new TaskB(), Brushes.Gray);
                AddFunction(new TaskD(), Brushes.Gray);
                break;
            case 3:
                AddFunction(new TaskA(), Brushes.Gray);
                AddFunction(new TaskE(), Brushes.Gray);
                break;
        }
    }

    // 각 작업을 추가하는 메서드
    public void AddFunction(ITaskAction taskAction, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(taskAction.GetTaskName(), () => taskAction.ExecuteAsync(this, _plcInstance), initialColor);
        FunctionStatusList.Add(functionStatus);
    }

    // 작업 시작
    public async Task StartTask()
    {
        _stopwatch.Restart();
        Status = "Running";
        await ExecuteTaskSequence();
        Status = "Completed";
        TotalSeconds = (int)_stopwatch.Elapsed.TotalSeconds;
        _stopwatch.Stop();
    }

    // 작업 순차 실행
    private async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            Stopwatch functionStopwatch = new Stopwatch();
            functionStopwatch.Start();

            // 작업 실행 및 도형 색상 업데이트
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);

            functionStopwatch.Stop();
            functionStatus.ExecutionTime = $"{functionStopwatch.Elapsed.TotalSeconds:F2} seconds";
        }
    }

    // 작업 실행 중/완료 시 색상 업데이트
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 진행 중 색상
        });

        await task();

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 색상
        });
    }
}
4. FunctionStatus 클래스
각 함수의 상태(도형 색상, 실행 시간)를 관리하는 FunctionStatus 클래스는 이전과 동일하게 사용합니다.

csharp
코드 복사
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }
    public string ExecutionTime { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush initialColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = initialColor;
    }

    public void UpdateStatus(Brush color)
    {
        StatusColor = color;
        OnPropertyChanged(nameof(StatusColor));
    }
}
요약:
ITaskAction 인터페이스로 각 작업을 독립적으로 구현했습니다.
**TaskModel**에서 각 작업을 관리하며, 함수(작업)를 추가할 때 해당 작업을 실행하는 Func<Task>와 함께 관리합니다.
각 작업의 상태는 FunctionStatus를 통해 도형의 색상, 실행 시간 등의 상태를 관리합니다.
이 방식은 코드가 모듈화되어 각 작업을 독립적으로 구현할 수 있고, 작업의 흐름이 더욱 명확하게 관리됩니다.