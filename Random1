아래는 c:/prod_file_logs/의 하위 폴더까지 모두 탐색하여, 3일 이상 된 DetailCMD가 포함된 파일들을 처리하는 전체 코드입니다. 수정 사항을 명확히 반영하여, 하위 디렉토리를 모두 확인하고 지정한 조건에 맞는 파일을 수집하도록 했습니다.

python
코드 복사
import os
import csv
import re
from datetime import datetime, timedelta

# 디렉토리 경로 설정
directory_path = 'c:/prod_file_logs/'
output_directory = 'c:/Agent/'

# 3일 전 날짜 계산
three_days_ago = datetime.now() - timedelta(days=3)

# 출력할 최대 행 수
max_rows = 300000

# 정규 표현식 패턴 설정
time_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'  # 날짜와 시간 추출 패턴
key_pattern = r'고유키:[^\s]+'  # 고유키 추출 패턴 (공백 전까지)
send_value_pattern = r'보낸값:[^\s]+'  # 보낸값 추출 패턴 (공백 전까지)
recv_value_pattern = r'받은값:[^\s]+'  # 받은값 추출 패턴 (공백 전까지)

# CSV로 저장할 데이터를 담을 리스트
data_for_csv = []

# 디렉토리 및 하위 폴더 내 모든 파일을 재귀적으로 탐색
for root, dirs, files in os.walk(directory_path):
    for filename in files:
        # "DetailCMD"가 포함된 .txt 파일만 처리하며, 3일 전보다 이전에 생성된 파일만
        file_path = os.path.join(root, filename)
        if filename.endswith('.txt') and 'DetailCMD' in filename:
            file_creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
            
            if file_creation_time <= three_days_ago:
                with open(file_path, 'r', encoding='utf-8') as file:
                    lines = file.readlines()  # 파일의 모든 줄을 읽음
                    i = 0
                    
                    # 각 줄을 순회하면서 "보낸값"과 "받은값" 쌍 찾기
                    while i < len(lines):
                        # "보낸값" 줄을 찾음
                        send_match = re.search(send_value_pattern, lines[i])
                        
                        if send_match:
                            # "보낸값" 줄에서 시간, 고유키, 보낸값 추출
                            time_match = re.search(time_pattern, lines[i])
                            key_match = re.search(key_pattern, lines[i])
                            
                            if time_match and key_match:
                                # 시간과 고유키 추출
                                time_str = time_match.group()
                                unique_key = key_match.group().split(':')[1]  # 고유키 값만 추출
                                send_value = send_match.group().split(':')[1]  # 보낸값 값만 추출

                                # 다음 줄에서 "받은값" 추출
                                if i + 1 < len(lines):
                                    recv_match = re.search(recv_value_pattern, lines[i + 1])

                                if recv_match:
                                    recv_value = recv_match.group().split(':')[1]  # 받은값 값만 추출
                                    
                                    # 시간 형식을 "yyMMdd HHmmss"로 변환
                                    original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                                    formatted_time = original_time.strftime('%y%m%d %H%M%S')

                                    # 응답값의 길이 계산
                                    recv_length = len(recv_value)

                                    # 데이터 리스트에 추가 (시간, 고유키, 보낸값, 받은값, 받은값 길이)
                                    data_for_csv.append([formatted_time, unique_key, send_value, recv_value, recv_length])

                                    # 데이터가 max_rows만큼 모이면 정렬 후 CSV로 저장하고 종료
                                    if len(data_for_csv) >= max_rows:
                                        # length와 시간 순으로 정렬
                                        data_for_csv.sort(key=lambda x: (x[4], x[0]))

                                        # 파일 이름에 타임스탬프 추가
                                        timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
                                        output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')
                                        
                                        # CSV 파일로 저장
                                        with open(output_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
                                            csv_writer = csv.writer(csvfile)
                                            csv_writer.writerow(['Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length'])
                                            csv_writer.writerows(data_for_csv)
                                        exit()  # 스크립트 종료
                            
                            # "보낸값" 다음 줄로 이동
                            i += 2
                        else:
                            # "보낸값"이 없는 경우 다음 줄로 이동
                            i += 1

# 혹시 max_rows보다 적게 데이터가 모일 경우에 대비하여 최종 저장
if data_for_csv and len(data_for_csv) < max_rows:
    # length와 시간 순으로 정렬
    data_for_csv.sort(key=lambda x: (x[4], x[0]))

    # 파일 이름에 타임스탬프 추가
    timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
    output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')
    
    # CSV 파일로 저장
    with open(output_csv_path, 'w', newline='', encoding='utf-8') as csvfile:
        csv_writer = csv.writer(csvfile)
        csv_writer.writerow(['Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length'])
        csv_writer.writerows(data_for_csv)

print(f'\nCSV 파일 생성 완료: {output_csv_path}')
코드 설명
하위 폴더 탐색:

os.walk(directory_path)를 사용하여 c:/prod_file_logs/ 디렉토리의 모든 하위 폴더까지 재귀적으로 탐색합니다. 따라서 DetailCMD가 포함된 파일을 하위 폴더까지 모두 확인합니다.
파일 필터링 조건:

파일 이름에 DetailCMD가 포함된 .txt 파일을 대상으로, 3일 이상 지난 파일만 처리하도록 조건을 설정했습니다.
정렬 및 CSV 저장:

30만 행이 모일 때마다 length와 시간 순서로 정렬 후 저장하며, 파일이 끝나면 최종적으로 저장합니다.