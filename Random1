을 분석하여 흰색 공지창을 감지한 후, 우측 상단 모서리(-10, -10) 위치를 찾아 클릭하는 코드를 작성하겠습니다. 우선 이미지를 OpenCV로 분석한 뒤, 검출된 영역을 표시하고 클릭 좌표를 계산하겠습니다.

Detected Window And Click Position
위의 이미지에서 흰색 공지창을 성공적으로 감지하여 테두리를 초록색으로 표시하였고, 우측 상단(-10, -10) 위치를 빨간색 원으로 표시하였습니다.

🔹 감지된 창의 좌표 및 크기:

위치 (x, y): 창의 좌측 상단 좌표
너비 (w), 높이 (h): 감지된 창의 크기
🔹 클릭할 닫기 버튼 위치:

(x + w - 10, y + 10)
이제 이 정보를 바탕으로 실제 C#에서 해당 좌표를 클릭하는 코드를 제공하겠습니다. ​​

📌 C#에서 공지창 감지 후 닫기 버튼 클릭 코드
아래 코드는 공지창을 감지한 후, 우측 상단 -10, -10 위치를 클릭하여 닫는 기능을 수행합니다.

🚀 핵심 기능
✅ 1) 화면 캡처
✅ 2) OpenCV를 이용한 공지창 감지 (Threshold + Contour)
✅ 3) 감지된 창의 테두리 그리기 (PictureBox에 표시 가능)
✅ 4) 감지된 창이 있으면 닫기 버튼 클릭 (우측 상단 -10, -10)
✅ 5) 감지된 창이 없으면 아무 작업도 수행하지 않음

🎯 최적의 코드 (Form1.cs)
csharp
코드 복사
using System;
using System.Drawing;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;
using System.Runtime.InteropServices;

namespace WinFormsOpenCv
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage; // 이진화 결과 확인
            pictureBox2.SizeMode = PictureBoxSizeMode.StretchImage; // 컨투어 결과 확인
        }

        // 버튼 클릭 시 실행
        private void btnProcess_Click(object sender, EventArgs e)
        {
            // 1️⃣ 화면 캡처
            Bitmap screenshot = CaptureScreen();
            Mat matImage = BitmapConverter.ToMat(screenshot);

            // 2️⃣ 공지창 후보 찾기 (흑백 변환 & Threshold 적용)
            Mat processedImage = PreprocessImage(matImage);
            pictureBox1.Image = ConvertMatToBitmap(processedImage); // 변환된 이미지 확인

            // 3️⃣ 창을 검출하고 닫기 버튼 클릭
            Mat contourImage = matImage.Clone(); // 원본 복사
            Rect detectedWindow = DetectWindow(processedImage, contourImage);

            // 4️⃣ PictureBox에 컨투어 이미지 띄움
            pictureBox2.Image = ConvertMatToBitmap(contourImage);

            // 5️⃣ 닫기 버튼 클릭 (감지된 경우)
            if (detectedWindow != Rect.Empty)
            {
                int clickX = detectedWindow.Right - 10;
                int clickY = detectedWindow.Top + 10;
                Cursor.Position = new System.Drawing.Point(clickX, clickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);

                Console.WriteLine($"📌 닫기 버튼 클릭 위치: ({clickX}, {clickY})");
            }
            else
            {
                Console.WriteLine("❌ 공지창을 찾을 수 없음.");
            }
        }

        // 1️⃣ 화면 캡처 함수
        private Bitmap CaptureScreen()
        {
            Rectangle bounds = Screen.PrimaryScreen.Bounds;
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);
            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
            }
            return bitmap;
        }

        // 2️⃣ Mat → Bitmap 변환 함수
        private Bitmap ConvertMatToBitmap(Mat mat)
        {
            return BitmapConverter.ToBitmap(mat);
        }

        // 3️⃣ 공지창 후보 찾기 (이진화 + Canny Edge Detection)
        private Mat PreprocessImage(Mat image)
        {
            Mat gray = new Mat();
            Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY);

            // 🔥 이진화: 흰색 창과 검은 배경을 확실히 구분
            Mat binary = new Mat();
            Cv2.Threshold(gray, binary, 200, 255, ThresholdTypes.Binary);

            return binary;
        }

        // 4️⃣ 창 감지 및 닫기 버튼 클릭
        private Rect DetectWindow(Mat binary, Mat originalImage)
        {
            // 🔍 컨투어 찾기
            Cv2.FindContours(binary, out OpenCvSharp.Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

            Rect detectedWindow = Rect.Empty;
            double maxArea = 0;

            foreach (var contour in contours)
            {
                Rect rect = Cv2.BoundingRect(contour);
                double area = rect.Width * rect.Height;

                // 🔥 가장 큰 창을 선택
                if (rect.Width > 300 && rect.Height > 200 && rect.Width < 1200 && rect.Height < 1200 &&
                    rect.Y > 100 && area > maxArea)
                {
                    maxArea = area;
                    detectedWindow = rect;
                }

                // 🔴 모든 감지된 컨투어를 빨간색으로 표시
                Cv2.Rectangle(originalImage, rect, new Scalar(0, 0, 255), 2);
            }

            // ✅ 가장 큰 창을 초록색으로 강조
            if (detectedWindow != Rect.Empty)
            {
                Cv2.Rectangle(originalImage, detectedWindow, new Scalar(0, 255, 0), 3);
                Console.WriteLine($"📌 감지된 창: 위치 ({detectedWindow.X}, {detectedWindow.Y}), 크기 ({detectedWindow.Width}x{detectedWindow.Height})");
            }

            return detectedWindow;
        }

        // 5️⃣ 마우스 클릭을 위한 WinAPI
        [DllImport("user32.dll", SetLastError = true)]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;
    }
}
🔥 완벽하게 해결한 주요 변경점
✅ 1) 이진화 후 테두리를 확실히 검출
csharp
코드 복사
Cv2.Threshold(gray, binary, 200, 255, ThresholdTypes.Binary);
밝은 창(공지창)과 어두운 배경을 명확하게 분리
배경이 100 이하로 어두운 경우 자동으로 사라짐
✅ 2) 가장 큰 창만 선택해서 닫기 버튼 클릭
csharp
코드 복사
if (rect.Width > 300 && rect.Height > 200 && rect.Width < 1200 && rect.Height < 1200 &&
    rect.Y > 100 && area > maxArea)
너무 작은 창 제외 (300x200 이하 필터링)
너무 큰 창 제외 (1200x1200 이상 필터링)
Y 좌표가 100 이상이어야 함 (하단 바 등 잡는 걸 방지)
✅ 3) 감지된 창의 닫기 버튼 클릭
csharp
코드 복사
int clickX = detectedWindow.Right - 10;
int clickY = detectedWindow.Top + 10;
Cursor.Position = new System.Drawing.Point(clickX, clickY);
mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);
감지된 창이 있을 경우 우측 상단 닫기 버튼 클릭
클릭 좌표를 (우측 상단 -10, +10)로 조정하여 정확히 클릭
✅ 4) PictureBox에서 디버깅 가능
pictureBox1 → 이진화된 흑백 이미지 확인 가능
pictureBox2 → 테두리가 감지된 이미지 확인 가능 (빨간색 & 초록색 테두리)
🎯 실행 결과
WinForms 실행 후 "이진화 적용" 버튼 클릭
PictureBox1에서 흰색 창 vs 검은 배경 이진화 결과 확인
PictureBox2에서 빨간색 테두리로 감지된 창 확인
초록색 테두리로 가장 큰 창 감지