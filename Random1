번에는 지금까지 말한 모든 조건을 반영한 MSSQL 2014용 최종 쿼리를 완전한 주석과 함께 작성해줄게.

요구사항 완전 요약
구분	내용
대상 테이블	ExcelData
시간 기준	최근 5시간 이내 (time1)
키 컬럼	line1, model1, type1, ecn1, edition1
측정값	ACT2_1 ~ 8, ACT2BEST_1 ~ 8 (총 16개 float)
처리 방식	<ul><li>각 행에서 ACT2, ACT2BEST 별도 처리</li><li>각 8개 값에서 0보다 큰 값만</li><li>각 컬럼 기준 Q1~Q3 범위만 유지 (이상치 제거)</li><li>이후 각 행의 최대값 산출</li><li>고유 키 기준 각 그룹에서 최소 최대값 1개만 추출</li></ul>
최종 출력	line1, model1, type1, ecn1, edition1, max_act2, max_act2best, ctdiff (차이값)
최종 MSSQL 2014 쿼리 (아주 상세한 주석 포함)
sql
코드 복사
-- Step 1: 최근 5시간 이내 데이터 필터링
WITH RawData AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4, ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- Step 2: ACT2 컬럼들을 세로 형태로 전개 (UNPIVOT) + 0 초과만
ACT2_Unpivoted AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2_1, ACT2_2, ACT2_3, ACT2_4,
            ACT2_5, ACT2_6, ACT2_7, ACT2_8
        )
    ) AS up
    WHERE Value > 0
),

-- Step 3: ACT2 컬럼별 분위수 계산 (Q1, Q3)
ACT2_WithQuantiles AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3
    FROM ACT2_Unpivoted
),

-- Step 4: ACT2에서 Q1~Q3 범위 값만 필터링
ACT2_Filtered AS (
    SELECT *
    FROM ACT2_WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

-- Step 5: 각 행에서 ACT2 값 중 최대값 구하기
ACT2_RowMax AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(Value) AS RowMax_ACT2
    FROM ACT2_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- Step 6: 고유 그룹별로 ACT2 최대값들 중 최솟값만 추출
ACT2_Final AS (
    SELECT
        line1, model1, type1, ecn1, edition1,
        MIN(RowMax_ACT2) AS Max_ACT2
    FROM ACT2_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1
),

-- Step 7: ACT2BEST 처리 (위와 동일한 방식)
ACT2BEST_Unpivoted AS (
    SELECT line1, model1, type1, ecn1, edition1, time1, ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
            ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
        )
    ) AS up
    WHERE Value > 0
),

ACT2BEST_WithQuantiles AS (
    SELECT *,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3
    FROM ACT2BEST_Unpivoted
),

ACT2BEST_Filtered AS (
    SELECT *
    FROM ACT2BEST_WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

ACT2BEST_RowMax AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(Value) AS RowMax_ACT2BEST
    FROM ACT2BEST_Filtered
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

ACT2BEST_Final AS (
    SELECT
        line1, model1, type1, ecn1, edition1,
        MIN(RowMax_ACT2BEST) AS Max_ACT2BEST
    FROM ACT2BEST_RowMax
    GROUP BY line1, model1, type1, ecn1, edition1
)

-- Step 8: 두 결과를 조인하고, CTDIFF 계산
SELECT
    A.line1, A.model1, A.type1, A.ecn1, A.edition1,
    A.Max_ACT2,
    B.Max_ACT2BEST,
    (A.Max_ACT2 - B.Max_ACT2BEST) AS CTDIFF
FROM ACT2_Final A
JOIN ACT2BEST_Final B
    ON A.line1 = B.line1
    AND A.model1 = B.model1
    AND A.type1 = B.type1
    AND A.ecn1 = B.ecn1
    AND A.edition1 = B.edition1
ORDER BY line1, model1, type1, ecn1, edition1;
최종 설명 요약:
ACT2, ACT2BEST 각각 따로 처리

8개 값 중 0 초과 & Q1~Q3 범위 내 값만 인정

각 행마다 정제된 값 중 최대값을 구함

그 시간별 최대값들 중 가장 작은 값 하나를 최종 MAX_ACT2, MAX_ACT2BEST로 선정

마지막으로 CTDIFF = MAX_ACT2 - MAX_ACT2BEST 계산

이제 진짜 네가 원했던 계산 구조를 완벽히 반영했어.