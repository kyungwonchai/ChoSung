래는 상세한 주석을 포함한 FileWatcher.cs입니다. 각 코드 부분에 대한 상세한 설명을 주석으로 추가했습니다.

FileWatcher.cs (상세 주석 포함)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiWatcher
{
    // FileWatcher 클래스는 파일 시스템을 감시하고, 로그 파일의 변화를 처리하여 실시간으로 데이터를 업데이트하는 역할을 합니다.
    public class FileWatcher
    {
        // 파일 시스템 감시기(FileSystemWatcher)를 위한 객체
        private FileSystemWatcher _fileWatcher;

        // 감시할 로그 파일의 디렉토리 경로 (실제 경로를 지정)
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 감시할 파일의 이름 패턴을 정규식으로 정의
        // 파일 이름 형식 예: "xxx.xxx.xxx.xxx_M4OIxxxxx_gumixxxx_12.log" (마지막 두 자리는 날짜)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 주기적으로 파일 변화를 체크할 타이머
        private DispatcherTimer _timer;

        // 마지막으로 감시한 파일의 경로를 저장 (중복 처리를 방지하기 위해)
        private string _lastMonitoredFile;

        // 현재 처리 중인 ProductOrder 객체 (PLAN Selected 라인에 해당하는 주문 정보를 저장)
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (제품 주문 정보를 담음)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // 마지막으로 감지된 PLAN Selected의 시간을 저장 (최근 2일 이내에 감지 여부를 확인하기 위함)
        private DateTime _lastPlanSelectedDate;

        // FileWatcher 생성자
        // 생성 시 감시할 파일 목록과 주기적인 파일 변화를 처리하는 타이머를 설정합니다.
        public FileWatcher(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders; // MainViewModel에서 전달된 ObservableCollection과 바인딩

            // FileSystemWatcher 객체 초기화 및 설정
            _fileWatcher = new FileSystemWatcher
            {
                Path = _logDirectory, // 감시할 디렉토리 경로
                Filter = "*.log", // 로그 파일만 감시 (확장자가 .log인 파일)
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName | NotifyFilters.Size // 파일 수정, 생성, 크기 변경 감시
            };

            // 파일이 변경되거나 생성되면 OnChanged 이벤트 핸들러 호출
            _fileWatcher.Changed += OnChanged;
            _fileWatcher.Created += OnChanged;
            _fileWatcher.EnableRaisingEvents = true; // 파일 감시 시작

            // 주기적으로 파일 변화를 체크할 타이머 설정 (1초 간격)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 이벤트 발생
            };
            _timer.Tick += CheckLatestFile; // 매 Tick마다 파일을 체크하는 메소드 호출
            _timer.Start(); // 타이머 시작

            // 프로그램 시작 시점을 기준으로 마지막 PLAN Selected 감지 시간을 초기화
            _lastPlanSelectedDate = DateTime.Now;
        }

        // 파일이 변경되거나 생성되면 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            // 파일 이름이 지정된 정규식 패턴에 맞는지 확인
            if (!Regex.IsMatch(e.Name, _filePattern)) return;

            // 최근에 수정된 파일 경로를 가져옴
            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                // 최근에 감시한 파일과 다른 경우 해당 파일 처리
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile);
            }
        }

        // 지정된 경로에서 가장 최근에 수정된 파일의 경로를 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 지정된 경로에서 로그 파일을 가져오고 정규식 패턴에 맞는 파일만 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일만 선택
                .OrderByDescending(f => f.LastWriteTime) // 최근 수정된 파일부터 정렬
                .ToList();

            // 가장 최근에 수정된 파일의 경로를 반환
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일 내용을 읽고 각 줄을 처리하는 메소드
        private void ReadLogFile(string filePath)
        {
            // 파일의 모든 줄을 읽고 각 줄을 처리
            var lines = File.ReadAllLines(filePath);
            foreach (var line in lines)
            {
                ProcessLogLine(line, filePath); // 각 줄을 처리하는 메소드 호출
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        // 파일 경로에서 날짜(day)를 추출하고 PLAN Selected 라인을 감지하여 주문 정보를 업데이트
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 마지막 두 글자를 추출하여 day 값을 가져옴 (확장자 앞의 두 자리)
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 마지막 두 글자 추출 (예: "12")

            // 현재 연도와 월을 구해서 yyyyMMdd 형식으로 날짜를 조합
            string currentYearMonth = DateTime.Now.ToString("yyyyMM");
            string fullDate = currentYearMonth + dayString; // 예: "20230912" (2023년 9월 12일)

            // PLAN Selected 라인 감지 (주문이 선택된 시점)
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 나눔
                string productOrder = splitLine[1]; // 두 번째 값이 제품 주문 번호

                // 현재 처리 중인 주문이 없거나 이전 주문과 다를 경우 새로운 주문으로 처리
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    // 최근 2일 이내에 PLAN Selected가 감지되지 않은 경우에만 새로운 주문을 처리
                    if (DateTime.Now.Subtract(_lastPlanSelectedDate).TotalDays > 2)
                    {
                        // 새로운 ProductOrder 객체 생성 및 초기화
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder, // 제품 주문 번호 설정
                            PDate = fullDate, // 파일 이름에서 추출한 날짜를 yyyyMMdd 형식으로 저장
                            POStatus = "wait" // 상태를 "대기(wait)"로 설정
                        };

                        // 새로운 주문을 ObservableCollection에 추가 (DataGrid에 실시간 반영)
                        _productOrders.Add(_currentProductOrder);
                    }

                    // 마지막 PLAN Selected 감지 시간을 현재 시간으로 업데이트
                    _lastPlanSelectedDate = DateTime.Now;
                }
            }
            // BasicModel을 감지하여 모델 정보를 저장
            else if (line.Contains("BasicModel"))
            {
                var modelData = line.Split(':')[1].Trim(); // ":"을 기준으로 나누어 모델 정보 추출
                _currentProductOrder.BasicModel = modelData; // 모델 정보 저장
            }
            // MB^ 라인을 감지하여 잔여 수량과 매거진 수량을 처리
            else if (line.Contains("MB^"))
            {
                var mbData = line.Split('^'); // "^"을 기준으로 나누어 데이터를 추출
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 저장
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 당 제품 수량 저장
            }
            // JB^ 라인을 감지하여 생산된 개수를 증가시킴
            else if (line.Contains("JB^"))
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가
            }
            // FNL^ 라인을 감지하여 상태를 적재로 변경
            else if (line.Contains("FNL^"))
            {
                _currentProductOrder.POStatus = "stack"; // 상태를 "적재(stack)"로 변경
            }
            // JD^ 라인을 감지하여 배출 처리
            else if (line.Contains("JD^"))
            {
                _currentProductOrder.POStatus = "out"; // 상태를 "배출(out)"로 변경
                ExecuteOutFunction(); // 배출 함수 호출
            }
        }

        // 배출 처리를 위한 함수 (구현 필요)
        private void ExecuteOutFunction()
        {
            // 배출 처리 로직을 여기에 구현할 수 있음
        }

        // 주기적으로 최근 파일을 체크하는 메소드 (타이머에 의해 호출)
        private void CheckLatestFile(object sender, EventArgs e)
        {
            // 최근에 수정된 파일의 경로를 가져옴
            string latestFile = GetLatestLogFile();
            if (latestFile != _lastMonitoredFile)
            {
                // 최근에 감시한 파일과 다른 경우 해당 파일 처리
                _lastMonitoredFile = latestFile;
                ReadLogFile(latestFile); // 파일 내용을 읽고 처리
            }
        }
    }

    // ProductOrderModel 클래스는 각 제품 주문의 정보를 저장하는 데이터 모델
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; } // 제품 주문 번호
        public string BasicModel { get; set; } // 제품 모델 정보
        public int PORemain { get; set; } // 잔여 수량
        public int MGCount { get; set; } // 매거진 당 제품 수량
        public int PCount { get; set; } // 생산된 제품 수량
        public string POStatus { get; set; } // 제품 주문 상태 (대기, 적재, 배출)
        public string PDate { get; set; } // 제품 주문 날짜 (yyyyMMdd 형식)
    }
}
주석 내용 설명
클래스 전반 설명: 각 클래스와 메소드가 어떤 역할을 하는지 전반적인 설명을 추가했습니다.
FileSystemWatcher와 타이머 설정: 파일 감시기의 설정과 주기적으로 파일 변화를 체크하는 타이머의 역할을 설명했습니다.
로그 파일 처리: 파일을 읽어 PLAN Selected, BasicModel, MB^, JB^, FNL^, JD^ 등의 키워드를 감지하여 적절히 처리하는 과정에 대한 상세한 설명을 추가했습니다.
날짜 처리: 파일 이름에서 마지막 두 글자를 추출해 날짜(yyyyMMdd)로 변환하는 과정을 설명했습니다.
최근 2일 이내에 PLAN Selected 감지 여부 처리: 마지막 PLAN Selected 감지 시간을 확인하고, 2일 이내에 감지되지 않은 경우에만 새로운 주문을 처리하도록 하는 로직을 주석으로 설명했습니다.
이제 각 부분의 역할과 기능이 주석을 통해