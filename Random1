아, 정말 죄송합니다! 제가 드린 edit_post.html 코드를 적용하셨는데도 비밀번호 입력창이 제대로 나타나지 않는다니, 정말 답답하시겠네요. 사용자님 말씀이 맞습니다. 체크박스만 있고 암호를 입력하는 곳이 없다면 제대로 암호를 설정할 수가 없죠. 제가 뭔가 중요한 부분을 놓치고 있거나 설명이 부족했던 것 같습니다.

"비밀번호 보호" 체크박스를 클릭했을 때 비밀번호 입력창이 나타나고, 체크를 해제하면 사라지도록 하는 것은 JavaScript가 담당합니다. 만약 이 부분이 동작하지 않는다면, JavaScript 코드에 문제가 있거나 HTML 요소의 ID가 일치하지 않을 가능성이 큽니다.

다시 한번, edit_post.html 파일의 전체 코드를 점검하고, 특히 JavaScript 부분을 확실하게 수정하여 드리겠습니다. 이 코드로 파일을 완전히 대체해 보시고, 그래도 문제가 지속된다면 브라우저의 JavaScript 콘솔 오류를 확인해야 합니다.

templates/edit_post.html (JavaScript 부분 중점 수정 및 전체 코드)

HTML

{% extends "base.html" %}

{% block title %}{{ '게시글 수정' if post else '새 게시글 작성' }} - 나의 게시판{% endblock %}

{% block head_extra %}
    <script src="{{ url_for('static', filename='tinymce/tinymce.min.js') }}" referrerpolicy="origin"></script>
{% endblock %}

{% block content %}
<div class="container-fluid mt-4"> {# 또는 이전에 사용하시던 container 클래스 #}
    <h2>{{ '게시글 수정' if post else '새 게시글 작성' }}</h2>
    <form method="POST" action="{{ url_for('edit_post', slug=post.slug) if post else url_for('new_post') }}">
        <div class="form-group">
            <label for="title">제목</label>
            <input type="text" class="form-control" id="title" name="title" value="{{ title or (post.title if post else '') }}" required>
        </div>

        <div class="form-group">
            <label for="category_id">카테고리</label>
            <select class="form-control" id="category_id" name="category_id">
                <option value="">-- 카테고리 선택 안 함 --</option>
                {% for category_item in categories %}
                    <option value="{{ category_item.id }}" {% if selected_category_id and category_item.id == selected_category_id|int %}selected{% endif %}>
                        {{ category_item.name }}
                    </option>
                {% endfor %}
            </select>
        </div>

        {# --- 게시글 비밀번호 설정 --- #}
        <div class="form-group form-check">
            <input type="checkbox" class="form-check-input" id="is_password_protected_checkbox" name="is_password_protected" value="y"
                   {% if post and post.is_password_protected %}checked{% endif %}>
            <label class="form-check-label" for="is_password_protected_checkbox">이 글을 비밀번호로 보호합니다.</label>
        </div>

        {# 초기 display 상태는 Jinja 템플릿으로 서버에서 전달된 값에 따라 설정 #}
        <div id="password_fields_container" style="display: {% if post and post.is_password_protected %}block{% else %}none{% endif %};">
            <div class="form-group">
                <label for="post_password_input">비밀번호 설정/변경</label>
                <input type="password" class="form-control" id="post_password_input" name="post_password" placeholder="새 비밀번호 입력 (변경 시에만)">
                <small class="form-text text-muted">
                    비밀번호를 설정하거나 변경하려면 여기에 입력하세요. 기존 비밀번호를 유지하려면 비워두세요.
                    보호를 해제하려면 위 체크박스를 해제하세요.
                </small>
            </div>
        </div>
        {# --- 게시글 비밀번호 설정 끝 --- #}

        <div class="form-group">
            <label for="content">내용</label>
            <textarea class="form-control" id="content" name="content" rows="15">{{ content or (post.content if post else '') }}</textarea>
        </div>
        <button type="submit" class="btn btn-primary">저장</button>
        <a href="{{ url_for('index') }}" class="btn btn-secondary">취소</a>
    </form>
</div>
{% endblock %}

{% block scripts_extra %}
<script>
document.addEventListener('DOMContentLoaded', function () {
    // TinyMCE 초기화
    tinymce.init({
        selector: 'textarea#content',
        plugins: 'preview importcss searchreplace autolink autosave save directionality code visualblocks visualchars fullscreen image link media template codesample table charmap pagebreak nonbreaking anchor insertdatetime advlist lists wordcount help charmap quickbars emoticons accordion',
        menubar: 'file edit view insert format tools table help',
        toolbar: 'undo redo | accordion accordionremove | blocks fontfamily fontsize | bold italic underline strikethrough | align numlist bullist | link image media table | lineheight outdent indent| forecolor backcolor removeformat | charmap emoticons | code fullscreen preview | save print | pagebreak anchor codesample | ltr rtl',
        height: 600,
        language: 'ko_KR',
        automatic_uploads: true,
        images_upload_url: "{{ url_for('upload_image') }}",
        file_picker_types: 'image',
        paste_data_images: true,
        images_upload_handler: function (blobInfo, progress) {
            return new Promise((resolve, reject) => {
                const image_size_mb = blobInfo.blob().size / 1024 / 1024;
                const client_max_size_mb = 10; // 예시: 10MB

                if (image_size_mb > client_max_size_mb) {
                    reject({ 
                        message: '이미지 용량이 너무 큽니다 (' + image_size_mb.toFixed(1) + 'MB). 클라이언트 최대 허용 용량은 ' + client_max_size_mb + 'MB 입니다.', 
                        remove: true
                    });
                    return;
                }
                const xhr = new XMLHttpRequest();
                xhr.withCredentials = false;
                xhr.open('POST', "{{ url_for('upload_image') }}");
                xhr.upload.onprogress = (e) => {
                    if (e.lengthComputable) {
                        progress(e.loaded / e.total * 100);
                    }
                };
                xhr.onload = () => {
                    if (xhr.status < 200 || xhr.status >= 300) {
                        let errorMessage = 'HTTP Error: ' + xhr.status;
                        try {
                            const jsonError = JSON.parse(xhr.responseText);
                            if (jsonError && jsonError.error && jsonError.error.message) {
                                errorMessage = jsonError.error.message;
                            }
                        } catch (e) {
                            if (xhr.status === 413) {
                                 errorMessage = '파일이 너무 큽니다. 서버에서 요청을 거부했습니다 (HTTP 413).';
                            } else if (xhr.responseText && xhr.responseText.length < 300) {
                                errorMessage = `서버 오류: ${xhr.status} - ${xhr.responseText.substring(0,100)}`;
                            } else {
                                errorMessage = `서버에서 예상치 못한 응답을 받았습니다 (HTTP ${xhr.status}).`;
                            }
                        }
                        reject({ message: errorMessage, remove: true });
                        return;
                    }
                    try {
                        const json = JSON.parse(xhr.responseText);
                        if (!json || typeof json.location != 'string') {
                            reject({ message: '서버로부터 잘못된 JSON 응답을 받았습니다: ' + xhr.responseText, remove: true });
                            return;
                        }
                        resolve(json.location);
                    } catch (e) {
                        reject({ message: '서버 응답 처리 중 오류 발생 (JSON 파싱 실패): ' + e.message + ' 응답내용: ' + xhr.responseText.substring(0,100), remove: true });
                    }
                };
                xhr.onerror = () => {
                    reject({ message: '네트워크 오류로 이미지 업로드에 실패했습니다. 서버 연결을 확인해주세요.', remove: true });
                };
                const formData = new FormData();
                formData.append('file', blobInfo.blob(), blobInfo.filename());
                xhr.send(formData);
            });
        }
    });

    // --- 비밀번호 필드 표시/숨김 처리 JavaScript ---
    const protectionCheckbox = document.getElementById('is_password_protected_checkbox'); // ID 변경에 유의
    const passwordFieldsContainer = document.getElementById('password_fields_container'); // ID 변경에 유의
    // const passwordInput = document.getElementById('post_password_input'); // ID 변경에 유의, 필요시 사용

    function handlePasswordProtectionChange() {
        if (protectionCheckbox && passwordFieldsContainer) { // 요소들이 존재하는지 확인
            if (protectionCheckbox.checked) {
                passwordFieldsContainer.style.display = 'block';
            } else {
                passwordFieldsContainer.style.display = 'none';
                // 보호 해제 시 비밀번호 입력 필드 값 초기화 (선택 사항)
                // const pwdInput = document.getElementById('post_password_input');
                // if (pwdInput) {
                //    pwdInput.value = '';
                // }
            }
        }
    }

    if (protectionCheckbox) {
        protectionCheckbox.addEventListener('change', handlePasswordProtectionChange);
        // 페이지 로드 시 초기 상태는 HTML의 style 속성에 의해 이미 설정되어 있어야 합니다.
        // 만약 JavaScript로 초기 상태를 강제하고 싶다면 여기서 handlePasswordProtectionChange(); 호출.
        // 하지만 현재는 HTML style로 처리하므로 중복 호출 불필요.
    } else {
        console.error("ID 'is_password_protected_checkbox'를 가진 체크박스를 찾을 수 없습니다.");
    }
    // --- 비밀번호 필드 표시/숨김 처리 JavaScript 끝 ---
});
</script>
{% endblock %}
주요 변경 및 확인 사항:

HTML 요소 ID 변경 (혼동 방지 및 명확성):

체크박스 ID: is_password_protected -> is_password_protected_checkbox
비밀번호 필드들을 감싸는 div ID: password_fields -> password_fields_container
비밀번호 입력 필드 ID: post_password -> post_password_input (이렇게 ID를 조금 더 명확하게 변경하여 다른 요소와의 충돌 가능성을 줄였습니다.)
JavaScript 로직:

변경된 ID에 맞춰 JavaScript 코드 내의 document.getElementById(...) 부분도 수정했습니다.
handlePasswordProtectionChange 함수 (이전 togglePasswordFieldsVisibility)는 체크박스의 change 이벤트에 올바르게 연결됩니다.
함수 내에서 protectionCheckbox 와 passwordFieldsContainer 요소가 실제로 존재하는지 한번 더 확인하는 방어 코드를 추가했습니다.
작동 방식 설명:

페이지 로드 시:

password_fields_container div의 style="display: {% if post and post.is_password_protected %}block{% else %}none{% endif %};" 부분은 서버에서 전달된 post.is_password_protected 값에 따라 비밀번호 입력 칸을 처음부터 보여주거나 숨깁니다. (예: 기존에 비밀번호가 설정된 글을 수정하려고 열면 처음부터 비밀번호 칸이 보입니다.)
체크박스 클릭 시:

is_password_protected_checkbox를 클릭하면 change 이벤트가 발생합니다.
handlePasswordProtectionChange 함수가 호출됩니다.
이 함수는 체크박스가 현재 선택된 상태(checked)인지 확인합니다.
선택되어 있으면: password_fields_container.style.display = 'block'; 코드가 실행되어 비밀번호 입력 칸이 보이게 됩니다.
선택 해제되어 있으면: password_fields_container.style.display = 'none'; 코드가 실행되어 비밀번호 입력 칸이 숨겨집니다.
테스트 방법:

위 코드로 templates/edit_post.html 파일을 완전히 업데이트해주세요. (ID 변경된 부분 유의)
브라우저 강력 새로고침 (Ctrl+Shift+R 또는 Cmd+Shift+R) 후 페이지를 다시 로드합니다.