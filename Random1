니다. 이어서 파일 목록의 16, 17, 18번째 파일(Zone.cs, LogViewModel.cs, MainViewModel.cs)의 전체 코드를 여기에 바로 작성해 드리겠습니다.

16. Models/Zone.cs

구역 마스터 데이터를 나타내는 모델 클래스입니다. (Models 폴더에 위치)

C#

using LockerManagementApp.Infrastructure; // ViewModelBase 사용 위해 추가
using System.Collections.Generic;
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Runtime.CompilerServices;

namespace LockerManagementApp.Models
{
    /// <summary>
    /// 구역 마스터 데이터 모델
    /// </summary>
    [Table("Zones")] // 데이터베이스 테이블 이름 명시
    public class Zone : ViewModelBase // ViewModelBase 상속하여 INotifyPropertyChanged 구현
    {
        private int _id;
        private string _name;

        [Key] // 기본 키
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)] // 자동 증가
        public int Id
        {
            get => _id;
            set => SetProperty(ref _id, value);
        }

        [Required(ErrorMessage = "구역 이름은 필수입니다.")] // 필수 값
        [StringLength(50)] // 문자열 길이 제한
        // 참고: UNIQUE 제약 조건은 SQL 스크립트에서 설정했습니다.
        public string Name
        {
            get => _name;
            set => SetProperty(ref _name, value); // 값 변경 시 UI 알림
        }

        // ToString() 재정의
        public override string ToString()
        {
            return Name ?? base.ToString();
        }

        // ViewModelBase에서 INotifyPropertyChanged 관련 구현 상속받음
    }
}
17. ViewModels/LogViewModel.cs

감사 로그 조회 화면을 위한 ViewModel 클래스입니다. (ViewModels 폴더에 위치)

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.Data.Entity; // EF6 네임스페이스
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 감사 로그 조회 ViewModel (DbContext 자체 생성 및 관리)
    /// </summary>
    public class LogViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context; // 이 ViewModel 전용 DbContext
        public ObservableCollection<AuditLog> AuditLogs { get; set; }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        public ICommand LoadLogsCommand { get; }

        /// <summary>
        /// LogViewModel 생성자 (DbContext 직접 생성)
        /// </summary>
        public LogViewModel()
        {
            try
            {
                _context = new LockerDbContext(); // 자신의 DbContext 생성
            }
            catch (Exception ex)
            {
                 MessageBox.Show($"[Log] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 StatusMessage = "[Log] DB 연결 오류!";
                 AuditLogs = new ObservableCollection<AuditLog>(); // 빈 컬렉션
                 LoadLogsCommand = new RelayCommand(_ => { }, _ => false); // 비활성화
                 return; // 초기화 중단
            }

            AuditLogs = new ObservableCollection<AuditLog>();
            LoadLogsCommand = new RelayCommand(async _ => await LoadLogsAsync());

            // DbContext 생성 성공 시 로그 로드
            if (_context != null)
            {
                _ = LoadLogsAsync();
            }
        }

        /// <summary>
        /// 감사 로그를 비동기적으로 로드합니다. (내부 _context 사용)
        /// </summary>
        public async Task LoadLogsAsync()
        {
            if (_context == null) return;
            StatusMessage = "로그 로딩 중...";
            try
            {
                // AuditLogs 테이블에서 데이터를 가져옵니다.
                // 최신 로그가 가장 위에 표시되도록 Timestamp 기준으로 내림차순 정렬합니다.
                // AsNoTracking()을 사용하여 읽기 전용 성능 향상
                var logs = await _context.AuditLogs
                                         .OrderByDescending(log => log.Timestamp)
                                         .Take(1000) // 성능을 위해 최근 1000개만 로드 (필요 시 조정)
                                         .AsNoTracking()
                                         .ToListAsync();

                AuditLogs.Clear(); // 기존 목록을 지웁니다.
                foreach (var log in logs) // 로드된 로그를 ObservableCollection에 추가합니다.
                {
                    AuditLogs.Add(log);
                }
                StatusMessage = $"총 {AuditLogs.Count}개의 로그를 로드했습니다.";
            }
            catch (Exception ex)
            {
                // 오류 발생 시 상태 메시지 업데이트 및 사용자 알림
                StatusMessage = $"로그 로딩 오류: {ex.Message}";
                MessageBox.Show($"{StatusMessage}\n\n데이터베이스 연결 및 로그 테이블 상태를 확인하세요.", "로그 로딩 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    // 관리되는 리소스 해제 (DbContext)
                    _context?.Dispose();
                }
                disposed = true;
            }
        }
        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
18. ViewModels/MainViewModel.cs

메인 윈도우의 ViewModel입니다. 사물함 관리, 마스터 키 확인, 마스터 데이터 창 열기 등의 기능을 담당합니다. (ViewModels 폴더에 위치)

C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views; // MasterDataWindow 참조 위해 추가
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 윈도우(MainWindow)와 연결되는 주 ViewModel 클래스입니다.
    /// 각 ViewModel이 독립적인 DbContext를 사용합니다.
    /// (.NET Framework 4.8 버전 - 최종)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";

        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;

        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;

        // 자식 ViewModel 인스턴스 (LogViewModel만 유지 - 필요없다면 이 부분도 제거)
        public LogViewModel LogVM { get; private set; }

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>();
            _allFloors = new ObservableCollection<Floor>();
            _allZones = new ObservableCollection<Zone>();
            _allSubParts = new ObservableCollection<SubPart>();
            _allAdministrators = new ObservableCollection<Administrator>();

            // LogViewModel 생성 (필요 없다면 이 줄 제거)
            LogVM = new LogViewModel();

            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync());
            OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow);

            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private async Task LoadInitialDataAsync() { await LoadMasterDataAsync(); await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null) return; StatusBarText = "사물함 목록 로딩 중..."; try { var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(); LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; } catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (_context == null) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; try { AllLockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync()); AllFloors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync()); AllZones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync()); AllSubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync()); AllAdministrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync()); StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; StatusBarText = "마스터 모드 활성화."; MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        /// <summary>
        /// 마스터 데이터 관리 창 열기
        /// </summary>
        private void OpenMasterDataWindow(object parameter)
        {
            try
            {
                // 새 MasterDataViewModel 인스턴스 생성 (자체 DbContext 사용)
                var masterDataVM = new MasterDataViewModel();
                var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow };
                masterDataWindow.ShowDialog(); // 모달로 표시

                // 창 닫힌 후 콤보박스 목록 새로고침
                _ = LoadMasterDataAsync();

                // ViewModel 리소스 정리
                masterDataVM.Dispose();
            }
            catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync() { if (_context == null) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: entry.CurrentValues.SetValues(entry.OriginalValues); entry.State = EntityState.Unchanged; break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; }
        #endregion

        #region Helper Methods
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); LogVM?.Dispose(); /* MasterDataVM은 OpenMasterDataWindow에서 관리 */ } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }