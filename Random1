청하신 대로 최근 10분 이내에 modelnumber에 해당하는 값이 존재하는지 행 수를 확인하여 판단하는 방식으로 수정한 checkModelInMySQL 함수입니다. 또한, isExecuting 플래그를 사용하여 중복 실행을 방지하도록 했습니다.

수정된 checkModelInMySQL 함수
kotlin
코드 복사
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import java.sql.SQLException
import java.sql.Timestamp
import java.time.LocalDateTime

private var isExecuting = false

private suspend fun checkModelInMySQL(qrCode: String): String? {
    return withContext(Dispatchers.IO) {
        if (isExecuting) {
            Log.d("MySQLConnection", "Already executing, skipping this call.")
            return@withContext null
        }

        isExecuting = true
        var connection: Connection? = null
        var preparedStatement: PreparedStatement? = null
        var resultSet: ResultSet? = null
        var result: String? = null

        try {
            // MySQL JDBC 드라이버 로드
            Class.forName("com.mysql.cj.jdbc.Driver")

            // MySQL 서버에 연결
            val url = "jdbc:mysql://10.244.122.122:3306/your_database_name?useSSL=false&serverTimezone=UTC"
            connection = DriverManager.getConnection(url, "abc", "1233445")

            // 첫 번째 쿼리: smd.management_mobile_mainseet에서 modelnumber 정보 조회
            val query1 = "SELECT district, at, modelnumber FROM smd.management_mobile_mainseet WHERE modelnumber = ?"
            preparedStatement = connection.prepareStatement(query1)
            preparedStatement.setString(1, qrCode)
            resultSet = preparedStatement.executeQuery()

            if (resultSet.next()) {
                val district = resultSet.getString("district")
                val at = resultSet.getString("at")
                val modelnumber = resultSet.getString("modelnumber")
                result = "District: $district, At: $at, Model: $modelnumber"

                // 두 번째 쿼리: 최근 10분 이내에 해당 modelnumber로 체크된 기록이 있는지 확인
                val query2 = """
                    SELECT COUNT(*) as count FROM smd.management_mobile_checksheet 
                    WHERE modelnumber = ? AND check_time > ?
                """.trimIndent()
                preparedStatement = connection.prepareStatement(query2)
                preparedStatement.setString(1, modelnumber)
                preparedStatement.setTimestamp(2, Timestamp.valueOf(LocalDateTime.now().minusMinutes(10)))

                val countResultSet = preparedStatement.executeQuery()

                var shouldInsert = true

                if (countResultSet.next()) {
                    val count = countResultSet.getInt("count")
                    if (count > 0) {
                        shouldInsert = false
                    }
                }

                // 10분 이내에 기록이 없다면 새로운 레코드를 삽입
                if (shouldInsert) {
                    val insertQuery = """
                        INSERT INTO smd.management_mobile_checksheet 
                        (depart, part, floor, district, at, model, modelnumber, type, checkidnum, checkname, check_time) 
                        VALUES ('00000000', '00000000', '00000000', ?, ?, '00000000', ?, '00000000', '00000000', 'mobile', ?)
                    """.trimIndent()

                    preparedStatement = connection.prepareStatement(insertQuery)
                    preparedStatement.setString(1, district)
                    preparedStatement.setString(2, at)
                    preparedStatement.setString(3, modelnumber)
                    preparedStatement.setTimestamp(4, Timestamp.valueOf(LocalDateTime.now()))
                    preparedStatement.executeUpdate()

                    result += " - New record inserted"
                } else {
                    result += " - No insertion, recent check_time is within 10 minutes"
                }
            }

        } catch (e: SQLException) {
            e.printStackTrace()
            result = "SQL error: ${e.message}"
        } catch (e: ClassNotFoundException) {
            e.printStackTrace()
            result = "JDBC Driver not found: ${e.message}"
        } catch (e: Exception) {
            e.printStackTrace()
            result = "Unexpected error: ${e.message}"
        } finally {
            try {
                resultSet?.close()
                preparedStatement?.close()
                connection?.close()
            } catch (e: SQLException) {
                e.printStackTrace()
            }
            isExecuting = false // 작업 완료 후 플래그를 다시 false로 설정
        }

        return@withContext result
    }
}
주요 변경 사항:
최근 10분 이내의 기록 확인:

SELECT COUNT(*) as count 쿼리를 사용하여 modelnumber에 대해 최근 10분 이내의 check_time이 존재하는지 확인합니다.
check_time > ? 조건을 사용하여 최근 10분 내의 데이터를 조회합니다.
삽입 조건 판단:

count 값이 0보다 크면 최근 10분 내에 이미 기록이 있는 것이므로 shouldInsert를 false로 설정합니다.
기록이 없다면(count == 0), 새 레코드를 삽입합니다.
isExecuting 플래그:

함수가 실행 중인지 확인하고, 실행 중이라면 중복 실행을 방지합니다.
결론
이 코드는 modelnumber에 대해 최근 10분 이내에 기록이 있는지 확인하고, 기록이 없는 경우에만 데이터를 삽입합니다. 이를 통해 중복 삽입을 방지할 수 있습니다. 추가적인 질문이 있거나 더 도움이 필요하시면 언제든지 말씀해 주