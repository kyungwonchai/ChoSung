령어 구성과 응답 형식에 대한 요구사항을 명확히 이해했습니다. 주소와 값 사이에 붙는 형식을 반영하여 명령어 생성 로직을 조정하겠습니다. 또한, 응답 메시지 예시를 제공해주셨기 때문에 응답 처리 로직도 그에 맞게 수정할 수 있습니다. 아래는 전체 코드에서 필요한 수정 사항을 반영한 버전입니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

public class PlcMutocolCommunication
{
    private SerialPort _serialPort;
    private const int _timeout = 30000; // 30초 타임아웃

    public PlcMutocolCommunication(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate);
        _serialPort.DataBits = 8;
        _serialPort.Parity = Parity.None;
        _serialPort.StopBits = StopBits.One;
        _serialPort.ReadTimeout = _timeout;
        _serialPort.WriteTimeout = _timeout;
    }

    public void OpenPort()
    {
        if (!_serialPort.IsOpen)
        {
            _serialPort.Open();
        }
    }

    public void ClosePort()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }

    public async Task<string> ReadAsync(string address, bool waitForResponse)
    {
        string command = CreateReadCommand(address);
        await WriteCommandAsync(command);

        if (waitForResponse)
        {
            string response = await ReadResponseAsync();
            return response.StartsWith("%01$RD") ? "읽기 성공" : "읽기 실패";
        }
        return "응답 없음 (대기 안 함)";
    }

    public async Task<string> WriteAsync(string address, string value, bool waitForResponse)
    {
        string command = CreateWriteCommand(address, value);
        await WriteCommandAsync(command);

        if (waitForResponse)
        {
            string response = await ReadResponseAsync();
            return response.StartsWith("%01$WD") ? "쓰기 성공" : "쓰기 실패";
        }
        return "응답 없음 (대기 안 함)";
    }

    private async Task WriteCommandAsync(string command)
    {
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        await _serialPort.BaseStream.WriteAsync(commandBytes, 0, commandBytes.Length);
    }

    private async Task<string> ReadResponseAsync()
    {
        byte[] buffer = new byte[256];
        int bytesRead = await _serialPort.BaseStream.ReadAsync(buffer, 0, buffer.Length);
        return Encoding.ASCII.GetString(buffer, 0, bytesRead);
    }

    private string CreateWriteCommand(string address, string value)
    {
        string plcAddress = FormatAddress(address);
        string formattedValue = FormatValue(value);
        
        // 예: D2300에 1을 쓰면 %01#WDD02300023000100**
        string command = $"%01#WD{plcAddress}{plcAddress}{formattedValue}**";
        return command;
    }

    private string CreateReadCommand(string address)
    {
        string plcAddress = FormatAddress(address);
        
        // 읽기 명령어 예시: %01#RDD023000**
        string command = $"%01#RD{plcAddress}**";
        return command;
    }

    private string FormatAddress(string address)
    {
        if (int.TryParse(address.Substring(1), out int numericAddress))
        {
            return numericAddress.ToString("D6"); // 주소를 6자리로 변환 (예: 2300 -> 023000)
        }
        return "000000"; // 잘못된 주소일 경우 기본값
    }

    private string FormatValue(string value)
    {
        if (int.TryParse(value, out int numericValue))
        {
            return numericValue.ToString("D4") + "00"; // 값이 숫자인 경우 4자리로 변환 (예: 1 -> 0100)
        }
        else
        {
            return "0000"; // 잘못된 값일 경우 기본값
        }
    }
}
이 코드는 PLC에 데이터를 쓸 때 사용자가 지정한 형식으로 명령을 구성하고, 자동으로 응답을 처리하는 로직을 포함합니다. WriteAsync 함수를 이용해 데이터를 전송하고, 필요에 따라 응답을 받아 성공 또는 실패를 판별할 수 있습니