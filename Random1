알겠습니다! 요청하신 내용을 종합하여, 응답을 N회 시도하고, N초 간격으로 재시도하며, 실패 시 큐 중지 및 알람을 띄우는 전체 코드를 제공하겠습니다. 또한 DB 기록과 XAML UI 구성, 모든 C# 코드를 함께 제공합니다. 재시도 횟수와 간격은 변수로 지정하여 유연하게 처리할 수 있도록 구현하겠습니다.

구현 목표:
N회 응답 시도 (기본값 3회).
N초 간격으로 재시도 (기본값 2초).
응답 실패 시 큐 중지 및 알람 표시.
DB에 명령 상태 기록 (성공/실패 및 재시도 횟수 포함).
XAML을 통한 UI로 명령 상태와 프로그레스바를 시각적으로 표현.
1. DB 테이블 생성 스크립트
sql
코드 복사
CREATE TABLE CommandLog (
    Id INT PRIMARY KEY IDENTITY(1,1),
    CommandText NVARCHAR(255), -- 명령어 텍스트
    Status NVARCHAR(50),       -- 작업 상태 (Pending, Processing, Completed, Failed)
    Result INT,                -- 작업 결과 (1: 성공, 0: 실패)
    RetryCount INT,            -- 재시도 횟수
    Output NVARCHAR(MAX),      -- 명령의 결과 또는 오류 메시지
    Timestamp DATETIME DEFAULT GETDATE() -- 작업 완료 시간
);
DB 설명:
CommandLog 테이블은 각 명령의 상태와 결과, 재시도 횟수 및 응답 메시지를 기록합니다.
2. DatabaseHelper.cs
csharp
코드 복사
using System;
using System.Data.SqlClient;
using System.Threading.Tasks;

public class DatabaseHelper
{
    private string connectionString = "your_connection_string_here"; // DB 연결 문자열

    // 명령과 결과를 DB에 기록하는 함수
    public async Task LogCommandToDatabase(string commandText, string status, int result, int retryCount, string output)
    {
        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            await connection.OpenAsync();

            string query = "INSERT INTO CommandLog (CommandText, Status, Result, RetryCount, Output, Timestamp) " +
                           "VALUES (@CommandText, @Status, @Result, @RetryCount, @Output, GETDATE())";

            using (SqlCommand command = new SqlCommand(query, connection))
            {
                command.Parameters.AddWithValue("@CommandText", commandText);  // 명령어 텍스트
                command.Parameters.AddWithValue("@Status", status);            // 상태
                command.Parameters.AddWithValue("@Result", result);            // 결과
                command.Parameters.AddWithValue("@RetryCount", retryCount);    // 재시도 횟수
                command.Parameters.AddWithValue("@Output", output);            // 결과/오류 메시지

                await command.ExecuteNonQueryAsync();
            }
        }
    }
}
DatabaseHelper 설명:
이 클래스는 명령의 상태, 결과, 재시도 횟수, 응답 메시지 등을 DB에 기록합니다.
3. CommandQueueViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public event PropertyChangedEventHandler PropertyChanged;

    private bool _isProcessing; // 현재 작업이 처리 중인지 여부를 나타냄
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 2000; // 기본 재시도 간격 2초 (2000ms)

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 큐에서 작업을 처리 중인지 상태 플래그
    }

    // 비동기 작업을 큐에 추가 (Task 반환) - 응답에 따라 중단 여부 결정
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, Func<string, bool> responseValidator)
    {
        EnqueueTask(asyncTask, commandText, responseValidator);
    }

    // 명령을 큐에 추가하는 함수 (Task<string> 반환)
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem { CommandText = commandText, Status = "Pending" };
        RemainingCommands.Add(newCommand);

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing";
            int retryCount = 0;

            while (retryCount < RetryLimit)
            {
                try
                {
                    string result = await taskFunc(); // 비동기 작업 실행
                    newCommand.Output = result;

                    if (responseValidator(result))
                    {
                        newCommand.Status = "Completed";
                        newCommand.Result = 1; // 성공 처리
                        await _dbHelper.LogCommandToDatabase(newCommand.CommandText, "Completed", newCommand.Result, retryCount, newCommand.Output);
                        return new CommandResult { Success = true, Message = result };
                    }
                    else
                    {
                        retryCount++;
                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed";
                            newCommand.Result = 0; // 실패 처리
                            await _dbHelper.LogCommandToDatabase(newCommand.CommandText, "Failed", newCommand.Result, retryCount, result);
                            ShowAlarm("Failed after maximum retries: " + result);
                            StopProcessing();
                            return new CommandResult { Success = false, Message = result };
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed";
                    newCommand.Result = 0;
                    await _dbHelper.LogCommandToDatabase(newCommand.CommandText, "Failed", newCommand.Result, retryCount, ex.Message);
                    ShowAlarm("Error occurred: " + ex.Message);
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }
            return new CommandResult { Success = false };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 명령 큐를 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue();
            await command(); // 큐에 있는 작업 실행
            UpdateProgress(); // 프로그레스바 상태 업데이트
        }

        _isProcessing = false; // 모든 작업 완료 후 처리 중 상태 해제
    }

    // 큐 처리 중단 함수
    private void StopProcessing()
    {
        commandQueue.Clear(); // 큐를 비우고 처리 중단
        _isProcessing = false; // 처리 중 상태 해제
    }

    // 알람 표시 (실제 구현은 UI 관련 코드로 연결)
    private void ShowAlarm(string message)
    {
        Console.WriteLine("ALARM: " + message); // 콘솔에 알람 출력 (UI에서 알람 처리)
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count;
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }

    public int Progress { get; private set; }
}
CommandQueueViewModel 설명:
RetryLimit와 RetryInterval: 재시도 횟수와 간격을 변수로 지정.
응답 검증 및 재시도: 응답이 정상적이지 않으면 최대 재시도 횟수만큼 재시도.
재시도 간격: 기본값으로 2초로 설정 (변경 가능).
실패 시 작업 중단: 재시도 횟수를 초과하면 큐를 중지하고 알람을 띄움.
4. CommandItem.cs
csharp
코드 복사
public class CommandItem
{
    public string CommandText { get; set; } // 명령어 또는 작업 설명
    public string Status { get; set; } // 작업 상태 (Pending, Processing, Completed, Failed)
    public string Output { get; set; } // 명령의 출력 또는 오류 메시지
    public int Result { get; set; } // 결과 (1: 성공, 0: 실패)
}
CommandItem 설명:
Output: 명령의 결과 또는 오류 메시지를 저장하여 사용자에게 전달.
Status: 작업의 상태 (Pending, Processing, Completed, Failed)를 저장.
5. ClassC (비동기 함수 및 응답 검증)
csharp
코드 복사
public class ClassC
{
    private readonly CommandQueueViewModel _commandQueue;

    public ClassC(CommandQueueViewModel commandQueue)
    {
        _commandQueue = commandQueue;
    }

    // FA 함수 (예시)
    public async Task<string> FA(string param)
    {
        await Task.Delay(500); // 비동기 작업 시뮬레이션
        return "FA Success Response"; // 정상 응답
    }

    // FA 응답 검증 함수
    private bool ValidateFAResponse(string response)
    {
        return response.Contains("Success"); // 응답이 'Success' 포함 여부 확인
    }

    // 큐에 FA 함수 실행 및 검증 추가
    public void EnqueueFA()
    {
        _commandQueue.AddAsyncTaskCommand(() => FA("Param1"), "Executing FA", ValidateFAResponse);
    }
}
ClassC 설명:
FA 응답 검증: FA 함수의 응답을 검증하여 정상적인 응답일 때만 작업을 계속 수행.
응답이 정상이 아닐 경우, 재시도 후 실패 처리.
6. XAML (UI)
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 남아 있는 명령을 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding CommandQueue.RemainingCommands}" HorizontalAlignment="Left" Height="300" VerticalAlignment="Top" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 명령 텍스트 -->
                        <TextBlock Text="{Binding CommandText}" Width="200"/>
                        <!-- 작업 상태 -->
                        <TextBlock Text=" 상태: " Width="70"/>
                        <TextBlock Text="{Binding Status}" Width="100"/>
                        <!-- 결과 -->
                        <TextBlock Text="{Binding Output}" Width="300"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 남아 있는 명령 수 시각적으로 표시) -->
        <ProgressBar VerticalAlignment="Top" Height="300" Width="30" Orientation="Vertical" Value="{Binding CommandQueue.Progress}" Maximum="10" HorizontalAlignment="Right" Margin="0,0,50,0"/>
    </Grid>
</Window>
XAML 설명:
ListBox: 명령의 상태와 결과를 표시.
ProgressBar: 큐에 남아 있는 명령의 개수를 시각적으로 표시.
결론
N회 응답 시도: 기본값 3회로 재시도, N초 간격으로 (기본 2초) 재시도 처리.
응답이 실패할 경우, 큐 중지 및 알람 표시.
DB에 작업 기록: 성공/실패, 재시도 횟수 및 결과 메시지 기록.
UI에서 명령 상태와 결과를 시각적으로 표시