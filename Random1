API 키를 통해서만 API 접근을 허용하도록 보안을 강화하는 것은 좋은 방법입니다. 클라이언트(호출자)가 요청 시 유효한 API 키를 제공해야만 API가 응답하도록 구현할 수 있습니다.

ASP.NET Core에서 이를 구현하는 가장 일반적이고 깔끔한 방법은 **사용자 지정 미들웨어(Custom Middleware)**를 사용하는 것입니다.

구현 단계:

1. API 키 저장 및 설정 (서버 - API 프로젝트)

appsettings.json (또는 appsettings.Production.json) 에 API 키 설정 추가:

실제 운영 환경에서는 보안을 위해 사용자 비밀(User Secrets), 환경 변수, Azure Key Vault 등 더 안전한 방법으로 키를 관리해야 합니다. 아래는 설정 구조 예시입니다.
JSON

{
  // ... 다른 설정들 ...

  "AllowedHosts": "*",
  "ConnectionStrings": {
    // ... 연결 문자열 ...
  },
  "ApiKeySettings": {
    "HeaderName": "X-API-Key", // 클라이언트가 키를 전달할 헤더 이름 (원하는 이름 사용 가능)
    "SecretApiKey": "MySuperSecretAndLongApiKey123!@#" // ★ 실제 키 값 - 절대로 소스코드나 appsettings에 직접 넣지 마세요! ★
  }
}
HeaderName: 클라이언트가 요청 헤더에 API 키를 담아 보낼 때 사용할 헤더의 이름입니다. X-API-Key가 일반적으로 많이 사용됩니다.
SecretApiKey: 서버가 유효하다고 인정하는 실제 API 키 값입니다. 이 값은 절대로 appsettings.json 파일에 직접 저장하지 마세요. 개발 중에는 '사용자 비밀 관리' 도구를 사용하고, 운영 서버에서는 환경 변수나 Azure Key Vault 같은 안전한 저장소를 사용해야 합니다. (이 예제에서는 설명을 위해 임시로 넣었습니다.)
2. API 키 검증 미들웨어 생성 (서버 - API 프로젝트)

API 프로젝트에 새 폴더(예: Middleware)를 만듭니다.

해당 폴더에 새 C# 클래스 파일(예: ApiKeyMiddleware.cs)을 추가하고 아래 코드를 작성합니다.

C#

using Microsoft.Extensions.Options; // IOptions 사용 시 필요
using System.Threading.Tasks;
using Microsoft.AspNetCore.Http;
using Microsoft.Extensions.Configuration; // IConfiguration 사용

namespace YourApiProjectName.Middleware // 네임스페이스는 프로젝트에 맞게 수정
{
    public class ApiKeyMiddleware
    {
        private readonly RequestDelegate _next;
        private readonly IConfiguration _configuration;
        private const string ApiKeyHeaderNameConfigKey = "ApiKeySettings:HeaderName"; // appsettings.json 키 경로
        private const string ApiKeyConfigKey = "ApiKeySettings:SecretApiKey";      // appsettings.json 키 경로

        public ApiKeyMiddleware(RequestDelegate next, IConfiguration configuration)
        {
            _next = next;
            _configuration = configuration;
        }

        public async Task InvokeAsync(HttpContext context)
        {
            // 설정에서 API 키 헤더 이름과 실제 키 값 가져오기
            var apiKeyHeaderName = _configuration.GetValue<string>(ApiKeyHeaderNameConfigKey);
            var expectedApiKey = _configuration.GetValue<string>(ApiKeyConfigKey); // 실제 키 값

            // 헤더 이름이나 기대하는 키 값이 설정되지 않았으면 오류 (설정 누락 방지)
            if (string.IsNullOrWhiteSpace(apiKeyHeaderName) || string.IsNullOrWhiteSpace(expectedApiKey))
            {
                // 로그 기록 권장
                context.Response.StatusCode = StatusCodes.Status500InternalServerError;
                await context.Response.WriteAsync("Error: API Key not configured on server.");
                return;
            }

            // 요청 헤더에서 API 키 값 추출 시도
            if (!context.Request.Headers.TryGetValue(apiKeyHeaderName, out var extractedApiKey))
            {
                // 헤더에 API 키가 없는 경우
                context.Response.StatusCode = StatusCodes.Status401Unauthorized; // 401 Unauthorized
                await context.Response.WriteAsync("API Key was not provided.");
                return;
            }

            // 추출된 키와 서버에 저장된 기대 키 비교
            // 중요: 실제 운영 환경에서는 보안 강화를 위해 고정 시간 비교(Constant-time comparison) 사용 고려
            if (!expectedApiKey.Equals(extractedApiKey))
            {
                // API 키가 유효하지 않은 경우
                context.Response.StatusCode = StatusCodes.Status401Unauthorized; // 401 Unauthorized
                await context.Response.WriteAsync("Unauthorized client.");
                return;
            }

            // API 키가 유효하면 다음 미들웨어 또는 엔드포인트로 요청 전달
            await _next(context);
        }
    }
}
3. 미들웨어 등록 (서버 - API 프로젝트 Program.cs)

Program.cs 파일을 열고 (또는 .NET 6 이전의 Startup.cs의 Configure 메서드), 미들웨어 파이프라인에 방금 만든 ApiKeyMiddleware를 등록합니다.

미들웨어 등록 위치가 중요합니다. 일반적으로 라우팅(app.UseRouting()) 이후, 인증/권한 부여(app.UseAuthentication(), app.UseAuthorization()) 및 엔드포인트 매핑(app.MapControllers()) 이전에 위치시키는 것이 좋습니다.

C#

// Program.cs (.NET 6 이상)

using YourApiProjectName.Middleware; // 추가한 미들웨어 네임스페이스

var builder = WebApplication.CreateBuilder(args);

// Add services to the container.
builder.Services.AddControllers();
// Learn more about configuring Swagger/OpenAPI at https://aka.ms/aspnetcore/swashbuckle
builder.Services.AddEndpointsApiExplorer();
builder.Services.AddSwaggerGen();

var app = builder.Build();

// Configure the HTTP request pipeline.
if (app.Environment.IsDevelopment())
{
    app.UseSwagger();
    app.UseSwaggerUI();
}

app.UseHttpsRedirection();

app.UseRouting(); // 라우팅 먼저

// ★★ 여기에 API 키 미들웨어 등록 ★★
app.UseMiddleware<ApiKeyMiddleware>();

// 필요하다면 인증/권한 부여 미들웨어는 이 다음에 위치
// app.UseAuthentication(); // 예시: JWT 인증 등 사용하는 경우
app.UseAuthorization();

app.MapControllers();

app.Run();
4. 클라이언트에서 API 키 전송 (예: WPF 애플리케이션)

API를 호출하는 클라이언트(WPF 앱 등)는 이제 모든 요청에 appsettings.json에서 설정한 헤더 이름(X-API-Key)으로 유효한 API 키 값을 포함하여 보내야 합니다.

WPF 앱의 HttpClient 호출 코드 수정 예시 (MainWindow.xaml.cs):

C#

using System.Net.Http;
using System.Net.Http.Headers; // 헤더 추가 위해 필요

// ... 다른 using 문 ...

public partial class MainWindow : Window
{
    private static readonly HttpClient client = new HttpClient();
    private const string ApiKeyHeader = "X-API-Key"; // API 설정과 동일한 헤더 이름
    private const string ApiKeyValue = "MySuperSecretAndLongApiKey123!@#"; // ★ 실제 키 값 - 클라이언트 측에서도 안전하게 관리 필요 ★

    public MainWindow()
    {
        InitializeComponent();
        // BaseAddress 설정 등은 이전과 동일
        client.BaseAddress = new Uri("https://localhost:7123/");
        client.DefaultRequestHeaders.Accept.Clear();
        client.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));

        // ★★ 기본 요청 헤더에 API 키 추가 (모든 요청에 적용됨) ★★
        // 주의: 이 방식은 동일한 HttpClient 인스턴스를 계속 사용할 때 유효합니다.
        // 요청마다 키를 다르게 보내야 하거나 더 세밀한 제어가 필요하면 아래 `CallApiButton_Click` 내부 방식 참고
        if (!client.DefaultRequestHeaders.Contains(ApiKeyHeader))
        {
             client.DefaultRequestHeaders.Add(ApiKeyHeader, ApiKeyValue);
        }
    }

    private async void CallApiButton_Click(object sender, RoutedEventArgs e)
    {
        string barcode = BarcodeTextBox.Text;
        // ... 입력값 검증 ...
        StatusTextBlock.Text = "API 호출 중...";

        try
        {
            // 만약 DefaultRequestHeaders에 추가하지 않았다면, 각 요청마다 헤더를 추가할 수도 있습니다.
            // var request = new HttpRequestMessage(HttpMethod.Get, $"api/RepairInfo/{barcode}");
            // request.Headers.Add(ApiKeyHeader, ApiKeyValue);
            // HttpResponseMessage response = await client.SendAsync(request);

            // DefaultRequestHeaders에 추가했다면 그냥 GetAsync 사용
            HttpResponseMessage response = await client.GetAsync($"api/RepairInfo/{barcode}");


            if (response.IsSuccessStatusCode)
            {
                // ... 성공 처리 (이전과 동일) ...
                StatusTextBlock.Text = "조회 완료";
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.Unauthorized) // 401 Unauthorized
            {
                // API 키가 없거나 틀렸을 때 서버가 401을 반환함
                StatusTextBlock.Text = "오류: API 키가 유효하지 않습니다. (401)";
            }
            else if (response.StatusCode == System.Net.HttpStatusCode.NotFound) // 404 Not Found
            {
                StatusTextBlock.Text = $"오류: 해당 바코드({barcode}) 정보를 찾을 수 없습니다. (404)";
            }
            else // 그 외 오류 상태 코드
            {
                StatusTextBlock.Text = $"오류 발생: {response.StatusCode}";
            }
        }
        // ... 예외 처리 (이전과 동일) ...
        catch (Exception ex)
        {
            StatusTextBlock.Text = $"오류: {ex.Message}";
        }
    }
}
클라이언트 측 키 관리: 클라이언트 코드(특히 WPF 같은 배포형 앱)에 API 키를 하드코딩하는 것도 안전하지 않습니다. 설정 파일 암호화, 사용자별 설정 저장 등 별도의 안전한 키 관리 방안이 필요합니다.
보안 고려 사항:

키 생성 및 관리: 예측 불가능하고 충분히 긴 API 키를 생성해야 합니다. 키를 정기적으로 교체(Rotation)하는 정책도 고려해야 합니다.
HTTPS 필수: API 키는 네트워크를 통해 평문으로 전송되므로, 반드시 HTTPS를 사용하여 통신을 암호화해야 합니다.
단일 키 vs 다중 키: 위 예제는 서버 전체에 적용되는 단일 API 키를 사용합니다. 클라이언트별로 다른 키를 발급하고 관리해야 한다면 데이터베이스 등을 사용하여 키를 저장하고 검증 로직을 더 복잡하게 구현해야 합니다.