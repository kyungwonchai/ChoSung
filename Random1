진심으로 죄송합니다. 제가 여러 파일에 걸쳐 코드를 드리면서 네임스페이스나 참조 관계에서 혼란을 드린 것 같습니다. 사용자님께서 MGSPBrokerService 프로젝트에서 CS0117 오류를 겪고 계신다면, 이는 대부분 MessageContract.cs 파일에 정의된 타입들을 다른 파일(예: BrokerCore.cs, ClientState.cs)에서 올바르게 참조하지 못해서 발생합니다.

특히 MessageContract.cs 파일의 네임스페이스를 MonitorControl.SharedModels로 통일하기로 했으므로, 이 네임스페이스를 사용하는 다른 파일들도 모두 using MonitorControl.SharedModels;를 상단에 추가해야 합니다.

MGSPBrokerService 프로젝트에서 MessageContract.cs 변경으로 인해 함께 수정되어야 할 주요 파일은 ClientState.cs와 BrokerCore.cs입니다. 이 두 파일의 전체 코드를 MonitorControl.SharedModels 네임스페이스를 사용하도록 수정하여 다시 드리겠습니다.

전제 조건:

이전에 드린 MessageContract.cs 파일 (네임스페이스가 MonitorControl.SharedModels로 된 버전)이 MGSPBrokerService 프로젝트의 Models 폴더에 정확히 위치해 있어야 합니다.
1. MGSPBrokerService/Models/MessageContract.cs (재확인용 - 이전 답변과 동일)

이 파일은 반드시 아래 내용과 같이 네임스페이스가 MonitorControl.SharedModels로 되어 있어야 합니다.

C#

// 파일 경로: MGSPBrokerService/Models/MessageContract.cs
namespace MonitorControl.SharedModels // <--- 이 네임스페이스를 사용합니다.
{
    using System;
    using System.Collections.Generic;

    public enum MessageType { /* ... (이전 답변 내용과 동일) ... */ }
    public class BrokerMessage { /* ... (이전 답변 내용과 동일) ... */ }
    public class AgentHelloPayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class UiControlAgentPayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class BrokerExecuteControlPayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class AgentCommandResultPayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class AgentStatusUpdatePayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class BrokerStatusInfoPayload { /* ... (이전 답변 내용과 동일) ... */ }
    public class LiveAgentInfoForUi { /* ... (이전 답변 내용과 동일) ... */ }
}
(주: 위 주석 처리된 부분은 이전 답변의 MessageContract.cs 전체 내용을 의미합니다. 동일한 내용이므로 생략했습니다.)

2. MGSPBrokerService/ClientManagement/ClientState.cs (수정된 전체 코드)

파일 상단에 using MonitorControl.SharedModels;를 추가하고, 코드 내에서 관련 타입을 사용할 때 네임스페이스를 명시하지 않도록 합니다.

C#

// MGSPBrokerService/ClientManagement/ClientState.cs
using System;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MGSPBrokerService.Services; // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // <<< MessageContract.cs의 네임스페이스 추가!

namespace MGSPBrokerService.ClientManagement
{
    public enum ClientType { Unknown, UiClient, AgentClient }

    public class ClientState : IDisposable
    {
        public TcpClient TcpClient { get; }
        public string ClientId { get; private set; } 
        public ClientType Type { get; private set; } = ClientType.Unknown;
        public NetworkStream Stream { get; }
        private readonly StreamReader _reader;
        private readonly StreamWriter _writer;
        private readonly ILoggingService _logger;
        // 콜백의 BrokerMessage 타입이 MonitorControl.SharedModels.BrokerMessage를 사용하도록 함
        private readonly Action<ClientState, BrokerMessage> _onMessageReceived; 
        private readonly Action<ClientState> _onDisconnected; 
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly object _writeLock = new object();
        private bool _isDisposed = false;

        public DateTime ConnectedTime { get; }
        public DateTime LastActivityTime { get; private set; }

        public ClientState(TcpClient tcpClient, ILoggingService logger, Action<ClientState, BrokerMessage> onMessageReceived, Action<ClientState> onDisconnected)
        {
            TcpClient = tcpClient;
            _logger = logger;
            _onMessageReceived = onMessageReceived;
            _onDisconnected = onDisconnected;
            
            Stream = tcpClient.GetStream();
            _reader = new StreamReader(Stream, Encoding.UTF8);
            _writer = new StreamWriter(Stream, Encoding.UTF8) { AutoFlush = true };
            
            ConnectedTime = DateTime.UtcNow;
            LastActivityTime = DateTime.UtcNow;
            ClientId = $"Temp_{Guid.NewGuid().ToString("N").Substring(0, 8)}"; 
        }

        public void StartReceiving(CancellationTokenSource parentCts)
        {
            if (_isDisposed) return;
            _cts = CancellationTokenSource.CreateLinkedTokenSource(parentCts.Token);
            _receiveLoopTask = Task.Run(ReceiveLoopAsync, _cts.Token);
        }

        public void IdentifyClient(string id, ClientType type)
        {
            ClientId = id;
            Type = type;
            _logger.Info($"Client identified: ID='{ClientId}', Type='{Type}', RemoteEndPoint='{TcpClient.Client.RemoteEndPoint}'");
        }

        private async Task ReceiveLoopAsync()
        {
            if (_isDisposed) return;
            _logger.Info($"Receive loop started for client: {ClientId} ({TcpClient.Client.RemoteEndPoint})");
            try
            {
                while (!_cts.IsCancellationRequested && TcpClient.Connected)
                {
                    string messageJson = await _reader.ReadLineAsync().ConfigureAwait(false);
                    if (messageJson == null) 
                    {
                        _logger.Info($"Client {ClientId} disconnected (stream closed by remote or local).");
                        break;
                    }
                    LastActivityTime = DateTime.UtcNow;

                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        // 여기서 BrokerMessage는 MonitorControl.SharedModels.BrokerMessage
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null)
                        {
                            _onMessageReceived?.Invoke(this, message);
                        }
                        else
                        {
                            _logger.Warn($"Failed to deserialize message from {ClientId}: {messageJson}");
                        }
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.Error($"JSON deserialization error from {ClientId}: {jsonEx.Message}. Received: {messageJson}", jsonEx);
                    }
                }
            }
            catch (IOException ioEx) when (_cts.IsCancellationRequested || !TcpClient.Connected)
            {
                 _logger.Info($"IOException in receive loop for {ClientId} (connection likely closed or cancelled): {ioEx.Message}");
            }
            catch (ObjectDisposedException)
            {
                _logger.Info($"Receive loop for {ClientId} terminated due to object disposal (likely during shutdown).");
            }
            catch (OperationCanceledException)
            {
                 _logger.Info($"Receive loop for {ClientId} cancelled.");
            }
            catch (Exception ex)
            {
                if(!_cts.IsCancellationRequested) // 취소 중이 아닐때만 에러로 기록
                    _logger.Error($"Unexpected error in receive loop for {ClientId}: {ex.Message}", ex);
            }
            finally
            {
                _logger.Info($"Receive loop ended for client: {ClientId}");
                if (!_isDisposed)
                {
                    _onDisconnected?.Invoke(this); // 연결 종료 알림
                    // Dispose(); // 여기서 Dispose 호출하면 재귀적 문제나 이중 Dispose 가능성. _onDisconnected에서 처리하거나, BrokerCore에서 관리.
                                  // 일단 ClientState의 메시지 수신 루프가 끝나면 _onDisconnected 콜백을 통해 BrokerCore에 알리고,
                                  // BrokerCore가 해당 ClientState를 목록에서 제거하고 Dispose를 호출하는 것이 더 안전한 흐름.
                }
            }
        }

        public async Task SendMessageAsync(BrokerMessage message) // BrokerMessage는 MonitorControl.SharedModels.BrokerMessage
        {
            if (_isDisposed || !TcpClient.Connected || _writer == null || (_cts != null && _cts.IsCancellationRequested))
            {
                _logger.Warn($"Cannot send message to {ClientId}. Client not connected, sending cancelled, or object disposed.");
                return;
            }
            try
            {
                string messageJson = JsonConvert.SerializeObject(message);
                lock(_writeLock) 
                {
                    if (TcpClient.Connected && _writer != null && !_isDisposed && (_cts == null || !_cts.IsCancellationRequested))
                    {
                        _writer.WriteLine(messageJson);
                    }
                    else
                    {
                         _logger.Warn($"Write cancelled or not possible for {ClientId} inside lock.");
                         return; // lock 안에서 바로 반환
                    }
                }
                LastActivityTime = DateTime.UtcNow;
            }
            catch (ObjectDisposedException)
            {
                _logger.Warn($"Attempted to send message to {ClientId} on a disposed stream/writer (Type: {message.Type}).");
                if (!_isDisposed) { _onDisconnected?.Invoke(this); }
            }
            catch (IOException ioEx)
            {
                _logger.Error($"IOException sending message to {ClientId} (Type: {message.Type}, connection may be lost): {ioEx.Message}", ioEx);
                 if (!_isDisposed) { _onDisconnected?.Invoke(this); }
            }
            catch (Exception ex)
            {
                _logger.Error($"Error sending message to {ClientId} (Type: {message.Type}): {ex.Message}", ex);
                 if (!_isDisposed) { _onDisconnected?.Invoke(this); }
            }
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            _logger.Info($"Disposing ClientState for {ClientId}.");
            _cts?.Cancel(); // 수신 루프 등 비동기 작업 취소
            
            // _receiveLoopTask가 완료될 때까지 잠시 기다릴 수 있지만, Dispose는 빠르게 반환되어야 함.
            // 루프는 CancellationToken을 확인하고 스스로 종료해야 함.

            try { _writer?.Dispose(); } catch { /* 무시 */ }
            try { _reader?.Dispose(); } catch { /* 무시 */ }
            try { Stream?.Dispose(); } catch { /* 무시 */ }
            try { TcpClient?.Close(); } catch { /* 무시 */ } // Close는 Dispose 호출
            
            _cts?.Dispose();
            // _logger.Info($"ClientState for {ClientId} fully disposed."); // 너무 잦은 로그일 수 있음
            GC.SuppressFinalize(this);
        }
    }
}
3. MGSPBrokerService/BrokerCore.cs (수정된 전체 코드)

이 파일도 상단에 using MonitorControl.SharedModels;를 추가하고, 관련 타입을 사용할 때 네임스페이스를 명시하지 않도록 합니다.

C#

// MGSPBrokerService/BrokerCore.cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using MGSPBrokerService.ClientManagement;
using MGSPBrokerService.Services; // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // <<< MessageContract.cs의 네임스페이스 추가!

namespace MGSPBrokerService
{
    public class BrokerCore : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly int _uiListenPort;
        private readonly int _agentListenPort;

        private TcpListener _uiListener;
        private TcpListener _agentListener;
        private CancellationTokenSource _serverCts;
        private bool _isDisposed = false;

        // Key: ClientState.ClientId (UI의 경우 임시 ID 후 UI가 보내는 식별자 또는 ConnectionId 기반, Agent는 AgentIdProvidedByApp)
        private readonly ConcurrentDictionary<string, ClientState> _uiClients = new ConcurrentDictionary<string, ClientState>();
        private readonly ConcurrentDictionary<string, ClientState> _agentClients = new ConcurrentDictionary<string, ClientState>();
        
        public static DateTime ServerStartTime { get; private set; }
        public static string BrokerVersion { get; set; } = "1.0.0-BrokerCore";


        public BrokerCore(ILoggingService logger, int uiPort, int agentPort)
        {
            _logger = logger;
            _uiListenPort = uiPort;
            _agentListenPort = agentPort;
            ServerStartTime = DateTime.UtcNow;
        }

        public void Start()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(BrokerCore));
            _serverCts = new CancellationTokenSource();
            _logger.Info($"MGSP Broker Core Service v{BrokerVersion} starting...");

            try
            {
                _uiListener = new TcpListener(IPAddress.Any, _uiListenPort);
                _uiListener.Start();
                _logger.Info($"UI Listener started on port {_uiListenPort}. Waiting for UI connections...");
                Task.Run(() => AcceptLoopAsync(_uiListener, ClientType.UiClient, _serverCts.Token), _serverCts.Token);

                _agentListener = new TcpListener(IPAddress.Any, _agentListenPort);
                _agentListener.Start();
                _logger.Info($"Agent Listener started on port {_agentListenPort}. Waiting for Agent connections...");
                Task.Run(() => AcceptLoopAsync(_agentListener, ClientType.AgentClient, _serverCts.Token), _serverCts.Token);

                _logger.Info("Broker Core Service running.");
            }
            catch (SocketException sockEx)
            {
                 _logger.Fatal($"Failed to start TCP listener(s). Port in use or permission issue? UI Port: {_uiListenPort}, Agent Port: {_agentListenPort}. Error: {sockEx.Message}", sockEx);
                 throw; 
            }
            catch (Exception ex)
            {
                _logger.Fatal($"Critical error during BrokerCore Start: {ex.Message}", ex);
                throw;
            }
        }

        private async Task AcceptLoopAsync(TcpListener listener, ClientType expectedClientType, CancellationToken token)
        {
            _logger.Info($"Accept loop started for {expectedClientType} on port {((IPEndPoint)listener.LocalEndpoint).Port}");
            while (!token.IsCancellationRequested)
            {
                try
                {
                    TcpClient connectedTcpClient = await listener.AcceptTcpClientAsync().ConfigureAwait(false);
                    string clientIp = ((IPEndPoint)connectedTcpClient.Client.RemoteEndPoint).ToString();
                    _logger.Info($"New connection for {expectedClientType} from {clientIp}");
                    
                    // ClientState 생성 시 바로 딕셔너리에 추가하지 않고, 첫 메시지(AgentHello 또는 UiClientHello)를 통해 ID 확정 후 추가.
                    // 임시 ID로 ClientState 객체는 생성.
                    var clientState = new ClientState(connectedTcpClient, _logger, HandleClientMessage, HandleClientDisconnect);
                    
                    // 임시 ID로 우선 등록 (나중에 IdentifyClient 호출 시 실제 ID로 업데이트된 ClientState 객체로 교체됨)
                    if (expectedClientType == ClientType.UiClient)
                    {
                        // UI 클라이언트는 연결 직후 바로 딕셔너리에 추가하고, Hello 메시지를 기다림 (또는 Hello 없이 사용)
                        // UI는 첫 메시지로 UiClientHello를 보내거나, Broker가 먼저 요청할 수 있음.
                        // 여기서는 UiClientHello를 기다린다고 가정하지 않고 바로 추가.
                        // ClientId는 임시 ID -> UiClientHello에서 실제 ID로 업데이트 (선택적)
                        clientState.IdentifyClient(clientState.ClientId, ClientType.UiClient); // 일단 임시 ID로 타입만 지정
                        _uiClients.TryAdd(clientState.ClientId, clientState); // 임시 ClientId를 키로 추가
                        _logger.Info($"Temporary UI client entry added: {clientState.ClientId}");
                        // 새 UI에 현재 Agent 목록과 서버 상태 전송
                        SendInitialDataToUi(clientState);
                    }
                    // Agent는 AgentHello를 통해 ID를 알려주므로, 그 때 _agentClients에 추가.

                    clientState.StartReceiving(_serverCts); // 메시지 수신 루프 시작
                }
                catch (ObjectDisposedException) when (token.IsCancellationRequested || _isDisposed)
                {
                    _logger.Info($"Listener for {expectedClientType} stopped as requested.");
                    break;
                }
                catch (SocketException sockEx) when (token.IsCancellationRequested || _isDisposed || (listener != null && !listener.Server.IsBound))
                {
                     _logger.Info($"Listener socket for {expectedClientType} closed during shutdown or error: {sockEx.Message}");
                     break;
                }
                catch (Exception ex)
                {
                    if (!token.IsCancellationRequested && !_isDisposed)
                    {
                        _logger.Error($"Error in {expectedClientType} accept loop: {ex.Message}", ex);
                        try { await Task.Delay(1000, token); } catch { /* ignore cancellation */ }
                    }
                }
            }
            _logger.Info($"Accept loop for {expectedClientType} stopped.");
        }
        
        private void SendInitialDataToUi(ClientState uiClientState)
        {
            // 현재 Agent 목록 전송
            var agentList = _agentClients.Values.Where(a => a.Type == ClientType.AgentClient && a.TcpClient.Connected)
                                           .Select(a => new LiveAgentInfoForUi { // LiveAgentInfoForUi 사용
                                                AgentIdProvidedByApp = a.ClientId, // AgentHello에서 설정된 ID
                                                IsOnline = true,
                                                // 초기 상태는 UI가 DB 정보와 조합해서 표시하거나, AgentHello 시 정보 활용
                                                // 여기서는 Broker가 아는 최소 정보만 전달
                                           }).ToList();
            var initialAgentListMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_InitialAgentList,
                Payload = JsonConvert.SerializeObject(agentList)
            };
            uiClientState.SendMessageAsync(initialAgentListMessage).ConfigureAwait(false);

            // 현재 서버 상태 전송
            SendBrokerStatusToUiInternal(uiClientState);
             _logger.Info($"Sent initial data (agents, status) to new UI client {uiClientState.ClientId}");
        }


        private void HandleClientMessage(ClientState sender, BrokerMessage message)
        {
            if (_isDisposed) return;
            _logger.Debug($"Message received from {sender.ClientId} ({sender.Type}): {message.Type}, CorrId: {message.CorrelationId}");
            switch (message.Type)
            {
                case MessageType.AgentHello:
                    HandleAgentHello(sender, message);
                    break;
                case MessageType.AgentStatusUpdate:
                    BroadcastAgentStatusToUis(sender, message);
                    break;
                case MessageType.AgentCommandResult:
                    ForwardAgentResultToSpecificUi(sender, message);
                    break;
                
                case MessageType.UiClientHello: // UI 클라이언트가 자신을 알리는 메시지 (선택적)
                    HandleUiClientHello(sender, message);
                    break;
                case MessageType.UiRequest_ControlAgent:
                    RelayControlCommandToAgent(sender, message);
                    break;
                case MessageType.UiRequest_GetBrokerStatus:
                    SendBrokerStatusToUiInternal(sender); // 특정 UI에게만 전송
                    break;
                case MessageType.UiRequest_GetInitialAgentList: // UI가 명시적으로 요청 시
                    SendInitialAgentListToUi(sender);
                    break;

                case MessageType.Ping:
                    HandlePing(sender, message);
                    break;
                default:
                    _logger.Warn($"Unhandled message type '{message.Type}' from {sender.ClientId} ({sender.Type})");
                    break;
            }
        }
        
        private void HandleUiClientHello(ClientState sender, BrokerMessage helloMessage)
        {
            // UiClientHelloPayload가 있다면 파싱하여 sender.ClientId를 업데이트 할 수 있음
            // 여기서는 단순히 로그만 남기고, sender는 이미 _uiClients에 임시 ID로 등록됨.
            // 만약 UI가 고유 ID를 보내온다면, _uiClients 딕셔너리의 키를 업데이트해야함 (복잡)
            // 여기서는 UI ClientId는 연결 시 생성된 임시 ID를 그대로 사용하거나,
            // UI가 사용자 ID 등을 보내면 그걸로 ClientState.ClientId를 업데이트.
            // 지금은 sender.ClientId (임시ID)를 그대로 사용.
            _logger.Info($"UiClientHello received from {sender.ClientId}. (No action defined for payload yet)");
            // 필요하다면 여기서 sender.IdentifyClient(newUiId, ClientType.UiClient) 호출.
            // 이 경우 _uiClients 딕셔너리 키 변경 처리 필요.
        }
        
        private void SendInitialAgentListToUi(ClientState uiClientState)
        {
             var agentList = _agentClients.Values.Where(a => a.Type == ClientType.AgentClient && a.TcpClient.Connected)
                                           .Select(a => new LiveAgentInfoForUi {
                                                AgentIdProvidedByApp = a.ClientId,
                                                IsOnline = true,
                                                // 추가 정보는 AgentHelloPayload나 AgentStatusUpdatePayload에서 가져와야 함.
                                                // 이 LiveAgentInfoForUi는 Broker가 Agent로부터 받은 최신 정보를 바탕으로 구성.
                                           }).ToList();
            var initialAgentListMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_InitialAgentList,
                Payload = JsonConvert.SerializeObject(agentList)
            };
            uiClientState.SendMessageAsync(initialAgentListMessage).ConfigureAwait(false);
            _logger.Info($"Sent initial agent list to UI client {uiClientState.ClientId} by request.");
        }


        private void HandleAgentHello(ClientState potentialAgentClient, BrokerMessage helloMessage)
        {
            AgentHelloPayload helloPayload = null;
            try
            {
                helloPayload = JsonConvert.DeserializeObject<AgentHelloPayload>(helloMessage.Payload);
            }
            catch (JsonException jsonEx)
            {
                _logger.Error($"Failed to parse AgentHello payload from {potentialAgentClient.ClientId}: {jsonEx.Message}. Payload: {helloMessage.Payload}", jsonEx);
                potentialAgentClient.Dispose(); return;
            }

            if (helloPayload == null || string.IsNullOrWhiteSpace(helloPayload.AgentIdProvidedByApp))
            {
                _logger.Warn($"Invalid AgentHello payload (or missing AgentIdProvidedByApp) from {potentialAgentClient.ClientId}. Closing connection.");
                potentialAgentClient.Dispose(); return;
            }

            string agentAppId = helloPayload.AgentIdProvidedByApp;
            
            // 이전 ClientState는 임시 ID로 _uiClients에 등록되었을 수 있으므로 거기서 제거 (만약 잘못 연결된 경우)
            // _uiClients.TryRemove(potentialAgentClient.ClientId, out _); // Agent는 UI가 아님

            // 이 ClientState를 Agent로 확정
            potentialAgentClient.IdentifyClient(agentAppId, ClientType.AgentClient);

            ClientState oldClientSessionToClose = null;
            _agentClients.AddOrUpdate(agentAppId, potentialAgentClient, (key, existingClient) => {
                if (existingClient != potentialAgentClient) // 다른 세션이 이미 이 ID로 존재
                {
                    _logger.Warn($"Agent {agentAppId} reconnected. Previous session {existingClient.ClientId} will be closed.");
                    oldClientSessionToClose = existingClient; // 이전 세션은 나중에 닫도록 표시
                }
                return potentialAgentClient; // 새 세션으로 업데이트
            });
            
            if (oldClientSessionToClose != null)
            {
                oldClientSessionToClose.Dispose(); // 이전 세션 닫기
            }

            _logger.Info($"Agent '{agentAppId}' (Machine: {helloPayload.MachineName}, IP: {helloPayload.PrimaryReportedIpAddress}) registered/updated.");

            // Agent에게 Hello에 대한 Ack 전송
            var ackMessage = new BrokerMessage { Type = MessageType.BrokerAck_AgentHello, TargetId = agentAppId, CorrelationId = helloMessage.CorrelationId };
            potentialAgentClient.SendMessageAsync(ackMessage).ConfigureAwait(false);

            // 모든 UI 클라이언트에게 새로운 Agent 연결/업데이트 정보 브로드캐스트
            var liveInfo = new LiveAgentInfoForUi
            {
                AgentIdProvidedByApp = agentAppId,
                PrimaryReportedIpAddress = helloPayload.PrimaryReportedIpAddress,
                AllIpAddresses = helloPayload.AllIpAddresses,
                IsOnline = true,
                CurrentMonitorStatus = helloPayload.InitialMonitorStatus,
                LastHeartbeatUtc = DateTime.UtcNow, // Hello 받은 시점을 첫 하트비트로
                StatusMessageFromAgent = "Just connected"
            };
            var broadcastMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_BroadcastAgentRegisteredOrUpdated,
                Payload = JsonConvert.SerializeObject(liveInfo)
            };
            BroadcastToAllUiClients(broadcastMessage);
        }

        private void BroadcastAgentStatusToUis(ClientState agentClient, BrokerMessage agentStatusMessage)
        {
            AgentStatusUpdatePayload statusPayload = null;
            try { statusPayload = JsonConvert.DeserializeObject<AgentStatusUpdatePayload>(agentStatusMessage.Payload); }
            catch (Exception ex) { _logger.Error($"Error parsing AgentStatusUpdatePayload for {agentClient.ClientId}", ex); return; }

            if (statusPayload == null) return;

            // LiveAgentInfoForUi 모델을 사용하여 UI에 전달할 정보 구성
            var liveInfo = new LiveAgentInfoForUi
            {
                AgentIdProvidedByApp = agentClient.ClientId, // AgentHello에서 설정된 실제 ID
                IsOnline = agentClient.TcpClient.Connected, // 현재 연결 상태
                CurrentMonitorStatus = statusPayload.CurrentMonitorStatus,
                LastHeartbeatUtc = DateTime.UtcNow, // 상태 업데이트 받은 시점을 하트비트로 간주
                // 추가 IP 정보 등은 AgentHello 시 받은 정보 유지 또는 주기적 업데이트 필요
                // 여기서는 상태만 업데이트
            };

            var uiMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_BroadcastAgentStatus,
                SourceId = agentClient.ClientId,
                Payload = JsonConvert.SerializeObject(liveInfo) // AgentStatusUpdatePayload 대신 LiveAgentInfoForUi 사용
            };
            BroadcastToAllUiClients(uiMessage);
            _logger.Debug($"Broadcasted status from Agent {agentClient.ClientId} (Monitor: {statusPayload.CurrentMonitorStatus}) to {_uiClients.Count} UIs.");
        }
        
        // Agent가 보낸 결과를 특정 UI (명령을 내린 UI) 에게 전달
        private void ForwardAgentResultToSpecificUi(ClientState agentClient, BrokerMessage agentResultMessage)
        {
            // agentResultMessage.CorrelationId를 보고, 이 명령을 요청했던 UI의 ConnectionId(ClientState.ClientId)를 찾아야 함.
            // 이를 위해서는 UI가 명령을 보낼 때 (UiRequest_ControlAgent), Broker가 해당 UI의 ClientState.ClientId와 CorrelationId를 매핑해둬야 함.
            // 현재는 BrokerMessage에 TargetId가 있지만, 이건 Agent를 향한 것.
            // 가장 간단한 방법은 Agent가 결과를 보낼 때, 원본 요청의 CorrelationId와 함께,
            // "이 명령을 내린 UI의 ConnectionId"도 함께 보내주는 것 (만약 Broker가 Agent에게 전달 시 알려줬다면).
            // 또는, UI가 명령 보낼 때 자신의 ClientId를 CorrelationId와 함께 저장해뒀다가 매칭.

            // 여기서는 UI가 보낸 ServerCommand에 있던 IssuedByUiConnectionId를 Agent가 결과에 포함시켜 보낸다고 가정.
            // (MessageContract.cs 의 AgentCommandResultPayload 에 OriginalUiConnectionId 필드 추가 필요)
            // 또는, agentResultMessage.CorrelationId를 키로 해서 이전에 저장한 UI Connection ID를 찾는 방식.

            // 단순화를 위해 여기서는 모든 UI에게 브로드캐스트하거나, CorrelationId만 전달.
            // UI쪽에서 자신이 보낸 명령의 CorrelationId와 일치하는지 확인하고 처리하도록 함.
            var uiMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_ForwardAgentCommandResult,
                SourceId = agentClient.ClientId, // 결과를 보낸 Agent
                CorrelationId = agentResultMessage.CorrelationId, // UI가 보낸 원본 CorrelationId
                Payload = agentResultMessage.Payload // Agent가 보낸 결과 페이로드 (AgentCommandResultPayload)
            };

            // 특정 UI에게만 보내려면, uiMessage.TargetId = "해당UI의ClientId" 설정 필요
            // 여기서는 모든 UI에게 브로드캐스트 (UI가 CorrelationId로 필터링)
            BroadcastToAllUiClients(uiMessage);
            _logger.Info($"Forwarded command result from Agent {agentClient.ClientId} to UIs. CorrId: {uiMessage.CorrelationId}");
        }


        private void RelayControlCommandToAgent(ClientState uiClient, BrokerMessage uiCommandMessage)
        {
            UiControlAgentPayload controlPayload = null;
            try
            {
                controlPayload = JsonConvert.DeserializeObject<UiControlAgentPayload>(uiCommandMessage.Payload);
            }
            catch (JsonException jsonEx)
            {
                _logger.Error($"Failed to parse UiControlAgentPayload from UI {uiClient.ClientId}: {jsonEx.Message}. Payload: {uiCommandMessage.Payload}", jsonEx);
                 SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, "Invalid command payload from UI.");
                return;
            }
            
            if (controlPayload == null || string.IsNullOrWhiteSpace(controlPayload.TargetAgentIdProvidedByApp))
            {
                _logger.Warn($"Invalid UiRequest_ControlAgent payload (or missing TargetAgentIdProvidedByApp) from UI {uiClient.ClientId}.");
                SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, "Invalid or missing TargetAgentIdProvidedByApp in command from UI.");
                return;
            }

            string targetAgentAppId = controlPayload.TargetAgentIdProvidedByApp;
            ClientState targetAgentSession = null; // 최종적으로 명령을 받을 Agent 또는 Gateway Agent의 세션

            BrokerExecuteControlPayload payloadForAgent = new BrokerExecuteControlPayload
            {
                ActionToPerform = controlPayload.ControlAction,
                Parameters = controlPayload.OriginalParameters,
                IsGatewayRelayRequired = false // 기본값
            };

            if (controlPayload.ControlType == "Direct")
            {
                if (_agentClients.TryGetValue(targetAgentAppId, out targetAgentSession))
                {
                    _logger.Info($"Relaying command '{controlPayload.ControlAction}' directly to Agent {targetAgentAppId} for UI {uiClient.ClientId}. CorrId: {uiCommandMessage.CorrelationId}");
                }
                else
                {
                    _logger.Warn($"Target Agent {targetAgentAppId} for direct control not found or not connected. UI: {uiClient.ClientId}");
                    SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, $"Agent {targetAgentAppId} for direct control not connected.");
                    return;
                }
            }
            else if (controlPayload.ControlType == "Gatewayed")
            {
                if (string.IsNullOrWhiteSpace(controlPayload.GatewayAgentIdToUse))
                {
                    _logger.Error($"GatewayAgentIdToUse not specified for Gatewayed control to {targetAgentAppId}. UI: {uiClient.ClientId}");
                     SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, "GatewayAgent ID not specified for relayed command.");
                    return;
                }

                if (_agentClients.TryGetValue(controlPayload.GatewayAgentIdToUse, out targetAgentSession)) // Gateway Agent 세션 찾기
                {
                    payloadForAgent.IsGatewayRelayRequired = true;
                    payloadForAgent.FinalTargetAgentIp = controlPayload.PrimaryIpAddress;
                    payloadForAgent.FinalTargetAgentPort = controlPayload.PrimaryPort;
                    payloadForAgent.FinalTargetAgentId = targetAgentAppId; // 최종 타겟 정보 전달
                    _logger.Info($"Relaying command '{controlPayload.ControlAction}' via Gateway Agent {controlPayload.GatewayAgentIdToUse} (for final target {targetAgentAppId}) for UI {uiClient.ClientId}. CorrId: {uiCommandMessage.CorrelationId}");
                }
                else
                {
                    _logger.Warn($"Gateway Agent {controlPayload.GatewayAgentIdToUse} for relay not found or not connected. UI: {uiClient.ClientId}");
                    SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, $"Gateway Agent {controlPayload.GatewayAgentIdToUse} not connected.");
                    return;
                }
            }
            else
            {
                 _logger.Warn($"Unknown ControlType '{controlPayload.ControlType}' from UI {uiClient.ClientId}");
                 SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, $"Unknown ControlType: {controlPayload.ControlType}.");
                 return;
            }

            // targetAgentSession이 확정되었으므로 명령 전송
            if (targetAgentSession != null && targetAgentSession.TcpClient.Connected)
            {
                var agentCommand = new BrokerMessage
                {
                    Type = MessageType.BrokerToAgent_ExecuteControl,
                    TargetId = targetAgentSession.ClientId, // 명령을 받는 세션의 ID (Direct Agent 또는 Gateway Agent)
                    SourceId = "BROKER", 
                    CorrelationId = uiCommandMessage.CorrelationId,
                    Payload = JsonConvert.SerializeObject(payloadForAgent)
                };
                targetAgentSession.SendMessageAsync(agentCommand).ConfigureAwait(false);
            }
            else // 이 경우는 위에서 이미 return 되었어야 함
            {
                _logger.Error($"Internal error: Target session for command to {targetAgentAppId} became null or disconnected before send. UI: {uiClient.ClientId}");
                SendDispatchFailedToUi(uiClient, uiCommandMessage.CorrelationId, "Internal error: Target agent session lost before command send.");
            }
        }
        
        private void SendDispatchFailedToUi(ClientState uiClient, string correlationId, string reason)
        {
            var failMsg = new BrokerMessage { 
                Type = MessageType.BrokerToUi_CommandDispatchFailed, 
                CorrelationId = correlationId, 
                Payload = JsonConvert.SerializeObject(new { Message = reason }) // 간단한 실패 페이로드
            };
            uiClient.SendMessageAsync(failMsg).ConfigureAwait(false);
        }


        private void SendBrokerStatusToUiInternal(ClientState uiClient)
        {
            var statusPayload = new BrokerStatusInfoPayload
            {
                ServerStartTimeUtc = BrokerCore.ServerStartTime,
                UptimeString = (DateTime.UtcNow - BrokerCore.ServerStartTime).ToString(@"d\.hh\:mm\:ss"),
                ConnectedUiClientCount = _uiClients.Count,
                ConnectedAgentCount = _agentClients.Count(ac => ac.Value.Type == ClientType.AgentClient && ac.Value.TcpClient.Connected),
                RecentServerLogs = _logger.GetRecentLogs(50),
                BrokerVersion = BrokerCore.BrokerVersion
            };
            var statusMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_SendBrokerStatus,
                Payload = JsonConvert.SerializeObject(statusPayload)
            };
            uiClient.SendMessageAsync(statusMessage).ConfigureAwait(false);
            _logger.Info($"Sent broker status to UI {uiClient.ClientId}");
        }

        private void HandlePing(ClientState sender, BrokerMessage pingMessage)
        {
            var pongMessage = new BrokerMessage { Type = MessageType.Pong, CorrelationId = pingMessage.CorrelationId, TargetId = sender.ClientId };
            sender.SendMessageAsync(pongMessage).ConfigureAwait(false);
            _logger.Debug($"Sent Pong to {sender.Type} {sender.ClientId}");
        }


        private void HandleClientDisconnect(ClientState clientState)
        {
            if (_isDisposed) return;
            _logger.Info($"Handling disconnect for client: {clientState.ClientId} ({clientState.Type}), RemoteEndPoint: {clientState.TcpClient?.Client?.RemoteEndPoint}");
            
            bool removed = false;
            if (clientState.Type == ClientType.UiClient)
            {
                removed = _uiClients.TryRemove(clientState.ClientId, out _);
                if(removed) _logger.Info($"UI Client {clientState.ClientId} removed. Total UIs: {_uiClients.Count}");
                else _logger.Warn($"Failed to remove UI client {clientState.ClientId} from dictionary, or already removed.");
            }
            else if (clientState.Type == ClientType.AgentClient && !string.IsNullOrWhiteSpace(clientState.ClientId) && clientState.ClientId.StartsWith("Temp_") == false)
            {
                // Agent의 경우 ClientId가 AgentIdProvidedByApp로 설정되어 있음
                removed = _agentClients.TryRemove(clientState.ClientId, out _);
                if(removed)
                {
                    _logger.Info($"Agent Client {clientState.ClientId} removed. Total Agents: {_agentClients.Count}");
                    // 모든 UI에게 해당 Agent 연결 끊김 알림 (LiveAgentInfoForUi 사용)
                    var disconnectedAgentInfo = new LiveAgentInfoForUi
                    {
                        AgentIdProvidedByApp = clientState.ClientId,
                        IsOnline = false,
                        CurrentMonitorStatus = "Offline (Disconnected)",
                        LastHeartbeatUtc = clientState.LastActivityTime, // 마지막 활동 시간
                        StatusMessageFromAgent = "Connection Lost"
                    };
                    var broadcastMessage = new BrokerMessage
                    {
                        Type = MessageType.BrokerToUi_BroadcastAgentDisconnected, // 또는 _BroadcastAgentStatus
                        SourceId = clientState.ClientId, // 연결 끊긴 Agent
                        Payload = JsonConvert.SerializeObject(disconnectedAgentInfo)
                    };
                    BroadcastToAllUiClients(broadcastMessage);
                }
                else
                {
                     _logger.Warn($"Failed to remove Agent client {clientState.ClientId} from dictionary, or already removed.");
                }
            }
            else // 아직 식별되지 않은 클라이언트 (Temp_ ID) 또는 타입 불명
            {
                 _logger.Info($"Unidentified or unknown type client {clientState.ClientId} disconnected.");
            }
            
            // ClientState.Dispose()는 ClientState 내부의 ReceiveLoopAsync finally에서 호출됨.
            // 여기서는 BrokerCore가 관리하는 목록에서만 제거.
        }

        private void BroadcastToAllUiClients(BrokerMessage message)
        {
            if (_isDisposed) return;
            var uiClientList = _uiClients.Values.ToList(); // 동시 수정 방지를 위해 복사본 사용
            foreach (var uiClientState in uiClientList)
            {
                if (uiClientState.TcpClient.Connected)
                {
                    uiClientState.SendMessageAsync(message).ConfigureAwait(false);
                }
            }
        }
        
        public void Stop()
        {
            if (_isDisposed) return;
            _logger.Info("Broker Core Service stopping...");
            _serverCts?.Cancel(); 

            _uiListener?.Stop();
            _agentListener?.Stop();

            var allClients = _uiClients.Values.Concat(_agentClients.Values).ToList();
            _logger.Info($"Closing {allClients.Count} client connections...");
            foreach (var client in allClients)
            {
                client.Dispose();
            }
            _uiClients.Clear();
            _agentClients.Clear();
            
            _serverCts?.Dispose();
            _isDisposed = true; // Dispose 완료 플래그
            _logger.Info("Broker Core Service stopped and resources released.");
        }

        public void Dispose()
        {
            Stop(); // Dispose 시 Stop 호출
            GC.SuppressFinalize(this);
        }
    }
}
4. MGSPBrokerService/Program.cs (수정된 전체 코드)

이 파일은 이전 답변에서 "핸들이 잘못되었다" 오류를 해결하기 위해 수정했던 버전을 기반으로, 로깅 서비스 주입 등을 명확히 합니다.

C#

// MGSPBrokerService/Program.cs
using System;
using System.Reflection;
using System.Threading;
using MGSPBrokerService.Services; // ILoggingService, BrokerLoggingService

namespace MGSPBrokerService
{
    class Program
    {
        private static BrokerCore _brokerCore;
        private static ManualResetEvent _shutdownEvent = new ManualResetEvent(false);
        private static ILoggingService _logger; // Logger 인터페이스 사용
        private static readonly object _shutdownLock = new object();
        private static bool _isShuttingDown = false;

        static void Main(string[] args)
        {
            _logger = new BrokerLoggingService(); // 로거 인스턴스 생성

            try
            {
                var version = Assembly.GetExecutingAssembly().GetName().Version;
                BrokerCore.BrokerVersion = $"{version.Major}.{version.Minor}.{version.Build}.{version.Revision}";
            }
            catch { BrokerCore.BrokerVersion = "N/A"; }

            Console.Title = $"MGSP Broker Service - v{BrokerCore.BrokerVersion}";
            _logger.Info($"MGSP Broker Service v{BrokerCore.BrokerVersion} starting up...");

            Console.CancelKeyPress += (sender, e) => { e.Cancel = true; _logger.Info("Ctrl+C detected. Initiating shutdown..."); InitiateShutdown(); };
            AppDomain.CurrentDomain.ProcessExit += (sender, e) => { _logger.Info("ProcessExit detected. Ensuring shutdown..."); InitiateShutdown(); };

            try
            {
                // 설정 파일에서 포트 번호 등을 읽어올 수 있으나, 여기서는 하드코딩
                int uiPort = 9001;    // 제어 UI 연결용 포트
                int agentPort = 9002; // Agent 연결용 포트
                
                _logger.Info($"Configuring Broker to listen for UIs on port {uiPort} and Agents on port {agentPort}.");
                _brokerCore = new BrokerCore(_logger, uiPort, agentPort);
                _brokerCore.Start(); // BrokerCore 시작 (내부적으로 리스너 시작)

                _logger.Info("Broker Service is now running. Press Ctrl+C to stop.");
                _shutdownEvent.WaitOne(); // 종료 시그널 대기
                 _logger.Info("Main thread released from wait. Proceeding with shutdown.");
            }
            catch (ObjectDisposedException ode)
            {
                _logger.Warn($"ObjectDisposedException in Main: {ode.Message}. This can happen during shutdown race conditions.");
            }
            catch (Exception ex)
            {
                _logger.Fatal("A critical error occurred during Broker startup or operation.", ex);
                Console.WriteLine("A fatal error occurred. Check logs. Press any key to exit.");
                Console.ReadKey(); // 사용자가 오류를 볼 수 있도록
                Environment.ExitCode = -1; // 오류 종료 코드
            }
            finally
            {
                _logger.Info("Broker Service Main finally block. Cleaning up resources...");
                CleanupResources();
            }
            _logger.Info("Broker Service has shut down. Press any key to close window if it hasn't closed automatically.");
            // 콘솔 앱이 바로 닫히는 것을 방지하기 위해 ReadKey 추가 (특히 오류 없이 정상 종료 시)
            if (Environment.ExitCode == 0) // 정상 종료 시에만 ReadKey
            {
                 Console.ReadKey();
            }
        }

        private static void InitiateShutdown()
        {
            lock (_shutdownLock)
            {
                if (_isShuttingDown) return;
                _isShuttingDown = true;
            }

            _logger.Info("Initiating Broker shutdown sequence...");
            _brokerCore?.Stop(); // BrokerCore의 Stop 메서드 호출 (내부적으로 리스너, 클라이언트 정리)
            
            if (_shutdownEvent != null && !_shutdownEvent.SafeWaitHandle.IsClosed)
            {
                try
                {
                    _shutdownEvent.Set(); // Main 스레드 종료 허용
                    _logger.Info("Shutdown event signaled to Main thread.");
                }
                catch (ObjectDisposedException) { _logger.Warn("Attempted to set an already disposed shutdown event in InitiateShutdown."); }
            }
        }

        private static void CleanupResources() // Main의 finally에서 호출
        {
            _logger.Info("CleanupResources called.");
            _brokerCore?.Dispose(); // BrokerCore의 Dispose 메서드 (Stop 호출 포함)
            _brokerCore = null;

            if (_shutdownEvent != null)
            {
                if (!_shutdownEvent.SafeWaitHandle.IsClosed)
                {
                    _shutdownEvent.Close(); // ManualResetEvent 리소스 해제
                }
                _shutdownEvent = null;
                _logger.Info("Shutdown event handle disposed.");
            }
            _logger.Info("All core resources cleaned up.");
        }
    }
}
위 코드들을 MGSPBrokerService 프로젝트에 적용하시면 CS0117 오류가 해결되고, 새로운 로그 관리 및 상태 제공 기능이 포함된 중계 프로그램이 준비됩니다.

중요:

MessageContract.cs 파일은 반드시 MonitorControl.SharedModels 네임스페이스를 사용하고, 이 네임스페이스를 사용하는 모든 파일(ClientState.cs, BrokerCore.cs 등) 상단에 using MonitorControl.SharedModels; 지시문을 추가해야 합니다.