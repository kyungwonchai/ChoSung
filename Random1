좋아. 이제 너가 원하는 방식으로 동작 원리와 순서에 대한 설명을 포함한 매우 상세한 주석을 추가한 코드를 제공할게.

전문가 수준의 비동기 소켓 클라이언트 (상세 주석 포함)
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // 서버와의 TCP 연결을 위한 TcpClient 객체
    private NetworkStream _stream; // 데이터 송수신을 위한 스트림
    private byte[] _buffer = new byte[1024]; // 수신 데이터를 저장할 버퍼
    private bool _isConnected = false; // 현재 연결 상태를 나타내는 플래그

    // 요청 ID와 해당 응답을 기다리는 TaskCompletionSource 매핑하는 비동기 딕셔너리
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _pendingRequests 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    /// <summary>
    /// 서버와 연결하고, 비동기 수신 루프를 시작한다.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient(); // TcpClient 객체 생성
        await _client.ConnectAsync(ip, port); // 서버와 비동기적으로 연결 시도
        _stream = _client.GetStream(); // 연결된 스트림을 가져옴
        _isConnected = true; // 연결 성공 여부 설정

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // 항상 돌아가는 수신 루프를 비동기로 시작 (Task.Run으로 백그라운드에서 실행)
        _ = Task.Run(ReceiveLoopAsync);
    }

    /// <summary>
    /// 서버로 명령을 비동기로 보내고, 해당 명령에 대한 응답을 기다린다.
    /// 요청마다 고유 ID를 부여하여 응답을 정확히 구분한다.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string command)
    {
        if (!_isConnected) return "[ERROR] Not connected."; // 연결되지 않은 상태에서는 에러 리턴

        // 1. 요청마다 고유한 ID를 생성 (Guid로 고유 ID 생성)
        string requestId = Guid.NewGuid().ToString("N").Substring(0, 8); // 예: "d4a3b6f9"

        // 2. 요청 메시지를 고유 ID와 함께 구성
        string fullMessage = $"REQ:{requestId}:{command}"; // 예: "REQ:d4a3b6f9:STATUS"
        string wrappedMessage = '\x02' + fullMessage + '\x03'; // STX(시작), ETX(종료)로 감싸기
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage); // 문자열을 바이트 배열로 변환

        // 3. TaskCompletionSource 생성하여 응답 대기를 준비
        var tcs = new TaskCompletionSource<string>();

        // 4. 고유 ID를 키로 사용하여 대기 목록에 추가 (비동기 응답 처리를 위해)
        _pendingRequests.TryAdd(requestId, tcs);

        // 5. 서버로 메시지 전송 (비동기적으로 전송)
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {fullMessage}");

        // 6. 해당 요청의 응답을 비동기로 대기 (여기서 응답을 기다림)
        string response = await tcs.Task;
        return response;
    }

    /// <summary>
    /// 항상 돌아가는 수신 루프.
    /// 서버에서 보내는 모든 데이터를 처리하고, 응답과 선제 메시지를 구분한다.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // 서버로부터 데이터를 비동기로 읽음
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                // 서버 연결이 끊어졌을 경우 (0바이트를 수신)
                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 수신된 바이트 배열을 문자열로 변환
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                // 응답 메시지와 선제 메시지(OP_CLEAR)를 구분하여 처리
                if (received.StartsWith("RES:"))
                {
                    ProcessResponse(received); // 응답 메시지 처리
                }
                else if (received == "OP_CLEAR")
                {
                    ProcessOpClear(); // 서버의 선제 메시지 처리 (특수 처리)
                }
                else
                {
                    Console.WriteLine($"[WARN] Unknown message format: {received}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// 응답 메시지를 처리한다.
    /// 요청 ID를 기준으로 대기 중인 요청을 완료시킨다.
    /// </summary>
    private void ProcessResponse(string message)
    {
        var parts = message.Split(':', 3); // 메시지를 ':' 기준으로 최대 3개로 분리

        if (parts.Length < 3) return; // 형식 오류 방지

        string requestId = parts[1]; // 요청 ID 추출
        string responseContent = parts[2]; // 응답 내용 추출

        // 요청 ID가 대기 목록에 있는지 확인하고, 응답을 전달한다.
        if (_pendingRequests.TryRemove(requestId, out var tcs))
        {
            tcs.SetResult(responseContent); // 응답을 TaskCompletionSource에 설정하여 대기 중인 Task를 완료시킴
        }
        else
        {
            Console.WriteLine($"[ERROR] Unexpected response ID: {requestId}");
        }
    }

    /// <summary>
    /// 서버의 선제 메시지(OP_CLEAR) 처리
    /// </summary>
    private void ProcessOpClear()
    {
        Console.WriteLine("[EVENT] OP_CLEAR received. Processing it separately.");
        // 여기에서 필요한 로직을 구현 (예: UI 초기화, 로그 기록 등)
    }

    /// <summary>
    /// 서버 연결을 해제한다.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false; // 연결 상태 플래그 해제
        _stream?.Close(); // 스트림 닫기
        _client?.Close(); // TCP 클라이언트 닫기
        Console.WriteLine("[INFO] Disconnected.");
    }
}
✅ 코드 동작 원리와 순서
연결 (ConnectAsync):

서버와 연결을 맺고, 수신 루프(ReceiveLoopAsync())를 항상 돌림.

연결이 끊어지면 _isConnected 플래그로 중단 처리.

명령 전송 및 응답 대기 (SendAndReceiveAsync):

고유한 요청 ID 생성 후 메시지에 포함.

비동기적으로 메시지 전송 (WriteAsync()).

응답은 TaskCompletionSource를 이용해 비동기 대기.

수신 루프 (ReceiveLoopAsync):

모든 수신 데이터는 이 루프에서 받음.

응답 메시지(RES:...)와 선제 메시지(OP_CLEAR)를 구분하여 처리.

응답 처리 (ProcessResponse):

요청 ID와 매칭되는 요청의 응답을 찾아서 완료시킴.

선제 메시지 처리 (ProcessOpClear):

별도로 처리하며, 다른 메시지와 충돌하지 않도록 분리.

코드가 완벽히 이해될 수 있도록 주석과 흐름을 자세히 설명했어.