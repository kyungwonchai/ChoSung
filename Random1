알겠습니다. 이제 SocketClientMergeOI 클래스만 남겨두고, 불필요한 부분을 제거하고, 주석을 아주 상세히 추가하여 전체 코드를 다시 작성해 드리겠습니다.

최종 코드: SocketClientMergeOI 클래스
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientMergeOI
{
    private TcpClient _client; // TCP 클라이언트 소켓
    private NetworkStream _stream; // 서버와의 데이터 송수신을 위한 네트워크 스트림
    private readonly string _ipAddress; // 접속할 서버의 IP 주소
    private readonly int _port; // 접속할 서버의 포트 번호
    private bool _isConnected; // 연결 상태를 저장하는 플래그
    private readonly int _retryInterval = 10000; // 재연결 시도 간격 (10초)

    // 연결 상태가 변경될 때 호출되는 이벤트
    public event Action<string> ConnectionStatusChanged;

    // 서버로부터 메시지를 수신했을 때 호출되는 이벤트
    public event Action<string> MessageReceived;

    // 명령어를 성공적으로 서버로 전송했을 때 호출되는 이벤트
    public event Action<string> CommandSent;

    // 생성자: 서버 IP와 포트를 받아서 객체를 초기화
    public SocketClientMergeOI(string ipAddress, int port)
    {
        _ipAddress = ipAddress; // 입력받은 IP 주소 저장
        _port = port; // 입력받은 포트 번호 저장
        _client = new TcpClient(); // TCP 클라이언트 생성
        _isConnected = false; // 초기 연결 상태는 false
        StartConnectionAttemptAsync(); // 연결 시도를 시작
    }

    // 비동기적으로 서버에 연결을 시도하는 함수
    private async void StartConnectionAttemptAsync()
    {
        while (!_isConnected) // 연결될 때까지 반복
        {
            try
            {
                await _client.ConnectAsync(_ipAddress, _port); // 서버에 연결 시도
                _isConnected = true; // 연결 성공 시 플래그를 true로 변경
                _stream = _client.GetStream(); // 서버와 통신할 네트워크 스트림 열기
                ConnectionStatusChanged?.Invoke("Connected"); // 연결 성공 이벤트 발생
                StartReceiving(); // 서버로부터 데이터를 수신하기 시작
            }
            catch (Exception)
            {
                ConnectionStatusChanged?.Invoke("Retrying in 10 seconds..."); // 연결 실패 시 재시도 메시지 발생
                await Task.Delay(_retryInterval); // 10초 대기 후 재시도
            }
        }
    }

    // 메시지를 서버로 전송하고 응답을 기다리는 비동기 함수
    public async Task<string> SendAndReceiveMessageAsync(string message)
    {
        if (!_isConnected) // 연결되어 있지 않으면
            return "Not connected"; // 연결되지 않았다는 메시지 반환

        string fullMessage = $"\x02{message}\x03"; // STX(0x02)와 ETX(0x03)로 감싸서 메시지 구성
        byte[] messageBytes = Encoding.ASCII.GetBytes(fullMessage); // ASCII로 인코딩하여 바이트 배열로 변환

        try
        {
            await _stream.WriteAsync(messageBytes, 0, messageBytes.Length); // 서버로 메시지 전송
            CommandSent?.Invoke(message); // 명령어 전송 이벤트 호출 (명령어를 로그에 남기기 위함)
        }
        catch (Exception)
        {
            return "Send Failed"; // 전송 실패 시 에러 메시지 반환
        }

        // 응답을 기다리고 검증
        string response = await ReceiveMessageAsync(); // 응답을 비동기적으로 수신
        return ValidateResponse(message, response); // 응답 검증 후 결과 반환
    }

    // 비동기적으로 서버로부터 메시지를 수신하는 함수
    private async Task<string> ReceiveMessageAsync()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 저장할 버퍼

        try
        {
            int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 읽음
            if (bytesRead > 0) // 읽은 데이터가 있을 경우
            {
                string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 바이트 데이터를 문자열로 변환
                MessageReceived?.Invoke(receivedMessage); // 수신된 메시지 이벤트 호출
                return receivedMessage; // 수신된 메시지를 반환
            }
        }
        catch (Exception)
        {
            _isConnected = false; // 연결이 끊긴 경우 연결 상태를 false로 설정
            ConnectionStatusChanged?.Invoke("Connection lost, retrying..."); // 연결 끊김 이벤트 호출
            StartConnectionAttemptAsync(); // 다시 연결 시도
        }

        return string.Empty; // 수신 실패 시 빈 문자열 반환
    }

    // 서버로부터 받은 응답을 검증하는 함수
    private string ValidateResponse(string sentMessage, string receivedMessage)
    {
        // STX와 ETX로 감싸진 메시지인지 확인
        if (receivedMessage.StartsWith("\x02") && receivedMessage.EndsWith("\x03"))
        {
            string cleanMessage = receivedMessage.Trim('\x02', '\x03'); // STX와 ETX를 제거한 메시지 추출
            if (cleanMessage == "OK") // "OK" 메시지일 경우
            {
                return "OK"; // 정상 응답 반환
            }
            else if (cleanMessage == sentMessage) // 전송한 메시지와 동일한 경우 (NG 응답)
            {
                return "NG"; // NG 응답 반환
            }
        }
        return "Invalid Response"; // 유효하지 않은 응답
    }

    // 서버와의 연결을 중지하는 함수
    public void StopConnection()
    {
        _isConnected = false; // 연결 상태를 false로 설정
        _stream?.Close(); // 스트림을 닫음
        _client?.Close(); // TCP 클라이언트를 닫음
    }
}
상세 설명
SocketClientMergeOI 생성자

IP 주소와 포트를 받아서 소켓 클라이언트를 초기화하고, 서버 연결을 시도합니다.
StartConnectionAttemptAsync

서버에 비동기적으로 연결을 시도하는 함수입니다. 연결이 실패할 경우 10초마다 재시도하며, 연결이 성공하면 수신을 시작합니다.
SendAndReceiveMessageAsync

메시지를 서버로 전송하고, 응답을 비동기적으로 기다립니다. 메시지는 STX와 ETX로 감싸서 전송되고, 응답이 정상인지 검증한 뒤 OK 또는 NG를 반환합니다.
ReceiveMessageAsync

서버로부터 데이터를 비동기적으로 수신하는 함수입니다. 수신된 데이터를 이벤트로 호출하고, 메시지를 반환합니다.
ValidateResponse

서버로부터 받은 응답이 유효한지 검증합니다. 만약 응답이 OK라면 성공, 전송한 메시지와 동일하다면 NG 응답을 반환합니다.
StopConnection

연결을 종료하고, 스트림 및 소켓을 닫습니다.
사용 방법 예시
csharp
코드 복사
// SocketClientMergeOI 인스턴스 생성
SocketClientMergeOI socketClient = new SocketClientMergeOI("127.0.0.1", 2400);

// 데이터를 전송하고 응답을 처리하는 함수 호출
string response = await socketClient.SendAndReceiveMessageAsync("YourCommandHere");

// 응답이 OK인지 NG인지 확인
if (response == "OK")
{
    Console.WriteLine("전송 성공!");
}
else if (response == "NG")
{
    Console.WriteLine("전송 실패 - NG 응답!");
}
else
{
    Console.WriteLine("잘못된 응답");
}
이 코드는 WPF MVVM 패턴을 유지하며, 소켓 통신에 필요한 필수적인 기