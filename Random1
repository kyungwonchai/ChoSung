 이제 ReceiveLoopAsync()에서 받은 메시지를 보낸 메시지와 정확히 매칭하도록 수정해줄게.

✅ 목표
수신된 메시지 (received)를 보낸 메시지와 정확히 매칭해야 한다.

ReceiveLoopAsync() 내부에서 처리할 때 보낸 메시지를 확인할 수 있게 해야 한다.

보낸 메시지와 받은 메시지를 모두 로그로 남길 수 있게 한다.

🔥 코드 수정 (ReceiveLoopAsync에서 보낸 메시지 매칭)
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // 서버와 연결하는 TcpClient 객체
    private NetworkStream _stream; // 데이터를 주고받기 위한 네트워크 스트림
    private byte[] _buffer = new byte[1024]; // 수신 데이터를 저장하는 버퍼 (1KB 크기)
    private bool _isConnected = false; // 서버와의 연결 상태를 확인하는 플래그

    // 요청 ID와 응답 TaskCompletionSource를 매핑하기 위한 딕셔너리
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    // 보낸 메시지를 기록하기 위한 딕셔너리 (매칭을 위해 사용)
    private ConcurrentDictionary<string, string> _sentMessages = new ConcurrentDictionary<string, string>();

    /// <summary>
    /// 서버에 연결하고 수신 루프를 시작한다.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // 항상 돌아가는 수신 루프를 비동기로 실행
        _ = Task.Run(ReceiveLoopAsync); 
    }

    /// <summary>
    /// 서버로 메시지를 보내고 응답을 기다린다.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected)
            return "[ERROR] Not connected.";

        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        var tcs = new TaskCompletionSource<string>();

        // 고유한 요청 ID 생성
        string requestId = Guid.NewGuid().ToString("N");

        // 보낸 메시지와 요청 ID를 매칭하여 저장
        _responseTasks.TryAdd(requestId, tcs);
        _sentMessages.TryAdd(requestId, message); 

        // 서버로 메시지 전송
        await _stream.WriteAsync(data, 0, data.Length);
        LogMessage($"[SEND] [{requestId}] {message}");

        // 응답을 기다림
        string response = await tcs.Task;
        _responseTasks.TryRemove(requestId, out _);
        _sentMessages.TryRemove(requestId, out _);

        return response;
    }

    /// <summary>
    /// 항상 돌아가는 수신 루프. 모든 메시지를 감지하고 처리한다.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // 받은 메시지 변환
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                LogMessage($"[RECV] {received}");

                // 메시지를 받은 후, 보낸 메시지와 매칭하여 로그로 남기기
                foreach (var key in _responseTasks.Keys)
                {
                    if (_responseTasks.TryRemove(key, out var tcs))
                    {
                        if (_sentMessages.TryGetValue(key, out var sentMessage))
                        {
                            LogMessage($"[MATCHED] Sent: {sentMessage} | Received: {received}");
                        }
                        tcs.SetResult(received); // 응답 설정
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// 메시지를 기록하는 함수. (콘솔 또는 파일로 로그를 남길 수 있음)
    /// </summary>
    private void LogMessage(string message)
    {
        Console.WriteLine(message);
    }

    /// <summary>
    /// 서버 연결을 해제한다.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
📌 코드 설명 (수정 사항)
요청과 응답 매칭을 위한 추가 저장소 (_sentMessages)

SendAndReceiveAsync()에서 보낸 메시지를 _sentMessages 딕셔너리에 저장.

요청 ID (requestId)로 매칭 가능하도록 관리.

ReceiveLoopAsync()에서 응답을 보낸 메시지와 매칭

foreach (var key in _responseTasks.Keys)로 모든 키를 확인하면서 매칭.

매칭되면 LogMessage() 함수로 [MATCHED] Sent: ... | Received: ... 형태로 기록.

로그 예시:

css
코드 복사
[SEND] [b91bfa24e5b54abf924fa56e0d4d9463] STATUS_CHECK
[RECV] OK_STATUS
[MATCHED] Sent: STATUS_CHECK | Received: OK_STATUS
로그 함수 (LogMessage())

콘솔로 출력하지만, 파일로도 저장할 수 있게 쉽게 수정 가능.

💯 결론
✅ 이제 ReceiveLoopAsync()에서 받은 메시지를 보낸 메시지와 정확히 매칭할 수 있다.

✅ 요청 ID (requestId)로 딕셔너리를 사용해서 안전하게 관리한다.

✅ 보낸 메시지와 받은 메시지를 모두 기록할 수 있다.
