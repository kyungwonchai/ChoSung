재 제공된 코드에서는 ServiceControllerHelper 클래스에서 발생하는 로그 메시지가 MainViewModel의 LogMessages에 제대로 전달되지 않는 문제가 있습니다. 이 문제의 원인은 ServiceControllerHelper 클래스에서 발생하는 로그 메시지가 MainViewModel의 UI 스레드가 아닌 다른 스레드에서 실행되기 때문입니다. 따라서 로그 메시지를 UI 요소인 ListBox에 추가하려면 UI 스레드에서 실행해야 합니다.

이를 해결하기 위해 다음과 같은 수정을 해야 합니다:

UI 스레드에서 로그 메시지 추가: ServiceControllerHelper 클래스에서 발생하는 로그 메시지가 UI 스레드에서 실행되도록 MainViewModel의 LogMessage 메서드에서 Dispatcher.Invoke를 사용합니다.
수정된 MainViewModel 코드
csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Threading;
using RouterMiddleACR.Services;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ServiceControllerHelper _serviceControllerHelper;

        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();

        public MainViewModel()
        {
            _serviceControllerHelper = new ServiceControllerHelper();
            _serviceControllerHelper.OnLogMessage += LogMessage; // 로그 메시지 이벤트 핸들러 등록
        }

        // 로그 메시지를 UI 스레드에서 추가하는 메서드
        private void LogMessage(string message)
        {
            // Dispatcher를 사용하여 UI 스레드에서 실행
            App.Current.Dispatcher.Invoke(() =>
            {
                LogMessages.Add(message);
            });
        }

        // 서비스 시작 메서드
        public void StartService()
        {
            _serviceControllerHelper.StartService();
        }

        // 서비스 중지 메서드
        public void StopService()
        {
            _serviceControllerHelper.StopService();
        }

        // 서비스 상태를 갱신하는 메서드
        public void RefreshServiceStatus()
        {
            var status = _serviceControllerHelper.GetServiceStatus();
            LogMessage($"서비스 상태: {status}");
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
수정된 ServiceControllerHelper 코드
ServiceControllerHelper 클래스에서는 특별한 수정이 필요하지 않지만, OnLogMessage 이벤트를 트리거할 때는 여전히 UI 스레드에서 처리되도록 해야 합니다. 이 작업은 MainViewModel에서 수행하므로 ServiceControllerHelper 코드는 그대로 유지할 수 있습니다.

ServiceControllerHelper.cs
csharp
코드 복사
using System;
using System.ServiceProcess;
using System.Timers;

namespace RouterMiddleACR.Services
{
    public class ServiceControllerHelper
    {
        private ServiceController _serviceController;
        private Timer _statusCheckTimer;
        private readonly string _serviceName = "RouterMiddleACRService";

        public event Action<string> OnLogMessage; // 로그 메시지를 전달하는 이벤트

        public ServiceControllerHelper()
        {
            _serviceController = new ServiceController(_serviceName);
            InitializeStatusCheckTimer();
        }

        // 서비스 상태 확인을 위한 타이머 초기화
        private void InitializeStatusCheckTimer()
        {
            _statusCheckTimer = new Timer(10000); // 10초마다 상태 체크
            _statusCheckTimer.Elapsed += (sender, args) => CheckServiceStatus();
            _statusCheckTimer.Start();
        }

        // 서비스 상태를 확인하고 필요한 경우 재시작하는 메서드
        private void CheckServiceStatus()
        {
            try
            {
                _serviceController.Refresh();
                string status = _serviceController.Status.ToString();
                OnLogMessage?.Invoke($"서비스 상태: {status}");

                if (_serviceController.Status == ServiceControllerStatus.Stopped)
                {
                    OnLogMessage?.Invoke("서비스가 중지되었습니다. 재시작합니다...");
                    RestartService();
                }
            }
            catch (Exception ex)
            {
                OnLogMessage?.Invoke($"서비스 상태 확인 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            try
            {
                if (_serviceController.Status == ServiceControllerStatus.Stopped)
                {
                    _serviceController.Start();
                    _serviceController.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(30));
                    OnLogMessage?.Invoke("서비스가 성공적으로 시작되었습니다.");
                }
            }
            catch (Exception ex)
            {
                OnLogMessage?.Invoke($"서비스 시작 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            try
            {
                if (_serviceController.Status == ServiceControllerStatus.Running)
                {
                    _serviceController.Stop();
                    _serviceController.WaitForStatus(ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(30));
                    OnLogMessage?.Invoke("서비스가 성공적으로 중지되었습니다.");
                }
            }
            catch (Exception ex)
            {
                OnLogMessage?.Invoke($"서비스 중지 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 재시작하는 메서드
        public void RestartService()
        {
            StopService();
            StartService();
        }

        // 현재 서비스 상태를 반환하는 메서드
        public string GetServiceStatus()
        {
            try
            {
                _serviceController.Refresh();
                return _serviceController.Status.ToString();
            }
            catch (Exception ex)
            {
                OnLogMessage?.Invoke($"서비스 상태를 가져오는 중 오류 발생: {ex.Message}");
                return "Unknown";
            }
        }
    }
}
원인 설명
원인: ServiceControllerHelper에서 발생하는 로그 메시지는 OnLogMessage 이벤트를 통해 MainViewModel에 전달되지만, 이 이벤트가 비동기적으로 호출될 수 있습니다. WPF의 ObservableCollection은 UI 스레드에서 업데이트되어야 하므로, 다른 스레드에서 직접 접근하려고 하면 예외가 발생하거나 UI가 업데이트되지 않을 수 있습니다.

해결 방법: MainViewModel에서 LogMessage 메서드가 호출될 때, Dispatcher.Invoke를 사용하여 로그 메시지를 UI 스레드에서 추가하도록 수정했습니다. 이를 통해 모든 로그 메시지가 UI 스레드에서 안전하게 처리되어 ListBox에 제대로 표시됩니다.

요약
ServiceControllerHelper에서 발생한 로그 메시지를 MainViewModel의 LogMessages에 추가할 때, UI 스레드에서 실행되도록 Dispatcher.Invoke를 사용했습니다.
이 수정으로 ServiceControllerHelper에서 발생한 모든 로그 메시지가 MainWindow의 ListBox에 올바르게 표시될 것입니다.