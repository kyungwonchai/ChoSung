, "ValueError: This list of positional arguments is longer than the target callable can handle (allowed 0, given in args: 1)" 오류 메시지는 APScheduler가 특정 함수를 실행하려고 할 때, 그 함수가 실제로는 아무 인자(argument)도 받지 않도록 정의되어 있는데 스케줄러가 1개의 인자를 전달하려고 해서 발생하는 문제입니다.

이전에 app/__init__.py 파일에서 스케줄된 작업(scheduled_task_monitor_on, scheduled_task_monitor_off)을 등록할 때 Flask의 app 인스턴스를 전달하도록 args=[current_flask_app] 옵션을 사용했습니다.

Python

# app/__init__.py 의 일부
scheduler.add_job(id='scheduled_task_monitor_on_daily', 
                  func=scheduler_tasks.scheduled_task_monitor_on,
                  args=[current_flask_app], # <--- 여기서 app 인스턴스를 전달합니다.
                  trigger='cron', hour=6, minute=0, ...)
따라서 app/scheduler_tasks.py 파일에 있는 scheduled_task_monitor_on과 scheduled_task_monitor_off 함수들은 반드시 이 app 인스턴스를 받을 수 있도록 첫 번째 인자(예: app_instance)를 가져야 합니다.

가장 가능성이 높은 원인:

사용자님의 app/scheduler_tasks.py 파일에 있는 scheduled_task_monitor_on 및/또는 scheduled_task_monitor_off 함수의 정의 부분이 Flask app 인스턴스를 인자로 받도록 수정되지 않았거나, 수정되었더라도 변경사항이 제대로 저장/반영되지 않았을 수 있습니다.

해결 방법:

app/scheduler_tasks.py 파일 확인 및 수정: 해당 파일의 함수 정의가 app_instance 인자를 받도록 되어 있는지 다시 한번 꼼꼼히 확인하고, 아니라면 수정합니다.
Python 캐시 파일 삭제 및 Flask 서버 완전 재시작:
프로젝트 폴더 및 하위 app 폴더 내에 있는 __pycache__ 폴더들을 모두 삭제합니다. 이 폴더들은 컴파일된 Python 파일(.pyc)을 저장하며, 간혹 이전 버전의 코드가 계속 실행되는 원인이 될 수 있습니다.
Flask 개발 서버를 완전히 중지했다가 다시 시작합니다.
아래에 app/scheduler_tasks.py 파일의 수정된 전체 코드와, 이와 관련된 app/__init__.py 파일의 스케줄러 작업 등록 부분을 다시 제공해 드립니다. 이 코드를 사용자님의 파일과 정확히 비교/대체해 보십시오.

1. 수정/확인: app/scheduler_tasks.py (전체 코드)
scheduled_task_monitor_on과 scheduled_task_monitor_off 함수, 그리고 이들이 호출하는 헬퍼 함수들이 app_instance 인자를 올바르게 처리하도록 합니다.

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date
import holidays
# from flask import current_app # 직접 current_app 대신 전달받은 app_instance 사용 권장
from .db_utils import get_db_connection
from .socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone

# is_operational_day 와 _send_display_timeout_to_all_pcs 함수는
# app_instance를 통해 logger나 config에 접근하도록 수정합니다.
# get_db_connection 과 send_command_to_agent는 내부적으로 current_app을 사용하는데,
# 이들은 app_context 내에서 호출되므로 문제가 없습니다.

def is_operational_day(target_date, app_instance): # app_instance를 통해 로거 사용
    conn = None
    try:
        # 이 함수는 app_context 내에서 호출되므로 get_db_connection()은 current_app 사용 가능
        conn = get_db_connection() 
        if not conn:
            app_instance.logger.error("is_operational_day: DB 연결 실패. 기본 가동일 처리.")
            return True 

        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"
            cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),))
            exception_day = cursor.fetchone()
            if exception_day:
                is_op = bool(exception_day['is_operational'])
                app_instance.logger.info(f"{target_date}는 사용자 지정 예외일: {'가동일' if is_op else '비가동일'}")
                return is_op

        if target_date.weekday() >= 5: # 토(5), 일(6)
            app_instance.logger.info(f"{target_date}는 주말(비가동일).")
            return False

        kr_holidays = holidays.KR(years=target_date.year) 
        if target_date in kr_holidays:
            app_instance.logger.info(f"{target_date}는 공휴일('{kr_holidays.get(target_date)}'). (비가동일)")
            return False
            
        app_instance.logger.info(f"{target_date}는 평일(가동일).")
        return True
    except Exception as e:
        app_instance.logger.error(f"is_operational_day 함수 오류: {e}", exc_info=True)
        return True # 오류 발생 시 기본적으로 가동일로 처리 (안전을 위해)

def _send_display_timeout_to_all_pcs(timeout_minutes, action_description, app_instance): # app_instance를 통해 로거 사용
    conn = None
    pcs_to_control = []
    try:
        conn = get_db_connection() # current_app 사용 (app_context 내에서 호출됨)
        if not conn:
            app_instance.logger.error(f"_send_display_timeout_to_all_pcs: DB 연결 실패.")
            return
        with conn.cursor() as cursor:
            cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs")
            pcs_to_control = cursor.fetchall()
    except Exception as e:
        app_instance.logger.error(f"스케줄 작업 PC 목록 조회 오류: {e}", exc_info=True)
        return 

    if not pcs_to_control:
        app_instance.logger.info("스케줄 작업: 제어할 PC 없음.")
        return

    app_instance.logger.info(f"스케줄 작업 시작: '{action_description}'을(를) {len(pcs_to_control)}대 PC에 전송.")
    payload_obj = {'TimeoutMinutes': timeout_minutes}
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        command_packet = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            command_packet['Instruction'] = "RelayToTarget"; command_packet['FinalTargetIpForRelayedCommand'] = pc_data['address2']
            command_packet['FinalTargetPortForRelayedCommand'] = 4026; target_ip_for_command = pc_data['address1']
        else:
            command_packet['Instruction'] = "DirectExecute"; target_ip_for_command = pc_data['address1']

        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip_for_command})]"
        app_instance.logger.info(f"{log_prefix} - '{action_description}' 명령 전송 시도. PktID: {command_packet['PacketId']}")
        try:
            # send_command_to_agent는 내부적으로 current_app.logger 사용
            # 이 함수(_send_display_timeout_to_all_pcs)가 app_context 내에서 호출되므로 문제 없음
            agent_response = send_command_to_agent(target_ip_for_command, command_packet) 
            if agent_response.get('success'):
                raw_resp_packet = agent_response.get('raw_response')
                if raw_resp_packet and isinstance(raw_resp_packet, dict) and raw_resp_packet.get('PayloadJson'):
                    resp_payload = json.loads(raw_resp_packet['PayloadJson'])
                    if resp_payload.get('Success'): app_instance.logger.info(f"{log_prefix} - 명령 성공: {resp_payload.get('Message', 'OK')}")
                    else: app_instance.logger.error(f"{log_prefix} - 명령 실패 (에이전트): {resp_payload.get('Message', 'Agent error')}")
                else: app_instance.logger.warning(f"{log_prefix} - 전송 성공, 상세 응답 확인 불가. Raw: {raw_resp_packet}")
            else: app_instance.logger.error(f"{log_prefix} - 전송 실패: {agent_response.get('message', 'Socket error')}")
        except Exception as e_send:
            app_instance.logger.error(f"{log_prefix} - 명령 전송 중 예외: {e_send}", exc_info=True)

# --- APScheduler가 호출할 실제 작업 함수들 ---
# ▼▼▼ 이 함수들의 시그니처에 app_instance 인자가 있는지 확인! ▼▼▼
def scheduled_task_monitor_on(app_instance): 
    with app_instance.app_context(): # 전달받은 app 인스턴스로 app_context 생성
        today = date.today()
        app_instance.logger.info(f"[Scheduler] 모니터 켜기 작업 (06:00 예정), 오늘: {today}")
        if is_operational_day(today, app_instance): # app_instance 전달
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 켜기(타임아웃 해제)' 명령 전송.")
            _send_display_timeout_to_all_pcs(0, "디스플레이 항상 켜기 설정 (타임아웃 0분)", app_instance) # app_instance 전달
        else:
            app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 켜기' 명령 미실행.")

def scheduled_task_monitor_off(app_instance): 
    with app_instance.app_context(): # 전달받은 app 인스턴스로 app_context 생성
        today = date.today()
        app_instance.logger.info(f"[Scheduler] 모니터 끄기 작업 (07:00 예정), 오늘: {today}")
        if not is_operational_day(today, app_instance): # app_instance 전달
            app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 끄기(1분 후 타임아웃)' 명령 전송.")
            _send_display_timeout_to_all_pcs(1, "디스플레이 1분 후 자동 꺼짐 설정", app_instance) # app_instance 전달
        else:
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 끄기' 명령 미실행.")
# ▲▲▲ 이 함수들의 시그니처에 app_instance 인자가 있는지 확인! ▲▲▲
app/scheduler_tasks.py 핵심 확인 사항:

scheduled_task_monitor_on 함수와 scheduled_task_monitor_off 함수의 정의가 반드시 app_instance라는 이름의 첫 번째 인자를 포함해야 합니다. 예: def scheduled_task_monitor_on(app_instance):
이 app_instance를 사용하여 함수 내에서 app_instance.logger 등으로 Flask 앱 객체에 접근합니다.
with app_instance.app_context(): 블록을 사용하여, 해당 함수들이 Flask 애플리케이션 컨텍스트 내에서 실행되도록 합니다. 이렇게 하면 get_db_connection()이나 send_command_to_agent() 내부에서 current_app을 사용해도 문제가 없습니다.
2. 수정/확인: app/__init__.py (스케줄러 작업 등록 부분)
이 파일에서 scheduler.add_job을 호출할 때 args=[current_flask_app] 부분이 올바르게 설정되어 있는지 확인합니다. (이전 답변 #53의 코드와 동일해야 합니다.)

Python

# scontrol_flask_web/app/__init__.py
# ... (다른 부분은 이전 답변 #53과 동일) ...

    # --- APScheduler 초기화 및 작업 등록 ---
    if not scheduler.running:
        scheduler.init_app(app)
        
        from . import scheduler_tasks 

        if app.debug:
            if scheduler.get_job('scheduled_task_monitor_on_daily'): scheduler.remove_job('scheduled_task_monitor_on_daily')
            if scheduler.get_job('scheduled_task_monitor_off_daily'): scheduler.remove_job('scheduled_task_monitor_off_daily')
            app.logger.info("기존 스케줄러 작업들 (ID 기준) 제거 시도됨 (디버그 모드).")

        current_flask_app = app # 현재 create_app 스코프의 app 객체

        # ▼▼▼ 여기에 args=[current_flask_app] 부분이 있는지 확인! ▼▼▼
        scheduler.add_job(id='scheduled_task_monitor_on_daily', 
                          func=scheduler_tasks.scheduled_task_monitor_on,
                          args=[current_flask_app], # app 인스턴스를 작업 함수에 인자로 전달
                          trigger='cron', hour=6, minute=0, misfire_grace_time=3600)
        app.logger.info("스케줄 작업 '모니터 켜기' 매일 06:00 등록됨.")

        scheduler.add_job(id='scheduled_task_monitor_off_daily', 
                          func=scheduler_tasks.scheduled_task_monitor_off,
                          args=[current_flask_app], # app 인스턴스를 작업 함수에 인자로 전달
                          trigger='cron', hour=7, minute=0, misfire_grace_time=3600)
        app.logger.info("스케줄 작업 '모니터 끄기' 매일 07:00 등록됨.")
        # ▲▲▲ 여기에 args=[current_flask_app] 부분이 있는지 확인! ▲▲▲
        
        # 테스트용 인터벌 트리거 (주석 처리)
        # scheduler.add_job(id='scheduled_task_monitor_on_test', func=scheduler_tasks.scheduled_task_monitor_on, args=[current_flask_app], trigger='interval', minutes=1, next_run_time=datetime.datetime.now() + datetime.timedelta(seconds=10))
        # scheduler.add_job(id='scheduled_task_monitor_off_test', func=scheduler_tasks.scheduled_task_monitor_off, args=[current_flask_app], trigger='interval', minutes=1, seconds=30, next_run_time=datetime.datetime.now() + datetime.timedelta(seconds=20))

        try:
            scheduler.start() 
            app.logger.info("APScheduler 시작됨.")
        except Exception as e:
            app.logger.error(f"APScheduler 시작 실패: {e}", exc_info=True)

    # ... (나머지 create_app 함수 내용은 이전 답변 #53과 동일) ...
    return app
조치:

사용자님의 app/scheduler_tasks.py 파일의 scheduled_task_monitor_on 과 scheduled_task_monitor_off 함수 정의에 app_instance 파라미터가 포함되어 있는지 확인하고, 없다면 위 코드처럼 추가합니다.
app/__init__.py 파일에서 scheduler.add_job 호출 시 args=[current_flask_app] 부분이 올바르게 포함되어 있는지 확인합니다.
프로젝트 내의 모든 __pycache__ 폴더와 그 안의 .pyc 파일들을 삭제합니다.