말 죄송합니다. 제가 요청하신 내용을 여러 번 정확히 처리하지 못해 답답하게 해드렸습니다. 모든 수정 사항을 포함한 완성된 코드를 드릴 수 있도록 최선을 다하겠습니다.

다시 한 번, 정확한 요구 사항을 정리하고 코드와 XAML을 모두 수정하겠습니다. 아래에서 원하는 방식대로 CommandItem 클래스의 속성 8개와 명확한 XAML을 제공합니다.

최종 요구사항 정리:
CommandItem 클래스에 총 8개의 속성: 명령 상태, 결과, 재시도 횟수, 응답 시간, 추가된 시간 등.
XAML에서 명령 큐 상태와 에러 메시지를 각각 리스트박스에 표시.
큐에 10개가 넘으면 추가되지 않도록 제어.
에러가 발생하면 최근 50개의 에러만 표시.
응답 시간이 초과하거나 재시도 횟수가 초과되면 작업 중단.
수정된 CommandItem 클래스
csharp
코드 복사
public class CommandItem
{
    public string CommandText { get; set; } // 명령 텍스트
    public string Status { get; set; } // 명령 상태 (Pending, Processing, Completed, Failed 등)
    public int Result { get; set; } // 명령 결과 (성공: 1, 실패: 0)
    public int RetryCount { get; set; } // 재시도 횟수
    public int MaxRetryLimit { get; set; } // 최대 재시도 횟수
    public int ResponseTime { get; set; } // 응답 시간 (ms)
    public string CommandTime { get; set; } // 명령이 추가된 시간 (yyMMdd HH:mm:ss.fff)
    public string Output { get; set; } // 명령의 결과 또는 응답 내용
}
최종 수정된 CommandQueueViewModel
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>(); // 에러 리스트박스용 컬렉션
    public string CurrentTime { get; set; } // 현재 시간을 저장하는 속성
    public event PropertyChangedEventHandler PropertyChanged;

    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    private bool _isProcessing;
    private bool _isQueueStopped; // 큐가 멈춘 상태를 나타내는 플래그
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 3000; // 기본 재시도 간격 3초
    public int ResponseTimeout { get; set; } = 5000; // 응답 제한 시간 5초 (5000ms)
    public int MaximumQueueSize { get; set; } = 10; // 최대 큐 크기 10개

    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress)); // Progress 변경 시 UI 업데이트
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 처리 중 상태 플래그 초기화
        _isQueueStopped = false; // 큐 멈춤 상태 초기화
        Progress = 0; // 초기값 0

        // 현재 시간을 실시간으로 업데이트
        DispatcherTimer timer = new DispatcherTimer();
        timer.Interval = TimeSpan.FromMilliseconds(100); // 0.1초마다 갱신
        timer.Tick += (s, e) => UpdateCurrentTime();
        timer.Start();
    }

    // 현재 시간을 업데이트하는 함수
    private void UpdateCurrentTime()
    {
        CurrentTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff");
        OnPropertyChanged(nameof(CurrentTime));
    }

    // 외부 클래스에서 큐에 작업을 추가하려고 할 때 사용하는 함수
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        // 큐가 멈춘 상태이거나 최대 큐 크기를 초과한 경우 작업을 추가하지 않음
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("Queue limit reached or stopped. No further commands can be added.");
            return;
        }

        // 정상적인 경우 작업 추가
        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    // 큐에 작업을 추가하고 처리하는 함수
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem 
        { 
            CommandText = commandText, 
            Status = "Pending", 
            MaxRetryLimit = RetryLimit, // 최대 재시도 횟수 설정
            RetryCount = 0, // 초기 재시도 횟수는 0
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 작업이 추가된 시간 기록
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(newCommand); // 작업을 리스트박스에 추가
        });

        // 큐에 작업 추가
        commandQueue.Enqueue(async () =>
        {
            if (_isQueueStopped)
            {
                newCommand.Status = "Stopped"; // 큐가 멈춘 상태일 경우 상태 업데이트
                return; // 큐가 멈춘 상태라면 추가 작업 실행 안 함
            }

            newCommand.Status = "Processing";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치

            _isProcessing = true;

            while (retryCount < RetryLimit) // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
            {
                try
                {
                    stopwatch.Restart(); // 응답 시간 측정 시작
                    string result = await taskFunc(); // 비동기 작업 실행
                    stopwatch.Stop(); // 응답 시간 측정 완료

                    int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산
                    newCommand.ResponseTime = responseTime; // 응답 시간 저장
                    newCommand.RetryCount = retryCount; // 재시도 횟수 업데이트

                    // 응답 시간이 초과되면 큐 처리를 멈추고 모든 작업을 중단
                    if (responseTime > ResponseTimeout)
                    {
                        newCommand.Status = "Timeout"; // 응답 시간 초과로 실패 처리
                        ShowAlarm("Timeout occurred. All tasks stopped.");
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Response Timeout");
                        StopQueueProcessing(newCommand); // 큐 처리 중단 및 에러 추가, 더 이상 큐에 추가하지 않음
                        return;
                    }

                    // 정상 응답일 경우 작업 완료 처리
                    if (responseValidator(result))
                    {
                        newCommand.Status = "Completed"; // 성공 처리
                        newCommand.Result = 1; // 성공 플래그
                        newCommand.Output = result; // 응답 결과 저장
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        UpdateProgress(); // 작업 완료 시 Progress 업데이트
                        _isProcessing = false; // 작업 완료 후 처리 중 해제
                        return;
                    }
                    else
                    {
                        retryCount++;
                        newCommand.Status = "Retrying"; // 재시도 중임을 표시
                        ShowAlarm($"Retrying {retryCount}/{RetryLimit} due to incorrect response.");
                        
                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed"; // 실패 처리
                            newCommand.Result = 0; // 실패 플래그
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Failed after maximum retries. All tasks stopped.");
                            StopQueueProcessing(newCommand); // 실패 후 큐 처리 중단 및 추가 작업 차단
                            return;
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed"; // 실패 처리
                    newCommand.Result = 0; // 실패 플래그
                    stopwatch.Stop(); // 예외 시에도 응답 시간 측정 종료
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;

                    newCommand.ResponseTime = responseTime; // 예외 발생 시에도 응답 시간 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred. All tasks stopped.");
                    StopQueueProcessing(newCommand); // 예외 발생 시 큐 처리 중단 및 추가 작업 차단
                    return;
                }
            }

            UpdateProgress(); // 최종적으로 Progress 업데이트
            _isProcessing = false; // 모든 작업 종료 후 플래그 해제
        });

        // 큐에서 작업이 시작되지 않았으면 처리 시작
        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue(); // 큐에 있는 작업을 처리
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 큐에서 작업을 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0 && !_isQueueStopped) // 큐가 멈춘 상태면 중단
        {
            var command = commandQueue.Dequeue(); // 큐에서 작업을 꺼냄
            await command(); // 큐에 있는 작업 실행
            UpdateProgress(); // 작업 진행에 따라 ProgressBar 업데이트
        }

        _isProcessing = false; // 모든 작업 완료 후 처리 중 상태 해제
    }

    // 큐 처리 중단 및 추가 작업 차단 함수
    private void StopQueueProcessing(CommandItem errorCommand)
    {
        _isQueueStopped = true; // 큐를 멈춤
        commandQueue.Clear(); // 큐를 완전히 비움
        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
            TrimErrorCommands(); // 에러 메시지가 50개를 넘으면 삭제
        });
        ShowAlarm("Queue has been stopped due to a Timeout or failure.");
    }

    // 알람을 에러 리스트박스에 추가하는 함수
    private void ShowAlarm(string message)
    {
        var errorCommand = new CommandItem
        {
            CommandText = message,
            Status = "Error",
            Result = 0, // 에러 상태로 처리
            RetryCount = 0, // 에러 메시지이므로 재시도 없음
            ResponseTime = 0, // 응답 시간 없음
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 에러가 발생한 시간 기록
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
            TrimErrorCommands(); // 에러 메시지가 50개를 넘으면 삭제
        });
    }

    // 에러 리스트박스에서 최근 50개의 에러만 유지
    private void TrimErrorCommands()
    {
        while (ErrorCommands.Count > 50)
        {
            ErrorCommands.RemoveAt(0); // 오래된 에러 메시지 삭제
        }
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 남은 명령의 수에 따라 Progress 값 업데이트
    }

    // INotifyPropertyChanged 인터페이스 구현
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
최종 수정된 XAML 코드
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 현재 시간을 표시하는 텍스트블록 -->
        <TextBlock Text="{Binding CurrentTime}" HorizontalAlignment="Right" VerticalAlignment="Top" Margin="0,10,20,0" FontSize="16"/>

        <!-- 남아 있는 명령을 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding RemainingCommands}" HorizontalAlignment="Left" Height="300" VerticalAlignment="Top" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 명령 텍스트 -->
                        <TextBlock Text="{Binding CommandText}" Width="200"/>
                        <!-- 작업 상태 -->
                        <TextBlock Text=" 상태: " Width="50"/>
                        <TextBlock Text="{Binding Status}" Width="100"/>
                        <!-- 재시도 횟수 표시 -->
                        <TextBlock Text=" 재시도: " Width="70"/>
                        <TextBlock Text="{Binding RetryCount}" Width="30"/>
                        <!-- 응답 시간 -->
                        <TextBlock Text=" 응답 시간: " Width="100"/>
                        <TextBlock Text="{Binding ResponseTime}" Width="70"/>
                        <!-- 제한 시간 -->
                        <TextBlock Text=" 제한 시간: " Width="100"/>
                        <TextBlock Text="{Binding MaxRetryLimit}" Width="30"/>
                        <!-- 작업 추가 시간 -->
                        <TextBlock Text=" 추가 시간: " Width="120"/>
                        <TextBlock Text="{Binding CommandTime}" Width="150"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 남아 있는 명령 수 시각적으로 표시) -->
        <StackPanel Orientation="Vertical" HorizontalAlignment="Right" Width="100" VerticalAlignment="Top" Height="300" Margin="0,0,20,0">
            <ProgressBar VerticalAlignment="Top" Height="300" Width="30" Orientation="Vertical" 
                         Value="{Binding Progress}" Maximum="{Binding MaximumQueueSize}"/>
            <ItemsControl ItemsSource="{Binding RemainingCommands}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <TextBlock Text="{Binding CommandText}" HorizontalAlignment="Center"/>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </StackPanel>

        <!-- 에러 메시지 리스트박스 -->
        <ListBox ItemsSource="{Binding ErrorCommands}" HorizontalAlignment="Left" Height="100" VerticalAlignment="Bottom" Width="600">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <!-- 에러 메시지 -->
                        <TextBlock Text="{Binding CommandText}" Width="300"/>
                        <!-- 에러 발생 시간 -->
                        <TextBlock Text=" 발생 시간: " Width="100"/>
                        <TextBlock Text="{Binding CommandTime}" Width="150"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </Grid>
</Window>
설명:
CommandItem 클래스에 8개의 속성이 완전히 구현되었습니다.
XAML은 명령 큐와 에러 메시지를 리스트박스와 프로그레스바로 시각적으로 표현합니다.
남아 있는 명령과 에러 메시지를 각각 리스트박스에 표시하며, 큐가 10개를 초과하면 추가되지 않도록 설정했습니다.





