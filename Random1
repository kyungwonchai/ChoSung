 알겠습니다. 두 가지 문제를 해결해 드리겠습니다.

routes_user.py 최종 코드 제공 (pymssql 직접 사용 방식)
달력 예외 추가 시 "specified as_dict=True and there are columns with no names:[0]" 오류 해결
1. app/routes_admin.py의 달력 예외 추가 오류 수정
오류 메시지 "specified as_dict=True and there are columns with no names:[0]"는 pymssql 커서가 결과를 딕셔너리 형태로 반환하도록 as_dict=True로 설정되어 있을 때, SQL 쿼리 결과의 특정 컬럼에 이름이 제대로 부여되지 않아 발생하는 문제입니다.

manage_calendar_exceptions 함수의 POST (예외 추가) 로직 중 날짜 중복 확인 쿼리 부분을 수정해야 합니다.

수정 대상: app/routes_admin.py 파일의 manage_calendar_exceptions 함수 내 POST 처리 부분

기존 코드:

Python

                # 날짜 중복 확인 (PK 위반 방지)
                cursor.execute("SELECT 1 FROM dbo.work_calendar_exceptions WHERE exception_date = %s", (exception_date_val.strftime('%Y-%m-%d'),))
                if cursor.fetchone():
                    flash(f"오류: 날짜 {exception_date_val.strftime('%Y-%m-%d')} 에 대한 예외가 이미 존재합니다.", 'error')
수정 후 코드 (컬럼에 별칭 부여):

Python

                # 날짜 중복 확인 (PK 위반 방지)
                cursor.execute("SELECT 1 AS existing_check FROM dbo.work_calendar_exceptions WHERE exception_date = %s", (exception_date_val.strftime('%Y-%m-%d'),))
                if cursor.fetchone(): # 결과가 있다면 existing_check 키가 있는 딕셔너리가 반환됨
                    flash(f"오류: 날짜 {exception_date_val.strftime('%Y-%m-%d')} 에 대한 예외가 이미 존재합니다. 삭제 후 다시 추가하거나 수정 기능을 이용하세요.", 'error')
이유: SELECT 1과 같이 상수 값을 선택하면 결과 컬럼에 이름이 자동으로 부여되지 않을 수 있습니다. SELECT 1 AS existing_check와 같이 명시적으로 컬럼 별칭(alias)을 지정하면 pymssql이 딕셔너리 키로 사용할 수 있게 되어 오류가 해결됩니다.

이 수정 사항이 반영된 routes_admin.py 전체 코드는 이전 답변(#49)을 참고하여 해당 부분만 수정해 주시면 됩니다. 만약 전체 파일이 다시 필요하시면 요청해주세요.

2. 최종: app/routes_user.py (전체 코드, pymssql 직접 사용)
사용자 제어판 관련 라우트입니다. PC 목록 조회 부분을 pymssql 직접 호출 방식으로 수정하고, 명령 전송 로직은 이전과 동일하게 socket_client.py를 사용합니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection # pymssql 연결 유틸리티
from app.auth import ip_auth_required
from app.socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt_datetime, timezone # dt_datetime으로 별칭 사용
import math

user_bp = Blueprint('user', __name__)

@user_bp.route('/control_panel')
@ip_auth_required('user') # 관리자 또는 허용된 사용자만 접근 가능
def control_panel():
    page = request.args.get('page', 1, type=int)
    per_page = 20 
    offset = (page - 1) * per_page
    pcs_on_current_page = []
    total_pcs = 0
    conn = None
    # 페이지네이션 데이터 기본값 초기화
    pagination_data = {
        'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 
        'items': [], 'has_prev': False, 'has_next': False, 
        'prev_num': 1, 'next_num': 1
    }

    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            # 총 PC 개수 조회
            cursor.execute("SELECT COUNT(*) AS total FROM dbo.target_pcs")
            total_pcs_result = cursor.fetchone()
            if total_pcs_result:
                total_pcs = total_pcs_result.get('total', 0) # .get()으로 안전하게 접근
            
            if total_pcs > 0:
                # 현재 페이지 PC 목록 조회 (MSSQL OFFSET FETCH 사용)
                query_data = """
                    SELECT id, pc_name, address1, address2, description 
                    FROM dbo.target_pcs 
                    ORDER BY pc_name 
                    OFFSET %s ROWS FETCH NEXT %s ROWS ONLY
                """
                cursor.execute(query_data, (offset, per_page))
                pcs_on_current_page = cursor.fetchall() # as_dict=True 이므로 딕셔너리 리스트
            
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({
                'total_items': total_pcs, 
                'total_pages': total_pages, 
                'items': pcs_on_current_page, 
                'has_prev': page > 1, 
                'has_next': page < total_pages,
                'prev_num': page - 1 if page > 1 else 1,
                'next_num': page + 1 if page < total_pages else total_pages
            })

    except Exception as e:
        current_app.logger.error(f"제어판 PC 목록 조회 오류: {e}", exc_info=True)
        flash("PC 목록을 불러오는 중 오류가 발생했습니다. DB 연결을 확인하세요.", "error")
        # 오류 발생 시 pcs_on_current_page는 빈 리스트, total_pcs는 0으로 유지됨
        
    title = "원격 제어판"
    if g.current_user_role == 'admin': # g 객체는 auth.py의 컨텍스트 프로세서에 의해 설정됨
        title = "원격 제어판 (관리자 모드)"
        
    return render_template('user/control_panel.html', 
                           pcs=pcs_on_current_page, # pagination_data['items']와 동일
                           pagination=pagination_data, 
                           title=title)

@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    selected_pc_ids_str = request.form.getlist('selected_pcs')
    command_action_str = request.form.get('command_action')

    if not selected_pc_ids_str:
        flash("제어할 PC를 하나 이상 선택해주세요.", 'warning')
        return redirect(url_for('user.control_panel'))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]:
        flash("수행할 명령(켜기/끄기)이 올바르게 지정되지 않았습니다.", 'warning')
        return redirect(url_for('user.control_panel'))

    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]
    
    timeout_minutes_for_command = 0 if command_action_str == "켜기" else 1
    action_description_log = "디스플레이 항상 켜기 설정(타임아웃 0분)" if command_action_str == "켜기" else "디스플레이 1분 후 자동 꺼짐 설정"
    payload_for_agent = {'TimeoutMinutes': timeout_minutes_for_command}

    conn = None
    target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids:
                placeholders = ', '.join(['%s'] * len(selected_pc_ids)) # 올바른 플레이스홀더 사용
                sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"
                # pymssql은 %s 플레이스홀더에 대해 튜플 형태로 파라미터를 전달해야 함
                cursor.execute(sql_select_pcs, tuple(selected_pc_ids))
                target_pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True)
        flash("명령 대상 PC 정보를 DB에서 조회하는 중 오류가 발생했습니다.", "error")
        return redirect(url_for('user.control_panel'))

    if not target_pcs_to_control:
        flash("선택된 PC 정보를 찾을 수 없습니다.", "warning")
        return redirect(url_for('user.control_panel'))

    for pc_data in target_pcs_to_control: # pc_data는 딕셔너리
        command_packet_to_send = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': dt_datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': "SET_DISPLAY_TIMEOUT", 
            'PayloadJson': json.dumps(payload_for_agent),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command_send = ""
        # pc_data가 딕셔너리이므로 .get() 사용 또는 키 존재 확인
        is_relay = bool(pc_data.get('address2') and pc_data.get('address2','').strip())

        if is_relay:
            command_packet_to_send['Instruction'] = "RelayToTarget"
            command_packet_to_send['FinalTargetIpForRelayedCommand'] = pc_data.get('address2')
            command_packet_to_send['FinalTargetPortForRelayedCommand'] = 4026
            target_ip_for_command_send = pc_data.get('address1')
        else:
            command_packet_to_send['Instruction'] = "DirectExecute"
            target_ip_for_command_send = pc_data.get('address1')
        
        log_msg_prefix = f"PC '{pc_data.get('pc_name', 'N/A')}' ({target_ip_for_command_send})"
        flash(f"{log_msg_prefix}에 '{action_description_log}' 명령 전송 시도...", 'info')
        current_app.logger.info(f"{log_msg_prefix} - 명령 전송: {action_description_log}, PktID: {command_packet_to_send['PacketId']}")
        
        agent_response = send_command_to_agent(target_ip_for_command_send, command_packet_to_send)
        
        _process_agent_response(agent_response, log_msg_prefix, action_description_log) # 헬퍼 함수 사용

        # "켜기" 명령일 때 추가로 MonitorControl (On) 명령 전송
        if command_action_str == "켜기":
            action_desc_monitor_on = "모니터 즉시 켜기"
            payload_monitor_on = {'Action': -1} # MonitorAction.On
            
            packet_monitor_on = {
                'PacketId': str(uuid.uuid4()), 
                'TimestampUtc': dt_datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
                'CommandName': "MONITOR_CONTROL", 'PayloadJson': json.dumps(payload_monitor_on),
                'ResponseAddress': None, 'ResponsePort': None,
                'Instruction': command_packet_to_send['Instruction'], # 이전 Instruction 유지
                'FinalTargetIpForRelayedCommand': command_packet_to_send.get('FinalTargetIpForRelayedCommand'),
                'FinalTargetPortForRelayedCommand': command_packet_to_send.get('FinalTargetPortForRelayedCommand')
            }
            flash(f"{log_msg_prefix}에 '{action_desc_monitor_on}' 명령 추가 전송 시도...", 'info')
            current_app.logger.info(f"{log_msg_prefix} - 명령 전송: {action_desc_monitor_on}, PktID: {packet_monitor_on['PacketId']}")
            agent_response_monitor_on = send_command_to_agent(target_ip_for_command_send, packet_monitor_on)
            _process_agent_response(agent_response_monitor_on, log_msg_prefix, action_desc_monitor_on)


    return redirect(url_for('user.control_panel'))

def _process_agent_response(agent_response, log_prefix, command_description):
    """에이전트 응답을 처리하고 flash 메시지와 로그를 남기는 헬퍼 함수"""
    if agent_response.get('success'):
        raw_resp_packet = agent_response.get('raw_response')
        if raw_resp_packet and isinstance(raw_resp_packet, dict) and 'PayloadJson' in raw_resp_packet:
            payload_json_str = raw_resp_packet.get('PayloadJson')
            current_app.logger.info(f"{log_prefix} - '{command_description}' 응답 PayloadJson: >>>{payload_json_str}<<<")
            if payload_json_str is not None:
                try:
                    resp_payload = json.loads(payload_json_str) 
                    if resp_payload.get('Success'):
                        flash(f"{log_prefix} ({command_description}): 성공 - {resp_payload.get('Message', 'OK')}", 'success')
                        current_app.logger.info(f"{log_prefix} ({command_description}) - 성공: {resp_payload.get('Message')}")
                    else:
                        flash(f"{log_prefix} ({command_description}): 실패 (에이전트) - {resp_payload.get('Message', 'Agent error')}", 'error')
                        current_app.logger.error(f"{log_prefix} ({command_description}) - 에이전트 실패: {resp_payload.get('Message')}")
                except json.JSONDecodeError as je:
                    flash(f"{log_prefix} ({command_description}): 응답 페이로드 JSON 형식 오류 - {je.msg}", 'error')
                    current_app.logger.error(f"{log_prefix} ({command_description}) - PayloadJson 파싱 오류: {je.msg}. 원본: {payload_json_str}", exc_info=True)
                except Exception as e:
                    flash(f"{log_prefix} ({command_description}): 응답 페이로드 처리 중 알 수 없는 오류 - {e}", 'error')
                    current_app.logger.error(f"{log_prefix} ({command_description}) - PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_json_str}", exc_info=True)
            else:
                flash(f"{log_prefix} ({command_description}): 전송 성공 (에이전트 페이로드 없음)", 'warning')
                current_app.logger.warning(f"{log_prefix} ({command_description}) - 전송 성공, 페이로드 없음. RawPkt: {raw_resp_packet}")
        else:
            flash(f"{log_prefix} ({command_description}): 전송 성공 (에이전트 상세 응답 확인 불가)", 'warning')
            current_app.logger.warning(f"{log_prefix} ({command_description}) - 전송 성공, 상세 응답/페이로드 없음. RawPkt: {raw_resp_packet}")
    else:
        flash(f"{log_prefix} ({command_description}): 전송 실패 - {agent_response.get('message', 'Unknown socket error')}", 'error')
        current_app.logger.error(f"{log_prefix} ({command_description}) - 전송 실패: {agent_response.get('message')}")

app/routes_user.py 주요 변경 사항:

control_panel() 함수:
PC 목록 조회 시 pymssql을 사용하도록 수정했습니다.
페이지네이션 관련 변수(total_pcs_result, pcs_on_current_page)가 None일 경우를 대비한 안전장치를 추가했습니다.
pagination_data 딕셔너리를 사용하여 페이지네이션 정보를 템플릿에 전달합니다. (이전 _get_pagination_data 유틸리티 함수와 유사한 정보를 직접 생성)
send_batch_command() 함수:
선택된 PC들의 정보를 DB에서 조회하는 부분을 pymssql 직접 호출로 변경했습니다. IN (...) 절에 파라미터를 전달하기 위해 플레이스홀더 문자열을 동적으로 생성하고 tuple(selected_pc_ids)를 사용합니다.
pc_data가 딕셔너리이므로 pc_data.get('address2', '').strip() 와 같이 .get()을 사용하여 안전하게 필드에 접근하도록 수정했습니다.
"켜기" 명령 시, SetDisplayTimeout 명령 전송 후 추가로 MonitorControl (On) 명령을 전송하는 로직은 그대로 유지됩니다.
_process_agent_response 헬퍼 함수: 이전 답변에서 추가된 이 함수는 변경 없이 그대로 사용됩니다.
위 수정된 app/routes_user.py 파일을 프로젝트에 적용해 주십시오. 이로써 Flask 애플리케이션의 사용자 제어판 기능도 pymssql을 직접 사용하여 데이터베이스와 상호작용하도록 변경되었습니다.

이제 Flask 애플리케이션의 모든 주요 Python 파일들(config.py, app/__init__.py, app/db_utils.py, app/auth.py, app/routes_admin.py, app/routes_user.py, app/socket_client.py)이 pymssql 직접 사용 방식에 맞게 수정된 상태입니다.