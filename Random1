러 메시지 Can't create handler inside thread that has not called Looper.prepare()는 UI 작업이 메인(UI) 스레드가 아닌 다른 스레드에서 실행될 때 발생하는 문제입니다. Android에서는 UI 관련 작업, 특히 AlertDialog와 같은 팝업 창을 메인 스레드에서 실행해야 합니다.

SignalR에서 메시지를 수신할 때 코루틴이나 다른 비동기 스레드에서 실행되므로, UI 스레드로 전환해서 팝업을 띄워야 합니다. 이를 해결하기 위해 runOnUiThread를 사용하여 UI 작업을 메인 스레드에서 실행하도록 수정하겠습니다.

수정된 코드
아래는 playAlarmSound 함수에서 AlertDialog를 UI 스레드에서 실행하도록 수정한 코드입니다.

kotlin
코드 복사
private fun playAlarmSound() {
    // 사운드 재생 설정
    try {
        val alarmSound: Uri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM)
            ?: RingtoneManager.getDefaultUri(RingtoneManager.TYPE_NOTIFICATION)

        mediaPlayer = MediaPlayer().apply {
            setAudioAttributes(
                AudioAttributes.Builder()
                    .setContentType(AudioAttributes.CONTENT_TYPE_SONIFICATION)
                    .setUsage(AudioAttributes.USAGE_ALARM)
                    .build()
            )
            setDataSource(this@MainActivity, alarmSound)
            isLooping = true // 사운드를 반복 재생
            prepare()
            start()
        }
    } catch (e: Exception) {
        Log.e("MainActivity", "Failed to play alarm sound", e)
    }

    // UI 스레드에서 팝업 창을 띄우기
    runOnUiThread {
        val builder = AlertDialog.Builder(this)
        builder.setTitle("알림")
            .setMessage("문제를 확인하고 창을 터치하여 경고음을 종료하세요.")
            .setPositiveButton("확인") { dialog, _ ->
                stopAlarmSound() // 사운드 멈춤
                dialog.dismiss()
            }
            .setCancelable(false) // 사용자가 창을 닫기 전까지 팝업이 꺼지지 않음
        builder.create().show()
    }
}

private fun stopAlarmSound() {
    mediaPlayer?.let {
        if (it.isPlaying) {
            it.stop()
            it.release()
        }
    }
}
설명
runOnUiThread 사용:

runOnUiThread를 사용하여 AlertDialog가 항상 메인(UI) 스레드에서 실행되도록 합니다.
이 방법은 다른 스레드에서 실행된 작업을 UI 스레드로 전환할 때 사용합니다.
playAlarmSound 함수:
