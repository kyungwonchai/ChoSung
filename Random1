알겠습니다. 현재 입력된 글자 상태에 맞게 행 높이가 즉시 늘어나고 줄어들어야 하는데, 지금은 늘어나기만 한다는 문제를 수정하겠습니다.

이 문제의 주된 원인은 브라우저가 style.height = 'auto'로 변경된 후, 실제 높이가 DOM에 반영되어 scrollHeight가 정확히 계산되기까지의 타이밍과 관련이 있을 수 있습니다. 또는, 높이를 계산하는 로직이 축소되는 경우를 제대로 반영하지 못했을 수 있습니다.

다음과 같이 수정해 보겠습니다:

adjustSingleRowHeight 함수 개선:
먼저 해당 행의 모든 셀 높이를 'auto'로 설정하여 자연스러운 높이를 갖도록 합니다.
그 후에 각 셀의 scrollHeight를 읽어 최대 높이를 계산합니다. 이렇게 단계를 분리하면 브라우저가 'auto' 높이를 반영할 시간을 더 확실히 가질 수 있습니다.
input 이벤트 핸들러 단순화:
편집 중인 셀의 input 이벤트 핸들러에서는 adjustSingleRowHeight 함수만 호출하도록 하여, 높이 계산 로직을 한 곳에서 관리합니다.
templates/index.html의 <script> 부분 수정:

HTML

<script>
    // Helper function to adjust the height of a single row
    function adjustSingleRowHeight(rowElement) {
        if (!rowElement) return;

        const cellsInRow = rowElement.getElementsByTagName('td');

        // 1. Reset all cells in the row to 'auto' height first.
        // This allows them to naturally shrink or grow based on their current content.
        for (let j = 0; j < cellsInRow.length; j++) {
            cellsInRow[j].style.height = 'auto';
        }

        // To ensure the 'auto' height has taken effect before reading scrollHeight,
        // a micro-delay or forcing a reflow might be needed in some edge cases.
        // However, modern browsers are usually good. Forcing reflow: void rowElement.offsetHeight;

        // 2. Now, calculate the maximum scrollHeight among all cells in that row.
        let maxHeightInRow = 0;
        for (let j = 0; j < cellsInRow.length; j++) {
            const cell = cellsInRow[j];
            // scrollHeight should now reflect the height after 'auto' and content changes.
            // For an empty contenteditable cell with padding, scrollHeight will be padding + one line's height.
            if (cell.scrollHeight > maxHeightInRow) {
                maxHeightInRow = cell.scrollHeight;
            }
        }

        // 3. Apply the determined maxHeightInRow to all cells in the row and the row itself.
        // Ensure a minimum height if needed, though scrollHeight usually includes padding and a line.
        // Example: if (maxHeightInRow > 0 && maxHeightInRow < 24) maxHeightInRow = 24; // Minimum for padding + one line
        
        if (maxHeightInRow > 0) {
            for (let j = 0; j < cellsInRow.length; j++) {
                cellsInRow[j].style.height = maxHeightInRow + 'px';
            }
            rowElement.style.height = maxHeightInRow + 'px'; // Set row height explicitly too
        } else {
            // Fallback if somehow maxHeightInRow is 0 (very unlikely with padding)
            for (let j = 0; j < cellsInRow.length; j++) {
                cellsInRow[j].style.height = 'auto';
            }
            rowElement.style.height = 'auto';
        }
    }

    // Function to adjust all rows in the table
    function adjustAllTableHeights() {
        const table = document.getElementById('myTable');
        if (!table) return;
        const tbody = table.getElementsByTagName('tbody')[0];
        if (!tbody) return;
        const rows = tbody.getElementsByTagName('tr');
        for (let i = 0; i < rows.length; i++) {
            adjustSingleRowHeight(rows[i]);
        }
    }

    // --- Modal Logic (remains the same) ---
    const modal = document.getElementById("imageModal");
    const modalImg = document.getElementById("modalImage");
    const captionText = document.getElementById("modalCaption");
    const closeButton = document.getElementsByClassName("close-button")[0];

    function openModal(element) {
        modal.style.display = "block";
        modalImg.src = element.src;
        captionText.innerHTML = element.dataset.title || element.alt;
    }

    // --- Editable Cell & Thumbnail Logic ---
    function initializeTableInteractions() {
        // Thumbnails
        const currentThumbnails = document.querySelectorAll(".thumbnail-image");
        currentThumbnails.forEach(thumb => {
            // Remove existing listener before adding, or use a flag if preferred
            thumb.removeEventListener('click', thumbnailClickHandler); // Use named function for removal
            thumb.addEventListener('click', thumbnailClickHandler);
        });

        // Editable Cells
        const currentEditableCells = document.querySelectorAll('td.description-cell[contenteditable="true"]');
        currentEditableCells.forEach(cell => {
            cell.removeEventListener('input', editableCellInputHandler);
            cell.addEventListener('input', editableCellInputHandler);

            cell.removeEventListener('blur', editableCellBlurHandler);
            cell.addEventListener('blur', editableCellBlurHandler);
        });
    }
    
    // Named event handlers for easier add/remove
    function thumbnailClickHandler() { // 'this' will be the image element
        openModal(this);
    }

    function editableCellInputHandler() { // 'this' will be the TD cell
        const row = this.closest('tr');
        if (row) {
            adjustSingleRowHeight(row);
        }
    }

    function editableCellBlurHandler() { // 'this' will be the TD cell
        const row = this.closest('tr');
        if (row) {
            adjustSingleRowHeight(row); // Final adjustment
        }
        // console.log(`Content for ID ${this.dataset.id} changed to: ${this.innerText}`); // For saving data
    }


    // Initial setup and listeners
    window.addEventListener('load', function() {
        adjustAllTableHeights();
        initializeTableInteractions(); // Initialize all event listeners
    });

    if(closeButton) { // Modal close button
        closeButton.onclick = function() { modal.style.display = "none"; }
    }
    window.onclick = function(event) { // Modal close on overlay click
        if (event.target == modal) { modal.style.display = "none"; }
    }

    let resizeTimeout;
    window.addEventListener('resize', function() {
        clearTimeout(resizeTimeout);
        resizeTimeout = setTimeout(function() {
            adjustAllTableHeights();
        }, 150);
    });
</script>
주요 변경 및 설명:

adjustSingleRowHeight(rowElement) 함수 수정:

1단계 (모든 셀 높이 'auto' 설정): 함수 시작 부분에서 전달받은 행(rowElement) 내부의 모든 <td> 셀들의 style.height를 'auto'로 먼저 설정합니다. 이렇게 하면 각 셀이 현재 내용에 맞게 자연스럽게 줄어들거나 늘어날 준비를 합니다.
2단계 (최대 scrollHeight 계산): 그 다음, 다시 모든 셀을 순회하면서 scrollHeight (패딩을 포함한 실제 콘텐츠 높이)를 읽어, 해당 행에서 가장 큰 scrollHeight 값을 찾습니다. scrollHeight는 'auto'로 설정된 후의 값이어야 정확합니다.
3단계 (계산된 최대 높이 적용): 찾아낸 maxHeightInRow 값을 해당 행의 모든 셀과 행 자체의 style.height로 설정합니다. 이렇게 하면 행 내의 모든 셀이 동일한 높이를 가지며, 내용이 줄어들면 maxHeightInRow 자체가 작아지므로 행 전체 높이도 줄어듭니다.
padding: 5px인 경우, 내용이 완전히 없어도 셀은 최소한 10px (상하패딩) + 한 줄의 line-height 만큼의 scrollHeight를 가집니다. 따라서 maxHeightInRow가 0이 되는 경우는 거의 없습니다.
editableCellInputHandler (이전 input 이벤트 핸들러) 단순화:

이제 input 이벤트가 발생하면, 해당 셀이 속한 행을 찾아 adjustSingleRowHeight() 함수만 호출합니다. 높이 조절에 대한 모든 복잡한 로직은 adjustSingleRowHeight 함수 내에서 처리됩니다. 이렇게 하면 코드가 더 명확해지고 관리가 쉬워집니다.
이벤트 리스너 관리 개선 (initializeTableInteractions 함수 도입):

썸네일 이미지와 편집 가능한 셀에 대한 이벤트 리스너 할당 로직을 initializeTableInteractions라는 별도의 함수로 옮겼습니다.
리스너를 추가하기 전에 removeEventListener를 호출하여 (이름 있는 함수 핸들러 사용 시 가능) 중복으로 리스너가 등록되는 것을 방지했습니다. 이는 특히 동적으로 콘텐츠가 변경될 수 있는 경우에 유용하지만, 이 예제에서도 좋은 습관입니다.
window.addEventListener('load', ...) 내에서 initializeTableInteractions()를 호출하여 초기 로드 시 모든 상호작용 요소를 설정합니다.
이 변경으로:

사용자가 contenteditable 셀의 내용을 삭제하면, 해당 셀의 scrollHeight가 줄어듭니다.
adjustSingleRowHeight 함수는 이 줄어든 scrollHeight를 감지하고, 해당 행의 다른 셀들도 이 새로운 (더 작아진) 최대 높이에 맞춰 높이가 조절됩니다.