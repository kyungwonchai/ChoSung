, 알겠습니다. MVVM 패턴을 유지하면서 센서 값 감시 로직을 통합하는 구조와 코드를 다시 정리해 드리겠습니다.

구조 설명:

Models 폴더: 데이터 자체를 나타내는 클래스를 둡니다.
DT2330M.cs: sensor 속성을 포함하는 순수 데이터 클래스입니다. 이 클래스의 인스턴스는 외부(예: 통신 서비스)에 의해 업데이트됩니다. ViewModel은 이 모델의 데이터를 사용합니다.
ViewModels 폴더: View와 Model 사이의 중개자 역할을 하는 클래스를 둡니다. UI 로직, 데이터 가공, 명령 처리 등을 담당합니다.
MainViewModel.cs (또는 해당 기능을 담당하는 ViewModel):
DT2330M 모델 인스턴스에 대한 참조를 가집니다 (생성자 주입, 서비스 로케이터 등 다양한 방법으로 얻을 수 있습니다).
센서 감시 로직(StartMonitoring, StopMonitoringAsync, MonitorSensorLoopAsync, OnSensorBecameFiveAsync)을 포함합니다.
View에 표시해야 할 데이터나 상태(예: 현재 센서 값, 감시 상태 등)가 있다면 INotifyPropertyChanged를 구현하고 관련 속성을 노출합니다.
View의 생명주기(Loaded, Unloaded 등)나 특정 명령(Command)에 맞춰 감시 시작/중지 메서드를 호출합니다.
Views 폴더: 사용자 인터페이스(XAML 등)와 관련된 파일을 둡니다.
MainWindow.xaml (또는 해당 View): ViewModel을 DataContext로 설정하고, ViewModel이 노출하는 속성에 데이터를 바인딩합니다. 필요시 View의 코드 비하인드(예: MainWindow.xaml.cs)에서 ViewModel의 감시 시작/중지 메서드를 호출할 수 있습니다.
코드 예시:

1. Models/DT2330M.cs

C#

namespace YourApp.Models // <-- 실제 네임스페이스로 변경하세요
{
    // 순수 데이터 모델 클래스
    public class DT2330M
    {
        // 이 값은 외부 서비스(예: PLC 통신)에 의해 업데이트됩니다.
        public int Sensor { get; set; }

        // DT2330M 관련 다른 데이터 속성들...

        // 테스트용 메서드 (실제로는 외부에서 변경됨)
        public void SimulateExternalChange(int newValue)
        {
            // Console.WriteLine($"[MODEL:{GetHashCode()}] Sensor 값을 {newValue}(으)로 변경 시도");
            this.Sensor = newValue;
            // 만약 Sensor 값 변경 시 ViewModel이 즉시 알아야 한다면,
            // 이 모델 클래스도 INotifyPropertyChanged를 구현할 수 있습니다.
            // 하지만 여기서는 ViewModel이 주기적으로 폴링하므로 필수는 아닙니다.
        }
    }
}
2. ViewModels/MainViewModel.cs (또는 관련 ViewModel)

C#

using System;
using System.ComponentModel; // INotifyPropertyChanged 사용 시
using System.Runtime.CompilerServices; // CallerMemberName 사용 시
using System.Threading;
using System.Threading.Tasks;
using YourApp.Models; // <-- 실제 네임스페이스로 변경하세요

namespace YourApp.ViewModels // <-- 실제 네임스페이스로 변경하세요
{
    // ViewModel은 INotifyPropertyChanged를 구현하는 것이 일반적입니다.
    public class MainViewModel : INotifyPropertyChanged, IDisposable
    {
        // --- Model ---
        private readonly DT2330M _dt2330mModel; // 감시 대상 모델

        // --- Monitoring State ---
        private CancellationTokenSource _monitorCts;
        private Task _monitoringTask;
        private int _previousSensorValue = -1; // 이전 센서 값 저장
        private bool _isMonitoring;

        // --- Properties for View Binding (Optional) ---
        public bool IsMonitoring
        {
            get => _isMonitoring;
            private set => SetProperty(ref _isMonitoring, value);
        }

        // 생성자: 모델 인스턴스를 주입받는 것이 좋습니다.
        public MainViewModel(DT2330M dt2330mModel)
        {
            _dt2330mModel = dt2330mModel ?? throw new ArgumentNullException(nameof(dt2330mModel));
            // 필요하다면 모델의 초기값을 읽어올 수 있습니다.
            // _previousSensorValue = _dt2330mModel.Sensor;
        }

        // --- Monitoring Control Methods ---

        // 감시 시작 (View 로드 시 또는 특정 버튼 클릭 시 호출)
        public void StartSensorMonitoring()
        {
            if (IsMonitoring)
            {
                Console.WriteLine("이미 감시 중입니다.");
                return;
            }

            _monitorCts = new CancellationTokenSource();
            _previousSensorValue = _dt2330mModel.Sensor; // 시작 시점의 값으로 초기화

            Console.WriteLine($"[VM] 센서 감시 시작. 초기 값: {_previousSensorValue}");
            IsMonitoring = true; // 상태 변경 (View에 알림)
            _monitoringTask = MonitorSensorLoopAsync(_monitorCts.Token);
        }

        // 감시 중지 (View 언로드 시 또는 특정 버튼 클릭 시 호출)
        public async Task StopSensorMonitoringAsync()
        {
            if (!IsMonitoring || _monitorCts == null)
            {
                return;
            }

            Console.WriteLine("[VM] 센서 감시 중지 요청...");
            _monitorCts.Cancel();

            if (_monitoringTask != null)
            {
                try
                {
                    await _monitoringTask; // 작업 완료 대기
                }
                catch (OperationCanceledException) { /* 정상 취소 */ }
                catch (Exception ex)
                {
                    Console.WriteLine($"[VM] 감시 중지 중 오류: {ex.Message}");
                    // 오류 처리
                }
            }

            _monitorCts.Dispose();
            _monitorCts = null;
            _monitoringTask = null;
            IsMonitoring = false; // 상태 변경 (View에 알림)
            Console.WriteLine("[VM] 센서 감시 중지 완료.");
        }

        // --- Core Monitoring Logic (Private) ---

        private async Task MonitorSensorLoopAsync(CancellationToken token)
        {
            Console.WriteLine("[VM] Monitor loop started.");
            try
            {
                while (!token.IsCancellationRequested)
                {
                    // 모델의 현재 센서 값 읽기
                    int currentSensorValue = _dt2330mModel.Sensor;

                    // 조건 확인: != 5 에서 5로 변경되었는가?
                    if (currentSensorValue == 5 && _previousSensorValue != 5)
                    {
                        Console.WriteLine($"[VM][감지!] Sensor: {_previousSensorValue} -> {currentSensorValue}. 액션 실행!");
                        // 조건 만족 시 실행할 비동기 함수 호출
                        await OnSensorBecameFiveAsync(); // ViewModel 내의 다른 메서드 호출
                    }

                    // 다음 루프를 위해 현재 값 저장
                    _previousSensorValue = currentSensorValue;

                    // 대기 (주기 설정)
                    await Task.Delay(200, token); // 0.2초 간격
                }
            }
            catch (OperationCanceledException)
            {
                Console.WriteLine("[VM] Monitor loop cancelled.");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[VM] Monitor loop error: {ex.Message}");
                IsMonitoring = false; // 오류 발생 시 모니터링 상태 업데이트
                // 오류 처리 (로깅 등)
            }
            finally
            {
                 Console.WriteLine("[VM] Monitor loop finished.");
            }
        }

        // --- Action Method (Private) ---

        // 센서 값이 5가 되었을 때 실행할 실제 로직
        private async Task OnSensorBecameFiveAsync()
        {
            Console.ForegroundColor = ConsoleColor.Cyan;
            Console.WriteLine("[VM] ===> OnSensorBecameFiveAsync() 실행 시작...");
            // 여기에 필요한 비동기 작업 수행
            // 예: 다른 서비스 호출, 상태 업데이트, 로그 전송 등
            await Task.Delay(1000); // 작업 시뮬레이션
            Console.WriteLine("[VM] ===> OnSensorBecameFiveAsync() 실행 완료.");
            Console.ResetColor();
        }


        // --- INotifyPropertyChanged Implementation ---
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T field, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(field, value)) return false;
            field = value;
            OnPropertyChanged(propertyName);
            return true;
        }

        // --- IDisposable Implementation ---
        private bool disposedValue;
        protected virtual void Dispose(bool disposing)
        {
            if (!disposedValue)
            {
                if (disposing)
                {
                    // 관리형 리소스 해제 (CancellationTokenSource 등)
                    // Stop 메서드를 동기적으로 기다리는 것은 주의해야 할 수 있음 (데드락 가능성)
                    // 비동기 Dispose 패턴을 고려하거나, ViewModel 소멸 시점 관리 필요
                     _monitorCts?.Cancel(); // 먼저 취소 요청
                     _monitorCts?.Dispose(); // 그 다음 Dispose
                     _monitorCts = null;
                     // _monitoringTask 관련 정리는 StopAsync에서 처리
                    Console.WriteLine("[VM] Disposed.");
                }
                // 비관리형 리소스 해제 (필요시)
                disposedValue = true;
            }
        }

        public void Dispose()
        {
            Dispose(disposing: true);
            GC.SuppressFinalize(this);
        }
    }
}
3. Views/MainWindow.xaml (예시)

XML

<Window x:Class="YourApp.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:local="clr-namespace:YourApp.Views"
        xmlns:vm="clr-namespace:YourApp.ViewModels"
        mc:Ignorable="d"
        Title="Sensor Monitor" Height="200" Width="300"
        Loaded="Window_Loaded" Closing="Window_Closing">

    <StackPanel Margin="10">
        <TextBlock Text="Sensor Monitoring Status:"/>
        <TextBlock Text="{Binding IsMonitoring, StringFormat='Monitoring: {0}'}" FontWeight="Bold"/>
        <Button Content="Start Monitoring" Click="StartButton_Click" Margin="0,10,0,0"/>
        <Button Content="Stop Monitoring" Click="StopButton_Click" Margin="0,5,0,0"/>
        <Button Content="Simulate Sensor = 1" Click="Simulate1_Click" Margin="0,10,0,0"/>
        <Button Content="Simulate Sensor = 5" Click="Simulate5_Click" Margin="0,5,0,0"/>
    </StackPanel>
</Window>
4. Views/MainWindow.xaml.cs (코드 비하인드 예시)

C#

using System.ComponentModel;
using System.Windows;
using YourApp.Models;       // 실제 네임스페이스
using YourApp.ViewModels;  // 실제 네임스페이스

namespace YourApp.Views // 실제 네임스페이스
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();

            // --- ViewModel 인스턴스화 ---
            // 실제 앱에서는 Dependency Injection 사용을 권장합니다.
            var dt2330mModel = new DT2330M { Sensor = 0 }; // 모델 생성
            _viewModel = new MainViewModel(dt2330mModel); // ViewModel에 모델 주입
            this.DataContext = _viewModel; // View의 DataContext 설정
        }

        // 창이 로드될 때 모니터링 시작
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            _viewModel?.StartSensorMonitoring();
        }

        // 창이 닫힐 때 모니터링 중지 (Dispose 호출)
        private async void Window_Closing(object sender, CancelEventArgs e)
        {
            if (_viewModel != null)
            {
                await _viewModel.StopSensorMonitoringAsync(); // 비동기 중지 호출
                _viewModel.Dispose(); // 리소스 해제
            }
        }

        // --- 테스트용 버튼 핸들러 ---
        private void StartButton_Click(object sender, RoutedEventArgs e)
        {
            _viewModel?.StartSensorMonitoring();
        }

        private async void StopButton_Click(object sender, RoutedEventArgs e)
        {
           await _viewModel?.StopSensorMonitoringAsync();
        }

        private void Simulate1_Click(object sender, RoutedEventArgs e)
        {
            // 실제로는 ViewModel이 직접 Model을 바꾸지 않지만, 테스트를 위해 사용
             (_viewModel?.TargetDT2330M as DT2330M)?.SimulateExternalChange(1);
        }

        private void Simulate5_Click(object sender, RoutedEventArgs e)
        {
             (_viewModel?.TargetDT2330M as DT2330M)?.SimulateExternalChange(5);
        }
    }
}
통합 방법:

위 코드들을 참고하여 Models, ViewModels 폴더에 각각 클래스를 배치합니다. (네임스페이스는 실제 프로젝트에 맞게 수정하세요.)
ViewModel(MainViewModel)이 DT2330M 모델 인스턴스를 얻을 수 있도록 합니다. (생성자 주입이 가장 일반적입니다.)
View(MainWindow.xaml 또는 해당 View)의 DataContext를 생성된 ViewModel 인스턴스로 설정합니다.