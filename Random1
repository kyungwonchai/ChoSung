전문가 수준으로 분업하고 파일 처리와 PLC 통신을 분리하여 모듈화한 구조로 전체 코드를 수정하겠습니다. 파일 감시와 PLC 통신은 각기 별도의 클래스로 나누고, 이를 MainViewModel에서 적절히 관리하도록 구현합니다.

주요 변경 사항:
파일 처리 및 감시 모듈: 파일 감시는 5초마다 체크하며, 새로운 파일이 발견되면 이를 처리하고, PLC에 신호를 보내는 작업을 트리거합니다.
PLC 통신 클래스: 파일이 감지될 때마다 PLC에 신호를 보내고, 작업 상태를 관리합니다.
작업 큐 및 비동기 처리: 파일이 추가될 때마다 작업 큐에 추가되어 순차적으로 작업이 실행되며, 상태가 업데이트됩니다.
파일 및 폴더 구조
plaintext
코드 복사
ProjectRoot/
│
├── Models/
│   ├── TaskModel.cs
│   └── TaskQueue.cs
│
├── Services/
│   ├── FileProcessor.cs
│   └── PlcCommunication.cs
│
├── ViewModels/
│   └── MainViewModel.cs
│
├── Views/
│   └── MainWindow.xaml
│   └── MainWindow.xaml.cs
│
└── App.xaml
└── App.xaml.cs
FileProcessor.cs (파일 감시 및 처리)
Services/FileProcessor.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Timers;

public class FileProcessor
{
    private readonly string _logFolder;  // 로그 파일이 저장된 폴더 경로
    private readonly PlcCommunication _plcCommunication;  // PLC 통신 클래스 참조
    private List<string> _processedFiles = new List<string>();  // 이미 처리한 파일명 저장
    private DateTime _lastProcessedFileTime;  // 마지막으로 처리한 파일의 시간
    private Timer _fileCheckTimer;

    public event Action<string> NewFileDetected;  // 파일이 감지되면 발생하는 이벤트

    public FileProcessor(string logFolder, PlcCommunication plcCommunication)
    {
        _logFolder = logFolder;
        _plcCommunication = plcCommunication;
        _lastProcessedFileTime = DateTime.MinValue;  // 기본값으로 설정

        // 5초마다 파일을 감시하는 타이머 설정
        _fileCheckTimer = new Timer(5000);
        _fileCheckTimer.Elapsed += CheckForNewFiles;
        _fileCheckTimer.Start();
    }

    /// <summary>
    /// 파일명에서 연월일시분초.fff 값을 추출하여 DateTime으로 변환합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var datePart = Path.GetFileNameWithoutExtension(fileName).Split('_')[1];
        return DateTime.ParseExact(datePart, "yyyyMMddHHmmssfff", CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 마지막 파일 시간 이후에 생성된 파일만 처리합니다.
    /// </summary>
    private void CheckForNewFiles(object sender, ElapsedEventArgs e)
    {
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderBy(f => ExtractDateTimeFromFileName(f))
            .ToList();

        foreach (var file in files)
        {
            var fileTime = ExtractDateTimeFromFileName(file);

            if (fileTime > _lastProcessedFileTime)
            {
                // 새 파일 발견 시 이벤트 발생 및 PLC 통신 트리거
                NewFileDetected?.Invoke(file);
                
                // PLC 신호 전송
                _plcCommunication.SendSignalForFile(file);

                // 마지막 처리 시간 업데이트
                _lastProcessedFileTime = fileTime;

                // 처리된 파일 기록
                _processedFiles.Add(Path.GetFileName(file));
            }
        }
    }
}
PlcCommunication.cs (PLC 통신 클래스)
Services/PlcCommunication.cs

csharp
코드 복사
using System;

public class PlcCommunication
{
    /// <summary>
    /// 파일이 감지되었을 때 PLC로 신호를 전송하는 메서드.
    /// </summary>
    public void SendSignalForFile(string filePath)
    {
        Console.WriteLine($"PLC에 신호 전송: {filePath}");

        // 실제 PLC 통신 코드 작성 (예: 시리얼 통신 또는 TCP/IP 통신)
        // 이 예제에서는 단순 출력으로 대체
    }

    /// <summary>
    /// PLC 신호를 통해 명령을 전달하고 응답을 받는 메서드
    /// </summary>
    public bool ExecutePlcCommand(string command)
    {
        // PLC에 명령 전송 및 응답 처리
        Console.WriteLine($"PLC 명령 실행: {command}");
        
        // 실제 응답 처리 로직 구현
        return true;  // 성공 시 true 반환
    }
}
TaskModel.cs (작업 모델)
Models/TaskModel.cs

csharp
코드 복사
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string LogisticsStatus { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsCancelled { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }
    public ICommand CancelCommand { get; }

    public TaskModel(string poNumber, TaskQueue taskQueue, string logisticsStatus, bool isExecutable)
    {
        PONumber = poNumber;
        _taskQueue = taskQueue;
        LogisticsStatus = logisticsStatus;

        StartCommand = new RelayCommand(StartTask);
        CancelCommand = new RelayCommand(CancelTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;

        var success = await _taskQueue.ExecuteTaskQueue(PONumber);

        Status = success ? "Completed" : "Failed";
        IsCompleted = success;
        IsError = !success;
        IsRunning = false;
    }

    private void CancelTask()
    {
        _taskQueue.Cancel();
        Status = "Cancelled";
        IsCancelled = true;
    }
}
TaskQueue.cs (작업 큐)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Task<bool>>> _tasks;
    private CancellationTokenSource _cancellationTokenSource;

    public TaskQueue()
    {
        _tasks = new List<Func<Task<bool>>>();
        _cancellationTokenSource = new CancellationTokenSource();
        AddDefaultTasks();
    }

    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    public async Task<bool> ExecuteTaskQueue(string poNumber)
    {
        foreach (var task in _tasks)
        {
            if (_cancellationTokenSource.Token.IsCancellationRequested)
                return false;

            var success = await task();
            if (!success) return false;
        }
        return true;
    }

    public void Cancel()
    {
        _cancellationTokenSource.Cancel();
    }

    public void CancelAll()
    {
        _cancellationTokenSource.Cancel();
    }

    private async Task<bool> TaskA()
    {
        await Task.Delay(1000);  // 비동기 작업 대기
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB()
    {
        await Task.Delay(1000);
        return true;
    }

    private async Task<bool> TaskC()
    {
        await Task.Delay(1000);
        return true;
    }
}
MainViewModel.cs (메인 ViewModel)
ViewModels/MainViewModel.cs

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;
    private FileProcessor _fileProcessor;

    public ICommand CancelAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        _taskQueue = new TaskQueue();
        var plcCommunication = new PlcCommunication();
        _fileProcessor = new FileProcessor(@"C:\Logs", plcCommunication);

        _fileProcessor.NewFileDetected += OnNewFileDetected;

        CancelAllCommand = new RelayCommand(CancelAllTasks);
    }

    private void OnNewFileDetected(string filePath)
    {
        var poNumber = ExtractPONumberFromFile(filePath);
        var logisticsStatus = "Processing";  // 가정된 값

        var taskModel = new TaskModel(poNumber, _taskQueue, logisticsStatus, true);
        TaskList.Add(taskModel);
    }

    private string ExtractPONumberFromFile(string filePath)
    {
        // 파일 이름에서 PO 번호 추출
        return Path.GetFileNameWithoutExtension(filePath);
    }

    private void CancelAllTasks()
    {
        _taskQueue.CancelAll();
        foreach (var task in TaskList)
        {
            task.Status = "Cancelled";
        }
    }
}
MainWindow.xaml.cs (UI Code-behind)
Views/MainWindow.xaml.cs

csharp
코드 복사
using System.Windows;

namespace LogisticsApp
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
            DataContext = new MainViewModel();
        }
    }
}
파일 및 클래스 설명:
FileProcessor:

파일 감시 및 처리를 담당합니다. 5초마다 파일을 확인하고, 새로운 파일이 감지되면 PLC 통신을 통해 신호를 보내고, NewFileDetected 이벤트를 발생시켜 작업 처리를 트리거합니다.
PlcCommunication:

PLC와의 통신을 담당하는 클래스입니다. 파일 감지 시 PLC로 신호를 보내거나 명령을 실행하는 역할을 합니다.
TaskModel:

각 작업의 상태를 관리합니다. PO 번호, 물류 상태, 실행 명령 등을 포함하고, 비동기 작업을 큐에서 순차적으로 실행하거나 취소할 수 있습니다.
TaskQueue:

비동기 작업 큐를 관리하며, 각 작업을 순차적으로 실행합니다. 취소 및 모든 작업 취소 기능을 제공합니다.
MainViewModel:

전체 작업 흐름을 관리합니다. FileProcessor에서 감지된 파일이 추가되면 이를 TaskModel로 처리하며, 작업 리스트를 관리하고 UI와 연결합니다.
이제 이 코드는 파일 감지 및 처리, PLC 통신, 비동기 작업 실행이 잘 분리되어 있으며, 각 기능이 모듈화되어 확장성과 유지보수성을 고려한 전문가 수준의 설계입니다.