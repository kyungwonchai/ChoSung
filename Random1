네, C#에서 SqlCommand의 CommandText와 파라미터를 조합하여 실제 실행될 SQL 쿼리 문자열처럼 만드는 코드를 요청하셨네요. 이 기능은 주로 디버깅이나 로깅 목적으로 사용됩니다.

다음은 SqlCommand의 확장 메서드(extension method)를 사용하여 이 기능을 구현한 예제 코드입니다.

C#

using System;
using System.Data;
using System.Data.SqlClient; // SQL Server를 사용하는 경우
// 만약 다른 데이터베이스를 사용한다면 해당 DB에 맞는 Provider의 클래스를 사용해야 합니다.
// 예: Oracle -> Oracle.ManagedDataAccess.Client.OracleCommand
//     MySql -> MySql.Data.MySqlClient.MySqlCommand
//     Npgsql -> Npgsql.NpgsqlCommand
using System.Text;
using System.Linq;

public static class SqlCommandExtensions
{
    /// <summary>
    /// SqlCommand의 CommandText와 파라미터를 조합하여 실제 실행될 쿼리문 형태로 반환합니다.
    /// (주의: 이 메서드는 디버깅 및 로깅 목적으로만 사용해야 합니다.
    /// 생성된 문자열을 직접 실행하는 것은 SQL Injection에 취약할 수 있습니다.)
    /// </summary>
    /// <param name="command">SqlCommand 개체</param>
    /// <returns>파라미터 값이 포함된 쿼리 문자열</returns>
    public static string GetActualQuery(this SqlCommand command)
    {
        if (command == null)
        {
            throw new ArgumentNullException(nameof(command));
        }

        string query = command.CommandText;

        // 명명된 파라미터가 아닌 위치 기반 파라미터(@ 없이 ?만 쓰는 경우 등)는 이 방식으로는 정확히 대체하기 어렵습니다.
        // SqlClient는 주로 명명된 파라미터(@paramName)를 사용합니다.

        // 파라미터를 값으로 대체하기 전에 긴 이름의 파라미터부터 처리하여
        // 짧은 이름 파라미터가 긴 이름 파라미터의 일부를 잘못 대체하는 것을 방지합니다.
        // 예: @p1, @p10 -> @p10을 먼저 처리해야 @p1이 @p10의 일부를 바꾸지 않음.
        var sortedParameters = command.Parameters.Cast<SqlParameter>()
                                      .OrderByDescending(p => p.ParameterName.Length)
                                      .ToList();

        foreach (SqlParameter param in sortedParameters)
        {
            string paramName = param.ParameterName;
            string paramValueString;

            if (param.Value == null || param.Value == DBNull.Value)
            {
                paramValueString = "NULL";
            }
            else
            {
                switch (param.SqlDbType)
                {
                    case SqlDbType.Char:
                    case SqlDbType.NChar:
                    case SqlDbType.VarChar:
                    case SqlDbType.NVarChar:
                    case SqlDbType.Text:
                    case SqlDbType.NText:
                    case SqlDbType.Xml:
                        // 문자열 값은 작은따옴표로 감싸고, 내부의 작은따옴표는 이스케이프 처리 ( ' -> '' )
                        paramValueString = $"'{param.Value.ToString().Replace("'", "''")}'";
                        break;

                    case SqlDbType.Date:
                    case SqlDbType.DateTime:
                    case SqlDbType.DateTime2:
                    case SqlDbType.SmallDateTime:
                    case SqlDbType.Time:
                    case SqlDbType.DateTimeOffset:
                        // 날짜/시간 값도 작은따옴표로 감싸고, SQL Server가 인식할 수 있는 형식으로 포맷팅
                        // .NET의 DateTime.ToString()은 현재 문화권에 따라 달라질 수 있으므로,
                        // 명시적인 포맷을 사용하는 것이 좋습니다. ISO 8601 형식이 안전합니다.
                        if (param.Value is DateTime dt)
                        {
                            paramValueString = $"'{dt:yyyy-MM-dd HH:mm:ss.fff}'";
                        }
                        else if (param.Value is DateTimeOffset dto)
                        {
                            paramValueString = $"'{dto:yyyy-MM-dd HH:mm:ss.fff zzz}'";
                        }
                        else
                        {
                            paramValueString = $"'{param.Value.ToString().Replace("'", "''")}'"; // Fallback
                        }
                        break;

                    case SqlDbType.Bit:
                        // Boolean 값은 0 또는 1로 표현
                        paramValueString = (Convert.ToBoolean(param.Value)) ? "1" : "0";
                        break;

                    case SqlDbType.Binary:
                    case SqlDbType.VarBinary:
                    case SqlDbType.Image:
                    case SqlDbType.Timestamp:
                    case SqlDbType.Udt: // 사용자 정의 타입을 어떻게 표현할지는 UDT에 따라 다름
                        // 이진 데이터는 0x 접두사를 사용하는 16진수 문자열로 표현
                        if (param.Value is byte[] bytes)
                        {
                            StringBuilder hex = new StringBuilder("0x");
                            foreach (byte b in bytes)
                            {
                                hex.AppendFormat("{0:x2}", b);
                            }
                            paramValueString = hex.ToString();
                        }
                        else
                        {
                            paramValueString = $"'[Binary Data of type {param.Value.GetType().Name}]'";
                        }
                        break;

                    // 숫자형은 그대로 사용
                    case SqlDbType.TinyInt:
                    case SqlDbType.SmallInt:
                    case SqlDbType.Int:
                    case SqlDbType.BigInt:
                    case SqlDbType.Decimal:
                    case SqlDbType.Float:
                    case SqlDbType.Money:
                    case SqlDbType.Real:
                    case SqlDbType.SmallMoney:
                        paramValueString = param.Value.ToString();
                        break;

                    case SqlDbType.UniqueIdentifier:
                        paramValueString = $"'{param.Value.ToString()}'";
                        break;

                    default:
                        // 기타 타입은 기본적으로 ToString() 결과를 사용하되, 문자열처럼 처리
                        paramValueString = $"'{param.Value.ToString().Replace("'", "''")}'";
                        break;
                }
            }
            // 정규식을 사용하여 파라미터 이름이 단어 경계에 있는지 확인하여 @p가 @p1까지 바꾸는 것을 방지
            // (?<!\w)@ParamName(?!\w) -> @ParamName 앞뒤로 문자(알파벳,숫자,_)가 없는 경우에만 일치
            // 하지만 ParameterName 자체가 @를 포함하고 있으므로, 간단히 Replace로도 대부분 잘 동작합니다.
            // 좀 더 정확하게 하려면 정규식을 사용할 수 있습니다. 여기서는 간단한 Replace를 사용합니다.
            query = query.Replace(paramName, paramValueString);
        }

        return query;
    }
}

// --- 사용 예제 ---
public class ExampleUsage
{
    public static void Main(string[] args)
    {
        string connectionString = "Server=your_server;Database=your_database;User ID=your_user;Password=your_password;Encrypt=True;TrustServerCertificate=True;"; // 실제 연결 문자열로 변경

        using (SqlConnection connection = new SqlConnection(connectionString))
        {
            string sqlQuery = "SELECT * FROM Users WHERE UserID = @UserID AND UserName = @UserName AND RegistrationDate > @RegDate AND IsActive = @IsActive AND ProfileData = @Data;";
            using (SqlCommand command = new SqlCommand(sqlQuery, connection))
            {
                command.Parameters.AddWithValue("@UserID", 123);
                command.Parameters.AddWithValue("@UserName", "John O'Doe"); // 작은 따옴표가 포함된 문자열
                command.Parameters.Add("@RegDate", SqlDbType.DateTime).Value = new DateTime(2023, 1, 1);
                command.Parameters.AddWithValue("@IsActive", true);
                command.Parameters.AddWithValue("@Data", new byte[] { 0x01, 0x02, 0x03, 0x04 });
                command.Parameters.AddWithValue("@AnotherValueWithNull", DBNull.Value); // NULL 값 예제 (쿼리에는 없지만 추가해봄)

                // 확장 메서드 호출
                string actualQuery = command.GetActualQuery();

                Console.WriteLine("Original CommandText:");
                Console.WriteLine(command.CommandText);
                Console.WriteLine("\nCommandText with Parameters:");
                Console.WriteLine(actualQuery);

                // 실제 쿼리 실행 예 (위의 GetActualQuery와는 별개)
                /*
                try
                {
                    connection.Open();
                    using (SqlDataReader reader = command.ExecuteReader())
                    {
                        while (reader.Read())
                        {
                            // 데이터 처리
                        }
                    }
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error executing query: {ex.Message}");
                    Console.WriteLine($"Faulty query (for debugging): {actualQuery}");
                }
                */
            }
        }
    }
}
코드 설명:

SqlCommandExtensions 클래스: SqlCommand 클래스에 기능을 추가하기 위한 정적 클래스입니다.