알겠습니다! 이전의 복잡한 설정 방식에 대해 정말 죄송하게 생각합니다. 사용자님의 요구사항은 **"Agent는 어떤 외부 설정 파일이나 실행 시 파라미터 없이, 실행만 하면 자신의 IP를 기반으로 동작하고, 고정된 포트(4099)를 사용해야 한다"**는 것으로 명확히 이해했습니다.

이 요구사항을 만족시키려면 Agent 프로그램의 동작 방식에 큰 변화가 필요합니다. Agent가 중계 프로그램으로 먼저 접속하는 것이 아니라, Agent 프로그램 자체가 지정된 포트(4099)에서 중계 프로그램의 연결 요청을 기다리는 서버(리스너) 역할을 해야 합니다.

새로운 Agent 프로그램 (MonitorAgent) 동작 방식:

ID 및 리슨 정보:
실행 시 자신의 주 IP 주소를 식별합니다. 이 IP 주소가 외부(UI, 중계기)에서 이 Agent를 지칭하는 주소가 됩니다.
항상 **고정된 포트 번호 4099**에서 TCP 연결 요청을 리슨합니다.
통신:
중계 프로그램(MGSPBrokerService)이 특정 Agent를 제어해야 할 때, 해당 Agent의 IP 주소와 고정 포트 4099로 TCP 연결을 시도합니다.
Agent는 이 연결을 수락하고, 중계 프로그램으로부터 명령 메시지를 수신합니다.
명령을 처리한 후, 그 결과를 동일한 TCP 연결을 통해 중계 프로그램으로 다시 전송합니다.
상태 보고: Agent가 자신의 상태(모니터 켜짐/꺼짐 등)를 중계 프로그램으로 "먼저" 보고하는 방식은 이 모델에서 변경되어야 합니다. 중계 프로그램이 Agent에게 상태를 "요청"하거나, Agent가 명령 처리 결과에 현재 상태를 포함시켜 보내는 방식으로 변경될 수 있습니다. 또는, Agent가 주기적으로 중계 프로그램으로 새로운 연결을 맺어 상태를 보고하고 연결을 끊는 방식도 가능하지만, 이는 중계 프로그램이 Agent의 연결을 관리하는 방식과 일관성이 떨어질 수 있습니다. 여기서는 명령에 대한 응답에 상태를 포함하고, 중계기가 필요시 상태 요청을 보내는 것으로 가정하겠습니다.
게이트웨이 기능:
만약 이 Agent가 게이트웨이 역할을 해야 한다면, 중계 프로그램으로부터 "최종 대상 Agent(IP 정보 포함)에게 특정 명령을 전달하라"는 요청을 받습니다.
이 게이트웨이 Agent는 다시 DownstreamAgentClient와 유사한 TCP 클라이언트 기능을 사용하여, 최종 대상 Agent의 IP와 고정 포트 4099로 접속하여 명령을 전달하고 결과를 받아 중계 프로그램에 보고합니다. (최종 대상 Agent도 4099 포트에서 리슨)
로그 관리: 날짜별 로그 생성 및 3일 지난 로그 자동 삭제 기능은 그대로 유지됩니다.
이 방식의 장점:

Agent PC에 어떤 설정 파일도, 실행 시 파라미터도 필요 없습니다. MonitorAgent.exe 실행만 하면 됩니다.
고려 사항:

방화벽: 모든 Agent PC의 방화벽에서 TCP 포트 4099에 대한 인바운드 연결을 허용해야 합니다.
네트워크 환경(NAT 등): Agent PC가 NAT 환경 뒤에 있다면 중계 프로그램이 직접 Agent의 사설 IP로 접속하기 어려울 수 있습니다. (이 부분은 현재 논의 범위 밖으로 간주)
IP 주소 변동(DHCP): Agent PC의 IP 주소가 변경되면 제어 UI의 DB에 저장된 IP 정보와 달라져 제어가 불가능해집니다. UI에서 Agent IP를 주기적으로 확인하거나 업데이트하는 메커니즘, 또는 Agent가 자신의 IP 변경을 (어떤 방식으로든) 중계기에 알리는 방법이 필요합니다. (이 부분도 고급 주제로 현재는 고정 IP 또는 UI에서 IP 관리한다고 가정)
수정될 MonitorAgent 파일 목록 (대부분 변경됨):

Config/AgentIdentifier.cs: IP 가져오는 역할은 유지.
Services/LoggingService.cs: (이전과 동일)
Services/MonitorControlService.cs: (이전과 동일)
Models/MessageContract.cs: (공통 파일, 내용 동일)
Network/AgentTcpListener.cs (신규 또는 대폭 수정): 핵심 TCP 서버 로직. 중계기로부터 연결 받고 메시지 처리.
Network/BrokerTcpClient.cs (삭제): Agent가 더 이상 Broker에 먼저 클라이언트로 접속하지 않음.
Network/DownstreamAgentClient.cs: (유지 및 수정) 게이트웨이 역할 시 최종 Agent(얘도 4099 리슨)에 접속하는 클라이언트.
Core/AgentCore.cs (대폭 수정): AgentTcpListener를 관리하고, 수신된 명령을 처리하며, 게이트웨이 로직 수행.
UI/TrayIconManager.cs: (유지)
App.xaml.cs (수정): 명령줄 인자 파싱 불필요, AgentCore 시작 방식 변경.
App.xaml: (변경 없음)
이제 이 새로운 아키텍처에 맞춰 MonitorAgent 프로그램의 전체 코드를 다시 제공하겠습니다. 이전 코드와는 상당히 달라지므로 주의 깊게 봐주시기 바랍니다.

먼저, MessageContract.cs는 이전 답변에서 드린 공통 버전을 그대로 사용한다고 가정합니다. (네임스페이스 MonitorControl.SharedModels)

1. Config/AppConstants.cs (수정)

Agent 리슨 포트 상수 추가.

C#

// MonitorAgent/Config/AppConstants.cs
namespace MonitorAgent.Config
{
    public static class AppConstants
    {
        public const string LogDirectoryName = "Logs";
        public const string LogFileNameDateFormat = "yyyy-MM-dd";
        public const string AppName = "MonitorAgent";
        public const int DaysToKeepLogs = 3;
        
        public const int AgentListenPort = 4099; // Agent가 리슨할 고정 포트
    }
}
2. Config/AgentIdentifier.cs (유지 또는 약간 수정)
자신의 IP 정보를 가져오는 역할은 여전히 필요합니다. UniqueId는 이제 Agent가 중계기에 자신을 알릴 때 사용될 수 있습니다 (예: 명령 응답 시 SourceId 등).

코드 스니펫

// MonitorAgent/Config/AgentIdentifier.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using MonitorAgent.Services;

namespace MonitorAgent.Config
{
    public class AgentIdentifier
    {
        private readonly ILoggingService _logger;
        public string PrimaryIpAddress { get; private set; }
        public List<string> AllIpAddresses { get; private set; }
        public string UniqueId { get; private set; } // 여전히 내부 식별 또는 로깅에 사용 가능

        public AgentIdentifier(ILoggingService logger)
        {
            _logger = logger;
            DetermineIdentifiers();
        }

        private void DetermineIdentifiers()
        {
            AllIpAddresses = GetLocalIpAddressesStatic(_logger);

            if (AllIpAddresses.Any())
            {
                PrimaryIpAddress = AllIpAddresses.FirstOrDefault(ip => !string.IsNullOrEmpty(ip) && ip != "127.0.0.1");
                if (string.IsNullOrEmpty(PrimaryIpAddress))
                {
                    PrimaryIpAddress = AllIpAddresses.FirstOrDefault(ip => !string.IsNullOrEmpty(ip));
                }
                
                if (string.IsNullOrEmpty(PrimaryIpAddress)) { PrimaryIpAddress = "IP_Not_Found"; }
                
                // UniqueId는 이제 PrimaryIpAddress와 동일하게 사용하거나, 필요시 다른 조합 사용
                UniqueId = PrimaryIpAddress; 
                _logger.LogInfo($"Agent Primary IP for listening: {PrimaryIpAddress}. All IPs: {string.Join(", ", AllIpAddresses)}. Unique ID set to: {UniqueId}");
            }
            else
            {
                _logger.LogWarning("No valid local IP addresses found for Agent identification.");
                PrimaryIpAddress = "UnknownIP";
                AllIpAddresses = new List<string> { PrimaryIpAddress };
                string fallbackIdBase = $"{Environment.MachineName.Replace(" ", "_").Replace(".", "_")}-{Guid.NewGuid().ToString("N").Substring(0, 8)}";
                UniqueId = $"NO_IP_FALLBACK_{fallbackIdBase}";
                 _logger.LogError($"CRITICAL: Agent could not determine a primary IP address. Using fallback ID: {UniqueId}. This agent might not be controllable.");
            }
        }

        public static List<string> GetLocalIpAddressesStatic(ILoggingService loggerForStatic)
        {
            // 이전 답변의 GetLocalIpAddressesStatic 메서드 내용과 동일하게 사용
            var ipAddressList = new List<string>();
            try
            {
                if (!NetworkInterface.GetIsNetworkAvailable())
                {
                    loggerForStatic?.LogWarning("No network connection is available.");
                    return ipAddressList;
                }
                var upInterfaces = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(ni => ni.OperationalStatus == OperationalStatus.Up &&
                                 ni.NetworkInterfaceType != NetworkInterfaceType.Loopback &&
                                 ni.NetworkInterfaceType != NetworkInterfaceType.Tunnel)
                    .OrderByDescending(ni => ni.GetIPProperties().GatewayAddresses.Any()) 
                    .ThenByDescending(ni => ni.Speed); 

                foreach (NetworkInterface item in upInterfaces)
                {
                    foreach (UnicastIPAddressInformation ipInfo in item.GetIPProperties().UnicastAddresses)
                    {
                        if (ipInfo.Address.AddressFamily == AddressFamily.InterNetwork) 
                        {
                            if (ipInfo.Address.ToString().StartsWith("169.254.")) continue;
                            ipAddressList.Add(ipInfo.Address.ToString());
                        }
                    }
                }
                if (!ipAddressList.Any()) { loggerForStatic?.LogWarning("No suitable IPv4 addresses found."); }
            }
            catch (Exception ex) { loggerForStatic?.LogError("Error getting local IP addresses", ex); }
            return ipAddressList.Distinct().ToList();
        }
    }
}
3. Services/LoggingService.cs 및 Services/MonitorControlService.cs
이 두 파일은 이전 답변에서 제공한 최종 버전을 그대로 사용합니다. (날짜별 로그 및 자동 삭제 기능이 포함된 LoggingService, 모니터 제어 기능의 MonitorControlService)

4. Network/AgentTcpListener.cs (신규 - 핵심 TCP 서버 로직)

C#

// MonitorAgent/Network/AgentTcpListener.cs
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Config; // AppConstants
using MonitorAgent.Models; // BrokerMessage (SharedModels 네임스페이스 사용)
using MonitorAgent.Services; // ILoggingService
using Newtonsoft.Json;
using MonitorControl.SharedModels; // BrokerMessage, MessageType 등 공용 모델

namespace MonitorAgent.Network
{
    public class AgentTcpListener : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly int _listenPort;
        private TcpListener _tcpListener;
        private CancellationTokenSource _cts;
        private readonly Func<BrokerMessage, Task<BrokerMessage>> _messageHandler; // 메시지 처리 후 응답을 반환하는 콜백
        private bool _isDisposed = false;

        public AgentTcpListener(ILoggingService logger, Func<BrokerMessage, Task<BrokerMessage>> messageHandler)
        {
            _logger = logger;
            _listenPort = AppConstants.AgentListenPort; // 고정 포트 사용
            _messageHandler = messageHandler;
        }

        public void Start()
        {
            if (_isDisposed) throw new ObjectDisposedException(nameof(AgentTcpListener));
            if (_tcpListener != null && _tcpListener.Server.IsBound)
            {
                _logger.LogWarning("Agent TCP Listener is already running.");
                return;
            }

            _cts = new CancellationTokenSource();
            try
            {
                _tcpListener = new TcpListener(IPAddress.Any, _listenPort);
                _tcpListener.Start();
                _logger.LogInfo($"Agent TCP Listener started. Listening on port {_listenPort} for Broker connections.");
                Task.Run(() => AcceptConnectionsAsync(_cts.Token), _cts.Token);
            }
            catch (SocketException sockEx)
            {
                _logger.LogFatal($"SocketException starting Agent TCP Listener on port {_listenPort}: {sockEx.Message}. Port might be in use or firewall issue.", sockEx);
                throw;
            }
            catch (Exception ex)
            {
                _logger.LogFatal($"Error starting Agent TCP Listener: {ex.Message}", ex);
                throw;
            }
        }

        private async Task AcceptConnectionsAsync(CancellationToken token)
        {
            _logger.LogInfo($"Accepting Broker connections on port {_listenPort}...");
            while (!token.IsCancellationRequested)
            {
                try
                {
                    TcpClient brokerTcpClient = await _tcpListener.AcceptTcpClientAsync().ConfigureAwait(false);
                    string clientIp = ((IPEndPoint)brokerTcpClient.Client.RemoteEndPoint).ToString();
                    _logger.LogInfo($"Broker connection accepted from: {clientIp}");
                    
                    // 각 클라이언트 연결을 별도의 태스크로 처리
                    _ = HandleBrokerConnectionAsync(brokerTcpClient, token);
                }
                catch (ObjectDisposedException) when (token.IsCancellationRequested || _isDisposed)
                {
                    _logger.LogInfo("Agent TcpListener stopped as requested.");
                    break;
                }
                catch (SocketException sockEx) when (token.IsCancellationRequested || _isDisposed || (_tcpListener != null && !_tcpListener.Server.IsBound))
                {
                     _logger.LogInfo($"Agent TcpListener socket closed during shutdown or error: {sockEx.Message}");
                     break;
                }
                catch (Exception ex)
                {
                    if (!token.IsCancellationRequested && !_isDisposed)
                    {
                        _logger.LogError($"Error accepting new Broker connection: {ex.Message}", ex);
                        try { await Task.Delay(1000, token); } catch { /* ignore cancellation */ }
                    }
                }
            }
            _logger.LogInfo("Agent TCP Listener client acceptance loop stopped.");
        }

        private async Task HandleBrokerConnectionAsync(TcpClient brokerTcpClient, CancellationToken token)
        {
            NetworkStream stream = null;
            StreamReader reader = null;
            StreamWriter writer = null;
            string remoteEndpointInfo = "Unknown";

            try
            {
                remoteEndpointInfo = brokerTcpClient.Client.RemoteEndPoint.ToString();
                stream = brokerTcpClient.GetStream();
                reader = new StreamReader(stream, Encoding.UTF8);
                writer = new StreamWriter(stream, Encoding.UTF8) { AutoFlush = true };

                _logger.LogInfo($"Handling connection from Broker: {remoteEndpointInfo}");

                while (!token.IsCancellationRequested && brokerTcpClient.Connected)
                {
                    string messageJson = await reader.ReadLineAsync().ConfigureAwait(false);
                    if (messageJson == null) // 클라이언트 연결 종료
                    {
                        _logger.LogInfo($"Broker {remoteEndpointInfo} disconnected (stream closed).");
                        break;
                    }
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    BrokerMessage receivedMessage = null;
                    try
                    {
                        receivedMessage = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.LogError($"JSON deserialization error from Broker {remoteEndpointInfo}: {jsonEx.Message}. Received: {messageJson}", jsonEx);
                        // 잘못된 형식의 메시지 응답 또는 연결 종료 고려
                        var errorResponse = new BrokerMessage { Type = MessageType.AgentCommandResult, Payload = JsonConvert.SerializeObject(new AgentCommandResultPayload { Success = false, Message = "Invalid message format from Agent." }) };
                        await writer.WriteLineAsync(JsonConvert.SerializeObject(errorResponse)).ConfigureAwait(false);
                        continue;
                    }
                    
                    if (receivedMessage != null && _messageHandler != null)
                    {
                        _logger.LogDebug($"Received from Broker {remoteEndpointInfo}: Type={receivedMessage.Type}, CorrId={receivedMessage.CorrelationId}");
                        BrokerMessage responseMessage = await _messageHandler(receivedMessage); // 핵심 로직 호출
                        if (responseMessage != null) // 응답이 있다면 전송
                        {
                            string responseJson = JsonConvert.SerializeObject(responseMessage);
                             await writer.WriteLineAsync(responseJson).ConfigureAwait(false);
                             _logger.LogDebug($"Sent response to Broker {remoteEndpointInfo}: Type={responseMessage.Type}, CorrId={responseMessage.CorrelationId}");
                        }
                    }
                    else if (receivedMessage == null)
                    {
                        _logger.LogWarning($"Failed to deserialize message from Broker {remoteEndpointInfo}: {messageJson}");
                    }
                }
            }
            catch (IOException ioEx) when (token.IsCancellationRequested || !brokerTcpClient.Connected)
            {
                 _logger.LogInfo($"IOException for Broker {remoteEndpointInfo} (likely connection forcibly closed or cancelled): {ioEx.Message}");
            }
            catch (ObjectDisposedException)
            {
                 _logger.LogInfo($"Broker connection {remoteEndpointInfo} terminated due to object disposal.");
            }
            catch (OperationCanceledException)
            {
                 _logger.LogInfo($"Broker connection {remoteEndpointInfo} handling cancelled.");
            }
            catch (Exception ex)
            {
                 if(!token.IsCancellationRequested && !_isDisposed)
                    _logger.LogError($"Unexpected error handling Broker connection {remoteEndpointInfo}: {ex.Message}", ex);
            }
            finally
            {
                _logger.LogInfo($"Closing connection with Broker: {remoteEndpointInfo}");
                writer?.Dispose();
                reader?.Dispose();
                stream?.Dispose();
                brokerTcpClient?.Close();
            }
        }

        public void Stop()
        {
            if (_isDisposed) return;
            _logger.LogInfo("Agent TCP Listener stopping...");
            _cts?.Cancel();
            _tcpListener?.Stop();
            _cts?.Dispose(); // CancellationTokenSource도 Dispose
            _cts = null;
            _tcpListener = null; // 명시적 해제
            _logger.LogInfo("Agent TCP Listener stopped.");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Stop();
            GC.SuppressFinalize(this);
        }
    }
}
5. Network/DownstreamAgentClient.cs (유지 및 포트 고정 반영)
게이트웨이 Agent가 최종 Agent(얘도 4099에서 리슨)에게 접속할 때 사용합니다. 이전 코드를 거의 그대로 사용하되, 최종 Agent의 접속 포트가 고정(AppConstants.AgentListenPort)임을 인지하고 호출부에서 이 포트를 사용해야 합니다. 이 클래스 자체의 변경은 거의 없습니다. (이전 최종본 사용)

6. Core/AgentCore.cs (대폭 수정)
AgentTcpListener를 관리하고, 수신된 명령을 처리하며, 게이트웨이 로직을 수행합니다.

C#

// MonitorAgent/Core/AgentCore.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Config;
using MonitorAgent.Network;
using MonitorAgent.Services;
using Newtonsoft.Json;
using MonitorControl.SharedModels; // 공용 MessageContract 사용

namespace MonitorAgent.Core
{
    public enum AgentOperationalStatus 
    {
        Initializing,
        StartingListener,
        ListeningForBroker, // TCP 리스너 실행 중
        ProcessingBrokerCommand,
        ActingAsGateway,
        Error,
        Stopping
    }

    public class AgentCore : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly AgentIdentifier _agentIdentifier;
        private readonly IMonitorControlService _monitorControl;
        
        private AgentTcpListener _agentListener;
        private CancellationTokenSource _mainCts;
        private AgentOperationalStatus _currentStatus;
        private bool _isDisposed = false;

        public event Action<AgentOperationalStatus, string> OnStatusChanged;

        public AgentCore(ILoggingService logger, AgentIdentifier agentIdentifier, IMonitorControlService monitorControl)
        {
            _logger = logger;
            _agentIdentifier = agentIdentifier;
            _monitorControl = monitorControl;
            UpdateStatus(AgentOperationalStatus.Initializing, "Agent core created. My ID for Broker: " + _agentIdentifier.UniqueId);
        }

        public Task StartAsync() // 반환 타입을 Task로 변경하여 비동기 시작 지원
        {
            if (_mainCts != null && !_mainCts.IsCancellationRequested)
            {
                _logger.LogWarning("AgentCore is already running or starting.");
                return Task.FromResult(false); // .NET 4.5에는 Task.CompletedTask 없음
            }
            if (_isDisposed) throw new ObjectDisposedException(nameof(AgentCore));

            _mainCts = new CancellationTokenSource();
            UpdateStatus(AgentOperationalStatus.StartingListener, "Agent core starting listener...");

            try
            {
                // AgentTcpListener는 Broker로부터 메시지를 받으면 HandleBrokerMessageFromListener를 호출
                _agentListener = new AgentTcpListener(_logger, HandleBrokerMessageFromListener);
                _agentListener.Start(); // 내부적으로 비동기 AcceptLoop 시작
                UpdateStatus(AgentOperationalStatus.ListeningForBroker, $"Listening on port {AppConstants.AgentListenPort}. My Primary IP: {_agentIdentifier.PrimaryIpAddress}");
            }
            catch (Exception ex)
            {
                UpdateStatus(AgentOperationalStatus.Error, $"Failed to start Agent TCP Listener: {ex.Message}");
                _logger.LogFatal("Could not start Agent TCP Listener.", ex);
                // 여기서 프로그램을 종료하거나, 재시도 로직을 넣을 수 있음
                return Task.FromResult(false);
            }
            return Task.FromResult(true);
        }

        // AgentTcpListener가 Broker로부터 메시지를 받으면 호출하는 콜백 메서드
        private async Task<BrokerMessage> HandleBrokerMessageFromListener(BrokerMessage receivedMessage)
        {
            if (_isDisposed || (_mainCts != null && _mainCts.IsCancellationRequested)) return null; // 응답 없음

            _logger.LogInfo($"Broker Command Received: Type={receivedMessage.Type}, CorrId={receivedMessage.CorrelationId}, Target(in msg)='{receivedMessage.TargetId}'");
            UpdateStatus(AgentOperationalStatus.ProcessingBrokerCommand, $"Processing command: {receivedMessage.Type}");

            BrokerMessage responseToBroker = null;
            AgentCommandResultPayload commandResultPayload = new AgentCommandResultPayload { Success = false, Message = "NotProcessed" };

            if (receivedMessage.Type == MessageType.BrokerToAgent_ExecuteControl)
            {
                BrokerExecuteControlPayload controlPayload = null;
                try
                {
                    controlPayload = JsonConvert.DeserializeObject<BrokerExecuteControlPayload>(receivedMessage.Payload);
                }
                catch (JsonException jsonEx)
                {
                    _logger.LogError($"Failed to parse ExecuteControl payload: {jsonEx.Message}", jsonEx);
                    commandResultPayload.Message = "Invalid command payload format.";
                }

                if (controlPayload != null)
                {
                    if (!controlPayload.IsGatewayRelayRequired) // 이 Agent가 최종 실행 대상
                    {
                        _logger.LogInfo($"Executing direct command: {controlPayload.ActionToPerform}");
                        switch (controlPayload.ActionToPerform)
                        {
                            case "TurnMonitorOn":
                                commandResultPayload.Success = _monitorControl.TurnMonitorOn();
                                commandResultPayload.Message = commandResultPayload.Success ? "Monitor turned ON." : "Failed to turn monitor ON.";
                                break;
                            case "TurnMonitorOff":
                                commandResultPayload.Success = _monitorControl.TurnMonitorOff();
                                commandResultPayload.Message = commandResultPayload.Success ? "Monitor turned OFF." : "Failed to turn monitor OFF.";
                                break;
                            default:
                                commandResultPayload.Message = $"Unknown direct action: {controlPayload.ActionToPerform}";
                                _logger.LogWarning(commandResultPayload.Message);
                                break;
                        }
                        commandResultPayload.CurrentMonitorStatus = _monitorControl.GetCurrentMonitorStateApproximation();
                    }
                    else // 이 Agent가 Gateway로서 다른 최종 Agent에게 전달해야 함
                    {
                        UpdateStatus(AgentOperationalStatus.ActingAsGateway, $"Relaying command '{controlPayload.ActionToPerform}' to {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");
                        _logger.LogInfo($"Gateway Role: Relaying command '{controlPayload.ActionToPerform}' to final target {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");

                        using (var downstreamClient = new DownstreamAgentClient(_logger))
                        {
                            if (await downstreamClient.ConnectAsync(controlPayload.FinalTargetAgentIp, AppConstants.AgentListenPort, _mainCts.Token)) // 최종 Agent도 4099 포트 사용
                            {
                                var payloadForFinalAgent = new BrokerExecuteControlPayload
                                {
                                    ActionToPerform = controlPayload.ActionToPerform,
                                    Parameters = controlPayload.Parameters,
                                    IsGatewayRelayRequired = false // 최종 대상에게는 이것이 직접 명령임
                                };
                                commandResultPayload = await downstreamClient.SendCommandAndGetResponseAsync(
                                    payloadForFinalAgent, 
                                    receivedMessage.CorrelationId, 
                                    _agentIdentifier.UniqueId, // 이 게이트웨이 Agent의 ID
                                    controlPayload.FinalTargetAgentId ?? controlPayload.FinalTargetAgentIp, // 최종 대상 Agent의 ID (정보용)
                                    _mainCts.Token);
                            }
                            else
                            {
                                commandResultPayload.Success = false;
                                commandResultPayload.Message = $"Gateway ({_agentIdentifier.UniqueId}) failed to connect to final agent {controlPayload.FinalTargetAgentIp}:{AppConstants.AgentListenPort}.";
                            }
                        } // downstreamClient.Dispose()
                        UpdateStatus(AgentOperationalStatus.ListeningForBroker, "Command relay finished."); // 원래 리슨 상태로 (메시지 처리 후)
                    }
                }
                // 실행 결과를 담은 응답 메시지 생성
                responseToBroker = new BrokerMessage
                {
                    Type = MessageType.AgentCommandResult,
                    SourceId = _agentIdentifier.UniqueId, // 이 Agent가 결과를 보냄
                    TargetId = receivedMessage.SourceId, // 원본 요청을 보낸 주체 (Broker)
                    CorrelationId = receivedMessage.CorrelationId,
                    Payload = JsonConvert.SerializeObject(commandResultPayload)
                };
            }
            else if (receivedMessage.Type == MessageType.BrokerPingToAgent)
            {
                _logger.LogDebug("Ping received from Broker. Preparing Pong.");
                // Pong에 현재 상태 담아서 보낼 수도 있음
                var statusPayload = new AgentStatusUpdatePayload { CurrentMonitorStatus = _monitorControl.GetCurrentMonitorStateApproximation(), IsRespondingToPing = true };
                responseToBroker = new BrokerMessage
                {
                    Type = MessageType.Pong, // 또는 AgentStatusUpdate를 Pong 대신 사용
                    SourceId = _agentIdentifier.UniqueId,
                    TargetId = receivedMessage.SourceId, // Broker
                    CorrelationId = receivedMessage.CorrelationId,
                    Payload = JsonConvert.SerializeObject(statusPayload) // Pong에 상태 정보 포함
                };
            }
            // AgentHello에 대한 Ack는 Agent가 Broker에게 보내는 것이 아님. (Broker가 Agent에게 보냄)
            // AgentStatusUpdate는 Agent가 Broker에게 먼저 보내는 것이므로, Broker로부터 요청받는 형태는 아님. (주기적 또는 이벤트 기반)
            // 여기서는 Broker가 명령을 내리고 Agent가 응답하는 시나리오만 처리.
            // Agent가 먼저 Broker에게 상태를 보내는 것은 AgentCore 다른 로직 (예: 타이머)에서 처리해야 함.
            // 이 콜백은 Broker가 "요청한 것"에 대한 "응답"을 반환하는 역할.

            UpdateStatus(AgentOperationalStatus.ListeningForBroker, $"Finished processing: {receivedMessage.Type}");
            return responseToBroker; // 처리 결과를 Broker에게 반환 (AgentTcpListener가 전송)
        }

        // TODO: 주기적으로 Broker에게 자신의 상태를 보고하는 로직 추가 (Agent가 서버 역할이므로 이 방식은 맞지 않음)
        // 대신, Broker가 Agent에게 상태를 요청하는 명령(예: BrokerToAgent_RequestStatus)을 보내고,
        // Agent가 그에 대한 응답으로 AgentStatusUpdatePayload를 담아 보내는 방식이 더 적합.
        // 또는, Agent가 명령을 처리한 결과(AgentCommandResult)에 항상 최신 상태를 포함하여 보내는 것으로 충분할 수 있음.
        // 여기서는 후자를 사용: AgentCommandResultPayload에 CurrentMonitorStatus 포함.

        private void UpdateStatus(AgentOperationalStatus newStatus, string message)
        {
            if (_currentStatus == newStatus && 
                !(newStatus == AgentOperationalStatus.ProcessingBrokerCommand || newStatus == AgentOperationalStatus.ActingAsGateway)) return; 

            _currentStatus = newStatus;
            string logMessage = $"Agent Status: {_currentStatus} - {message}";
             if (newStatus == AgentOperationalStatus.Error) _logger.LogError(logMessage);
             else _logger.LogInfo(logMessage);
            OnStatusChanged?.Invoke(_currentStatus, message);
        }

        public void Stop()
        {
            if (_isDisposed) return;
            UpdateStatus(AgentOperationalStatus.Stopping, "Agent core stopping...");
            _mainCts?.Cancel(); 
            
            _agentListener?.Stop(); 
            _agentListener?.Dispose();
            _agentListener = null;
            
            _mainCts?.Dispose();
            _mainCts = null;
            _logger.LogInfo("Agent core stopped.");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Stop();
            GC.SuppressFinalize(this);
        }
    }
}
7. UI/TrayIconManager.cs (큰 변경 없음, 이전 답변과 동일)
Agent ID를 생성자에서 받고, 상태 업데이트 시 반영하는 로직은 그대로 사용 가능합니다.

8. App.xaml.cs (수정됨 - 명령줄 인자 처리 불필요, AgentCore 시작 방식 변경)
Agent가 서버 역할을 하므로, 중계 프로그램 주소를 명령줄로 받을 필요가 없습니다.

C#

// MonitorAgent/App.xaml.cs
using System;
using System.Windows;
using System.Windows.Forms; 
using System.Drawing;       
using MonitorAgent.Config;
using MonitorAgent.Core;
using MonitorAgent.Services;
using MonitorAgent.UI;
using Microsoft.Win32;      
using System.Diagnostics;   
using System.Linq;          
using System.Threading; // Mutex

namespace MonitorAgent
{
    public partial class App : Application
    {
        private AgentCore _agentCore;
        private AgentLoggingService _loggingService;
        private TrayIconManager _trayIconManager;
        private AgentIdentifier _agentIdentifier;
        private MonitorControlService _monitorControlService;
        private StartupRegistryService _startupRegistryService;
        private Mutex _mutex; // 중복 실행 방지용

        protected override async void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // App.xaml에서 StartupUri="MainWindow.xaml" 제거 또는 주석 처리 필수

            // 로그 서비스 우선 초기화 (설정 파일에서 로그 레벨을 읽어올 수 있도록)
            // 여기서는 간단히 기본 "Info" 레벨 사용
            _loggingService = new AgentLoggingService("Info"); 

            _agentIdentifier = new AgentIdentifier(_loggingService); // IP 기반 ID 생성

            // 중복 실행 방지 (Agent 고유 ID 기반)
            string mutexName = $"Global\\MonitorAgentInstance_{_agentIdentifier.UniqueId.Replace(":", "_").Replace(".", "_")}";
            bool createdNew;
            _mutex = new Mutex(true, mutexName, out createdNew);
            if (!createdNew)
            {
               _loggingService.LogWarning($"MonitorAgent (ID: {_agentIdentifier.UniqueId}) is already running. Shutting down new instance.");
                // 사용자에게 알림 (선택적)
                // MessageBox.Show("Monitor Agent is already running.", AppConstants.AppName, MessageBoxButton.OK, MessageBoxImage.Information);
                Shutdown();
                return;
            }

            _loggingService.LogInfo($"Starting {AppConstants.AppName} with ID: {_agentIdentifier.UniqueId}");

            _monitorControlService = new MonitorControlService(_loggingService);
            _startupRegistryService = new StartupRegistryService(AppConstants.AppName, _loggingService);

            _agentCore = new AgentCore(_loggingService, _agentIdentifier, _monitorControlService);
            _agentCore.OnStatusChanged += AgentCore_OnStatusChanged;

            _trayIconManager = new TrayIconManager(_agentIdentifier.UniqueId, HandleExitRequest);
            _trayIconManager.UpdateStatus(AgentOperationalStatus.Initializing, "Starting up...");

            _startupRegistryService.EnsureRegistered();

            try
            {
                await _agentCore.StartAsync(); // AgentCore 시작 (내부적으로 TCP 리스너 시작)
            }
            catch (Exception ex)
            {
                _loggingService.LogFatal("Failed to start AgentCore during application startup.", ex);
                MessageBox.Show($"Critical error starting agent: {ex.Message}\nCheck logs for details. The application will now exit.", 
                                AppConstants.AppName + " Error", MessageBoxButton.OK, MessageBoxImage.Error);
                Shutdown(-1); // 오류 코드로 종료
                return;
            }
        }

        private void AgentCore_OnStatusChanged(AgentOperationalStatus status, string message)
        {
            Dispatcher.Invoke(() =>
            {
                _trayIconManager?.UpdateStatus(status, message);
            });
        }

        private void HandleExitRequest()
        {
            _loggingService.LogInfo("Exit requested from tray icon. Shutting down agent...");
            ShutdownAgentCoreAndExit();
        }

        private void ShutdownAgentCoreAndExit()
        {
            if (Application.Current == null || Application.Current.Dispatcher.HasShutdownStarted || Application.Current.Dispatcher.HasShutdownFinished)
            {
                return;
            }

            _loggingService?.LogInfo("Initiating agent core shutdown sequence...");
            if (_agentCore != null)
            {
                _agentCore.Stop(); 
                _agentCore.Dispose(); 
                _agentCore = null;
            }
            _trayIconManager?.Dispose(); 
            _trayIconManager = null;
            
            _mutex?.ReleaseMutex(); // 뮤텍스 해제
            _mutex?.Dispose();
            _mutex = null;

            _loggingService?.LogInfo("Agent shutdown complete. Exiting application.");
            
            if (Application.Current != null)
            {
                Application.Current.Shutdown();
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            _loggingService?.LogInfo("Application OnExit called.");
            // 중복 호출 방지 및 리소스 정리
            ShutdownAgentCoreAndExit(); 
            base.OnExit(e);
        }
    }
    
    // StartupRegistryService 클래스는 이전 답변과 동일하게 사용
    public class StartupRegistryService
    {
        private readonly string _appName;
        private readonly ILoggingService _logger;
        private readonly string _appPath;

        public StartupRegistryService(string appName, ILoggingService logger)
        {
            _appName = appName ?? throw new ArgumentNullException(nameof(appName));
            _logger = logger ?? throw new ArgumentNullException(nameof(logger));
            try
            {
                _appPath = Process.GetCurrentProcess().MainModule.FileName;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to get current process path for startup registration.", ex);
                _appPath = string.Empty; 
            }
        }
        public void EnsureRegistered()
        {
            if (string.IsNullOrEmpty(_appPath)) { _logger.LogWarning("App path unknown, cannot register startup."); return; }
            try
            {
                using (RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true))
                {
                    if (rkApp == null) { _logger.LogError("Could not open HKCU startup registry key."); return; }
                    object currentValue = rkApp.GetValue(_appName);
                    if (currentValue == null || currentValue.ToString() != _appPath)
                    {
                        rkApp.SetValue(_appName, _appPath);
                        _logger.LogInfo($"App registered for startup: '{_appPath}'");
                    }
                }
            }
            catch (Exception ex) { _logger.LogError("Error accessing registry for startup.", ex); }
        }
    }
}
9. App.xaml (변경 없음 - StartupUri 제거된 상태)

XML

<Application x:Class="MonitorAgent.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:MonitorAgent">
    <Application.Resources>
    </Application.Resources>
</Application>
MonitorAgent 실행:

위 코드들로 MonitorAgent 프로젝트를 빌드합니다.
Newtonsoft.Json NuGet 패키지가 설치되었는지 확인합니다.
별도의 설정 파일이나 명령줄 인자 없이 MonitorAgent.exe를 실행합니다.
Agent는 고정 포트 4099에서 중계 프로그램의 연결을 기다립니다.
로그는 Logs 폴더에 날짜별로 기록되고, 3일 지난 로그는 자동 삭제됩니다.
트레이 아이콘이 표시됩니다.
이제 이 MonitorAgent는 중계 프로그램(MGSPBrokerService)이 자신의 IP와 4099 포트로 접속하여 명령을 내릴 수 있도록 준비된 상태입니다.