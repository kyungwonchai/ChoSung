MouseMove와 Drop 이벤트가 ListBox에 설정되어 있으면, ListBox에서의 마우스 이벤트가 CheckBox로 전파되지 않을 수 있습니다. 이 문제를 해결하기 위해서는 몇 가지 방법이 있습니다.

먼저, ListBox의 드래그 앤 드롭 이벤트를 처리하는 코드에서 실제로 드래그해야 하는 아이템이 CheckBox가 아닌지 확인해야 합니다. CheckBox를 드래그하는 것이 아니라, ListBoxItem을 드래그하도록 코드를 작성해야 합니다.

PreviewMouseMove 이벤트 핸들러는 다음과 같이 작성해야 합니다:

csharp
Copy code
private void ListBoxColumns_PreviewMouseMove(object sender, MouseEventArgs e)
{
    if (sender is ListBoxItem && e.LeftButton == MouseButtonState.Pressed)
    {
        var listBoxItem = FindAncestor<ListBoxItem>((DependencyObject)e.OriginalSource);
        if (listBoxItem != null && listBoxItem.IsSelected)
        {
            DragDrop.DoDragDrop(listBoxItem, listBoxItem.DataContext, DragDropEffects.Move);
        }
    }
}
Drop 이벤트도 유사하게, 실제로 ListBoxItem에 대해서만 동작하도록 해야 합니다.

CheckBox_Checked 이벤트가 발생하지 않는 문제를 해결하기 위해서는, CheckBox 이벤트 핸들러에서 e.Handled를 true로 설정하지 않는지 확인해야 합니다. 이렇게 하면 이벤트가 부모 컨트롤로 전파되지 않습니다.

CheckBox에 대한 Checked 및 Unchecked 이벤트 핸들러는 다음과 같이 작성할 수 있습니다:

csharp
Copy code
private void CheckBox_Checked(object sender, RoutedEventArgs e)
{
    // 체크박스의 체크 상태가 변경될 때 필요한 로직을 여기에 구현합니다.
    // 예: 해당 ColumnInfo의 IsVisible 속성 업데이트
    var checkBox = sender as CheckBox;
    var columnInfo = checkBox.DataContext as ColumnInfo;
    if (columnInfo != null)
    {
        columnInfo.IsVisible = checkBox.IsChecked == true;
    }

    // 이벤트 전파를 막지 않습니다. e.Handled = true; 를 설정하지 않습니다.
}
CheckBox 클릭 이벤트가 정상적으로 동작하지 않는다면, 이벤트 버블링과 관련된 문제일 수 있습니다. PreviewMouseMove 이벤트가 CheckBox 이벤트를 가로채지 않도록, 드래그 앤 드롭 로직을 구현할 때 OriginalSource가 CheckBox인지 확인하고, 그렇다면 드래그 앤 드롭을 시작하지 않도록 해야 합니다.

또한, 드래그 앤 드롭 시 ListBoxItem이 아닌 해당 컨트롤의 DataContext (즉, ColumnInfo 객체)를 사용하여 드래그 앤 드롭을 수행해야 하며, 드래그를 시작하기 전에 OriginalSource가 CheckBox인지 확인해야 합니다.

위 코드 예시는 기본적인 아이디어를 제공합니다만, 실제 구현은 사용 중인 전체 코드의 컨텍스트에 따라 달라질 수 있습니다. 따라서, 위 코드를 기반으로 실제 사용 중인 코드에 맞게 조정이 필요할 수 있습니