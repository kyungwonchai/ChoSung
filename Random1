// MGSPMonitorControl/Services/BrokerClientService.cs
using System;
using System.IO;
using System.Net; 
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorControl.SharedModels; 
using Newtonsoft.Json;
using System.Configuration;     

namespace MGSPMonitorControl.Services
{
    // ... (IBrokerClientService 인터페이스는 이전과 동일) ...

    public class BrokerClientService : IBrokerClientService, IDisposable
    {
        // ... (다른 필드 선언은 이전과 동일) ...
        private volatile bool _isConnectingInternal = false; // volatile은 유지
        private readonly object _connectLock = new object(); // 연결 시도 동기화를 위한 lock 객체

        // ... (생성자 및 다른 메서드는 이전 답변의 최종본과 동일하게 유지) ...

        private async Task<Tuple<bool, string>> ConnectInternalAsync(CancellationToken token)
        {
            if (IsConnected) return Tuple.Create(true, "Already connected internally.");
            if (_isDisposed) return Tuple.Create(false, "Object disposed.");

            // --- 여기가 수정된 부분 ---
            // Interlocked 대신 lock 사용 또는 단순 플래그 관리
            // 여기서는 lock을 사용하여 _isConnectingInternal 플래그를 안전하게 관리
            lock (_connectLock)
            {
                if (_isConnectingInternal)
                {
                    SafeConsoleLog("BrokerClientService: Internal connection attempt already in progress (lock check).");
                    return Tuple.Create(false, "Internal connection attempt already in progress.");
                }
                _isConnectingInternal = true; // lock 안에서 설정
            }
            // --- 수정된 부분 끝 ---

            string connectResultMessage = "Connection attempt failed.";
            // 이전 연결 리소스가 남아있을 수 있으므로 정리 후 시도
            CleanupConnectionResourcesInternal(false, "Preparing for new connection attempt", false, token);

            _tcpClient = new TcpClient(); 
            SafeConsoleLog($"BrokerClientService: New TcpClient. Target: {_brokerIp}:{_brokerPort}");

            try
            {
                if (string.IsNullOrEmpty(_brokerIp)) 
                {
                    connectResultMessage = "Broker IP address is not configured or invalid. Cannot connect.";
                    SafeConsoleLog($"[ERROR] BrokerClientService: {connectResultMessage}");
                    // finally 블록에서 _isConnectingInternal = false; 처리되므로 여기서 별도 처리 안함
                    return Tuple.Create(false, connectResultMessage);
                }

                SafeConsoleLog($"BrokerClientService: Attempting _tcpClient.ConnectAsync to {_brokerIp}:{_brokerPort}...");
                
                var connectTask = _tcpClient.ConnectAsync(_brokerIp, _brokerPort);
                var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(7), token);

                Task completedTask = await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false);

                if (token.IsCancellationRequested) throw new OperationCanceledException("Connection cancelled by token.", token);
                if (completedTask == timeoutDelayTask || !connectTask.IsCompleted) throw new TimeoutException($"Timeout connecting to Broker {_brokerIp}:{_brokerPort} after 7s.");
                
                await connectTask.ConfigureAwait(false); 

                if (_tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    if (_networkStream == null) 
                    {
                        connectResultMessage = "CRITICAL: NetworkStream is null after TcpClient successfully connected.";
                        SafeConsoleLog($"[ERROR] BrokerClientService: {connectResultMessage}");
                        _tcpClient?.Close(); 
                        return Tuple.Create(false, connectResultMessage);
                    }
                    
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    
                    connectResultMessage = "Successfully connected. Streams initialized.";
                    SafeConsoleLog($"BrokerClientService: {connectResultMessage}");
                    
                    // _isConnectingInternal = false; // 성공 시에는 finally에서 처리하지 않고, 여기서 false로 할 수 있으나 일관성을 위해 finally에서.
                    Connected?.Invoke();   

                    if (_receiveLoopTask == null || _receiveLoopTask.IsCompleted)
                    {
                         _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(token), token);
                    }
                    return Tuple.Create(true, connectResultMessage);
                }
                else throw new SocketException((int)SocketError.NotConnected);
            }
            // ... (catch 블록들은 이전 답변과 동일하게 유지, connectResultMessage 설정) ...
            catch (OperationCanceledException opEx) { connectResultMessage = $"Connection cancelled: {opEx.Message}"; SafeConsoleLog(connectResultMessage); }
            catch (SocketException sockEx) { connectResultMessage = $"SocketException: {sockEx.Message} (Code: {sockEx.SocketErrorCode}). Broker at {_brokerIp}:{_brokerPort} may be down/firewalled."; SafeConsoleLog($"[ERROR] {connectResultMessage}"); }
            catch (TimeoutException timeEx) { connectResultMessage = timeEx.Message; SafeConsoleLog($"[ERROR] {connectResultMessage}"); }
            catch (InvalidOperationException invOpEx) { connectResultMessage = $"Invalid operation: {invOpEx.Message}"; SafeConsoleLog($"[ERROR] {connectResultMessage}");}
            catch (Exception ex) { connectResultMessage = $"General Connect Error: {ex.ToString()}"; SafeConsoleLog($"[ERROR] {connectResultMessage}"); }
            finally 
            { 
                // Interlocked.Exchange(ref _isConnectingInternal, 0); // bool 이므로 Interlocked 사용 불가
                _isConnectingInternal = false; // 단순 할당 (lock으로 보호했으므로 스레드 안전)
                if (!IsConnected) { _tcpClient?.Close(); _tcpClient = null; }
            }
            
            // CleanupConnectionResourcesInternal(false, $"ConnectInternalAsync failed: {connectResultMessage}", false); // 여기서 호출하지 않음
            // Disconnected 이벤트는 MaintainConnectionLoopAsync 또는 외부 ConnectAsync 호출자가 처리
            return Tuple.Create(false, connectResultMessage);
        }

        // ... (ReceiveMessagesAsync, SendMessageAsync, HandleSendErrorInternal, DisconnectAsync,
        //      CleanupConnectionResourcesInternal, Dispose, SafeConsoleLog 메서드들은
        //      이전 답변("열받네,,,,,야 씨발 이에러에 집중해서...")에서 제공한 최종본과 동일하게 유지합니다.) ...
    }
}