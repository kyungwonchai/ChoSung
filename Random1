해했습니다. 드래그 앤 드롭을 통해 작업 순서를 변경하는 기능을 포함하도록 전체 코드를 제공합니다. MainWindow.xaml.cs 파일에서 드래그 앤 드롭을 구현하고, 순서 변경 후 데이터베이스에 반영하는 코드도 포함하여 드리겠습니다.

수정된 MainWindow.xaml.cs - 드래그 앤 드롭 포함 전체 코드
csharp
코드 복사
using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Windows.Input;
using DevExpress.Xpf.Grid;
using SwiftAIMaster.ViewModels;
using SwiftAIMaster.Models;

namespace SwiftAIMaster.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel ViewModel => (MainViewModel)DataContext;

        private bool isDragging = false;      // 드래그 상태 플래그
        private int sourceIndex = -1;         // 드래그 시작 인덱스 저장용

        public MainWindow()
        {
            InitializeComponent();
            DataContext = new MainViewModel();
        }

        // 작업 추가 버튼 클릭 이벤트
        private void AddTaskButton_Click(object sender, RoutedEventArgs e)
        {
            var addTaskWindow = new AddTaskWindow();
            if (addTaskWindow.ShowDialog() == true)
            {
                var newTask = addTaskWindow.Task;
                ViewModel.AddNewTask(newTask.FolderPath, newTask.CellColor, newTask.Assignee);
            }
        }

        // 폴더 열기 명령 설정
        public ICommand OpenFolderCommand => new RelayCommand<string>(OpenFolder);

        // 폴더 열기 함수
        private void OpenFolder(string folderPath)
        {
            if (Directory.Exists(folderPath))
            {
                Process.Start("explorer.exe", folderPath);
            }
            else
            {
                MessageBox.Show("폴더가 존재하지 않습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        // MouseDown 이벤트 - 드래그 시작
        private void taskGrid_MouseDown(object sender, MouseButtonEventArgs e)
        {
            var rowHandle = taskGrid.View.GetRowHandleByMouseEventArgs(e);
            if (rowHandle >= 0 && rowHandle < ViewModel.TaskManager.Tasks.Count) // 유효한 인덱스인지 확인
            {
                isDragging = true;           // 드래그 시작 플래그 설정
                sourceIndex = rowHandle;     // 드래그 시작 위치 설정
            }
        }

        // MouseMove 이벤트 - 드래그 상태 유지
        private void taskGrid_MouseMove(object sender, MouseEventArgs e)
        {
            // 드래그 상태에서만 처리
            if (isDragging && e.LeftButton == MouseButtonState.Pressed)
            {
                // 드래그 상태 유지 (여기에서는 추가 로직이 필요 없음)
            }
        }

        // MouseUp 이벤트 - 드래그 완료
        private void taskGrid_MouseUp(object sender, MouseButtonEventArgs e)
        {
            if (isDragging)
            {
                // 드래그한 항목을 놓을 위치를 가져옴
                var targetIndex = taskGrid.View.GetRowHandleByMouseEventArgs(e);
                if (targetIndex >= 0 && targetIndex < ViewModel.TaskManager.Tasks.Count && targetIndex != sourceIndex)
                {
                    // 드래그한 항목을 새로운 위치로 이동
                    var task = ViewModel.TaskManager.Tasks[sourceIndex];
                    ViewModel.TaskManager.Tasks.RemoveAt(sourceIndex);
                    ViewModel.TaskManager.Tasks.Insert(targetIndex, task);

                    // 순서 변경을 DB에 반영
                    ViewModel.TaskManager.UpdateTaskPriorities();
                }

                // 드래그 상태 초기화
                isDragging = false;
                sourceIndex = -1;
            }
        }
    }
}
추가 설명
MouseDown, MouseMove, MouseUp 이벤트를 통해 드래그 앤 드롭으로 순서를 변경할 수 있도록 했습니다.
UpdateTaskPriorities 메서드를 통해 드래그 완료 시 새로운 순서가 데이터베이스에 반영됩니다.
이제 드래그 앤 드롭 기