겠습니다. 주어진 조건에 따라 시간대 분류를 정확히 구현하겠습니다. 특히 "~"를 기준으로 각 구간을 반영하여 수정하겠습니다.

조건 정리
21:00 ~ 22:20 → 21시
22:30 ~ 23:20 → 22시
23:30 ~ 00:20 → 23시
00:30 ~ 01:20 → 00시
01:30 ~ 02:20 → 01시
02:30 ~ 03:20 → 02시
03:30 ~ 04:20 → 03시
04:30 ~ 05:20 → 04시
05:30 ~ 06:50 → 05시
나머지 시간은 그대로 반환.
수정된 쿼리
sql
코드 복사
WITH view1 AS (
    SELECT 
        Line,
        DATEADD(MINUTE, -10, datev) AS datev1,
        pickupcnt
    FROM table_lossdata
)
SELECT 
    Line,
    pickupcnt,
    datev1,
    CONVERT(VARCHAR(13), datev1, 120) AS 시간,
    CASE
        -- 21시: 21:00 ~ 22:20
        WHEN (DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) >= 0)
          OR (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) <= 20) THEN '21'
        -- 22시: 22:30 ~ 23:20
        WHEN (DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) <= 20) THEN '22'
        -- 23시: 23:30 ~ 00:20
        WHEN (DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) <= 20) THEN '23'
        -- 00시: 00:30 ~ 01:20
        WHEN (DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) <= 20) THEN '00'
        -- 01시: 01:30 ~ 02:20
        WHEN (DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 2 AND DATEPART(MINUTE, datev1) <= 20) THEN '01'
        -- 02시: 02:30 ~ 03:20
        WHEN (DATEPART(HOUR, datev1) = 2 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 3 AND DATEPART(MINUTE, datev1) <= 20) THEN '02'
        -- 03시: 03:30 ~ 04:20
        WHEN (DATEPART(HOUR, datev1) = 3 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 4 AND DATEPART(MINUTE, datev1) <= 20) THEN '03'
        -- 04시: 04:30 ~ 05:20
        WHEN (DATEPART(HOUR, datev1) = 4 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) <= 20) THEN '04'
        -- 05시: 05:30 ~ 06:50
        WHEN (DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) >= 30)
          OR (DATEPART(HOUR, datev1) = 6 AND DATEPART(MINUTE, datev1) <= 50) THEN '05'
        -- 기본: 그대로 반환
        ELSE RIGHT('0' + CONVERT(VARCHAR, DATEPART(HOUR, datev1)), 2)
    END AS 분류시간
FROM view1
ORDER BY datev1;
쿼리 설명
view1 생성:

datev에서 10분을 뺀 datev1을 생성.
이후 처리에 사용할 기준 데이터를 정리.
CASE 문 분류:

DATEPART(HOUR, datev1)와 DATEPART(MINUTE, datev1)을 사용하여 각 시간대를 구분.
주어진 규칙에 따라 특정 시간대로 그룹화:
21시: 21:00 ~ 22:20
22시: 22:30 ~ 23:20
23시: 23:30 ~ 00:20
00시 ~ 04시: 동일한 규칙 반복.
05시: 05:30 ~ 06:50
결과 정렬:

datev1 기준 오름차순으로 정렬.
예시 결과
Line	pickupcnt	datev1	시간	분류시간
A	10	2025-01-20 21:10:00	2025-01-20 21	21
A	20	2025-01-20 22:40:00	2025-01-20 22	22
A	30	2025-01-20 23:45:00	2025-01-20 23	23
A	40	2025-01-21 00:35:00	2025-01-21 00	00