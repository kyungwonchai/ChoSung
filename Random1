알겠습니다. 말씀하신 조건을 정확히 반영하여 코드를 수정하겠습니다.

수정된 규칙 요약:
rf-로 시작하는 문자열 뒤에 올 수 있는 올바른 형식은:

정확히 공백 4칸 + 세미콜론 (예: "rf-abc1234 ;")
공백 N칸 (N은 1개 이상) + 이어진 문자열(공백 없이) + 공백 M칸 (M은 0개 이상) + 세미콜론 (예: "rf-abc text ;", "rf-xyz987 ;", "rf-example example2;")
잘못된 형식:

rf- 뒤에 공백 없이 바로 세미콜론이 오는 경우는 NG.
rf- 뒤에 여러 그룹의 띄워진 문자열이 있는 경우도 NG. (예: "rf-ab cd;")
rf- 뒤에 공백이 4개가 아닌 경우(0~3개 또는 5개 이상) 뒤에 세미콜론이 오는 경우도 NG.
수정된 코드:
csharp
코드 복사
using System;
using System.Text.RegularExpressions;
using System.Diagnostics;

class Program
{
    static void Main()
    {
        // 예시 문자열들
        string[] inputs = {
            "rf-abc1234    ; following text",   // OK: 공백 4칸 + 세미콜론
            "rf-xyz987 ; other text",          // NG: 공백 1칸 + 세미콜론 (잘못된 규칙)
            "rf-sampletext      ;",            // NG: 공백 6칸 + 세미콜론 (잘못된 규칙)
            "rf-abcdefg;;",                    // NG: 공백 없이 바로 세미콜론 (잘못된 규칙)
            "rf-qwerty   ;",                   // NG: 공백 3칸 + 세미콜론 (잘못된 규칙)
            "rf-random text ;",                // OK: 문자열 + 공백 + 세미콜론 (정상)
            "rf-abcdefg    following text;",   // OK: 공백 4칸 + 텍스트 + 세미콜론 (정상)
            "rf-test;;",                       // NG: 공백 없이 바로 세미콜론 (잘못된 규칙)
            "rf-abc text1 text2 ;",            // NG: 두 그룹의 띄워진 문자열 (잘못된 규칙)
            "rf-example   example2 ;",         // OK: 이어진 두 개의 단어가 공백 없이 이어져 있음 (정상)
            "rf-exgsdgsd  gsdgs ;",            // OK: 공백 + 이어진 문자열 + 공백 + 세미콜론 (정상)
            "rf-fsdgsdgds ab cd;"              // NG: 여러 개의 띄워진 문자열 그룹 (잘못된 규칙)
        };

        // 정규식 패턴 설정
        // 패턴: rf-로 시작하는 문자열 뒤에 특정 조건을 만족하는 패턴을 찾기 위한 정규식
        string pattern = @"rf-(?<content>[^\s;]+)(?<ending>(\s{4};|\s+[^\s;]+(\s+[^\s;]+)?\s*;))";

        // 각 문자열 검사
        foreach (var input in inputs)
        {
            // 패턴에 매칭되는지 검사
            var match = Regex.Match(input, pattern);

            if (match.Success)
            {
                // 올바른 패턴이 매칭된 경우 - 아무런 처리도 하지 않음
                // 올바른 패턴:
                // - 공백 4칸 + 세미콜론
                // - 공백 N칸 (N은 1개 이상) + 이어진 문자열(공백 없이) + 공백 M칸 (M은 0개 이상) + 세미콜론
                continue;
            }
            else
            {
                // 잘못된 패턴이 있는 경우
                // "rf-"로 시작하는 부분을 찾고 첫 번째 공백 또는 세미콜론이 나오기 전까지의 문자열 추출
                var rfMatch = Regex.Match(input, @"rf-[^\s;]*");
                if (rfMatch.Success)
                {
                    // "rf-"로 시작하고 공백 없이 바로 세미콜론이 오는 경우 NG 처리
                    if (Regex.IsMatch(input, @"rf-[^\s;]+;"))
                    {
                        Debug.WriteLine($"Invalid pattern found: '{input}'. Starts with 'rf-': '{rfMatch.Value}' - Reason: No space before semicolon.");
                    }
                    // "rf-"로 시작하고 두 그룹 이상의 띄워진 문자열이 있는 경우 NG 처리
                    else if (Regex.IsMatch(input, @"rf-[^\s;]+\s+[^\s;]+\s+[^\s;]+;"))
                    {
                        Debug.WriteLine($"Invalid pattern found: '{input}'. Starts with 'rf-': '{rfMatch.Value}' - Reason: Multiple groups of words before semicolon.");
                    }
                    // "rf-"로 시작하고 공백이 0-3개 또는 5개 이상인 경우 NG 처리
                    else if (Regex.IsMatch(input, @"rf-[^\s;]+(\s{0,3};|\s{5,};)"))
                    {
                        Debug.WriteLine($"Invalid pattern found: '{input}'. Starts with 'rf-': '{rfMatch.Value}' - Reason: Incorrect number of spaces before semicolon.");
                    }
                    else
                    {
                        Debug.WriteLine($"Invalid pattern found: '{input}'. Starts with 'rf-': '{rfMatch.Value}'");
                    }
                }
                else
                {
                    // "rf-"로 시작하지 않는 잘못된 문자열에 대한 디버그 출력
                    Debug.WriteLine($"Invalid pattern found: '{input}'");
                }
            }
        }
    }
}
코드 설명
inputs 배열:

검사할 여러 예시 문자열을 저장하고 있습니다. 각 문자열이 규칙에 맞는지 확인합니다.
정규식 패턴 (pattern):

rf-(?<content>[^\s;]+): rf-로 시작하고 그 뒤에 공백이나 세미콜론이 아닌 문자열이 옵니다.
(?<ending>(\s{4};|\s+[^\s;]+(\s+[^\s;]+)?\s*;)): 패턴의 끝나는 부분을 검사합니다.
\s{4};: 정확히 4개의 공백 뒤에 세미콜론이 오는 경우.
\s+[^\s;]+(\s+[^\s;]+)?\s*;: 공백이 1개 이상 있고 단일 이어진 문자열(공백 없이)만 있으며, 그 뒤에 세미콜론이 오는 경우. 두 번째 단어도 공백 없이 이어질 수 있음.
패턴 매칭 (Regex.Match):

각 문자열에 대해 정규식 패턴을 사용하여 매칭을 시도합니다.
매칭에 성공하면 continue로 루프의 다음 반복으로 넘어갑니다.
매칭에 실패하면 그 문자열을 잘못된 패턴으로 간주합니다.
잘못된 패턴 처리:

잘못된 패턴의 경우, rf-로 시작하는 문자열을 찾아내어 첫 번째 공백이나 세미콜론이 나오기 전까지의 부분을 추출합니다.
여러 가지 잘못된 경우를 각각 검사하여 디버그 출력을 통해 문제가 되는 패턴을 보고합니다:
공백 없이 바로 세미콜론이 오는 경우.
여러 그룹의 띄워진 문자열이 있는 경우.
공백이 0-3개 또는 5개 이상인 경우.
Debug.WriteLine을 사용하여 잘못된 패턴과 관련된 정보를 디버깅 출력으로 표시합니다. 이를 통해 콘솔에 불필요한 출력을 남기지 않고 디버깅 목적으로만 출력을 확인할 수 있습니다.
각 문자열에 대한 평가
"rf-abc1234 ; following text"

OK: rf- 뒤에 abc1234가 오고, 정확히 4칸의 공백 뒤에 세미콜론이 옵니다. 규칙에 맞음.
"rf-xyz987 ; other text"

NG: rf- 뒤에 xyz987가 오고, 공백 1칸 뒤에 세미콜론이 옵니다. 4칸의 공백이 아니므로 잘못된 규칙입니다.
"rf-sampletext ;"

NG: rf- 뒤에 sampletext가 오고, 6칸의 공백 뒤에 세미콜론이 옵니다. 4칸의 공백이 아니므로 잘못된 규칙입니다.
"rf-abcdefg;;"

NG: rf- 뒤에 abcdefg가 오고, 바로 세미콜론이 옵니다. 공백이 없으므로 잘못된 규칙입니다.
