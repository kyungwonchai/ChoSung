알겠습니다! DB 이름은 MonitorControlDB로 확정되었군요. 이 정보는 나중에 제어 UI 프로그램에서 DB에 연결할 때 사용됩니다. 중계 프로그램은 DB에 직접 접근하지 않으므로 DB명 자체는 중계 프로그램 코드에 직접적인 영향을 주지는 않습니다.

이제 중계 프로그램 (MGSPBrokerService)의 전체 코드를 제공해 드리겠습니다. 이 프로그램은 순수 TCP 소켓 통신을 기반으로 하며, 제어 UI와 Agent들 사이의 메시지를 중계하는 역할을 합니다.

프로젝트 생성:

Visual Studio에서 새 프로젝트를 만듭니다.
템플릿: "콘솔 앱(.NET Framework)"
프로젝트 이름: MGSPBrokerService
프레임워크: ".NET Framework 4.5"
필요한 NuGet 패키지 설치:

솔루션 탐색기에서 MGSPBrokerService 프로젝트 마우스 우클릭 -> "NuGet 패키지 관리..." -> "찾아보기" 탭에서 다음 패키지를 검색하여 설치합니다.

Newtonsoft.Json: Agent, UI와 주고받을 메시지를 JSON 형식으로 직렬화/역직렬화하기 위해 사용합니다.
패키지 관리자 콘솔 명령어: Install-Package Newtonsoft.Json
중계 프로그램 (MGSPBrokerService) 코드 구성:

1. Models/MessageContract.cs (통신 메시지 규약 정의)

이 파일은 UI, 중계기, Agent 간에 주고받을 메시지의 종류와 데이터 구조를 정의합니다. 사실상 통신 프로토콜의 일부입니다.

C#

// MGSPBrokerService/Models/MessageContract.cs
using System.Collections.Generic;

namespace MGSPBrokerService.Models
{
    // 메시지 타입 구분용 Enum
    public enum MessageType
    {
        // UI -> Broker -> Agent (명령 관련)
        UiRequest_ControlAgent,     // UI가 Agent 제어 명령을 Broker에게 요청
        BrokerToAgent_ExecuteControl, // Broker가 Agent에게 실제 제어 명령 전달

        // Agent -> Broker -> UI (명령 결과 및 상태 보고 관련)
        AgentToBroker_CommandResult,  // Agent가 Broker에게 명령 실행 결과 보고
        BrokerToUi_ForwardAgentResult, // Broker가 UI에게 Agent의 명령 실행 결과 전달
        AgentToBroker_StatusUpdate,   // Agent가 Broker에게 자신의 현재 상태 보고
        BrokerToUi_BroadcastAgentStatus, // Broker가 UI에게 Agent의 현재 상태 브로드캐스트

        // Broker <-> UI (Broker 자체 상태 및 로그 관련)
        UiRequest_GetBrokerStatus,    // UI가 Broker에게 상태 및 로그 요청
        BrokerToUi_SendBrokerStatus,  // Broker가 UI에게 자신의 상태 및 로그 전달

        // Broker <-> Agent (연결 관리 등)
        AgentHello,                 // Agent가 Broker에 처음 연결 시 자신을 알림
        BrokerAck_AgentHello,       // Broker가 AgentHello에 대한 응답
        Ping,                       // 생존 확인용
        Pong                        // Ping에 대한 응답
    }

    // 기본 메시지 구조체 (모든 메시지의 기본 형태)
    public class BrokerMessage
    {
        public MessageType Type { get; set; }
        public string SourceId { get; set; } // 메시지를 보낸 주체 (AgentId 또는 UI의 고유 식별자)
        public string TargetId { get; set; } // 메시지를 받을 대상 (AgentId 또는 "ALL_UIS", "BROKER")
        public string CorrelationId { get; set; } // 요청과 응답을 매칭하기 위한 ID
        public string Payload { get; set; } // 실제 데이터 (JSON 문자열)
    }

    // 페이로드 예시들

    // AgentHello 메시지의 페이로드 (Agent -> Broker)
    public class AgentHelloPayload
    {
        public string AgentIdProvidedByApp { get; set; } // Agent가 자체적으로 가진 고유 ID
        public string MachineName { get; set; }
        public List<string> IpAddresses { get; set; }
        public string AgentVersion { get; set; }
    }

    // UiRequest_ControlAgent 메시지의 페이로드 (UI -> Broker)
    // 이 정보는 UI가 DB에서 가져와서 Broker에게 전달함
    public class UiControlAgentPayload
    {
        public string TargetAgentIdProvidedByApp { get; set; } // 제어할 Agent의 고유 ID
        public string ControlAction { get; set; } // 예: "TurnMonitorOn", "TurnMonitorOff"
        // Agent 제어 경로 정보 (UI가 DB에서 읽어옴)
        public string ControlType { get; set; } // "Direct" 또는 "Gatewayed"
        public string PrimaryIpAddress { get; set; }
        public int PrimaryPort { get; set; }
        public string GatewayAgentIpAddress { get; set; } // ControlType이 Gatewayed일 경우
        public int? GatewayAgentPort { get; set; }      // ControlType이 Gatewayed일 경우
        public string OriginalParameters { get; set; } // 명령에 필요한 추가 파라미터 (JSON)
    }

    // BrokerToAgent_ExecuteControl 메시지의 페이로드 (Broker -> Agent 또는 Broker -> GatewayAgent)
    public class BrokerExecuteControlPayload
    {
        public string ActionToPerform { get; set; } // 예: "TurnMonitorOn"
        public string Parameters { get; set; } // 명령 파라미터

        // 만약 이 명령이 GatewayAgent를 통해 최종 Agent로 가야 한다면, 최종 Agent 정보 포함
        public bool IsGatewayRelay { get; set; } = false;
        public string FinalTargetAgentIp { get; set; } // Gateway가 이 IP로 최종 전달
        public int? FinalTargetAgentPort { get; set; }
    }

    // AgentToBroker_CommandResult 메시지의 페이로드 (Agent -> Broker)
    public class AgentCommandResultPayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string CurrentMonitorStatus { get; set; } // 명령 실행 후 모니터 상태
    }
    
    // AgentToBroker_StatusUpdate 메시지의 페이로드 (Agent -> Broker)
    public class AgentStatusUpdatePayload
    {
        public string CurrentMonitorStatus { get; set; }
        // 추가적인 상태 정보 (CPU, Memory 등) 포함 가능
    }

    // BrokerToUi_SendBrokerStatus 메시지의 페이로드 (Broker -> UI)
    public class BrokerStatusPayload
    {
        public DateTime ServerStartTime { get; set; }
        public string UptimeString { get; set; }
        public int ConnectedUiCount { get; set; }
        public int ConnectedAgentCount { get; set; }
        public List<string> RecentLogs { get; set; } // 서버 내부 로그
        public string BrokerVersion { get; set; }
    }
}
2. Services/LoggingService.cs (간단 로깅 서비스)

이전 Agent의 로깅 서비스와 유사하지만, Broker용으로 맞춤.

C#

// MGSPBrokerService/Services/LoggingService.cs
using System;
using System.Collections.Concurrent;
using System.IO;
using System.Text;

namespace MGSPBrokerService.Services
{
    public enum LogLevel
    {
        Debug, Info, Warning, Error, Fatal
    }

    public interface ILoggingService
    {
        void Debug(string message);
        void Info(string message);
        void Warn(string message);
        void Error(string message, Exception ex = null);
        void Fatal(string message, Exception ex = null);
        List<string> GetRecentLogs(int count);
    }

    public class BrokerLoggingService : ILoggingService
    {
        private const string LogFileName = "broker_service_log.txt";
        private const int MaxInMemoryLogs = 100; // UI 전송용 메모리 내 로그 수
        private readonly string _logFilePath;
        private static readonly object _fileLock = new object();
        private readonly ConcurrentQueue<string> _recentLogs = new ConcurrentQueue<string>();

        public BrokerLoggingService()
        {
            _logFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, LogFileName);
            Info("Broker Logging Service initialized.");
        }

        private void WriteLog(LogLevel level, string message, Exception ex = null)
        {
            string logEntry = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] [{level.ToString().ToUpper()}] {message}";
            if (ex != null)
            {
                logEntry += $"{Environment.NewLine}   Exception: {ex.ToString()}";
            }

            // 콘솔에 출력
            if (level >= LogLevel.Info) // 정보 레벨 이상만 콘솔에 출력 (조정 가능)
            {
                ConsoleColor originalColor = Console.ForegroundColor;
                switch (level)
                {
                    case LogLevel.Warning: Console.ForegroundColor = ConsoleColor.Yellow; break;
                    case LogLevel.Error:   Console.ForegroundColor = ConsoleColor.Red; break;
                    case LogLevel.Fatal:   Console.ForegroundColor = ConsoleColor.DarkRed; break;
                    default: Console.ForegroundColor = ConsoleColor.Gray; break;
                }
                Console.WriteLine(logEntry);
                Console.ForegroundColor = originalColor;
            }

            // 파일에 기록
            lock (_fileLock)
            {
                try
                {
                    File.AppendAllText(_logFilePath, logEntry + Environment.NewLine);
                }
                catch { /* 파일 쓰기 실패는 일단 무시 */ }
            }
            
            // 메모리 내 로그 큐에 추가
            _recentLogs.Enqueue(logEntry);
            while (_recentLogs.Count > MaxInMemoryLogs && _recentLogs.TryDequeue(out _)) { }
        }

        public void Debug(string message) => WriteLog(LogLevel.Debug, message);
        public void Info(string message) => WriteLog(LogLevel.Info, message);
        public void Warn(string message) => WriteLog(LogLevel.Warning, message);
        public void Error(string message, Exception ex = null) => WriteLog(LogLevel.Error, message, ex);
        public void Fatal(string message, Exception ex = null) => WriteLog(LogLevel.Fatal, message, ex);

        public List<string> GetRecentLogs(int count)
        {
            return _recentLogs.TakeLast(count).ToList(); // ConcurrentQueue는 TakeLast 직접 지원 안함. ToArray 후 Linq 사용.
                                                         // 또는 _recentLogs.ToList().TakeLast() 도 가능.
                                                         // 더 효율적인 방법은 Dequeue/Enqueue 시 별도 List 관리 또는 Circular Buffer.
                                                         // 여기서는 단순하게.
            return _recentLogs.ToArray().Reverse().Take(count).Reverse().ToList(); // 최신 순으로 정렬된 것처럼
        }
    }
}
3. ClientManagement/ClientState.cs (연결된 클라이언트 정보 관리)

C#

// MGSPBrokerService/ClientManagement/ClientState.cs
using System;
using System.Net.Sockets;
using System.IO;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MGSPBrokerService.Models; // BrokerMessage
using MGSPBrokerService.Services; // ILoggingService
using Newtonsoft.Json;

namespace MGSPBrokerService.ClientManagement
{
    public enum ClientType { Unknown, UiClient, AgentClient }

    public class ClientState : IDisposable
    {
        public TcpClient TcpClient { get; }
        public string ClientId { get; private set; } // UI의 경우 ConnectionId, Agent의 경우 AgentIdProvidedByApp
        public ClientType Type { get; private set; } = ClientType.Unknown;
        public NetworkStream Stream { get; }
        private readonly StreamReader _reader;
        private readonly StreamWriter _writer;
        private readonly ILoggingService _logger;
        private readonly Action<ClientState, BrokerMessage> _onMessageReceived; // 메시지 수신 시 호출될 콜백
        private readonly Action<ClientState> _onDisconnected; // 연결 종료 시 호출될 콜백
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly object _writeLock = new object();

        public DateTime ConnectedTime { get; }
        public DateTime LastActivityTime { get; private set; }

        public ClientState(TcpClient tcpClient, ILoggingService logger, Action<ClientState, BrokerMessage> onMessageReceived, Action<ClientState> onDisconnected)
        {
            TcpClient = tcpClient;
            _logger = logger;
            _onMessageReceived = onMessageReceived;
            _onDisconnected = onDisconnected;
            
            Stream = tcpClient.GetStream();
            _reader = new StreamReader(Stream, Encoding.UTF8);
            _writer = new StreamWriter(Stream, Encoding.UTF8) { AutoFlush = true };
            
            ConnectedTime = DateTime.UtcNow;
            LastActivityTime = DateTime.UtcNow;

            // 임시 ID (AgentHello 또는 UI 등록 전까지 사용)
            ClientId = $"Temp_{Guid.NewGuid().ToString("N").Substring(0, 8)}"; 
        }

        public void StartReceiving(CancellationTokenSource parentCts)
        {
            _cts = CancellationTokenSource.CreateLinkedTokenSource(parentCts.Token);
            _receiveLoopTask = Task.Run(ReceiveLoopAsync, _cts.Token);
        }

        // 이 메서드는 AgentHello 또는 UI 등록 후 호출되어 실제 ID와 타입 설정
        public void IdentifyClient(string id, ClientType type)
        {
            ClientId = id;
            Type = type;
            _logger.Info($"Client identified: ID='{ClientId}', Type='{Type}', RemoteEndPoint='{TcpClient.Client.RemoteEndPoint}'");
        }

        private async Task ReceiveLoopAsync()
        {
            _logger.Info($"Receive loop started for client: {ClientId} ({TcpClient.Client.RemoteEndPoint})");
            try
            {
                while (!_cts.Token.IsCancellationRequested && TcpClient.Connected)
                {
                    string messageJson = await _reader.ReadLineAsync(); // 라인 단위로 JSON 메시지 수신
                    if (messageJson == null) // 클라이언트 연결 종료
                    {
                        _logger.Info($"Client {ClientId} disconnected (stream closed).");
                        break;
                    }
                    LastActivityTime = DateTime.UtcNow;

                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null)
                        {
                            _onMessageReceived?.Invoke(this, message);
                        }
                        else
                        {
                            _logger.Warn($"Failed to deserialize message from {ClientId}: {messageJson}");
                        }
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.Error($"JSON deserialization error from {ClientId}: {jsonEx.Message}. Received: {messageJson}", jsonEx);
                    }
                }
            }
            catch (IOException ioEx)
            {
                _logger.Info($"IOException in receive loop for {ClientId} (likely connection forcibly closed): {ioEx.Message}");
            }
            catch (ObjectDisposedException)
            {
                _logger.Info($"Receive loop for {ClientId} terminated due to object disposal (likely during shutdown).");
            }
            catch (OperationCanceledException)
            {
                 _logger.Info($"Receive loop for {ClientId} cancelled.");
            }
            catch (Exception ex)
            {
                _logger.Error($"Unexpected error in receive loop for {ClientId}: {ex.Message}", ex);
            }
            finally
            {
                _logger.Info($"Receive loop ended for client: {ClientId}");
                _onDisconnected?.Invoke(this); // 연결 종료 알림
                Dispose(); // 루프 종료 시 리소스 정리
            }
        }

        public async Task SendMessageAsync(BrokerMessage message)
        {
            if (!TcpClient.Connected || _cts.IsCancellationRequested)
            {
                _logger.Warn($"Cannot send message to {ClientId}. Client not connected or sending cancelled.");
                return;
            }
            try
            {
                string messageJson = JsonConvert.SerializeObject(message);
                // 동시 쓰기 방지를 위해 lock 사용 (StreamWriter는 스레드 안전하지 않을 수 있음)
                lock(_writeLock) 
                {
                    if (!_cts.IsCancellationRequested && TcpClient.Connected)
                    {
                        _writer.WriteLine(messageJson);
                        // _writer.Flush(); // AutoFlush = true 이므로 생략 가능
                    }
                }
                LastActivityTime = DateTime.UtcNow;
                // _logger.Debug($"Message sent to {ClientId}: {message.Type}"); // 너무 잦은 로그일 수 있음
            }
            catch (ObjectDisposedException)
            {
                _logger.Warn($"Attempted to send message to {ClientId} on a disposed stream/writer.");
            }
            catch (IOException ioEx)
            {
                _logger.Error($"IOException sending message to {ClientId} (connection may be lost): {ioEx.Message}", ioEx);
                _onDisconnected?.Invoke(this); // 연결 문제 시 알림
                Dispose();
            }
            catch (Exception ex)
            {
                _logger.Error($"Error sending message to {ClientId}: {ex.Message}", ex);
            }
        }

        public void Dispose()
        {
            if (_cts != null && !_cts.IsCancellationRequested)
            {
                _cts.Cancel(); // 수신 루프 종료 요청
            }
            
            _reader?.Dispose();
            _writer?.Dispose(); // StreamWriter가 Stream을 닫을 수 있으므로 먼저 Dispose
            Stream?.Dispose();  // NetworkStream Dispose
            TcpClient?.Close(); // TcpClient Close (Dispose 호출)
            _cts?.Dispose();
            // _logger.Info($"ClientState for {ClientId} disposed."); // 너무 잦을 수 있음
        }
    }
}
4. BrokerCore.cs (핵심 로직 - 서버 운영 및 메시지 처리)

C#

// MGSPBrokerService/BrokerCore.cs
using System;
using System.Collections.Concurrent;
using System.Collections.Generic;
using System.Linq;
using System.Net;
using System.Net.Sockets;
using System.Threading;
using System.Threading.Tasks;
using MGSPBrokerService.ClientManagement;
using MGSPBrokerService.Models;
using MGSPBrokerService.Services;
using Newtonsoft.Json;

namespace MGSPBrokerService
{
    public class BrokerCore : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly int _uiListenPort;
        private readonly int _agentListenPort;

        private TcpListener _uiListener;
        private TcpListener _agentListener;
        private CancellationTokenSource _serverCts;

        // Key: ConnectionId (ClientState.ClientId와 다름, UI는 임시 ID 후 등록하면 그 ID 사용)
        private readonly ConcurrentDictionary<string, ClientState> _uiClients = new ConcurrentDictionary<string, ClientState>();
        // Key: AgentIdProvidedByApp
        private readonly ConcurrentDictionary<string, ClientState> _agentClients = new ConcurrentDictionary<string, ClientState>();
        
        public static DateTime ServerStartTime { get; private set; }
        public static string BrokerVersion { get; set; } = "1.0.0-Broker";


        public BrokerCore(ILoggingService logger, int uiPort, int agentPort)
        {
            _logger = logger;
            _uiListenPort = uiPort;
            _agentListenPort = agentPort;
            ServerStartTime = DateTime.UtcNow;
            // 버전 정보는 Program.cs 등에서 설정 가능
        }

        public void Start()
        {
            _serverCts = new CancellationTokenSource();
            _logger.Info($"MGSP Broker Service v{BrokerVersion} starting...");

            try
            {
                // UI 리스너 시작
                _uiListener = new TcpListener(IPAddress.Any, _uiListenPort);
                _uiListener.Start();
                _logger.Info($"UI Listener started on port {_uiListenPort}. Waiting for UI connections...");
                Task.Run(() => AcceptLoopAsync(_uiListener, ClientType.UiClient, _serverCts.Token), _serverCts.Token);

                // Agent 리스너 시작
                _agentListener = new TcpListener(IPAddress.Any, _agentListenPort);
                _agentListener.Start();
                _logger.Info($"Agent Listener started on port {_agentListenPort}. Waiting for Agent connections...");
                Task.Run(() => AcceptLoopAsync(_agentListener, ClientType.AgentClient, _serverCts.Token), _serverCts.Token);

                _logger.Info("Broker Core Service running.");
            }
            catch (SocketException sockEx)
            {
                 _logger.Fatal($"Failed to start TCP listener(s). Port in use or permission issue? UI Port: {_uiListenPort}, Agent Port: {_agentListenPort}. Error: {sockEx.Message}", sockEx);
                 throw; // 상위에서 처리하도록 예외 다시 던짐
            }
            catch (Exception ex)
            {
                _logger.Fatal($"Critical error during BrokerCore Start: {ex.Message}", ex);
                throw;
            }
        }

        private async Task AcceptLoopAsync(TcpListener listener, ClientType clientTypeForNewConnections, CancellationToken token)
        {
            _logger.Info($"Accept loop started for {clientTypeForNewConnections} on {((IPEndPoint)listener.LocalEndpoint).Port}");
            while (!token.IsCancellationRequested)
            {
                try
                {
                    TcpClient connectedTcpClient = await listener.AcceptTcpClientAsync().ConfigureAwait(false);
                    _logger.Info($"New {(clientTypeForNewConnections == ClientType.UiClient ? "UI" : "Agent (pending hello)")} connection from {connectedTcpClient.Client.RemoteEndPoint}");
                    
                    var clientState = new ClientState(connectedTcpClient, _logger, HandleClientMessage, HandleClientDisconnect);
                    // 여기서 바로 딕셔너리에 추가하지 않고, 첫 메시지(AgentHello 등)를 통해 ID 확정 후 추가
                    clientState.StartReceiving(_serverCts); // 메시지 수신 루프 시작
                }
                catch (ObjectDisposedException) when (token.IsCancellationRequested)
                {
                    _logger.Info($"Listener for {clientTypeForNewConnections} stopped as requested.");
                    break;
                }
                catch (SocketException sockEx) when (token.IsCancellationRequested || !listener.Server.IsBound)
                {
                     _logger.Info($"Listener socket for {clientTypeForNewConnections} closed during shutdown: {sockEx.Message}");
                     break;
                }
                catch (Exception ex)
                {
                    if (!token.IsCancellationRequested)
                    {
                        _logger.Error($"Error in {clientTypeForNewConnections} accept loop: {ex.Message}", ex);
                        await Task.Delay(1000, token); // 오류 발생 시 잠시 대기
                    }
                }
            }
            _logger.Info($"Accept loop for {clientTypeForNewConnections} stopped.");
        }

        private void HandleClientMessage(ClientState sender, BrokerMessage message)
        {
            _logger.Debug($"Message received from {sender.ClientId} ({sender.Type}): {message.Type}");
            switch (message.Type)
            {
                // Agent -> Broker 메시지 처리
                case MessageType.AgentHello:
                    HandleAgentHello(sender, message);
                    break;
                case MessageType.AgentToBroker_CommandResult:
                    ForwardAgentResultToUi(sender, message);
                    break;
                case MessageType.AgentToBroker_StatusUpdate:
                    BroadcastAgentStatusToUis(sender, message);
                    break;
                
                // UI -> Broker 메시지 처리
                case MessageType.UiRequest_ControlAgent:
                    RelayControlCommandToAgent(sender, message);
                    break;
                case MessageType.UiRequest_GetBrokerStatus:
                    SendBrokerStatusToUi(sender);
                    break;

                // 공통 메시지 (Ping/Pong 등)
                case MessageType.Ping:
                    HandlePing(sender, message);
                    break;
                // 다른 메시지 타입 처리...
                default:
                    _logger.Warn($"Unhandled message type '{message.Type}' from {sender.ClientId}");
                    break;
            }
        }
        
        private void HandleAgentHello(ClientState sender, BrokerMessage helloMessage)
        {
            try
            {
                var helloPayload = JsonConvert.DeserializeObject<AgentHelloPayload>(helloMessage.Payload);
                if (helloPayload == null || string.IsNullOrWhiteSpace(helloPayload.AgentIdProvidedByApp))
                {
                    _logger.Warn($"Invalid AgentHello payload from {sender.ClientId}. Closing connection.");
                    sender.Dispose(); // 연결 종료
                    return;
                }

                string agentId = helloPayload.AgentIdProvidedByApp;
                sender.IdentifyClient(agentId, ClientType.AgentClient); // ClientState에 실제 ID와 타입 설정

                // 기존 연결이 있다면 정리 (예: 이전 세션이 비정상 종료된 경우)
                if (_agentClients.TryGetValue(agentId, out var existingClientState) && existingClientState != sender)
                {
                    _logger.Warn($"Agent {agentId} reconnected with a new session. Closing old session {existingClientState.ClientId}.");
                    existingClientState.Dispose(); 
                    _agentClients.TryRemove(agentId, out _); // 이전 것 제거 시도
                }
                
                _agentClients.AddOrUpdate(agentId, sender, (key, oldClient) => {
                     if(oldClient != sender) oldClient.Dispose(); // 만약 같은 ID로 다른 세션이 있었다면 닫음
                     return sender; 
                });

                _logger.Info($"Agent {agentId} successfully identified and added/updated in list. Machine: {helloPayload.MachineName}");

                // Agent에게 Hello에 대한 Ack 전송
                var ackMessage = new BrokerMessage { Type = MessageType.BrokerAck_AgentHello, TargetId = agentId, CorrelationId = helloMessage.CorrelationId };
                sender.SendMessageAsync(ackMessage).ConfigureAwait(false);

                // 모든 UI 클라이언트에게 새로운 Agent 연결(또는 상태 업데이트) 알림
                var statusPayload = new AgentStatusUpdatePayload { CurrentMonitorStatus = "Unknown" }; // 초기 상태
                BroadcastAgentStatusToUis(sender, new BrokerMessage { Type = MessageType.AgentToBroker_StatusUpdate, SourceId = agentId, Payload = JsonConvert.SerializeObject(statusPayload) });

            }
            catch (JsonException jsonEx)
            {
                _logger.Error($"Failed to parse AgentHello payload from {sender.ClientId}: {jsonEx.Message}", jsonEx);
                sender.Dispose();
            }
            catch (Exception ex)
            {
                 _logger.Error($"Error handling AgentHello from {sender.ClientId}: {ex.Message}", ex);
                 sender.Dispose();
            }
        }


        private void ForwardAgentResultToUi(ClientState agentClient, BrokerMessage agentResultMessage)
        {
            // 이 결과는 특정 UI의 요청에 대한 응답일 수 있으므로, CorrelationId 등을 활용
            // 여기서는 간단히 모든 UI 또는 특정 UI에 브로드캐스트
            // agentResultMessage.SourceId 는 AgentId임.
            // agentResultMessage.TargetId 는 Broker가 설정한 원래 UI의 client ID (ClientState.ClientId)가 될 수 있음
            // 또는 CorrelationId로 매칭
            
            // UI가 보낸 명령의 CorrelationId를 Agent가 결과에 포함시켜 보냈다고 가정.
            // 그 CorrelationId를 사용하여 특정 UI에게만 전달하거나, 모든 UI에 브로드캐스트.
            // 여기서는 모든 UI에 브로드캐스트 하는 예시 (메시지 타입을 BrokerToUi_ForwardAgentResult 로 변경)
            var uiMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_ForwardAgentResult,
                SourceId = agentResultMessage.SourceId, // 결과를 보낸 Agent
                CorrelationId = agentResultMessage.CorrelationId,
                Payload = agentResultMessage.Payload // Agent가 보낸 결과 페이로드 그대로 전달
            };

            foreach (var uiClient in _uiClients.Values)
            {
                uiClient.SendMessageAsync(uiMessage).ConfigureAwait(false);
            }
             _logger.Info($"Forwarded command result from Agent {agentClient.ClientId} to UIs. CorrId: {uiMessage.CorrelationId}");
        }

        private void BroadcastAgentStatusToUis(ClientState agentClient, BrokerMessage agentStatusMessage)
        {
            // 모든 UI 클라이언트에게 Agent의 현재 상태 브로드캐스트
            var uiMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_BroadcastAgentStatus,
                SourceId = agentClient.ClientId, // 상태를 보고한 Agent
                Payload = agentStatusMessage.Payload // AgentStatusUpdatePayload JSON
            };
            foreach (var uiClientState in _uiClients.Values)
            {
                uiClientState.SendMessageAsync(uiMessage).ConfigureAwait(false);
            }
            _logger.Debug($"Broadcasted status from Agent {agentClient.ClientId} to {_uiClients.Count} UIs.");
        }

        private void RelayControlCommandToAgent(ClientState uiClient, BrokerMessage uiCommandMessage)
        {
            try
            {
                var controlPayload = JsonConvert.DeserializeObject<UiControlAgentPayload>(uiCommandMessage.Payload);
                if (controlPayload == null || string.IsNullOrWhiteSpace(controlPayload.TargetAgentIdProvidedByApp))
                {
                    _logger.Warn($"Invalid UiRequest_ControlAgent payload from UI {uiClient.ClientId}.");
                    // UI에게 오류 응답 보낼 수 있음
                    return;
                }

                string targetAgentAppId = controlPayload.TargetAgentIdProvidedByApp;
                BrokerMessage agentCommand = null;

                if (controlPayload.ControlType == "Direct")
                {
                    if (_agentClients.TryGetValue(targetAgentAppId, out var directAgentClientState))
                    {
                        var execPayload = new BrokerExecuteControlPayload
                        {
                            ActionToPerform = controlPayload.ControlAction,
                            Parameters = controlPayload.OriginalParameters,
                            IsGatewayRelay = false
                        };
                        agentCommand = new BrokerMessage
                        {
                            Type = MessageType.BrokerToAgent_ExecuteControl,
                            TargetId = targetAgentAppId, // 최종 타겟 Agent
                            SourceId = _logger.GetType().Name, // Broker가 보냄
                            CorrelationId = uiCommandMessage.CorrelationId,
                            Payload = JsonConvert.SerializeObject(execPayload)
                        };
                        directAgentClientState.SendMessageAsync(agentCommand).ConfigureAwait(false);
                        _logger.Info($"Relayed command '{controlPayload.ControlAction}' directly to Agent {targetAgentAppId} for UI {uiClient.ClientId}. CorrId: {uiCommandMessage.CorrelationId}");
                    }
                    else
                    {
                        _logger.Warn($"Target Agent {targetAgentAppId} for direct control not found or not connected. UI: {uiClient.ClientId}");
                        // UI에게 실패 알림
                        var failMsg = new BrokerMessage { Type = MessageType.BrokerToUi_ForwardAgentResult, CorrelationId = uiCommandMessage.CorrelationId, SourceId=targetAgentAppId, Payload = JsonConvert.SerializeObject(new AgentCommandResultPayload { Success = false, Message = $"Agent {targetAgentAppId} not connected."}) };
                        uiClient.SendMessageAsync(failMsg).ConfigureAwait(false);
                    }
                }
                else if (controlPayload.ControlType == "Gatewayed")
                {
                    if (string.IsNullOrWhiteSpace(controlPayload.GatewayAgentIpAddress) || !controlPayload.GatewayAgentPort.HasValue)
                    {
                        _logger.Error($"Gateway IP/Port not specified for Gatewayed control to {targetAgentAppId}. UI: {uiClient.ClientId}");
                        return;
                    }
                    
                    // Gateway Agent ID 찾기 (DB 설정에 따라 GatewayAgentIpAddress로 찾아야 할 수도 있으나, 여기서는 Gateway도 AgentIdProvidedByApp 으로 식별한다고 가정)
                    // UI가 Gateway의 AgentIdProvidedByApp도 함께 보내줘야 함. 여기서는 일단 IP로 찾지는 않음.
                    // 임시로, Gateway Agent도 _agentClients에 등록되어 있다고 가정하고, UI가 Gateway의 AgentIdProvidedByApp를 알아서 보내준다고 가정.
                    // 실제로는 UI가 DB에서 GatewayAgent의 AgentIdProvidedByApp를 조회해서 UiControlAgentPayload에 포함시켜야 함.
                    // 여기서는 controlPayload.GatewayAgentIpAddress가 사실상 GatewayAgent의 AgentIdProvidedByApp라고 가정. (단순화)

                    string gatewayAgentAppId = controlPayload.GatewayAgentIpAddress; // 이 부분이 UI에서 Gateway의 AgentIdProvidedByApp를 보내줘야 함.

                    if (_agentClients.TryGetValue(gatewayAgentAppId, out var gatewayAgentClientState))
                    {
                        var execPayloadForGateway = new BrokerExecuteControlPayload
                        {
                            ActionToPerform = controlPayload.ControlAction,
                            Parameters = controlPayload.OriginalParameters,
                            IsGatewayRelay = true,
                            FinalTargetAgentIp = controlPayload.PrimaryIpAddress, // 최종 Agent의 IP
                            FinalTargetAgentPort = controlPayload.PrimaryPort       // 최종 Agent의 포트
                        };
                        agentCommand = new BrokerMessage
                        {
                            Type = MessageType.BrokerToAgent_ExecuteControl,
                            TargetId = gatewayAgentAppId, // Gateway Agent에게 보냄
                            SourceId = _logger.GetType().Name, // Broker가 보냄
                            CorrelationId = uiCommandMessage.CorrelationId,
                            Payload = JsonConvert.SerializeObject(execPayloadForGateway)
                        };
                        gatewayAgentClientState.SendMessageAsync(agentCommand).ConfigureAwait(false);
                         _logger.Info($"Relayed command '{controlPayload.ControlAction}' to Gateway Agent {gatewayAgentAppId} (for final target {targetAgentAppId}) for UI {uiClient.ClientId}. CorrId: {uiCommandMessage.CorrelationId}");
                    }
                    else
                    {
                        _logger.Warn($"Gateway Agent {gatewayAgentAppId} for relay not found or not connected. UI: {uiClient.ClientId}");
                        // UI에게 실패 알림
                         var failMsg = new BrokerMessage { Type = MessageType.BrokerToUi_ForwardAgentResult, CorrelationId = uiCommandMessage.CorrelationId, SourceId=targetAgentAppId, Payload = JsonConvert.SerializeObject(new AgentCommandResultPayload { Success = false, Message = $"Gateway Agent {gatewayAgentAppId} not connected."}) };
                        uiClient.SendMessageAsync(failMsg).ConfigureAwait(false);
                    }
                }
                else
                {
                     _logger.Warn($"Unknown ControlType '{controlPayload.ControlType}' from UI {uiClient.ClientId}");
                }
            }
            catch (JsonException jsonEx)
            {
                _logger.Error($"Failed to parse UiRequest_ControlAgent payload from UI {uiClient.ClientId}: {jsonEx.Message}", jsonEx);
            }
            catch (Exception ex)
            {
                 _logger.Error($"Error relaying control command from UI {uiClient.ClientId}: {ex.Message}", ex);
            }
        }

        private void SendBrokerStatusToUi(ClientState uiClient)
        {
            var statusPayload = new BrokerStatusPayload
            {
                ServerStartTime = BrokerCore.ServerStartTime,
                UptimeString = (DateTime.UtcNow - BrokerCore.ServerStartTime).ToString(@"d\.hh\:mm\:ss"),
                ConnectedUiCount = _uiClients.Count,
                ConnectedAgentCount = _agentClients.Count(ac => ac.Value.Type == ClientType.AgentClient && ac.Value.TcpClient.Connected),
                RecentLogs = _logger.GetRecentLogs(50), // 최근 50개 로그
                BrokerVersion = BrokerCore.BrokerVersion
            };
            var statusMessage = new BrokerMessage
            {
                Type = MessageType.BrokerToUi_SendBrokerStatus,
                Payload = JsonConvert.SerializeObject(statusPayload)
            };
            uiClient.SendMessageAsync(statusMessage).ConfigureAwait(false);
            _logger.Info($"Sent broker status to UI {uiClient.ClientId}");
        }

        private void HandlePing(ClientState sender, BrokerMessage pingMessage)
        {
            var pongMessage = new BrokerMessage { Type = MessageType.Pong, CorrelationId = pingMessage.CorrelationId, TargetId = sender.ClientId };
            sender.SendMessageAsync(pongMessage).ConfigureAwait(false);
            _logger.Debug($"Sent Pong to {sender.Type} {sender.ClientId}");
        }


        private void HandleClientDisconnect(ClientState clientState)
        {
            _logger.Info($"Handling disconnect for client: {clientState.ClientId} ({clientState.Type})");
            if (clientState.Type == ClientType.UiClient)
            {
                _uiClients.TryRemove(clientState.ClientId, out _);
                _logger.Info($"UI Client {clientState.ClientId} removed. Total UIs: {_uiClients.Count}");
            }
            else if (clientState.Type == ClientType.AgentClient)
            {
                _agentClients.TryRemove(clientState.ClientId, out _); // AgentIdProvidedByApp를 키로 사용
                _logger.Info($"Agent Client {clientState.ClientId} removed. Total Agents: {_agentClients.Count}");
                
                // 모든 UI에게 해당 Agent 연결 끊김 알림
                var disconnectNotification = new BrokerMessage
                {
                    Type = MessageType.BrokerToUi_BroadcastAgentStatus, // 상태 업데이트 메시지 재활용 가능
                    SourceId = clientState.ClientId,
                    Payload = JsonConvert.SerializeObject(new AgentStatusUpdatePayload { CurrentMonitorStatus = "Offline (Disconnected)"}) // 예시
                };
                foreach (var ui in _uiClients.Values)
                {
                    ui.SendMessageAsync(disconnectNotification).ConfigureAwait(false);
                }
            }
            // ClientState.Dispose()는 ClientState 내부의 ReceiveLoopAsync finally에서 호출됨
        }
        
        public void Stop()
        {
            _logger.Info("Broker Core Service stopping...");
            _serverCts?.Cancel(); // 모든 AcceptLoop 및 ClientState의 ReceiveLoop 종료 요청

            _uiListener?.Stop();
            _agentListener?.Stop();

            // 모든 클라이언트 연결 종료
            _logger.Info("Closing all UI client connections...");
            foreach (var uiClient in _uiClients.Values)
            {
                uiClient.Dispose();
            }
            _uiClients.Clear();

            _logger.Info("Closing all Agent client connections...");
            foreach (var agentClient in _agentClients.Values)
            {
                agentClient.Dispose();
            }
            _agentClients.Clear();
            
            _serverCts?.Dispose();
            _logger.Info("Broker Core Service stopped.");
        }

        public void Dispose()
        {
            Stop();
        }
    }
}
5. Program.cs (메인 진입점)

C#

// MGSPBrokerService/Program.cs
using System;
using System.Reflection;
using System.Threading;
using MGSPBrokerService.Services;

namespace MGSPBrokerService
{
    class Program
    {
        private static BrokerCore _brokerCore;
        private static ManualResetEvent _shutdownEvent = new ManualResetEvent(false);
        private static ILoggingService _logger;

        static void Main(string[] args)
        {
            _logger = new BrokerLoggingService(); // 로거 인스턴스 생성

            // 버전 정보 설정
            try
            {
                var version = Assembly.GetExecutingAssembly().GetName().Version;
                BrokerCore.BrokerVersion = $"{version.Major}.{version.Minor}.{version.Build}.{version.Revision}";
            }
            catch { BrokerCore.BrokerVersion = "N/A (Version Error)"; }

            Console.Title = $"MGSP Broker Service - v{BrokerCore.BrokerVersion}";
            _logger.Info($"MGSP Broker Service v{BrokerCore.BrokerVersion} starting up...");

            // 종료 이벤트 핸들러 등록
            Console.CancelKeyPress += (sender, e) => { e.Cancel = true; _logger.Info("Ctrl+C detected. Shutting down..."); InitiateShutdown(); };
            AppDomain.CurrentDomain.ProcessExit += (sender, e) => { _logger.Info("ProcessExit detected. Ensuring shutdown..."); InitiateShutdown(); };

            try
            {
                // 설정 파일에서 포트 번호 등을 읽어올 수 있으나, 여기서는 하드코딩
                int uiPort = 9001;
                int agentPort = 9002;
                
                _logger.Info($"Configuring Broker to listen for UIs on port {uiPort} and Agents on port {agentPort}.");
                _brokerCore = new BrokerCore(_logger, uiPort, agentPort);
                _brokerCore.Start();

                _logger.Info("Broker Service is now running. Press Ctrl+C to stop.");
                _shutdownEvent.WaitOne(); // 종료 시그널 대기
            }
            catch (Exception ex)
            {
                _logger.Fatal("A critical error occurred during Broker startup or operation.", ex);
                Console.WriteLine("A fatal error occurred. Check logs. Press any key to exit.");
                Console.ReadKey();
            }
            finally
            {
                _logger.Info("Broker Service Main finally block. Cleaning up...");
                Cleanup();
            }
            _logger.Info("Broker Service has shut down. Press any key to close window.");
            Console.ReadKey();
        }

        private static void InitiateShutdown()
        {
            // 이미 종료 중이면 아무것도 안 함
            if (_shutdownEvent.WaitOne(0)) return; 

            _logger.Info("Shutdown initiated...");
            _brokerCore?.Stop(); // BrokerCore의 Stop 메서드 호출
            _shutdownEvent.Set(); // Main 스레드 종료 허용
        }

        private static void Cleanup()
        {
             _brokerCore?.Dispose(); // BrokerCore의 Dispose 메서드 (Stop 호출 포함)
            _logger.Info("Cleanup finished.");
            // 필요시 다른 리소스 정리
        }
    }
}
MGSPBrokerService 실행 방법:

위 코드들을 사용하여 MGSPBrokerService 프로젝트를 빌드합니다.
Newtonsoft.Json NuGet 패키지가 설치되어 있는지 확인합니다.
빌드된 MGSPBrokerService.exe를 실행합니다.
콘솔 창에 로그가 출력되며, UI 연결 포트(기본 9001)와 Agent 연결 포트(기본 9002)에서 연결을 기다립니다.
방화벽에서 이 포트들이 열려 있는지 확인해야 다른 PC의 UI나 Agent가 접속할 수 있습니다.
이것으로 중계 프로그램(MGSPBrokerService)의 기본 골격이 완성되었습니다. 이 프로그램은 UI로부터 Agent 제어 명령을 받아 라우팅하고, Agent로부터 상태를 받아 UI로 브로드캐스트하며, 자체적인 간단한 로그를 콘솔과 내부 메모리에 기록합니다.