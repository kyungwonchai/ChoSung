import os
import re
import tkinter as tk
from tkinter import filedialog, messagebox
import xml.etree.ElementTree as ET
from datetime import datetime
import logging

# --- 로깅 설정 ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')

def sanitize_name(name):
    """파일 및 폴더명으로 사용할 수 없는 문자를 제거하거나 대체합니다."""
    # 제네릭 <T> 같은 형태를 _T_ 로 변경
    name = re.sub(r'<', '_', name)
    name = re.sub(r'>', '_', name)
    # 윈도우 파일 시스템에서 허용되지 않는 문자 제거
    return re.sub(r'[\\/*?:"<>|]', '', name).strip()

def find_matching_brace(code_str, start_pos):
    """주어진 코드 문자열에서 시작 괄호에 대응하는 닫는 괄호의 위치를 찾습니다."""
    if code_str[start_pos] != '{':
        return -1

    brace_count = 1
    for i in range(start_pos + 1, len(code_str)):
        if code_str[i] == '{':
            brace_count += 1
        elif code_str[i] == '}':
            brace_count -= 1
        
        if brace_count == 0:
            return i
    return -1 # 짝을 찾지 못함

def clean_code(code):
    """코드에서 주석과 빈 줄을 제거합니다."""
    # 여러 줄 주석 제거 (/* ... */)
    code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
    # 한 줄 주석 제거 (// ...)
    code = re.sub(r'//.*?$', '', code, flags=re.MULTILINE)
    # 빈 줄 제거
    lines = [line.strip() for line in code.splitlines() if line.strip()]
    return '\n'.join(lines)

def get_cs_files_from_solution(sln_path):
    """솔루션(.sln) 파일을 분석하여 포함된 모든 C# 프로젝트(.csproj)의 소스 파일(.cs) 목록을 반환합니다."""
    cs_files = []
    sln_dir = os.path.dirname(sln_path)
    
    try:
        with open(sln_path, 'r', encoding='utf-8-sig') as f:
            content = f.read()

        # .csproj 파일 경로 찾기
        project_pattern = re.compile(r'Project\("\{.*?}"\) = ".*?", "(.*?\.csproj)"', re.IGNORECASE)
        project_paths = project_pattern.findall(content)

        for proj_path in project_paths:
            full_proj_path = os.path.join(sln_dir, proj_path.replace('\\', os.sep))
            
            if not os.path.exists(full_proj_path):
                logging.warning(f"프로젝트 파일을 찾을 수 없습니다: {full_proj_path}")
                continue
            
            proj_dir = os.path.dirname(full_proj_path)
            
            # .csproj 파일(XML) 파싱하여 .cs 파일 찾기
            tree = ET.parse(full_proj_path)
            root = tree.getroot()
            
            # XML 네임스페이스 처리
            ns = {'ms': root.tag.split('}')[0][1:]} if '}' in root.tag else {}
            compile_items = root.findall('.//ms:Compile', ns) if ns else root.findall('.//Compile')

            for item in compile_items:
                include_path = item.get('Include')
                if include_path and include_path.endswith('.cs'):
                    full_cs_path = os.path.join(proj_dir, include_path.replace('\\', os.sep))
                    if os.path.exists(full_cs_path):
                        cs_files.append(os.path.normpath(full_cs_path))
    except Exception as e:
        logging.error(f"솔루션 파일을 처리하는 중 오류 발생: {e}")
        messagebox.showerror("오류", f"솔루션 파일을 처리하는 중 오류가 발생했습니다.\n{e}")

    return list(set(cs_files)) # 중복 제거

def process_solution():
    """메인 처리 함수: 솔루션 선택부터 함수 추출 및 파일 생성까지 전체 과정을 관장합니다."""
    root = tk.Tk()
    root.withdraw() # 메인 윈도우 숨기기

    sln_path = filedialog.askopenfilename(
        title="분석할 C# 솔루션(.sln) 파일을 선택하세요",
        filetypes=(("Solution files", "*.sln"), ("All files", "*.*"))
    )

    if not sln_path:
        logging.info("파일 선택이 취소되었습니다.")
        return

    logging.info(f"선택된 솔루션: {sln_path}")

    # --- 출력 폴더 설정 ---
    sln_name = os.path.splitext(os.path.basename(sln_path))[0]
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    output_base_dir = os.path.join(os.path.dirname(sln_path), f"{sln_name}_Processed_{timestamp}")
    
    try:
        os.makedirs(output_base_dir, exist_ok=True)
        logging.info(f"출력 폴더 생성: {output_base_dir}")
    except OSError as e:
        logging.error(f"출력 폴더를 생성할 수 없습니다: {e}")
        messagebox.showerror("오류", f"출력 폴더를 생성할 수 없습니다.\n{e}")
        return

    # --- C# 파일 목록 가져오기 ---
    cs_files = get_cs_files_from_solution(sln_path)
    if not cs_files:
        logging.warning("솔루션에서 처리할 C# 파일을 찾지 못했습니다.")
        messagebox.showwarning("결과 없음", "솔루션에서 처리할 C# 파일을 찾지 못했습니다.")
        return
        
    logging.info(f"총 {len(cs_files)}개의 C# 파일을 분석합니다.")

    # --- 각 C# 파일 처리 ---
    total_functions_extracted = 0
    for file_path in cs_files:
        try:
            with open(file_path, 'r', encoding='utf-8-sig') as f:
                original_code = f.read()

            clean_code_str = clean_code(original_code)
            
            # 네임스페이스 추출
            namespace_match = re.search(r'namespace\s+([^{]+)', clean_code_str)
            current_namespace = namespace_match.group(1).strip() if namespace_match else "NoNamespace"

            # 클래스/인터페이스/구조체 블록 추출
            # 정규식: (class|interface|struct) 식별자 { ... }
            class_pattern = re.compile(r'(?:public|internal|private|protected|static|sealed|abstract)\s+.*?(class|interface|struct)\s+([\w\d_<>,\s]+?)\s*[:\w\d\s,<>]*\s*\{')
            
            for class_match in class_pattern.finditer(clean_code_str):
                class_start_brace_pos = class_match.end() -1
                class_end_brace_pos = find_matching_brace(clean_code_str, class_start_brace_pos)
                if class_end_brace_pos == -1:
                    continue
                
                class_name_raw = class_match.group(2).strip()
                # 제네릭 정의 부분 제거 (예: MyClass<T> -> MyClass)
                class_name = re.sub(r'<.*?>', '', class_name_raw).strip()
                class_body = clean_code_str[class_start_brace_pos + 1 : class_end_brace_pos]

                # 함수(메서드, 생성자) 추출
                # 정규식: (수식어들) 타입 식별자(...) { ... }
                # 생성자도 포함 (타입 부분이 클래스명과 동일)
                method_pattern = re.compile(
                    # 접근제한자, 반환타입 등 (그룹1)
                    r'((?:public|private|protected|internal|static|virtual|override|async|unsafe|extern|new)\s*.*?)??'
                    # 함수명 (그룹2) - 클래스명과 같을 수도 있음 (생성자)
                    r'([\w\d_~]+)\s*'
                    # 제네릭 및 파라미터 (그룹3)
                    r'(<.*?>)?\s*\((.*?)\)\s*(?:where\s+.*?)?\s*\{'
                )

                for method_match in method_pattern.finditer(class_body):
                    method_start_brace_pos = method_match.end() - 1
                    method_end_brace_pos = find_matching_brace(class_body, method_start_brace_pos)
                    if method_end_brace_pos == -1:
                        continue
                    
                    method_name_raw = method_match.group(2).strip()
                    # 소멸자(~) 처리
                    method_name = method_name_raw.replace('~', 'Finalizer_')
                    
                    # 생성자인 경우 이름을 'Constructor'로 명시
                    if method_name == class_name:
                        method_name = "Constructor"

                    method_body_content = class_body[method_start_brace_pos + 1 : method_end_brace_pos].strip()

                    # --- 파일 및 폴더 생성 ---
                    s_ns = sanitize_name(current_namespace)
                    s_class = sanitize_name(class_name)
                    s_method = sanitize_name(method_name)
                    
                    # 파라미터 개수나 타입을 이름에 추가하여 오버로딩 구분
                    params = method_match.group(4).strip()
                    if params:
                        param_count = len(params.split(','))
                        s_method += f"_Overload{param_count}"
                    
                    target_dir_name = f"{s_ns}_{s_class}_{s_method}"
                    target_dir = os.path.join(output_base_dir, target_dir_name)
                    os.makedirs(target_dir, exist_ok=True)
                    
                    # 속성 파일 작성
                    prop_file_path = os.path.join(target_dir, "속성.txt")
                    with open(prop_file_path, 'w', encoding='utf-8') as pf:
                        pf.write(f"네임스페이스: {current_namespace}\n")
                        pf.write(f"클래스: {class_name_raw}\n")
                        pf.write(f"함수명: {method_name_raw}\n")
                        
                    # 함수 코드 파일 작성
                    func_file_path = os.path.join(target_dir, f"{s_method}.cs")
                    with open(func_file_path, 'w', encoding='utf-8') as ff:
                        ff.write(method_body_content)
                    
                    total_functions_extracted += 1

        except Exception as e:
            logging.error(f"{file_path} 파일을 처리하는 중 오류 발생: {e}")
            continue

    logging.info(f"작업 완료. 총 {total_functions_extracted}개의 함수를 추출했습니다.")
    messagebox.showinfo("완료", f"분석이 완료되었습니다.\n총 {total_functions_extracted}개의 함수를 추출하여 아래 폴더에 저장했습니다.\n\n{output_base_dir}")

if __name__ == "__main__":
    process_solution()