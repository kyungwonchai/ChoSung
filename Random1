 통해 삭제할 파일의 패턴을 찾아내도록 수정합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using Microsoft.ML;
using Microsoft.ML.Data;

namespace SMDFileCleaner
{
    public class MLModelBuilder
    {
        private readonly MLContext _mlContext;
        private ITransformer _model;
        private List<FileRecord> _fileDataList;

        public MLModelBuilder()
        {
            _mlContext = new MLContext();
            _fileDataList = new List<FileRecord>();
        }

        public void TrainModel(List<FileRecord> fileData)
        {
            try
            {
                if (fileData == null || fileData.Count < 10) // 최소 샘플 수 확인
                {
                    throw new InvalidOperationException("Not enough samples to train the model. Minimum required samples: 10");
                }

                _fileDataList = fileData;
                var data = _mlContext.Data.LoadFromEnumerable(fileData);

                var pipeline = _mlContext.Transforms.Concatenate("Features", nameof(FileRecord.Size))
                    .Append(_mlContext.Transforms.Conversion.ConvertType("Features", outputKind: DataKind.Single))
                    .Append(_mlContext.Clustering.Trainers.KMeans("Features", numberOfClusters: 2));

                _model = pipeline.Fit(data);
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to train model: " + ex.Message, ex);
            }
        }

        public bool Predict(FileInfo fileInfo)
        {
            try
            {
                if (_model == null)
                {
                    throw new InvalidOperationException("Model is not trained.");
                }

                var fileData = new FileRecord
                {
                    Size = (float)fileInfo.Length // float 형식으로 변환
                };

                var predictionEngine = _mlContext.Model.CreatePredictionEngine<FileRecord, FilePrediction>(_model);
                var prediction = predictionEngine.Predict(fileData);

                return prediction.PredictedClusterId == 1; // Cluster 1 is considered as regularly generated files
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to predict file classification: " + ex.Message, ex);
            }
        }

        public string GetCurrentPatterns()
        {
            try
            {
                var regexPatterns = GetRegexPatterns();
                if (regexPatterns.Count == 0)
                {
                    return "No patterns found.";
                }

                return string.Join(", ", regexPatterns.Select(p => p.ToString()));
            }
            catch (Exception ex)
            {
                throw new ApplicationException("Failed to get current patterns: " + ex.Message, ex);
            }
        }

        public List<Regex> GetRegexPatterns()
        {
            var patterns = new List<Regex>();
            var regexes = new List<Regex>
            {
                new Regex(@"(\d{4})-(\d{2})-(\d{2})"), // 날짜 패턴 (예: 2022-01-01)
                new Regex(@"IMG_(\d{8})"), // 이미지 파일 패턴 (예: IMG_20220101)
                // 필요한 다른 정규식 패턴 추가
            };

            foreach (var regex in regexes)
            {
                var matches = _fileDataList.Where(f => regex.IsMatch(f.FilePath)).ToList();
                if (matches.Count > 0)
                {
                    patterns.Add(regex);
                }
            }

            return patterns;
        }
    }

    public class FilePrediction
    {
        [ColumnName("PredictedLabel")]
        public uint PredictedClusterId { get; set; }
    }
}
MainWindow.xaml.cs 수정
학습한 패턴을 UI에 표시하고, 로그에 시간 및 상세 설명을 추가합니다.

csharp
코드 복사
private async void btnStart_Click(object sender, RoutedEventArgs e)
{
    string folderPath = txtFolderPath.Text;
    string fileExtension = cmbFileExtension.Text;
    string driveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\";

    if (string.IsNullOrEmpty(folderPath) || folderPath == "폴더 경로 입력" ||
        string.IsNullOrEmpty(fileExtension))
    {
        System.Windows.Forms.MessageBox.Show("모든 입력값을 제공해주세요.");
        return;
    }

    try
    {
        Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 중..."; });

        _trainingData = await Task.Run(() => CollectInitialFileData(folderPath, fileExtension));
        if (_trainingData.Count < MinimumSampleSize)
        {
            System.Windows.Forms.MessageBox.Show($"학습 모델을 훈련시키기에 샘플이 충분하지 않습니다. 최소 샘플 수: {MinimumSampleSize}");
            Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: 샘플 부족"; });
            return;
        }

        Dispatcher.Invoke(() =>
        {
            dataGridTrainingData.ItemsSource = _trainingData;
            _mlModelBuilder.TrainModel(_trainingData);
            txtTrainingStatus.Text = "학습 완료";
            txtCurrentPatterns.Text = _mlModelBuilder.GetCurrentPatterns();
        });

        await Task.Run(() => MonitorAndDisplayFilesToDelete(folderPath, fileExtension, driveName));
    }
    catch (Exception ex)
    {
        LogError("모델 훈련 실패: " + ex.Message);
        Dispatcher.Invoke(() => { txtTrainingStatus.Text = "학습 실패: " + ex.Message; });
    }
}

private void LogRecentActivity(string message)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: {message}";
        lstRecentLogs.Items.Add(logMessage);
        if (lstRecentLogs.Items.Count > 200)
        {
            lstRecentLogs.Items.RemoveAt(0);
        }
    });
}

private void LogDeletionActivity(string message)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: {message}";
        lstDeletionLogs.Items.Add(logMessage);
        if (lstDeletionLogs.Items.Count > 200)
        {
            lstDeletionLogs.Items.RemoveAt(0);
        }
    });
}

private void UpdateFolderStatistics(long totalSize, string folderPath)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: 폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB";
        lstRecentLogs.Items.Add(logMessage);
        if (lstRecentLogs.Items.Count > 200)
        {
            lstRecentLogs.Items.RemoveAt(0);
        }
    });
}

private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
{
    while (true)
    {
        try
        {
            long freeSpace = await Task.Run(() => _fileCleaner.GetDriveFreeSpace(driveName));
            List<FileInfo> filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension));

            Dispatcher.Invoke(() => DisplayFilesToDelete(filesToDelete));

            //await _fileCleaner.DeleteFilesAsync(filesToDelete); // 실제 삭제 코드 (주석 처리)

            await Task.Run(() => _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension));
            await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
        }
        catch (Exception ex)
        {
            LogError("모니터링 중 오류 발생: " + ex.Message);
        }
    }
}
이제 학습한 패턴을 정규식으로 UI에 표시하고, 로그에 시간과 상세 설명을 추가합니다. LogRecentActivity, LogDeletionA