, 알겠습니다. 여러 오류가 동시에 발생하여 혼란스러우실 것 같습니다. 특히 "No connection string named 'LockerDbConnection' could be found..." 오류가 로그 로딩 시에만 발생한다면, LogViewModel이 LockerDbContext를 생성하는 시점이나 방식에 미묘한 문제가 있을 수 있습니다. 다른 기능에서는 연결 문자열을 잘 찾는 것처럼 보이기 때문이죠.

또한, 101, 143줄 오류는 MainViewModel의 비동기 데이터 로딩(LoadMasterDataAsync) 및 저장(SaveChangesAsync)과 관련된 것으로 보이며, 이는 불안정한 DbContext 상태 또는 리소스 경쟁과 연관될 수 있습니다.

가장 유력한 해결 방법:

LockerDbContext가 생성될 때마다 App.config에서 연결 문자열을 암묵적으로 찾도록 하는 대신, 생성자에서 명시적으로 ConfigurationManager를 사용하여 연결 문자열을 읽어오도록 수정합니다. 이렇게 하면 어떤 ViewModel이 DbContext를 생성하든 동일하고 안정적인 방식으로 연결 문자열을 사용하게 되어, 특정 ViewModel에서만 연결 문자열을 찾지 못하는 문제를 해결할 수 있습니다. 이 방식이 DbContext 상태 안정화에도 도움이 되어 다른 오류들도 함께 해결될 수 있습니다.

수정해야 할 파일 목록:

Data/LockerDbContext.cs (생성자 수정)
ViewModels/MainViewModel.cs (최신 버전 확인용)
ViewModels/LogViewModel.cs (최신 버전 확인용)
아래에 이 3개 파일의 수정된 전체 코드를 작성합니다.

1. Data/LockerDbContext.cs (수정)

생성자에서 ConfigurationManager를 사용하여 연결 문자열을 직접 읽고 base() 생성자에 전달하도록 수정합니다.
using System.Configuration;을 추가합니다.
C#

// 필요한 네임스페이스
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration; // ConfigurationManager 사용 위해 추가
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json; // Newtonsoft.Json 사용
using System.Diagnostics;

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스 (연결 문자열 명시적 로드)
    /// </summary>
    public class LockerDbContext : DbContext
    {
        // --- DbSets (이전과 동일) ---
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }

        // 연결 문자열 이름 상수화 (오타 방지)
        private const string ConnectionStringName = "LockerDbConnection";

        /// <summary>
        /// 기본 생성자. App.config에서 연결 문자열을 명시적으로 읽어 사용합니다.
        /// </summary>
        public LockerDbContext() : base(GetConnectionString()) // 수정: base() 호출 변경
        {
            // Database.SetInitializer<LockerDbContext>(null);
        }

        /// <summary>
        /// App.config에서 연결 문자열을 읽어오는 정적 메서드
        /// </summary>
        /// <returns>연결 문자열</returns>
        /// <exception cref="ConfigurationErrorsException">연결 문자열을 찾지 못한 경우</exception>
        private static string GetConnectionString()
        {
            // ConfigurationManager를 사용하여 연결 문자열 가져오기
            var connectionStringSetting = ConfigurationManager.ConnectionStrings[ConnectionStringName];

            if (connectionStringSetting == null || string.IsNullOrWhiteSpace(connectionStringSetting.ConnectionString))
            {
                // 연결 문자열을 찾지 못하면 예외 발생 또는 기본값 반환 등의 처리 필요
                throw new ConfigurationErrorsException($"App.config 파일에서 '{ConnectionStringName}' 이름의 연결 문자열을 찾을 수 없거나 비어 있습니다.");
            }
            Debug.WriteLine($"ConnectionString '{ConnectionStringName}' loaded successfully.");
            return connectionStringSetting.ConnectionString; // 실제 연결 문자열 반환
        }


        /// <summary>
        /// 모델(테이블) 생성 시 추가 구성을 위한 메서드입니다 (Fluent API).
        /// </summary>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // LockerAssignment Nullable 속성 설정 확인
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();

            base.OnModelCreating(modelBuilder);
        }

        /// <summary>
        /// 엔티티 저장 전 유효성 검사를 재정의합니다.
        /// </summary>
        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified))
            {
                var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList();
                if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류를 무시합니다."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } }
            }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (이전과 동일)

        public override int SaveChanges()
        {
            List<AuditLog> auditEntries = null;
            #region Logging Enable/Disable
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
            #endregion
            try { return base.SaveChanges(); }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
        }

        public override async Task<int> SaveChangesAsync()
        {
             List<AuditLog> auditEntries = null;
            #region Logging Enable/Disable
            try { auditEntries = CreateAuditEntries(); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }
            if (auditEntries != null && auditEntries.Any()) { try { this.AuditLogs.AddRange(auditEntries); } catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); } }
            #endregion
            try { return await base.SaveChangesAsync(); }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
        }

        private List<AuditLog> CreateAuditEntries() { string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser"; var auditEntries = new List<AuditLog>(); var changedEntries = ChangeTracker.Entries().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted).ToList(); var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None }; foreach (var entry in changedEntries) { if (entry.Entity is AuditLog) continue; var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() }; try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; } var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>(); if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } } else if (entry.State == EntityState.Modified) { foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (affectedColumns.Any()) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"!!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else continue; } auditEntries.Add(auditEntry); } UpdateLockerAssignmentTimestamps(changedEntries); return auditEntries; }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; } }

        #endregion

        #region Error Logging Helpers (이전과 동일)
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.Message}"); var innerEx = dbEx.InnerException; while (innerEx != null) { Debug.WriteLine($"  InnerException: {innerEx.Message}"); innerEx = innerEx.InnerException; } foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
2. ViewModels/MainViewModel.cs (최종 확인용)

(이전 최종 버전과 동일 - CancellationToken, 하이라이트 로직, 임시 컨텍스트 로딩 등 포함)

C#

// 필요한 네임스페이스
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using LockerManagementApp.Views;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Linq;
using System.Security;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices;
using System.IO;
using System.Text;
using System.Windows.Threading;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";
        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;
        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;
        public LogViewModel LogVM { get; private set; }
        private readonly CancellationTokenSource _cts = new CancellationTokenSource();
        private bool _disposed = false;
        private object _selectedCellValue;
        private string _selectedCellColumnFieldName;

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set => SetProperty(ref _selectedAssignment, value); }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        public object SelectedCellValue { get => _selectedCellValue; private set => SetProperty(ref _selectedCellValue, value); }
        public string SelectedCellColumnFieldName { get => _selectedCellColumnFieldName; private set => SetProperty(ref _selectedCellColumnFieldName, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        public ICommand OpenMasterDataWindowCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); } catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }
            _lockerAssignments = new ObservableCollection<LockerAssignment>(); _allLockerTypes = new ObservableCollection<LockerType>(); _allFloors = new ObservableCollection<Floor>(); _allZones = new ObservableCollection<Zone>(); _allSubParts = new ObservableCollection<SubPart>(); _allAdministrators = new ObservableCollection<Administrator>();
            LogVM = new LogViewModel();
            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync(), _ => !_disposed); SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync(), CanSaveChangesExecute); AddNewCommand = new RelayCommand(AddNewLocker, _ => !_disposed); DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), CanDeleteExecute); ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, CanClearAssignmentExecute); CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword, _ => !_disposed); RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync(), _ => !_disposed); OpenMasterDataWindowCommand = new RelayCommand(OpenMasterDataWindow, _ => !_disposed);
            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        private bool CanSaveChangesExecute(object parameter) { if (_disposed || _context == null) return false; try { return _context.ChangeTracker.HasChanges(); } catch { return false; } }
        private bool CanDeleteExecute(object parameter) => !_disposed && SelectedAssignment != null;
        private bool CanClearAssignmentExecute(object parameter) => !_disposed && SelectedAssignment != null && SelectedAssignment.IsAssigned;
        private async Task LoadInitialDataAsync() { if (_disposed || _cts.IsCancellationRequested) return; await LoadMasterDataAsync(); if (_disposed || _cts.IsCancellationRequested) return; await LoadAssignmentsAsync(); }
        private async Task LoadAssignmentsAsync() { if (_context == null || _disposed || _cts.IsCancellationRequested) return; StatusBarText = "사물함 목록 로딩 중..."; try { var trackedAssignments = _context.ChangeTracker.Entries<LockerAssignment>().ToList(); if (trackedAssignments.Any()) { foreach (var entry in trackedAssignments) entry.State = EntityState.Detached; } var assignments = await _context.LockerAssignments.OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation).ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨 (await 이후)."); return; } Application.Current.Dispatcher.Invoke(() => { LockerAssignments = new ObservableCollection<LockerAssignment>(assignments); StatusBarText = $"총 {LockerAssignments.Count}개 로드 완료."; (DeleteCommand as RelayCommand)?.RaiseCanExecuteChanged(); (ClearAssignmentCommand as RelayCommand)?.RaiseCanExecuteChanged(); }); } catch (OperationCanceledException) { Debug.WriteLine("LoadAssignmentsAsync 작업 취소됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadAssignmentsAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "사물함 목록 로딩 오류 (컨텍스트 해제됨)."; } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("사물함 목록 로딩", ex); } }
        private async Task LoadMasterDataAsync() { if (_disposed || _cts.IsCancellationRequested) return; StatusBarText = "마스터 데이터(콤보박스용) 로딩 중..."; LockerDbContext tempContext = null; try { using (tempContext = new LockerDbContext()) { var types = await tempContext.LockerTypes.OrderBy(t => t.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var floors = await tempContext.Floors.OrderBy(f => f.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var zones = await tempContext.Zones.OrderBy(z => z.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var subParts = await tempContext.SubParts.OrderBy(p => p.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; var administrators = await tempContext.Administrators.OrderBy(a => a.Name).AsNoTracking().ToListAsync(_cts.Token); if (_cts.IsCancellationRequested || _disposed) return; Application.Current.Dispatcher.Invoke(() => { AllLockerTypes = new ObservableCollection<LockerType>(types); AllFloors = new ObservableCollection<Floor>(floors); AllZones = new ObservableCollection<Zone>(zones); AllSubParts = new ObservableCollection<SubPart>(subParts); AllAdministrators = new ObservableCollection<Administrator>(administrators); if (!_cts.IsCancellationRequested && !_disposed) StatusBarText = "마스터 데이터(콤보박스용) 로드 완료."; }); } } catch (OperationCanceledException) { Debug.WriteLine("LoadMasterDataAsync 작업 취소됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 취소됨."; } catch (ObjectDisposedException) { Debug.WriteLine("LoadMasterDataAsync 실행 중 DbContext Dispose됨."); if (!_disposed) StatusBarText = "마스터 데이터 로딩 오류 (컨텍스트 해제됨)."; } catch (SqlException sqlEx) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩 (DB 오류)", sqlEx); } catch (EntityException entityEx) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩 (EF 오류)", entityEx); } catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) { if (!_cts.IsCancellationRequested && !_disposed) { HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx); MessageBox.Show("데이터 로딩 중 충돌 발생. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션 확인 또는 재시도.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); } } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("마스터 데이터 로딩", ex); } }
        private void CheckMasterPassword(object parameter) { try { string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"]; if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey) 없음.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; } string plainPassword = ConvertToUnsecureString(MasterPasswordInput); if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; } else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키 불일치.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); } catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private void OpenMasterDataWindow(object parameter) { if (!BackupDataToCsv()) { if (MessageBox.Show("데이터 백업 실패. 계속 진행하시겠습니까?", "백업 실패", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.No) return; } try { using (var masterDataVM = new MasterDataViewModel()) { var masterDataWindow = new MasterDataWindow { DataContext = masterDataVM, Owner = Application.Current.MainWindow }; masterDataWindow.ShowDialog(); _ = LoadMasterDataAsync(); _ = LoadAssignmentsAsync(); } } catch (Exception ex) { MessageBox.Show($"마스터 데이터 관리 창 열기 오류:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        #region CRUD 및 기타 메서드
        private async Task SaveChangesAsync() { if (_context == null || _disposed || !CanSaveChangesExecute(null)) return; StatusBarText = "변경 사항 저장 중..."; List<DbEntityEntry> allChangedEntriesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var changedLockerEntries = _context.ChangeTracker.Entries<LockerAssignment>().Where(e => e.State == EntityState.Added || e.State == EntityState.Modified).ToList(); var allItemsToCheck = LockerAssignments.ToList(); var duplicates = allItemsToCheck.GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation }).Where(g => g.Count() > 1).Select(g => g.Key); if (duplicates.Any()) { MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); RollbackChanges(allChangedEntriesForRollback); return; } foreach(var entry in changedLockerEntries) { entry.Entity.Administrator = _currentAdmin; } int changedCount = await _context.SaveChangesAsync(_cts.Token); StatusBarText = $"성공적으로 {changedCount}개 저장됨."; } catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync 작업 취소됨."); StatusBarText = "저장 작업 취소됨."; RollbackChanges(allChangedEntriesForRollback); } catch (DbEntityValidationException vex) { HandleValidationException(vex); RollbackChanges(allChangedEntriesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(allChangedEntriesForRollback); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("저장", ex); RollbackChanges(allChangedEntriesForRollback); } }
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries.ToList()) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity)) LockerAssignments.Remove(addedEntity); break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusBarText = "변경 롤백됨."; }
        private void AddNewLocker(object parameter) { if (_context == null || _disposed) return; var newAssignment = new LockerAssignment { LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함", Floor = AllFloors.FirstOrDefault()?.Name ?? "1", Zone = AllZones.FirstOrDefault()?.Name ?? "A", SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4), Administrator = _currentAdmin, LastUpdated = DateTime.Now }; LockerAssignments.Add(newAssignment); _context.LockerAssignments.Add(newAssignment); SelectedAssignment = newAssignment; StatusBarText = "새 사물함 추가됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        private async Task DeleteSelectedAsync() { if (_context == null || SelectedAssignment == null || _disposed || _cts.IsCancellationRequested) return; if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 삭제?", "확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { StatusBarText = "삭제 중..."; List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); try { var assignmentToDelete = SelectedAssignment; var entry = _context.Entry(assignmentToDelete); if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); } _context.LockerAssignments.Remove(assignmentToDelete); int changedCount = await _context.SaveChangesAsync(_cts.Token); LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null; StatusBarText = $"성공적으로 {changedCount}개 삭제됨."; } catch (OperationCanceledException) { Debug.WriteLine("DeleteSelectedAsync 작업 취소됨."); StatusBarText = "삭제 작업 취소됨."; RollbackChanges(changesForRollback); } catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } catch (Exception ex) { if (!_cts.IsCancellationRequested && !_disposed) HandleGenericException("삭제", ex); RollbackChanges(changesForRollback); await LoadAssignmentsAsync(); } } }
        private void ClearSelectedAssignment(object parameter) { if (_context == null || SelectedAssignment == null || _disposed) return; SelectedAssignment.UserName = null; SelectedAssignment.KnoxId = null; SelectedAssignment.SubPart = null; _context.Entry(SelectedAssignment).State = EntityState.Modified; SelectedAssignment.Administrator = _currentAdmin; StatusBarText = "배정 해제됨. 저장 필요."; (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged(); }
        #endregion

        #region Backup Logic (CSV - 이전과 동일)
        private bool BackupDataToCsv() { string backupDir = @"C:\agent"; string fileName = $"LockerBackup_{DateTime.Now:yyyyMMdd_HHmmss}.csv"; string filePath = Path.Combine(backupDir, fileName); StatusBarText = "데이터 백업 시작..."; try { Directory.CreateDirectory(backupDir); using (var backupContext = new LockerDbContext()) using (var writer = new StreamWriter(filePath, false, Encoding.UTF8)) { WriteTableToCsv<LockerType>(backupContext, writer); WriteTableToCsv<Floor>(backupContext, writer); WriteTableToCsv<Zone>(backupContext, writer); WriteTableToCsv<SubPart>(backupContext, writer); WriteTableToCsv<Administrator>(backupContext, writer); WriteTableToCsv<LockerAssignment>(backupContext, writer); WriteTableToCsv<AuditLog>(backupContext, writer); } StatusBarText = $"데이터 백업 완료: {filePath}"; MessageBox.Show($"데이터가 다음 위치에 백업되었습니다:\n{filePath}", "백업 완료", MessageBoxButton.OK, MessageBoxImage.Information); return true; } catch (Exception ex) { StatusBarText = $"데이터 백업 실패: {ex.Message}"; MessageBox.Show($"데이터 백업 중 오류가 발생했습니다:\n{ex.ToString()}", "백업 오류", MessageBoxButton.OK, MessageBoxImage.Error); return false; } }
        private void WriteTableToCsv<T>(LockerDbContext context, StreamWriter writer) where T : class { var dbSet = context.Set<T>(); var entityType = typeof(T); var properties = entityType.GetProperties().Where(p => p.GetGetMethod().IsVirtual == false).ToList(); writer.WriteLine($"--- Table: {entityType.Name} ---"); writer.WriteLine(string.Join(",", properties.Select(p => EscapeCsvValue(p.Name)))); foreach (var entity in dbSet.AsNoTracking()) { var values = properties.Select(p => EscapeCsvValue(p.GetValue(entity)?.ToString() ?? "")); writer.WriteLine(string.Join(",", values)); } writer.WriteLine(); writer.WriteLine(); }
        private string EscapeCsvValue(string value) { if (string.IsNullOrEmpty(value)) return ""; if (value.Contains(",") || value.Contains("\"") || value.Contains("\r") || value.Contains("\n")) { return $"\"{value.Replace("\"", "\"\"")}\""; } return value; }
        #endregion

        #region Helper Methods (오류 메시지 상세화)
        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 예기치 않은 오류가 발생했습니다:\n\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { Exception innerMostException = dbEx; while (innerMostException.InnerException != null) innerMostException = innerMostException.InnerException; string innerExMsg = innerMostException.Message; var validationErrors = dbEx.Entries.SelectMany(e => e.GetValidationResult().ValidationErrors); string validationErrorMsg = ""; if (validationErrors.Any()) validationErrorMsg = "\n\n유효성 검사 오류:\n" + string.Join("\n", validationErrors.Select(err => $" - {err.PropertyName}: {err.ErrorMessage}")); StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"데이터베이스 작업 중 오류가 발생했습니다:\n{innerExMsg}{validationErrorMsg}\n\n(전체 오류: {dbEx.ToString()})", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private void HandleValidationException(DbEntityValidationException vex) { var errorMessages = vex.EntityValidationErrors.SelectMany(x => x.ValidationErrors).Select(x => $"{x.PropertyName}: {x.ErrorMessage}"); var fullErrorMessage = string.Join("\n", errorMessages); var exceptionMessage = $"데이터 유효성 검사 오류:\n{fullErrorMessage}"; StatusBarText = "데이터 유효성 검사 오류 발생"; MessageBox.Show(exceptionMessage, "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning); Debug.WriteLine($"!!! DbEntityValidationException 발생:\n{exceptionMessage}\n{vex.ToString()}"); }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }
        #endregion

        #region IDisposable 구현
        // private bool disposed = false; // 클래스 멤버 변수로 이동됨
        protected virtual void Dispose(bool disposing) { if (!_disposed) { if (disposing) { Debug.WriteLine("MainViewModel Dispose 시작..."); _cts?.Cancel(); _cts?.Dispose(); _context?.Dispose(); LogVM?.Dispose(); Debug.WriteLine("MainViewModel 리소스 해제 완료."); } _disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
핵심 변경 사항:

LockerDbContext.cs:
ValidateEntity 메서드를 재정의하여 LockerAssignment의 UserName 필수 오류를 무시하도록 했습니다.
SaveChanges/SaveChangesAsync 내부에 로그 로직 비활성화를 위한 #region 주석을 추가했습니다. 만약 저장 오류가 계속된다면, 이 #region 부분을 주석 처리하고 다시 테스트하여 로그 로직이 문제인지 확인해 보세요.
DbEntityValidationException 발생 시 더 자세한 오류 정보를 디버그 창에 출력하도록 LogValidationErrors 헬퍼 메서드를 추가했습니다.
JSON 직렬화를 Newtonsoft.Json으로 변경했습니다 (NuGet 패키지 설치 필요).
MainViewModel.cs:
SaveChangesAsync의 catch 블록에 DbEntityValidationException을 처리하는 HandleValidationException 호출을 추가했습니다.
오류 메시지 박스에 ex.ToString()을 사용하여 더 상세한 오류 정보(InnerException 포함)가 표시되도록 했습니다.
다음 단계:

NuGet 패키지: Newtonsoft.Json 패키지를 설치합니다.
코드 적용 및 빌드: 위 코드로 해당 파일들을 업데이트하고 솔루션을 다시 빌드합니다.
오류 재현 및 확인:
마스터 데이터 창 저장 시: 오류가 발생하면 오류 메시지 박스의 전체 내용과 Visual Studio 출력 창의 DbEntityValidationException 관련 상세 로그(어떤 속성, 어떤 오류 메시지)를 확인하여 알려주세요.