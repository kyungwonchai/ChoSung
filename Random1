송합니다. 요청하신 내용을 반영하여 MySQL에서 QR 코드가 일치하는 항목을 확인하고, 리스트박스에 해당 정보를 추가하는 코드와 함께, 3초 내에 동일한 QR 코드를 다시 읽지 않도록 해시테이블을 사용한 로직을 추가하겠습니다.

주요 변경 사항:
MySQL에서 일치하는 QR 코드 확인:
QR 코드가 MySQL 데이터베이스의 modelnumber와 일치하는지 확인합니다. 일치할 경우, 해당 정보를 리스트박스에 추가합니다.
3초간 중복 스캔 방지:
QR 코드 값을 해시맵(HashMap)에 저장하고, 3초 동안 동일한 QR 코드를 다시 읽지 않도록 합니다. 3초 후에는 해당 QR 코드가 해시맵에서 제거됩니다.
수정된 Kotlin 코드 (MainActivity.kt)
kotlin
코드 복사
package com.dxmxsmd.mobilechecker

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.wifi.WifiManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.widget.ArrayAdapter
import android.widget.ListView
import android.widget.RelativeLayout
import android.widget.TextView
import androidx.activity.ComponentActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.camera2.interop.ExperimentalCamera2Interop
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import kotlinx.coroutines.*
import java.net.InetAddress
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class MainActivity : ComponentActivity() {

    private lateinit var viewFinder: PreviewView
    private lateinit var cameraContainer: RelativeLayout
    private lateinit var deviceInfo: TextView
    private lateinit var qrCodeList: ListView
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var handler: Handler
    private lateinit var qrCodeAdapter: ArrayAdapter<String>

    private lateinit var deviceIp: String
    private lateinit var deviceId: String

    private var isGreenState = false
    private val recentQrCodes = HashMap<String, Long>() // 최근에 스캔된 QR 코드를 저장하는 해시맵

    // MSSQL 연결 정보
    private val dbUrl = "jdbc:sqlserver://<SERVER>:<PORT>;databaseName=<DATABASE>"
    private val dbUser = "<USERNAME>"
    private val dbPassword = "<PASSWORD>"

    // MySQL 연결 정보
    private val mySqlUrl = "jdbc:mysql://<MYSQL_SERVER>:<MYSQL_PORT>/<MYSQL_DATABASE>"
    private val mySqlUser = "<MYSQL_USERNAME>"
    private val mySqlPassword = "<MYSQL_PASSWORD>"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewFinder = findViewById(R.id.viewFinder)
        cameraContainer = findViewById(R.id.camera_container)
        deviceInfo = findViewById(R.id.device_info)
        qrCodeList = findViewById(R.id.qr_code_list)

        // 기기 IP 주소와 ID 가져오기
        deviceIp = getDeviceIpAddress()
        deviceId = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)

        // IP 주소와 기기 ID 표시
        deviceInfo.text = "IP: $deviceIp\nID: $deviceId"

        qrCodeAdapter = ArrayAdapter(this, android.R.layout.simple_list_item_1, mutableListOf())
        qrCodeList.adapter = qrCodeAdapter

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        cameraExecutor = Executors.newSingleThreadExecutor()
        handler = Handler(Looper.getMainLooper())
    }

    @OptIn(ExperimentalCamera2Interop::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val previewBuilder = Preview.Builder()

            // Camera2Interop을 사용하여 연속 자동 초점 모드 설정
            val camera2Interop = Camera2Interop.Extender(previewBuilder)
            camera2Interop.setCaptureRequestOption(
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE,
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
            )

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(viewFinder.surfaceProvider)
            }

            val barcodeScanner = BarcodeScanning.getClient()

            val imageAnalysis = ImageAnalysis.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9) // 장치의 최대 해상도 사용
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .setTargetRotation(viewFinder.display.rotation) // 디스플레이 회전에 맞춤
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor, { imageProxy ->
                        processImageProxy(barcodeScanner, imageProxy)
                    })
                }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageAnalysis
                )

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    private fun processImageProxy(barcodeScanner: BarcodeScanner, imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        val rawValue = barcode.rawValue
                        findViewById<TextView>(R.id.text_view_result).text = rawValue

                        // 최근 스캔된 QR 코드인지 확인 (3초 이내)
                        if (recentQrCodes.containsKey(rawValue)) {
                            val lastScannedTime = recentQrCodes[rawValue]
                            val currentTime = System.currentTimeMillis()
                            if (lastScannedTime != null && (currentTime - lastScannedTime) < 3000) {
                                // 3초 이내에 스캔된 경우 처리하지 않음
                                return@addOnSuccessListener
                            }
                        }

                        // 최근 스캔된 QR 코드로 등록
                        recentQrCodes[rawValue] = System.currentTimeMillis()

                        // 녹색 상태가 아닐 때만 DB 체크
                        if (!isGreenState) {
                            CoroutineScope(Dispatchers.Main).launch {
                                val isInDatabase = isQrCodeInDatabase(rawValue)
                                if (isInDatabase) {
                                    isGreenState = true
                                    // QR 코드가 DB에 존재할 경우 테두리를 녹색으로 변경
                                    cameraContainer.setBackgroundColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_green_light))

                                    // 5분 동안 DB 체크 중지
                                    delay(TimeUnit.MINUTES.toMillis(5))
                                    isGreenState = false
                                    cameraContainer.setBackgroundColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_orange_light))
                                }
                            }
                        } else {
                            // 녹색 상태에서는 읽은 바코드를 MSSQL에 저장
                            CoroutineScope(Dispatchers.IO).launch {
                                insertScannedData(rawValue, deviceId)

                                // MySQL에서 modelnumber 확인
                                val modelInfo = checkModelInMySQL(rawValue)
                                modelInfo?.let {
                                    withContext(Dispatchers.Main) {
                                        qrCodeAdapter.add(it)
                                        qrCodeAdapter.notifyDataSetChanged()
                                    }
                                }
                            }
                        }

                        // 3초 후에 해시맵에서 QR 코드 제거
                        handler.postDelayed({
                            recentQrCodes.remove(rawValue)
                        }, 3000)
                    }
                }
                .addOnFailureListener {
                    // Handle failure
                }
                .addOnCompleteListener {
                    imageProxy.close()
                }
        }
    }

    private suspend fun isQrCodeInDatabase(qrCode: String): Boolean {
        return withContext(Dispatchers.IO) {
            var connection: Connection? = null
            var preparedStatement: PreparedStatement? = null
            var resultSet: ResultSet? = null
            var result = false
            try {
                // JDBC 드라이버 로드
                Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver")

                // 데이터베이스 연결
                connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword)

                // 쿼리 실행
                val query = "SELECT COUNT(*) FROM QRCodeData WHERE QRCode = ?"
                preparedStatement = connection.prepareStatement(query)
                preparedStatement.setString(1, qrCode)
                
                resultSet = preparedStatement.executeQuery()

                // 결과 처리
                if (resultSet.next()) {
                    result = resultSet.getInt(1) > 0
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                try {
                    resultSet?.close()
                    preparedStatement?.close()
                    connection?.close()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            result
        }
    }

    private suspend fun insertScannedData(qrCode: String, deviceId: String) {
        withContext(Dispatchers.IO) {
            var connection: Connection? = null
            var preparedStatement: PreparedStatement? = null
            try {
                // JDBC 드라이버 로드
                Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver")

                // 데이터베이스 연결
                connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword)

                // 데이터 삽입
                val query = "INSERT INTO ScannedData (QRCodeData, ScannedAt) VALUES (?, ?)"
                preparedStatement = connection.prepareStatement(query)
                preparedStatement.setString(1, qrCode)
                preparedStatement.setString(2, deviceId)
                preparedStatement.executeUpdate()
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                try {
                    preparedStatement?.close()
                    connection?.close()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
        }
    }

    private suspend fun checkModelInMySQL(qrCode: String): String? {
        return withContext(Dispatchers.IO) {
            var connection: Connection? = null
            var preparedStatement: PreparedStatement? = null
            var resultSet: ResultSet? = null
            var result: String? = null
            try {
                // MySQL JDBC 드라이버 로드
                Class.forName("com.mysql.jdbc.Driver")

                // 데이터베이스 연결
                connection = DriverManager.getConnection(mySqlUrl, mySqlUser, mySqlPassword)

                // 쿼리 실행
                val query = "SELECT district, at, modelnumber FROM smd.management_mobile_mainseet WHERE modelnumber = ?"
                preparedStatement = connection.prepareStatement(query)
                preparedStatement.setString(1, qrCode)
                
                resultSet = preparedStatement.executeQuery()

                // 결과 처리
                if (resultSet.next()) {
                    val district = resultSet.getString("district")
                    val at = resultSet.getString("at")
                    val modelnumber = resultSet.getString("modelnumber")
                    result = "District: $district, At: $at, Model: $modelnumber"
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                try {
                    resultSet?.close()
                    preparedStatement?.close()
                    connection?.close()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            result
        }
    }

    private fun getDeviceIpAddress(): String {
        try {
            val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
            val ipAddress = wifiManager.connectionInfo.ipAddress
            return InetAddress.getByAddress(
                byteArrayOf(
                    (ipAddress and 0xff).toByte(),
                    (ipAddress shr 8 and 0xff).toByte(),
                    (ipAddress shr 16 and 0xff).toByte(),
                    (ipAddress shr 24 and 0xff).toByte()
                )
            ).hostAddress ?: "IP not found"
        } catch (ex: Exception) {
            return "IP not found"
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
        handler.removeCallbacksAndMessages(null) // 모든 핸들러 작업 중지
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)
    }
}
주요 수정 사항:
최근 QR 코드 기록 및 3초 간 중복 방지:

recentQrCodes 해시맵을 사용하여 최근에 스캔된 QR 코드를 기록하고, 3초 내에 동일한 QR 코드를 다시 스캔하지 못하게 합니다.
QR 코드 스캔 후 해시맵에서 제거:

스캔된 QR 코드는 3초 후에 해시맵에서 제거되므로, 3초 후에는 다시 스캔이 가능해집니다.
MySQL 데이터베이스 체크 및 리스트 업데이트:

QR 코드가 MySQL 데이터베이스의 modelnumber와 일치할 경우, 해당 정보를 리스트박스에 추가합니다.
이제, 이 코드를 통해 QR 코드가 MySQL 데이터베이스에서 확인된 경우 리스트박스에 추가되며, 3초 내에 동일한 QR 코드를 다시 스캔하지 못하도록 구현되었습