JSON이 너무 커지면 결국 유지보수가 어려워질 수 있습니다. 이를 해결하기 위해 더 효과적인 아키텍처 설계를 적용하겠습니다.

1. JSON이 커지는 문제 해결 (데이터 분리 & UI 동적 구성)
✅ 솔루션: JSON을 분할 & 동적 UI 관리
JSON을 여러 개의 파일로 나눈다. (Home.json, Edit.json 등)
JSON 대신 DB 또는 Excel 활용 가능
UI를 동적으로 생성하여 필요할 때만 버튼을 로드
JSON을 직접 수정하지 않고, 프로그램 내에서 버튼 추가 UI를 제공
2. 새로운 설계 방식 (최고의 유지보수성)
① 버튼 데이터를 JSON이 아닌 DB 또는 Excel로 관리
JSON을 사용하지 않고, SQLite / MSSQL / Excel을 활용하여 유지보수를 더 쉽게 만듭니다.

✅ Excel 기반 버튼 데이터 예시
Page	Group	Name	Icon	Tag
Home	File	New File	new.png	btnNewFile
Home	File	Open File	open.png	btnOpenFile
Edit	Edit	Copy	copy.png	btnCopy
② JSON 없이 SQLite DB로 데이터 관리
sql
코드 복사
CREATE TABLE Buttons (
    Id INTEGER PRIMARY KEY AUTOINCREMENT,
    Page TEXT,
    GroupName TEXT,
    Name TEXT,
    Icon TEXT,
    Tag TEXT
);
📌 데이터 입력 예시

sql
코드 복사
INSERT INTO Buttons (Page, GroupName, Name, Icon, Tag) VALUES
('Home', 'File', 'New File', 'new.png', 'btnNewFile'),
('Home', 'File', 'Open File', 'open.png', 'btnOpenFile'),
('Edit', 'Clipboard', 'Copy', 'copy.png', 'btnCopy');
③ SQLite 또는 Excel에서 버튼 데이터 로드
csharp
코드 복사
public class ButtonConfigLoader
{
    private string _dbPath = "buttons.db";

    public List<ButtonConfig> LoadButtonsFromDB()
    {
        var buttonConfigs = new List<ButtonConfig>();
        using (var connection = new SQLiteConnection($"Data Source={_dbPath};Version=3;"))
        {
            connection.Open();
            string query = "SELECT Page, GroupName, Name, Icon, Tag FROM Buttons";
            using (var command = new SQLiteCommand(query, connection))
            using (var reader = command.ExecuteReader())
            {
                while (reader.Read())
                {
                    buttonConfigs.Add(new ButtonConfig
                    {
                        Page = reader.GetString(0),
                        Group = reader.GetString(1),
                        Name = reader.GetString(2),
                        Icon = reader.GetString(3),
                        Tag = reader.GetString(4)
                    });
                }
            }
        }
        return buttonConfigs;
    }
}
④ UI에서 버튼 추가 기능 제공 (JSON을 직접 수정할 필요 없음!)
csharp
코드 복사
private void AddButtonToDB(string page, string group, string name, string icon, string tag)
{
    using (var connection = new SQLiteConnection($"Data Source=buttons.db;Version=3;"))
    {
        connection.Open();
        string query = "INSERT INTO Buttons (Page, GroupName, Name, Icon, Tag) VALUES (@Page, @Group, @Name, @Icon, @Tag)";
        using (var command = new SQLiteCommand(query, connection))
        {
            command.Parameters.AddWithValue("@Page", page);
            command.Parameters.AddWithValue("@Group", group);
            command.Parameters.AddWithValue("@Name", name);
            command.Parameters.AddWithValue("@Icon", icon);
            command.Parameters.AddWithValue("@Tag", tag);
            command.ExecuteNonQuery();
        }
    }
    MessageBox.Show($"Button '{name}' added successfully!");
}
이제 프로그램 내에서 직접 버튼을 추가할 수 있습니다.
✅ JSON 수정 없이 UI에서 바로 버튼을 추가 가능
✅ 데이터가 DB에 저장되므로 유지보수 편리

3. 결론 (최고의 유지보수성과 성능)
방식	장점	단점
JSON	간단하지만, 크기가 커지면 불편	크기가 커지면 직접 관리하기 어려움
SQLite	데이터 관리가 쉬움, UI에서 추가 가능	초기 DB 설정 필요
Excel	사용자가 직접 관리 가능	엑셀 파싱 코드 필요
🚀 최종 적용 구조
SQLite로 버튼 데이터를 저장
프로그램 내에서 버튼 추가 기능 제공
버튼 생성 시 필요한 데이터만 불러오기