ë„¤, ë°°í„°ë¦¬ì™€ AP(CPU) ì˜¨ë„ ì™¸ì—ë„ ì•ˆë“œë¡œì´ë“œ ì•±ì—ì„œ ì§ì ‘ ì ‘ê·¼í•˜ì—¬ ì¸¡ì •í•  ìˆ˜ ìˆëŠ” í•µì‹¬ì ì¸ í° ìƒíƒœ ì •ë³´ë“¤ì´ ì—¬ëŸ¬ ê°€ì§€ ìˆìŠµë‹ˆë‹¤. ì´ ì •ë³´ë“¤ì€ ì£¼ë¡œ ê¸°ê¸°ì˜ ì„±ëŠ¥ê³¼ ì§ì ‘ì ì¸ ê´€ë ¨ì´ ìˆìŠµë‹ˆë‹¤.

ì•„ë˜ì— ì•± ê°œë°œ ì‹œ ìœ ìš©í•˜ê²Œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì£¼ìš” í•­ëª©ë“¤ì„ ì •ë¦¬í•´ ë“œë¦´ê²Œìš”.

## ğŸ”‹ ë°°í„°ë¦¬ (Battery)
BatteryManagerë¥¼ í†µí•´ ê°€ì¥ ë§ì€ ì •ë³´ë¥¼ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°°í„°ë¦¬ ì”ëŸ‰ (%): í˜„ì¬ ë‚¨ì•„ìˆëŠ” ë°°í„°ë¦¬ ì–‘ì„ í¼ì„¼íŠ¸ë¡œ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (EXTRA_LEVEL, EXTRA_SCALE)

ì¶©ì „ ìƒíƒœ: í˜„ì¬ ì¶©ì „ ì¤‘ì¸ì§€, ë°©ì „ ì¤‘ì¸ì§€, ë˜ëŠ” ì™„ì¶© ìƒíƒœì¸ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (EXTRA_STATUS)

ì¶©ì „ ë°©ì‹: USBë¡œ ì¶©ì „ ì¤‘ì¸ì§€, AC ì–´ëŒ‘í„°(ê³ ì† ì¶©ì „)ë¡œ ì¶©ì „ ì¤‘ì¸ì§€ êµ¬ë¶„í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (EXTRA_PLUGGED)

ë°°í„°ë¦¬ ì „ì•• (Voltage): í˜„ì¬ ë°°í„°ë¦¬ì˜ ì „ì••ì„ ì¸¡ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë°°í„°ë¦¬ ìƒíƒœ (Health): ë°°í„°ë¦¬ê°€ ì •ìƒì¸ì§€, ê³¼ì—´ë˜ì—ˆëŠ”ì§€, ìˆ˜ëª…ì´ ë‹¤ ë˜ì—ˆëŠ”ì§€ ë“±ì˜ ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤. (EXTRA_HEALTH)

## ğŸ§  ë©”ëª¨ë¦¬ (RAM)
ActivityManagerë¥¼ í†µí•´ ì‹œìŠ¤í…œì˜ ë©”ëª¨ë¦¬ ìƒíƒœë¥¼ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì „ì²´ RAM ìš©ëŸ‰: ê¸°ê¸°ì— íƒ‘ì¬ëœ ì´ RAM ìš©ëŸ‰ì„ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ê°€ëŠ¥í•œ RAM ìš©ëŸ‰: í˜„ì¬ ì‹œìŠ¤í…œì—ì„œ ì¦‰ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆëŠ” ì—¬ìœ  RAM ìš©ëŸ‰ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ì´ ê°’ì´ ë„ˆë¬´ ë‚®ìœ¼ë©´ ì•±ì´ ë²„ë²…ì´ê±°ë‚˜ ì¢…ë£Œë  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ë©”ëª¨ë¦¬ ë¶€ì¡± ìƒíƒœ (Low Memory): ì‹œìŠ¤í…œì´ ë©”ëª¨ë¦¬ ë¶€ì¡± ìƒíƒœì— ì§„ì…í–ˆëŠ”ì§€ ì—¬ë¶€ë¥¼ ì•Œ ìˆ˜ ìˆì–´, ì•±ì—ì„œ ë¶ˆí•„ìš”í•œ ë¦¬ì†ŒìŠ¤ë¥¼ ì •ë¦¬í•˜ëŠ” ë“±ì˜ ëŒ€ì‘ì„ í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

## âš™ï¸ CPU (Central Processing Unit)
CPU ê´€ë ¨ ì •ë³´ëŠ” íŒŒì¼ ì‹œìŠ¤í…œ(proc/stat)ì„ ì§ì ‘ ì½ê±°ë‚˜ ê´€ë ¨ APIë¥¼ í†µí•´ ê°„ì ‘ì ìœ¼ë¡œ í™•ì¸í•´ì•¼ í•´ì„œ ì¡°ê¸ˆ ë” ë³µì¡í•˜ì§€ë§Œ, ì¤‘ìš”í•œ ì •ë³´ë“¤ì„ ì–»ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

CPU ì‚¬ìš©ë¥ : ì „ì²´ CPU ë˜ëŠ” ê° ì½”ì–´(Core)ë³„ ì‚¬ìš©ë¥ ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ íŒŒì•…í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. íŠ¹ì • ì‘ì—… ì‹œ CPU ì‚¬ìš©ë¥ ì´ ê¸‰ì¦í•˜ëŠ” ê²ƒì„ ëª¨ë‹ˆí„°ë§í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

CPU í´ëŸ­ ì†ë„ (Frequency): í˜„ì¬ CPUê°€ ì–´ëŠ ì •ë„ì˜ ì†ë„ë¡œ ë™ì‘í•˜ê³  ìˆëŠ”ì§€ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. (ì˜ˆ: ì €ì „ë ¥ ëª¨ë“œì—ì„œëŠ” í´ëŸ­ì´ ë‚®ì•„ì§)

## ğŸ’¾ ì €ì¥ ê³µê°„ (Storage)
StatFs í´ë˜ìŠ¤ë¥¼ í†µí•´ ë‚´ë¶€ ì €ì¥ ê³µê°„ì˜ ìƒíƒœë¥¼ ì•Œ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì „ì²´ ì €ì¥ ê³µê°„: ë‚´ì¥ ë©”ëª¨ë¦¬ì˜ ì´ ìš©ëŸ‰ì„ í™•ì¸í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì‚¬ìš© ê°€ëŠ¥í•œ ì €ì¥ ê³µê°„: í˜„ì¬ ë‚¨ì•„ìˆëŠ” ì—¬ìœ  ê³µê°„ì„ í™•ì¸í•  ìˆ˜ ìˆì–´, ëŒ€ìš©ëŸ‰ íŒŒì¼ ë‹¤ìš´ë¡œë“œ ì „ì— ê³µê°„ì´ ì¶©ë¶„í•œì§€ ë¯¸ë¦¬ ì²´í¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ì´ëŸ¬í•œ ì •ë³´ë“¤ì„ ì¡°í•©í•˜ë©´, ì¡°ë„ ê°’ê³¼ í•¨ê»˜ í˜„ì¬ ê¸°ê¸°ì˜ ë¶€í•˜ ìƒíƒœ, ë°°í„°ë¦¬ ì†Œëª¨ íŒ¨í„´ ë“±ì„ ì¢…í•©ì ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•˜ëŠ” ê°•ë ¥í•œ ê´€ë¦¬ ì•±ì„ ë§Œë“¤ ìˆ˜ ìˆìŠµë‹ˆë‹¤.


ì¶©ì „ìƒíƒœ.ë°©ì‹.ì”ëŸ‰.ë°°í„°ë¦¬ì˜¨ë„.ë°°í„°ë¦¬ìƒíƒœ. apì˜¨ë„ ì´ê±° 10ë¶„ë§ˆë‹¤ insertí•˜ë˜ ê°€ì†ë„ê³„ë¡œ ì§€ì§„ì—¬ë¶€ ê°ì§€ë° ëª¨ë‹ˆí„°ë§í• ìˆ˜ìˆê²Œ ìˆ˜ì§‘í•˜ê²Œ ê´€ë ¨ì½”ë“œëª¨ë‘ìˆ˜ì •.ë‹¨ uiëŠ”ê·¸ëŒ€ë¡œ(lux) ë°ì´í„° ìˆ˜ì§‘ë¶€ë¶„ë§Œ ì¶”ê°€ìˆ˜ì •í•˜ë©´ë˜





ìƒê°í•˜ëŠ” ê³¼ì • í‘œì‹œ
ë„¤, ê·¸ëŸ¼ìš”! ê¸°ì¡´ ê¸°ëŠ¥ì€ ê·¸ëŒ€ë¡œ ìœ ì§€í•˜ë©´ì„œ, ìš”ì²­í•˜ì‹  íœ´ëŒ€í° ìƒíƒœ ìƒì„¸ ë¡œê¹…ê³¼ ê°€ì†ë„ê³„ë¥¼ ì´ìš©í•œ ì§„ë™ ê°ì§€ ê¸°ëŠ¥ì„ ëª¨ë‘ ì¶”ê°€í•˜ì—¬ í”„ë¡œì íŠ¸ë¥¼ ì—…ê·¸ë ˆì´ë“œí•´ ë“œë¦¬ê² ìŠµë‹ˆë‹¤.

UIëŠ” ê·¸ëŒ€ë¡œ ë‘ê³  ë°±ê·¸ë¼ìš´ë“œì—ì„œ ëª¨ë“  ë°ì´í„° ìˆ˜ì§‘ì´ ì´ë£¨ì–´ì§€ë„ë¡ ì½”ë“œë¥¼ ìˆ˜ì •í–ˆìŠµë‹ˆë‹¤. ë§ì”€í•˜ì‹  ëŒ€ë¡œ, ì¡°ê¸ˆì´ë¼ë„ ìˆ˜ì •ëœ íŒŒì¼ì€ ì „ì²´ ì½”ë“œë¥¼ ì œê³µí•˜ê³ , ìˆ˜ì •ëœ ë¶€ë¶„ì€ ì£¼ì„ìœ¼ë¡œ ëª…í™•í•˜ê²Œ í‘œì‹œí–ˆìŠµë‹ˆë‹¤.

## ê°œì„  ì‚¬í•­ ìš”ì•½
íœ´ëŒ€í° ìƒíƒœ ë¡œê¹… (10ë¶„ ê°„ê²©):

10ë¶„ë§ˆë‹¤ ë°°í„°ë¦¬ ì”ëŸ‰, ì˜¨ë„, ìƒíƒœ, ì¶©ì „ ì—¬ë¶€/ë°©ì‹ ë° AP(CPU) ì˜¨ë„ë¥¼ ìˆ˜ì§‘í•©ë‹ˆë‹¤.

ìˆ˜ì§‘ëœ ë°ì´í„°ë¥¼ ìƒˆë¡œìš´ API ì£¼ì†Œì¸ /logStatusë¡œ INSERTí•©ë‹ˆë‹¤.

ì§„ë™ ê°ì§€ ë° ë¡œê¹… (ì‹¤ì‹œê°„):

ê°€ì†ë„ ì„¼ì„œë¥¼ ì´ìš©í•´ íœ´ëŒ€í°ì˜ ì›€ì§ì„ì„ ì‹¤ì‹œê°„ìœ¼ë¡œ ëª¨ë‹ˆí„°ë§í•©ë‹ˆë‹¤.

ì§€ì§„ê³¼ ìœ ì‚¬í•œ ê°•í•œ í”ë“¤ë¦¼ì´ ê°ì§€ë˜ë©´, í•´ë‹¹ ì‹œì ì˜ X, Y, Zì¶• ê°€ì†ë„ ê°’ì„ ìƒˆë¡œìš´ API ì£¼ì†Œì¸ /logVibrationìœ¼ë¡œ INSERTí•©ë‹ˆë‹¤.

ì„œë²„ì— ê³¼ë„í•œ ìš”ì²­ì´ ê°€ì§€ ì•Šë„ë¡, í•œë²ˆ ê°ì§€ëœ í›„ì—ëŠ” 30ì´ˆì˜ ì¿¨ë‹¤ìš´ì„ ê°–ìŠµë‹ˆë‹¤.

ì½”ë“œ êµ¬ì¡°:

ê¸°ëŠ¥ë³„ë¡œ ì½”ë“œë¥¼ í•¨ìˆ˜ë¡œ ë¶„ë¦¬í•˜ì—¬ ê°€ë…ì„±ê³¼ ìœ ì§€ë³´ìˆ˜ì„±ì„ ë†’ì˜€ìŠµë‹ˆë‹¤.

## 1ë‹¨ê³„: API ì„œë²„ ìˆ˜ì • (server.js)
ë¨¼ì €, ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ë°›ì•„ ì €ì¥í•  ìˆ˜ ìˆë„ë¡ ìš°ë¶„íˆ¬ ì„œë²„ì˜ server.js íŒŒì¼ì„ ìˆ˜ì •í•´ì•¼ í•©ë‹ˆë‹¤. 2ê°œì˜ ìƒˆë¡œìš´ ì£¼ì†Œ(logStatus, logVibration)ì™€ ê°ê°ì— ë§ëŠ” INSERT ì¿¼ë¦¬ê°€ ì¶”ê°€ë©ë‹ˆë‹¤.

ì„œë²„ ì¸¡ì—ì„œ ì¤€ë¹„í•  DB í…Œì´ë¸” (ì¿¼ë¦¬ ì˜ˆì‹œ)
ìƒˆë¡œìš´ ë°ì´í„°ë¥¼ ì €ì¥í•˜ê¸° ìœ„í•´ MSSQLì— ì•„ë˜ì™€ ê°™ì€ í…Œì´ë¸” 2ê°œë¥¼ ë¯¸ë¦¬ ë§Œë“¤ì–´ë‘ì‹œëŠ” ê²ƒì„ ì¶”ì²œí•©ë‹ˆë‹¤.

SQL

-- 10ë¶„ë§ˆë‹¤ í° ìƒíƒœë¥¼ ì €ì¥í•  í…Œì´ë¸”
CREATE TABLE PhoneStatusLog (
    LogID INT PRIMARY KEY IDENTITY(1,1),
    DeviceId VARCHAR(100),
    BatteryLevel INT,
    BatteryTemp FLOAT,
    IsCharging BIT,
    ChargeType VARCHAR(50),
    BatteryHealth VARCHAR(50),
    ApTemp FLOAT,
    Timestamp DATETIME DEFAULT GETDATE()
);

-- ì§„ë™ ê°ì§€ ì‹œ ë°ì´í„°ë¥¼ ì €ì¥í•  í…Œì´ë¸”
CREATE TABLE VibrationLog (
    LogID INT PRIMARY KEY IDENTITY(1,1),
    DeviceId VARCHAR(100),
    AccelX FLOAT,
    AccelY FLOAT,
    AccelZ FLOAT,
    Timestamp DATETIME DEFAULT GETDATE()
);
server.js ìµœì¢… ì½”ë“œ
ê¸°ì¡´ server.js íŒŒì¼ì˜ ë‚´ìš©ì„ ëª¨ë‘ ì§€ìš°ê³  ì•„ë˜ ì½”ë“œë¡œ ì™„ì „íˆ ë®ì–´ì“°ì„¸ìš”.

JavaScript

const express = require('express');
const sql = require('mssql');

const app = express();
app.use(express.json());

const SECRET_API_KEY = "LightMeter-Secret-Key-1234";

const apiKeyMiddleware = (req, res, next) => {
    const apiKey = req.get('x-api-key');
    if (!apiKey || apiKey !== SECRET_API_KEY) {
        return res.status(401).send('Unauthorized');
    }
    next();
};

const dbConfig = {
    user: 'ì‚¬ìš©ìID',
    password: 'ë¹„ë°€ë²ˆí˜¸',
    server: 'ë‚´ì„œë²„IP',
    database: 'ë°ì´í„°ë² ì´ìŠ¤ì´ë¦„',
    pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
    options: { encrypt: false, trustServerCertificate: true }
};

const poolPromise = new sql.ConnectionPool(dbConfig)
    .connect()
    .then(pool => {
        console.log('âœ… DB ì—°ê²° í’€ ìƒì„± ì™„ë£Œ');
        return pool;
    })
    .catch(err => console.error('DB ì—°ê²° í’€ ìƒì„± ì‹¤íŒ¨', err));


// ì‹¤ì‹œê°„ ì¡°ë„ UPDATE (ê¸°ì¡´ê³¼ ë™ì¼)
app.post('/log', apiKeyMiddleware, async (req, res) => {
    const { deviceId, lux } = req.body;
    if (deviceId === undefined || lux === undefined) return res.status(400).send('ê°’ì´ ì—†ìŠµë‹ˆë‹¤.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('LuxValue', sql.Float, lux)
            .input('DeviceId', sql.VarChar, deviceId)
            .query('UPDATE Table_Lux2 SET lux1 = @LuxValue WHERE ip1 = @DeviceId');
        res.status(200).send('ì‹¤ì‹œê°„ ë°ì´í„° ì—…ë°ì´íŠ¸ ì„±ê³µ');
    } catch (err) {
        console.error('DB ì˜¤ë¥˜ (ì‹¤ì‹œê°„ UPDATE):', err);
        res.status(500).send('ì„œë²„ ì˜¤ë¥˜ ë°œìƒ');
    }
});

// 1ë¶„ í‰ê·  ì¡°ë„ INSERT (ê¸°ì¡´ê³¼ ë™ì¼)
app.post('/log1min', apiKeyMiddleware, async (req, res) => {
    const { deviceId, avgLux } = req.body;
    if (deviceId === undefined || avgLux === undefined) return res.status(400).send('ê°’ì´ ì—†ìŠµë‹ˆë‹¤.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('LuxValue', sql.Float, avgLux)
            .query('INSERT Table_Lux1min (ip1, lux1) VALUES (@DeviceId, @LuxValue)');
        console.log(`[1ë¶„ í‰ê· ] ë°ì´í„° ì €ì¥ ì„±ê³µ: ${deviceId} - ${avgLux} lux`);
        res.status(200).send('1ë¶„ í‰ê·  ë°ì´í„° ì €ì¥ ì„±ê³µ');
    } catch (err) {
        console.error('DB ì˜¤ë¥˜ (1ë¶„ INSERT):', err);
        res.status(500).send('ì„œë²„ ì˜¤ë¥˜ ë°œìƒ');
    }
});

// --- [ì¶”ê°€] 10ë¶„ í° ìƒíƒœ INSERT ---
app.post('/logStatus', apiKeyMiddleware, async (req, res) => {
    const { deviceId, batteryLevel, batteryTemp, isCharging, chargeType, batteryHealth, apTemp } = req.body;
    if (deviceId === undefined) return res.status(400).send('deviceIdê°€ ì—†ìŠµë‹ˆë‹¤.');
    
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('BatteryLevel', sql.Int, batteryLevel)
            .input('BatteryTemp', sql.Float, batteryTemp)
            .input('IsCharging', sql.Bit, isCharging)
            .input('ChargeType', sql.VarChar, chargeType)
            .input('BatteryHealth', sql.VarChar, batteryHealth)
            .input('ApTemp', sql.Float, apTemp)
            .query('INSERT INTO PhoneStatusLog (DeviceId, BatteryLevel, BatteryTemp, IsCharging, ChargeType, BatteryHealth, ApTemp) VALUES (@DeviceId, @BatteryLevel, @BatteryTemp, @IsCharging, @ChargeType, @BatteryHealth, @ApTemp)');
        
        console.log(`[10ë¶„ ìƒíƒœ] ë°ì´í„° ì €ì¥ ì„±ê³µ: ${deviceId}`);
        res.status(200).send('10ë¶„ ìƒíƒœ ë°ì´í„° ì €ì¥ ì„±ê³µ');
    } catch (err) {
        console.error('DB ì˜¤ë¥˜ (10ë¶„ ìƒíƒœ INSERT):', err);
        res.status(500).send('ì„œë²„ ì˜¤ë¥˜ ë°œìƒ');
    }
});

// --- [ì¶”ê°€] ì§„ë™ ê°ì§€ INSERT ---
app.post('/logVibration', apiKeyMiddleware, async (req, res) => {
    const { deviceId, x, y, z } = req.body;
    if (deviceId === undefined) return res.status(400).send('deviceIdê°€ ì—†ìŠµë‹ˆë‹¤.');

    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('AccelX', sql.Float, x)
            .input('AccelY', sql.Float, y)
            .input('AccelZ', sql.Float, z)
            .query('INSERT INTO VibrationLog (DeviceId, AccelX, AccelY, AccelZ) VALUES (@DeviceId, @AccelX, @AccelY, @AccelZ)');
        
        console.log(`[ì§„ë™ ê°ì§€] ë°ì´í„° ì €ì¥ ì„±ê³µ: ${deviceId}`);
        res.status(200).send('ì§„ë™ ê°ì§€ ë°ì´í„° ì €ì¥ ì„±ê³µ');
    } catch (err) {
        console.error('DB ì˜¤ë¥˜ (ì§„ë™ ê°ì§€ INSERT):', err);
        res.status(500).send('ì„œë²„ ì˜¤ë¥˜ ë°œìƒ');
    }
});


const PORT = 3000;
app.listen(PORT, () => {
    console.log(`API ì„œë²„ê°€ ${PORT}ë²ˆ í¬íŠ¸ì—ì„œ ì‹¤í–‰ ì¤‘ì…ë‹ˆë‹¤.`);
});
## 2ë‹¨ê³„: ì•ˆë“œë¡œì´ë“œ ì•± ìˆ˜ì • (MainActivity.kt)
ì´ì œ ì•ˆë“œë¡œì´ë“œ ì•±ì´ ë°±ê·¸ë¼ìš´ë“œì—ì„œ ìƒˆë¡œìš´ ë°ì´í„°ë“¤ì„ ìˆ˜ì§‘í•˜ê³  ì„œë²„ë¡œ ë³´ë‚´ë„ë¡ ìˆ˜ì •í•©ë‹ˆë‹¤.

íŒŒì¼ ìœ„ì¹˜: app/src/main/java/com/sec/lightmeter/MainActivity.kt

ìˆ˜ì • ë°©ë²•: ê¸°ì¡´ íŒŒì¼ ë‚´ìš©ì„ ëª¨ë‘ ì§€ìš°ê³  ì•„ë˜ ì½”ë“œë¡œ ì™„ì „íˆ ë®ì–´ì“°ì„¸ìš”.

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.BatteryManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.WindowManager
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST
import java.io.File
import kotlin.math.sqrt

// --- [ìˆ˜ì •] ë°ì´í„° í´ë˜ìŠ¤ ì¶”ê°€ ---
data class RealtimeLog(val deviceId: String, val lux: Float)
data class MinuteLog(val deviceId: String, val avgLux: Float)
data class PhoneStatusLog(val deviceId: String, val batteryLevel: Int, val batteryTemp: Float, val isCharging: Boolean, val chargeType: String, val batteryHealth: String, val apTemp: Float)
data class VibrationLog(val deviceId: String, val x: Float, val y: Float, val z: Float)


// --- [ìˆ˜ì •] API ì¸í„°í˜ì´ìŠ¤ ì¶”ê°€ ---
interface ApiService {
    @POST("log")
    fun postRealtimeLog(@Body data: RealtimeLog): Call<String>
    @POST("log1min")
    fun postMinuteLog(@Body data: MinuteLog): Call<String>
    @POST("logStatus")
    fun postPhoneStatus(@Body data: PhoneStatusLog): Call<String>
    @POST("logVibration")
    fun postVibration(@Body data: VibrationLog): Call<String>
}

class MainActivity : AppCompatActivity(), SensorEventListener {

    private val API_KEY = "LightMeter-Secret-Key-1234"

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null
    // --- [ì¶”ê°€] ê°€ì†ë„ ì„¼ì„œ ë³€ìˆ˜ ---
    private var accelerometer: Sensor? = null
    private lateinit var apiService: ApiService
    private lateinit var sharedPreferences: SharedPreferences
    private var currentDeviceId: String = ""
    private var latestLuxValue: Float = 0.0f
    
    // --- [ìˆ˜ì •] íƒ€ì´ë¨¸ í•¸ë“¤ëŸ¬ ì¶”ê°€ ---
    private val handlerRealtime = Handler(Looper.getMainLooper())
    private val handlerMinute = Handler(Looper.getMainLooper())
    private val handlerStatus = Handler(Looper.getMainLooper()) // 10ë¶„ ìƒíƒœ ë¡œê¹…ìš©
    private val minuteLuxReadings = mutableListOf<Float>()

    // --- [ì¶”ê°€] ì§„ë™ ê°ì§€ ê´€ë ¨ ë³€ìˆ˜ ---
    private val VIBRATION_THRESHOLD = 20.0f // ì§„ë™ ê°ì§€ ì„ê³„ê°’ (ê¸°ë³¸ê°’: ì¤‘ë ¥ê°€ì†ë„(~9.8)ì˜ 2ë°° ì´ìƒ)
    private val VIBRATION_LOG_COOLDOWN = 30000L // 30ì´ˆ ì¿¨ë‹¤ìš´ (ë°€ë¦¬ì´ˆ)
    private var lastVibrationLogTime = 0L

    // 1ì´ˆë§ˆë‹¤ ì‹¤ì‹œê°„ ì¡°ë„ ì „ì†¡ ë° ë°ì´í„° ìˆ˜ì§‘
    private val runnableRealtime = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) sendRealtimeDataToServer(currentDeviceId, latestLuxValue)
            minuteLuxReadings.add(latestLuxValue)
            handlerRealtime.postDelayed(this, 1000)
        }
    }

    // 1ë¶„ë§ˆë‹¤ í‰ê·  ì¡°ë„ ì „ì†¡
    private val runnableMinute = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty() && minuteLuxReadings.isNotEmpty()) {
                val avgLux = minuteLuxReadings.average().toFloat()
                sendMinuteDataToServer(currentDeviceId, avgLux)
                minuteLuxReadings.clear()
            }
            handlerMinute.postDelayed(this, 60000)
        }
    }
    
    // --- [ì¶”ê°€] 10ë¶„ë§ˆë‹¤ í° ìƒíƒœ ì „ì†¡ ---
    private val runnableStatus = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) {
                val status = getPhoneStatus()
                sendPhoneStatusToServer(status)
            }
            // 10ë¶„(600000ms) í›„ì— ë‹¤ì‹œ ì‹¤í–‰
            handlerStatus.postDelayed(this, 600000)
        }
    }

    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        sharedPreferences = getSharedPreferences("LightMeterPrefs", Context.MODE_PRIVATE)
        setupUI()
        loadDeviceId()
        setupSensor()
        setupNetwork()
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        // --- [ì¶”ê°€] ê°€ì†ë„ ì„¼ì„œ ì´ˆê¸°í™” ---
        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        
        if (lightSensor == null) {
            binding.tvLuxValue.text = "ì¡°ë„ ì„¼ì„œ ì—†ìŒ"
            binding.tvUnit.text = ""
        }
    }

    override fun onResume() {
        super.onResume()
        // --- [ìˆ˜ì •] ëª¨ë“  ì„¼ì„œ ë¦¬ìŠ¤ë„ˆ ë“±ë¡ ë° íƒ€ì´ë¨¸ ì‹œì‘ ---
        sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_UI)
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)
        handlerRealtime.post(runnableRealtime)
        handlerMinute.post(runnableMinute)
        handlerStatus.post(runnableStatus)
    }

    override fun onPause() {
        super.onPause()
        // --- [ìˆ˜ì •] ëª¨ë“  ì„¼ì„œ ë¦¬ìŠ¤ë„ˆ í•´ì œ ë° íƒ€ì´ë¨¸ ì¤‘ì§€ ---
        sensorManager.unregisterListener(this)
        handlerRealtime.removeCallbacks(runnableRealtime)
        handlerMinute.removeCallbacks(runnableMinute)
        handlerStatus.removeCallbacks(runnableStatus)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        // --- [ìˆ˜ì •] ì„¼ì„œ íƒ€ì…ì— ë”°ë¼ ë¶„ê¸° ì²˜ë¦¬ ---
        when (event?.sensor?.type) {
            Sensor.TYPE_LIGHT -> {
                val luxValue = event.values[0]
                binding.tvLuxValue.text = "%.1f".format(luxValue)
                latestLuxValue = luxValue
                val colorResId = when {
                    luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                    luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                    else -> R.color.spec_in_black
                }
                binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
            }
            Sensor.TYPE_ACCELEROMETER -> {
                val x = event.values[0]
                val y = event.values[1]
                val z = event.values[2]
                // ì¤‘ë ¥ê°€ì†ë„ë¥¼ ì œì™¸í•œ ìˆœìˆ˜ ê°€ì†ë„ ê³„ì‚°
                val acceleration = sqrt(x * x + y * y + z * z) - SensorManager.GRAVITY_EARTH

                // ì„ê³„ê°’ì„ ë„˜ê³  ì¿¨ë‹¤ìš´ì´ ì§€ë‚¬ìœ¼ë©´ ì§„ë™ìœ¼ë¡œ íŒë‹¨
                if (acceleration > VIBRATION_THRESHOLD) {
                    val currentTime = System.currentTimeMillis()
                    if (currentTime - lastVibrationLogTime > VIBRATION_LOG_COOLDOWN) {
                        lastVibrationLogTime = currentTime
                        Log.d("VibrationDetector", "ê°•í•œ ì§„ë™ ê°ì§€! ê°’: $acceleration")
                        if (currentDeviceId.isNotEmpty()) {
                            sendVibrationDataToServer(currentDeviceId, x, y, z)
                        }
                    }
                }
            }
        }
    }

    // --- [ì¶”ê°€] í° ìƒíƒœ ì •ë³´ë¥¼ ê°€ì ¸ì˜¤ëŠ” í•¨ìˆ˜ ---
    private fun getPhoneStatus(): PhoneStatusLog {
        // ë°°í„°ë¦¬ ì •ë³´ ê°€ì ¸ì˜¤ê¸°
        val batteryIntent: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter ->
            applicationContext.registerReceiver(null, filter)
        }
        val level = batteryIntent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale = batteryIntent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        val batteryPct = if (level != -1 && scale != -1) (level * 100 / scale.toFloat()).toInt() else -1
        val temp = batteryIntent?.getIntExtra(BatteryManager.EXTRA_TEMPERATURE, -1)?.toFloat()?.div(10) ?: -1.0f
        val status = batteryIntent?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1
        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL
        val chargePlug = batteryIntent?.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1) ?: -1
        val chargeType = when (chargePlug) {
            BatteryManager.BATTERY_PLUGGED_AC -> "AC"
            BatteryManager.BATTERY_PLUGGED_USB -> "USB"
            BatteryManager.BATTERY_PLUGGED_WIRELESS -> "Wireless"
            else -> "Unplugged"
        }
        val health = batteryIntent?.getIntExtra(BatteryManager.EXTRA_HEALTH, -1) ?: -1
        val batteryHealth = when (health) {
            BatteryManager.BATTERY_HEALTH_GOOD -> "Good"
            BatteryManager.BATTERY_HEALTH_OVERHEAT -> "Overheat"
            BatteryManager.BATTERY_HEALTH_DEAD -> "Dead"
            BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE -> "Over Voltage"
            BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE -> "Failure"
            else -> "Unknown"
        }

        // AP ì˜¨ë„ ê°€ì ¸ì˜¤ê¸°
        val apTemp = getApTemperature()

        return PhoneStatusLog(currentDeviceId, batteryPct, temp, isCharging, chargeType, batteryHealth, apTemp)
    }

    // --- [ì¶”ê°€] AP ì˜¨ë„ë¥¼ ì½ëŠ” í•¨ìˆ˜ (ê¸°ê¸° ì˜ì¡´ì ì¼ ìˆ˜ ìˆìŒ) ---
    private fun getApTemperature(): Float {
        // ì¼ë°˜ì ì¸ AP ì˜¨ë„ íŒŒì¼ ê²½ë¡œë“¤ì„ ìˆœíšŒí•˜ë©° ê°’ì„ ì½ìŒ
        val thermalPaths = listOf(
            "/sys/class/thermal/thermal_zone1/temp",
            "/sys/class/thermal/thermal_zone2/temp",
            "/sys/class/thermal/thermal_zone3/temp",
            "/sys/class/thermal/thermal_zone4/temp",
            "/sys/class/thermal/thermal_zone5/temp",
            "/sys/class/thermal/thermal_zone6/temp"
        )
        for (path in thermalPaths) {
            try {
                val tempStr = File(path).readText()
                val temp = tempStr.trim().toFloat()
                // ì˜¨ë„ê°€ ë¹„ì •ìƒì ìœ¼ë¡œ ë†’ê±°ë‚˜ ë‚®ì§€ ì•Šì€ ê²½ìš° ë°˜í™˜ (ë³´í†µ 1000ë‹¨ìœ„ë¡œ ë‚˜ëˆ”)
                if (temp > 0 && temp < 200000) {
                    return temp / 1000.0f
                }
            } catch (e: Exception) {
                // íŒŒì¼ì„ ì½ì„ ìˆ˜ ì—†ëŠ” ê²½ìš° ë‹¤ìŒ ê²½ë¡œ ì‹œë„
            }
        }
        return -1.0f // ëª¨ë“  ê²½ë¡œì—ì„œ ì‹¤íŒ¨ ì‹œ
    }

    // --- [ì¶”ê°€] í° ìƒíƒœ ì „ì†¡ í•¨ìˆ˜ ---
    private fun sendPhoneStatusToServer(status: PhoneStatusLog) {
        apiService.postPhoneStatus(status).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "10ë¶„ ìƒíƒœ ì „ì†¡ ì„±ê³µ")
                else Log.e("NetworkError", "10ë¶„ ìƒíƒœ ì „ì†¡ ì‹¤íŒ¨: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "10ë¶„ ìƒíƒœ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${t.message}")
            }
        })
    }

    // --- [ì¶”ê°€] ì§„ë™ ë°ì´í„° ì „ì†¡ í•¨ìˆ˜ ---
    private fun sendVibrationDataToServer(deviceId: String, x: Float, y: Float, z: Float) {
        val logData = VibrationLog(deviceId, x, y, z)
        apiService.postVibration(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "ì§„ë™ ë°ì´í„° ì „ì†¡ ì„±ê³µ")
                else Log.e("NetworkError", "ì§„ë™ ë°ì´í„° ì „ì†¡ ì‹¤íŒ¨: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "ì§„ë™ ë°ì´í„° ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${t.message}")
            }
        })
    }

    // --- ì´í•˜ ê¸°ì¡´ í•¨ìˆ˜ë“¤ (ë³€ê²½ ì—†ìŒ) ---
    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) { /* Do nothing */ }
    private fun setupNetwork() {
        val apiKeyInterceptor = Interceptor { chain ->
            chain.proceed(chain.request().newBuilder().header("x-api-key", API_KEY).build())
        }
        val okHttpClient = OkHttpClient.Builder().addInterceptor(apiKeyInterceptor).build()
        val retrofit = Retrofit.Builder()
            .baseUrl("http://ì—¬ê¸°ì—-ì‚¬ìš©ì-ìš°ë¶„íˆ¬-ì„œë²„-IPì£¼ì†Œ:3000/")
            .client(okHttpClient)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        apiService = retrofit.create(ApiService::class.java)
    }
    private fun setupUI() {
        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)
        binding.btnSaveDeviceId.setOnClickListener {
            val deviceId = binding.etDeviceId.text.toString().trim()
            if (deviceId.isNotEmpty()) saveDeviceId(deviceId)
        }
    }
    private fun loadDeviceId() {
        val savedId = sharedPreferences.getString("DEVICE_ID", "") ?: ""
        currentDeviceId = savedId
        binding.tvCurrentDeviceId.text = if (savedId.isNotEmpty()) getString(R.string.current_device_id_label, savedId) else getString(R.string.current_device_id_label, getString(R.string.device_id_not_set))
    }
    private fun saveDeviceId(deviceId: String) {
        sharedPreferences.edit().putString("DEVICE_ID", deviceId).apply()
        currentDeviceId = deviceId
        binding.tvCurrentDeviceId.text = getString(R.string.current_device_id_label, deviceId)
        Toast.makeText(this, getString(R.string.device_id_saved_message), Toast.LENGTH_SHORT).show()
    }
    private fun sendRealtimeDataToServer(deviceId: String, lux: Float) {
        val logData = RealtimeLog(deviceId = deviceId, lux = lux)
        apiService.postRealtimeLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (!response.isSuccessful) Log.e("NetworkError", "ì‹¤ì‹œê°„ ì „ì†¡ ì‹¤íŒ¨: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "ì‹¤ì‹œê°„ ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${t.message}")
            }
        })
    }
    private fun sendMinuteDataToServer(deviceId: String, avgLux: Float) {
        val logData = MinuteLog(deviceId = deviceId, avgLux = avgLux)
        apiService.postMinuteLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "1ë¶„ í‰ê·  ì „ì†¡ ì„±ê³µ")
                else Log.e("NetworkError", "1ë¶„ í‰ê·  ì „ì†¡ ì‹¤íŒ¨: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "1ë¶„ í‰ê·  ë„¤íŠ¸ì›Œí¬ ì˜¤ë¥˜: ${t.message}")
            }
        })
    }
}

ì†ŒìŠ¤
pm2 




ë™ì˜ìƒ
