DevExpress의 BarButtonItem은 기본적으로 테두리가 없지만, ItemAppearance 속성을 사용하여 테두리를 추가할 수 있습니다. 모든 버튼에 테두리를 추가하려면 **테두리 색상(BorderColor)**과 **테두리 사용 활성화(Options.UseBorderColor)**를 설정하면 됩니다.

아래는 모든 버튼에 테두리를 추가하는 방법입니다.

모든 버튼에 테두리 추가
전역 변수로 테두리 색상 정의
csharp
코드 복사
private readonly Color DefaultBorderColor = Color.DarkGray; // 기본 테두리 색상
버튼 테두리 설정 함수
csharp
코드 복사
private void ApplyBorderStyle(BarButtonItem button, Color borderColor)
{
    button.ItemAppearance.Normal.BorderColor = borderColor; // 테두리 색상 설정
    button.ItemAppearance.Normal.Options.UseBorderColor = true; // 테두리 활성화
}
모든 버튼에 테두리 적용 (InitializeButtons 수정)
InitializeButtons 함수에서 각 버튼에 테두리를 적용합니다.

csharp
코드 복사
private void InitializeButtons()
{
    foreach (RibbonPage page in ribbonK.Pages)
    {
        foreach (RibbonPageGroup group in page.Groups)
        {
            foreach (BarItemLink link in group.ItemLinks)
            {
                if (link.Item is BarButtonItem button)
                {
                    // 테두리 적용
                    ApplyBorderStyle(button, DefaultBorderColor);

                    // 즐겨찾기 여부에 따른 스타일 지정
                    if (favoriteKeys.Contains(button.Name))
                    {
                        ApplyFavoriteStyle(button, !string.IsNullOrWhiteSpace(currentUserId));
                        AddToFavorites(button, GetButtonGroupName(button));
                    }
                    else
                    {
                        ResetButtonStyle(button);
                    }
                }
            }
        }
    }
}
즐겨찾기 버튼 스타일 함수 수정
즐겨찾기 버튼에 사용자 상태별 테두리 색상을 추가합니다.

csharp
코드 복사
private void ApplyFavoriteStyle(BarButtonItem button, bool isLoggedIn)
{
    Color borderColor = isLoggedIn ? Color.Blue : Color.DarkGray;

    button.ItemAppearance.Normal.BackColor = isLoggedIn ? Color.LightSkyBlue : Color.LightSlateGray;
    button.ItemAppearance.Normal.Options.UseBackColor = true;

    // 테두리 색상 설정
    button.ItemAppearance.Normal.BorderColor = borderColor;
    button.ItemAppearance.Normal.Options.UseBorderColor = true;
}
기본 스타일 초기화 함수 수정
기본 버튼 스타일에서 테두리도 초기화합니다.

csharp
코드 복사
private void ResetButtonStyle(BarButtonItem button)
{
    button.ItemAppearance.Normal.BackColor = Color.Empty;
    button.ItemAppearance.Normal.Options.UseBackColor = false;

    // 테두리 초기화
    button.ItemAppearance.Normal.BorderColor = DefaultBorderColor;
    button.ItemAppearance.Normal.Options.UseBorderColor = true; // 테두리는 유지
}
동작 흐름
테두리 기본 설정:

InitializeButtons 호출 시 모든 버튼에 DefaultBorderColor를 적용.
즐겨찾기 스타일 적용:

ApplyFavoriteStyle로 로그인 상태에 따라 테두리 색상을 설정.
기본 스타일 복구:

ResetButtonStyle로 기본 테두리와 배경색 복구.
테스트 결과
모든 버튼에 테두리가 적용됩니다.
기본 테두리 색상: DefaultBorderColor.
즐겨찾기 버튼은 사용자 상태에 따라 다른 테두리 색상이 적용됩니다.
로그인: 파란 테두리.
로그아웃: 어두운 회색 테두리.
이제 모든 버튼에 테두리가 추가됩니다. 테두리 스타일을 더 커스터마이즈하거나 추가 요청이 있다면 알려주세요! 😊






나의 말:
바버튼아이템 테두린데,,전혀 색상이안칠해져 검정색인데,,두께줘야되냐?
ChatGPT의 말:
ChatGPT
DevExpress BarButtonItem에서 테두리의 색상이 검정색으로만 보이는 경우, 테두리 두께를 설정할 수 있는 직접적인 옵션은 없습니다. 하지만 테두리를 두껍게 표시하거나 색상을 더 강조하려면 CustomDraw 이벤트를 활용하여 버튼의 드로잉을 사용자 정의해야 합니다.

CustomDraw로 테두리 두께와 색상 설정
BarManager의 CustomDraw 이벤트 처리
csharp
코드 복사
private void ribbonK_Manager_ItemDraw(object sender, DevExpress.XtraBars.ViewInfo.DrawItemEventArgs e)
{
    // BarButtonItem에만 적용
    if (e.Item is BarButtonItem button)
    {
        // 테두리 색상과 두께 설정
        Color borderColor = Color.Blue; // 원하는 테두리 색상
        int borderWidth = 2; // 원하는 테두리 두께

        using (var pen = new Pen(borderColor, borderWidth))
        {
            e.Graphics.DrawRectangle(pen, e.Bounds);
        }

        // 기본 버튼 그리기
        e.DefaultDraw();
    }
}
적용 방법
CustomDraw 이벤트 연결:

리본 컨트롤의 BarManager 또는 RibbonControl의 ItemDraw 이벤트에 위 함수를 연결합니다.
csharp
코드 복사
ribbonK.Manager.ItemDraw += ribbonK_Manager_ItemDraw;
테두리 색상 및 두께 설정:

borderColor: 원하는 테두리 색상을 설정합니다.
borderWidth: 테두리 두께를 픽셀 단위로 설정합니다.
동작 흐름
CustomDraw 이벤트 트리거:

DevExpress가 버튼을 그릴 때마다 ribbonK_Manager_ItemDraw 이벤트가 호출됩니다.
테두리 커스터마이징:

DrawRectangle을 사용해 테두리 색상과 두께를 직접 설정.
기본 버튼 유지:

e.DefaultDraw() 호출로 기본 버튼 스타일 유지.
결과
테두리 색상이 Color.Blue로 설정되고, 두께가 2픽셀로 표시됩니다.
DevExpress 기본 스타일과 충돌 없이 테두리만 커스터마이징됩니다.
참고 사항
**DrawRectangle**로 커스터마이징한 드로잉은 버튼에 호버하거나 클릭할 때도 유지됩니다.