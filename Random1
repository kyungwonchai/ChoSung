C와 통신할 때, %로 시작하는 프리 응답을 먼저 받고, 그 뒤에 본격적인 응답을 처리해야 하는 시나리오를 처리하는 C# 코드를 예시로 작성해드리겠습니다. 이 코드는 WPF MVVM 패턴을 기반으로 하고, 통신 관련 처리를 별도의 클래스에서 처리합니다.

1. 통신 클래스 (PlcCommunication.cs)
이 클래스는 PLC와의 통신을 처리하며, %로 시작하는 응답을 필터링한 후 본격적인 응답을 처리합니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Threading.Tasks;

public class PlcCommunication
{
    private SerialPort _serialPort;
    private Action<string> _responseCallback; // 본격 응답을 처리할 콜백

    public PlcCommunication(Action<string> responseCallback)
    {
        _responseCallback = responseCallback;

        // SerialPort 설정 (COM 포트와 통신 속도는 외부 설정에 맞게 조정)
        _serialPort = new SerialPort("COM1", 9600);
        _serialPort.DataReceived += OnDataReceived;
        _serialPort.Open();
    }

    // 데이터를 받았을 때 처리하는 메서드
    private void OnDataReceived(object sender, SerialDataReceivedEventArgs e)
    {
        Task.Run(() =>
        {
            string data = _serialPort.ReadExisting(); // 수신한 데이터

            // %로 시작하는 응답은 무시하고 본격적인 응답만 처리
            if (!data.StartsWith("%"))
            {
                _responseCallback.Invoke(data); // 응답을 ViewModel 등으로 전달
            }
        });
    }

    // PLC에 명령을 보내는 메서드
    public void SendCommand(string command)
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.WriteLine(command);
        }
    }

    public void Close()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }
}
2. ViewModel 클래스 (PlcViewModel.cs)
이 클래스는 View와 통신 클래스를 연결하는 역할을 합니다. 본격적인 응답이 오면 UI에 업데이트합니다.

csharp
코드 복사
using System.ComponentModel;

public class PlcViewModel : INotifyPropertyChanged
{
    private PlcCommunication _plcCommunication;

    private string _responseMessage;
    public string ResponseMessage
    {
        get => _responseMessage;
        set
        {
            _responseMessage = value;
            OnPropertyChanged(nameof(ResponseMessage));
        }
    }

    public PlcViewModel()
    {
        // PLC 통신 클래스를 초기화하고, 응답 콜백 설정
        _plcCommunication = new PlcCommunication(OnPlcResponseReceived);
    }

    // PLC에서 응답을 받을 때 처리하는 콜백 메서드
    private void OnPlcResponseReceived(string response)
    {
        // UI에 응답을 업데이트
        ResponseMessage = $"PLC 응답: {response}";
    }

    // PLC에 명령을 보내는 메서드
    public void SendCommandToPlc(string command)
    {
        _plcCommunication.SendCommand(command);
    }

    public void CloseConnection()
    {
        _plcCommunication.Close();
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
3. XAML View (MainWindow.xaml)
View는 ViewModel과 바인딩되어, PLC에서 수신한 데이터를 실시간으로 UI에 표시합니다.

xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC 통신" Height="350" Width="525">
    <Grid>
        <TextBlock Text="{Binding ResponseMessage}" HorizontalAlignment="Center" VerticalAlignment="Center" FontSize="16"/>
        <Button Content="Send Command" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Command="{Binding SendCommandCommand}"/>
    </Grid>
</Window>
4. 연결 및 명령 전송 예시
View에서 버튼을 눌러 PLC에 명령을 전송하고, PLC로부터 응답을 받으면 UI에 출력됩니다.

%로 시작하는 응답은 무시되고, 본격적인 응답만 ResponseMessage에 표시됩니다.
명령을 전송할 때는 SendCommandToPlc 메서드를 호출하면 됩니다.
이 코드는 기본적인 시나리오를 커버하지만, 실제로는 더 복잡한 에러 처리와 비동