먼저, 주신 사항을 다시 요약해 보면:

센서 체크 후에만 적재/배출 작업이 이루어져야 한다는 요청이 있었고,
적재/배출 작업은 순차적으로 대기 상태로 작업 큐에 쌓인 순서대로 처리되어야 한다는 내용이 있습니다.
이를 기반으로, 전체적으로 코드를 수정하고 ProcessLogLine 함수부터 시작하여 적재와 배출 작업이 센서 체크 이후에 순차적으로 처리되는 구조를 만들어 드리겠습니다. 그리고 모든 동작이 비동기적으로 이루어지도록 하여 작업이 중복되거나 동시에 처리되지 않도록 보장하겠습니다.

코드 개선 목표:
작업 큐에 쌓인 작업이 먼저 처리되고, 다음 작업은 해당 작업이 완료된 후에 수행되도록 할 것.
센서 체크를 먼저 진행하고, 센서가 정상적으로 동작한 후에만 배출 또는 적재 작업이 실행되도록 할 것.
비동기적 처리를 사용하여 작업들이 대기 중에도 UI가 멈추지 않도록 구현.
작업 진행 상황을 로그로 기록하며, UI에 실시간으로 표시되도록 구현.
수정된 전체 코드 (상세 설명 포함)
csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;

namespace GumiChecker
{
    public class FileCheckerMES20
    {
        private readonly string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일 경로
        private readonly string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$"; // 로그 파일 이름 패턴
        private string _currentMonitoredFile; // 현재 감시 중인 파일 경로
        private long _lastPlanSelectedPosition = 0; // 파일 내 마지막 PLAN Selected 위치
        private DateTime _lastWriteTime; // 파일이 마지막으로 수정된 시간
        private bool _isProcessingTask = false; // 현재 작업 처리 중인지 여부

        private ProductOrderModel _currentProductOrder; // 현재 처리 중인 주문 정보
        private ProductOrderModel _previousProductOrder; // 이전에 처리된 주문 정보

        private ObservableCollection<ProductOrderModel> _productOrders; // 주문 목록 (UI와 바인딩됨)
        private ObservableCollection<string> _taskList; // 작업 상태 목록 (UI와 바인딩됨)
        private ConcurrentQueue<string> _taskQueue = new ConcurrentQueue<string>(); // 비동기 작업 큐
        private ComportManager _comPortPLC; // PLC와의 통신 매니저
        private const int _R520SensorTimeout = 180000; // R520/R521 센서 감지 타임아웃 (3분)

        // 생성자: 의존성을 주입하고 초기 설정을 수행
        public FileCheckerMES20(ObservableCollection<ProductOrderModel> productOrders, ComportManager comPortManager, ObservableCollection<string> taskList)
        {
            _productOrders = productOrders; // 주문 목록 초기화
            _comPortPLC = comPortManager; // PLC 통신 객체 초기화
            _taskList = taskList; // 작업 상태 리스트 초기화

            // 현재 감시할 최신 로그 파일 설정
            _currentMonitoredFile = GetLatestLogFile();
            _lastWriteTime = _currentMonitoredFile != null
                ? File.GetLastWriteTime(_currentMonitoredFile)
                : DateTime.MinValue;

            // 첫 실행 시 로그 파일 내 PLAN Selected 위치 찾기
            FindLastPlanSelected(_currentMonitoredFile);
        }

        // 최신 로그 파일을 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 파일 경로에서 가장 최신 로그 파일을 검색
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern))
                .OrderByDescending(f => f.LastWriteTime)
                .ToList();

            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일에서 마지막 PLAN Selected 위치를 찾는 메소드
        private void FindLastPlanSelected(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 바로 종료

            // 파일을 읽기 전용 모드로 열고 다른 프로세스가 쓸 수 있도록 공유 설정
            using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
            using (var streamReader = new StreamReader(fileStream))
            {
                string line;
                long currentPosition = 0;

                // 파일 내의 각 줄을 순차적으로 읽으면서 PLAN Selected 탐색
                while ((line = streamReader.ReadLine()) != null)
                {
                    currentPosition = fileStream.Position; // 현재 파일 포인터 위치

                    if (line.Contains("PLAN Selected"))
                    {
                        _lastPlanSelectedPosition = currentPosition; // PLAN Selected 위치 저장
                    }

                    ProcessLogLine(line, filePath, false); // 첫 실행 시 실제 작업 처리 없이 표에만 표시
                }
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드 (비동기 방식으로 처리)
        private async Task ProcessLogLineAsync(string line, string filePath)
        {
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 파일명에서 날짜 추출
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도 및 월
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 날짜 조합

            // 로그 행에서 시간값(시분초.밀리초)을 추출
            string timestamp = ExtractTimestamp(line);

            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' ');
                string productOrder = splitLine[1];

                if (timestamp != null)
                {
                    string fullDateTime = fullDate + " " + timestamp;

                    // 새로운 주문이거나 다른 주문일 경우 처리
                    if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                    {
                        // 이전 주문이 있는 경우 배출 처리
                        if (_previousProductOrder != null)
                        {
                            // 배출 함수는 센서 체크 이후에 동작하도록 함
                            if (await MonitorSensorsAsync()) // 센서 체크 먼저 수행
                            {
                                _previousProductOrder.POStatus = "out";
                                await ExecuteOutFunction(_previousProductOrder); // 배출 작업 처리
                            }
                            else
                            {
                                _taskList.Add("센서 체크 실패로 배출 중단");
                            }
                        }

                        // 새로운 주문 생성 및 상태 추가
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder,
                            PDate = fullDateTime,
                            POStatus = "wait"
                        };

                        _previousProductOrder = _currentProductOrder; // 현재 주문을 이전 주문으로 설정
                        _productOrders.Add(_currentProductOrder); // 주문 목록에 추가
                    }
                }
            }
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                // FNL^ 감지 시 적재 상태로 전환
                _currentProductOrder.POStatus = "stack";

                // 적재 함수는 센서 체크 이후에 동작하도록 함
                if (await MonitorSensorsAsync()) // 센서 체크 먼저 수행
                {
                    await ExecuteStackFunction(_currentProductOrder); // 적재 작업 처리
                }
                else
                {
                    _taskList.Add("센서 체크 실패로 적재 중단");
                }
            }
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                // BasicModel 감지 시 주문의 모델 정보를 업데이트
                var modelData = line.Split(':')[1].Trim();
                _currentProductOrder.BasicModel = modelData;
            }
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                // MB^ 감지 시 잔여 수량 및 매거진 수량을 업데이트
                var mbData = line.Split('^');
                _currentProductOrder.PORemain = int.Parse(mbData[1]);
                _currentProductOrder.MGCount = int.Parse(mbData[2]);
            }
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                // JB^ 감지 시 생산된 제품 개수를 증가시킴
                _currentProductOrder.PCount++;
            }
        }

        // 시간값을 추출하는 함수 (시분초와 밀리초 분리)
        private string ExtractTimestamp(string line)
        {
            var match = Regex.Match(line, @"\[(\d{6})\.(\d{3})\]");
            if (match.Success)
            {
                string timePart = match.Groups[1].Value;
                string millisPart = match.Groups[2].Value;

                string hours = timePart.Substring(0, 2);
                string minutes = timePart.Substring(2, 2);
                string seconds = timePart.Substring(4, 2);

                return $"{hours}:{minutes}:{seconds}.{millisPart}";
            }
            return null;
        }

        // 배출 작업을 처리하는 비동기 메소드 (센서 체크 후 배출)
        private async Task ExecuteOutFunction(ProductOrderModel order)
        {
            _taskList.Add($"배출 작업 대기: {order.ProductOrder}");

            _taskQueue.Enqueue($"배출: {order.ProductOrder}"); // 작업을 큐에 넣음
            await ProcessQueueAsync(); // 큐 작업 처리
        }

        // 적재 작업을 처리하는 비동기 메소드 (센서 체크 후 적재)
        private async Task ExecuteStackFunction(ProductOrderModel order)
        {
            _taskList.Add($"적재 작업 대기: {order.ProductOrder}");

            _taskQueue.Enqueue($"적재: {order.ProductOrder}"); // 작업을 큐에 넣음
            await ProcessQueueAsync(); // 큐 작업 처리
        }

        // 큐에서 작업을 처리하는 비동기 메소드
        private async Task ProcessQueueAsync()
        {
            _isProcessingTask = true;

            while (_taskQueue.TryDequeue(out string task))
            {
                _taskList.Add($"처리 시작: {task}");
                string[] taskParts = task.Split(':');
                string taskType = taskParts[0].Trim();
                string productOrder = taskParts[1].Trim();

                if (taskType == "적재")
                {
                    await ProcessStackAsync(productOrder); // 적재 작업 처리
                }
                else if (taskType == "배출")
                {
                    await ProcessOutAsync(productOrder); // 배출 작업 처리
                }

                _taskList.Add($"처리 완료: {task}");
            }

            _isProcessingTask = false;
        }

        // 적재 작업을 처리하는 메소드 (비동기)
        private async Task ProcessStackAsync(string productOrder)
        {
            _taskList.Add($"PLC 적재 신호 전송: {productOrder}");

            // PLC에 적재 신호 전송
            bool isCommandSent = SendStackCommandToPLC();

            if (isCommandSent)
            {
                _taskList.Add($"WD13 응답 대기: {productOrder}");
                bool isWD13Response = await WaitForWD13ResponseAsync();
                if (isWD13Response)
                {
                    _taskList.Add($"WD13 응답 완료: {productOrder}");
                    bool isSensorSuccess = await MonitorSensorsAsync();
                    if (isSensorSuccess)
                    {
                        _taskList.Add($"적재 완료: {productOrder}");
                    }
                    else
                    {
                        _taskList.Add($"적재 실패(3분 초과): {productOrder}");
                        ShowError($"적재 실패: {productOrder} (3분 내 감지되지 않음)");
                    }
                }
                else
                {
                    _taskList.Add($"WD13 응답 실패: {productOrder}");
                    ShowError($"WD13 응답 실패: {productOrder}");
                }
            }
        }

        // 센서 감시 함수 (R520, R521 센서 감시)
        private async Task<bool> MonitorSensorsAsync()
        {
            var startTime = DateTime.Now;

            // 3분간 센서 감시
            while ((DateTime.Now - startTime).TotalMilliseconds < _R520SensorTimeout)
            {
                bool isR520Detected = ReadSensor("R520");
                bool isR521Detected = ReadSensor("R521");

                if (isR520Detected)
                {
                    _taskList.Add("R520 감지됨");

                    // R520 꺼짐 대기
                    while (!ReadSensor("R520"))
                    {
                        await Task.Delay(100);
                    }

                    _taskList.Add("R520 꺼짐 확인");

                    if (isR521Detected)
                    {
                        _taskList.Add("R521 감지됨");
                        return true;
                    }
                }

                await Task.Delay(100);
            }

            return false;
        }

        // PLC에 적재 신호 전송 함수 (가정된 구현)
        private bool SendStackCommandToPLC()
        {
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // WD13 응답 대기 함수 (비동기)
        private async Task<bool> WaitForWD13ResponseAsync()
        {
            await Task.Delay(2000); // 예시로 2초 대기
            return true;
        }

        // 에러 처리 함수
        private void ShowError(string message)
        {
            msgvs.Instance.LogT2(message); // 에러 메시지 기록
        }
    }

    // ProductOrderModel: 제품 주문 정보를 담고 있으며 UI와 데이터 바인딩을 지원
    public class ProductOrderModel : INotifyPropertyChanged
    {
        private string _productOrder;
        private string _basicModel;
        private int _poRemain;
        private int _mgCount;
        private int _pCount;
        private string _poStatus;
        private string _pDate;

        public string ProductOrder
        {
            get => _productOrder;
            set
            {
                _productOrder = value;
                OnPropertyChanged(nameof(ProductOrder));
            }
        }

        public string BasicModel
        {
            get => _basicModel;
            set
            {
                _basicModel = value;
                OnPropertyChanged(nameof(BasicModel));
            }
        }

        public int PORemain
        {
            get => _poRemain;
            set
            {
                _poRemain = value;
                OnPropertyChanged(nameof(PORemain));
            }
        }

        public int MGCount
        {
            get => _mgCount;
            set
            {
                _mgCount = value;
                OnPropertyChanged(nameof(MGCount));
            }
        }

        public int PCount
        {
            get => _pCount;
            set
            {
                _pCount = value;
                OnPropertyChanged(nameof(PCount));
            }
        }

        public string POStatus
        {
            get => _poStatus;
            set
            {
                _poStatus = value;
                OnPropertyChanged(nameof(POStatus));
            }
        }

        public string PDate
        {
            get => _pDate;
            set
            {
                _pDate = value;
                OnPropertyChanged(nameof(PDate));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // UI 업데이트를 위한 이벤트 호출
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항:
비동기 작업 큐: 작업이 큐에 쌓이고, 순차적으로 하나씩 실행되도록 하였습니다. 새로운 작업이 큐에 추가될 때 이전 작업이 완료된 후에만 실행됩니다.
센서 체크 로직 추가: MonitorSensorsAsync() 함수를 통해 적재나 배출 작업이 실행되기 전에 반드시 센서 감지가 이루어지도록 하였습니다.
센서 감지 실패 시 작업 중단: 센서가 정상적으로 동작하지 않으면 적재 및 배출 작업이 진행되지 않으며, 로그에 기록됩니다.
이 코드로 센서 감지 작업 후 적재/배출 작업이 순차적으로 실행되며, 모든 작업이 비동기적으로 처리되어 성능을 보장할 수 있습니다.