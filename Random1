아래는 RouterMiddleACR 프로젝트의 기존 기능을 유지하면서, 코드를 최적화하고 단일 애플리케이션으로 통합한 예제입니다. 서비스와 UI를 분리하지 않고, 하나의 애플리케이션에서 모든 기능을 처리하도록 하였습니다. 기존의 기능을 모두 포함하고, 코드의 가독성을 높이기 위해 함수형 패턴을 적용하였습니다.

MainWindow.xaml
이 파일은 사용자 인터페이스(UI)를 정의합니다. 여기에는 로그를 표시하는 ListBox, PLC 데이터를 전송하는 버튼, 상태 표시 등을 포함합니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="RouterMiddleACR" Height="600" Width="800"
        Closing="Window_Closing">
    <Grid>
        <!-- 로그를 출력하는 ListBox -->
        <ListBox x:Name="LogListBox" HorizontalAlignment="Stretch" VerticalAlignment="Top" Height="400" Margin="10"/>

        <!-- 버튼과 텍스트박스를 배치하기 위한 StackPanel -->
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="10">
            <!-- PLC 데이터를 전송하는 버튼 예시 -->
            <Button Content="Send PLC Data" Width="100" Height="30" Margin="5" Click="SendPLCData_Click"/>
            <!-- 텍스트 박스 예시 -->
            <TextBox x:Name="InputTextBox" Width="200" Height="30" Margin="5"/>
            <!-- 서비스 상태 표시 -->
            <TextBlock x:Name="ServiceStatusTextBlock" Text="Service Status: Unknown" Margin="10,0,0,0"/>
            <!-- 시작 버튼 -->
            <Button Content="Start Service" Width="100" Height="30" Margin="5" Click="StartService_Click"/>
            <!-- 중지 버튼 -->
            <Button Content="Stop Service" Width="100" Height="30" Margin="5" Click="StopService_Click"/>
        </StackPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
이 파일은 애플리케이션의 모든 로직을 포함합니다. 모든 기능이 하나의 클래스에 통합되어 있어, 코드의 가독성을 높이고 관리하기 쉽게 하였습니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private SerialPort _serialPort; // 시리얼 포트 객체
        private Dictionary<string, int> _memory; // PLC의 메모리 시뮬레이션
        private Dictionary<string, string> _stringMemory; // 문자열을 저장하는 메모리 시뮬레이션
        private DispatcherTimer _serviceCheckTimer; // 서비스 상태 체크를 위한 타이머

        public MainWindow()
        {
            InitializeComponent();

            // PLC 메모리 초기화
            InitializeMemory();

            // 시리얼 포트 초기화
            InitializeSerialPort("COM3"); // COM3 포트를 사용 예시

            // 서비스 상태 체크 타이머 초기화
            InitializeServiceCheckTimer();
        }

        // PLC 메모리를 초기화하는 메서드
        private void InitializeMemory()
        {
            _memory = new Dictionary<string, int>
            {
                { "D2300", 0 },
                { "D2330", 0 },
                { "R520", 0 },
                { "R521", 0 }
            };

            _stringMemory = new Dictionary<string, string>
            {
                { "D2310", string.Empty }
            };
        }

        // 시리얼 포트를 초기화하는 메서드
        private void InitializeSerialPort(string portName)
        {
            _serialPort = new SerialPort(portName, 9600, Parity.None, 8, StopBits.One);
            _serialPort.DataReceived += SerialPort_DataReceived; // 데이터 수신 이벤트 핸들러 등록
            _serialPort.Open(); // 시리얼 포트 열기
        }

        // 서비스 상태 체크 타이머를 초기화하는 메서드
        private void InitializeServiceCheckTimer()
        {
            _serviceCheckTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(5)
            };
            _serviceCheckTimer.Tick += CheckServiceStatus; // 타이머 틱 이벤트 핸들러 등록
            _serviceCheckTimer.Start(); // 타이머 시작
        }

        // 서비스 상태를 주기적으로 체크하는 메서드
        private void CheckServiceStatus(object sender, EventArgs e)
        {
            // 서비스 상태 확인 로직 구현
            bool isServiceRunning = CheckIfServiceRunning();
            UpdateServiceStatus(isServiceRunning);
        }

        // 서비스 상태를 확인하는 메서드 (예시로 랜덤 상태 반환)
        private bool CheckIfServiceRunning()
        {
            // 실제 서비스 상태 확인 로직 구현 필요
            return new Random().Next(0, 2) == 1;
        }

        // 서비스 상태에 따라 UI를 업데이트하는 메서드
        private void UpdateServiceStatus(bool isRunning)
        {
            ServiceStatusTextBlock.Text = isRunning ? "Service Status: Running" : "Service Status: Stopped";
        }

        // 시리얼 포트로 수신된 데이터를 처리하는 메서드
        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            string data = _serialPort.ReadExisting(); // 수신된 데이터를 ASCII로 읽기
            ProcessReceivedData(data);
        }

        // 수신된 데이터를 처리하는 메서드
        private void ProcessReceivedData(string data)
        {
            LogMessage($"Received: {data}");

            // ASCII 형식의 명령 처리 로직
            if (data.Contains("WDD"))
            {
                if (data.Contains("D2300"))
                {
                    var value = ExtractValueFromCommand(data);
                    WriteDataToPLC("D2300", value);
                    WriteDataToPLC("D2330", value);
                }
            }

            if (data.Contains("WDS"))
            {
                if (data.Contains("D2310"))
                {
                    var value = ExtractStringFromCommand(data);
                    WriteStringToPLC("D2310", value);
                }
            }
        }

        // PLC 메모리에 데이터를 쓰는 메서드
        private void WriteDataToPLC(string address, int value)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = value;
                LogMessage($"Data written to {address}: {value}");
            }
        }

        // PLC 메모리에 문자열 데이터를 쓰는 메서드
        private void WriteStringToPLC(string address, string value)
        {
            if (_stringMemory.ContainsKey(address))
            {
                _stringMemory[address] = value.Length > 20 ? value.Substring(0, 20) : value;
                LogMessage($"String written to {address}: {_stringMemory[address]}");
            }
        }

        // 명령에서 값을 추출하는 메서드
        private int ExtractValueFromCommand(string command)
        {
            string valueString = command.Substring(command.Length - 4);
            return int.TryParse(valueString, out int value) ? value : 0;
        }

        // 명령에서 문자열을 추출하는 메서드
        private string ExtractStringFromCommand(string command)
        {
            string valueString = command.Substring(8); // 시작 위치 조정 필요
            return valueString;
        }

        // 로그 메시지를 UI에 출력하는 메서드
        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() =>
            {
                LogListBox.Items.Add(message); // ListBox에 로그 메시지 추가
                LogListBox.ScrollIntoView(LogListBox.Items[LogListBox.Items.Count - 1]); // 항상 마지막 항목으로 스크롤
            });
        }

        // "Start Service" 버튼 클릭 이벤트 핸들러
        private void StartService_Click(object sender, RoutedEventArgs e)
        {
            LogMessage("서비스 시작");
            // 서비스 시작 로직 구현 필요
        }

        // "Stop Service" 버튼 클릭 이벤트 핸들러
        private void StopService_Click(object sender, RoutedEventArgs e)
        {
            LogMessage("서비스 중지");
            // 서비스 중지 로직 구현 필요
        }

        // "Send PLC Data" 버튼 클릭 이벤트 핸들러
        private void SendPLCData_Click(object sender, RoutedEventArgs e)
        {
            string dataToSend = InputTextBox.Text;
            _serialPort.WriteLine(dataToSend); // 입력된 데이터를 시리얼 포트를 통해 전송
            LogMessage($"Sent data: {dataToSend}");
        }

        // 윈도우 닫기 시 포트 닫기
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _serialPort.Close(); // 시리얼 포트 닫기
        }
    }
}
주요 변경 사항과 설명
파일 구조 단순화:

모든 기능을 MainWindow.xaml.cs 파일 하나에 통합하였습니다. 서비스와 UI를 분리하지 않고, 하나의 애플리케이션에서 모든 기능을 처리하도록 하였습니다.
PLC 메모리 및 문자열 처리:

PLC 메모리를 시뮬레이션하기 위해 딕셔너리를 사용하였으며, 문자열 데이터를 처리할 수 있도록 추가했습니다.
시리얼 포트 통신:

시리얼 포트를 통해 PLC와 통신하며, 데이터를 수신하고 처리합니다.
로그 메시지 출력:

LogMessage 메서드를 사용하여 모든 로그 메시지를 UI의 ListBox에 출력합니다.
명령 처리 로직:

ProcessReceivedData 메서드를 통해 ASCII 형식의 명령을 처리하고, 메모리에 데이터를 쓰거나 문자열을 저장합니다.
서비스 상태 체크:

DispatcherTimer를 사용하여 주기적으로 서비스 상태를 확인하고, UI에 표시합니다.
이 코드 구조는 프로젝트의 복잡성을 줄이고, 필수 기능을 하나의 파일에 집중시켜 관리하기 쉽게 만들었습니다. 이를 통해 유지보수와 확장이 더 쉬워졌습니다