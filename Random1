알겠습니다. 요청하신 대로 전체 솔루션 구조와 코드에 다양한 추가 기능을 포함하여 기존 코드와 주석, 설명을 제공하겠습니다. 각 기능은 언제, 왜 사용하는지 설명을 포함하고, 예제 코드를 통해 응용할 수 있는 방법도 제시하겠습니다.

전체 솔루션 구조
1. RouterMiddleACR (WPF 클라이언트 애플리케이션)
이 프로젝트는 사용자 인터페이스(UI)를 제공하며, Windows Service와 상호작용하여 서비스를 제어하고 실시간으로 로그를 수신합니다.

2. RouterMiddleACRService (Windows Service 애플리케이션)
이 프로젝트는 백그라운드에서 파일 감시와 데이터를 처리하며, 발생하는 로그를 Named Pipes를 통해 WPF 클라이언트에 전송합니다.

솔루션 1: RouterMiddleACR (WPF 클라이언트 애플리케이션)
프로젝트 구조
arduino
코드 복사
RouterMiddleACR
├── RouterMiddleACR.sln                  // 솔루션 파일
└── RouterMiddleACR
    ├── App.xaml                         // 애플리케이션 진입점 및 리소스 정의
    ├── App.xaml.cs                      // 애플리케이션 초기화 코드
    ├── MainWindow.xaml                  // 메인 UI 정의
    ├── MainWindow.xaml.cs               // 메인 UI 코드 비하인드
    ├── ViewModels
    │   └── MainViewModel.cs             // 데이터 바인딩 및 서비스 제어 로직
    └── Services
        ├── ServiceControllerHelper.cs   // Windows Service와 상호작용하는 헬퍼 클래스
        └── AdditionalFunctions.cs       // 추가 기능을 위한 헬퍼 클래스
1. App.xaml
WPF 애플리케이션의 진입점 및 리소스를 정의하는 파일입니다.

xml
코드 복사
<Application x:Class="RouterMiddleACR.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <!-- 전역 리소스 및 스타일 정의 -->
    </Application.Resources>
</Application>
2. App.xaml.cs
애플리케이션 초기화 및 시작 시 실행되는 코드입니다.

csharp
코드 복사
using System.Windows;

namespace RouterMiddleACR
{
    public partial class App : Application
    {
        // 애플리케이션이 시작될 때 호출되는 메서드
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
        }
    }
}
3. MainWindow.xaml
메인 UI 레이아웃을 정의하는 XAML 파일입니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Router Middle ACR" Height="600" Width="800">
    <Grid>
        <StackPanel Orientation="Vertical" Background="Lavender">
            <TextBlock Text="Router Middle ACR" FontSize="24" FontWeight="Bold" HorizontalAlignment="Center" Margin="10"/>
            
            <!-- 서비스 상태 표시 및 제어 버튼들 -->
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                <Button Content="Start Service" Click="StartService_Click" Margin="5"/>
                <Button Content="Stop Service" Click="StopService_Click" Margin="5"/>
                <Button Content="Refresh Status" Click="RefreshStatus_Click" Margin="5"/>
                <Button Content="Update Service" Click="UpdateService_Click" Margin="5"/>
            </StackPanel>

            <!-- 서비스 상태를 표시하는 텍스트 블록 -->
            <TextBlock Text="{Binding ServiceStatus}" FontSize="18" FontWeight="Bold" HorizontalAlignment="Center" Margin="10"/>
            
            <!-- 실시간 로그를 표시할 리스트박스 -->
            <ListBox ItemsSource="{Binding LogMessages}" Height="200" Margin="10"/>

            <!-- 추가 기능 버튼들 -->
            <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" Margin="10">
                <Button Content="Check System Health" Click="CheckHealth_Click" Margin="5"/>
                <Button Content="Backup Data" Click="BackupData_Click" Margin="5"/>
                <Button Content="Export Logs" Click="ExportLogs_Click" Margin="5"/>
            </StackPanel>
        </StackPanel>
    </Grid>
</Window>
4. MainWindow.xaml.cs
메인 윈도우의 이벤트 핸들러와 로그 수신을 처리하는 코드 비하인드 파일입니다.

csharp
코드 복사
using System;
using System.IO.Pipes;
using System.Threading.Tasks;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;
        private NamedPipeClientStream _pipeClient;
        private StreamReader _pipeReader;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;

            StartListeningToLogs(); // 로그 수신을 시작
        }

        // Named Pipe를 통해 서비스로부터 로그를 수신하는 메서드
        private void StartListeningToLogs()
        {
            Task.Run(() =>
            {
                try
                {
                    // Named Pipe 클라이언트를 생성하고 연결
                    _pipeClient = new NamedPipeClientStream(".", "RouterMiddleACRLogPipe", PipeDirection.In);
                    _pipeClient.Connect();

                    _pipeReader = new StreamReader(_pipeClient);

                    // 로그 메시지를 지속적으로 읽어와서 UI에 표시
                    while (true)
                    {
                        var message = _pipeReader.ReadLine();
                        if (message != null)
                        {
                            Dispatcher.Invoke(() => _viewModel.LogMessages.Add(message));
                        }
                    }
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
                }
            });
        }

        private void StartService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StartService();
        }

        private void StopService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StopService();
        }

        private void RefreshStatus_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.RefreshServiceStatus();
        }

        private void UpdateService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.UpdateService();
        }

        private void CheckHealth_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.CheckSystemHealth(); // 시스템 상태 확인
        }

        private void BackupData_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.BackupData(); // 데이터 백업
        }

        private void ExportLogs_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.ExportLogs(); // 로그 내보내기
        }
    }
}
5. ViewModels/MainViewModel.cs
MVVM 패턴을 사용하여 UI와 데이터를 바인딩하며, 서비스 제어 로직을 포함하는 ViewModel 클래스입니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using RouterMiddleACR.Services;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ServiceControllerHelper _serviceControllerHelper;
        private string _serviceStatus;
        private AdditionalFunctions _additionalFunctions;

        // 로그 메시지를 저장할 ObservableCollection
        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();

        public string ServiceStatus
        {
            get => _serviceStatus;
            set
            {
                _serviceStatus = value;
                OnPropertyChanged(nameof(ServiceStatus));
            }
        }

        public MainViewModel()
        {
            _serviceControllerHelper = new ServiceControllerHelper();
            _additionalFunctions = new AdditionalFunctions();
            RefreshServiceStatus();
        }

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            _serviceControllerHelper.StartService();
            RefreshServiceStatus();
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            _serviceControllerHelper.StopService();
            RefreshServiceStatus();
        }

        // 서비스 상태를 갱신하는 메서드
        public void RefreshServiceStatus()
        {
            ServiceStatus = _serviceControllerHelper.GetServiceStatus();
        }

        // 서비스를 업데이트하는 메서드
        public void UpdateService()
        {
            _serviceControllerHelper.UpdateService();
            RefreshServiceStatus();
        }

        // 시스템 상태를 확인하는 메서드
        public void CheckSystemHealth()
        {
            LogMessages.Add("Checking system health...");
            var healthStatus = _additionalFunctions.CheckSystemHealth();
            LogMessages.Add(healthStatus ? "System is healthy." : "System has some issues.");
        }

        // 데이터를 백업하는 메서드
        public void BackupData()
        {
            LogMessages.Add("Backing up data...");
            _additionalFunctions.BackupData();
            LogMessages.Add("Data backup completed.");
        }

        // 로그를 내보내는 메서드
        public void ExportLogs()
        {
            LogMessages.Add("Exporting logs...");
            _additionalFunctions.ExportLogs();
            LogMessages.Add("Logs exported successfully.");
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
6. Services/ServiceControllerHelper.cs
Windows Service와 상호작용하기 위한 헬퍼 클래스입니다. 이 클래스는 서비스를 시작, 중지, 상태 조회, 업데이트하는 기능을 제공합니다.

csharp
코드 복사
using System.ServiceProcess;
using System.IO;

namespace RouterMiddleACR.Services
{
    public class ServiceControllerHelper
    {
        private string _serviceName = "RouterMiddleACRService"; // 서비스 이름
        private string _serviceExePath = @"C:\Program Files\RouterMiddleACRService\RouterMiddleACRService.exe"; // 서비스 실행 파일 경로
        private string _serviceUpdateSourcePath = @"C:\UpdateSource\RouterMiddleACRService.exe"; // 업데이트할 새로운 서비스 파일 경로

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            using (var sc = new ServiceController(_serviceName))
            {
                if (sc.Status == ServiceControllerStatus.Stopped)
                {
                    sc.Start();
                    sc.WaitForStatus(ServiceControllerStatus.Running);
                }
            }
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            using (var sc = new ServiceController(_serviceName))
            {
                if (sc.Status == ServiceControllerStatus.Running)
                {
                    sc.Stop();
                    sc.WaitForStatus(ServiceControllerStatus.Stopped);
                }
            }
        }

        // 서비스 상태를 가져오는 메서드
        public string GetServiceStatus()
        {
            using (var sc = new ServiceController(_serviceName))
            {
                return sc.Status.ToString();
            }
        }

        // 서비스를 업데이트하는 메서드
        public void UpdateService()
        {
            StopService(); // 서비스를 중지

            // 서비스 파일 교체
            if (File.Exists(_serviceUpdateSourcePath))
            {
                File.Copy(_serviceUpdateSourcePath, _serviceExePath, true); // 새 파일로 교체
            }

            StartService(); // 서비스를 다시 시작
        }
    }
}
7. Services/AdditionalFunctions.cs
추가 기능을 구현한 헬퍼 클래스입니다. 예를 들어, 시스템 상태 확인, 데이터 백업, 로그 내보내기 등을 포함합니다.

csharp
코드 복사
using System;
using System.IO;

namespace RouterMiddleACR.Services
{
    public class AdditionalFunctions
    {
        // 시스템 상태를 확인하는 메서드
        public bool CheckSystemHealth()
        {
            // 시스템 상태를 확인하고 결과를 반환합니다.
            // 실제로는 여러 하드웨어 및 소프트웨어 상태를 점검할 수 있습니다.
            return true; // 여기서는 간단히 시스템이 정상임을 가정합니다.
        }

        // 데이터를 백업하는 메서드
        public void BackupData()
        {
            // 데이터 백업 로직을 구현합니다.
            // 예: 특정 디렉토리를 백업 폴더로 복사
            string sourceDirectory = @"C:\Data";
            string backupDirectory = @"C:\Backup\Data";
            Directory.CreateDirectory(backupDirectory);
            foreach (string filePath in Directory.GetFiles(sourceDirectory))
            {
                string fileName = Path.GetFileName(filePath);
                string destFilePath = Path.Combine(backupDirectory, fileName);
                File.Copy(filePath, destFilePath, true);
            }
        }

        // 로그를 내보내는 메서드
        public void ExportLogs()
        {
            // 로그를 내보내는 로직을 구현합니다.
            // 예: 로그 파일을 압축하여 다른 위치로 이동
            string logDirectory = @"C:\Agent\RouterFlowSync\Log";
            string exportPath = @"C:\ExportedLogs\Logs.zip";
            if (Directory.Exists(logDirectory))
            {
                System.IO.Compression.ZipFile.CreateFromDirectory(logDirectory, exportPath);
            }
        }
    }
}
솔루션 2: RouterMiddleACRService (Windows Service 애플리케이션)
프로젝트 구조
arduino
코드 복사
RouterMiddleACRService
├── RouterMiddleACRService.sln              // 솔루션 파일
└── RouterMiddleACRService
    ├── Program.cs                         // 서비스 진입점
    ├── RouterMiddleACRService.cs          // Windows Service 메인 클래스
    ├── Services
    │   ├── FileWatcherService.cs          // 파일 감시 및 처리 로직
    │   ├── ComPortManager.cs              // COM 포트 관리 및 데이터 전송 로직
    │   └── LogService.cs                  // 로그 기록 및 Named Pipe 서버 관리
1. Program.cs
Windows Service의 진입점으로, 메인 서비스 클래스를 실행합니다.

csharp
코드 복사
using System.ServiceProcess;

namespace RouterMiddleACRService
{
    static class Program
    {
        static void Main()
        {
            ServiceBase[] ServicesToRun;
            ServicesToRun = new ServiceBase[]
            {
                new RouterMiddleACRService() // 서비스 실행
            };
            ServiceBase.Run(ServicesToRun);
        }
    }
}
2. RouterMiddleACRService.cs
Windows Service의 메인 클래스입니다. 서비스가 시작되거나 종료될 때 호출되는 메서드를 정의합니다.

csharp
코드 복사
using System.ServiceProcess;
using RouterMiddleACRService.Services;

namespace RouterMiddleACRService
{
    public partial class RouterMiddleACRService : ServiceBase
    {
        private FileWatcherService _fileWatcherService;
        private ComPortManager _comPortManager;

        public RouterMiddleACRService()
        {
            InitializeComponent();
            _comPortManager = new ComPortManager();
            _fileWatcherService = new FileWatcherService("C:\\SourceDirectory", "C:\\BackupDirectory", _comPortManager);
        }

        // 서비스가 시작될 때 호출되는 메서드
        protected override void OnStart(string[] args)
        {
            _fileWatcherService.StartWatching(); // 파일 감시 서비스 시작
        }

        // 서비스가 종료될 때 호출되는 메서드
        protected override void OnStop()
        {
            _fileWatcherService.StopWatching(); // 파일 감시 서비스 중지
        }
    }
}
3. Services/FileWatcherService.cs
파일 시스템을 감시하고 파일이 생성되었을 때 데이터를 처리하는 서비스입니다.

csharp
코드 복사
using System;
using System.IO;
using System.Threading.Tasks;

namespace RouterMiddleACRService.Services
{
    public class FileWatcherService
    {
        private FileSystemWatcher _watcher;
        private readonly string _sourceDirectory;
        private readonly string _backupDirectory;
        private readonly ComPortManager _comPortManager;

        public FileWatcherService(string sourceDirectory, string backupDirectory, ComPortManager comPortManager)
        {
            _sourceDirectory = sourceDirectory;
            _backupDirectory = backupDirectory;
            _comPortManager = comPortManager;
        }

        public void StartWatching()
        {
            _watcher = new FileSystemWatcher(_sourceDirectory)
            {
                NotifyFilter = NotifyFilters.FileName | NotifyFilters.LastWrite,
                Filter = "*.*"
            };

            _watcher.Created += OnFileCreated;
            _watcher.EnableRaisingEvents = true; // 파일 감시를 활성화
        }

        public void StopWatching()
        {
            if (_watcher != null)
            {
                _watcher.EnableRaisingEvents = false; // 파일 감시를 비활성화
                _watcher.Dispose(); // FileSystemWatcher 리소스를 해제
            }
        }

        private void OnFileCreated(object sender, FileSystemEventArgs e)
        {
            Task.Run(() => ProcessFile(e.FullPath)); // 파일 생성 이벤트가 발생하면 파일 처리를 비동기로 실행
        }

        private async Task ProcessFile(string filePath)
        {
            try
            {
                string dateFolder = DateTime.Now.ToString("yyyyMM");
                string backupSubFolder = Path.Combine(_backupDirectory, dateFolder, DateTime.Now.ToString("yyyyMMdd"));
                Directory.CreateDirectory(backupSubFolder); // 날짜별 백업 폴더를 생성

                string backupFileName = $"{DateTime.Now:yyyyMMddHHmmss}_{Path.GetFileName(filePath)}";
                string backupFilePath = Path.Combine(backupSubFolder, backupFileName);

                File.Copy(filePath, backupFilePath, true); // 파일을 백업 폴더로 복사
                File.Delete(filePath); // 원본 파일 삭제

                await Task.Delay(500); // 처리 시간 지연

                File.Move(backupFilePath, backupFilePath.Replace(Path.GetExtension(backupFilePath), ".complete")); // 백업 파일의 확장자를 .complete로 변경

                string dataToSend = "파일에서 추출된 데이터"; // 실제 전송할 데이터를 파일에서 추출해야 함
                bool plcResult = await _comPortManager.SendDataToPLCAsync(dataToSend);
                bool oiResult = await _comPortManager.SendDataToOIAsync(dataToSend);

                if (plcResult && oiResult)
                {
                    LogService.Instance.LogOperation("PLC 및 OI로 데이터 전송 성공");
                }
                else
                {
                    LogService.Instance.LogError("PLC 또는 OI로 데이터 전송 실패");
                }
            }
            catch (Exception ex)
            {
                LogService.Instance.LogError($"파일 처리 중 오류 발생: {ex.Message}");
            }
        }
    }
}
4. Services/ComPortManager.cs
PLC와 OI에 데이터를 전송하는 COM 포트 관리 클래스입니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Threading.Tasks;

namespace RouterMiddleACRService.Services
{
    public class ComPortManager
    {
        private SerialPort _plcPort; // PLC용 SerialPort 객체
        private SerialPort _oiPort; // OI용 SerialPort 객체

        public void ConfigurePLCPort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            ConfigurePort(ref _plcPort, portName, baudRate, parity, dataBits, stopBits);
        }

        public void ConfigureOIPort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            ConfigurePort(ref _oiPort, portName, baudRate, parity, dataBits, stopBits);
        }

        private void ConfigurePort(ref SerialPort port, string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
        {
            if (port != null && port.IsOpen)
            {
                port.Close(); // 이미 열려 있는 포트가 있으면 닫음
            }

            port = new SerialPort(portName, baudRate, parity, dataBits, stopBits); // 새 포트 설정
        }

        public async Task<bool> SendDataToPLCAsync(string data)
        {
            return await SendDataAsync(_plcPort, data);
        }

        public async Task<bool> SendDataToOIAsync(string data)
        {
            return await SendDataAsync(_oiPort, data);
        }

        private async Task<bool> SendDataAsync(SerialPort port, string data)
        {
            try
            {
                if (port == null)
                {
                    throw new InvalidOperationException("Port is not configured.");
                }

                if (!port.IsOpen)
                {
                    port.Open(); // 포트가 열려 있지 않다면 열기
                }

                port.WriteLine(data); // 데이터 전송
                await Task.Delay(100); // 통신 대기 시간
                string response = port.ReadLine(); // 응답 수신
                LogService.Instance.LogOperation($"전송 데이터: {data}, 응답: {response}");

                return response.Contains("OK"); // 응답 확인
            }
            catch (Exception ex)
            {
                LogService.Instance.LogError($"COM 포트 전송 중 오류 발생: {ex.Message}");
                return false;
            }
            finally
            {
                if (port != null && port.IsOpen)
                {
                    port.Close(); // 포트를 닫음
                }
            }
        }
    }
}
5. Services/LogService.cs
로그를 기록하고 Named Pipe 서버를 통해 클라이언트에 실시간으로 로그 메시지를 전송하는 클래스입니다.

csharp
코드 복사
using System;
using System.IO;
using System.IO.Pipes;
using System.Threading.Tasks;

namespace RouterMiddleACRService.Services
{
    public class LogService
    {
        private static LogService _instance;
        private readonly string _logDirectory;
        private NamedPipeServerStream _pipeServer;

        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        private LogService()
        {
            _logDirectory = Path.Combine("C:\\Agent\\RouterFlowSync\\Log", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory);
            StartNamedPipeServer(); // Named Pipe 서버 시작
        }

        public void LogOperation(string message)
        {
            string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_OperatorLog.txt");
            WriteLog(logFilePath, message);
            SendLogToClient($"INFO: {message}"); // 로그를 클라이언트로 전송
        }

        public void LogError(string message)
        {
            string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ErrorLog.txt");
            WriteLog(logFilePath, message);
            SendLogToClient($"ERROR: {message}"); // 로그를 클라이언트로 전송
        }

        private void WriteLog(string logFilePath, string message)
        {
            string logMessage = $"{DateTime.Now:HH:mm:ss} - {message}";
            File.AppendAllText(logFilePath, logMessage + Environment.NewLine);
        }

        private void StartNamedPipeServer()
        {
            _pipeServer = new NamedPipeServerStream("RouterMiddleACRLogPipe", PipeDirection.Out, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous);
            _pipeServer.BeginWaitForConnection(OnClientConnected, null);
        }

        private void OnClientConnected(IAsyncResult ar)
        {
            _pipeServer.EndWaitForConnection(ar);
            // 클라이언트가 연결되었을 때 추가 로직을 여기에 작성할 수 있음
        }

        private void SendLogToClient(string logMessage)
        {
            if (_pipeServer.IsConnected)
            {
                using (StreamWriter writer = new StreamWriter(_pipeServer))
                {
                    writer.AutoFlush = true;
                    writer.WriteLine(logMessage); // 클라이언트로 로그 메시지 전송
                }
            }
        }
    }
}
전체 코드 흐름 및 응용 방법
1. 코드 흐름 설명
서비스 시작:
RouterMiddleACRService가 Windows 서비스로 시작됩니다. 서비스 시작 시 OnStart 메서드가 호출되어 파일 감시 서비스(FileWatcherService)가 시작됩니다.
파일 감시 및 로그 생성:
FileWatcherService는 지정된 디렉토리를 감시하다가 새로운 파일이 생성되면, ProcessFile 메서드를 호출하여 파일을 처리하고 데이터를 전송합니다.
이 과정에서 발생한 모든 로그는 LogService를 통해 기록되고, 동시에 Named Pipe 서버를 통해 실시간으로 WPF 클라이언트 애플리케이션에 전송됩니다.
WPF 클라이언트에서 로그 수신:
RouterMiddleACR WPF 애플리케이션은 시작 시 MainWindow에서 Named Pipe 클라이언트(NamedPipeClientStream)를 시작하여 로그를 수신합니다.
수신된 로그 메시지는 MainViewModel의 LogMessages 컬렉션에 추가되어 UI에서 실시간으로 표시됩니다.
서비스 제어:
사용자가 WPF 클라이언트의 버튼을 클릭하여 서비스를 시작, 중지 또는 업데이트할 수 있습니다.
이러한 사용자 액션은 ServiceControllerHelper를 통해 서비스 제어 명령으로 변환되어 Windows 서비스에 전달됩니다.
2. 응용 가능한 추가 기능
1. 파일 처리 결과 이메일 알림
언제 사용하나?
파일이 성공적으로 처리되었거나 오류가 발생했을 때 관리자에게 이메일 알림을 보내기 위해 사용합니다.

왜 사용하나?
시스템 모니터링을 자동화하여 관리자에게 중요한 이벤트에 대해 신속하게 알릴 수 있습니다.

예제 코드 추가 (LogService.cs)

csharp
코드 복사
using System.Net;
using System.Net.Mail;

public void SendEmailNotification(string subject, string body)
{
    try
    {
        var smtpClient = new SmtpClient("smtp.example.com")
        {
            Port = 587,
            Credentials = new NetworkCredential("username", "password"),
            EnableSsl = true,
        };

        smtpClient.Send("from@example.com", "to@example.com", subject, body);
    }
    catch (Exception ex)
    {
        LogError($"Failed to send email: {ex.Message}");
    }
}
2. 성능 모니터링
언제 사용하나?
시스템 성능(예: CPU 사용률, 메모리 사용량)을 모니터링해야 할 때 사용합니다.

왜 사용하나?
성능 병목 현상을 감지하고, 리소스 사용량을 모니터링하여 시스템 최적화를 위해 사용합니다.

예제 코드 추가 (AdditionalFunctions.cs)

csharp
코드 복사
using System.Diagnostics;

public double GetCpuUsage()
{
    var cpuCounter = new PerformanceCounter("Processor", "% Processor Time", "_Total");
    cpuCounter.NextValue(); // 처음 호출은 0을 반환하므로 무시
    System.Threading.Thread.Sleep(1000);
    return cpuCounter.NextValue();
}

public double GetMemoryUsage()
{
    var memoryCounter = new PerformanceCounter("Memory", "Available MBytes");
    return memoryCounter.NextValue();
}
3. 사용자 인증 및 권한 관리
언제 사용하나?
사용자가 애플리케이션을 사용하기 전에 인증하고, 특정 기능에 대한 접근을 제어해야 할 때 사용합니다.

왜 사용하나?
보안 강화 및 권한 기반의 접근 제어를 위해 사용합니다.

예제 코드 추가 (MainWindow.xaml.cs)

csharp
코드 복사
private void AuthenticateUser(string username, string password)
{
    // 간단한 인증 로직 (실제 구현에서는 더 복잡한 인증 방식을 사용해야 함)
    if (username == "admin" && password == "password")
    {
        MessageBox.Show("Authentication successful.");
    }
    else
    {
        MessageBox.Show("Authentication failed.");
    }
}
위와 같이 다양한 기능을 추가하여 시스템을 더욱 강화할 수 있습니다. 이 모든 기능은 시스템의 안정성과 유연성을 높이고, 다양한 상황에 대응할 수 있도록 도와줍니