import pdfplumber
import re
from typing import List, Dict, Any

# 각 텍스트 요소의 상세 정보를 담을 데이터 클래스
class TextElement:
    def __init__(self, element: Dict[str, Any]):
        self.value = element.get('text', '')
        # 좌표 및 크기 정보는 소수점 2자리까지 반올림하여 일관성 유지
        self.x0 = round(element.get('x0', 0), 2)
        self.y0 = round(element.get('y0', 0), 2)
        self.x1 = round(element.get('x1', 0), 2)
        self.y1 = round(element.get('y1', 0), 2)
        self.size = round(element.get('size', 0), 2)
        self.color = element.get('non_stroking_color', (0, 0, 0))

    def __repr__(self) -> str:
        """객체를 문자열로 표현하여 출력 형식을 정의합니다."""
        return (
            f"Color: {self.color}, "
            f"Size: {self.size}, "
            f"Value: '{self.value}', "
            f"Position: (x0={self.x0}, y0={self.y0}, x1={self.x1}, y1={self.y1})"
        )

# 부품 정보 그룹을 나타내는 클래스
class PartComponent:
    def __init__(self, page_number: int, part_number_element: TextElement):
        self.page_number = page_number
        self.part_number = part_number_element
        # 이 부품에 속한 모든 텍스트 요소들을 저장 (부품 번호 포함)
        self.related_elements: List[TextElement] = []

    def add_element(self, element: TextElement):
        """그룹에 텍스트 요소를 추가합니다."""
        self.related_elements.append(element)

    def __repr__(self) -> str:
        """최종 출력 형식을 정의합니다."""
        # 요소들을 시각적 순서(위->아래, 왼쪽->오른쪽)로 정렬하여 출력
        sorted_elements = sorted(self.related_elements, key=lambda e: (e.y0, e.x0))
        
        # 각 관련 정보들을 쉼표와 줄바꿈으로 구분하여 가독성 좋게 만듭니다.
        details_str = ",\n\t".join([str(elem) for elem in sorted_elements])
        return (
            f"Page: {self.page_number}, PartNumber: {self.part_number.value}\n"
            f"Details: [\n\t{details_str}\n]"
        )

def analyze_parts_from_pdf(pdf_path: str, output_txt_path: str):
    """
    PDF 파일에서 부품 컴포넌트를 분석하여 텍스트 파일로 저장합니다.

    Args:
        pdf_path (str): 분석할 PDF 파일의 경로
        output_txt_path (str): 결과를 저장할 텍스트 파일 경로
    """
    all_part_components = []
    
    # 부품 코드와 섹션 시작점(03L, 4L 등)을 찾기 위한 정규식
    part_number_pattern = re.compile(r"^\d{4}-\d{6}$")
    section_starter_pattern = re.compile(r"^\d+[LR]$")

    try:
        with pdfplumber.open(pdf_path) as pdf:
            for page_num, page in enumerate(pdf.pages, 1):
                page_within_bounds = page.crop((0, 100, page.width, page.height))
                words = page_within_bounds.extract_words(extra_attrs=["size", "non_stroking_color"])
                
                if not words:
                    continue

                # 1. '섹션 시작점' (예: '03L', '4L')을 모두 찾아 y0 좌표 기준으로 정렬합니다.
                section_starters = sorted(
                    [w for w in words if section_starter_pattern.match(w['text'])],
                    key=lambda w: w['y0']
                )
                
                if not section_starters:
                    continue

                # 2. 각 섹션 시작점을 기준으로 수직 영역을 나누고, 해당 영역의 단어들을 그룹화합니다.
                num_starters = len(section_starters)
                for i in range(num_starters):
                    current_starter = section_starters[i]
                    
                    # 현재 그룹의 수직 경계(y0 ~ y1)를 정의합니다.
                    group_top_y = current_starter['y0']
                    group_bottom_y = section_starters[i+1]['y0'] if i + 1 < num_starters else page.height

                    # 3. 경계 내에 포함되는 모든 단어를 수집합니다.
                    component_words_in_boundary = [
                        w for w in words 
                        if group_top_y <= w['y0'] < group_bottom_y
                    ]
                    
                    if not component_words_in_boundary:
                        continue

                    # 4. 수집된 단어들 중에서 부품 코드를 찾아 PartComponent 객체를 생성합니다.
                    found_part_number_obj = None
                    for word_obj in component_words_in_boundary:
                        if part_number_pattern.match(word_obj['text']):
                            found_part_number_obj = word_obj
                            break
                    
                    if found_part_number_obj:
                        part_element = TextElement(found_part_number_obj)
                        part_component = PartComponent(page_num, part_element)
                        
                        for word_obj in component_words_in_boundary:
                            part_component.add_element(TextElement(word_obj))
                        
                        all_part_components.append(part_component)

        # 5. 모든 분석 결과를 텍스트 파일에 저장합니다.
        with open(output_txt_path, 'w', encoding='utf-8') as f:
            f.write(f"총 {len(all_part_components)}개의 부품을 찾았습니다.\n")
            f.write("=" * 60 + "\n")
            for component in all_part_components:
                f.write(str(component) + "\n")
                f.write("-" * 60 + "\n")
        
        print(f"분석 완료. 결과가 '{output_txt_path}' 파일에 저장되었습니다.")

    except FileNotFoundError:
        print(f"오류: 파일을 찾을 수 없습니다. 경로를 확인하세요: {pdf_path}")
    except Exception as e:
        print(f"오류가 발생했습니다: {e}")

# --- 메인 실행 부분 ---
if __name__ == "__main__":
    # 1. 여기에 실제 PDF 파일 경로를 입력하세요.
    pdf_file_path = "YOUR_PDF_FILE_PATH.pdf" 
    
    # 2. 결과가 저장될 텍스트 파일 경로입니다.
    output_file_path = "part_list_output.txt"

    analyze_parts_from_pdf(pdf_file_path, output_file_path)