습니다. 요청하신 대로 연결이 되어 있지 않다면 전송 명령을 시도할 때 **로그에 '연결이 안 되어 있어서 전송할 수 없다'**는 메시지가 남도록 수정한 코드를 드리겠습니다. 또한, 모든 코드에 상세한 주석을 추가하여 설명하겠습니다.

수정된 SocketClientMergeOI 클래스와 시뮬레이션 서버
**클라이언트 측 (SocketClientMergeOI)**에서, 연결이 되어 있지 않다면 명령어 전송 시 로그에 "연결이 되어 있지 않음" 메시지를 기록하도록 수정합니다.
서버 측은 그대로 유지하지만, 클라이언트에서의 변경 사항에 맞춰 시뮬레이션할 수 있습니다.
SocketClientMergeOI.cs (수정된 클라이언트 코드)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientMergeOI
{
    private TcpClient _client; // TCP 클라이언트 객체
    private NetworkStream _stream; // 네트워크 스트림
    private readonly string _ipAddress; // 접속할 서버의 IP 주소
    private readonly int _port; // 접속할 서버의 포트 번호
    private bool _isConnected; // 서버와의 연결 여부 플래그
    private readonly int _retryInterval = 10000; // 10초 간격으로 재연결 시도

    // ObservableCollection을 사용하여 메시지 목록 관리
    public ObservableCollection<MessageLog> MessageLogs { get; private set; } // 읽기 전용

    // 생성자: IP 주소와 포트로 소켓 클라이언트를 초기화
    public SocketClientMergeOI(string ipAddress, int port)
    {
        _ipAddress = ipAddress; // 입력받은 IP 저장
        _port = port; // 입력받은 포트 저장
        _client = new TcpClient(); // TCP 클라이언트 생성
        _isConnected = false; // 초기 연결 상태 false
        MessageLogs = new ObservableCollection<MessageLog>(); // 메시지 로그 초기화
        StartConnectionAttemptAsync(); // 연결 시도 시작
    }

    // 서버에 연결 시도하는 비동기 함수
    private async void StartConnectionAttemptAsync()
    {
        while (!_isConnected) // 연결이 될 때까지 반복
        {
            try
            {
                await _client.ConnectAsync(_ipAddress, _port); // 서버에 연결 시도
                _isConnected = true; // 연결 성공
                _stream = _client.GetStream(); // 스트림 생성
                LogMessage("System", _ipAddress, "Connected", ""); // 연결 성공 로그 남김
                StartReceiving(); // 메시지 수신 대기
            }
            catch (Exception)
            {
                LogMessage("System", _ipAddress, "Retrying in 10 seconds...", ""); // 재시도 로그
                await Task.Delay(_retryInterval); // 10초 대기 후 재시도
            }
        }
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async void StartReceiving()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼 생성

        while (_isConnected) // 연결된 동안 메시지 수신을 계속 시도
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 읽음
                if (bytesRead > 0)
                {
                    string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신된 데이터를 문자열로 변환
                    LogMessage(_ipAddress, "Client", "", receivedMessage); // 수신 메시지를 로그에 기록
                }
            }
            catch (Exception)
            {
                _isConnected = false; // 연결이 끊긴 경우
                LogMessage("System", _ipAddress, "Connection lost", ""); // 연결 끊김 로그
                StartConnectionAttemptAsync(); // 다시 연결 시도
            }
        }
    }

    // 메시지를 전송하고 응답을 받는 비동기 함수
    public async Task<string> SendAndReceiveMessageAsync(string message)
    {
        // 연결 상태 확인 후 연결이 안 되어 있으면 로그 남기기
        if (!_isConnected) // 연결이 되어 있지 않으면
        {
            LogMessage("Client", _ipAddress, message, "Failed: Not connected"); // 연결 실패 로그 남기기
            return "Not connected"; // 연결되지 않았음을 반환
        }

        string fullMessage = $"\x02{message}\x03"; // STX 및 ETX 추가
        byte[] messageBytes = Encoding.ASCII.GetBytes(fullMessage); // 메시지를 바이트 배열로 변환

        try
        {
            await _stream.WriteAsync(messageBytes, 0, messageBytes.Length); // 서버에 전송
            LogMessage("Client", _ipAddress, message, ""); // 전송 로그 남김
        }
        catch (Exception)
        {
            LogMessage("Client", _ipAddress, message, "Failed: Send Error"); // 전송 실패 로그 남기기
            return "Send Failed"; // 전송 실패 시 에러 반환
        }

        // 서버로부터 응답 대기 및 검증
        string response = await ReceiveMessageAsync();
        LogMessage(_ipAddress, "Client", message, response); // 응답 로그 기록
        return ValidateResponse(message, response); // 응답 검증 후 결과 반환
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async Task<string> ReceiveMessageAsync()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

        try
        {
            int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 수신
            if (bytesRead > 0)
            {
                string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신된 데이터를 문자열로 변환
                return receivedMessage; // 변환된 메시지 반환
            }
        }
        catch (Exception)
        {
            _isConnected = false; // 연결이 끊긴 경우
            LogMessage("System", _ipAddress, "Connection lost", ""); // 연결 끊김 로그
            StartConnectionAttemptAsync(); // 다시 연결 시도
        }

        return string.Empty;
    }

    // 메시지 로그 추가 함수
    private void LogMessage(string sender, string receiver, string sentMessage, string responseMessage)
    {
        // 로그 항목 추가
        MessageLog log = new MessageLog
        {
            Timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
            Sender = sender,
            Receiver = receiver,
            SentMessage = sentMessage,
            ResponseMessage = responseMessage
        };

        if (MessageLogs.Count >= 50) // 최대 50개 로그 유지
        {
            MessageLogs.RemoveAt(0); // 오래된 항목 삭제
        }

        MessageLogs.Add(log); // 새로운 항목 추가
    }

    // 응답 검증 함수
    private string ValidateResponse(string sentMessage, string receivedMessage)
    {
        if (receivedMessage.StartsWith("\x02") && receivedMessage.EndsWith("\x03"))
        {
            string cleanMessage = receivedMessage.Trim('\x02', '\x03');
            if (cleanMessage == "OK")
            {
                return "OK";
            }
            else if (cleanMessage == sentMessage)
            {
                return "NG";
            }
        }
        return "Invalid Response";
    }

    // 연결을 중지하는 함수
    public void StopConnection()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
    }
}

// 메시지 로그를 위한 클래스
public class MessageLog
{
    public string Timestamp { get; set; } // 메시지의 타임스탬프
    public string Sender { get; set; } // 발신자
    public string Receiver { get; set; } // 수신자
    public string SentMessage { get; set; } // 전송된 메시지
    public string ResponseMessage { get; set; } // 수신된 응답 메시지
}
변경 사항 설명:
연결되지 않은 상태에서 전송 명령을 시도했을 때:
연결이 되어 있지 않을 경우 SendAndReceiveMessageAsync 함수 내에서 "연결되지 않음" 로그를 남기도록 추가했습니다.
메시지가 전송되지 않았음을 클라이언트 로그에 기록하고, 메시지가 기록되지 않았음을 명확하게 알 수 있습니다.
MainWindow.xaml.cs (서버 코드)
서버 코드는 변경이 없지만, 클라이언트와의 상호작용을 시뮬레이션하는 데 적합한 상태로 유지됩니다. 만약 클라이언트가 연결되지 않은 상태에서 전송 명령을 시도하면, 서버가 요청을 받지 않고, 클라이언트에서 로그가 기록됩니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace SocketServer
{
    public partial class MainWindow : Window
    {
        private TcpListener _tcpListener; // 클라이언트 연결을 수신할 TCP 리스너
        public ObservableCollection<MessageLog> MessageLogs { get; set; } // 로그를 저장할 ObservableCollection

        public MainWindow()
        {
            InitializeComponent();
            MessageLogs = new ObservableCollection<MessageLog>(); // 메시지 로그 초기화
            DataContext = this; // 데이터 바인딩 설정
        }

        // 서버 시작 버튼 클릭 시 호출되는 이벤트
        private async void StartServer_Click(object sender, RoutedEventArgs e)
        {
            await StartServerAsync(); // 비동기적으로 서버 시작
        }

        // 서버 시작 및 클라이언트 연결 처리 비동기 함수
        private async Task StartServerAsync()
        {
            _tcpListener = new TcpListener(IPAddress.Any, 2400); // 포트 2400에서 모든 IP 주소에서 연결을 대기
            _tcpListener.Start(); // 서버 시작
            LogMessage("", "Server started and waiting for client connection...", ""); // 서버 시작 로그

            while (true) // 서버가 실행되는 동안 클라이언트 연결을 계속 수신
            {
                TcpClient client = await _tcpListener.AcceptTcpClientAsync(); // 클라이언트 연결 대기
                LogMessage("", "Client connected.", ""); // 클라이언트 연결 로그
                _ = Task.Run(() => HandleClientAsync(client)); // 클라이언트 처리 비동기 함수 실행
            }
        }

        // 클라이언트로부터 데이터를 수신하고 응답을 처리하는 비동기 함수
        private async Task HandleClientAsync(TcpClient client)
        {
            NetworkStream stream = client.GetStream(); // 클라이언트와의 통신을 위한 네트워크 스트림

            byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

            try
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 수신
                if (bytesRead > 0)
                {
                    string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신한 데이터를 문자열로 변환
                    LogMessage(receivedMessage, "", ""); // 수신 메시지 로그 기록

                    // 응답 생성: 수신한 메시지를 그대로 돌려보내거나 "OK" 메시지를 보냄
                    string responseMessage = receivedMessage.Trim('\x02', '\x03') == "TestCommand" ? "\x02OK\x03" : "\x02NG\x03";
                    byte[] responseBytes = Encoding.ASCII.GetBytes(responseMessage); // 응답을 바이트 배열로 변환
                    await stream.WriteAsync(responseBytes, 0, responseBytes.Length); // 클라이언트로 응답 전송
                    LogMessage(receivedMessage, responseMessage, responseMessage.Contains("OK").ToString()); // 응답 로그 기록
                }
            }
            catch (Exception ex)
            {
                LogMessage("", $"Error: {ex.Message}", "False"); // 오류 로그 기록
            }
            finally
            {
                client.Close(); // 클라이언트 연결 종료
            }
        }

        // 메시지 로그 추가 함수
        private void LogMessage(string receivedMessage, string sentResponse, string success)
        {
            Application.Current.Dispatcher.Invoke(() => // UI 스레드에서 실행되도록 보장
            {
                MessageLogs.Add(new MessageLog
                {
                    ReceivedMessage = receivedMessage,
                    SentResponse = sentResponse,
                    Success = success
                });

                if (MessageLogs.Count > 50) // 최대 50개의 로그만 유지
                {
                    MessageLogs.RemoveAt(0); // 오래된 항목 삭제
                }
            });
        }
    }

    // 메시지 로그를 위한 클래스
    public class MessageLog
    {
        public string ReceivedMessage { get; set; } // 수신된 메시지
        public string SentResponse { get; set; } // 보낸 응답
        public string Success { get; set; } // 정상 여부 (OK/NG)
    }
}