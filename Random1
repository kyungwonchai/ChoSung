소켓 통신에서 메시지가 누적되어 여러 번 나오는 문제는 수신 측에서 메시지를 올바르게 처리하지 않아서 발생할 수 있습니다. 주로 발생하는 원인은 다음과 같습니다:

메시지 버퍼 초기화 문제: 이전에 수신된 메시지를 처리한 후에도 남아있는 버퍼 데이터를 처리하지 않아서 누적된 데이터가 나중에 다시 읽히는 경우.
메시지 분할 및 누적 처리: 스트림 기반 통신에서 부분적으로 수신된 데이터를 다음 읽기 작업과 함께 누적하여 처리하는 과정에서 문제가 발생할 수 있습니다.
이 문제를 해결하려면 수신 측에서 메시지를 처리한 후, 처리된 데이터를 올바르게 제거하고 다음 읽기를 준비하는 것이 중요합니다.

수정된 코드 예제
다음은 수신 측에서 메시지를 올바르게 처리하고 누적되지 않도록 수정된 코드 예제입니다.

MainWindow.xaml.cs 수정
csharp
코드 복사
private void StartListeningToLogs()
{
    Task.Run(async () =>
    {
        try
        {
            _tcpClient = new TcpClient("127.0.0.1", 9000); // 로컬호스트의 포트 9000에 연결
            _networkStream = _tcpClient.GetStream();

            byte[] buffer = new byte[1024];
            int bytesRead;
            StringBuilder messageBuilder = new StringBuilder();

            // 로그 메시지를 지속적으로 수신하여 UI에 표시
            while ((bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
            {
                string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                messageBuilder.Append(receivedData);

                // 메시지 구분자로 분할하여 개별 메시지로 처리
                string[] messages = messageBuilder.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);

                // 메시지를 순차적으로 처리하고 마지막 남은 부분은 messageBuilder에 남김
                for (int i = 0; i < messages.Length - 1; i++)
                {
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add(messages[i])); // UI에 로그 메시지 추가
                }

                // 마지막 메시지가 완성되지 않았을 수 있으므로 messageBuilder를 갱신
                messageBuilder.Clear();
                if (!receivedData.EndsWith("\n"))
                {
                    messageBuilder.Append(messages.Last());
                }
            }
        }
        catch (Exception ex)
        {
            Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
        }
        finally
        {
            _networkStream?.Close();
            _tcpClient?.Close();
        }
    });
}
주요 변경점 설명
메시지 처리 후 남은 부분 관리:

Split 메서드를 사용하여 메시지를 줄바꿈 문자(\n)로 분할합니다.
for 루프를 통해 모든 완성된 메시지(messages.Length - 1까지)를 UI에 추가합니다.
마지막 메시지는 완성되지 않은 메시지일 수 있으므로 messageBuilder에 남겨두어 다음 수신 시 계속 처리할 수 있도록 합니다.
메시지 누적 방지:

messageBuilder.Clear()를 호출하여 메시지를 처리한 후에는 남아있는 데이터를 제거합니다.
마지막 메시지가 완성되지 않았을 경우에만 messageBuilder를 업데이트합니다. 이를 통해 이미 처리된 메시지를 반복해서 처리하는 일이 없도록 합니다.
이렇게 하면, 메시지가 누적되어 여러 번 나오는 문제를 해결할 수 있습니다. 소켓 통신에서는 데이터 스트림을 올바르게 관리하는 것이 중요하며, 이를 위해 메시지 경계를 정확히 파악하고 처리하는 방법을 사용해야 합니다