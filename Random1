;summary>&lt;b>[클릭] 모든 코드가 포함된 MainWindow.xaml.cs 최종 전체 버전&lt;/b>&lt;74></summary>

C#

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;
using Gdi = System.Drawing;
using Wpf = System.Windows;

namespace funcenvget
{
    public partial class MainWindow : Wpf.Window
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private Wpf.Threading.DispatcherTimer timer;
        private Wpf.Threading.DispatcherTimer searchTimer;
        private TesseractEngine _ocrEngine;
        private bool isLocked = true;
        private readonly string agentBasePath = @"C:\Agent\funcenvget";
        private readonly string logFolderPath;
        private readonly string traceLogPath;
        private string previewImagePath;
        private bool isExiting = false;

        private TesseractEngine OcrEngine
        {
            get
            {
                if (_ocrEngine == null)
                {
                    string exePath = AppDomain.CurrentDomain.BaseDirectory;
                    string tessDataPath = Path.Combine(exePath, "tessdata");
                    _ocrEngine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default);
                    _ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");
                }
                return _ocrEngine;
            }
        }
        
        public MainWindow()
        {
            logFolderPath = Path.Combine(agentBasePath, "logs");
            traceLogPath = Path.Combine(logFolderPath, "trace_log.txt");
            InitializeComponent();
            InitializeApp();
        }

        private void LogTrace(string message)
        {
            try
            {
                Directory.CreateDirectory(logFolderPath);
                string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} - {message}\r\n";
                File.AppendAllText(traceLogPath, logMessage);
            }
            catch { }
        }

        protected override void OnContentRendered(EventArgs e)
        {
            base.OnContentRendered(e);
            this.Hide();
        }

        private void InitializeApp()
        {
            LogTrace("Application Initializing...");
            CheckRequiredFiles();
            timer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromSeconds(10) };
            timer.Tick += Timer_Tick;
            searchTimer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromMinutes(1) };
            searchTimer.Tick += SearchTimer_Tick;
            Directory.CreateDirectory(agentBasePath);
            previewImagePath = Path.Combine(agentBasePath, "preview_capture.png");
            LogTrace("Application Initialized.");
        }
        
        private void SearchTimer_Tick(object sender, EventArgs e)
        {
            LogTrace("SearchTimer Tick: 재탐색 시작...");
            lblStatus.Text = "대상 창/프로세스를 찾는 중... (1분마다 재시도)";
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd != IntPtr.Zero)
            {
                LogTrace("SearchTimer Tick: 대상 발견!");
                searchTimer.Stop();
                lblStatus.Text = "대상 발견! 자동 로깅을 시작합니다.";
                if (!timer.IsEnabled) { btnStart_Click(this, new RoutedEventArgs()); }
            }
            else
            {
                LogTrace("SearchTimer Tick: 대상 찾기 실패.");
            }
        }

        private void CheckRequiredFiles()
        {
            string exePath = AppDomain.CurrentDomain.BaseDirectory;
            string[] requiredFiles = { "tesseract53.dll", "leptonica-1.83.1.dll" }; 
            foreach (var file in requiredFiles)
            {
                if (!File.Exists(Path.Combine(exePath, file)))
                {
                    LogTrace($"CheckRequiredFiles: 필수 파일 없음 - {file}");
                    MessageBox.Show($"실행에 필수적인 파일이 없습니다: {file}\n\nClickOnce 게시 설정에서 모든 관련 파일이 '포함(Include)'되었는지 확인하세요.", "실행 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    Application.Current.Shutdown();
                    return;
                }
            }
            if (!Directory.Exists(Path.Combine(exePath, "tessdata")))
            {
                LogTrace("CheckRequiredFiles: tessdata 폴더 없음.");
                MessageBox.Show("tessdata 폴더를 찾을 수 없습니다.\n\nClickOnce 게시 설정에서 tessdata 폴더와 그 안의 파일들이 포함되었는지 확인하세요.", "실행 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                Application.Current.Shutdown();
                return;
            }
            LogTrace("CheckRequiredFiles: 모든 필수 파일 확인 완료.");
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            LogTrace("Window_Loaded: 설정 로드 시작.");
            txtTarget.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            txtPcName.Text = Settings.Default.PcName;

            if (Settings.Default.SearchByProcessName)
            {
                rbFindByProcess.IsChecked = true;
            }
            else
            {
                rbFindByTitle.IsChecked = true;
            }
            SearchMethod_Changed(null, null); 

            if (File.Exists(previewImagePath))
            {
                try
                {
                    LogTrace($"Window_Loaded: 미리보기 이미지 로드 시도 - {previewImagePath}");
                    var preview = new Wpf.Media.Imaging.BitmapImage();
                    preview.BeginInit();
                    using (var stream = new FileStream(previewImagePath, FileMode.Open, FileAccess.Read, FileShare.Read))
                    {
                        preview.StreamSource = stream;
                        preview.CacheOption = Wpf.Media.Imaging.BitmapCacheOption.OnLoad;
                        preview.EndInit();
                    }
                    imgPreview.Source = preview;
                    LogTrace("Window_Loaded: 미리보기 이미지 로드 성공.");
                }
                catch (Exception ex)
                {
                    LogTrace($"Window_Loaded: 미리보기 이미지 로드 실패 - {ex.Message}");
                }
            }
            else { LogTrace("Window_Loaded: 미리보기 이미지 파일 없음."); }
            UpdateLockState(true);
            LogTrace("Window_Loaded: 설정 로드 완료, 자동 시작 시도.");
            AttemptAutoStart();
        }

        private void AttemptAutoStart()
        {
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && !string.IsNullOrWhiteSpace(txtTarget.Text))
            {
                LogTrace("AttemptAutoStart: 자동 시작 조건 충족. 대상 검색 시도.");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd != IntPtr.Zero)
                {
                    LogTrace("AttemptAutoStart: 대상 즉시 발견. 로깅 시작.");
                    if (!timer.IsEnabled) { btnStart_Click(this, new RoutedEventArgs()); }
                }
                else
                {
                    LogTrace("AttemptAutoStart: 대상 찾기 실패. 재탐색 타이머 시작.");
                    lblStatus.Text = "대상을 찾을 수 없어, 1분마다 재검색을 시작합니다.";
                    searchTimer.Start();
                }
            }
            else
            {
                LogTrace("AttemptAutoStart: 자동 시작 조건 미충족 (PC 이름 또는 대상 정보 부족).");
            }
        }
        
        private void SaveApplicationSettings()
        {
            LogTrace("SaveApplicationSettings: 설정 저장 시작.");
            Settings.Default.WindowTitle = txtTarget.Text;
            Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
            Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
            Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
            Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
            Settings.Default.PcName = txtPcName.Text;
            Settings.Default.SearchByProcessName = rbFindByProcess.IsChecked == true;
            Settings.Default.Save();
            LogTrace("SaveApplicationSettings: 설정 저장 완료.");
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            SaveApplicationSettings();
            lblStatus.Text = $"상태: {DateTime.Now:T} - 설정이 저장되었습니다.";
            MessageBox.Show("설정이 저장되었습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void btnToggleEdit_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled || searchTimer.IsEnabled)
            {
                MessageBox.Show("로깅 또는 대상 탐색이 실행 중일 때는 설정을 수정할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            isLocked = !isLocked;
            UpdateLockState(isLocked);
            LogTrace($"btnToggleEdit_Click: 잠금 상태 변경 -> {isLocked}");

            if (isLocked)
            {
                SaveApplicationSettings();
                lblStatus.Text = $"상태: {DateTime.Now:T} - 변경된 설정이 저장되었습니다.";
            }
        }

        private void UpdateLockState(bool lockState)
        {
            isLocked = lockState;
            txtPcName.IsReadOnly = isLocked;
            txtTarget.IsReadOnly = isLocked;
            rbFindByTitle.IsEnabled = !isLocked;
            rbFindByProcess.IsEnabled = !isLocked;
            btnSelectArea.IsEnabled = !isLocked;
            btnSaveSettings.IsEnabled = !isLocked; 

            if (isLocked)
            {
                btnToggleEdit.Content = "수정";
                txtPcName.Background = Wpf.Media.Brushes.LightGray;
                txtTarget.Background = Wpf.Media.Brushes.LightGray;
            }
            else
            {
                btnToggleEdit.Content = "잠금";
                txtPcName.Background = Wpf.Media.Brushes.White;
                txtTarget.Background = Wpf.Media.Brushes.White;
            }
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled || searchTimer.IsEnabled)
            {
                LogTrace("btnStart_Click: 로깅/탐색 중지 요청.");
                timer.Stop();
                searchTimer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 모든 작업이 중지되었습니다.";
            }
            else
            {
                LogTrace("btnStart_Click: 로깅 시작 요청.");
                searchTimer.Stop(); 
                if (!isLocked) { LogTrace("btnStart_Click: 시작 실패 - 잠금 상태 아님."); MessageBox.Show("설정을 먼저 '잠금' 상태로 변경해주세요.", "알림", MessageBoxButton.OK, MessageBoxImage.Information); return; }
                if (string.IsNullOrWhiteSpace(txtPcName.Text) || string.IsNullOrWhiteSpace(txtTarget.Text)) { LogTrace("btnStart_Click: 시작 실패 - PC이름 또는 대상 정보 부족."); MessageBox.Show("PC이름과 대상(창 제목/프로세스 이름)을 모두 설정해야 합니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error); return; }
                if (GetTargetWindowHandle() == IntPtr.Zero) { LogTrace("btnStart_Click: 시작 실패 - 대상 찾을 수 없음."); lblStatus.Text = "상태: 오류! 대상을 찾을 수 없어 시작할 수 없습니다."; return; }
                
                LogTrace("btnStart_Click: 로깅 시작됨.");
                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }
        
        private void SearchMethod_Changed(object sender, RoutedEventArgs e)
        {
            if (lblTarget == null || txtTarget == null) return;
            if (rbFindByTitle.IsChecked == true) { lblTarget.Content = "대상 창 제목:"; txtTarget.ToolTip = "찾으려는 프로그램의 전체 창 제목을 입력하세요."; }
            else { lblTarget.Content = "프로세스 이름:"; txtTarget.ToolTip = "작업 관리자의 '세부 정보' 탭에 있는 프로세스 이름을 입력하세요 (예: notepad)"; }
            LogTrace($"SearchMethod_Changed: 탐색 방법 변경됨 - { (rbFindByTitle.IsChecked == true ? "창 제목" : "프로세스 이름") }");
        }
        
        private IntPtr GetTargetWindowHandle()
        {
            string target = txtTarget.Text;
            if (string.IsNullOrWhiteSpace(target)) return IntPtr.Zero;
            if (rbFindByTitle.IsChecked == true) { return FindWindow(null, target); }
            else
            {
                string processName = target.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ? Path.GetFileNameWithoutExtension(target) : target;
                Process[] processes = Process.GetProcessesByName(processName);
                if (processes.Length == 0) return IntPtr.Zero;
                var targetProcess = processes.FirstOrDefault(p => p.MainWindowHandle != IntPtr.Zero);
                return targetProcess?.MainWindowHandle ?? IntPtr.Zero;
            }
        }

        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e) { LogTrace("MyNotifyIcon_TrayMouseDoubleClick: 창 보이기."); this.Show(); this.WindowState = WindowState.Normal; this.Activate(); }
        private void MenuOpen_Click(object sender, RoutedEventArgs e) { LogTrace("MenuOpen_Click: 창 보이기."); this.Show(); this.WindowState = WindowState.Normal; this.Activate(); }
        private void MenuExit_Click(object sender, RoutedEventArgs e) { LogTrace("MenuExit_Click: 프로그램 종료 시작."); isExiting = true; this.Close(); }

        protected override void OnClosing(CancelEventArgs e)
        {
            if (!isExiting)
            {
                e.Cancel = true;
                this.Hide();
                LogTrace("Window OnClosing: 창 숨기기로 전환됨 (X 버튼).");
            }
            else
            {
                LogTrace("Window OnClosing: 실제 종료 진행. 설정 저장 및 리소스 정리 시작.");
                SaveApplicationSettings();
                LogTrace("Window OnClosing: 설정 저장 완료 (OnClosing 내부).");
                MyNotifyIcon.Dispose();
                LogTrace("Window OnClosing: NotifyIcon 정리 완료.");
                _ocrEngine?.Dispose();
                LogTrace("Window OnClosing: OCR 엔진 정리 완료.");
            }
            base.OnClosing(e);
        }

        private void Timer_Tick(object sender, EventArgs e) { PerformLogging(); }

        private void PerformLogging()
        {
            Gdi.Rectangle cropArea = Gdi.Rectangle.Empty;
            Gdi.Size bmpSize = Gdi.Size.Empty;
            try
            {
                LogTrace("===== PerformLogging 시작 =====");
                LogTrace("1. 대상 핸들 가져오기 시작...");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero)
                {
                    LogTrace("1-1. 대상 핸들 없음. 재탐색 시도...");
                    lblStatus.Text = "상태: 오류! 대상 창/프로세스를 찾을 수 없습니다.";
                    if (!searchTimer.IsEnabled) { timer.Stop(); searchTimer.Start(); lblStatus.Text = "대상 연결 끊김. 1분마다 재탐색합니다."; }
                    return;
                }
                LogTrace($"1-1. 대상 핸들 찾음: {hWnd}");
                LogTrace("2. 최소화 상태 확인 시작...");
                if (IsIconic(hWnd)) { LogTrace("2-1. 최소화됨. 작업 건너뜀."); lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다."; return; }
                LogTrace("2-1. 최소화되지 않음.");
                LogTrace("3. 창 크기 가져오기 시작...");
                GetWindowRect(hWnd, out RECT rect);
                int width = rect.Right - rect.Left;
                int height = rect.Bottom - rect.Top;
                if (width <= 0 || height <= 0) { LogTrace($"3-1. 유효하지 않은 창 크기({width}x{height}). 작업 건너뜀."); lblStatus.Text = "상태: 오류! 대상 창의 크기가 유효하지 않습니다."; return; }
                LogTrace($"3-1. 창 크기 확인: {width}x{height}");
                bmpSize = new Gdi.Size(width, height);
                LogTrace("4. 비트맵 객체 생성 시작...");
                using (var bmp = new Gdi.Bitmap(width, height, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    LogTrace("4-1. 비트맵 객체 생성 완료.");
                    LogTrace("5. 그래픽 컨텍스트 생성 및 PrintWindow 호출 시작...");
                    using (var g = Gdi.Graphics.FromImage(bmp))
                    {
                        IntPtr hdc = g.GetHdc();
                        LogTrace($"5-0. HDC 얻음: {hdc}. PrintWindow 호출.");
                        PrintWindow(hWnd, hdc, 2);
                        g.ReleaseHdc(hdc);
                        LogTrace($"5-0. HDC 해제.");
                    }
                    LogTrace("5-1. PrintWindow 완료.");
                    cropArea = new Gdi.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    if (cropArea.Right > bmp.Width || cropArea.Bottom > bmp.Height || cropArea.X < 0 || cropArea.Y < 0)
                    {
                        LogTrace($"6. 오류! 캡처 영역이 창 크기를 벗어남. bmp=({bmp.Width}x{bmp.Height}), crop=({cropArea.X},{cropArea.Y} {cropArea.Width}x{cropArea.Height}). 로깅 중지.");
                        timer.Stop(); btnStart.Content = "로깅 시작"; lblStatus.Text = "상태: 오류! 캡처 영역이 창 크기를 벗어났습니다.";
                        MessageBox.Show("캡처 영역 설정이 잘못되었습니다.\n대상 창의 크기나 위치가 변경되었을 수 있습니다.\n프로그램을 열어 영역을 다시 설정해주세요.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                        return;
                    }
                    LogTrace($"6. 이미지 자르기(Clone) 시작... [원본크기: {bmp.Width}x{bmp.Height}, 영역: {cropArea}]");
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        LogTrace("6-1. 이미지 자르기 완료.");
                        LogTrace("7. OCR 처리 시작...");
                        using (var page = OcrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            LogTrace($"7-1. OCR 처리 완료. 인식된 텍스트: '{rawText}'");
                            if (!string.IsNullOrWhiteSpace(rawText)) { ProcessOcrResult(rawText); } else { lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다."; }
                        }
                    }
                }
                LogTrace("===== PerformLogging 성공적으로 완료 =====");
            }
            catch (Exception ex)
            {
                LogTrace($"!!!!! PerformLogging에서 예외 발생 !!!!!\n{ex}");
                if (timer.IsEnabled) timer.Stop();
                if (searchTimer.IsEnabled) searchTimer.Stop();
                btnStart.Content = "로깅 시작";
                var sb = new StringBuilder();
                sb.AppendLine("캡처 중 예측하지 못한 오류가 발생하여 작업을 중지합니다.");
                sb.AppendLine("==============================================");
                sb.AppendLine($"[진단 정보]");
                sb.AppendLine($"전체 창 크기: {bmpSize.Width} x {bmpSize.Height}");
                sb.AppendLine($"잘라낼 영역 (X,Y,W,H): {cropArea.X}, {cropArea.Y}, {cropArea.Width}, {cropArea.Height}");
                sb.AppendLine("==============================================");
                Exception currentEx = ex;
                int indentLevel = 0;
                while (currentEx != null)
                {
                    sb.AppendLine($"\n[오류 레벨 {indentLevel}] {(indentLevel == 1 ? "(진짜 원인일 가능성이 높음)" : "")}");
                    sb.AppendLine($"  - 오류 유형: {currentEx.GetType().Name}");
                    sb.AppendLine($"  - 메시지: {currentEx.Message}");
                    sb.AppendLine($"  - 스택 트레이스:\n{currentEx.StackTrace}");
                    currentEx = currentEx.InnerException;
                    indentLevel++;
                }
                MessageBox.Show(sb.ToString(), "캡처 상세 오류 보고", MessageBoxButton.OK, MessageBoxImage.Error);
                lblStatus.Text = "상태: 캡처 오류 발생. 로깅 중지됨.";
            }
        }
        
        private void ProcessOcrResult(string rawText) 
        {
            LogTrace($"ProcessOcrResult: 원본 텍스트='{rawText}'");
            string processedText = rawText.Replace("-", "");
            string[] parts = processedText.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 2) { LogTrace($"ProcessOcrResult: 값 분리 오류, {parts.Length}개 분리됨."); lblStatus.Text = $"상태: 값 분리 오류 (인식된 값 {parts.Length}개)"; return; }
            if (decimal.TryParse(parts[0], out decimal val1) && decimal.TryParse(parts[1], out decimal val2))
            {
                decimal temp = Math.Truncate(val1 * 10) / 10m;
                decimal humid = Math.Truncate(val2 * 10) / 10m;
                LogTrace($"ProcessOcrResult: 숫자 변환 성공. temp={temp}, humid={humid}. DB 업로드 시작.");
                UploadToDatabase(temp, humid);
            }
            else { LogTrace($"ProcessOcrResult: 숫자 변환 실패. parts[0]='{parts[0]}', parts[1]='{parts[1]}'"); lblStatus.Text = $"상태: 숫자 변환 오류 ({parts[0]},{parts[1]})"; }
        }

        private void UploadToDatabase(decimal temp, decimal humid)
        {
            string pcName = txtPcName.Text;
            if (string.IsNullOrWhiteSpace(pcName)) { LogTrace("UploadToDatabase: PC 이름 없음. 건너뜀."); lblStatus.Text = "상태: PC 이름이 비어있어 DB 작업을 건너뜁니다."; return; }
            
            string connectionString = "Server=127.0.0.1;Port=3306;Database=smd;Uid=root;Pwd=password;"; // 실제 정보로 변경 필요
            
            LogTrace($"UploadToDatabase: DB 연결 시도 시작. PC={pcName}, T={temp}, H={humid}. 연결 문자열: {connectionString.Substring(0, connectionString.IndexOf("Pwd=") + 4)}******"); // 비밀번호 가리기

            MySqlConnection conn = null;
            MySqlTransaction trans = null;
            int rowsAffected = 0;

            try
            {
                LogTrace("UploadToDatabase: MySqlConnection 객체 생성 시도...");
                conn = new MySqlConnection(connectionString);
                LogTrace("UploadToDatabase: MySqlConnection 객체 생성 성공.");

                LogTrace("UploadToDatabase: conn.Open() 호출 시도...");
                conn.Open();
                LogTrace("UploadToDatabase: conn.Open() 호출 성공. DB 연결 성공.");
                
                LogTrace("UploadToDatabase: 트랜잭션 시작 시도...");
                trans = conn.BeginTransaction();
                LogTrace("UploadToDatabase: 트랜잭션 시작 성공.");

                using (MySqlCommand cmd = new MySqlCommand())
                {
                    cmd.Connection = conn;
                    cmd.Transaction = trans;

                    LogTrace("UploadToDatabase: repair_func_now UPDATE 문 준비...");
                    cmd.CommandText = "UPDATE smd.repair_func_now SET temp1 = @temp1, humid1 = @humid1, stdtime = NOW() WHERE line = @line;";
                    cmd.Parameters.Clear();
                    cmd.Parameters.AddWithValue("@line", pcName);
                    cmd.Parameters.AddWithValue("@temp1", temp);
                    cmd.Parameters.AddWithValue("@humid1", humid);
                    LogTrace($"UploadToDatabase: repair_func_now UPDATE 실행.");
                    rowsAffected = cmd.ExecuteNonQuery();
                    LogTrace($"UploadToDatabase: repair_func_now UPDATE 완료. 영향받은 행: {rowsAffected}");

                    LogTrace("UploadToDatabase: repair_func_new_log INSERT 문 준비...");
                    cmd.CommandText = "INSERT INTO smd.repair_func_new_log (line, temp1, humid1, stdtime) VALUES (@line, @temp1, @humid1, NOW());";
                    LogTrace($"UploadToDatabase: repair_func_new_log INSERT 실행.");
                    cmd.ExecuteNonQuery();
                    LogTrace($"UploadToDatabase: repair_func_new_log INSERT 완료.");
                }

                LogTrace("UploadToDatabase: 트랜잭션 커밋 시도...");
                trans.Commit();
                LogTrace("UploadToDatabase: 트랜잭션 커밋 성공.");

                if (rowsAffected > 0) { lblStatus.Text = $"상태: {DateTime.Now:T} - DB 업데이트 성공!"; }
                else { lblStatus.Text = $"상태: {DateTime.Now:T} - 로그 기록 완료 (now 테이블에 해당 PC 없음)"; }
            }
            catch (Exception ex)
            {
                LogTrace($"!!!!! UploadToDatabase (실행 단계)에서 예외 발생 !!!!!\n{ex.ToString()}");
                try { trans?.Rollback(); LogTrace("UploadToDatabase: 예외 발생으로 트랜잭션 롤백 시도."); } 
                catch (Exception exRollback) { LogTrace($"UploadToDatabase: 트랜잭션 롤백 중 예외 발생: {exRollback.Message}"); }
                lblStatus.Text = $"상태: DB 오류! {ex.Message}";
            }
            finally
            {
                if (conn != null && conn.State != System.Data.ConnectionState.Closed)
                {
                    LogTrace("UploadToDatabase: DB 연결 종료 시도...");
                    conn.Close();
                    LogTrace("UploadToDatabase: DB 연결 종료 완료.");
                }
                else
                {
                    LogTrace("UploadToDatabase: DB 연결이 없거나 이미 닫혀있음.");
                }
            }
        }
        
        private void btnSelectArea_Click(object sender, RoutedEventArgs e)
        {
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd == IntPtr.Zero) { MessageBox.Show("먼저 유효한 '대상 창/프로세스 이름'을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; }
            this.Visibility = Visibility.Hidden;
            System.Threading.Thread.Sleep(200);
            var selectionWindow = new SelectionWindow();
            selectionWindow.Activate();
            if (selectionWindow.ShowDialog() == true)
            {
                Wpf.Rect screenRect = selectionWindow.SelectedArea;
                GetWindowRect(hWnd, out RECT windowRect);
                int relativeX = (int)screenRect.X - windowRect.Left;
                int relativeY = (int)screenRect.Y - windowRect.Top;
                relativeX = Math.Max(0, relativeX);
                relativeY = Math.Max(0, relativeY);
                txtX.Text = relativeX.ToString();
                txtY.Text = relativeY.ToString();
                txtWidth.Text = ((int)screenRect.Width).ToString();
                txtHeight.Text = ((int)screenRect.Height).ToString();
                LogTrace($"btnSelectArea_Click: 새 영역 설정 - X={txtX.Text}, Y={txtY.Text}, W={txtWidth.Text}, H={txtHeight.Text}");
                UpdatePreviewImage();
            }
            this.Visibility = Visibility.Visible;
            this.Activate();
        }

        private void UpdatePreviewImage()
        {
            try
            {
                LogTrace("UpdatePreviewImage: 미리보기 업데이트 시작.");
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero) { LogTrace("UpdatePreviewImage: 대상 핸들 없음."); return; }
                if (IsIconic(hWnd)) { LogTrace("UpdatePreviewImage: 대상 최소화됨."); MessageBox.Show("대상 창이 최소화되어 있어 미리보기를 생성할 수 없습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); imgPreview.Source = null; return; }
                
                if (!int.TryParse(txtX.Text, out int capX) || !int.TryParse(txtY.Text, out int capY) ||
                    !int.TryParse(txtWidth.Text, out int capW) || !int.TryParse(txtHeight.Text, out int capH) ||
                    capW <= 0 || capH <= 0)
                {
                    LogTrace("UpdatePreviewImage: 캡처 좌표/크기 값이 유효하지 않음.");
                    imgPreview.Source = null;
                    return;
                }

                GetWindowRect(hWnd, out RECT rect);
                int width = rect.Right - rect.Left;
                int height = rect.Bottom - rect.Top;
                if (width <= 0 || height <= 0) { LogTrace($"UpdatePreviewImage: 유효하지 않은 창 크기({width}x{height})."); return; }

                using (var bmp = new Gdi.Bitmap(width, height, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Gdi.Graphics.FromImage(bmp)) { IntPtr hdc = g.GetHdc(); PrintWindow(hWnd, hdc, 2); g.ReleaseHdc(hdc); }
                    var cropArea = new Gdi.Rectangle(capX, capY, capW, capH);
                    
                    if (cropArea.Right > bmp.Width || cropArea.Bottom > bmp.Height || cropArea.X < 0 || cropArea.Y < 0)
                    {
                         LogTrace($"UpdatePreviewImage: 오류! 미리보기 캡처 영역이 창 크기를 벗어남. bmp=({bmp.Width}x{bmp.Height}), crop=({cropArea.X},{cropArea.Y} {cropArea.Width}x{cropArea.Height}).");
                         imgPreview.Source = null;
                         MessageBox.Show("미리보기를 위한 캡처 영역이 창 크기를 벗어났습니다. 영역을 다시 설정해주세요.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                         return;
                    }

                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat)) 
                    { 
                        imgPreview.Source = BitmapToImageSource(croppedBmp); 
                        croppedBmp.Save(previewImagePath, Gdi.Imaging.ImageFormat.Png); 
                        LogTrace($"UpdatePreviewImage: 미리보기 이미지 저장 완료 - {previewImagePath}");
                    }
                }
            }
            catch (Exception ex) { LogTrace($"!!!!! UpdatePreviewImage에서 예외 발생 !!!!!\n{ex}");}
        }

        Wpf.Media.Imaging.BitmapImage BitmapToImageSource(Gdi.Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, Gdi.Imaging.ImageFormat.Png);
                memory.Position = 0;
                var bitmapimage = new Wpf.Media.Imaging.BitmapImage();
                bitmapimage.BeginInit();
                bitmapimage.StreamSource = memory;
                bitmapimage.CacheOption = Wpf.Media.Imaging.BitmapCacheOption.OnLoad;
                bitmapimage.EndInit();
                return bitmapimage;
            }
        }
    }
}

&lt;/details>

이 코드를 적용하신 후, 문제가 발생하는 PC에서 다시 실행해 보시고, 프로그램이 종료되면 C:\Agent\funcenvget\logs\trace_log.txt 파일의 맨 마지막에 기록된 내용을 알려주시면 문제 해결에 큰 도움이 됩니다.


소스
netstat에서 0.0.0.0:3306 이거는 누가쓰잇다는건가?



netstat에서 0.0.0.0:3306이라고 표시되는 것은, 해당 PC의 **MySQL 서버(기본 포트 3306)가 현재 PC에 할당된 모든 IP 주소로부터의 연결 요청을 기다리고 있다(수신 대기 중이다)**는 의미입니다.

좀 더 자세히 설명해 드릴게요.

netstat의 0.0.0.0:3306 의미
netstat는 네트워크 연결, 라우팅 테이블, 네트워크 인터페이스 통계 등을 보여주는 명령어입니다. 여기서 0.0.0.0:3306은 다음과 같이 해석할 수 있습니다:

0.0.0.0:

이는 "지정되지 않은 IP 주소" 또는 "모든 사용 가능한 로컬 IP 주소"를 의미합니다.
서버 프로그램이 특정 IP 주소에만 바인딩(연결)되지 않고, 해당 컴퓨터가 가진 모든 네트워크 인터페이스(예: 여러 개의 랜카드, Wi-Fi, 로컬 루프백 주소 127.0.0.1 등)를 통해 들어오는 연결을 수신할 준비가 되어 있다는 뜻입니다.
IPv4 주소 체계에서 "모든 주소"를 나타냅니다. (IPv6에서는 ::로 표시됩니다)
:3306:

콜론 뒤의 숫자는 포트 번호를 나타냅니다.
3306은 MySQL 데이터베이스 서버의 기본 포트 번호입니다. 다른 프로그램도 이 포트를 사용할 수 있지만, 일반적으로 MySQL이 사용합니다.
LISTENING (수신 대기 중):

netstat -ano 등의 명령어로 확인했을 때 이 주소와 포트가 LISTENING 상태라면, 해당 포트에서 외부의 연결 요청을 받아들일 준비가 되어 있다는 의미입니다.
결론적으로, 0.0.0.0:3306 LISTENING은 "이 컴퓨터에서 실행 중인 MySQL 서버가 모든 네트워크 인터페이스의 3306번 포트로 들어오는 연결 요청을 기다리고 있습니다."라고 해석할 수 있습니다.

추가 정보
누가 사용 중인가?: netstat -ano | findstr ":3306" (Windows) 또는 sudo netstat -tulnp | grep 3306 (Linux) 명령어를 사용하면 해당 포트를 사용 중인 프로세스의 ID(PID)를 확인할 수 있습니다. 이 PID를 작업 관리자나 해당 OS의 프로세스 목록에서 찾아보면 어떤 프로그램이 MySQL 서버를 실행하고 있는지 알 수 있습니다.
외부 접속: bind-address = 0.0.0.0 설정은 MySQL 서버가 외부 IP 주소에서의 접속도 허용한다는 의미입니다. 보안을 위해서는 MySQL 자체의 사용자 계정 권한 설정과 운영체제의 방화벽 설정을 통해 실제 외부 접속을 제어해야 합니다. 만약 127.0.0.1:3306으로 표시된다면, 해당 PC 내부에서만 MySQL에 접속할 수 있다는 의미입니다.

이 피씨가 mysql설치해서쓰고잇으면 내프로그램의 mysql로 다른데로보낼건데 포트충돌은아닌건가




생각하는 과정 표시
네, 좋은 질문입니다. 결론부터 말씀드리면, 일반적으로 포트 충돌은 발생하지 않습니다.

상황을 조금 더 자세히 설명해 드릴게요.

로컬 PC의 MySQL 서버:

사용자님의 PC에 MySQL이 설치되어 실행 중이라면, 이 MySQL 서버는 특정 포트(기본값 3306)를 사용해서 외부의 연결 요청을 기다리고(LISTENING) 있습니다.
netstat에서 0.0.0.0:3306 LISTENING이라고 나오는 것은 바로 이 로컬 MySQL 서버가 "내 PC의 3306번 포트로 누가 접속하려고 하면 내가 응답할게!" 하고 대기 중이라는 뜻입니다.
사용자님의 프로그램 (MySQL 클라이언트):

사용자님의 프로그램(funcenvget)은 MySQL 데이터베이스에 데이터를 "보내는" 역할을 합니다. 즉, MySQL 클라이언트로 동작합니다.
이 프로그램이 다른 곳(원격지)에 있는 MySQL 서버로 데이터를 보낼 때, 프로그램은 다음과 같이 동작합니다.
목적지: 원격지 MySQL 서버의 IP 주소와 포트 번호(예: 원격서버IP:3306)로 접속을 시도합니다.
출발지: 사용자님의 PC에서는 이 연결을 위해 **임시로 사용 가능한 아무 포트(ephemeral port, 보통 1024번 이후의 높은 번호의 포트 중 OS가 할당해주는 포트)**를 사용합니다. 이 포트는 3306번이 아닙니다.
포트 충돌이 아닌 이유:

포트 충돌은 보통 하나의 PC에서 두 개 이상의 서버 프로그램이 '같은 포트 번호'를 동시에 사용하려고 할 때 발생합니다. 예를 들어, 로컬 PC에서 MySQL 서버도 3306번 포트를 쓰려고 하고, 동시에 다른 어떤 서버 프로그램도 3306번 포트를 쓰려고 하면 충돌이 납니다.
하지만 사용자님의 경우는 다릅니다.
로컬 PC의 MySQL 서버는 3306번 포트에서 요청을 기다리는 서버 역할입니다.
사용자님의 프로그램은 다른 PC의 3306번 포트로 데이터를 보내는 클라이언트 역할이며, 데이터를 보낼 때 자신의 PC에서는 3306번이 아닌 다른 임시 포트를 사용합니다.
비유하자면:

로컬 PC의 MySQL 서버는 "3306번 창구에서 손님을 기다리는 은행원"입니다.
사용자님의 프로그램은 "다른 동네 은행의 3306번 창구로 편지를 보내는 우체부"입니다. 우체부는 우리 동네 은행의 3306번 창구를 사용하지 않고, 그냥 우체국에서 출발하여 편지를 배달합니다.
따라서, 사용자님의 프로그램의 연결 문자열(connection string)에 있는 서버 주소와 포트가 로컬 PC의 MySQL 서버가 아닌, 데이터를 보내려는 원격지 MySQL 서버의 주소와 포트로 정확히 설정되어 있다면, 로컬 PC에 설치된 MySQL 서버와 포트 충돌 없이 정상적으로 작동합니다.