네, 알겠습니다. 요청하신 기능들을 반영하여 기존 스크립트를 업데이트하고, 기술적 한계가 있는 부분에 대해서는 명확히 설명해 드리겠습니다.

변경된 주요 내용은 다음과 같습니다.

경로 직접 지정: 코드 내에서 분석할 솔루션 경로와 출력 폴더 경로를 직접 지정하도록 변경하여 편의성을 높였습니다.

클래스 변수 추출: 각 클래스의 멤버 변수(전역 변수)를 식별하여 속성.txt 파일에 함께 기록합니다.

미사용 함수 분석 및 호출 경로 추적 (중요한 설명):

미사용 함수 제거: 어떤 함수가 솔루션 전체에서 한 번도 호출되지 않았는지(unused)를 판단하는 것은 단순한 텍스트 분석으로는 불가능합니다. 이는 컴파일러처럼 코드의 모든 문맥(상속, 인터페이스, 오버로딩 등)을 이해하고 전체 프로젝트의 호출 관계(Call Graph)를 그려야 알 수 있는 매우 복잡한 정적 코드 분석 영역입니다. Python 스크립트로 이 기능을 정확히 구현하는 것은 현실적으로 어렵습니다.

호출 경로 추적: 위와 같은 이유로, 특정 함수가 호출하는 다른 모든 함수를 완벽하게 추적하여 경로를 그리는 것 또한 불가능합니다.

따라서 이 두 가지 기능은 스크립트에 포함하지 않았습니다. 부정확한 정보를 제공하는 것보다, 명확한 한계를 알려드리는 것이 더 중요하기 때문입니다. 이러한 분석은 Visual Studio의 '모든 참조 찾기' 기능이나 ReSharper, SonarQube와 같은 전문 정적 분석 도구를 사용하시는 것이 올바른 방법입니다.

C# 솔루션 분석 스크립트 (v2)
아래 코드를 이전과 같이 .py 파일로 저장하고, 상단의 --- 사용자 설정 영역 --- 부분을 자신의 환경에 맞게 수정한 후 실행하세요.

Python

import os
import re
from datetime import datetime
import logging

# --- 로깅 설정 ---
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')


# --- 사용자 설정 영역 ---

# 1. 분석할 C# 솔루션 파일의 전체 경로를 지정하세요.
# 예시: SOLUTION_PATH = r"C:\MyProjects\MySolution\MySolution.sln"
# r"..." 형태는 경로의 백슬래시(\)를 문자로 인식하게 해줘서 편리합니다.
SOLUTION_PATH = r"여기에_분석할_솔루션_파일의_전체_경로를_입력하세요.sln"

# 2. 결과물을 저장할 기본 폴더 경로를 지정하세요.
# 예시: OUTPUT_DIR_BASE = r"C:\Temp\Analysis"
# 지정된 폴더 하위에 '솔루션명_Processed_...' 폴더가 생성됩니다.
OUTPUT_DIR_BASE = r"여기에_결과물을_저장할_폴더_경로를_입력하세요"

# --- 사용자 설정 영역 끝 ---


def sanitize_name(name):
    """파일 및 폴더명으로 사용할 수 없는 문자를 제거하거나 대체합니다."""
    name = re.sub(r'[<>,\s?]', '_', name).replace(':', '_')
    return re.sub(r'[\\/*?"|]', '', name).strip()

def find_matching_brace(code_str, start_pos):
    """주어진 코드 문자열에서 시작 괄호에 대응하는 닫는 괄호의 위치를 찾습니다."""
    if code_str[start_pos] != '{':
        return -1
    brace_count = 1
    for i in range(start_pos + 1, len(code_str)):
        if code_str[i] == '{':
            brace_count += 1
        elif code_str[i] == '}':
            brace_count -= 1
        if brace_count == 0:
            return i
    return -1

def clean_code(code):
    """코드에서 주석과 빈 줄을 제거합니다."""
    # 여러 줄 주석 제거 (/* ... */)
    code = re.sub(r'/\*.*?\*/', '', code, flags=re.DOTALL)
    # 한 줄 주석 제거 (// ...)
    code = re.sub(r'//.*?$', '', code, flags=re.MULTILINE)
    # 빈 줄 제거
    lines = [line for line in code.splitlines() if line.strip()]
    return '\n'.join(lines)

def get_cs_files_from_solution(sln_path):
    """솔루션(.sln) 파일을 분석하여 포함된 모든 C# 소스 파일(.cs) 목록을 반환합니다."""
    cs_files = []
    sln_dir = os.path.dirname(sln_path)
    try:
        with open(sln_path, 'r', encoding='utf-8-sig') as f:
            content = f.read()
        project_pattern = re.compile(r'Project\("\{.*?}"\) = ".*?", "(.*?\.csproj)"', re.IGNORECASE)
        for proj_path in project_pattern.findall(content):
            full_proj_path = os.path.join(sln_dir, proj_path.replace('\\', os.sep))
            if not os.path.exists(full_proj_path):
                logging.warning(f"프로젝트 파일을 찾을 수 없습니다: {full_proj_path}")
                continue
            
            proj_dir = os.path.dirname(full_proj_path)
            with open(full_proj_path, 'r', encoding='utf-8-sig') as proj_file:
                proj_content = proj_file.read()
            # .csproj에서 <Compile Include="..."/> 찾기
            cs_pattern = re.compile(r'<Compile\s+Include="(.*?\.cs)"\s*/>')
            for cs_path in cs_pattern.findall(proj_content):
                full_cs_path = os.path.join(proj_dir, cs_path.replace('\\', os.sep))
                if os.path.exists(full_cs_path):
                    cs_files.append(os.path.normpath(full_cs_path))
    except Exception as e:
        logging.error(f"솔루션 파일을 처리하는 중 오류 발생: {e}")
    return list(set(cs_files))

def analyze_and_extract(sln_path, output_base_dir):
    """솔루션 분석 및 함수/변수 추출을 수행하는 메인 함수."""
    # --- 출력 폴더 설정 ---
    sln_name = os.path.splitext(os.path.basename(sln_path))[0]
    timestamp = datetime.now().strftime("%Y%m%d_%H%MS")
    output_dir = os.path.join(output_base_dir, f"{sln_name}_Processed_{timestamp}")
    try:
        os.makedirs(output_dir, exist_ok=True)
        logging.info(f"출력 폴더: {output_dir}")
    except OSError as e:
        logging.error(f"출력 폴더를 생성할 수 없습니다: {e}")
        return

    # --- C# 파일 목록 가져오기 ---
    cs_files = get_cs_files_from_solution(sln_path)
    if not cs_files:
        logging.warning("솔루션에서 처리할 C# 파일을 찾지 못했습니다.")
        return
    logging.info(f"총 {len(cs_files)}개의 C# 파일을 분석합니다.")

    total_functions_extracted = 0
    for file_path in cs_files:
        try:
            with open(file_path, 'r', encoding='utf-8-sig') as f:
                clean_code_str = clean_code(f.read())
            
            namespace_match = re.search(r'namespace\s+([^{]+)', clean_code_str)
            current_namespace = namespace_match.group(1).strip() if namespace_match else "NoNamespace"

            class_pattern = re.compile(r'(?:public|internal|private|protected|static|sealed|abstract)\s*.*?(class|interface|struct)\s+([\w\d<>,_:\s]+?)\s*\{')
            for class_match in class_pattern.finditer(clean_code_str):
                class_start_brace_pos = class_match.end() - 1
                class_end_brace_pos = find_matching_brace(clean_code_str, class_start_brace_pos)
                if class_end_brace_pos == -1: continue

                class_name_raw = class_match.group(2).strip()
                class_name = re.sub(r'<.*?>', '', class_name_raw).strip().split(':')[0].strip()
                class_body_full = clean_code_str[class_start_brace_pos + 1 : class_end_brace_pos]
                
                # 클래스 본문에서 메서드들을 먼저 찾아서 저장
                methods = []
                method_pattern = re.compile(r'((?:public|private|protected|internal|static|virtual|override|async|unsafe|extern|new|sealed)\s*.*?)??([\w\d_~]+)\s*(<.*?>)?\s*\((.*?)\)\s*(?:where\s+.*?)?\s*\{')
                
                # 메서드 본문을 임시로 대체할 고유한 문자열
                placeholder_template = "METHOD_PLACEHOLDER_{}"
                temp_class_body = class_body_full
                
                for i, method_match in enumerate(method_pattern.finditer(class_body_full)):
                    method_start_brace_pos = method_match.end() - 1
                    method_end_brace_pos = find_matching_brace(class_body_full, method_start_brace_pos)
                    if method_end_brace_pos == -1: continue
                    
                    # 메서드 전체(시그니처 + 몸체)를 추출
                    method_full_text = class_body_full[method_match.start() : method_end_brace_pos + 1]
                    methods.append((method_match, class_body_full[method_start_brace_pos + 1 : method_end_brace_pos].strip()))
                    
                    # 찾은 메서드를 placeholder로 대체
                    temp_class_body = temp_class_body.replace(method_full_text, placeholder_template.format(i))

                # 메서드를 제외한 나머지 코드를 클래스 변수로 간주
                class_variables = "\n".join([line.strip() for line in temp_class_body.splitlines() if not line.strip().startswith("METHOD_PLACEHOLDER_") and line.strip()])

                # 저장된 메서드들을 파일로 저장
                for method_match, method_body_content in methods:
                    method_name_raw = method_match.group(2).strip()
                    method_name = method_name_raw.replace('~', 'Finalizer_')
                    if method_name == class_name:
                        method_name = "Constructor"

                    # 오버로딩 구분을 위한 파라미터 정보 추가
                    params = method_match.group(4).strip().replace(" ", "")
                    param_types = "_".join([p.split(',')[0].split('=')[0].strip() for p in re.split(r',(?![^<]*>)', params) if p]) # 제네릭 <T,U> 고려
                    
                    s_ns = sanitize_name(current_namespace)
                    s_class = sanitize_name(class_name)
                    s_method = sanitize_name(method_name)
                    s_params = sanitize_name(param_types)

                    folder_name = f"{s_ns}_{s_class}_{s_method}"
                    if s_params:
                        folder_name += f"_{s_params}"

                    target_dir = os.path.join(output_dir, folder_name)
                    os.makedirs(target_dir, exist_ok=True)
                    
                    with open(os.path.join(target_dir, "속성.txt"), 'w', encoding='utf-8') as pf:
                        pf.write(f"네임스페이스: {current_namespace}\n")
                        pf.write(f"클래스: {class_name_raw}\n")
                        pf.write(f"함수명: {method_name_raw}\n")
                        pf.write("\n--- 클래스 멤버 변수 ---\n")
                        pf.write(class_variables if class_variables else "N/A")
                        
                    with open(os.path.join(target_dir, f"{s_method}.cs"), 'w', encoding='utf-8') as ff:
                        ff.write(method_body_content)
                    
                    total_functions_extracted += 1
        except Exception as e:
            logging.error(f"{file_path} 파일을 처리하는 중 오류 발생: {e}")

    logging.info(f"작업 완료. 총 {total_functions_extracted}개의 함수를 추출했습니다.")

def main():
    """스크립트 실행을 위한 메인 함수."""
    if not os.path.isfile(SOLUTION_PATH):
        logging.error(f"솔루션 경로를 찾을 수 없습니다: '{SOLUTION_PATH}'")
        logging.error("스크립트 상단의 SOLUTION_PATH 변수를 올바른 .sln 파일 경로로 수정해주세요.")
        return
    if not os.path.isdir(OUTPUT_DIR_BASE):
        logging.error(f"출력 폴더 경로를 찾을 수 없습니다: '{OUTPUT_DIR_BASE}'")
        logging.error("스크립트 상단의 OUTPUT_DIR_BASE 변수를 올바른 폴더 경로로 수정해주세요.")
        return

    analyze_and_extract(SOLUTION_PATH, OUTPUT_DIR_BASE)

if __name__ == "__main__":
    main()
사용 방법
스크립트 저장: 위 코드를 .py 파일로 저장합니다.

경로 수정: 스크립트 파일 상단의 --- 사용자 설정 영역 --- 부분을 에디터로 열어 SOLUTION_PATH와 OUTPUT_DIR_BASE 변수의 값을 실제 경로에 맞게 반드시 수정합니다.

SOLUTION_PATH: 분석할 .sln 파일의 전체 경로 (예: "C:\\Users\\MyUser\\Documents\\Project\\MySolution.sln")

OUTPUT_DIR_BASE: 결과물을 저장할 폴더 (예: "D:\\CSharp_Analysis")

실행: 터미널에서 python [스크립트파일명].py 명령으로 실행하면, 지정된 경로의 솔루션을 분석하여 결과물을 생성합니다. 별도의 GUI 창은 나타나지 않고, 모든 진행 상황은 터미널 창에 출력됩니다.