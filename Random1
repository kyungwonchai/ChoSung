요청하신 내용을 반영하여 ImageListScreen과 ImageDisplayScreen의 UI 동작을 업데이트하겠습니다. fetch 버튼을 이미지 선택 시 숨기고, back 버튼을 누르면 다시 나타나도록 합니다. 또한, fetch 버튼에 이미지 제목을 표시하여 공간 효율을 높이겠습니다.

MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import kotlin.concurrent.fixedRateTimer
import kotlin.math.roundToInt

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    ImageListScreen()
                }
            }
        }
    }
}

@Composable
fun ImageListScreen() {
    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }
    var selectedImageTitle by remember { mutableStateOf("") }
    var selectedDatetime by remember { mutableStateOf("") }
    var isRefreshing by remember { mutableStateOf(false) }

    val scope = rememberCoroutineScope()

    Column {
        if (selectedImage == null) {
            Button(
                onClick = {
                    scope.launch {
                        imageList = fetchDataFromDatabase()
                    }
                },
                modifier = Modifier.padding(16.dp)
            ) {
                Text(if (imageList.isEmpty()) "Fetch Data" else imageList.joinToString(", ") { it.imageTitle })
            }
        }

        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.imageTitle, modifier = Modifier.weight(1f))
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        scope.launch {
                            selectedImage = fetchImageFromDatabase(imageData.imageTitle, imageData.datetime)
                            selectedImageTitle = imageData.imageTitle
                            selectedDatetime = imageData.datetime
                        }
                    }) {
                        Text("Load Image")
                    }
                }
            }
        }

        selectedImage?.let { bitmap ->
            ImageDisplayScreen(
                bitmap = bitmap,
                imageTitle = selectedImageTitle,
                datetime = selectedDatetime,
                onBack = {
                    selectedImage = null
                },
                onFit = {
                    selectedImage = bitmap
                },
                isRefreshing = isRefreshing,
                onToggleRefresh = { isRefreshing = it }
            )
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        currentBitmap = newBitmap
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        scale *= zoom
                        offset = Offset(offset.x + pan.x, offset.y + pan.y)
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            Log.d("Database", "Attempting to connect to database...")
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            Log.d("Database", "Connection established.")
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
                Log.d("Database", "Fetched data: $imageTitle, $datetime")
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            Log.e("Database", "Error fetching data", e)
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            Log.d("Database", "Attempting to fetch image for $imageTitle at $datetime...")
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
                Log.d("Database", "Image fetched successfully.")
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            Log.e("Database", "Error fetching image", e)
            null
        }
    }
}
주요 변경 사항:
selectedImage가 null일 때만 Fetch Data 버튼 표시: 이미지가 선택되지 않은 경우에만 Fetch Data 버튼이 나타나도록 조건문을 추가했습니다.
Fetch Data 버튼에 이미지 제목 표시: Fetch Data 버튼의 텍스트를 이미지 목록의 제목으로 설정했습니다.
ImageDisplayScreen 호출 시 이미지 타이틀과 날짜 전달: 이미지가 선택되면 ImageDisplayScreen 함수에 이미지 타이틀과 날짜를 전달하도록 했습니다.