. 아래는 다양한 작업에 적용할 수 있는 일반적인 공용 함수로 BackgroundWorker를 사용하는 방법입니다.
BackgroundWorkerUtility.cs

csharp

using System;
using System.ComponentModel;

namespace YourNamespace
{
    public class BackgroundWorkerUtility
    {
        public static BackgroundWorker CreateWorker(Action<BackgroundWorker, DoWorkEventArgs> doWork, Action<ProgressChangedEventArgs> progressChanged)
        {
            var worker = new BackgroundWorker { WorkerReportsProgress = true };
            worker.DoWork += (sender, e) => doWork((BackgroundWorker)sender, e);
            worker.ProgressChanged += (sender, e) => progressChanged(e);
            return worker;
        }
    }
}

MainWindow.xaml.cs

csharp

using System;
using System.ComponentModel;
using System.Windows;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        MySplashScreen mySplashScreen;
        BackgroundWorker bgWorker;

        public MainWindow()
        {
            InitializeComponent();

            bgWorker = BackgroundWorkerUtility.CreateWorker(DoWork, ProgressChanged);
        }

        private void DoWork(BackgroundWorker worker, DoWorkEventArgs e)
        {
            // 대규모 작업 수행
            for (int i = 1; i <= 100; i++)
            {
                // 임의의 작업, 예를 들어, i번째 행을 엑셀에서 읽기
                // ...

                // 작업 진행을 사용자에게 알림
                worker.ReportProgress(i);
            }
        }

        private void ProgressChanged(ProgressChangedEventArgs e)
        {
            mySplashScreen.UpdateProgress(e.ProgressPercentage);
        }

        private void UploadExcelButton_Click(object sender, RoutedEventArgs e)
        {
            mySplashScreen = new MySplashScreen();
            mySplashScreen.Show();

            bgWorker.RunWorkerAsync();
        }
    }
}

이렇게 하면 BackgroundWorkerUtility에서 BackgroundWorker 객체를 만들어 주며, 이를 여러 곳에서 재사용할 수 있습니다. DoWork와 ProgressChanged는 람다식