using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System.Collections.ObjectModel;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Input;
using Microsoft.EntityFrameworkCore; // For ToListAsync()
using System.Windows; // For MessageBox

namespace LockerManagementApp.ViewModels
{
    public class MainViewModel : ViewModelBase
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments = new ObservableCollection<LockerAssignment>();
        private LockerAssignment? _selectedAssignment;
        private string _statusBarText = "Ready";
        private string _currentAdmin = "홍길동A"; // Example: Get this from login or config

        public ObservableCollection<LockerAssignment> LockerAssignments
        {
            get => _lockerAssignments;
            set => SetProperty(ref _lockerAssignments, value);
        }

        public LockerAssignment? SelectedAssignment
        {
            get => _selectedAssignment;
            set
            {
                if (SetProperty(ref _selectedAssignment, value))
                {
                    // Raise CanExecuteChanged for commands that depend on selection
                    ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public string StatusBarText
        {
            get => _statusBarText;
            set => SetProperty(ref _statusBarText, value);
        }

        // --- Commands ---
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; } // Command to easily clear user info

        // --- Predefined Lists for ComboBoxes/Lookups (Improvement) ---
        // These could be loaded from DB or config
        public List<string> LockerTypes { get; } = new List<string> { "개인사물함", "락커", "신발장" };
        public List<string> Floors { get; } = new List<string> { "B1", "1", "2", "3", "4" };
        // Zones might be dynamic, but provide some examples
        public List<string> Zones { get; } = new List<string> { "A", "B", "C", "D", "E", "F", "G", "H", "B1", "B2", "B3", "B4", "1F", "2F", "3F", "4F", "기타" };
        public List<string> SubParts { get; } = new List<string> { "Main(시생산)", "MainA", "MainB", "MainC" /* ...add all A-Z */ };
        public List<string> Administrators { get; } = new List<string> { "홍길동A", "홍길동B", "홍길동C" /* ...add all A-X */ };


        public MainViewModel()
        {
            _context = new LockerDbContext();

            LoadDataCommand = new RelayCommand(async _ => await LoadDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker); // Note: Adding requires Save
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);

            // Load data on startup
            _ = LoadDataAsync();
        }

        private async Task LoadDataAsync()
        {
            StatusBarText = "Loading data...";
            try
            {
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor)
                                               .ThenBy(l => l.Zone)
                                               .ThenBy(l => l.SpecificLocation)
                                               .ToListAsync();
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"Loaded {LockerAssignments.Count} records.";
            }
            catch (Exception ex)
            {
                StatusBarText = $"Error loading data: {ex.Message}";
                MessageBox.Show($"Database connection or query failed:\n{ex.Message}\n\nCheck your connection string in App.config and ensure the database server is running.", "Load Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task SaveChangesAsync()
        {
            StatusBarText = "Saving changes...";
            try
            {
                // Basic Validation Example (ensure physical location is unique if adding)
                // More robust validation should be in the model or a validation service
                var duplicates = LockerAssignments
                    .Where(l => _context.Entry(l).State == EntityState.Added || _context.Entry(l).State == EntityState.Modified)
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key);

                if (duplicates.Any())
                {
                     MessageBox.Show($"Cannot save. Duplicate physical locker locations found: {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "Validation Error", MessageBoxButton.OK, MessageBoxImage.Warning);
                     StatusBarText = "Save failed due to duplicate locations.";
                     return; // Prevent saving
                }


                // Assign current admin before saving changes
                var changedEntries = _context.ChangeTracker.Entries<LockerAssignment>()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

                foreach(var entry in changedEntries)
                {
                    entry.Entity.Administrator = _currentAdmin; // Set the admin who made the change
                    // LastUpdated is handled by DbContext override
                }


                int changedCount = await _context.SaveChangesAsync();
                StatusBarText = $"Saved {changedCount} changes successfully.";
                // Optional: Reload data to refresh any calculated fields or defaults from DB
                // await LoadDataAsync();
            }
            catch (DbUpdateException dbEx) // Catch specific DB errors
            {
                 // Check inner exception for constraint violations etc.
                var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                StatusBarText = $"Error saving data: {innerExceptionMessage}";
                MessageBox.Show($"Failed to save changes to the database:\n{innerExceptionMessage}", "Save Error", MessageBoxButton.OK, MessageBoxImage.Error);
                 // Consider reverting changes if save fails completely
                 // await RollbackChangesAsync(); // Implement rollback logic if needed
            }
            catch (Exception ex)
            {
                StatusBarText = $"Error saving data: {ex.Message}";
                MessageBox.Show($"An unexpected error occurred while saving:\n{ex.Message}", "Save Error", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void AddNewLocker(object? parameter)
        {
            var newAssignment = new LockerAssignment
            {
                // Set default values if appropriate
                LockerType = LockerTypes.FirstOrDefault() ?? "개인사물함",
                Floor = Floors.FirstOrDefault() ?? "1",
                Zone = Zones.FirstOrDefault() ?? "A",
                SpecificLocation = "New-" + Guid.NewGuid().ToString().Substring(0, 4), // Placeholder
                Administrator = _currentAdmin,
                LastUpdated = DateTime.Now // Set initial time
            };
            LockerAssignments.Add(newAssignment);
            _context.LockerAssignments.Add(newAssignment); // Add to context tracking
            SelectedAssignment = newAssignment; // Select the new row for editing
            StatusBarText = "New locker added. Fill details and Save.";
        }

        private async Task DeleteSelectedAsync()
        {
            if (SelectedAssignment == null) return;

            if (MessageBox.Show($"Are you sure you want to delete the record for {SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}?",
                                "Confirm Delete", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "Deleting record...";
                try
                {
                    var assignmentToDelete = SelectedAssignment; // Keep reference
                    _context.LockerAssignments.Remove(assignmentToDelete);
                    int changedCount = await _context.SaveChangesAsync(); // Save deletion immediately

                    // Remove from ObservableCollection only after successful DB delete
                    LockerAssignments.Remove(assignmentToDelete);
                    SelectedAssignment = null; // Deselect
                    StatusBarText = $"Deleted {changedCount} record successfully.";
                }
                 catch (DbUpdateException dbEx) // Catch specific DB errors
                {
                    var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                    StatusBarText = $"Error deleting data: {innerExceptionMessage}";
                    MessageBox.Show($"Failed to delete the record from the database:\n{innerExceptionMessage}", "Delete Error", MessageBoxButton.OK, MessageBoxImage.Error);
                    // Optionally reload data to ensure consistency if delete fails
                     await LoadDataAsync();
                }
                catch (Exception ex)
                {
                    StatusBarText = $"Error deleting data: {ex.Message}";
                     MessageBox.Show($"An unexpected error occurred while deleting:\n{ex.Message}", "Delete Error", MessageBoxButton.OK, MessageBoxImage.Error);
                     // Optionally reload data to ensure consistency if delete fails
                     await LoadDataAsync();
                }
            }
        }

         // --- Easy Move/Clear Feature ---
        private void ClearSelectedAssignment(object? parameter)
        {
             if (SelectedAssignment != null)
            {
                // Clear user-specific fields
                SelectedAssignment.UserName = null;
                SelectedAssignment.KnoxId = null;
                SelectedAssignment.SubPart = null;
                // Administrator might stay or be cleared depending on rules
                // SelectedAssignment.Administrator = null;

                // IMPORTANT: We need to notify the UI that these properties changed!
                // If LockerAssignment implemented INotifyPropertyChanged, it would happen automatically.
                // Since it doesn't, we need a way to refresh the grid row or manually trigger updates.
                // Easiest way with DevExpress GridControl is often to rely on its internal update mechanisms
                // when the underlying data object changes, especially if using standard editing.
                // Alternatively, replace the item in the collection (less efficient).
                // Let's assume GridControl handles the update after modification + Save.

                // Mark the entity as modified in the context
                 _context.Entry(SelectedAssignment).State = EntityState.Modified;
                 SelectedAssignment.Administrator = _currentAdmin; // Track who cleared it
                 SelectedAssignment.LastUpdated = DateTime.Now; // Explicitly set time here too

                StatusBarText = $"Cleared assignment for {SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}. Save changes.";

                 // Optional: Immediately save the clearing action
                 // _ = SaveChangesAsync();
            }
        }

        // Cleanup context when ViewModel is no longer needed (e.g., window closing)
        public void Cleanup()
        {
            _context?.Dispose();
        }
    }