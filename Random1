정말 죄송합니다. 프로그램을 실행하자마자 종료되는 현상은 분명히 시작 과정에서 심각한 오류가 발생하고 있다는 신호입니다. "Shutdown으로 로그 남아"라는 말씀을 보면, 제가 App.xaml.cs에 넣어둔 오류 처리 로직(ShowCriticalErrorAndShutdown)이 작동하여 애플리케이션을 종료시키는 것으로 보입니다.

가장 가능성이 높은 원인은 애플리케이션 설정 파일(App.config) 문제 또는 데이터베이스 연결 문제입니다.

MGSPMonitorControl/App.xaml.cs 파일을 다음과 같이 수정하여, 어느 부분에서 오류가 발생하는지 좀 더 자세한 정보를 얻을 수 있도록 하고, 예외 처리를 강화하겠습니다.

C#

// MGSPMonitorControl/App.xaml.cs
using System;
using System.Configuration; 
using System.Windows;
using MGSPMonitorControl.DataAccess; 
using MGSPMonitorControl.Services;  
using MGSPMonitorControl.ViewModels; 
using MGSPMonitorControl.Views;      
using System.Threading.Tasks; 

namespace MGSPMonitorControl
{
    public partial class App : Application
    {
        private IDatabaseService _databaseService;
        private IBrokerClientService _brokerClientService;
        // UI 자체 파일 로깅 서비스를 사용한다면 여기서 초기화 (간단하게 Console 사용)
        // private FileLoggingService _uiLogger = new FileLoggingService("ui_log.txt"); 

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Application OnStartup entered.");

            SetupGlobalExceptionHandling(); 

            // 중요: 애플리케이션 시작 시 모든 초기화 로직은 이 메서드 안에서 수행
            InitializeAndRunApplication();
        }

        private async void InitializeAndRunApplication() 
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] InitializeAndRunApplication called.");
            try
            {
                // 1. 서비스 인스턴스 생성
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Initializing DatabaseService...");
                // DatabaseService는 생성자에서 App.config의 연결 문자열을 읽음
                _databaseService = new DatabaseService(); 
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] DatabaseService initialized.");
                
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Initializing BrokerClientService...");
                // BrokerClientService도 생성자에서 App.config의 BrokerAddress를 읽음
                _brokerClientService = new BrokerClientService(/* _uiLogger */); 
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] BrokerClientService initialized.");

                // 2. 메인 창 ViewModel 및 메인 창 바로 생성 및 표시
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Creating MainViewModel...");
                // MainViewModel 생성 시 UserSession 대신, 필요한 서비스만 전달
                var mainViewModel = new MainViewModel(_databaseService, _brokerClientService);
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MainViewModel created.");
                
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Creating MainWindow...");
                var mainWindow = new MainWindow(mainViewModel); 
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MainWindow created.");
                
                this.MainWindow = mainWindow;
                mainWindow.Show();
                
                Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] MGSPMonitorControl UI started and MainWindow shown.");

                // UI 로딩 후 Broker 연결 시도 (MainViewModel 생성자에서도 시도함)
                if (!_brokerClientService.IsConnected)
                {
                    Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Attempting initial connection to Broker from App...");
                    bool connected = await _brokerClientService.ConnectAsync();
                    if (!connected)
                    {
                        string brokerAddr = ConfigurationManager.AppSettings["BrokerAddress"] ?? "N/A";
                        Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] [WARNING] Failed to connect to Broker Service at {brokerAddr} on startup.");
                        // 이 메시지는 MainViewModel에서도 유사하게 처리될 수 있음
                        // MessageBox.Show($"Failed to connect to Broker Service at {brokerAddr} (check App.config and Broker service status).\nUI will operate in offline mode regarding Broker communication.",
                        //                 "Broker Connection Failed", MessageBoxButton.OK, MessageBoxImage.Warning);
                    }
                }
            }
            catch (ConfigurationErrorsException cex)
            {
                // App.config 관련 오류 (연결 문자열, appSettings 등)
                string errorDetails = $"Message: {cex.Message}";
                if (cex.InnerException != null) errorDetails += $"\nInner Exception: {cex.InnerException.Message}";
                ShowCriticalErrorAndShutdown($"Application configuration error:\n{errorDetails}\n\nPlease check App.config (especially 'MonitorControlDBConnection' connection string and 'BrokerAddress' appSetting).\nThe application will now exit.");
            }
            catch (SqlException sqlEx) // 데이터베이스 연결 또는 쿼리 오류
            {
                 ShowCriticalErrorAndShutdown($"Database connection or query error during startup:\n{sqlEx.Message}\n\nConnection String Used (from App.config):\n{GetConnectionStringSafely()}\n\nCheck DB server status and connection string.\nThe application will now exit.");
            }
            catch (Exception ex) // 그 외 모든 예외
            {
                 ShowCriticalErrorAndShutdown($"A critical error occurred during application startup:\n{ex.ToString()}\nThe application will now exit.");
            }
        }
        
        private string GetConnectionStringSafely()
        {
            try { return ConfigurationManager.ConnectionStrings["MonitorControlDBConnection"]?.ConnectionString ?? "Not Found or Empty"; }
            catch { return "Error reading connection string"; }
        }

        private void SetupGlobalExceptionHandling()
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Setting up global exception handlers.");
            // UI 스레드에서 처리되지 않은 예외
            this.DispatcherUnhandledException += (s, e) =>
            {
                string errorMessage = $"[UI THREAD CRASH] Unhandled UI exception occurred: {e.Exception.ToString()}";
                Console.WriteLine(errorMessage);
                // _uiLogger?.LogFatal(errorMessage, e.Exception);
                MessageBox.Show(errorMessage, "Unhandled UI Exception - Application Unstable", MessageBoxButton.OK, MessageBoxImage.Error);
                e.Handled = true; // true로 설정하면 애플리케이션이 즉시 종료되지 않도록 시도 (주의해서 사용)
                // Shutdown(); // 또는 여기서 강제 종료 결정
            };

            // 백그라운드 스레드에서 처리되지 않은 예외
            TaskScheduler.UnobservedTaskException += (s, e) =>
            {
                string errorMessage = $"[BACKGROUND THREAD CRASH] Unobserved task exception: {e.Exception.ToString()}";
                Console.WriteLine(errorMessage);
                // _uiLogger?.LogFatal(errorMessage, e.Exception.GetBaseException());
                // 이 예외는 UI 스레드가 아니므로 MessageBox 직접 사용 시 문제 발생 가능.
                e.SetObserved(); // 예외를 관찰한 것으로 처리하여 프로세스 종료 방지
            };
        }
        
        private void ShowCriticalErrorAndShutdown(string message)
        {
            Console.WriteLine($"[FATAL STARTUP ERROR] {message}");
            MessageBox.Show(message, "Application Startup Error", MessageBoxButton.OK, MessageBoxImage.Error);
            
            // 안전하게 종료 시도
            if (Application.Current != null) 
            {
                if (Application.Current.Dispatcher.CheckAccess())
                {
                     if (Application.Current.MainWindow != null && Application.Current.MainWindow.IsLoaded) Application.Current.MainWindow.Close();
                     Application.Current.Shutdown(-1);
                }
                else
                {
                    Application.Current.Dispatcher.Invoke(() => {
                        if (Application.Current.MainWindow != null && Application.Current.MainWindow.IsLoaded) Application.Current.MainWindow.Close();
                        Application.Current.Shutdown(-1);
                    });
                }
            }
            else // Application.Current가 null이면 (매우 드문 경우)
            {
                Environment.Exit(-1); // 강제 종료
            }
        }

        protected override void OnExit(ExitEventArgs e)
        {
            Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] Application OnExit called. ExitCode: {e.ApplicationExitCode}");
            // MainViewModel의 Cleanup은 MainWindow.xaml.cs의 Window_Closing에서 호출됨
            (_brokerClientService as IDisposable)?.Dispose();
            
            Console.WriteLine("MGSPMonitorControl application exited.");
            base.OnExit(e);
        }
    }
}
위 App.xaml.cs 코드의 주요 변경점:

상세한 콘솔 로그 추가: InitializeAndRunApplication 메서드 내의 각 주요 초기화 단계마다 콘솔에 로그를 출력하도록 했습니다. 이렇게 하면 프로그램이 어느 부분까지 실행되다가 종료되는지 추적하는 데 도움이 됩니다.
InitializeAndRunApplication 분리 및 async void 사용: OnStartup에서 직접 긴 작업을 수행하기보다 별도 메서드로 분리하고, BrokerClientService.ConnectAsync()를 await로 호출할 수 있도록 async void로 만들었습니다. (최상위 이벤트 핸들러에서의 async void는 허용됩니다.)
catch 블록 세분화 및 상세 정보 출력:
ConfigurationErrorsException: App.config 파일 관련 오류를 특정하여 잡습니다.
SqlException: 데이터베이스 연결 또는 쿼리 관련 오류를 특정하여 잡고, 사용된 연결 문자열을 (안전하게) 출력합니다.
Exception: 그 외 모든 예외를 잡고, ex.ToString()을 사용하여 스택 트레이스까지 포함된 상세 정보를 출력합니다.
GetConnectionStringSafely() 메서드 추가: App.config에서 연결 문자열을 읽어올 때 발생할 수 있는 예외를 방지하고 안전하게 값을 가져오기 위한 작은 유틸리티입니다.
ShowCriticalErrorAndShutdown 메서드 개선: 메시지 박스 표시 후 좀 더 안전하게 애플리케이션을 종료하도록 시도합니다.
이제 다음 단계를 진행해주세요:

위 수정된 App.xaml.cs 코드를 프로젝트에 적용합니다.
App.config 파일 확인 (매우 중요!):
MGSPMonitorControl 프로젝트의 루트에 App.config 파일이 있는지 확인합니다.
이 파일의 내용이 이전에 제가 드린 예시와 같이 connectionStrings 섹션에 MonitorControlDBConnection이 올바르게 정의되어 있고, appSettings 섹션에 BrokerAddress가 올바르게 정의되어 있는지 다시 한번 꼼꼼히 확인해주세요.
DB 연결 문자열: 실제 DB 서버 주소, DB 이름, 인증 정보(Windows 인증 또는 SQL Server 인증 사용자 ID/암호)가 정확해야 합니다.
Broker 주소: MGSPBrokerService가 실행 중인 IP 주소와 UI 연결용 포트(예: 127.0.0.1:9001)가 정확해야 합니다.
프로그램 실행 및 콘솔 출력 확인:
MGSPMonitorControl.exe를 직접 실행하지 마시고, Visual Studio에서 디버그 모드(F5)로 실행하거나, 명령 프롬프트(cmd)를 열고 직접 MGSPMonitorControl.exe를 실행하여 콘솔 창에 어떤 메시지들이 출력되는지 확인해주세요.