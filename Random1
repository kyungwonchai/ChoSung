장 중요한 부분은 **"단 한 번의 서비스 중단"**이 아닙니다. 와치독은 **watchdog-timeout**에 설정된 시간 동안 연속적으로 문제가 발생했을 때만 재부팅을 시작합니다.

핵심 동작 원리: 펫팅(Petting)과 카운트다운
와치독의 동작은 마치 **"일정 시간마다 먹이를 줘야 하는 강아지"**와 같습니다.

watchdogd 데몬 (주인): 5초마다 와치독 하드웨어(강아지)에게 **myservice-check.sh**라는 스크립트(사료)를 줍니다.

하드웨어 와치독 (강아지): 사료를 받으면 **"나는 아직 살아있다"**고 신호를 보냅니다. 이 신호가 리셋(petting)입니다. 이 신호를 받지 못하면 배고파서 카운트다운을 시작합니다.

watchdog-timeout (배고픔을 참을 수 있는 시간): 강아지가 60초 동안 사료를 받지 못하면, 더 이상 참지 못하고 **시스템을 강제로 재부팅(주인을 깨우는 행동)**시킵니다.

상황별 동작 시나리오
이제 두 가지 상황을 가정하고 어떻게 동작하는지 봅시다.

상황 1: 서비스가 잠깐 멈췄다가 다시 살아난 경우
0초: watchdogd가 스크립트를 실행합니다. myservice가 정상이라서 스크립트는 **exit 0**을 반환합니다. watchdogd는 하드웨어 타이머를 **리셋(펫팅)**합니다. (강아지에게 사료를 줌)

5초: watchdogd가 스크립트를 실행합니다. 어떤 문제로 myservice가 멈춰서 스크립트는 **exit 1**을 반환합니다. watchdogd는 타이머를 리셋하지 않습니다. (강아지에게 사료를 주지 않음) -> 60초 카운트다운 시작!

10초: watchdogd가 스크립트를 실행합니다. 다행히 myservice가 다시 살아나서 스크립트는 **exit 0**을 반환합니다. watchdogd는 문제가 해결된 것을 보고 하드웨어 타이머를 **다시 리셋(펫팅)**합니다. (다시 사료를 줌)

15초: watchdogd가 스크립트를 실행하고 타이머를 리셋합니다.

이 경우, watchdogd는 5초 동안만 타이머를 펫팅하지 않았기 때문에, 60초 카운트다운이 완료되기 전에 다시 리셋됩니다. 따라서 시스템은 재부팅되지 않습니다.

상황 2: 서비스가 60초 이상 연속으로 멈춰있는 경우
0초: 서비스 정상, 타이머 리셋.

5초: 서비스가 멈춤. 스크립트 exit 1. watchdogd는 타이머 리셋을 멈춥니다. -> 60초 카운트다운 시작!

10초: 서비스 멈춤. 스크립트 exit 1. watchdogd는 계속 타이머를 리셋하지 않습니다.

15초: 서비스 멈춤. 스크립트 exit 1. watchdogd는 계속 타이머를 리셋하지 않습니다.

...

60초가 되는 시점: 하드웨어 와치독 타이머가 0이 됩니다. 타이머는 60초 동안 펫팅(리셋)되지 않았기 때문에, 시스템은 강제로 재부팅됩니다.

결론: