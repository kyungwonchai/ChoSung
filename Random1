합니다. INotifyPropertyChanged 인터페이스를 구현하면, UI 갱신을 수동으로 처리할 필요 없이 속성 값을 업데이트할 때마다 UI가 자동으로 갱신됩니다.

따라서 Dispatcher.Invoke를 계속 사용할 필요 없이, 모델에서 값을 변경하면 UI와 자동으로 연동되도록 할 수 있습니다. 이를 위해서는 모델 속성에 INotifyPropertyChanged를 올바르게 구현하고, 속성 변경 시 자동으로 UI와 값이 동기화되도록 해야 합니다.

수정 방향
INotifyPropertyChanged 인터페이스를 CommandItem 모델 클래스에서 제대로 활용하여 속성 값이 바뀔 때마다 UI가 자동으로 업데이트되도록 설정.
PropertyChanged 이벤트를 통해 명령의 Status, ResponseTime, RetryCount 등이 변경되면 자동으로 UI에 반영되도록 처리.
모델에서 INotifyPropertyChanged 구현
1. CommandItem 클래스에서 INotifyPropertyChanged 구현
CommandItem 모델이 속성 변경을 UI에 알리도록 수정합니다.

csharp
코드 복사
public class CommandItem : INotifyPropertyChanged
{
    private string _status;
    private int _retryCount;
    private int _responseTime;

    public string CommandText { get; set; }

    // Status 속성에 변경 알림 추가
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    // RetryCount 속성에 변경 알림 추가
    public int RetryCount
    {
        get => _retryCount;
        set
        {
            _retryCount = value;
            OnPropertyChanged(nameof(RetryCount));
        }
    }

    // ResponseTime 속성에 변경 알림 추가
    public int ResponseTime
    {
        get => _responseTime;
        set
        {
            _responseTime = value;
            OnPropertyChanged(nameof(ResponseTime));
        }
    }

    public string CommandTime { get; set; }

    public event PropertyChangedEventHandler PropertyChanged;

    // 속성 값이 변경되면 PropertyChanged 이벤트를 발생시킴
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
2. CommandQueueViewModel의 EnqueueTask 메서드에서 값 변경
이제 CommandItem 모델의 속성 값이 변경되면 UI에서 자동으로 갱신됩니다. 따라서 Dispatcher.Invoke()를 사용할 필요 없이, 값을 설정하면 UI가 자동으로 업데이트됩니다.

csharp
코드 복사
private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
{
    var newCommand = new CommandItem 
    { 
        CommandText = commandText,
        Status = "Pending",
        MaxRetryLimit = RetryLimit,
        RetryCount = 0,
        CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff")
    };

    RemainingCommands.Add(newCommand); // RemainingCommands 컬렉션에 추가, UI 자동 갱신됨

    commandQueue.Enqueue(async () =>
    {
        newCommand.Status = "Processing"; // Status가 변경되면 자동으로 UI에 반영

        int retryCount = 0;
        Stopwatch stopwatch = new Stopwatch();
        _isProcessing = true;

        while (retryCount < RetryLimit)
        {
            try
            {
                stopwatch.Restart();
                string result = await taskFunc();

                // 0.1초마다 응답 시간 갱신
                while (stopwatch.ElapsedMilliseconds < ResponseTimeout)
                {
                    newCommand.ResponseTime = (int)(stopwatch.ElapsedMilliseconds / 100); // 응답 시간이 변경되면 자동으로 UI에 반영
                    await Task.Delay(100);
                }

                stopwatch.Stop();
                newCommand.ResponseTime = (int)stopwatch.ElapsedMilliseconds;

                if (newCommand.ResponseTime > ResponseTimeout)
                {
                    newCommand.Status = "Timeout"; // 상태가 변경되면 자동으로 UI에 반영
                    newCommand.Result = 0;
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, newCommand.ResponseTime, "Timeout occurred");
                    StopQueueProcessing(newCommand);
                    return new CommandResult { Success = false, Message = "Response Timeout" };
                }

                if (responseValidator(result))
                {
                    newCommand.Status = "Completed"; // 상태가 변경되면 자동으로 UI에 반영
                    newCommand.Result = 1;
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, newCommand.ResponseTime, result);
                    UpdateProgress();
                    _isProcessing = false;
                    return new CommandResult { Success = true, Message = result };
                }
                else
                {
                    retryCount++;
                    newCommand.Status = $"Retrying {retryCount}/{RetryLimit}"; // 재시도 횟수와 상태가 변경되면 자동으로 UI에 반영
                    if (retryCount >= RetryLimit)
                    {
                        newCommand.Status = "Failed";
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, newCommand.ResponseTime, "Failed after retries");
                        StopQueueProcessing(newCommand);
                        return new CommandResult { Success = false, Message = result };
                    }
                    await Task.Delay(RetryInterval);
                }
            }
            catch (Exception ex)
            {
                newCommand.Status = "Failed"; // 상태가 변경되면 자동으로 UI에 반영
                newCommand.Result = 0;
                stopwatch.Stop();
                newCommand.ResponseTime = (int)stopwatch.ElapsedMilliseconds;
                await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, newCommand.ResponseTime, ex.Message);
                StopQueueProcessing(newCommand);
                return new CommandResult { Success = false, Message = ex.Message };
            }
        }

        UpdateProgress();
        _isProcessing = false;
        return new CommandResult { Success = false };
    });

    if (!_isProcessing)
    {
        _isProcessing = true;
        await ProcessCommandQueue();
    }

    UpdateProgress();
}
수정된 부분 요약:
CommandItem 클래스에서 INotifyPropertyChanged 구현: 각 속성 값이 변경될 때 UI가 자동으로 갱신되도록 설정.
EnqueueTask 메서드에서 값 변경 시 Dispatcher.Invoke 제거: Status, RetryCount, ResponseTime 등의 값이 변경되면 자동으로 UI에 반영되도록 수정.
이제 MVVM 패턴에 맞게 모델의 값이 변경되면 U