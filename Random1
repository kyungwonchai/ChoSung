inForms에서 윈도우 창 최소화 시 **"쓰레드 크로스 예외" (Cross-thread operation not valid)**가 발생하는 문제를 해결하는 코드입니다.

✅ 문제 원인
WinForms의 컨트롤(예: Form, Label, TextBox 등)은 UI 쓰레드에서만 변경할 수 있습니다.
백그라운드 스레드에서 UI를 직접 수정하면 InvalidOperationException이 발생합니다.

✅ 해결 방법 1: Invoke() 사용 (UI 스레드에서 실행)
csharp
코드 복사
using System;
using System.Threading;
using System.Windows.Forms;

public class MyForm : Form
{
    private Label lblStatus;
    private Thread backgroundThread;

    public MyForm()
    {
        lblStatus = new Label { Text = "초기 상태", Dock = DockStyle.Top };
        Controls.Add(lblStatus);

        // 창 최소화 이벤트 핸들러 추가
        this.Resize += Form_Resize;

        // 백그라운드 작업 시작
        backgroundThread = new Thread(UpdateLabel);
        backgroundThread.IsBackground = true;
        backgroundThread.Start();
    }

    private void Form_Resize(object sender, EventArgs e)
    {
        if (this.WindowState == FormWindowState.Minimized)
        {
            // 최소화 시 UI 안전하게 변경
            SafeInvoke(() => lblStatus.Text = "창 최소화됨");
        }
    }

    private void UpdateLabel()
    {
        while (true)
        {
            Thread.Sleep(2000); // 2초마다 업데이트
            SafeInvoke(() => lblStatus.Text = $"업데이트 시간: {DateTime.Now}");
        }
    }

    private void SafeInvoke(Action action)
    {
        if (this.InvokeRequired)
        {
            this.Invoke(new MethodInvoker(action));
        }
        else
        {
            action();
        }
    }

    [STAThread]
    static void Main()
    {
        Application.EnableVisualStyles();
        Application.SetCompatibleTextRenderingDefault(false);
        Application.Run(new MyForm());
    }
}
✅ 해결 방법 2: BeginInvoke() 사용 (더 안전한 비동기 호출)
csharp
코드 복사
private void SafeInvoke(Action action)
{
    if (this.IsHandleCreated && this.InvokeRequired)
    {
        this.BeginInvoke(action);
    }
    else
    {
        action();
    }
}
🔹 BeginInvoke()는 UI가 너무 바쁘면 스레드 대기 없이 실행을 예약하여 응답성을 유지합니다.
