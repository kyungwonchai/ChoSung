네, 알겠습니다. 요청하신 세 가지 기능(이전 슬롯 복귀, 중복 입력 방지, 램프 점등)이 모두 포함된 최종 RackSystemManager.cs 스크립트를 드립니다.

## 최종 RackSystemManager.cs (모든 기능 포함)
Scripts 폴더에 있는 RackSystemManager.cs 파일의 내용을 아래 코드로 완전히 덮어쓰고 저장하세요.

C#

using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

public class RackSystemManager : MonoBehaviour
{
    [Header("핵심 연결 대상")]
    public Transform rackContainer;

    [Header("머티리얼")]
    public Material defaultLampMaterial;
    public Material litLampMaterial;

    [Header("애니메이션")]
    public float animationDuration = 0.5f;
    public float slideOutDistance = 0.4f;

    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    
    // 마지막으로 활성화된 오브젝트의 상태를 기억하기 위한 변수들
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Renderer lastLitLamp;
    private Vector3 lastMaskOriginalLocalPosition;

    // ★★★ 현재 활성화된 바코드를 저장하여 중복 입력을 감지하기 위한 변수 ★★★
    private string currentActiveBarcode = "";

    void Start()
    {
        InitializeAllRacks();
    }

    void InitializeAllRacks()
    {
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name;
            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name;
                string globalKey = $"{rackName}_{localName}";

                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                        lampRenderers.Add(globalKey, rend);
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                        maskObjects.Add(globalKey, rend.gameObject);
                }
            }
        }
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    public void ProcessBarcode(string barcode)
    {
        // ★★★ 중복 입력 방지 기능 ★★★
        // 새로 입력된 바코드가 현재 활성화된 바코드와 동일하다면, 아무것도 하지 않고 함수를 즉시 종료합니다.
        if (barcode == currentActiveBarcode)
        {
            return;
        }

        // ★★★ 이전 슬롯 자동 복귀 기능 ★★★
        // 새로운 바코드가 입력되면, 이전에 활성화됐던 램프와 마스크를 먼저 원래 상태로 되돌립니다.
        ResetPreviousSlot();
        
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10")) return;

        string rackID = barcode.Substring(5, 3);
        string floor = barcode.Substring(8, 1);
        string slotNum = barcode.Substring(9, 2);
        
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}";
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}";
        
        // ★★★ 램프 점등 기능 ★★★
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            // Inspector에서 연결한 'Lit Lamp Material'로 교체하여 램프를 밝게 켭니다.
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }

        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }

        // 모든 작업이 성공적으로 끝나면, 현재 활성화된 바코드를 기록합니다.
        currentActiveBarcode = barcode;
    }
    
    #region Helper Functions 
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
        // 새로운 바코드를 처리하기 전에 현재 활성화된 바코드 기록을 초기화합니다.
        currentActiveBarcode = "";
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;
        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }
        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;
        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
    #endregion
}
## 기능 설명
1. 이전 슬롯 자동 복귀: 새로운 바코드가 입력되면 ProcessBarcode 함수 시작 부분에서 ResetPreviousSlot() 함수가 호출됩니다. 이 함수가 이전에 켜졌던 램프를 끄고, 튀어나왔던 마스크를 다시 집어넣는 역할을 합니다.

2. 중복 입력 방지: currentActiveBarcode라는 변수가 현재 켜져 있는 바코드를 기억합니다. ProcessBarcode 함수 맨 위에서, 새로 들어온 바코드가 이 변수의 값과 같으면 아무 동작도 하지 않고 즉시 함수를 종료하여 그대로 있도록 만듭니다.