다음은 WPF에서 소켓 통신을 STX와 ETX로 감싸서 메시지를 보내고, 응답을 받아 로그로 기록하며, 연결이 끊어졌을 때 주기적으로 재시도하는 안정적인 클래스를 구현하는 방법입니다. 이 코드는 MVVM 패턴을 사용하여 MainViewModel에서 생성하고, TextBox와 ListBox를 통해 송수신을 처리합니다.

1. MainViewModel (MVVM)
우선 MainViewModel에 소켓 통신 클래스(SocketClient)를 생성하고, TextBox에 입력한 내용을 송신할 수 있도록 커맨드를 설정합니다.

MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    private readonly SocketClient _socketClient;
    public ObservableCollection<string> Messages { get; set; } // ListBox에 바인딩할 메시지 리스트
    public string InputText { get; set; } // TextBox에서 입력받은 텍스트

    public ICommand SendCommand { get; set; } // 전송 버튼에 바인딩할 커맨드

    public MainViewModel()
    {
        Messages = new ObservableCollection<string>();
        _socketClient = new SocketClient("10.22.22.22", 2400, Messages);

        SendCommand = new RelayCommand(SendMessage);
    }

    private void SendMessage(object parameter)
    {
        if (!string.IsNullOrWhiteSpace(InputText))
        {
            _socketClient.SendMessage(InputText);
            InputText = string.Empty;
        }
    }
}
2. SocketClient (소켓 통신 클래스)
다음은 소켓 통신을 처리하고, STX(시작 문자)와 ETX(종료 문자)를 메시지에 추가하는 클래스입니다. 연결이 끊어지면 주기적으로 재시도하며, 로그는 메시지 리스트로 남깁니다.

SocketClient.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

public class SocketClient
{
    private readonly string _ip;
    private readonly int _port;
    private TcpClient _client;
    private NetworkStream _stream;
    private readonly ObservableCollection<string> _messages;
    private bool _isConnected;
    private readonly object _lockObject = new object();

    public SocketClient(string ip, int port, ObservableCollection<string> messages)
    {
        _ip = ip;
        _port = port;
        _messages = messages;
        Connect();
    }

    private async void Connect()
    {
        while (!_isConnected)
        {
            try
            {
                _client = new TcpClient();
                await _client.ConnectAsync(_ip, _port);
                _stream = _client.GetStream();
                _isConnected = true;
                _messages.Add("Connected to server.");

                StartReceiving(); // 수신 시작
            }
            catch (Exception ex)
            {
                _messages.Add($"Connection failed: {ex.Message}");
                await Task.Delay(5000); // 5초 후 재시도
            }
        }
    }

    public void SendMessage(string message)
    {
        if (_isConnected)
        {
            try
            {
                byte[] data = Encoding.ASCII.GetBytes($"\x02{message}\x03"); // STX와 ETX로 감싸서 송신
                _stream.Write(data, 0, data.Length);
                _messages.Add($"Sent: {message}");
            }
            catch (Exception ex)
            {
                _messages.Add($"Send failed: {ex.Message}");
            }
        }
        else
        {
            _messages.Add("Not connected to the server.");
        }
    }

    private async void StartReceiving()
    {
        byte[] buffer = new byte[1024];
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length);
                if (bytesRead > 0)
                {
                    string response = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    // STX와 ETX로 감싸진 응답에서 실제 메시지만 추출
                    string extractedMessage = ExtractMessage(response);
                    _messages.Add($"Received: {extractedMessage}");
                }
            }
            catch (Exception ex)
            {
                _messages.Add($"Receive failed: {ex.Message}");
                _isConnected = false;
                _client.Close();
                Connect(); // 연결 재시도
            }
        }
    }

    private string ExtractMessage(string response)
    {
        // STX(시작 문자, '\x02')와 ETX(종료 문자, '\x03') 사이의 텍스트 추출
        int stxIndex = response.IndexOf('\x02');
        int etxIndex = response.IndexOf('\x03');
        if (stxIndex >= 0 && etxIndex > stxIndex)
        {
            return response.Substring(stxIndex + 1, etxIndex - stxIndex - 1);
        }
        return "Invalid response format";
    }
}
3. XAML 코드
TextBox, Button, ListBox 등을 UI에 배치하여, 입력 및 송수신 메시지를 보여주는 간단한 인터페이스를 설정합니다.

MainWindow.xaml
xml
코드 복사
<Window x:Class="SocketCommunication.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Socket Communication" Height="350" Width="525">
    <Grid>
        <TextBox Text="{Binding InputText, UpdateSourceTrigger=PropertyChanged}" Width="400" Height="30" Margin="10"/>
        <Button Content="Send" Command="{Binding SendCommand}" Width="100" Height="30" Margin="420,10,10,0" VerticalAlignment="Top"/>
        <ListBox ItemsSource="{Binding Messages}" Width="500" Height="250" Margin="10,50,10,10"/>
    </Grid>
</Window>
4. 주요 동작 요약
MainViewModel: SocketClient 객체를 생성하고, SendCommand를 통해 TextBox에서 입력한 메시지를 송신합니다.
SocketClient: STX와 ETX로 메시지를 감싼 후 송신하고, 수신된 데이터에서 STX와 ETX 사이의 데이터를 추출하여 ObservableCollection을 통해 로그로 기록합니다.