def bfs(maze):
    rows = len(maze)
    cols = len(maze[0])
    visited = set()
    queue = [((0, 0), [(0, 0)])]  # (현재 위치, 경로)
    directions = [(-1, 0), (1, 0), (0, -1), (0, 1)]  # 상하좌우 이동

    visited.add((0, 0))  # 시작점 방문 표시

    while queue:
        (x, y), path = queue.pop(0)

        # 도착점에 도달한 경우
        if x == rows - 1 and y == cols - 1:
            return [(chr(px + ord('A')) + str(py + 1)) for px, py in path]

        for dx, dy in directions:
            nx, ny = x + dx, y + dy
            if 0 <= nx < rows and 0 <= ny < cols and (nx, ny) not in visited and maze[nx][ny] == 0:
                visited.add((nx, ny))
                queue.append(((nx, ny), path + [(nx, ny)]))

    return "출구가 없습니다."

# 예시 미로
maze = [
    [0, 1, 0, 0, 0],
    [0, 1, 0, 1, 0],
    [0, 0, 0, 1, 0],
    [1, 1, 1, 0, 0],
    [0, 0, 0, 0, 0]
]

# 함수 실행
print(bfs(maze))
