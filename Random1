알겠습니다. 프로그램의 안정성과 사용 편의성을 높이기 위한 아주 좋은 제안입니다. 요청하신 세 가지 기능(입력창 잠금, 자동 시작, 트레이 아이콘으로 최소화)을 모두 반영하여 최종 완성 버전을 만들어 드리겠습니다.

## 1. 사전 준비: 트레이 아이콘 라이브러리 설치 (필수)
WPF는 트레이 아이콘(알림 영역 아이콘)을 기본적으로 지원하지 않으므로, 편리한 외부 라이브러리를 설치해야 합니다.

이전 단계에서 설치했던 MySql.Data와 같은 방법으로 NuGet 패키지 관리자를 엽니다.
찾아보기 탭에서 Hardcodet.NotifyIcon.Wpf를 검색합니다.
Hardcodet.NotifyIcon.Wpf 패키지를 찾아 설치합니다. 이 라이브러리가 가장 널리 쓰이고 안정적입니다.
## 2. UI 변경 (MainWindow.xaml)
입력창을 잠그는 '수정/잠금' 버튼을 추가하고, 트레이 아이콘을 정의합니다. 아래 코드로 MainWindow.xaml 파일 전체를 교체하세요.

XML

<Window x:Class="funcenvget.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        xmlns:tb="http://www.hardcodet.net/taskbar"
        mc:Ignorable="d"
        Title="실시간 데이터 로거 v3.0" Height="520" Width="520" ResizeMode="CanMinimize"
        Loaded="Window_Loaded" Closing="Window_Closing">
    <Grid>
        <tb:TaskbarIcon x:Name="MyNotifyIcon"
                        IconSource="/icon.ico"
                        ToolTipText="실시간 데이터 로거"
                        TrayMouseDoubleClick="MyNotifyIcon_TrayMouseDoubleClick">
            <tb:TaskbarIcon.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="열기" Click="MenuOpen_Click" FontWeight="Bold"/>
                    <MenuItem Header="종료" Click="MenuExit_Click"/>
                </ContextMenu>
            </tb:TaskbarIcon.ContextMenu>
        </tb:TaskbarIcon>

        <Grid Margin="15">
            <Grid.RowDefinitions>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="Auto"/>
                <RowDefinition Height="*"/>
                <RowDefinition Height="Auto"/>
            </Grid.RowDefinitions>

            <GroupBox Header="캡처 및 장비 설정" Grid.Row="0" FontWeight="Bold">
                <Grid Margin="5">
                    <Grid.RowDefinitions>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                        <RowDefinition Height="Auto"/>
                    </Grid.RowDefinitions>
                    <Grid.ColumnDefinitions>
                        <ColumnDefinition Width="Auto"/>
                        <ColumnDefinition Width="*"/>
                        <ColumnDefinition Width="Auto"/>
                    </Grid.ColumnDefinitions>

                    <Label Content="PC 이름:" Grid.Row="0" Grid.Column="0" VerticalAlignment="Center"/>
                    <TextBox x:Name="txtPcName" Grid.Row="0" Grid.Column="1" Margin="5" MaxLength="10" IsReadOnly="True"/>

                    <Label Content="대상 창 제목:" Grid.Row="1" Grid.Column="0" VerticalAlignment="Center"/>
                    <TextBox x:Name="txtWindowTitle" Grid.Row="1" Grid.Column="1" Margin="5" IsReadOnly="True"/>
                    
                    <Button x:Name="btnToggleEdit" Content="수정" Grid.Row="0" Grid.RowSpan="2" Grid.Column="2" Margin="5" Padding="15,5" Click="btnToggleEdit_Click"/>

                    <Label Content="캡처 영역 (X, Y):" Grid.Row="2" Grid.Column="0" VerticalAlignment="Center"/>
                    <StackPanel Grid.Row="2" Grid.Column="1" Orientation="Horizontal">
                        <TextBox x:Name="txtX" Width="80" Margin="5" IsReadOnly="True"/>
                        <TextBox x:Name="txtY" Width="80" Margin="5" IsReadOnly="True"/>
                    </StackPanel>

                    <Label Content="캡처 크기 (W, H):" Grid.Row="3" Grid.Column="0" VerticalAlignment="Center"/>
                    <StackPanel Grid.Row="3" Grid.Column="1" Orientation="Horizontal">
                        <TextBox x:Name="txtWidth" Width="80" Margin="5" IsReadOnly="True"/>
                        <TextBox x:Name="txtHeight" Width="80" Margin="5" IsReadOnly="True"/>
                    </StackPanel>

                    <Button x:Name="btnSelectArea" Content="영역 설정" Grid.Row="4" Grid.Column="0" Grid.ColumnSpan="3" Margin="5" Padding="5" Click="btnSelectArea_Click"/>
                </Grid>
            </GroupBox>

            <Button x:Name="btnStart" Content="로깅 시작" Grid.Row="1" Margin="5,15,5,5" Padding="5" FontWeight="Bold" Background="#FF4E76D8" Foreground="White" Click="btnStart_Click"/>

            <Border Grid.Row="2" BorderBrush="Gray" BorderThickness="1" Margin="5">
                <Image x:Name="imgPreview" Stretch="Uniform"/>
            </Border>

            <StatusBar Grid.Row="3">
                <StatusBarItem>
                    <TextBlock x:Name="lblStatus" Text="상태: 대기 중" TextWrapping="Wrap"/>
                </StatusBarItem>
            </StatusBar>
        </Grid>
    </Grid>
</Window>
아이콘 파일 추가
위 XAML 코드는 icon.ico 파일을 아이콘으로 사용합니다.

원하는 .ico 파일을 구해서 파일명을 icon.ico로 바꿉니다.
솔루션 탐색기에서 프로젝트 이름(funcenvget)에 파일을 드래그 앤 드롭하여 추가합니다.
추가된 icon.ico 파일을 클릭하고, 속성(Properties) 창에서 **'빌드 작업(Build Action)'**을 **'리소스(Resource)'**로 변경합니다.
## 3. 최종 C# 코드 (MainWindow.xaml.cs)
모든 새로운 로직(잠금, 자동시작, 트레이 최소화)을 반영한 최종 코드입니다. 이 코드로 MainWindow.xaml.cs 파일 전체를 교체하세요.

C#

using System;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Threading;
using Tesseract;
using funcenvget.Properties;
using System.Drawing;
using MySql.Data.MySqlClient;
using System.ComponentModel;

namespace funcenvget
{
    public partial class MainWindow : Window
    {
        // P/Invoke 선언 (변경 없음)
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private DispatcherTimer timer;
        private TesseractEngine ocrEngine;
        private bool isLocked = true; // 입력창 잠금 상태 변수

        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
            // 시작 시 창 숨기고 트레이 아이콘만 표시
            this.Hide();
        }

        private void InitializeApp()
        {
            // ... (이전과 동일)
            ocrEngine = new TesseractEngine("./tessdata", "eng", EngineMode.Default);
            ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");

            timer = new DispatcherTimer();
            timer.Interval = TimeSpan.FromSeconds(10);
            timer.Tick += Timer_Tick;
        }

        // 창 로드 완료 후 실행되는 로직
        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // 설정 불러오기
            txtWindowTitle.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            txtPcName.Text = Settings.Default.PcName;

            if (!string.IsNullOrEmpty(Settings.Default.PreviewImagePath) && File.Exists(Settings.Default.PreviewImagePath))
            {
                try
                {
                    var preview = new System.Windows.Media.Imaging.BitmapImage();
                    preview.BeginInit();
                    preview.UriSource = new Uri(Settings.Default.PreviewImagePath);
                    preview.CacheOption = System.Windows.Media.Imaging.BitmapCacheOption.OnLoad;
                    preview.EndInit();
                    imgPreview.Source = preview;
                }
                catch { /* 무시 */ }
            }
            
            // UI 잠금 상태 업데이트
            UpdateLockState(true); 
            // 자동 시작 시도
            AttemptAutoStart();
        }

        // 자동 시작 로직
        private void AttemptAutoStart()
        {
            // PC 이름이 있고, 대상 창이 실제로 존재하면 자동 시작
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && FindWindow(null, txtWindowTitle.Text) != IntPtr.Zero)
            {
                // 로깅이 중지된 상태일 때만 시작
                if (!timer.IsEnabled)
                {
                    btnStart_Click(this, new RoutedEventArgs());
                }
            }
        }

        // '수정/잠금' 버튼 로직
        private void btnToggleEdit_Click(object sender, RoutedEventArgs e)
        {
            // 로깅 중일 때는 수정 불가
            if (timer.IsEnabled)
            {
                MessageBox.Show("로깅이 실행 중일 때는 설정을 수정할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            isLocked = !isLocked;
            UpdateLockState(isLocked);
        }

        // UI 잠금 상태를 업데이트하는 헬퍼 함수
        private void UpdateLockState(bool lockState)
        {
            isLocked = lockState;
            txtPcName.IsReadOnly = isLocked;
            txtWindowTitle.IsReadOnly = isLocked;
            btnSelectArea.IsEnabled = !isLocked; // 잠겨있을 땐 영역 설정 불가

            if (isLocked)
            {
                btnToggleEdit.Content = "수정";
                txtPcName.Background = System.Windows.Media.Brushes.LightGray;
                txtWindowTitle.Background = System.Windows.Media.Brushes.LightGray;
            }
            else
            {
                btnToggleEdit.Content = "잠금";
                txtPcName.Background = System.Windows.Media.Brushes.White;
                txtWindowTitle.Background = System.Windows.Media.Brushes.White;
            }
        }

        // 로깅 시작 버튼 클릭
        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled)
            {
                timer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 로깅이 중지되었습니다.";
            }
            else
            {
                // 시작 전 방어 로직
                if (!isLocked)
                {
                    MessageBox.Show("설정을 먼저 '잠금' 상태로 변경해주세요.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                if (string.IsNullOrWhiteSpace(txtPcName.Text) || string.IsNullOrWhiteSpace(txtWindowTitle.Text))
                {
                    MessageBox.Show("PC이름과 대상 창 제목을 모두 설정해야 합니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }

        #region 트레이 아이콘 및 창 관리
        // 트레이 아이콘 더블클릭 시 창 보이기
        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e)
        {
            this.Show();
            this.WindowState = WindowState.Normal;
            this.Activate();
        }

        // 컨텍스트 메뉴 - 열기
        private void MenuOpen_Click(object sender, RoutedEventArgs e)
        {
            this.Show();
            this.WindowState = WindowState.Normal;
            this.Activate();
        }

        // 컨텍스트 메뉴 - 종료
        private void MenuExit_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }

        // 창 닫기(X) 버튼 클릭 시 종료 대신 숨기기
        protected override void OnClosing(CancelEventArgs e)
        {
            e.Cancel = true; // 기본 종료 이벤트를 취소
            this.Hide();     // 창을 숨김
            base.OnClosing(e);
        }
        #endregion

        #region 설정 저장 (Window_Closing)
        private void Window_Closing(object sender, CancelEventArgs e)
        {
            // 실제 종료 시에만 실행되도록 수정
            if (Application.Current.ShutdownMode == ShutdownMode.OnExplicitShutdown)
            {
                if (ocrEngine != null) ocrEngine.Dispose();
                if (timer != null) timer.Stop();

                Settings.Default.WindowTitle = txtWindowTitle.Text;
                Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
                Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
                Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
                Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
                Settings.Default.PcName = txtPcName.Text;

                Settings.Default.Save();
            }
        }
        #endregion

        #region 핵심 로깅 및 DB 연동 함수들 (이전과 동일)
        private void Timer_Tick(object sender, EventArgs e) { PerformLogging(); }
        private void btnSelectArea_Click(object sender, RoutedEventArgs e) { /* 이전 코드와 동일 */ }
        private void UpdatePreviewImage() { /* 이전 코드와 동일 */ }
        private System.Windows.Media.Imaging.BitmapImage BitmapToImageSource(Bitmap bitmap) { /* 이전 코드와 동일 */ }
        private void PerformLogging() { /* 이전 코드와 동일 */ }
        private void ProcessOcrResult(string rawText) { /* 이전 코드와 동일 */ }
        private void UploadToDatabase(decimal temp, decimal humid) { /* 이전 코드와 동일 */ }
        #endregion
    }
}
※ 중요: 위 코드의 마지막 #region 핵심 로깅... 부분에 생략된 함수들(btnSelectArea_Click, UpdatePreviewImage 등)은 바로 이전 답변의 코드와 완전히 동일하므로, 그대로 두시면 됩니다. 편의를 위해 전체 코드를 다시 첨부합니다. (아래 펼침 블록 확인)

&lt;details>
&lt;summary>&lt;b>[클릭] 생략된 부분 포함된 MainWindow.xaml.cs 최종 전체 코드&lt;/b>&lt;/summary>

C#

using System;
using System.ComponentModel;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Windows;
using System.Windows.Threading;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;

namespace funcenvget
{
    public partial class MainWindow : Window
    {
        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);

        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);

        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);

        [StructLayout(LayoutKind.Sequential)]
        public struct RECT
        {
            public int Left, Top, Right, Bottom;
        }

        private DispatcherTimer timer;
        private TesseractEngine ocrEngine;
        private bool isLocked = true;

        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
            this.Hide();
        }

        private void InitializeApp()
        {
            ocrEngine = new TesseractEngine("./tessdata", "eng", EngineMode.Default);
            ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");
            timer = new DispatcherTimer { Interval = TimeSpan.FromSeconds(10) };
            timer.Tick += Timer_Tick;
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            txtWindowTitle.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            txtPcName.Text = Settings.Default.PcName;

            if (!string.IsNullOrEmpty(Settings.Default.PreviewImagePath) && File.Exists(Settings.Default.PreviewImagePath))
            {
                try
                {
                    var preview = new System.Windows.Media.Imaging.BitmapImage();
                    preview.BeginInit();
                    preview.UriSource = new Uri(Settings.Default.PreviewImagePath);
                    preview.CacheOption = System.Windows.Media.Imaging.BitmapCacheOption.OnLoad;
                    preview.EndInit();
                    imgPreview.Source = preview;
                }
                catch { }
            }
            UpdateLockState(true);
            AttemptAutoStart();
        }
        
        private void AttemptAutoStart()
        {
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && FindWindow(null, txtWindowTitle.Text) != IntPtr.Zero)
            {
                if (!timer.IsEnabled)
                {
                    btnStart_Click(this, new RoutedEventArgs());
                }
            }
        }

        private void btnToggleEdit_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled)
            {
                MessageBox.Show("로깅이 실행 중일 때는 설정을 수정할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            isLocked = !isLocked;
            UpdateLockState(isLocked);
        }

        private void UpdateLockState(bool lockState)
        {
            isLocked = lockState;
            txtPcName.IsReadOnly = isLocked;
            txtWindowTitle.IsReadOnly = isLocked;
            btnSelectArea.IsEnabled = !isLocked;

            if (isLocked)
            {
                btnToggleEdit.Content = "수정";
                txtPcName.Background = System.Windows.Media.Brushes.LightGray;
                txtWindowTitle.Background = System.Windows.Media.Brushes.LightGray;
            }
            else
            {
                btnToggleEdit.Content = "잠금";
                txtPcName.Background = System.Windows.Media.Brushes.White;
                txtWindowTitle.Background = System.Windows.Media.Brushes.White;
            }
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled)
            {
                timer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 로깅이 중지되었습니다.";
            }
            else
            {
                if (!isLocked)
                {
                    MessageBox.Show("설정을 먼저 '잠금' 상태로 변경해주세요.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                if (string.IsNullOrWhiteSpace(txtPcName.Text) || string.IsNullOrWhiteSpace(txtWindowTitle.Text))
                {
                    MessageBox.Show("PC이름과 대상 창 제목을 모두 설정해야 합니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }
                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }
        
        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e)
        {
            this.Show();
            this.WindowState = WindowState.Normal;
            this.Activate();
        }
        
        private void MenuOpen_Click(object sender, RoutedEventArgs e)
        {
            this.Show();
            this.WindowState = WindowState.Normal;
            this.Activate();
        }
        
        private void MenuExit_Click(object sender, RoutedEventArgs e)
        {
            Application.Current.Shutdown();
        }
        
        protected override void OnClosing(CancelEventArgs e)
        {
            e.Cancel = true;
            this.Hide();
            base.OnClosing(e);
        }
        
        private void Window_Closing(object sender, CancelEventArgs e)
        {
             //실제 종료는 MenuExit_Click에서 Application.Current.Shutdown()으로만 이루어지므로,
             //OnClosing을 재정의한 이상 이 이벤트는 실제 종료 시점이 아닐 수 있습니다.
             //정확한 저장을 위해 App.xaml에 Exit 이벤트를 등록하는 것이 더 안정적이지만,
             //현재 구조에서는 Shutdown() 호출 전에 저장이 이루어지도록 로직을 유지합니다.
            Settings.Default.WindowTitle = txtWindowTitle.Text;
            Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
            Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
            Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
            Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
            Settings.Default.PcName = txtPcName.Text;
            Settings.Default.Save();
        }

        private void Timer_Tick(object sender, EventArgs e)
        {
            PerformLogging();
        }

        private void PerformLogging()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상 창을 찾을 수 없습니다.";
                    return;
                }
                if (IsIconic(hWnd))
                {
                    lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다.";
                    return;
                }
                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                    }
                    var cropArea = new System.Drawing.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        using (var page = ocrEngine.Process(croppedBmp))
                        {
                            string rawText = page.GetText().Trim();
                            if (!string.IsNullOrWhiteSpace(rawText))
                            {
                                ProcessOcrResult(rawText);
                            }
                            else
                            {
                                lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다.";
                            }
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                lblStatus.Text = $"상태: 캡처 중 심각한 오류 발생! {ex.Message}";
            }
        }

        private void ProcessOcrResult(string rawText)
        {
            string processedText = rawText.Replace("-", "");
            string[] parts = processedText.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);

            if (parts.Length != 2)
            {
                lblStatus.Text = $"상태: 값 분리 오류 (인식된 값 {parts.Length}개)";
                return;
            }

            if (decimal.TryParse(parts[0], out decimal val1) && decimal.TryParse(parts[1], out decimal val2))
            {
                decimal temp = Math.Truncate(val1 * 10) / 10m;
                decimal humid = Math.Truncate(val2 * 10) / 10m;
                UploadToDatabase(temp, humid);
            }
            else
            {
                lblStatus.Text = $"상태: 숫자 변환 오류 ({parts[0]},{parts[1]})";
            }
        }

        private void UploadToDatabase(decimal temp, decimal humid)
        {
            string pcName = txtPcName.Text;
            if (string.IsNullOrWhiteSpace(pcName))
            {
                lblStatus.Text = "상태: PC 이름이 비어있어 DB 작업을 건너뜁니다.";
                return;
            }
            
            string connectionString = "Server=127.0.0.1;Port=3306;Database=smd;Uid=root;Pwd=password;";
            MySqlConnection conn = null;
            MySqlTransaction trans = null;
            int rowsAffected = 0;

            try
            {
                conn = new MySqlConnection(connectionString);
                conn.Open();
                trans = conn.BeginTransaction();

                using (MySqlCommand cmd = new MySqlCommand())
                {
                    cmd.Connection = conn;
                    cmd.Transaction = trans;
                    cmd.CommandText = "UPDATE smd.repair_func_now SET temp1 = @temp1, humid1 = @humid1, stdtime = NOW() WHERE line = @line;";
                    cmd.Parameters.AddWithValue("@line", pcName);
                    cmd.Parameters.AddWithValue("@temp1", temp);
                    cmd.Parameters.AddWithValue("@humid1", humid);
                    rowsAffected = cmd.ExecuteNonQuery();
                    cmd.CommandText = "INSERT INTO smd.repair_func_new_log (line, temp1, humid1, stdtime) VALUES (@line, @temp1, @humid1, NOW());";
                    cmd.ExecuteNonQuery();
                }

                trans.Commit();
                
                if (rowsAffected > 0)
                {
                    lblStatus.Text = $"상태: {DateTime.Now:T} - DB 업데이트 성공!";
                }
                else
                {
                    lblStatus.Text = $"상태: {DateTime.Now:T} - 로그 기록 완료 (now 테이블에 해당 PC 없음)";
                }
            }
            catch (Exception ex)
            {
                try { trans?.Rollback(); } catch { }
                lblStatus.Text = $"상태: DB 오류! {ex.Message}";
            }
            finally
            {
                conn?.Close();
            }
        }
        
        private void btnSelectArea_Click(object sender, RoutedEventArgs e)
        {
            IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
            if (hWnd == IntPtr.Zero)
            {
                MessageBox.Show("먼저 유효한 '대상 창 제목'을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            this.Visibility = Visibility.Hidden;
            System.Threading.Thread.Sleep(200);
            var selectionWindow = new SelectionWindow();
            selectionWindow.Activate();
            if (selectionWindow.ShowDialog() == true)
            {
                System.Windows.Rect screenRect = selectionWindow.SelectedArea;
                GetWindowRect(hWnd, out RECT windowRect);
                int relativeX = (int)screenRect.X - windowRect.Left;
                int relativeY = (int)screenRect.Y - windowRect.Top;
                relativeX = Math.Max(0, relativeX);
                relativeY = Math.Max(0, relativeY);
                txtX.Text = relativeX.ToString();
                txtY.Text = relativeY.ToString();
                txtWidth.Text = ((int)screenRect.Width).ToString();
                txtHeight.Text = ((int)screenRect.Height).ToString();
                UpdatePreviewImage();
            }
            this.Visibility = Visibility.Visible;
            this.Activate();
        }

        private void UpdatePreviewImage()
        {
            try
            {
                IntPtr hWnd = FindWindow(null, txtWindowTitle.Text);
                if (hWnd == IntPtr.Zero) return;
                if (IsIconic(hWnd))
                {
                    MessageBox.Show("대상 창이 최소화되어 있어 미리보기를 생성할 수 없습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                    imgPreview.Source = null;
                    return;
                }
                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, System.Drawing.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Graphics.FromImage(bmp))
                    {
                        PrintWindow(hWnd, g.GetHdc(), 2);
                        g.ReleaseHdc();
                    }
                    var cropArea = new System.Drawing.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    if (cropArea.Width <= 0 || cropArea.Height <= 0) return;
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat))
                    {
                        imgPreview.Source = BitmapToImageSource(croppedBmp);
                        string previewPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "preview_capture.png");
                        croppedBmp.Save(previewPath, System.Drawing.Imaging.ImageFormat.Png);
                        Settings.Default.PreviewImagePath = previewPath;
                    }
                }
            }
            catch { }
        }

        System.Windows.Media.Imaging.BitmapImage BitmapToImageSource(Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, System.Drawing.Imaging.ImageFormat.Png);
                memory.Position = 0;
                var bitmapimage = new System.Windows.Media.Imaging.BitmapImage();
                bitmapimage.BeginInit();
                bitmapimage.StreamSource = memory;
                bitmapimage.CacheOption = System.Windows.Media.Imaging.BitmapCacheOption.OnLoad;
                bitmapimage.EndInit();
                return bitmapimage;
            }
        }
    }
}