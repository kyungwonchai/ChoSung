안녕하세요. 현재 구성하신 시스템(PC-파일-장비)은 간단하고 직관적이지만, 안정성과 확장성 면에서 몇 가지 개선할 점이 있습니다. 문의하신 센서 오감지 예방과 통신 방법 개선에 대해 C# (.NET 4.8) 구현 예제와 함께 자세히 설명해 드리겠습니다.

1. 센서 오감지 예방 방안
센서의 오감지는 물리적인 원인(센서 노후, 분진, 진동 등)과 전기적 노이즈로 인해 발생할 수 있습니다. 하드웨어 개선과 함께 소프트웨어적으로 안정성을 높이는 방법은 다음과 같습니다.

가. 디바운싱 (Debouncing)
가장 일반적이고 효과적인 방법입니다. 센서 신호가 짧은 시간 동안 여러 번 ON/OFF로 바뀌는 '채터링(Chattering)' 현상을 제거합니다. 즉, 센서 상태가 바뀐 후 일정 시간 동안 그 상태가 유지되어야만 실제 변경으로 인정하는 기법입니다.

C# 구현 예제 (타이머 활용)
C#

using System;
using System.Timers;

public class DebouncedSensor
{
    // --- 내부 변수 ---
    private Timer _debounceTimer;
    private bool _isSensorSignalHigh = false; // PLC로부터 받은 실제 센서 신호
    private bool _finalDetectedState = false; // 디바운싱 후 최종 감지 상태

    // --- 외부로 노출되는 속성 ---
    public bool IsDetected => _finalDetectedState;
    
    // --- 이벤트 ---
    public event Action<bool> OnStateChanged;

    /// <summary>
    /// 생성자
    /// </summary>
    /// <param name="debounceTimeMs">안정화에 필요한 시간 (밀리초)</param>
    public DebouncedSensor(int debounceTimeMs = 100)
    {
        _debounceTimer = new Timer(debounceTimeMs);
        _debounceTimer.Elapsed += DebounceTimer_Elapsed;
        _debounceTimer.AutoReset = false; // 한 번만 실행
    }

    /// <summary>
    /// PLC에서 센서 신호를 받았을 때 호출하는 메서드
    /// </summary>
    /// <param name="isHigh">현재 센서 신호 상태</param>
    public void SetSensorSignal(bool isHigh)
    {
        _isSensorSignalHigh = isHigh;
        _debounceTimer.Stop(); // 이전 타이머가 있다면 중지
        _debounceTimer.Start(); // 새 타이머 시작
    }

    private void DebounceTimer_Elapsed(object sender, ElapsedEventArgs e)
    {
        // 타이머가 완료된 시점의 센서 신호가 이전 최종 상태와 다를 경우에만 상태 변경
        if (_isSensorSignalHigh != _finalDetectedState)
        {
            _finalDetectedState = _isSensorSignalHigh;
            Console.WriteLine($"[상태 변경] 최종 감지 상태: {_finalDetectedState}");

            // 상태 변경 이벤트를 외부에 알림
            OnStateChanged?.Invoke(_finalDetectedState);
        }
    }
}

// --- 사용 예시 ---
public class Program
{
    public static void Main()
    {
        var sensor = new DebouncedSensor(100); // 100ms 동안 상태가 유지되어야 인정

        sensor.OnStateChanged += (isDetected) => {
            // 이 부분에서 파일에 쓰거나 다른 장비에 신호를 보냅니다.
            Console.WriteLine($"이벤트 수신: 장비에 '{isDetected}' 상태를 전달합니다.");
            // WriteToFile(isDetected);
        };

        // 시뮬레이션: 짧은 노이즈 발생
        sensor.SetSensorSignal(true);
        sensor.SetSensorSignal(false);
        sensor.SetSensorSignal(true); // 100ms 이내에 여러번 바뀌어도 마지막 상태로 한번만 타이머 동작

        Console.ReadLine();
    }
}
나. N회 연속 감지 (Consecutive Detection)
신호를 한 번만 확인하는 것이 아니라, 설정된 횟수(N번)만큼 연속으로 동일한 신호가 들어왔을 때만 상태를 인정하는 방식입니다. 주기적인 폴링(Polling) 환경에 적합합니다.

C# 구현 예제
C#

public class ConsecutiveDetectionSensor
{
    // --- 내부 변수 ---
    private readonly int _requiredDetections;
    private int _consecutiveHighCount = 0;
    private int _consecutiveLowCount = 0;
    private bool _finalDetectedState = false;

    // --- 외부로 노출되는 속성 ---
    public bool IsDetected => _finalDetectedState;

    // --- 이벤트 ---
    public event Action<bool> OnStateChanged;

    public ConsecutiveDetectionSensor(int requiredDetections = 3)
    {
        _requiredDetections = requiredDetections;
    }

    /// <summary>
    /// 주기적으로 PLC 센서 상태를 읽어와서 호출
    /// </summary>
    /// <param name="isHigh">현재 센서 신호 상태</param>
    public void CheckSensorState(bool isHigh)
    {
        if (isHigh)
        {
            _consecutiveHighCount++;
            _consecutiveLowCount = 0; // Low 카운터 초기화
        }
        else
        {
            _consecutiveLowCount++;
            _consecutiveHighCount = 0; // High 카운터 초기화
        }

        // ON 상태로 변경 조건 충족
        if (_consecutiveHighCount >= _requiredDetections && !_finalDetectedState)
        {
            _finalDetectedState = true;
            OnStateChanged?.Invoke(true);
        }
        // OFF 상태로 변경 조건 충족
        else if (_consecutiveLowCount >= _requiredDetections && _finalDetectedState)
        {
            _finalDetectedState = false;
            OnStateChanged?.Invoke(false);
        }
    }
}
2. 파일 기반 통신 대안
파일을 주기적으로 읽고 쓰는 방식(Polling)은 구현이 쉽지만 다음과 같은 단점이 있습니다.

느린 반응 속도: 파일 변경을 감지하는 주기가 길수록 장비의 반응이 늦어집니다.

I/O 부하: 잦은 파일 접근은 디스크에 부하를 줍니다. (특히 SSD 수명에 영향)

파일 잠금(File Lock) 문제: 한쪽 프로세스가 파일을 쓰는 동안 다른 프로세스가 접근하지 못할 수 있습니다.

이를 대체할 수 있는 실시간 이벤트 기반 통신 방법은 다음과 같습니다.

가. TCP/IP 소켓 통신 (가장 추천)
네트워크를 통해 직접 데이터를 주고받는 방식으로, PC와 다른 장비가 물리적으로 떨어져 있어도 사용할 수 있습니다. PC가 서버(Server) 역할을 하고, 다른 장비가 클라이언트(Client)로 접속하여 신호를 기다리는 구조입니다.

장점: 실시간 반응, 안정적, 원격 통신 가능

단점: 파일 방식보다 초기 구현이 복잡함

C# 구현 예제 (PC - 서버 역할)
C#

using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SensorSignalServer
{
    private TcpListener _tcpListener;
    private TcpClient _equipmentClient;

    public SensorSignalServer(string ipAddress, int port)
    {
        _tcpListener = new TcpListener(IPAddress.Parse(ipAddress), port);
    }

    public async Task StartListeningAsync()
    {
        _tcpListener.Start();
        Console.WriteLine("장비의 연결을 기다립니다...");
        _equipmentClient = await _tcpListener.AcceptTcpClientAsync();
        Console.WriteLine("장비가 연결되었습니다.");
    }

    public void SendSignal(bool isDetected)
    {
        if (_equipmentClient == null || !_equipmentClient.Connected)
        {
            Console.WriteLine("장비가 연결되지 않았습니다.");
            return;
        }

        try
        {
            NetworkStream stream = _equipmentClient.GetStream();
            // "SENSOR_ON" 또는 "SENSOR_OFF" 같은 명확한 메시지 전송
            byte[] messageBytes = Encoding.UTF8.GetBytes(isDetected ? "SENSOR_ON\n" : "SENSOR_OFF\n");
            stream.Write(messageBytes, 0, messageBytes.Length);
            Console.WriteLine($"신호 전송: {(isDetected ? "SENSOR_ON" : "SENSOR_OFF")}");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"신호 전송 오류: {ex.Message}");
            // 연결 끊김 처리 등 예외 처리 필요
        }
    }
}

// --- 사용 예시 ---
public class Program
{
    public static async Task Main()
    {
        // 서버 시작
        var server = new SensorSignalServer("127.0.0.1", 9999);
        _ = server.StartListeningAsync(); // 백그라운드에서 연결 대기

        // 디바운싱 센서와 연동
        var sensor = new DebouncedSensor(100);
        sensor.OnStateChanged += (isDetected) => {
            server.SendSignal(isDetected);
        };

        // PLC 신호 수신 시뮬레이션
        await Task.Delay(2000); // 장비가 연결될 시간 확보
        sensor.SetSensorSignal(true);

        await Task.Delay(1000);
        sensor.SetSensorSignal(false);
        
        Console.ReadLine();
    }
}
다른 장비(클라이언트)는 해당 IP와 포트로 접속하여 StreamReader.ReadLineAsync() 같은 메서드로 메시지를 실시간으로 읽으면 됩니다.

나. 명명된 파이프 (Named Pipes)
같은 PC 내에서 실행되는 프로세스 간 통신에 매우 효과적입니다. 파일처럼 보이지만 실제로는 메모리에서 동작하여 속도가 빠르고 I/O 부하가 없습니다.

장점: 같은 PC 내에서 매우 빠름, 구현이 소켓보다 간단함

단점: 다른 PC와는 통신할 수 없음

C# 구현 예제 (PC - 파이프 서버 역할)
C#

using System;
using System.IO;
using System.IO.Pipes;
using System.Threading.Tasks;

public class SensorSignalPipeServer
{
    private const string PipeName = "MyPlcSensorPipe";
    private NamedPipeServerStream _pipeServer;

    public async Task WaitForConnectionAsync()
    {
        _pipeServer = new NamedPipeServerStream(PipeName, PipeDirection.Out);
        Console.WriteLine("파이프 연결을 기다립니다...");
        await _pipeServer.WaitForConnectionAsync();
        Console.WriteLine("장비(프로세스)가 연결되었습니다.");
    }

    public void SendSignal(bool isDetected)
    {
        if (_pipeServer == null || !_pipeServer.IsConnected)
        {
            Console.WriteLine("파이프가 연결되지 않았습니다.");
            return;
        }

        try
        {
            using (var writer = new StreamWriter(_pipeServer, Encoding.UTF8, 4096, true))
            {
                writer.WriteLine(isDetected ? "DETECTED" : "CLEAR");
                writer.Flush();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"파이프 쓰기 오류: {ex.Message}");
        }
    }
}
다른 장비(프로세스)는 NamedPipeClientStream을 사용하여 같은 이름의 파이프에 연결하고 데이터를 읽으면 됩니다.

결론 및 추천
안정성 확보: 먼저 디바운싱 또는 N회 연속 감지 로직을 소프트웨어에 적용하여 센서 신호의 신뢰도를 높이세요.

통신 방식 변경:

PC와 장비가 네트워크로 분리되어 있다면 TCP/IP 소켓 통신을 사용하는 것이 가장 이상적인 해결책입니다.

PC와 장비 제어 프로그램이 모두 같은 PC에서 실행된다면, **명명된 파이프(Named Pipes)**가 훨씬 가볍고 빠른 대안이 될 수 있습니다.