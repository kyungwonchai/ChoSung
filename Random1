이제 정확히 알았습니다. 최근 10개의 파일을 가져오되, 과거순으로 정렬해서 DataGrid에 표시하고, 추가로 생성된 파일도 시간 순서대로 DataGrid의 아래에 추가되도록 해야 합니다.

다음으로 해야 할 작업은:

최근 10개의 파일을 과거순으로 가져옵니다 (파일명을 기반으로 시간 정보를 사용하여 정렬).
그 이후에 생성된 파일들도 시간 순서대로 DataGrid의 아래에 추가합니다.
해결 방안:
파일을 과거순으로 정렬해서 처음 10개의 파일을 표시.
새로 생성된 파일들도 시간 순서대로 아래에 추가.
아래는 이를 반영한 코드입니다.

FileProcessor 클래스 (수정된 파일)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;

public class FileProcessor
{
    private readonly string _logFolder;  // 로그 파일이 저장된 폴더 경로
    private List<string> _processedFiles = new List<string>();  // 이미 처리한 파일명 저장
    private DateTime _lastProcessedFileTime;  // 마지막으로 처리한 파일의 시간

    public FileProcessor(string logFolder)
    {
        _logFolder = logFolder;
        _lastProcessedFileTime = DateTime.MinValue;  // 기본값으로 설정
    }

    /// <summary>
    /// 파일명에서 연월일시분초.fff 값을 추출하여 DateTime으로 변환합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        // 파일명에서 언더바로 나눈 우측 값에서 연월일시분초.fff 추출 (예: W_test_20230920123045.txt)
        var datePart = Path.GetFileNameWithoutExtension(fileName).Split('_')[1];
        return DateTime.ParseExact(datePart, "yyyyMMddHHmmssfff", CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// 초기 실행 시, 최근 10개의 파일을 가져오고 마지막 파일의 시간을 저장합니다.
    /// 과거 순으로 정렬하여 반환합니다.
    /// </summary>
    public List<LogEntry> LoadInitialLogs()
    {
        // 폴더 내의 모든 파일을 시간순으로 정렬한 후 최근 10개의 파일만 가져옴
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderByDescending(f => ExtractDateTimeFromFileName(f))  // 파일명에서 시간 값을 추출하여 최신순으로 정렬
            .Take(10)  // 최신 10개만 선택
            .OrderBy(f => ExtractDateTimeFromFileName(f))  // 과거순으로 다시 정렬
            .ToList();

        var logEntries = new List<LogEntry>();

        foreach (var file in files)
        {
            // 파일을 읽어서 파싱 후 로그 엔트리로 추가
            var logEntry = ParseFile(file);
            logEntries.Add(logEntry);

            // 마지막 파일의 시간을 저장
            var fileTime = ExtractDateTimeFromFileName(file);
            if (fileTime > _lastProcessedFileTime)
            {
                _lastProcessedFileTime = fileTime;
            }

            // 처리한 파일 목록에 추가
            _processedFiles.Add(Path.GetFileName(file));
        }

        return logEntries;
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 마지막 파일 시간 이후에 생성된 파일만 처리합니다.
    /// </summary>
    public List<LogEntry> CheckForNewFiles()
    {
        List<LogEntry> newEntries = new List<LogEntry>();

        // 폴더 내의 모든 파일을 시간 순서대로 정렬
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderBy(f => ExtractDateTimeFromFileName(f))  // 파일명에서 시간 값을 추출하여 과거순으로 정렬
            .ToList();

        foreach (var file in files)
        {
            var fileTime = ExtractDateTimeFromFileName(file);

            // 마지막으로 처리된 파일 이후에 생성된 파일만 처리
            if (fileTime > _lastProcessedFileTime)
            {
                var logEntry = ParseFile(file);
                newEntries.Add(logEntry);

                // 새 파일의 시간을 마지막 처리 시간으로 갱신
                _lastProcessedFileTime = fileTime;

                // 처리한 파일 목록에 추가
                _processedFiles.Add(Path.GetFileName(file));
            }
        }

        return newEntries;
    }

    /// <summary>
    /// 파일을 읽어서 LogEntry 객체로 변환합니다.
    /// </summary>
    /// <param name="filePath">읽을 파일의 경로</param>
    /// <returns>파싱된 LogEntry 객체</returns>
    private LogEntry ParseFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);

        var logEntry = new LogEntry
        {
            FileName = Path.GetFileName(filePath),
            MAG_NO = GetValueFromLine(lines, "MAG_NO"),
            MAG_QTY = int.Parse(GetValueFromLine(lines, "MAG_QTY")),
            PO_NO = GetValueFromLine(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(GetValueFromLine(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(GetValueFromLine(lines, "PO_PROD_QTY"))
        };

        return logEntry;
    }

    /// <summary>
    /// 파일에서 특정 키에 해당하는 값을 추출합니다.
    /// </summary>
    /// <param name="lines">파일 내용</param>
    /// <param name="key">찾고자 하는 키 (예: "MAG_NO")</param>
    /// <returns>해당 키에 해당하는 값</returns>
    private string GetValueFromLine(string[] lines, string key)
    {
        var line = lines.FirstOrDefault(l => l.Contains(key));
        return line?.Split('=')[1].Trim('\'');
    }
}
MainViewModel 클래스 (수정된 코드)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Threading;
using System.Windows.Input;

public class MainViewModel
{
    private readonly FileProcessor _fileProcessor;  // 파일 처리 클래스
    private Timer _timer;  // 5초마다 체크할 타이머

    public ObservableCollection<LogEntry> LogEntries { get; set; }  // DataGrid에 바인딩할 로그 목록
    public ICommand LoadLogsCommand { get; }  // 수동으로 로그를 로드하는 명령

    public MainViewModel()
    {
        LogEntries = new ObservableCollection<LogEntry>();
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG");

        // 처음 실행 시 최근 10개의 파일을 로드 (과거순으로)
        LoadInitialLogs();

        // 5초마다 폴더를 감시하는 타이머 설정
        _timer = new Timer(CheckForNewLogs, null, 5000, 5000);

        // 수동으로 로그 로드를 위한 커맨드 설정
        LoadLogsCommand = new RelayCommand(LoadInitialLogs);
    }

    /// <summary>
    /// 처음 실행 시 최근 10개의 로그 파일을 로드합니다 (과거순으로).
    /// </summary>
    private void LoadInitialLogs()
    {
        var initialEntries = _fileProcessor.LoadInitialLogs();

        // 기존 로그를 모두 클리어하고 새로운 엔트리로 채움
        LogEntries.Clear();
        foreach (var entry in initialEntries)
        {
            LogEntries.Add(entry);  // 과거 순서대로 추가
        }
    }

    /// <summary>
    /// 타이머가 5초마다 호출하여 새로운 로그 파일을 확인합니다.
    /// </summary>
    private void CheckForNewLogs(object state)
    {
        var newEntries = _fileProcessor.CheckForNewFiles();

        // 새로운 엔트리들을 DataGrid에 추가 (시간 순서대로 추가)
        foreach (var entry in newEntries)
        {
            App.Current.Dispatcher.Invoke(() => LogEntries.Add(entry));
        }
    }
}
MainWindow.xaml
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log File Viewer" Height="450" Width="800">
    <Grid>
        <!-- DataGrid for displaying log entries -->
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="File Name" Binding="{Binding FileName}" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" />
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" />
            </DataGrid.Columns>
        </DataGrid>

        <!-- Button to manually reload logs -->
        <Button Content="Reload Logs" Command="{Binding LoadLogsCommand}" Width="150" Height="30" 
                HorizontalAlignment="Left" VerticalAlignment="Top" Margin="10"/>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
using System.Windows;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();

            // MainViewModel을 DataContext로 설정하여 바인딩
            DataContext = new MainViewModel();
        }
    }
}
설명:
FileProcessor 클래스:

ExtractDateTimeFromFileName(): 파일명에서 시간을 추출해 DateTime으로 변환합니다.
초기 로드: LoadInitialLogs()에서 최근 10개의 파일을 가져와 과거순으로 정렬한 후 DataGrid에 표시합니다.
실시간 업데이트: 5초마다 CheckForNewFiles()에서 마지막 파일 이후에 생성된 파일들을 과거순으로 추가합니다.
MainViewModel 클래스:

초기 로드: DataGrid에 과거순으로 파일을 추가하여 최근 10개의 파일을 표시합니다.
실시간 갱신: 이후 새로 생성된 파일들을 시간순으로 추가합니다.
이제 이 코드는 최근 10개의 파일을 과거순으로 로드하고, 새로 생성된 파일도 아래에 추가하는 방식으로 동작합