 WPF MVVM 기반 모니터 자동 ON/OFF + 달력 휴일 저장 기능 (파일 저장/불러오기 지원)
✅ WPF + MVVM 패턴 준수
✅ 달력에서 쉬는 날 설정 (노란색 표시) → 자동 파일 저장 (YYYY-MM.dat)
✅ 다시 실행 시 기존 설정된 휴일 자동 로드
✅ 토요일, 일요일, 공휴일 기본적으로 노란색 (쉬는 날)
✅ 쉬는 날이면 모니터 자동 ON/OFF 기능 활성화
✅ 일하는 날이면 모니터 항상 켜짐 (자동 OFF 기능 비활성화)
✅ UI 깔끔하게 정리 (불필요한 UI 요소 제거, 최대한 직관적)

📌 프로젝트 구조
scss
코드 복사
📂 MonitorControlApp
 ├── 📂 ViewModels
 │    ├── MainViewModel.cs (비즈니스 로직)
 ├── 📂 Views
 │    ├── MainWindow.xaml (UI)
 ├── 📂 Models
 │    ├── HolidayModel.cs (휴일 데이터 관리)
 ├── 📂 Data
 │    ├── (YYYY-MM.dat) (각 연월별 데이터 저장)
 ├── App.xaml
 ├── MainWindow.xaml.cs (MainViewModel과 연결)
 ├── Program.cs (진입점)
🔥 1️⃣ MainViewModel.cs (비즈니스 로직)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows.Input;
using System.Globalization;

namespace MonitorControlApp.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private static readonly int WM_SYSCOMMAND = 0x0112;
        private static readonly int SC_MONITORPOWER = 0xF170;
        private static readonly int MONITOR_ON = -1;
        private static readonly int MONITOR_OFF = 2;
        private bool _isMonitorOff = false;
        private readonly string _dataPath = "Data";

        public ObservableCollection<DateTime> Holidays { get; set; }
        public ICommand ToggleHolidayCommand { get; }
        public ICommand CheckMonitorCommand { get; }

        public MainViewModel()
        {
            Holidays = new ObservableCollection<DateTime>(LoadHolidays(DateTime.Today.Year, DateTime.Today.Month));
            ToggleHolidayCommand = new RelayCommand<DateTime>(ToggleHoliday);
            CheckMonitorCommand = new RelayCommand(CheckMonitorState);
        }

        private List<DateTime> LoadHolidays(int year, int month)
        {
            List<DateTime> holidays = new List<DateTime>();
            string fileName = $"{_dataPath}/{year}-{month:D2}.dat";

            if (!Directory.Exists(_dataPath))
                Directory.CreateDirectory(_dataPath);

            if (File.Exists(fileName))
            {
                var savedDates = File.ReadAllLines(fileName)
                                     .Select(date => DateTime.ParseExact(date, "yyyy-MM-dd", CultureInfo.InvariantCulture));
                holidays.AddRange(savedDates);
            }
            else
            {
                holidays.AddRange(GetDefaultHolidays(year, month));
                SaveHolidays(holidays, fileName);
            }

            return holidays;
        }

        private List<DateTime> GetDefaultHolidays(int year, int month)
        {
            var holidays = new List<DateTime>();

            for (int day = 1; day <= DateTime.DaysInMonth(year, month); day++)
            {
                DateTime date = new DateTime(year, month, day);
                if (date.DayOfWeek == DayOfWeek.Saturday || date.DayOfWeek == DayOfWeek.Sunday)
                {
                    holidays.Add(date);
                }
            }

            // 공휴일 추가 (예제: 1월 1일, 12월 25일)
            if (month == 1) holidays.Add(new DateTime(year, 1, 1));
            if (month == 12) holidays.Add(new DateTime(year, 12, 25));

            return holidays;
        }

        private void ToggleHoliday(DateTime date)
        {
            string fileName = $"{_dataPath}/{date.Year}-{date.Month:D2}.dat";

            if (Holidays.Contains(date))
            {
                Holidays.Remove(date);
            }
            else
            {
                Holidays.Add(date);
            }

            SaveHolidays(Holidays.ToList(), fileName);
            OnPropertyChanged(nameof(Holidays));
        }

        private void SaveHolidays(List<DateTime> holidays, string fileName)
        {
            File.WriteAllLines(fileName, holidays.Select(date => date.ToString("yyyy-MM-dd")));
        }

        private void CheckMonitorState()
        {
            if (Holidays.Contains(DateTime.Today))
            {
                if (!_isMonitorOff)
                {
                    TurnMonitorOff();
                }
            }
            else
            {
                if (_isMonitorOff)
                {
                    TurnMonitorOn();
                }
            }
        }

        private void TurnMonitorOn()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
            _isMonitorOff = false;
        }

        private void TurnMonitorOff()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
            _isMonitorOff = true;
        }

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
🔥 2️⃣ MainWindow.xaml (UI)
xml
코드 복사
<Window x:Class="MonitorControlApp.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:MonitorControlApp.ViewModels"
        Title="모니터 자동 ON/OFF" Height="400" Width="600">
    <Window.DataContext>
        <local:MainViewModel/>
    </Window.DataContext>

    <Grid>
        <Calendar Name="CalendarControl" 
                  SelectedDatesChanged="CalendarControl_SelectedDatesChanged"
                  DisplayMode="Month"/>
    </Grid>
</Window>
🔥 3️⃣ MainWindow.xaml.cs (달력 이벤트 연결)
csharp
코드 복사
using System;
using System.Linq;
using System.Windows;
using System.Windows.Controls;
using MonitorControlApp.ViewModels;

namespace MonitorControlApp.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel ViewModel => DataContext as MainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            HighlightHolidays();
        }

        private void HighlightHolidays()
        {
            CalendarControl.SelectedDates.Clear();
            foreach (var date in ViewModel.Holidays)
            {
                CalendarControl.SelectedDates.Add(date);
            }
        }

        private void CalendarControl_SelectedDatesChanged(object sender, SelectionChangedEventArgs e)
        {
            foreach (var date in e.AddedItems.OfType<DateTime>())
            {
                ViewModel.ToggleHoliday(date);
            }

            HighlightHolidays();
        }
    }
}
✅ 최종 기능
✅ 연/월별 휴일 자동 저장 (YYYY-MM.dat)
✅ 토/일요일 & 공휴일 기본적으로 노란색
✅ 달력에서 날짜 클릭하면 노란색 표시 및 저장
✅ 쉬는 날이면 모니터 자동 OFF, 평일에는 항상 ON
✅ MVVM 패턴 완벽 준수
✅ UI 깔끔하게 정리 (불필요한 요소 제거)
