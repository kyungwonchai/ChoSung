의 거리를 측정하는 Levenshtein 거리를 사용하도록 하겠습니다. 또한, 모델로는 scikit-learn의 CountVectorizer와 cosine_similarity를 사용하여 텍스트를 벡터로 변환하고 유사도를 계산할 수 있도록 하겠습니다.

아래는 해당 기능을 수행하는 예시 함수입니다.

python

import pandas as pd
from sklearn.feature_extraction.text import CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from Levenshtein import distance

def find_similar_parts(input_text, parts_data):
    # 입력된 텍스트와 부품코드 데이터의 유사도를 계산하기 위해 벡터 변환
    vectorizer = CountVectorizer()
    parts_vector = vectorizer.fit_transform(parts_data)

    # 입력된 텍스트도 벡터로 변환
    input_vector = vectorizer.transform([input_text])

    # 입력된 텍스트와 각 부품코드의 유사도 계산
    similarity_scores = cosine_similarity(input_vector, parts_vector).flatten()

    # 유사도가 가장 높은 순서대로 정렬하여 상위 10개 부품코드 추출
    top_indices = similarity_scores.argsort()[:-11:-1]
    similar_parts = parts_data[top_indices]

    # Levenshtein 거리를 계산하여 가장 유사한 순서로 정렬
    similarity_scores = [distance(input_text, part) for part in similar_parts]
    similar_parts_with_distance = sorted(zip(similarity_scores, similar_parts))

    return similar_parts_with_distance

이제 위의 함수를 사용하여 UI와 상호작용하는 파이썬 코드를 작성할 수 있습니다. 예를 들어, PyQt나 tkinter를 사용하여 간단한 UI를 구성하고, 사용자가 입력한 텍스트를 함수에 전달하여 결과를 표시할 수 있습니다.

다음은 tkinter를 사용한 예시 코드입니다.

python

import tkinter as tk

def show_similar_parts():
    input_text = input_entry.get()
    similar_parts = find_similar_parts(input_text, parts_data)

    result_text = '\n'.join(f'{part}: {distance}' for distance, part in similar_parts)
    result_label.config(text=result_text)

# 판다스 데이터프레임으로부터 부품코드 데이터를 로드
parts_data = pd.read_csv('부품코드.csv')['부품코드'].values

# tkinter 윈도우 생성
window = tk.Tk()
window.title('부품코드 유사도 검색')

# 입력 텍스트박스
input_entry = tk.Entry(window)
input_entry.pack()

# 검색 버튼
search_button = tk.Button(window, text='검색', command=show_similar_parts)
search_button.pack()

# 결과 텍스트 레이블
result_label = tk.Label(window, text='')
result_label.pack()

window.mainloop()