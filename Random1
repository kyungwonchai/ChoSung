청하신 대로 연결 상태에 따라 도형의 색상과 텍스트를 변경하는 UI를 MainWindow.xaml에 구현하고, 소켓 서버의 연결 상태에 따라 UI가 업데이트되도록 코드를 수정하겠습니다. Grid를 사용하여 도형 위에 텍스트를 겹치도록 만들고, 소켓 서버가 연결되었을 때는 녹색, 끊어졌을 때는 빨간색으로 표시되며 텍스트도 적절하게 변하도록 하겠습니다.

수정된 XAML 및 코드
MainWindow.xaml (UI 정의)
xml
코드 복사
<Window x:Class="SocketServer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Socket Server Simulation" Height="450" Width="600">
    <Grid>
        <!-- 서버 시작 버튼 -->
        <Button Content="Start Server" HorizontalAlignment="Left" VerticalAlignment="Top" Width="100" Height="30" Click="StartServer_Click"/>

        <!-- 연결 상태를 표시할 도형 및 텍스트 -->
        <Grid HorizontalAlignment="Center" VerticalAlignment="Top" Margin="0,50,0,0" Width="100" Height="100">
            <!-- 원형 도형 -->
            <Ellipse x:Name="ConnectionEllipse" Fill="Red" Width="100" Height="100"/>
            <!-- 상태 텍스트 (연결 상태에 따라 변경) -->
            <TextBlock x:Name="ConnectionStatusText" Text="연결 필요" Foreground="White" FontWeight="Bold" HorizontalAlignment="Center" VerticalAlignment="Center"/>
        </Grid>

        <!-- 메시지 로그를 보여줄 DataGrid -->
        <DataGrid ItemsSource="{Binding MessageLogs}" AutoGenerateColumns="False" IsReadOnly="True" Width="580" Height="300" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,0,0,10">
            <DataGrid.Columns>
                <!-- 수신된 메시지 -->
                <DataGridTextColumn Header="Received Message" Binding="{Binding ReceivedMessage}" Width="200"/>
                <!-- 보낸 응답 -->
                <DataGridTextColumn Header="Sent Response" Binding="{Binding SentResponse}" Width="200"/>
                <!-- 정상 여부 -->
                <DataGridTextColumn Header="Success" Binding="{Binding Success}" Width="100"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
MainWindow.xaml.cs (서버 동작 구현 및 상태 업데이트)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media;

namespace SocketServer
{
    public partial class MainWindow : Window
    {
        private TcpListener _tcpListener; // 클라이언트 연결을 수신할 TCP 리스너
        public ObservableCollection<MessageLog> MessageLogs { get; set; } // 로그를 저장할 ObservableCollection
        private bool _isConnected = false; // 현재 서버의 연결 상태를 저장하는 플래그

        public MainWindow()
        {
            InitializeComponent();
            MessageLogs = new ObservableCollection<MessageLog>(); // 메시지 로그 초기화
            DataContext = this; // 데이터 바인딩 설정
            UpdateConnectionStatus(); // 초기 연결 상태 업데이트
        }

        // 서버 시작 버튼 클릭 시 호출되는 이벤트
        private async void StartServer_Click(object sender, RoutedEventArgs e)
        {
            await StartServerAsync(); // 비동기적으로 서버 시작
        }

        // 서버 시작 및 클라이언트 연결 처리 비동기 함수
        private async Task StartServerAsync()
        {
            _tcpListener = new TcpListener(IPAddress.Any, 2400); // 포트 2400에서 모든 IP 주소에서 연결을 대기
            _tcpListener.Start(); // 서버 시작
            LogMessage("", "Server started and waiting for client connection...", ""); // 서버 시작 로그

            while (true) // 서버가 실행되는 동안 클라이언트 연결을 계속 수신
            {
                TcpClient client = await _tcpListener.AcceptTcpClientAsync(); // 클라이언트 연결 대기
                _isConnected = true; // 클라이언트가 연결되면 연결 상태 true
                UpdateConnectionStatus(); // 연결 상태 업데이트 (녹색으로 변경)
                LogMessage("", "Client connected.", ""); // 클라이언트 연결 로그
                _ = Task.Run(() => HandleClientAsync(client)); // 클라이언트 처리 비동기 함수 실행
            }
        }

        // 클라이언트로부터 데이터를 수신하고 응답을 처리하는 비동기 함수
        private async Task HandleClientAsync(TcpClient client)
        {
            NetworkStream stream = client.GetStream(); // 클라이언트와의 통신을 위한 네트워크 스트림
            byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

            try
            {
                int bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 수신
                if (bytesRead > 0)
                {
                    string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신한 데이터를 문자열로 변환
                    LogMessage(receivedMessage, "", ""); // 수신 메시지 로그 기록

                    // 응답 생성: 수신한 메시지를 그대로 돌려보내거나 "OK" 메시지를 보냄
                    string responseMessage = receivedMessage.Trim('\x02', '\x03') == "TestCommand" ? "\x02OK\x03" : "\x02NG\x03";
                    byte[] responseBytes = Encoding.ASCII.GetBytes(responseMessage); // 응답을 바이트 배열로 변환
                    await stream.WriteAsync(responseBytes, 0, responseBytes.Length); // 클라이언트로 응답 전송
                    LogMessage(receivedMessage, responseMessage, responseMessage.Contains("OK").ToString()); // 응답 로그 기록
                }
            }
            catch (Exception ex)
            {
                LogMessage("", $"Error: {ex.Message}", "False"); // 오류 로그 기록
            }
            finally
            {
                client.Close(); // 클라이언트 연결 종료
                _isConnected = false; // 연결이 끊겼으므로 false로 설정
                UpdateConnectionStatus(); // 연결 끊김 상태 업데이트 (빨간색으로 변경)
            }
        }

        // 메시지 로그 추가 함수
        private void LogMessage(string receivedMessage, string sentResponse, string success)
        {
            Application.Current.Dispatcher.Invoke(() => // UI 스레드에서 실행되도록 보장
            {
                MessageLogs.Add(new MessageLog
                {
                    ReceivedMessage = receivedMessage,
                    SentResponse = sentResponse,
                    Success = success
                });

                if (MessageLogs.Count > 50) // 최대 50개의 로그만 유지
                {
                    MessageLogs.RemoveAt(0); // 오래된 항목 삭제
                }
            });
        }

        // 연결 상태를 갱신하는 함수
        private void UpdateConnectionStatus()
        {
            Application.Current.Dispatcher.Invoke(() => // UI 업데이트를 위해 Dispatcher 사용
            {
                if (_isConnected)
                {
                    ConnectionEllipse.Fill = Brushes.Green; // 연결되면 녹색으로 변경
                    ConnectionStatusText.Text = "연결됨"; // 텍스트 변경
                }
                else
                {
                    ConnectionEllipse.Fill = Brushes.Red; // 연결되지 않았을 때 빨간색
                    ConnectionStatusText.Text = "연결 필요"; // 텍스트 변경
                }
            });
        }
    }

    // 메시지 로그를 위한 클래스
    public class MessageLog
    {
        public string ReceivedMessage { get; set; } // 수신된 메시지
        public string SentResponse { get; set; } // 보낸 응답
        public string Success { get; set; } // 정상 여부 (OK/NG)
    }
}
설명:
UI (MainWindow.xaml):

Grid를 사용하여 도형과 텍스트를 겹쳐 배치합니다.
원형 도형 (Ellipse)은 연결 상태를 나타냅니다. 기본적으로 빨간색으로 시작하며, 서버가 클라이언트와 연결되면 녹색으로 변경됩니다.
도형 위에 위치한 **텍스트 (TextBlock)**는 연결 상태를 설명합니다. 연결되지 않은 상태에서는 "연결 필요"로 표시되며, 연결되면 "연결됨"으로 변경됩니다.
MainWindow.xaml.cs:

_isConnected: 현재 서버와 클라이언트의 연결 상태를 저장하는 플래그입니다.
UpdateConnectionStatus: 연결 상태에 따라 원의 색상을 빨간색(연결 끊김) 또는 녹색(연결됨)으로 변경하고, 텍스트도 같이 변경합니다.