, 알겠습니다! "원격 제어판"(control_panel.html)에 표시되는 PC 목록이 많을 경우를 대비해, PC 이름 또는 IP 주소 등에 특정 단어가 포함된 행을 빠르게 찾아주는 검색 기능을 추가해 보겠습니다.

이 기능은 주로 Flask 웹 애플리케이션의 다음 파일들을 수정하여 구현합니다:

app/templates/user/control_panel.html (수정): 검색어 입력 필드와 검색 버튼을 추가합니다.
app/routes_user.py (수정): control_panel 라우트 함수가 검색어를 GET 파라미터로 받아, 데이터베이스 조회 시 해당 검색어가 pc_name, address1, address2 중 하나에 포함된 PC만 필터링하도록 수정합니다.
1. 수정: app/templates/user/control_panel.html (검색 UI 추가)
PC 목록 테이블 위에 검색어 입력 필드와 검색 버튼을 추가합니다.

HTML

{% extends "layout.html" %}

{% block title %}{{ title }}{% endblock %}

{% block content %}
    <h1>{{ title }}</h1>
    
    {# --- ▼▼▼ 검색 기능 UI 추가 ▼▼▼ --- #}
    <form method="GET" action="{{ url_for('user.control_panel') }}" style="margin-bottom: 20px;">
        <div class="form-group" style="display: flex; align-items: center;">
            <label for="search_term" style="margin-bottom: 0; margin-right: 10px; white-space: nowrap;">PC 검색:</label>
            <input type="text" name="search" id="search_term" value="{{ request.args.get('search', '') }}" 
                   placeholder="PC 이름, 주소1 또는 주소2 포함 단어" style="flex-grow: 1; margin-right: 10px;" class="form-control">
            <button type="submit" class="btn btn-primary btn-sm" style="padding: 10px 15px;">검색</button>
            {% if request.args.get('search') %}
            <a href="{{ url_for('user.control_panel') }}" class="btn btn-secondary btn-sm" style="margin-left: 5px; padding: 10px 15px;">필터 해제</a>
            {% endif %}
        </div>
    </form>
    {# --- ▲▲▲ 검색 기능 UI 추가 끝 ▲▲▲ --- #}

    <p>제어할 PC를 선택하고 하단의 명령 버튼을 클릭하세요.</p>

    {% if pcs %}
    <form action="{{ url_for('user.send_batch_command') }}" method="POST">
        <table style="margin-bottom: 20px;">
            <thead>
                <tr>
                    <th><input type="checkbox" id="selectAllPcs" onclick="toggleAllCheckBoxes(this, 'selected_pcs')"></th>
                    <th>ID</th>
                    <th>PC 이름</th>
                    <th>주소1 (릴레이 IP)</th>
                    <th>주소2 (최종 IP)</th>
                    <th>설명</th>
                </tr>
            </thead>
            <tbody>
                {% for pc in pcs %}
                <tr>
                    <td><input type="checkbox" name="selected_pcs" value="{{ pc.id }}"></td>
                    <td>{{ pc.id }}</td>
                    <td>{{ pc.pc_name }}</td>
                    <td>{{ pc.address1 }}</td>
                    <td>{{ pc.address2 if pc.address2 else '-' }}</td>
                    <td>{{ pc.description if pc.description else '-' }}</td>
                </tr>
                {% endfor %}
            </tbody>
        </table>

        <div class="command-buttons">
            <button type="submit" name="command_action" value="켜기" class="btn btn-primary" onclick="return confirmAction('선택된 PC들의 디스플레이 타임아웃을 [사용 안 함]으로 설정하고, 모니터를 즉시 켭니다. 계속하시겠습니까?');">선택 PC 일괄 켜기</button>
            <button type="submit" name="command_action" value="끄기" class="btn btn-danger" onclick="return confirmAction('선택된 PC들의 디스플레이 타임아웃을 [1분 후 끄기]로 설정합니다. 계속하시겠습니까?');">선택 PC 일괄 끄기</button>
        </div>
    </form>
    
    {% if pagination and pagination.total_pages > 1 %}
    <div class="pagination">
        {# 페이지네이션 링크 생성 시 검색어도 함께 전달 #}
        {% set pagination_kwargs = {'page': pagination.prev_num} %}
        {% if request.args.get('search') %}{%金の貸し借りpagination_kwargs, search=request.args.get('search')) %}{% endif %}
        {% if pagination.has_prev %}
            <a href="{{ url_for(request.endpoint, **pagination_kwargs) }}">&laquo; 이전</a>
        {% else %}
            <span class="disabled">&laquo; 이전</span>
        {% endif %}
        
        <span style="margin: 0 10px;">페이지 {{ pagination.page }} / {{ pagination.total_pages }}</span>
        
        {% set pagination_kwargs = {'page': pagination.next_num} %}
        {% if request.args.get('search') %}{%金の貸し借りpagination_kwargs, search=request.args.get('search')) %}{% endif %}
        {% if pagination.has_next %}
            <a href="{{ url_for(request.endpoint, **pagination_kwargs) }}">다음 &raquo;</a>
        {% else %}
            <span class="disabled">다음 &raquo;</span>
        {% endif %}
        <span style="margin-left: 15px;">(총 {{ pagination.total_items }}개)</span>
    </div>
    {% endif %}

    {% else %}
        {% if request.args.get('search') %}
            <p>'{{ request.args.get('search') }}'에 대한 검색 결과가 없습니다. <a href="{{ url_for('user.control_panel') }}">전체 목록 보기</a></p>
        {% else %}
            <p>제어 가능한 PC가 등록되어 있지 않습니다. 관리자에게 문의하세요.</p>
        {% endif %}
    {% endif %}

    {# Flash 메시지 표시 영역 (이전과 동일) #}
    <div style="margin-top: 30px;">
        {% with messages = get_flashed_messages(with_categories=true) %}
            {% if messages %}
                <h3 style="font-size: 1.1em; margin-bottom: 8px;">알림:</h3>
                <ul class="flash-messages">
                {% for category, message in messages %}
                    <li class="{{ category }}">{{ message }}</li>
                {% endfor %}
                </ul>
            {% endif %}
        {% endwith %}
    </div>
    
{% endblock %}

{% block scripts %}
{{ super() }} 
<script>
    function toggleAllCheckBoxes(source, name) {
        var checkboxes = document.getElementsByName(name);
        for(var i=0, n=checkboxes.length; i<n; i++) {
            checkboxes[i].checked = source.checked;
        }
    }
    function confirmAction(message) {
        return confirm(message);
    }
</script>
{% endblock %}
control_panel.html 주요 변경 사항:

페이지 상단에 검색어(name="search")를 입력할 수 있는 <input type="text"> 필드와 "검색" 버튼을 포함하는 <form method="GET">을 추가했습니다.
검색어가 이미 적용된 상태라면 "필터 해제" 버튼을 표시하여 전체 목록으로 돌아갈 수 있게 했습니다.
페이지네이션 링크 생성 시, 현재 검색어(request.args.get('search'))가 있다면 해당 검색어를 다음/이전 페이지 URL에도 포함하도록 수정했습니다. 이렇게 해야 검색 결과 내에서 페이지 이동이 가능합니다. **pagination_kwargs를 사용하여 동적으로 URL 파라미터를 구성합니다. ({% set ... %}과 {%金の貸し借り... %}는 Jinja2 매크로 set과 update 기능을 모방한 것입니다. 더 정확히는 dict.update를 Jinja2에서 사용하려면 약간의 트릭이 필요하거나, 파라미터를 직접 나열해야 합니다. 여기서는 Jinja2의 dict.update가 직접 지원되지 않으므로, URL 파라미터를 개별적으로 명시하는 것이 더 안전합니다. 아래 routes_user.py 수정과 함께 더 나은 방법을 고려하겠습니다. 지금은 개념만 표시했습니다.)
페이지네이션 링크 수정: Jinja2에서 딕셔너리를 직접 수정하는 것은 까다로우므로, url_for에 검색어를 명시적으로 추가하는 방식으로 변경하는 것이 좋습니다. (routes_user.py에서 이를 처리하는 pagination 객체에 search_term을 추가하여 전달하는 것이 더 깔끔할 수 있습니다.)
검색 결과가 없을 때 적절한 메시지를 표시하도록 수정했습니다.
페이지네이션 링크 수정 (더 나은 방법):
템플릿의 페이지네이션 부분을 다음과 같이 수정하고, routes_user.py에서 pagination_data에 search_term을 추가합니다.

HTML

    {# 페이지네이션 링크 (검색어 유지) #}
    {% if pagination and pagination.total_pages > 1 %}
    <div class="pagination">
        {% if pagination.has_prev %}
            <a href="{{ url_for(request.endpoint, page=pagination.prev_num, search=pagination.search_term if pagination.search_term else None) }}">&laquo; 이전</a>
        {% else %}
            <span class="disabled">&laquo; 이전</span>
        {% endif %}
        
        <span style="margin: 0 10px;">페이지 {{ pagination.page }} / {{ pagination.total_pages }}</span>
        
        {% if pagination.has_next %}
            <a href="{{ url_for(request.endpoint, page=pagination.next_num, search=pagination.search_term if pagination.search_term else None) }}">다음 &raquo;</a>
        {% else %}
            <span class="disabled">다음 &raquo;</span>
        {% endif %}
        <span style="margin-left: 15px;">(총 {{ pagination.total_items }}개)</span>
    </div>
    {% endif %}
2. 수정: app/routes_user.py (검색어 처리 로직 추가)
control_panel 라우트 함수를 수정하여 GET 요청으로 전달된 search 파라미터를 받고, 이 값을 사용하여 데이터베이스를 조회할 때 WHERE 절에 검색 조건을 추가합니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection
from app.auth import ip_auth_required
from app.socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone
import math

user_bp = Blueprint('user', __name__)

@user_bp.route('/control_panel') # GET 요청만 처리 (검색은 GET 파라미터로)
@ip_auth_required('user')
def control_panel():
    page = request.args.get('page', 1, type=int)
    per_page = 20 # 페이지 당 항목 수
    search_term = request.args.get('search', '').strip() # 검색어 가져오기 (양쪽 공백 제거)

    offset = (page - 1) * per_page
    pcs_on_current_page = []
    total_pcs = 0
    conn = None
    
    # 페이지네이션 데이터 기본값
    pagination_data = {
        'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 
        'items': [], 'has_prev': False, 'has_next': False, 
        'prev_num': 1, 'next_num': 1, 'search_term': search_term # 검색어 추가
    }

    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            count_query_base = "SELECT COUNT(*) AS total FROM dbo.target_pcs"
            data_query_base = "SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs"
            
            where_clauses = []
            query_params = []

            if search_term:
                like_search_term = f"%{search_term}%"
                # 여러 컬럼에서 검색 (OR 조건)
                where_clauses.append("(pc_name LIKE %s OR address1 LIKE %s OR address2 LIKE %s OR description LIKE %s)")
                # 각 LIKE 절에 대해 파라미터 추가
                for _ in range(4): # pc_name, address1, address2, description
                    query_params.append(like_search_term)
            
            # WHERE 절 조합
            sql_where = ""
            if where_clauses:
                sql_where = " WHERE " + " AND ".join(where_clauses) # 현재는 OR만 있으므로 AND는 불필요

            # 총 개수 조회
            final_count_query = count_query_base + sql_where
            cursor.execute(final_count_query, tuple(query_params)) # COUNT 쿼리에는 파라미터 그대로 사용
            total_pcs_result = cursor.fetchone()
            if total_pcs_result:
                total_pcs = total_pcs_result.get('total', 0)
            
            if total_pcs > 0:
                # 현재 페이지 데이터 조회 (정렬 및 페이지네이션 적용)
                # OFFSET FETCH는 ORDER BY와 함께 사용되어야 함
                final_data_query = f"""
                    {data_query_base} 
                    {sql_where}
                    ORDER BY pc_name 
                    OFFSET %s ROWS FETCH NEXT %s ROWS ONLY
                """
                # 데이터 조회용 파라미터에는 offset과 per_page 추가
                data_query_params = query_params + [offset, per_page]
                cursor.execute(final_data_query, tuple(data_query_params))
                pcs_on_current_page = cursor.fetchall()
            
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({
                'total_items': total_pcs, 
                'total_pages': total_pages, 
                'items': pcs_on_current_page, 
                'has_prev': page > 1, 
                'has_next': page < total_pages,
                'prev_num': page - 1 if page > 1 else 1,
                'next_num': page + 1 if page < total_pages else total_pages
            })

    except Exception as e:
        current_app.logger.error(f"제어판 PC 목록 조회 오류 (검색어: '{search_term}'): {e}", exc_info=True)
        flash("PC 목록을 불러오는 중 오류가 발생했습니다. DB 연결을 확인하세요.", "error")
        
    title = "원격 제어판"
    if search_term:
        title += f" (검색어: '{search_term}')"
    if g.current_user_role == 'admin':
        title = "원격 제어판 (관리자 모드)" + (f" (검색어: '{search_term}')" if search_term else "")
        
    return render_template('user/control_panel.html', 
                           pcs=pcs_on_current_page, 
                           pagination=pagination_data, 
                           title=title)

# send_batch_command 함수는 이전 답변과 동일하게 유지
@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    # ... (이전 send_batch_command 코드 전체 - 변경 없음) ...
    selected_pc_ids_str = request.form.getlist('selected_pcs'); command_action_str = request.form.get('command_action')
    if not selected_pc_ids_str: flash("PC를 선택하세요.", 'warning'); return redirect(url_for('user.control_panel'))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]: flash("명령(켜기/끄기) 지정 오류.", 'warning'); return redirect(url_for('user.control_panel'))
    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]; conn = None; target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids: placeholders = ', '.join(['%s'] * len(selected_pc_ids)); sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"; cursor.execute(sql_select_pcs, tuple(selected_pc_ids)); target_pcs_to_control = cursor.fetchall()
    except Exception as e: current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True); flash("명령 대상 PC 정보 DB 조회 오류.", "error"); return redirect(url_for('user.control_panel'))
    if not target_pcs_to_control: flash("선택된 PC 정보 없음.", "warning"); return redirect(url_for('user.control_panel'))
    timeout_minutes_for_command = 0 if command_action_str == "켜기" else 1 
    action_description_log = "디스플레이 항상 켜기(0분)" if command_action_str == "켜기" else "디스플레이 1분 후 자동 꺼짐"
    payload_for_agent = {'TimeoutMinutes': timeout_minutes_for_command} 
    for pc_data in target_pcs_to_control:
        packet_set_timeout = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': "SET_DISPLAY_TIMEOUT", 'PayloadJson': json.dumps(payload_for_agent), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: packet_set_timeout.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: packet_set_timeout.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"PC '{pc_data.get('pc_name','N/A')}' ({target_ip})"; flash(f"{log_prefix} '{action_description_log}' 전송 시도...", 'info')
        current_app.logger.info(f"{log_prefix} - 전송: {action_description_log}, PktID: {packet_set_timeout['PacketId']}")
        response_timeout = send_command_to_agent(target_ip, packet_set_timeout)
        _process_agent_response(response_timeout, log_prefix, "타임아웃 설정")
        if command_action_str == "켜기": 
            action_desc_monitor_on = "모니터 즉시 켜기"; payload_monitor_on = {'Action': -1} 
            packet_monitor_on = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': "MONITOR_CONTROL", 'PayloadJson': json.dumps(payload_monitor_on), 'ResponseAddress': None, 'ResponsePort': None, 'Instruction': packet_set_timeout['Instruction'], 'FinalTargetIpForRelayedCommand': packet_set_timeout.get('FinalTargetIpForRelayedCommand'), 'FinalTargetPortForRelayedCommand': packet_set_timeout.get('FinalTargetPortForRelayedCommand') }
            flash(f"{log_prefix} '{action_desc_monitor_on}' 추가 전송 시도...", 'info'); current_app.logger.info(f"{log_prefix} - 전송: {action_desc_monitor_on}, PktID: {packet_monitor_on['PacketId']}")
            response_monitor_on = send_command_to_agent(target_ip, packet_monitor_on)
            _process_agent_response(response_monitor_on, log_prefix, "즉시 모니터 켜기")
    return redirect(url_for('user.control_panel', search=request.form.get('search_term_hidden', ''))) # 검색어 유지하며 리다이렉트 고려

# _process_agent_response 헬퍼 함수는 이전 답변과 동일하게 유지
def _process_agent_response(agent_response, log_prefix, command_description):
    # ... (이전 _process_agent_response 코드 전체 - 변경 없음) ...
    if agent_response.get('success'):
        raw_pkt = agent_response.get('raw_response')
        if raw_pkt and isinstance(raw_pkt, dict) and 'PayloadJson' in raw_pkt:
            payload_str = raw_pkt.get('PayloadJson')
            current_app.logger.info(f"{log_prefix} - '{command_description}' 응답 PayloadJson: >>>{payload_str}<<<")
            if payload_str is not None:
                try:
                    resp_pl = json.loads(payload_str);
                    if resp_pl.get('Success'): flash(f"{log_prefix} ({command_description}): 성공 - {resp_pl.get('Message', 'OK')}", 'success'); current_app.logger.info(f"{log_prefix} ({command_description}) 성공: {resp_pl.get('Message')}")
                    else: flash(f"{log_prefix} ({command_description}): 실패 (에이전트) - {resp_pl.get('Message', 'Agent error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 에이전트 실패: {resp_pl.get('Message')}")
                except json.JSONDecodeError as je: flash(f"{log_prefix} ({command_description}): 응답 JSON 형식 오류 - {je.msg}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 파싱 오류: {je.msg}. 원본: {payload_str}", exc_info=True)
                except Exception as e: flash(f"{log_prefix} ({command_description}): 응답 처리 중 알 수 없는 오류 - {e}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_str}", exc_info=True)
            else: flash(f"{log_prefix} ({command_description}): 전송 성공 (페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 페이로드 없음. RawPkt: {raw_pkt}")
        else: flash(f"{log_prefix} ({command_description}): 전송 성공 (상세 응답/페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 상세 응답/페이로드 없음. RawPkt: {raw_pkt}")
    else: flash(f"{log_prefix} ({command_description}): 전송 실패 - {agent_response.get('message', 'Socket error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 전송 실패: {agent_response.get('message')}")

app/routes_user.py의 control_panel 함수 주요 변경 사항:

검색어 처리:
search_term = request.args.get('search', '').strip(): GET 파라미터로 전달된 search 값을 가져옵니다. 없으면 빈 문자열입니다.
pagination_data 딕셔너리에 search_term을 추가하여 템플릿의 페이지네이션 링크가 검색어를 유지할 수 있도록 합니다.
동적 SQL WHERE 절 생성:
search_term이 있는 경우, pc_name, address1, address2, description 컬럼에 대해 LIKE %검색어% 조건을 포함하는 WHERE 절을 동적으로 생성합니다.
파라미터화된 쿼리를 위해 query_params 리스트에 검색어를 추가합니다.
쿼리 실행: 총 개수 조회(final_count_query)와 실제 데이터 조회(final_data_query) 모두에 동적으로 생성된 WHERE 절과 query_params를 사용합니다.
템플릿에 전달: 검색 결과(pcs_on_current_page)와 수정된 pagination_data를 템플릿에 전달합니다. 페이지 제목에도 검색어가 포함되도록 수정했습니다.
참고: send_batch_command 함수는 이전과 동일하게 유지했습니다. 일괄 명령 전송 후 control_panel로 리다이렉트할 때, 현재 적용된 검색어를 유지하고 싶다면 redirect(url_for('user.control_panel', search=search_term_variable))와 같이 search 파라미터를 전달해야 합니다. (이를 위해서는 send_batch_command 함수가 현재 검색어를 알아야 합니다. HTML 폼에 hidden 필드로 현재 검색어를 포함시켜 POST 요청 시 함께 받는 방법이 있습니다.) 위 코드에서는 send_batch_command 후 리다이렉트 시 검색어 유지는 일단 생략했습니다.

위 수정된 파일들을 프로젝트에 적용하시면 "원격 제어판" 페이지 상단에 검색창이 나타나고, PC 이름이나 주소의 일부를 입력하여 필터링된 목록을 볼 수 있게 됩니다. 페이지네이션 링크도 검색어를 유지하며 동작하도록 템플릿과 라우트 함수가 수정되었습니다. (템플릿의 페이지네이션 링크 부분은 위 HTML 코드의 "페이지네이션 링크 (검색어 유지)" 부분을 참고하여 수정해주세요.)

테스트해보시고 잘 동작하는지 확인 부탁드립니다!

