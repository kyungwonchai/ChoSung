복된 줄을 캐치하지 않도록 해시를 사용하여 중복 감지 기능을 추가할 수 있습니다. 이 기능은 각 줄의 내용을 해시로 변환하고, 해시값을 저장한 뒤에 동일한 해시값을 가진 줄은 무시하는 방식으로 구현할 수 있습니다.

수정 사항:
해시값을 통한 중복 방지: 각 줄을 읽을 때 해시값을 계산하고, 이미 처리된 해시값이 있는지 확인하여 중복된 줄은 건너뜁니다.
중복된 해시값 저장: 중복된 줄의 해시값을 HashSet에 저장하여 빠르게 중복을 확인할 수 있도록 합니다.
수정된 ViewModel 코드
csharp
코드 복사
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.ComponentModel;
using System.Security.Cryptography;
using System.Text;
using System.Windows;

namespace LogFileWatcher.ViewModels
{
    public class FileWatcherViewModel : INotifyPropertyChanged
    {
        private FileSystemWatcher _watcher;
        private readonly string _folderPath = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 있는 폴더 경로
        private readonly string _positionFolderPath = @"C:\G-MES2.0\GUMI_WEB\log_positions"; // 마지막 줄 위치를 저장할 폴더
        private readonly string[] _keywords = { "FST", "FNL", "PLAN" };  // 감지할 키워드 목록
        private Dictionary<string, int> _fileLinePositions = new Dictionary<string, int>();  // 파일별 마지막 읽은 줄 저장
        private HashSet<string> _processedLineHashes = new HashSet<string>(); // 중복 방지용 해시값 저장

        public event PropertyChangedEventHandler PropertyChanged;

        public FileWatcherViewModel()
        {
            LoadLastPositions();  // 프로그램 시작 시 마지막 읽은 위치 로드
            SetupWatcher();
            Application.Current.Exit += OnExit;  // 프로그램 종료 시 이벤트 처리
        }

        // 마지막으로 읽은 줄 번호를 파일로부터 로드하는 메서드
        private void LoadLastPositions()
        {
            if (!Directory.Exists(_positionFolderPath))
            {
                Directory.CreateDirectory(_positionFolderPath);
            }

            var positionFiles = Directory.GetFiles(_positionFolderPath, "*.txt");
            foreach (var positionFile in positionFiles)
            {
                string fileName = Path.GetFileNameWithoutExtension(positionFile);
                if (int.TryParse(File.ReadAllText(positionFile), out int lastLine))
                {
                    _fileLinePositions[fileName] = lastLine;
                }
            }
        }

        // 마지막으로 읽은 줄 번호를 저장하는 메서드
        private void SaveLastPosition(string fileName, int lastLine)
        {
            string positionFilePath = Path.Combine(_positionFolderPath, fileName + ".txt");
            File.WriteAllText(positionFilePath, lastLine.ToString());
        }

        // FileSystemWatcher 설정
        private void SetupWatcher()
        {
            _watcher = new FileSystemWatcher
            {
                Path = _folderPath,  // 감시할 폴더 경로 설정
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,  // 파일 이름과 파일 변경 시 감지
                Filter = "*.log",  // .log 확장자 파일만 감지
                EnableRaisingEvents = true,  // 이벤트 활성화
                IncludeSubdirectories = false  // 하위 폴더는 감지하지 않음
            };

            _watcher.Created += OnChanged;
            _watcher.Changed += OnChanged;
        }

        // 파일이 생성되거나 변경되었을 때 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            string fileName = Path.GetFileName(e.FullPath);
            string pattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_\d{2}\.log$";

            if (Regex.IsMatch(fileName, pattern))
            {
                if (!_fileLinePositions.ContainsKey(fileName))
                {
                    _fileLinePositions[fileName] = 0;
                }

                CheckFileForKeywords(e.FullPath, fileName);
            }
        }

        // 변경된 파일의 내용을 읽고 특정 키워드(FST, FNL, PLAN)가 있는지 확인하는 메서드
        private void CheckFileForKeywords(string filePath, string fileName)
        {
            try
            {
                int lastReadLine = _fileLinePositions[fileName];  // 마지막 읽은 줄 번호
                int currentLineNumber = 0;

                using (StreamReader reader = new StreamReader(filePath))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        currentLineNumber++;

                        if (currentLineNumber > lastReadLine)
                        {
                            // 줄을 해시화하여 중복 감지
                            string lineHash = ComputeHash(line);
                            if (!_processedLineHashes.Contains(lineHash))
                            {
                                foreach (var keyword in _keywords)
                                {
                                    if (line.Contains(keyword))
                                    {
                                        Console.WriteLine($"[{fileName}] 특정 문구 발견: {line}");
                                    }
                                }

                                // 해시값 저장 (중복 방지)
                                _processedLineHashes.Add(lineHash);
                            }

                            _fileLinePositions[fileName] = currentLineNumber;
                        }
                    }
                }

                SaveLastPosition(fileName, _fileLinePositions[fileName]);
            }
            catch (IOException ex)
            {
                Console.WriteLine("파일을 읽는 도중 오류가 발생했습니다: " + ex.Message);
            }
        }

        // 줄을 해시로 변환하여 중복을 감지하는 메서드
        private string ComputeHash(string input)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] inputBytes = Encoding.UTF8.GetBytes(input);
                byte[] hashBytes = sha256.ComputeHash(inputBytes);
                return Convert.ToBase64String(hashBytes);
            }
        }

        // 프로그램 종료 시 마지막 상태를 저장하는 메서드
        private void OnExit(object sender, ExitEventArgs e)
        {
            foreach (var kvp in _fileLinePositions)
            {
                SaveLastPosition(kvp.Key, kvp.Value);
            }
        }

        // INotifyPropertyChanged 구현
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
추가된 중복 방지 기능 설명:
해시값을 통한 중복 감지:

ComputeHash 메서드를 사용하여 각 줄의 해시값을 계산합니다.
해시 알고리즘은 SHA256을 사용하여 각 줄을 고유한 해시값으로 변환합니다.
_processedLineHashes라는 HashSet<string>을 사용하여 이미 처리된 해시값을 저장하고, 중복된 줄은 무시합니다.
해시값을 저장하여 중복 방지:

CheckFileForKeywords 메서드에서 줄을 읽고 해시값을 계산한 후, 해당 해시값이 이미 존재하는지 확인합니다.
중복된 해시값이 없는 경우에만 해당 줄을 처리하고, 해시값을 HashSet에 추가합니다.
동작 방식:
파일 감시: FileSystemWatcher가 파일 변경을 감지합니다.
키워드 확인 및 해시 처리: 파일의 각 줄을 읽을 때 해시값을 계산하여 중복된 줄이 아니면 키워드를 확인하고, 처리된 해시값을 저장합니다.
중복 방지: 이미 처리된 줄은 해시값을 통해 중복 검사를 수행하므로, 동일한 내용이 중복해서 처리되지 않습니다.
이 코드를 통해 파일의 중복 줄을 해시값을 사용하여 효과적으로 방지할 수 있습니다. 추가적인 질문이나 수정이 필요하면 언제든지 알려주세