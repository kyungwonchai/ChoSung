ignalR 통신을 처리하는 클래스를 비동기 방식으로 구현하고, Singleton 패턴을 사용하여 SignalR 클래스를 전역적으로 하나만 사용하도록 전체 구조를 다시 작성하겠습니다. WithUrl 관련 에러가 발생하는 경우, 이를 해결하기 위해서는 Microsoft.AspNetCore.SignalR.Client와 관련된 패키지의 버전이나 설정을 확인하는 것이 좋습니다. 우선 SignalRClient 클래스를 Singleton 패턴으로 재구성하고 비동기 방식으로 다시 작성하겠습니다.

1. SignalRClient 클래스 (Singleton 패턴 및 비동기형 SignalR 처리)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using Microsoft.AspNetCore.SignalR.Client;

public class SignalRClient
{
    private static SignalRClient _instance;  // Singleton 인스턴스
    private HubConnection _hubConnection;  // SignalR 연결 객체
    public event EventHandler<string> LogMessageReceived;  // 로그 이벤트

    // Singleton 패턴을 위한 private 생성자
    private SignalRClient() { }

    // Singleton 인스턴스 접근
    public static SignalRClient Instance
    {
        get
        {
            if (_instance == null)
            {
                _instance = new SignalRClient();
            }
            return _instance;
        }
    }

    // SignalR 연결 초기화 함수 (비동기형)
    public async Task InitializeSignalRConnectionAsync(string hubUrl)
    {
        try
        {
            if (_hubConnection == null || _hubConnection.State != HubConnectionState.Connected)
            {
                _hubConnection = new HubConnectionBuilder()
                    .WithUrl(hubUrl)  // 허브 URL 설정
                    .Build();

                await _hubConnection.StartAsync();  // 비동기로 SignalR 연결 시작
                Log("SignalR Connection Started");  // 연결 성공 로그
            }
        }
        catch (Exception ex)
        {
            LogError(ex.Message);  // 연결 실패 시 로그 기록
        }
    }

    // 메시지 전송 함수 (비동기)
    public async Task SendMessageAsync(string message)
    {
        try
        {
            if (_hubConnection != null && _hubConnection.State == HubConnectionState.Connected)
            {
                await _hubConnection.InvokeAsync("SendMessage", message);
                Log($"Message sent: {message}");  // 성공적으로 전송된 경우 로그
            }
            else
            {
                LogError("SignalR is not connected.");
            }
        }
        catch (Exception ex)
        {
            LogError(ex.Message);  // 전송 중 오류 발생 시 로그 기록
        }
    }

    // 로그 기록 함수
    private void Log(string message)
    {
        LogMessageReceived?.Invoke(this, message);  // 로그 메시지를 외부로 전달
    }

    // 에러 로그 기록 함수
    private void LogError(string errorMessage)
    {
        Log($"Error: {errorMessage}");  // 에러 로그 기록
    }
}
2. MainViewModel 클래스 (SignalRClient의 Singleton 인스턴스를 사용)
csharp
코드 복사
using System;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

public class MainViewModel : INotifyPropertyChanged
{
    private string _logMessage;

    public event PropertyChangedEventHandler PropertyChanged;

    public string LogMessage
    {
        get { return _logMessage; }
        set
        {
            _logMessage = value;
            OnPropertyChanged();
        }
    }

    public MainViewModel()
    {
        InitializeSignalR();  // SignalR 연결 초기화
        SignalRClient.Instance.LogMessageReceived += OnLogMessageReceived;  // 로그 메시지 수신 이벤트 연결
        OtherClass.SignalReceived += OnSignalReceived;  // 외부 클래스의 이벤트 수신
    }

    // SignalR 연결 초기화 함수 (비동기)
    private async void InitializeSignalR()
    {
        await SignalRClient.Instance.InitializeSignalRConnectionAsync("http://localhost:5000/myhub");  // 허브 URL 설정
    }

    // 외부 클래스에서 이벤트가 발생했을 때 호출되는 함수
    private async void OnSignalReceived(object sender, string message)
    {
        await SendSignalRMessageAsync(message);
    }

    // SignalR을 통해 메시지를 보내는 함수
    private async Task SendSignalRMessageAsync(string message)
    {
        await SignalRClient.Instance.SendMessageAsync(message);  // Singleton 인스턴스의 SendMessage 호출
    }

    // SignalRClient에서 발생한 로그 메시지를 수신하여 UI에 표시
    private void OnLogMessageReceived(object sender, string logMessage)
    {
        LogMessage = logMessage;  // 로그 메시지 업데이트
    }

    // PropertyChanged 이벤트 발생 함수
    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
3. OtherClass (신호를 발생시키는 클래스)
csharp
코드 복사
using System;

public class OtherClass
{
    // 신호를 외부로 전달하는 이벤트
    public static event EventHandler<string> SignalReceived;

    // 특정 조건에서 신호를 발생시키는 함수 (예시로 타이머로 신호를 발생시킴)
    public void TriggerSignal()
    {
        string message = "This is a test message";

        // 이벤트 발생, MainViewModel에서 수신하여 SignalR로 전송함
        SignalReceived?.Invoke(this, message);
    }
}
4. XAML (UI 부분)
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
    <Grid>
        <TextBlock Text="{Binding LogMessage}" VerticalAlignment="Center" HorizontalAlignment="Center" />
    </Grid>
</Window>
5. MainWindow.xaml.cs (뷰모델 설정)
csharp
코드 복사
using System.Windows;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        DataContext = new MainViewModel();  // MainViewModel을 DataContext로 설정
    }
}
설명
SignalRClient (Singleton 패턴):

SignalRClient는 Singleton 패턴을 사용하여 애플리케이션 전역에서 하나의 SignalR 연결을 공유합니다. 이를 통해 메모리 사용을 최적화하고, 여러 인스턴스에서 발생할 수 있는 불필요한 연결을 방지합니다.
InitializeSignalRConnectionAsync: 허브 URL을 받아 SignalR 연결을 초기화하고 비동기로 시작합니다. 만약 연결이 실패하거나 예외가 발생하면 에러 로그를 남깁니다.
SendMessageAsync: SignalR 서버로 메시지를 비동기로 전송하며, 연결 상태를 확인하고 로그를 남깁니다.
MainViewModel:

SignalRClient.Instance를 통해 Singleton 인스턴스를 사용하여 메시지를 전송하고, 초기화할 때도 같은 인스턴스를 사용합니다.
LogMessage는 UI와 바인딩되며, SignalR 로그 메시지가 발생할 때마다 자동으로 UI에 표시됩니다.
OtherClass:

신호를 발생시키는 클래스입니다. 외부에서 이벤트를 통해 MainViewModel로 신호를 전달하여 SignalR로 값을 보냅니다.
에러 처리 및 프로그램 안정성
SignalR 연결 중에 문제가 발생하거나 메시지 전송 중 오류가 발생할 경우, LogError 메서드를 통해 에러 메시지를 로그로 남기고 프로그램은 종료되지 않습니다.
로그 기록: 에러 메시지 또는 성공 메시지는 LogMessageReceived 이벤트를 통해 외부로 전달되며, UI에서 이를 확인할 수 있습니다.
이 코드 구조는 Singleton 패턴을 사용하여 SignalR 연결을 한 번만 생성하고 공유하도록 하였으며, 비동기 방식으로 통신을 처리하고 에러 처리 로직도 포함하였습니다.




