고객님, 랙 규모를 대폭 축소하여 가로 12칸, 총 2개 랙 구성에 대한 솔루션을 제시해 드리겠습니다. 램프 간 간격이 80cm로 넓어진 점과 랙 전체 범위에 불을 켜는 시각적 보조 기능을 중점적으로 반영하여 구성하겠습니다.

이전 제안의 전체 인프라와 변수명을 그대로 유지하면서, 하드웨어 구성과 제어 로직을 간소화하여 가성비와 구현 편의성을 높이는 방향으로 설계하겠습니다.

1. 전체 시스템 인프라 및 아키텍처
규모가 작아진 만큼, 각 랙을 개별적으로 제어하는 복잡한 RS-485 통신 방식 대신, 메인 컨트롤러 하나로 모든 LED를 직접 제어하는 방식으로 단순화하겠습니다.

시스템 아키텍처 다이어그램 (간소화된 버전):

코드 스니펫

graph TD
    A[사용자 PC] -- 1. 바코드 스캔 / GUI --> B(MES)
    B -- 2. REST API / MQTT --> C(메인 컨트롤러 Main Controller)
    C -- 3. GPIO --> D{LED 모듈 1}
    C -- 3. GPIO --> E{LED 모듈 2}
    F[MES] -- 4. 바코드 / 슬롯 정보 관리 --> G(MSSQL 2014)
변수명 및 데이터 흐름 (일관성 유지):

rack_id: 'RACK-01', 'RACK-02' (총 2개)

slot_id: 'RACK-01_SLOT-01'부터 'RACK-01_SLOT-12'까지, 'RACK-02_SLOT-01'부터 'RACK-02_SLOT-12'까지. (총 24개)

barcode_data: 스캔된 바코드 데이터

led_pin_address: 각 LED의 GPIO 핀 주소

full_rack_light_status: 랙 전체 조명 상태 (ON, OFF)

2. 핵심 컴포넌트 및 솔루션 상세 (간소화)
2.1. 플랫폼 및 서버 구성
기존과 동일하게 MES와 MSSQL 2014를 핵심 플랫폼으로 사용합니다.

MES: 바코드 스캔 이벤트를 수신하고, MSSQL 2014에서 정보를 조회하여 메인 컨트롤러에 명령을 내리는 역할을 담당합니다.

MSSQL 2014: 바코드와 슬롯 정보, LED 핀 주소 매핑을 저장하는 데이터베이스입니다.

2.2. 통신 방식
MES와 메인 컨트롤러 간의 통신은 REST API 또는 MQTT를 사용합니다. 메인 컨트롤러와 LED 간의 통신은 직접적인 GPIO 제어를 사용합니다.

MES <-> 메인 컨트롤러: REST API

메인 컨트롤러에 REST API 서버를 구축하여 MES가 HTTP POST 요청을 통해 LED 제어 명령을 전달합니다.

메인 컨트롤러 <-> LED: GPIO (General Purpose Input/Output) 제어

메인 컨트롤러의 GPIO 핀을 각 LED에 직접 연결하여 제어합니다. 총 24개의 LED를 제어하기 때문에, GPIO 핀 수가 충분한 컨트롤러를 사용하면 됩니다.

2.3. 모듈 및 하드웨어 구성
메인 컨트롤러: ESP32 DevKitC 또는 Raspberry Pi Pico W

ESP32: Wi-Fi 통신을 지원하며 GPIO 핀이 풍부하여 24개 LED 제어에 충분합니다. REST API 서버를 구축하기에 적합합니다.

Raspberry Pi Pico W: 더 저렴하고 작지만, Wi-Fi를 지원하여 REST API 클라이언트/서버 역할을 수행할 수 있습니다. 24개 LED 제어에 필요한 GPIO 핀을 충분히 제공합니다.

선택 가이드:

ESP32: Wi-Fi 모듈이 내장되어 MES와 무선 통신이 편리하고, GPIO 핀이 많아 전체 시스템을 한 보드로 통합하기 좋습니다.

LED 모듈: **Shift Register (74HC595)**와 고휘도 LED

Shift Register (74HC595): 8비트 시프트 레지스터를 사용하여 적은 수의 GPIO 핀으로 많은 수의 LED를 제어할 수 있습니다. 예를 들어, 3개의 GPIO 핀으로 8개의 74HC595를 데이지 체인 방식으로 연결하면 총 64개의 LED를 제어할 수 있어 24개는 충분합니다.

고휘도 LED: 80cm 간격에서도 시각적으로 잘 보이도록 고휘도 LED를 사용합니다. 각 LED에는 전류 제한 저항을 필수로 연결해야 합니다.

랙 전체 조명: 각 랙 상단에 고휘도 LED 스트립을 추가로 설치하고, 이 역시 메인 컨트롤러의 GPIO 핀으로 제어합니다. Shift Register를 사용하여 제어하는 것이 핀 절약에 유리합니다.

3. MES에 대한 구체적인 요구사항 (간소화된 로직)
MES는 기존과 동일하게 MSSQL 2014에서 barcode_data를 조회합니다. 그러나 메인 컨트롤러에 전달하는 명령은 더 단순해집니다.

3.1. MES API 엔드포인트 요구사항
MES는 메인 컨트롤러에 2가지 종류의 명령을 전달합니다.

단일 LED 활성화 API:

기능: 바코드에 해당하는 특정 슬롯의 LED를 켭니다.

메서드: POST /api/activate-led

요청 바디 (Request Body):

JSON

{
  "led_pin_address": 15,
  "led_status": "ON"
}
랙 전체 조명 활성화 API:

기능: 특정 랙 전체에 대한 조명을 켭니다.

메서드: POST /api/activate-rack-light

요청 바디 (Request Body):

JSON

{
  "rack_id": "RACK-01",
  "full_rack_light_status": "ON"
}
3.2. 전체 로직 흐름 (간소화된 MES 통합)
바코드 스캔: 작업자가 바코드를 스캔합니다.

MES-DB 로직:

MES는 barcode_data를 사용하여 MSSQL 2014에서 led_pin_address와 rack_id를 조회합니다.

MES-컨트롤러 통신:

Step A (개별 LED 점등): MES는 조회된 led_pin_address와 led_status: "ON"을 포함하여 메인 컨트롤러의 /api/activate-led 엔드포인트로 POST 요청을 보냅니다.

Step B (랙 전체 조명 점등): 동시에 MES는 조회된 rack_id와 full_rack_light_status: "ON"을 포함하여 메인 컨트롤러의 /api/activate-rack-light 엔드포인트로 POST 요청을 보냅니다.

컨트롤러-LED 동작:

메인 컨트롤러는 /api/activate-led 요청을 받으면 해당 led_pin_address에 연결된 GPIO 핀을 HIGH로 설정하여 특정 슬롯의 LED를 켭니다.

메인 컨트롤러는 /api/activate-rack-light 요청을 받으면 해당 rack_id에 연결된 LED 스트립 제어용 GPIO 핀을 HIGH로 설정하여 랙 전체 조명을 켭니다.

추가 로직: 일정 시간(예: 30초) 후에 모든 LED와 조명을 자동으로 끄는 타이머 기능을 컨트롤러 펌웨어에 구현합니다.

이 간소화된 솔루션은 최소한의 비용으로 구현이 용이하고, MES와의 통신 로직이 단순해져 전체 시스템의 안정성 또한 높아질 것입니다.

