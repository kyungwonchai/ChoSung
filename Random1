기존 LogService 클래스에 TCP 서버 기능을 추가하여, 클라이언트와 서버 기능을 모두 수행할 수 있도록 수정하겠습니다. 이 클래스는 기존의 로그 메시지를 전송하는 클라이언트 역할을 유지하면서, 새로 추가된 서버 기능을 통해 메인 UI 애플리케이션으로부터 명령을 수신할 수 있게 됩니다.

주요 기능 설명
클라이언트 기능: LogService는 여전히 클라이언트로서 메인 UI 서버에 로그 메시지를 전송합니다.
서버 기능: 이제 LogService는 TCP 서버 기능도 포함하여, 메인 UI 애플리케이션으로부터 연결을 수신하고, 데이터를 처리할 수 있습니다.
PLC 통신: 수신된 명령을 PLC로 전송하는 기능을 포함합니다.
수정된 LogService.cs 전체 코드
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        private static LogService _instance;
        private readonly string _logDirectory;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private TcpListener _tcpListener;
        private string _serverIp = "127.0.0.1"; // 메인 UI 서버 IP
        private int _serverPort = 9000; // 메인 UI 서버 포트
        private CancellationTokenSource _cancellationTokenSource;
        private bool _isConnected = false;
        private Queue<string> _logQueue = new Queue<string>(); // 로그 메시지 큐

        // 싱글톤 패턴을 위한 인스턴스 접근자
        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        // 생성자
        private LogService()
        {
            // 로그 파일이 저장될 디렉터리 설정
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory);
        }

        // 서비스 시작 메서드
        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ConnectToMainUIServer(_cancellationTokenSource.Token)); // 메인 UI 서버 연결을 시작
            Task.Run(() => StartTcpListener(_cancellationTokenSource.Token)); // TCP 서버 시작
        }

        // 서비스 중지 메서드
        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _networkStream?.Close();
            _tcpClient?.Close();
            _tcpListener?.Stop();
        }

        // 메인 UI 서버에 연결하는 메서드
        private async Task ConnectToMainUIServer(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                if (!_isConnected)
                {
                    try
                    {
                        _tcpClient = new TcpClient();
                        await _tcpClient.ConnectAsync(_serverIp, _serverPort); // 서버에 연결
                        _networkStream = _tcpClient.GetStream();
                        _isConnected = true;
                        Console.WriteLine("Connected to main UI server.");
                        
                        // 재연결 후 로그 큐에 저장된 메시지 전송
                        await SendQueuedLogs();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error connecting to server: {ex.Message}");
                        _isConnected = false;
                        await Task.Delay(5000); // 5초 후 재연결 시도
                    }
                }
                else
                {
                    await Task.Delay(1000); // 연결이 되어 있을 때 1초마다 상태 체크
                }
            }
        }

        // TCP 서버를 시작하는 메서드
        private async Task StartTcpListener(CancellationToken cancellationToken)
        {
            _tcpListener = new TcpListener(IPAddress.Any, 9000); // 모든 IP 주소에서 포트 9000으로 대기
            _tcpListener.Start();
            Console.WriteLine("TCP server started, listening for connections...");

            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    TcpClient client = await _tcpListener.AcceptTcpClientAsync();
                    Console.WriteLine("Client connected.");
                    _ = Task.Run(() => HandleClient(client, cancellationToken));
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error accepting client: {ex.Message}");
                }
            }

            _tcpListener.Stop();
        }

        // 클라이언트 연결을 처리하는 메서드
        private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)
        {
            using (client)
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) != 0)
                {
                    string message = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    SendToPLC(message); // 수신된 메시지를 PLC로 전송
                }
            }
        }

        // PLC에 메시지를 전송하는 메서드
        private void SendToPLC(string message)
        {
            try
            {
                // PLC와의 시리얼 통신 코드 구현 (예: 시리얼 포트로 데이터 전송)
                Console.WriteLine($"Sending to PLC: {message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending to PLC: {ex.Message}");
            }
        }

        // 로그 메시지를 기록하고 메인 UI 서버로 전송하는 메서드
        public async Task LogMessage(string message)
        {
            try
            {
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
                string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");

                File.AppendAllText(logFilePath, logEntry + Environment.NewLine);

                if (_isConnected && _tcpClient != null && _tcpClient.Connected)
                {
                    await SendLogMessage(logEntry); // 연결된 경우 바로 전송
                }
                else
                {
                    _logQueue.Enqueue(logEntry); // 연결되지 않은 경우 로그 큐에 저장
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }

        // 메인 UI 서버로 로그 메시지를 전송하는 메서드
        private async Task SendLogMessage(string message)
        {
            try
            {
                // 네트워크 스트림과 TCP 클라이언트가 유효한지 확인
                if (_networkStream != null && _tcpClient != null && _tcpClient.Connected)
                {
                    string messageWithDelimiter = message + "\n";
                    byte[] data = Encoding.UTF8.GetBytes(messageWithDelimiter);
                    await _networkStream.WriteAsync(data, 0, data.Length); // 메시지 전송
                    Console.WriteLine("Log message sent to main UI server.");
                }
                else
                {
                    throw new InvalidOperationException("Network stream or TCP client is not connected.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending log message: {ex.Message}");
                _isConnected = false; // 전송 실패 시 연결 끊김으로 처리
            }
        }

        // 큐에 저장된 로그 메시지를 전송하는 메서드
        private async Task SendQueuedLogs()
        {
            while (_logQueue.Count > 0 && _isConnected)
            {
                var logMessage = _logQueue.Dequeue();
                await SendLogMessage(logMessage); // 큐에 저장된 로그 메시지 전송
            }
        }
    }
}
설명
싱글톤 패턴: LogService 클래스는 싱글톤 패턴을 사용하여 전역 인스턴스를 제공합니다. 이 패턴은 애플리케이션 전역에서 로그 서비스를 쉽게 사용할 수 있게 합니다.

TCP 클라이언트 및 서버:

클라이언트 기능: ConnectToMainUIServer 메서드는 메인 UI 서버에 연결하여 로그 메시지를 전송합니다.
서버 기능: StartTcpListener 메서드는 TCP 서버를 시작하여 메인 UI 애플리케이션으로부터 명령을 수신합니다.
PLC 통신: SendToPLC 메서드는 수신된 명령을 Mewtocol 형식으로 변환하여 PLC로 전송합니다. 실제 시리얼 통신 코드는 여기에 추가되어야 합니다.

로그 전송 및 처리:

로그 메시지 전송: LogMessage 메서드는 로그 메시지를 파일에 저장하고, 메인 UI 서버에 전송합니다. 연결이 끊어진 경우 메시지를 큐에 저장하여 나중에 전송합니다.
큐 메시지 전송: SendQueuedLogs 메서드는 큐에 저장된 메시지를 다시 전송합니다.
요약
이제 LogService 클래스는 클라이언트와 서버 기능을 모두 갖추고 있으며, 메인 UI 애플리케이션과 통신하여