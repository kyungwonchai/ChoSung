using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>(); // 에러 리스트박스용 컬렉션
    public string CurrentTime { get; set; } // 현재 시간을 저장하는 속성
    public event PropertyChangedEventHandler PropertyChanged;

    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    private bool _isProcessing;
    private bool _isQueueStopped; // 큐가 멈춘 상태를 나타내는 플래그
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 3000; // 기본 재시도 간격 3초
    public int ResponseTimeout { get; set; } = 5000; // 응답 제한 시간 5초 (5000ms)
    public int MaximumQueueSize { get; set; } = 10; // 최대 큐 크기 10개

    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress)); // Progress 변경 시 UI 업데이트
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 처리 중 상태 플래그 초기화
        _isQueueStopped = false; // 큐 멈춤 상태 초기화
        Progress = 0; // 초기값 0

        // 현재 시간을 실시간으로 업데이트
        DispatcherTimer timer = new DispatcherTimer();
        timer.Interval = TimeSpan.FromMilliseconds(100); // 0.1초마다 갱신
        timer.Tick += (s, e) => UpdateCurrentTime();
        timer.Start();
    }

    // 현재 시간을 업데이트하는 함수
    private void UpdateCurrentTime()
    {
        CurrentTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff");
        OnPropertyChanged(nameof(CurrentTime));
    }

    // 외부 클래스에서 큐에 작업을 추가하려고 할 때 사용하는 함수
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        // 큐가 멈춘 상태이거나 최대 큐 크기를 초과한 경우 작업을 추가하지 않음
        if (_isQueueStopped || commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm("Queue limit reached or stopped. No further commands can be added.");
            return;
        }

        // 정상적인 경우 작업 추가
        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    // 큐에 작업을 추가하고 처리하는 함수
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem 
        { 
            CommandText = commandText, 
            Status = "Pending", 
            MaxRetryLimit = RetryLimit, // 최대 재시도 횟수 설정
            RetryCount = 0, // 초기 재시도 횟수는 0
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 작업이 추가된 시간 기록
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(newCommand); // 작업을 리스트박스에 추가
        });

        // 큐에 작업 추가
        commandQueue.Enqueue(async () =>
        {
            if (_isQueueStopped)
            {
                newCommand.Status = "Stopped"; // 큐가 멈춘 상태일 경우 상태 업데이트
                return; // 큐가 멈춘 상태라면 추가 작업 실행 안 함
            }

            newCommand.Status = "Processing";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치

            _isProcessing = true;

            while (retryCount < RetryLimit) // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
            {
                try
                {
                    stopwatch.Restart(); // 응답 시간 측정 시작
                    string result = await taskFunc(); // 비동기 작업 실행
                    stopwatch.Stop(); // 응답 시간 측정 완료

                    int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산
                    newCommand.ResponseTime = responseTime; // 응답 시간 저장
                    newCommand.RetryCount = retryCount; // 재시도 횟수 업데이트

                    // 응답 시간이 초과되면 큐 처리를 멈추고 모든 작업을 중단
                    if (responseTime > ResponseTimeout)
                    {
                        newCommand.Status = "Timeout"; // 응답 시간 초과로 실패 처리
                        ShowAlarm("Timeout occurred. All tasks stopped.");
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Response Timeout");
                        StopQueueProcessing(newCommand); // 큐 처리 중단 및 에러 추가, 더 이상 큐에 추가하지 않음
                        return;
                    }

                    // 정상 응답일 경우 작업 완료 처리
                    if (responseValidator(result))
                    {
                        newCommand.Status = "Completed"; // 성공 처리
                        newCommand.Result = 1; // 성공 플래그
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        UpdateProgress(); // 작업 완료 시 Progress 업데이트
                        _isProcessing = false; // 작업 완료 후 처리 중 해제
                        return;
                    }
                    else
                    {
                        retryCount++;
                        newCommand.Status = "Retrying"; // 재시도 중임을 표시
                        ShowAlarm($"Retrying {retryCount}/{RetryLimit} due to incorrect response.");
                        
                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed"; // 실패 처리
                            newCommand.Result = 0; // 실패 플래그
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Failed after maximum retries. All tasks stopped.");
                            StopQueueProcessing(newCommand); // 실패 후 큐 처리 중단 및 추가 작업 차단
                            return;
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed"; // 실패 처리
                    newCommand.Result = 0; // 실패 플래그
                    stopwatch.Stop(); // 예외 시에도 응답 시간 측정 종료
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;

                    newCommand.ResponseTime = responseTime; // 예외 발생 시에도 응답 시간 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred. All tasks stopped.");
                    StopQueueProcessing(newCommand); // 예외 발생 시 큐 처리 중단 및 추가 작업 차단
                    return;
                }
            }

            UpdateProgress(); // 최종적으로 Progress 업데이트
            _isProcessing = false; // 모든 작업 종료 후 플래그 해제
        });

        // 큐에서 작업이 시작되지 않았으면 처리 시작
        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue(); // 큐에 있는 작업을 처리
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 큐에서 작업을 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0 && !_isQueueStopped) // 큐가 멈춘 상태면 중단
        {
            var command = commandQueue.Dequeue(); // 큐에서 작업을 꺼냄
            await command(); // 큐에 있는 작업 실행
            UpdateProgress(); // 작업 진행에 따라 ProgressBar 업데이트
        }

        _isProcessing = false; // 모든 작업 완료 후 처리 중 상태 해제
    }

    // 큐 처리 중단 및 추가 작업 차단 함수
    private void StopQueueProcessing(CommandItem errorCommand)
    {
        _isQueueStopped = true; // 큐를 멈춤
        commandQueue.Clear(); // 큐를 완전히 비움
        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
            TrimErrorCommands(); // 에러 메시지가 50개를 넘으면 삭제
        });
        ShowAlarm("Queue has been stopped due to a Timeout or failure.");
    }

    // 알람을 에러 리스트박스에 추가하는 함수
    private void ShowAlarm(string message)
    {
        var errorCommand = new CommandItem
        {
            CommandText = message,
            Status = "Error",
            Result = 0, // 에러 상태로 처리
            RetryCount = 0, // 에러 메시지이므로 재시도 없음
            ResponseTime = 0, // 응답 시간 없음
            CommandTime = DateTime.Now.ToString("yyMMdd HH:mm:ss.fff") // 에러가 발생한 시간 기록
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
            TrimErrorCommands(); // 에러 메시지가 50개를 넘으면 삭제
        });
    }

    // 에러 리스트박스에서 최근 50개의 에러만 유지
    private void TrimErrorCommands()
    {
        while (ErrorCommands.Count > 50)
        {
            ErrorCommands.RemoveAt(0); // 오래된 에러 메시지 삭제
        }
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 남은 명령의 수에 따라 Progress 값 업데이트
    }

    // INotifyPropertyChanged 인터페이스 구현
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
