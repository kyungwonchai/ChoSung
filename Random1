 정확히 이해하신 대로 세마포어는 자원에 대한 접근을 제한하여 특정 시점에서만 작업이 큐에 추가될 수 있도록 합니다. 여기서 세마포어의 핵심 개념은 "동시에 접근 가능한 자원의 개수를 제한하여 대기 중인 작업을 조절" 하는 것입니다.

이 개념을 CommandQueue와 AddAsyncTaskCommand 함수에 적용할 때의 상세한 흐름을 설명드리겠습니다.

시나리오: CommandQueue와 COM 포트 상태를 관리하는 예제
예를 들어, CommandQueue에 명령을 추가하는 AddAsyncTaskCommand 함수가 있다고 가정해보겠습니다. CommandQueue는 기본적으로 FIFO(First-In-First-Out) 방식으로 큐에 쌓인 작업을 순서대로 처리합니다. 그러나, COM 포트가 재시도 상태일 때는 새로운 명령을 큐에 넣으면 안 되는 상황이 발생할 수 있습니다. 이때, 세마포어를 사용하여 COM 포트가 재시도를 완료한 후에만 새로운 명령을 큐에 추가할 수 있게 조절하는 것이 가능합니다.

세마포어 사용 이유
동시 접근 제한: COM 포트가 재시도 중일 때는 CommandQueue에 명령을 추가하지 못하도록 제어해야 합니다.
대기 상태 관리: 세마포어를 사용하면 AddAsyncTaskCommand 함수가 COM 포트가 열릴 때까지 기다렸다가 큐에 추가할 수 있도록 대기 상태를 유지할 수 있습니다.
순서 보장: CommandQueue 자체는 FIFO이기 때문에 명령 실행의 순서가 자동으로 보장되지만, 세마포어는 AddAsyncTaskCommand가 새로운 명령을 큐에 넣을 수 있는 시점을 조절하는 역할을 합니다.
세마포어 적용 방식
세마포어를 적용하기 위해서는 다음 단계로 진행합니다.

세마포어 생성: COM 포트가 재시도 중인 상태에서는 AddAsyncTaskCommand에서 대기하도록 SemaphoreSlim을 생성합니다.
COM 포트 상태 관리: COM 포트의 재시도 상태를 관리하는 플래그(IsRetrying 등)를 통해 COM 포트가 사용 가능한 상태인지 확인합니다.
대기 및 해제: WaitAsync() 메서드를 통해 명령을 큐에 넣기 전 COM 포트가 정상 상태인지 확인하고, Release()를 통해 COM 포트가 정상 상태로 돌아왔을 때 대기를 해제하여 명령을 큐에 추가할 수 있도록 합니다.
세마포어를 적용한 코드 예제
csharp
코드 복사
public class ComPortManager
{
    public bool IsRetrying { get; private set; } = false; // COM 포트 재시도 상태
    public event Action ReconnectCompleted; // 재연결 완료 시 이벤트 발생

    public async Task<bool> CloseAndReopenComPortWithRetryAsync()
    {
        IsRetrying = true; // 재시도 상태 설정
        bool closeSuccess = await PerformOperationWithTimeoutAsync(() =>
        {
            LogT5("COM 포트 닫는 중...");
            comPort.Close();
            LogT5("COM 포트 닫힘 성공.");
        }, "COM 포트 닫기 실패");

        if (!closeSuccess)
        {
            IsRetrying = false;
            ReconnectCompleted?.Invoke(); // 재시도 종료, 대기 해제
            return false;
        }

        for (int i = 0; i < MaxOpenAttempts; i++)
        {
            try
            {
                LogT5($"COM 포트 열기 시도 중... (시도 횟수: {i + 1})");
                comPort.Open();
                LogT5("COM 포트 열림 성공.");
                IsRetrying = false; // 재시도 상태 해제
                ReconnectCompleted?.Invoke(); // 대기 중인 작업 해제
                return true;
            }
            catch (Exception ex)
            {
                LogT5($"COM 포트 열기 실패: {ex.Message} (시도 횟수: {i + 1})");
                await Task.Delay(OpenAttemptDelay); // 재시도 대기
            }
        }

        IsRetrying = false;
        ReconnectCompleted?.Invoke(); // 재시도 종료, 대기 해제
        LogT5("COM 포트 열기 시도 500,000번 초과, 포트 열기 실패.");
        return false;
    }

    private async Task<bool> PerformOperationWithTimeoutAsync(Action operation, string errorMessage)
    {
        try
        {
            var task = Task.Run(operation);
            if (await Task.WhenAny(task, Task.Delay(ComPortOperationTimeout)) == task)
            {
                return true;
            }
            else
            {
                LogT5($"{errorMessage} (타임아웃 {ComPortOperationTimeout}ms 초과)");
                return false;
            }
        }
        catch (Exception ex)
        {
            LogT5($"{errorMessage}: {ex.Message}");
            return false;
        }
    }

    private void LogT5(string message)
    {
        msgvs.Instance.LogT5($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
    }
}



