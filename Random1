이블의 기본 키를 ipname, InspectionTime, ModelName의 조합으로 설정하도록 수정하겠습니다. 이를 반영하여 SQL 테이블 정의와 C# 코드의 INSERT 문을 수정하겠습니다.

테이블 수정
새 테이블 정의
sql
코드 복사
CREATE TABLE YourTable (
    ipname NVARCHAR(50) NOT NULL, -- IP 주소
    InspectionTime DATETIME NOT NULL, -- 검사 시간
    ModelName NVARCHAR(100) NOT NULL, -- 모델 이름
    AlignResult NVARCHAR(100), -- 정렬 결과
    MP1DATA FLOAT, -- MP1 데이터
    MP1RESULT NVARCHAR(100), -- MP1 결과
    MP2DATA FLOAT, -- MP2 데이터
    MP2RESULT NVARCHAR(100), -- MP2 결과
    MP3DATA FLOAT, -- MP3 데이터
    MP3RESULT NVARCHAR(100), -- MP3 결과
    MP4DATA FLOAT, -- MP4 데이터
    MP4RESULT NVARCHAR(100), -- MP4 결과
    MP5DATA FLOAT, -- MP5 데이터
    MP5RESULT NVARCHAR(100), -- MP5 결과
    PRIMARY KEY (ipname, InspectionTime, ModelName) -- 복합 키 설정
);
기존 테이블 수정 (필요 시)
기존 테이블에서 복합 키를 설정하려면 다음 명령을 실행합니다:

sql
코드 복사
ALTER TABLE YourTable DROP CONSTRAINT PK_YourTable; -- 기존 기본 키 제거
ALTER TABLE YourTable ADD PRIMARY KEY (ipname, InspectionTime, ModelName); -- 복합 키 설정
C# 코드 수정
INSERT 문 수정
ipname, InspectionTime, ModelName을 기준으로 데이터의 존재 여부를 확인하도록 수정합니다.

csharp
코드 복사
using (var command = new SqlCommand(
    @"IF NOT EXISTS (SELECT 1 FROM YourTable WHERE ipname = @ipname AND InspectionTime = @InspectionTime AND ModelName = @ModelName)
      INSERT INTO YourTable (ipname, InspectionTime, ModelName, AlignResult, MP1DATA, MP1RESULT, MP2DATA, MP2RESULT, MP3DATA, MP3RESULT, MP4DATA, MP4RESULT, MP5DATA, MP5RESULT)
      VALUES (@ipname, @InspectionTime, @ModelName, @AlignResult, @MP1DATA, @MP1RESULT, @MP2DATA, @MP2RESULT, @MP3DATA, @MP3RESULT, @MP4DATA, @MP4RESULT, @MP5DATA, @MP5RESULT)", connection))
{
    command.Parameters.AddWithValue("@ipname", row["ipname"]);
    command.Parameters.AddWithValue("@InspectionTime", row["InspectionTime"]);
    command.Parameters.AddWithValue("@ModelName", row["ModelName"]);
    command.Parameters.AddWithValue("@AlignResult", row["AlignResult"]);
    command.Parameters.AddWithValue("@MP1DATA", row["MP1DATA"]);
    command.Parameters.AddWithValue("@MP1RESULT", row["MP1RESULT"]);
    command.Parameters.AddWithValue("@MP2DATA", row["MP2DATA"]);
    command.Parameters.AddWithValue("@MP2RESULT", row["MP2RESULT"]);
    command.Parameters.AddWithValue("@MP3DATA", row["MP3DATA"]);
    command.Parameters.AddWithValue("@MP3RESULT", row["MP3RESULT"]);
    command.Parameters.AddWithValue("@MP4DATA", row["MP4DATA"]);
    command.Parameters.AddWithValue("@MP4RESULT", row["MP4RESULT"]);
    command.Parameters.AddWithValue("@MP5DATA", row["MP5DATA"]);
    command.Parameters.AddWithValue("@MP5RESULT", row["MP5RESULT"]);

    await command.ExecuteNonQueryAsync();
}
GetNewRows 함수 (그대로 유지)
예시 데이터
입력된 ipname과 각 행의 InspectionTime, ModelName을 기준으로 처리됩니다.

plaintext
코드 복사
IP: 192.168.1.1
Row: 20250110 10:00:00, ModelA, Good, 123.45, Result1, 67.89, Result2, 45.67, Result3, 89.01, Result4, 12.34, Result5
결과
복합 키 설정:

ipname, InspectionTime, ModelName이 결합된 고유 키.
데이터 중복 삽입 방지.
SQL 조건 수정:

ipname, InspectionTime, ModelName의 조합으로 데이터 존재 여부 확인.
C# 코드 업데이트:

ipname을 포함하여 INSERT 및 WHERE 조건 수정.
위 수정으로 요구 사항에 맞는 복합 키를 설정하고, 데이터 처리 로직을 완성할 수 있습니다.






나의 말:
컬쳐인포로하지말고 현식을 yyyy-MM-dd HH:mm:ss로 해주면되
ChatGPT의 말:
ChatGPT
요구하신 형식(yyyy-MM-dd HH:mm:ss)으로 DateTime 값을 처리하도록 수정하겠습니다. 다음은 GetNewRows 함수의 수정된 코드입니다.

수정된 GetNewRows 함수
csharp
코드 복사
public List<Dictionary<string, object>> GetNewRows(string rootPath)
{
    var newRows = new List<Dictionary<string, object>>();
    var csvFiles = Directory.GetFiles(rootPath, "*.csv", SearchOption.AllDirectories);

    foreach (var file in csvFiles)
    {
        using (var reader = new StreamReader(new FileStream(file, FileMode.Open, FileAccess.Read, FileShare.ReadWrite)))
        {
            reader.ReadLine(); // 첫 번째 행(헤더) 무시
            while (!reader.EndOfStream)
            {
                var values = reader.ReadLine()?.Split(',');
                if (values == null || values.Length < 12) // MP5DATA와 MP5RESULT 포함 최소 12개 컬럼 확인
                {
                    Debug.WriteLine("Skipped Row: Insufficient columns.");
                    continue;
                }

                // 디버그 출력: 현재 처리 중인 행의 값을 출력
                Debug.WriteLine($"Processing Row: {string.Join(", ", values)}");

                // InspectionTime 문자열을 지정된 형식으로 파싱
                if (!DateTime.TryParseExact(values[0], "yyyy-MM-dd HH:mm:ss", null, System.Globalization.DateTimeStyles.None, out var inspectionTime))
                {
                    Debug.WriteLine("Skipped Row: InspectionTime is not in the valid format (yyyy-MM-dd HH:mm:ss).");
                    continue;
                }

                // 4열이 숫자(정수 또는 실수)가 아니면 제외
                if (!decimal.TryParse(values[3], out _))
                {
                    Debug.WriteLine("Skipped Row: 4th column is not a valid number.");
                    continue;
                }

                var row = new Dictionary<string, object>
                {
                    ["InspectionTime"] = inspectionTime, // 파싱된 DateTime 값 사용
                    ["ModelName"] = values[1],
                    ["AlignResult"] = values[2],
                    ["MP1DATA"] = float.Parse(values[3]),
                    ["MP1RESULT"] = values[4],
                    ["MP2DATA"] = float.Parse(values[5]),
                    ["MP2RESULT"] = values[6],
                    ["MP3DATA"] = float.Parse(values[7]),
                    ["MP3RESULT"] = values[8],
                    ["MP4DATA"] = float.Parse(values[9]),
                    ["MP4RESULT"] = values[10],
                    ["MP5DATA"] = float.Parse(values[11]),
                    ["MP5RESULT"] = values[12],
                    ["ipname"] = _ipAddress // 현재 IP 추가
                };

                // InspectionTime 조건 검사
                if (inspectionTime > _lastUploadedTime)
                {
                    Debug.WriteLine("Added Row: Passed all checks.");
                    newRows.Add(row);
                }
                else
                {
                    Debug.WriteLine("Skipped Row: InspectionTime is not newer than the last uploaded time.");
                }
            }
        }
    }

    return newRows;
}
수정된 부분 설명
DateTime.TryParseExact 사용:

형식: "yyyy-MM-dd HH:mm:ss"
지정된 형식 외의 문자열은 파싱 실패로 간주하고 해당 행을 스킵합니다.
디버그 출력:

행의 데이터를 출력: Processing Row: ...
InspectionTime 형식 오류: "Skipped Row: InspectionTime is not in the valid format (yyyy-MM-dd HH:mm:ss)."
모든 조건을 통과한 경우: "Added Row: Passed all checks."
컬럼 개수 검증:

최소 12개의 컬럼(MP5DATA, MP5RESULT 포함)을 요구.
디버깅 로그 예시
CSV 데이터
plaintext
코드 복사
2025-01-10 10:00:00,ModelA,Good,123.45,Result1,67.89,Result2,45.67,Result3,89.01,Result4,12.34,Result5
2025-01-09 09:00:00,ModelB,Good,N/A,Result1,67.89,Result2,45.67,Result3,89.01,Result4,12.34,Result5
2025-01-10 10:00:00,ModelC,Good,abc,Result1,67.89,Result2,45.67,Result3,89.01,Result4,12.34,Result5
InvalidDate,ModelD,Good,123.45,Result1,67.89,Result2,45.67,Result3,89.01,Result4,12.34,Result5
디버깅 출력
plaintext
코드 복사
Processing Row: 2025-01-10 10:00:00, ModelA, Good, 123.45, Result1, 67.89, Result2, 45.67, Result3, 89.01, Result4, 12.34, Result5
Added Row: Passed all checks.
Processing Row: 2025-01-09 09:00:00, ModelB, Good, N/A, Result1, 67.89, Result2, 45.67, Result3, 89.01, Result4, 12.34, Result5
Skipped Row: 4th column is not a valid number.
Processing Row: 2025-01-10 10:00:00, ModelC, Good, abc, Result1, 67.89, Result2, 45.67, Result3, 89.01, Result4, 12.34, Result5
Skipped Row: 4th column is not a valid number.
Processing Row: InvalidDate, ModelD, Good, 123.45, Result1, 67.89, Result2, 45.67, Result3, 89.01, Result4, 12.34, Result5
Skipped Row: InspectionTime is not in the valid format (yyyy-MM-dd HH:mm:ss).
결과
InspectionTime 형식 변경:

형식: "yyyy-MM-dd HH:mm:ss"
이외의 형식은 파싱 실패.
디버깅 정보 추가:

데이터 파싱 및 조건 체크 과정 확인.
컬럼 개수 검증 강화:
