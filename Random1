죄송합니다. 요구사항에 맞춰 XAML 코드와 리스트박스를 추가하여 에러를 표시하는 방식으로 전체적인 코드 수정을 제공하겠습니다.

요구사항:
에러용 리스트박스를 XAML에 추가하여 응답 실패나 시간 초과에 따른 에러를 표시.
작업 실패 및 큐 처리 중단 시, 에러 리스트박스에 에러 메시지를 추가.
XAML 및 전체 코드가 요구사항에 맞게 완전하게 수정된 상태로 제공.
수정된 XAML
xml
코드 복사
<Window x:Class="CommandQueueApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Command Queue" Height="450" Width="800">
    <Grid>
        <!-- 남아 있는 명령을 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding RemainingCommands}" HorizontalAlignment="Left" Height="200" VerticalAlignment="Top" Width="350">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="{Binding CommandText}" Width="100"/>
                        <TextBlock Text=" 상태: " Width="50"/>
                        <TextBlock Text="{Binding Status}" Width="100"/>
                        <TextBlock Text=" 재시도: " Width="70"/>
                        <TextBlock Text="{Binding RetryCount}" Width="30"/>
                        <TextBlock Text=" 응답 시간: " Width="100"/>
                        <TextBlock Text="{Binding ResponseTime}" Width="70"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 에러를 표시하는 리스트박스 -->
        <ListBox ItemsSource="{Binding ErrorCommands}" HorizontalAlignment="Left" Height="200" VerticalAlignment="Bottom" Width="350">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal">
                        <TextBlock Text="에러: " Width="50"/>
                        <TextBlock Text="{Binding CommandText}" Width="100"/>
                        <TextBlock Text=" 상태: " Width="50"/>
                        <TextBlock Text="{Binding Status}" Width="100"/>
                        <TextBlock Text=" 재시도: " Width="70"/>
                        <TextBlock Text="{Binding RetryCount}" Width="30"/>
                        <TextBlock Text=" 응답 시간: " Width="100"/>
                        <TextBlock Text="{Binding ResponseTime}" Width="70"/>
                    </StackPanel>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>

        <!-- 세로형 프로그레스바 (큐에 남아 있는 명령 수 시각적으로 표시) -->
        <ProgressBar VerticalAlignment="Top" Height="200" Width="30" Orientation="Vertical" 
                     Value="{Binding Progress}" Maximum="{Binding MaximumQueueSize}" HorizontalAlignment="Right" Margin="0,0,50,0"/>
    </Grid>
</Window>
수정된 C# 코드
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;
using System.Diagnostics;
using System.Windows.Threading;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    // 큐에 있는 명령 리스트 (남은 작업을 표시)
    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    
    // UI에 표시할 명령 리스트 (ListBox에 바인딩)
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();

    // 에러 리스트박스용 컬렉션
    public ObservableCollection<CommandItem> ErrorCommands { get; set; } = new ObservableCollection<CommandItem>();

    public event PropertyChangedEventHandler PropertyChanged;

    private bool _isProcessing; 
    private readonly DatabaseHelper _dbHelper;

    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 2000; // 기본 재시도 간격 2초 (2000ms)
    public int ResponseTimeout { get; set; } = 3000; // 응답 제한 시간 3초 (3000ms)
    public int MaximumQueueSize { get; set; } = 10; // 최대 큐 크기 10개

    // ProgressBar 바인딩을 위한 속성
    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress)); // Progress 변경 시 UI 업데이트
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 처리 중 상태 플래그 초기화
        Progress = 0; // 초기값 0
    }

    // 새로운 작업 추가 시 큐가 가득 차 있으면 추가하지 않고 에러 처리
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        if (commandQueue.Count >= MaximumQueueSize)
        {
            ShowAlarm($"Queue limit reached: {MaximumQueueSize} items. New command canceled. Stack Overflow!");
            AddStackOverflowError(); // 스택 오버플로우 에러 추가
            return;
        }

        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    // 스택 오버플로우 에러 처리
    private void AddStackOverflowError()
    {
        var errorCommand = new CommandItem
        {
            CommandText = "Stack Overflow Error",
            Status = "Failed",
            Result = 0,
            RetryCount = 0,
            ResponseTime = 0,
            MaxRetryLimit = 0
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
        });
    }

    // 큐에 작업을 추가하고 처리하는 함수
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem 
        { 
            CommandText = commandText, 
            Status = "Pending", 
            MaxRetryLimit = RetryLimit, // 최대 재시도 횟수 설정
            RetryCount = 0 // 초기 재시도 횟수는 0
        };

        App.Current.Dispatcher.Invoke(() =>
        {
            RemainingCommands.Add(newCommand); // 작업을 리스트박스에 추가
        });

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치

            _isProcessing = true;

            while (retryCount < RetryLimit) // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
            {
                try
                {
                    stopwatch.Restart(); // 응답 시간 측정 시작
                    string result = await taskFunc(); // 비동기 작업 실행
                    stopwatch.Stop(); // 응답 시간 측정 완료

                    int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산
                    newCommand.ResponseTime = responseTime; // 응답 시간 저장
                    newCommand.RetryCount = retryCount; // 재시도 횟수 업데이트

                    if (responseTime > ResponseTimeout)
                    {
                        newCommand.Status = "Timeout"; // 응답 시간 초과로 실패 처리
                        ShowAlarm($"Warning: Response took longer than {ResponseTimeout / 1000} seconds. Timeout.");
                        newCommand.Result = 0;
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, "Timeout", "Failed", newCommand.Result, retryCount, responseTime, "Response Timeout");
                        StopProcessingWithError(newCommand); // 큐 처리 중단 및 에러 추가
                        return new CommandResult { Success = false, Message = "Response Timeout" };
                    }

                    if (responseValidator(result)) // 정상 응답 검증
                    {
                        newCommand.Status = "Completed"; // 성공 처리
                        newCommand.Result = 1; // 성공 플래그
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        UpdateProgress(); // 작업 완료 시 Progress 업데이트
                        _isProcessing = false; // 작업 완료 후 처리 중 해제
                        return new CommandResult { Success = true, Message = result };
                    }
                    else
                    {
                        retryCount++;
                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed"; // 실패 처리
                            newCommand.Result = 0; // 실패 플래그
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Failed after maximum retries: " + result);
                            StopProcessingWithError(newCommand); // 큐 처리 중단 및 에러 추가
                            return new CommandResult { Success = false, Message = result };
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed"; // 실패 처리
                    newCommand.Result = 0; // 실패 플래그
                    stopwatch.Stop(); // 예외 시에도 응답 시간 측정 종료
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;

                    newCommand.ResponseTime = responseTime; // 예외 발생 시에도 응답 시간 기록
                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred: " + ex.Message); // 오류 알람
                    StopProcessingWithError(newCommand); // 큐 처리 중단 및 에러 추가
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }

            UpdateProgress(); // 최종적으로 Progress 업데이트
            _isProcessing = false; // 모든 작업 종료 후 플래그 해제
            return new CommandResult { Success = false };
        });

        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 큐 처리 중단 및 에러 추가 함수
    private void StopProcessingWithError(CommandItem errorCommand)
    {
        commandQueue.Clear(); // 큐를 비우고 작업 중단
        _isProcessing = false; // 처리 중 상태 해제

        App.Current.Dispatcher.Invoke(() =>
        {
            ErrorCommands.Add(errorCommand); // 에러 리스트박스에 추가
        });

        ShowAlarm("Processing stopped due to error.");
    }

    // 알람 표시
    private void ShowAlarm(string message)
    {
        Console.WriteLine("ALARM: " + message); // 콘솔에 알람 출력 (UI에서 알람 처리 필요)
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 남은 명령의 수에 따라 Progress 값 업데이트
    }

    // INotifyPropertyChanged 인터페이스 구현
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
코드 설명:
XAML 수정:

두 개의 ListBox가 있습니다:
RemainingCommands는 처리 중이거나 남은 명령을 표시하는 리스트박스.
ErrorCommands는 에러가 발생한 명령을 표시하는 에러용 리스트박스.
C# 코드 수정:

ErrorCommands 컬렉션을 추가해 에러가 발생하면 해당 리스트박스에 표시.
StopProcessingWithError 함수는 시간 초과나 응답 실패 시 큐를 중단하고 에러 리스트박스에 에러를 추가.
AddAsyncTaskCommand에서 큐가 10개 이상이면 새로운 작업을 받지 않고, 스택 오버플로우 에러를 표시하도록 추가.
이 구조를 통해 큐가 10개 이상 쌓이지 않고, 응답 시간 초과나 재시도 실패 시 에러 리스트박스에 정확하게 에러가 표시됩니다.