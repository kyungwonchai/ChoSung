 맞습니다. await Clients.Others.SendAsync("ReceiveEditStatus1", ...)

ASP.NET 쪽에서 이렇게 SignalR 메서드를 호출하면, WPF 클라이언트 측에서는 "ReceiveEditStatus1" 이벤트를 구독(subscribe)해야 합니다. 이를 구현하는 코드 예시는 다음과 같습니다:

csharp

// WPF Client Side
using Microsoft.AspNet.SignalR.Client;

HubConnection hubConnection = new HubConnection("http://yourServerAddress");
IHubProxy hubProxy = hubConnection.CreateHubProxy("YourHubName");

await hubConnection.Start();

hubProxy.On<string, string, string>("ReceiveEditStatus1", (key1, username, column) => 
{
    // 이 부분에서 key1, username, column 값을 처리합니다.
    // 예를 들어, 텍스트 박스에 값을 출력할 수 있습니다.
    // textBox1.Text = key1 + " " + username + " " + column;
});

여기서 ReceiveEditStatus1은 서버 쪽에서 Clients.Others.SendAsync로 호출한 이벤트 이름과 동일해야 하며, 그 뒤의 인자 타입과 개수도 서버에서 전송한 것과 일치해야 합니다.

이런 식으로 WPF 쪽에서 해당 이벤트를 받아 처리하면 됩니다.