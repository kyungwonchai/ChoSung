import pdb

def solution(picks, minerals):
    cnt = sum(picks)  # picks 배열의 합계를 구합니다. 이는 채굴할 광산의 개수를 의미합니다.
    mine = [[0]*5 for _ in range(cnt)]  # cnt 크기만큼의 5열짜리 2차원 배열을 생성합니다. 각 열은 광산에서 채굴 가능한 광물의 종류를 의미합니다.

    trans = {k:v for k,v in zip(["diamond","iron","stone"],[25,5,1])}  # 광물의 이름과 해당 광물을 채굴하는데 필요한 도구의 효율을 매핑합니다.

    minerals = [trans[i] for i in minerals[:5*cnt]]  # 주어진 minerals 리스트에서 각 광물 이름을 해당 효율 값으로 변환합니다.

    for i,v in enumerate(minerals):  # 변환된 minerals 리스트를 순회하면서 mine 배열에 광물의 효율 값을 배치합니다.
        N,i = divmod(i, 5)  # i를 5로 나눈 몫과 나머지를 구합니다. 몫은 행을, 나머지는 열을 의미합니다.
        mine[N][i] = v
    mine.sort(key=lambda x:-sum(x))  # mine 배열을 각 행의 합계를 기준으로 내림차순 정렬합니다. 광물의 총 효율이 높은 순으로 정렬됩니다.

    pdb.set_trace()  # 디버거를 실행하여 이 지점에서 코드 실행을 중단하고 변수를 검사할 수 있습니다.

    picks = [25]*picks[0] + [5]*picks[1] + [1]*picks[2]  # picks 배열에 따라 각 도구의 효율을 배열로 확장합니다.
    result = 0  # 최종 결과를 저장할 변수입니다.
    for p,m in zip(picks,mine):  # 확장된 도구 효율 배열과 정렬된 mine 배열을 순회하면서 결과를 계산합니다.
        result += sum([max(1,i//p) for i in m if i>0])  # 각 광물의 효율을 해당 도구로 나눈 값을 계산하고, 최소값은 1로 설정하여 결과에 더합니다.
    return result  # 계산된 결과를 반환합니다.
