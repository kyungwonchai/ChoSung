, machine1, lane1, tb를 기준으로 그룹화하고, 이 그룹 내에서 lotname이 변경될 때마다 새로운 서브그룹을 시작하며, 각 서브그룹 내에서 datetime1 기준 상위 20개 로우를 식별하여 xxx 컬럼을 업데이트하는 쿼리를 작성하겠습니다.

이를 위해, 먼저 line1, machine1, lane1, tb를 기준으로 그룹화하고, 이 그룹 내에서 lotname이 변경되는 지점을 식별하는 플래그를 생성합니다. 그런 다음, 이 플래그를 기반으로 누적 합계를 계산하여 서브그룹 ID를 생성하고, 이 ID를 기준으로 각 서브그룹 내에서 datetime1 기준 상위 20개 로우를 식별합니다.

다음은 수정된 쿼리입니다:

sql
Copy code
WITH LotChanges AS (
    SELECT *,
           CASE 
               WHEN LAG(lotname) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1) = lotname THEN 0 
               ELSE 1 
           END AS IsNewLot
    FROM LOG_MEV_Backup
),
LotGroups AS (
    SELECT *,
           SUM(IsNewLot) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SubGroupID
    FROM LotChanges
),
RankedLots AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY line1, machine1, lane1, tb, SubGroupID ORDER BY datetime1) AS rn
    FROM LotGroups
)
UPDATE LOG_MEV_Backup
SET xxx = CASE 
            WHEN RankedLots.rn <= 20 THEN 1
            ELSE 0
          END
FROM LOG_MEV_Backup
INNER JOIN RankedLots
ON LOG_MEV_Backup.line1 = RankedLots.line1
   AND LOG_MEV_Backup.machine1 = RankedLots.machine1
   AND LOG_MEV_Backup.lane1 = RankedLots.lane1
   AND LOG_MEV_Backup.lotname = RankedLots.lotname
   AND LOG_MEV_Backup.tb = RankedLots.tb
   AND LOG_MEV_Backup.datetime1 = RankedLots.datetime1;
이 쿼리는 지정된 조건(line1, machine1, lane1, tb)에 따라 그룹화하고, 각 그룹 내에서 lotname이 변경될 때마다 새로운 서브그룹을 시작합니다. 그리고 각 서브그룹 내에서 datetime1을 기준으로 상위 20개 로우를 식별하여 xxx 컬럼을 업데이트합니다. 이 쿼리도 테스트 환경에서 먼저 실행하여 예