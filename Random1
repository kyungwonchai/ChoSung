 UI 스레드와 백그라운드 스레드 간의 상호작용 문제로 인해 발생합니다. UI 요소는 UI 스레드에서만 액세스할 수 있으므로, Dispatcher.Invoke를 사용하여 UI 스레드에서 작업을 수행해야 합니다. 예외 처리를 강화하고 로그를 남기는 방식을 유지하면서 이 문제를 해결해 보겠습니다.

다음은 수정된 코드입니다:

XAML 파일 (MainWindow.xaml):
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="File Copier" Height="350" Width="525">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
            <RowDefinition Height="Auto"/>
        </Grid.RowDefinitions>

        <StackPanel Orientation="Horizontal" Margin="10">
            <CheckBox x:Name="IndividualFolderCheckBox" Content="Individual Folders" Margin="5"/>
        </StackPanel>

        <ListBox x:Name="LogListBox" Grid.Row="1" Margin="10" MaxHeight="200"/>

        <Button x:Name="StartButton" Content="Start" Grid.Row="2" Click="StartButton_Click" Margin="10"/>
    </Grid>
</Window>
C# 코드 (MainWindow.xaml.cs):
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Diagnostics;
using System.IO;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace WpfApp
{
    public partial class MainWindow : Window
    {
        private ObservableCollection<string> _logMessages = new ObservableCollection<string>();
        private readonly string _sourceFilePath = @"C:\Agent\1.jpg";
        private readonly string _destinationRootPath = @"F:\ABC";
        private readonly string _logFilePath = @"F:\filelog.txt";
        private bool _isRunning = false;

        public MainWindow()
        {
            InitializeComponent();
            LogListBox.ItemsSource = _logMessages;
        }

        private void StartButton_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                if (_isRunning)
                {
                    MessageBox.Show("Process is already running.");
                    return;
                }

                _isRunning = true;
                AddLog("File copy process started.");
                Task.Run(() => CopyFilesAsync());
            }
            catch (Exception ex)
            {
                var errorMessage = $"Error starting process: {ex.Message}";
                AddLog(errorMessage);
                LogToFile(errorMessage);
                Debug.WriteLine(errorMessage);
            }
        }

        private async Task CopyFilesAsync()
        {
            try
            {
                while (_isRunning)
                {
                    var timestamp = DateTime.Now.ToString("yyyyMMddHHmmss");
                    var fileName = $"{timestamp}file.jpg";
                    var destinationPath = IndividualFolderCheckBox.IsChecked == true
                        ? System.IO.Path.Combine(_destinationRootPath, timestamp, fileName)
                        : System.IO.Path.Combine(_destinationRootPath, DateTime.Now.ToString("yyyyMMdd"), fileName);

                    try
                    {
                        var folderPath = System.IO.Path.GetDirectoryName(destinationPath);
                        if (!Directory.Exists(folderPath))
                        {
                            Directory.CreateDirectory(folderPath);
                        }

                        if (File.Exists(_sourceFilePath))
                        {
                            File.Copy(_sourceFilePath, destinationPath, true);
                            var logMessage = $"File copied to: {destinationPath}";
                            AddLog(logMessage);
                            LogToFile(logMessage);
                        }
                        else
                        {
                            var errorMessage = $"Source file not found: {_sourceFilePath}";
                            AddLog(errorMessage);
                            LogToFile(errorMessage);
                            _isRunning = false;
                        }

                        Dispatcher.Invoke(() =>
                        {
                            if (_logMessages.Count > 200)
                            {
                                _logMessages.RemoveAt(0);
                            }
                        });
                    }
                    catch (Exception ex)
                    {
                        var errorMessage = $"Error during file copy: {ex.Message}";
                        AddLog(errorMessage);
                        LogToFile(errorMessage);
                        Debug.WriteLine(errorMessage);
                        _isRunning = false;
                    }

                    await Task.Delay(2000); // 2초 대기
                }

                AddLog("File copy process stopped.");
            }
            catch (Exception ex)
            {
                var errorMessage = $"Error in file copy loop: {ex.Message}";
                AddLog(errorMessage);
                LogToFile(errorMessage);
                Debug.WriteLine(errorMessage);
            }
        }

        private void AddLog(string message)
        {
            try
            {
                Dispatcher.Invoke(() => _logMessages.Add($"{DateTime.Now:HH:mm:ss} - {message}"));
            }
            catch (Exception ex)
            {
                var errorMessage = $"Error updating UI: {ex.Message}";
                Debug.WriteLine(errorMessage);
                LogToFile(errorMessage);
            }
        }

        private void LogToFile(string message)
        {
            try
            {
                using (StreamWriter writer = new StreamWriter(_logFilePath, true))
                {
                    writer.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
                }
            }
            catch (Exception ex)
            {
                var errorMessage = $"Log file writing error: {ex.Message}";
                Debug.WriteLine(errorMessage);
                Dispatcher.Invoke(() => _logMessages.Add($"{DateTime.Now:HH:mm:ss} - {errorMessage}"));
            }
        }
    }
}
주요 변경 사항:
Dispatcher.Invoke 사용 위치 수정: UI 스레드에서만 접근해야 하는 부분을 Dispatcher.Invoke로 감싸서 안전하게 접근하도록 수정했습니다.
모든 예외 처리 강화: 모든 예외를 정확히 잡아내고, 로그에 남기도록 예외 처리를 강화했습니다.
AddLog와 LogToFile에서 발생하는 예외 처리: 로그를 추가하거나 파일에 기록하는 중 발생하는 예외도 처리하여, 이 과정에서 발생하는 문제를 잡아낼 수 있도록 했습니다.
이제 코드를 실행하면 파일 복사 작업이 제