uncStatusList를 넘기고, 그 안에 있는 함수 목록을 기존에는 단순히 Enqueue하는 방식이었다면, 이제는 각 함수에 대해 별도의 처리(에러 처리 및 재시도 로직 등)가 필요한 상황입니다.

이를 해결하기 위해서는 각 함수 단위로 작업을 관리하는 별도의 큐가 필요할 수 있습니다. 여기서는 함수 하나하나를 처리하는 로직을 개선하고, 실패 시 해당 함수를 다시 처리하거나 그룹 단위로 다시 처리할 수 있도록 구현하는 방법을 제안합니다.

해결 방안
개별 함수 처리 큐: 각 함수(Func<Task<CommandResult>>)를 별도로 처리할 수 있는 큐를 만들어야 합니다. 함수는 FuncStatusList로 넘겨지며, 함수가 실패할 경우 재시작할 수 있는 구조로 큐를 확장할 수 있습니다.

작업 큐 로직 변경: 단순히 Enqueue만 하는 것이 아니라, 각 함수에 대해 성공/실패 여부를 확인하고, 실패한 경우 해당 함수를 다시 큐에 추가하거나 해당 그룹의 모든 함수를 처음부터 처리하도록 해야 합니다.

에러 처리 및 재시도: 함수가 실패했을 때의 처리를 어떻게 할 것인지 정해야 합니다. 에러 발생 시 해당 함수를 다시 실행할지, 아니면 해당 그룹 전체를 처음부터 다시 실행할지를 선택할 수 있습니다.

Step-by-Step 구현 논리
1. FuncStatus 클래스 및 큐 정의
각 함수를 관리하는 FuncStatus 클래스가 있다고 가정합니다. FuncStatus 리스트를 넘길 때, 각 함수를 개별적으로 처리할 수 있는 큐가 필요합니다.

csharp
코드 복사
public class FuncStatus
{
    public string FunctionName { get; set; }
    public Func<Task<CommandResult>> TaskFunction { get; set; }
    public int RetryCount { get; set; } = 0; // 재시도 횟수
    public int MaxRetries { get; set; } = 3; // 최대 재시도 횟수
}
2. ViewModel에 작업 큐 처리 로직 추가
AssSyncTaskCommand를 처리하는 ViewModel에서 함수 목록을 처리할 큐를 정의하고, 각 함수를 처리하는 로직을 추가합니다.

csharp
코드 복사
public class CommandQueueViewModel : ViewModelBase
{
    private ConcurrentQueue<FuncStatus> funcQueue = new ConcurrentQueue<FuncStatus>();

    public async Task ProcessQueueAsync()
    {
        while (funcQueue.TryDequeue(out var funcStatus))
        {
            bool success = await ProcessFuncAsync(funcStatus);

            if (!success && funcStatus.RetryCount < funcStatus.MaxRetries)
            {
                // 실패했을 경우, 재시도 횟수가 남아있으면 다시 큐에 추가
                funcStatus.RetryCount++;
                funcQueue.Enqueue(funcStatus);
            }
            else if (!success)
            {
                // 실패하고 재시도 횟수를 초과했으면 로그를 남기거나 다른 처리
                LogFailure(funcStatus);
            }
        }
    }

    private async Task<bool> ProcessFuncAsync(FuncStatus funcStatus)
    {
        try
        {
            var result = await funcStatus.TaskFunction();
            return result.IsSuccess;
        }
        catch (Exception ex)
        {
            // 예외 처리
            LogError(ex);
            return false;
        }
    }

    // 작업 실패 시 처리할 로직 (로그 기록 등)
    private void LogFailure(FuncStatus funcStatus)
    {
        // 예시: 로그 메시지 출력
        Console.WriteLine($"Function {funcStatus.FunctionName} failed after {funcStatus.RetryCount} attempts.");
    }

    private void LogError(Exception ex)
    {
        // 예외 처리에 대한 로그 기록
        Console.WriteLine($"Error: {ex.Message}");
    }
}
3. AssSyncTaskCommand 호출
AssSyncTaskCommand에서 FuncStatusList를 넘길 때, 각 함수를 큐에 추가합니다. 예를 들어, FuncStatusList에 있는 모든 함수들을 큐에 넣고, 큐에서 하나씩 처리합니다.

csharp
코드 복사
public void AssSyncTaskCommand(List<FuncStatus> funcStatusList)
{
    foreach (var funcStatus in funcStatusList)
    {
        funcQueue.Enqueue(funcStatus); // 각 함수를 큐에 추가
    }

    // 비동기로 큐 처리 시작
    ProcessQueueAsync();
}
4. 에러 처리 및 재시작
작업이 실패했을 때:

개별 함수(FuncStatus)가 실패할 경우 재시도 횟수를 확인하여 다시 큐에 넣고 재시도합니다.
재시도 횟수를 초과한 경우, 별도로 로그를 남기거나 다른 처리를 할 수 있습니다.
요약
개별 함수 큐: 각 함수를 관리하는 FuncStatus 객체를 큐에 추가하여 개별적으로 처리할 수 있는 구조를 만듭니다.
에러 처리 및 재시도: 함수가 실패하면 재시도 횟수를 확인하여 다시 큐에 추가하고, 최대 재시도 횟수를 초과한 경우에는 로그를 남기거나 다른 처리를 합니다.