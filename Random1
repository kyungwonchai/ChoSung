✅ static 없이 타이머 실행 및 비동기 작업 관리
10분마다 실행되지만, 이전 작업이 끝나지 않으면 다음 실행을 건너뛰는 비동기 타이머 코드

🔹 C# static 없이 구현된 비동기 타이머
csharp
코드 복사
using System;
using System.Threading;
using System.Threading.Tasks;

class TimerRunner
{
    private Timer _timer;
    private bool _isRunning = false;
    private readonly object _lock = new object();

    public TimerRunner()
    {
        _timer = new Timer(async _ => await CheckAndRunTask(), null, 0, 600000); // 10분마다 실행
    }

    private async Task CheckAndRunTask()
    {
        lock (_lock)
        {
            if (_isRunning)
            {
                Console.WriteLine($"{DateTime.Now:HH:mm:ss} - 이전 실행이 끝나지 않음, 대기...");
                return;
            }
            _isRunning = true;
        }

        try
        {
            Console.WriteLine($"{DateTime.Now:HH:mm:ss} - 작업 시작");
            await RunTaskAsync();
            Console.WriteLine($"{DateTime.Now:HH:mm:ss} - 작업 완료");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"오류 발생: {ex.Message}");
        }
        finally
        {
            _isRunning = false; // 실행 완료 후 상태 변경
        }
    }

    private async Task RunTaskAsync()
    {
        // 실제 수행할 작업 (여기서는 20초간 대기)
        await Task.Delay(20000); // 20초 동안 실행되는 작업
    }
}

class Program
{
    static async Task Main()
    {
        Console.WriteLine("Timer 시작...");
        var runner = new TimerRunner();

        await Task.Delay(Timeout.Infinite); // 프로그램 유지
    }
}
✅ 코드 설명
TimerRunner 클래스:

_timer: 10분(600000ms)마다 CheckAndRunTask() 실행
_isRunning 변수: 이전 작업이 끝나지 않으면 실행하지 않도록 설정
lock (_lock): 다중 실행 방지
비동기 실행 (RunTaskAsync())

10분마다 실행되지만, 이전 실행이 끝나지 않았으면 건너뜀
현재 예제에서는 await Task.Delay(20000)(20초 실행)
Main()에서 TimerRunner 인스턴스를 생성하여 static 없이 관리

✅ 실행 결과
makefile
코드 복사
Timer 시작...
10:00:00 - 작업 시작
10:00:20 - 작업 완료
10:10:00 - 작업 시작
10:10:20 - 작업 완료
10:20:00 - 이전 실행이 끝나지 않음, 대기...
✔ 10분마다 실행되지만, 이전 실행이 끝나지 않으면 다음 실행을 건너뜀
✔ 비동기 방식으로 CPU 사용 최소화
✔ static 없이 객체 인스턴스로 관리