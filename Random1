네, 이해했습니다. 안드로이드 기기가 다른 PC의 네트워크 공유 폴더에 직접 접근해서 PDF 목록을 가져오고 파일을 여는 방식으로 기능을 변경하는군요.

이것은 로컬 저장소 접근과는 완전히 다른 방식입니다. PC의 공유 폴더는 보통 SMB/CIFS라는 네트워크 프로토콜을 사용합니다. 안드로이드의 기본 파일 API는 SMB를 지원하지 않으므로, 이 프로토콜 통신을 위한 별도의 라이브러리를 사용해야 합니다. 가장 널리 쓰이는 jcifs-ng 라이브러리를 사용해 구현해 보겠습니다.

⚠️ 중요: 네트워크 통신은 반드시 메인(UI) 스레드가 아닌 백그라운드 스레드에서 처리해야 합니다. 여기서는 코틀린 코루틴(Coroutine)을 사용하여 이 문제를 해결하겠습니다.

📝 1단계: 라이브러리 추가 (build.gradle.kts)
먼저 SMB 통신을 위한 jcifs-ng 라이브러리를 프로젝트에 추가합니다.

Kotlin

// build.gradle.kts (Module :app)

dependencies {
    // ... 기존 라이브러리들
    
    // SMB/CIFS 프로토콜 통신을 위한 라이브러리
    implementation("eu.agno3.jcifs:jcifs-ng:2.1.9")
}
설정 후 'Sync Now'를 클릭하여 라이브러리를 반영해주세요.

📝 2단계: 권한 및 네트워크 설정 (AndroidManifest.xml)
네트워크 통신을 위해 INTERNET 권한이 필요합니다. 또한, SMB는 암호화되지 않은(cleartext) 통신을 할 수 있으므로, 최신 안드로이드 버전에서 이를 허용하는 옵션을 추가해야 합니다.

XML

<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.sec.ReellistViewer">

    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.ACCESS_NETWORK_STATE" />
    
    <application
        ...
        android:usesCleartextTraffic="true" >
        ...
    </application>

</manifest>
android:usesCleartextTraffic="true": 이 옵션이 없으면 최신 안드로이드 OS에서 SMB 통신이 차단될 수 있습니다.

💻 3단계: MainActivity.kt 전체 코드 수정
이제 MainActivity.kt 코드를 네트워크 기반으로 완전히 변경합니다. 코루틴을 사용하여 백그라운드에서 SMB 폴더에 접속하고, 파일 목록을 가져온 뒤, 선택된 파일을 기기의 임시 폴더로 다운로드하여 PDFView에 표시합니다.

Kotlin

// MainActivity.kt
package com.sec.ReellistViewer

import android.os.Bundle
import android.util.Log
import android.view.View
import android.widget.Toast
import androidx.appcompat.app.AlertDialog
import androidx.appcompat.app.AppCompatActivity
import androidx.lifecycle.lifecycleScope
import com.github.barteksc.pdfviewer.listener.OnLoadCompleteListener
import com.github.barteksc.pdfviewer.listener.OnPageErrorListener
import com.sec.ReellistViewer.databinding.ActivityMainBinding
import jcifs.CIFSContext
import jcifs.config.PropertyConfiguration
import jcifs.context.BaseContext
import jcifs.smb.NtlmPasswordAuthenticator
import jcifs.smb.SmbFile
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.File
import java.io.FileOutputStream
import java.util.Properties

class MainActivity : AppCompatActivity(), OnLoadCompleteListener, OnPageErrorListener {

    private lateinit var binding: ActivityMainBinding

    // --- 🖥️ PC 공유폴더 접속 정보 (사용자 환경에 맞게 수정) ---
    private val SMB_IP = "192.168.0.10" // 1. PC의 IP 주소
    private val SMB_SHARED_FOLDER = "SharedDocs" // 2. 공유한 폴더 이름
    private val SMB_USER = "guest" // 3. PC 접속 계정 (게스트 또는 특정 사용자)
    private val SMB_PASS = "" // 4. PC 접속 비밀번호
    // ---------------------------------------------------------

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        setupEventListeners()
    }

    private fun setupEventListeners() {
        binding.btnOpenFile.setOnClickListener {
            // 코루틴을 사용하여 백그라운드에서 네트워크 작업 수행
            lifecycleScope.launch(Dispatchers.IO) {
                showPdfListFromSmb()
            }
        }
        setupPageButtons() // 페이지 버튼 설정은 기존과 동일
    }
    
    /**
     * SMB 공유 폴더에 접속하여 PDF 파일 목록을 가져와 다이얼로그로 표시합니다.
     * (백그라운드 스레드에서 실행되어야 함)
     */
    private suspend fun showPdfListFromSmb() {
        val smbUrl = "smb://$SMB_IP/$SMB_SHARED_FOLDER/"

        try {
            // SMB 접속 설정 및 인증 정보 생성
            val properties = Properties()
            properties["jcifs.smb.client.minVersion"] = "SMB1" // 호환성을 위해 SMB1 설정
            properties["jcifs.smb.client.maxVersion"] = "SMB3"
            val config = PropertyConfiguration(properties)
            val cifsContext: CIFSContext = BaseContext(config)
            val auth = NtlmPasswordAuthenticator(null, SMB_USER, SMB_PASS)
            val context = cifsContext.withCredentials(auth)

            val dir = SmbFile(smbUrl, context)
            
            // .pdf로 끝나는 파일만 필터링
            val pdfFiles = dir.listFiles { f -> f.name.endsWith(".pdf", ignoreCase = true) }

            if (pdfFiles.isEmpty()) {
                withContext(Dispatchers.Main) {
                    Toast.makeText(this@MainActivity, "공유 폴더에 PDF 파일이 없습니다.", Toast.LENGTH_SHORT).show()
                }
                return
            }

            val fileNames = pdfFiles.map { it.name }.toTypedArray()

            // UI 작업은 Main 스레드에서 처리
            withContext(Dispatchers.Main) {
                AlertDialog.Builder(this@MainActivity)
                    .setTitle("PDF 파일 선택")
                    .setItems(fileNames) { _, which ->
                        val selectedFile = pdfFiles[which]
                        // 선택된 파일을 로드하는 작업도 백그라운드에서 수행
                        lifecycleScope.launch(Dispatchers.IO) {
                            loadPdfFromSmbFile(selectedFile)
                        }
                    }
                    .setNegativeButton("취소", null)
                    .show()
            }

        } catch (e: Exception) {
            Log.e("SmbTask", "SMB 연결 또는 파일 목록 조회 실패", e)
            withContext(Dispatchers.Main) {
                Toast.makeText(this@MainActivity, "공유 폴더에 연결할 수 없습니다.\n오류: ${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }

    /**
     * SmbFile을 기기의 임시 파일로 다운로드한 후, PDFView에 로드합니다.
     * (백그라운드 스레드에서 실행되어야 함)
     * @param smbFile 로드할 원격 SMB 파일 객체
     */
    private suspend fun loadPdfFromSmbFile(smbFile: SmbFile) {
        // UI에 진행 상황 표시
        withContext(Dispatchers.Main) {
            binding.btnOpenFile.isEnabled = false
            binding.btnOpenFile.text = "다운로드 중..."
            Toast.makeText(this@MainActivity, "${smbFile.name} 파일을 불러옵니다...", Toast.LENGTH_SHORT).show()
        }

        try {
            // 앱의 캐시 디렉토리에 임시 파일 생성
            val tempPdfFile = File(cacheDir, smbFile.name)
            
            // SmbFile의 InputStream을 사용하여 임시 파일에 내용 복사
            smbFile.inputStream.use { smbInputStream ->
                FileOutputStream(tempPdfFile).use { fileOutputStream ->
                    smbInputStream.copyTo(fileOutputStream)
                }
            }

            // 다운로드 완료 후, UI 스레드에서 PDF 뷰어에 파일 로드
            withContext(Dispatchers.Main) {
                binding.pdfView.fromFile(tempPdfFile)
                    .defaultPage(0)
                    .enableSwipe(true)
                    .onLoad(this@MainActivity)
                    .onPageError(this@MainActivity)
                    .load()
            }
        } catch (e: Exception) {
            Log.e("SmbTask", "SMB 파일 다운로드 실패", e)
            withContext(Dispatchers.Main) {
                Toast.makeText(this@MainActivity, "파일을 불러오는 데 실패했습니다.", Toast.LENGTH_LONG).show()
            }
        } finally {
            // 작업 완료 후 버튼 상태 복원
            withContext(Dispatchers.Main) {
                binding.btnOpenFile.isEnabled = true
                binding.btnOpenFile.text = "PDF 파일 열기"
            }
        }
    }

    // --- 아래는 기존 코드와 거의 동일 ---
    private fun setupPageButtons() {
        val pageButtons = mapOf(
            binding.btnPage1 to 1, binding.btnPage2 to 2, binding.btnPage3 to 3, binding.btnPage4 to 4,
            binding.btnPage5 to 5, binding.btnPage6 to 6, binding.btnPage7 to 7, binding.btnPage8 to 8,
            binding.btnPage9 to 9, binding.btnPage10 to 10, binding.btnPage11 to 11, binding.btnPage12 to 12,
            binding.btnPage13 to 13, binding.btnPage14 to 14, binding.btnPage15 to 15, binding.btnPage16 to 16
        )
        pageButtons.forEach { (button, pageNumber) ->
            button.setOnClickListener { jumpToPage(pageNumber) }
        }
    }

    private fun jumpToPage(pageNumber: Int) {
        binding.pdfView.jumpTo(pageNumber - 1, true)
    }

    override fun loadComplete(nbPages: Int) {
        Toast.makeText(this, "총 ${nbPages}페이지 PDF 로드 완료", Toast.LENGTH_SHORT).show()
        binding.pageButtonContainer.visibility = View.VISIBLE
    }

    override fun onPageError(page: Int, t: Throwable) {
        Log.e("PDFView", "페이지 로드 에러: ${page + 1} 페이지", t)
        Toast.makeText(this, "${page + 1}페이지 로드 중 에러가 발생했습니다.", Toast.LENGTH_SHORT).show()
    }
}
🖥️ 4단계: PC 공유 폴더 설정 및 확인 (매우 중요)
코드가 올바르게 동작하려면 PC의 설정이 정확해야 합니다. 아래 항목들을 반드시 확인하세요.

PC의 IP 주소 확인:

Windows 검색창에 cmd를 입력하여 명령 프롬프트를 엽니다.

ipconfig 라고 입력하고 Enter 키를 누릅니다.

IPv4 주소 항목에 나오는 숫자(예: 192.168.0.10)를 코드의 SMB_IP 변수에 입력합니다.

폴더 공유 설정:

PC에서 PDF 파일들이 들어있는 폴더를 마우스 오른쪽 버튼으로 클릭 -> 속성 -> 공유 탭으로 이동합니다.

공유... 버튼을 클릭하고 공유할 사용자(Everyone 또는 특정 사용자 계정)를 추가한 뒤, 읽기 권한을 부여하고 공유 버튼을 누릅니다.

고급 공유... 버튼을 클릭하여 선택한 폴더 공유에 체크가 되어 있는지 확인합니다. 공유 이름이 코드의 SMB_SHARED_FOLDER와 일치해야 합니다.

방화벽 설정 확인:

Windows 방화벽이 SMB 통신(포트 445)을 차단할 수 있습니다.

제어판 -> Windows Defender 방화벽 -> 고급 설정으로 이동합니다.

인바운드 규칙에서 파일 및 프린터 공유(SMB-In) 규칙이 사용으로 설정되어 있는지 확인합니다. 안 되어 있다면 규칙을 '사용'으로 변경하세요.

네트워크 연결 확인:

안드로이드 기기와 PC가 반드시 동일한 Wi-Fi 네트워크에 연결되어 있어야 합니다.