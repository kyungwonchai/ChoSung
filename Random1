í•­ìƒ ëŒê³  ìˆëŠ” ìˆ˜ì‹  ë£¨í”„ (ReceiveLoopAsync())ë¥¼ ìœ ì§€.

ëª¨ë“  ë©”ì‹œì§€ëŠ” ìˆ˜ì‹  ë£¨í”„ì—ì„œ ì¡íˆë©°, ë¶„ë¥˜ ë¡œì§ì„ ì¶”ê°€.

ëª…ë ¹ì„ ë³´ë‚¼ ë•Œë§ˆë‹¤ TaskCompletionSourceë¡œ ë¹„ë™ê¸° ì‘ë‹µì„ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬.

PLCì˜ ì„ ì œ ë©”ì‹œì§€ (OP_CLEAR)ëŠ” ë³„ë„ì˜ ì´ë²¤íŠ¸ë¡œ ì²˜ë¦¬.

ğŸ’¡ ì½”ë“œ ì˜ˆì‹œ (ì£¼ì„ ë§¤ìš° ìƒì„¸íˆ ì¶”ê°€)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ì˜ ì—°ê²°ì„ ë‹´ë‹¹í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„°ë¥¼ ì†¡ìˆ˜ì‹ í•˜ê¸° ìœ„í•œ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•  ë²„í¼ (1KB í¬ê¸°)
    private bool _isConnected = false; // ì„œë²„ì™€ ì—°ê²° ìƒíƒœë¥¼ ë‚˜íƒ€ë‚´ëŠ” í”Œë˜ê·¸

    // ì‘ë‹µ ëŒ€ê¸°ë¥¼ ìœ„í•œ ë¹„ë™ê¸° ì²˜ë¦¬ë¥¼ ê´€ë¦¬í•˜ëŠ” ë¦¬ìŠ¤íŠ¸ (FIFO ë°©ì‹)
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    // ì„ ì œ ì‹ í˜¸(OP_CLEAR)ë¥¼ ê°ì§€í–ˆì„ ë•Œ ë°œìƒì‹œí‚¤ëŠ” ì´ë²¤íŠ¸
    public event Action OnOpClearReceived;

    /// <summary>
    /// ì„œë²„ì™€ ë¹„ë™ê¸°ë¡œ ì—°ê²°ì„ ìˆ˜ë¦½í•˜ê³ , ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // ìˆ˜ì‹  ë£¨í”„ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰ (ë³„ë„ì˜ Taskë¡œ ì‹¤í–‰)
        _ = Task.Run(ReceiveLoopAsync); // í•­ìƒ ëŒì•„ê°€ë©´ì„œ ë©”ì‹œì§€ë¥¼ ê°ì§€
    }

    /// <summary>
    /// PLCë¡œ ëª…ë ¹ì„ ë³´ë‚´ê³  í•´ë‹¹ ì‘ë‹µì„ ë¹„ë™ê¸°ë¡œ ê¸°ë‹¤ë¦°ë‹¤.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected) return "[ERROR] Not connected.";

        // PLC ê·œì¹™ì— ë”°ë¼ ë©”ì‹œì§€ë¥¼ STXì™€ ETXë¡œ ê°ì‹¼ë‹¤.
        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        // ì‘ë‹µì„ ë°›ê¸° ìœ„í•œ TaskCompletionSourceë¥¼ ìƒì„±
        var tcs = new TaskCompletionSource<string>();
        string requestId = Guid.NewGuid().ToString("N"); // ê³ ìœ í•œ ìš”ì²­ ID ìƒì„±
        _responseTasks.TryAdd(requestId, tcs);

        // ì„œë²„ë¡œ ë©”ì‹œì§€ ì „ì†¡
        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {message}");

        // ì‘ë‹µì„ ê¸°ë‹¤ë¦¼ (ìˆ˜ì‹  ë£¨í”„ì—ì„œ ì‘ë‹µì´ ì˜¤ë©´ ì™„ë£Œë¨)
        string response = await tcs.Task;
        
        _responseTasks.TryRemove(requestId, out _); // ì‘ë‹µ ì²˜ë¦¬ í›„ ì œê±°

        return response;
    }

    /// <summary>
    /// ì„œë²„ë¡œë¶€í„° ì˜¤ëŠ” ëª¨ë“  ë°ì´í„°ë¥¼ ì²˜ë¦¬í•˜ëŠ” ìˆ˜ì‹  ë£¨í”„.
    /// OP_CLEAR ë©”ì‹œì§€ë¥¼ ë³„ë„ë¡œ ì²˜ë¦¬í•˜ê³ , ëª…ë ¹ ì‘ë‹µì€ ëŒ€ì‘ë˜ëŠ” Taskë¡œ ë°˜í™˜í•œë‹¤.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                // ë°ì´í„°ë¥¼ ë¹„ë™ê¸°ë¡œ ì½ìŒ (ë²„í¼ í¬ê¸°: 1KB)
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // ë°›ì€ ë°ì´í„°ë¥¼ ë¬¸ìì—´ë¡œ ë³€í™˜í•˜ê³  STXì™€ ETXë¥¼ ì œê±°
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                Console.WriteLine($"[RECV] {received}");

                if (received == "OP_CLEAR")
                {
                    // ì„ ì œ ì‹ í˜¸(OP_CLEAR)ë¥¼ ê°ì§€í–ˆì„ ë•Œ ì´ë²¤íŠ¸ ë°œìƒ
                    OnOpClearReceived?.Invoke();
                    Console.WriteLine("[EVENT] OP_CLEAR received and processed.");
                }
                else
                {
                    // ì‘ë‹µì„ ë°›ì•„ì•¼ í•  ìš”ì²­ì´ ìˆëŠ”ì§€ í™•ì¸
                    foreach (var key in _responseTasks.Keys)
                    {
                        if (_responseTasks.TryRemove(key, out var tcs))
                        {
                            tcs.SetResult(received);
                            break;
                        }
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// ì„œë²„ ì—°ê²°ì„ í•´ì œí•œë‹¤.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
ğŸ“Œ ì½”ë“œ ì„¤ëª… (ì•„ì£¼ ìƒì„¸í•˜ê²Œ)
SendAndReceiveAsync() ë©”ì„œë“œ:

ìš”ì²­ì„ ë³´ë‚¼ ë•Œë§ˆë‹¤ TaskCompletionSourceë¥¼ ì‚¬ìš©í•´ì„œ ë¹„ë™ê¸°ë¡œ ì‘ë‹µì„ ê¸°ë‹¤ë¦¼.

PLCë¡œ ë³´ë‚´ëŠ” ë©”ì‹œì§€ëŠ” ì›ë³¸ ê·¸ëŒ€ë¡œ ì „ì†¡ (STX/ETX í¬í•¨).

ì‘ë‹µì€ ReceiveLoopAsync()ì—ì„œ ì¡ì•„ì„œ ì²˜ë¦¬.

ReceiveLoopAsync() ë©”ì„œë“œ:

í•­ìƒ ëŒì•„ê°€ë©´ì„œ ë©”ì‹œì§€ë¥¼ ê°ì§€.

OP_CLEAR ë©”ì‹œì§€ê°€ ì˜¤ë©´ ì¦‰ì‹œ ì´ë²¤íŠ¸ë¡œ ê°ì§€ (OnOpClearReceived).

ì¼ë°˜ ë©”ì‹œì§€ëŠ” TaskCompletionSourceë¡œ ëŒ€ê¸° ì¤‘ì¸ ìš”ì²­ì—ê²Œ ì „ë‹¬.

OnOpClearReceived ì´ë²¤íŠ¸:

PLCì—ì„œ ë¨¼ì € ë³´ë‚´ëŠ” OP_CLEAR ì‹ í˜¸ë¥¼ ì¡ê¸° ìœ„í•´ ì‚¬ìš©.

UI ë˜ëŠ” ë‹¤ë¥¸ í´ë˜ìŠ¤ì—ì„œ ì´ ì´ë²¤íŠ¸ë¥¼ ë“±ë¡í•´ì„œ ì›í•˜ëŠ” ë¡œì§ì„ ì‹¤í–‰í•  ìˆ˜ ìˆìŒ.

ğŸ”‘ ì´ êµ¬ì¡°ë¡œ í•´ê²°ëœ ì 
âœ… PLCì™€ì˜ ê·œì¹™ì„ ì ˆëŒ€ ê¹¨ì§€ ì•ŠìŒ (ëª…ë ¹ì€ ì›ë³¸ ê·¸ëŒ€ë¡œ ë³´ëƒ„).

âœ… SendAndReceiveAsync()ë¡œ ì‘ë‹µì„ ì•ˆì „í•˜ê²Œ ë¹„ë™ê¸° ì²˜ë¦¬.

âœ… OP_CLEARëŠ” í•­ìƒ ë³„ë„ë¡œ ê°ì§€ ê°€ëŠ¥ (ìˆ˜ì‹  ë£¨í”„ì—ì„œ ìë™ ê°ì§€).

âœ… ì‘ë‹µì´ ê¼¬ì´ì§€ ì•Šê²Œ ì•ˆì „í•˜ê²Œ ì²˜ë¦¬ë¨.