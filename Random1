import pdfplumber
import re
from typing import List, Dict, Any

# 각 텍스트 요소의 상세 정보를 담을 데이터 클래스 (타입 힌트를 위해 사용)
class TextElement:
    def __init__(self, element: Dict[str, Any]):
        self.value = element.get('text', '')
        self.x0 = element.get('x0', 0)
        self.y0 = element.get('y0', 0)
        self.x1 = element.get('x1', 0)
        self.y1 = element.get('y1', 0)
        self.size = round(element.get('size', 0), 2)
        # pdfplumber는 색상 정보를 튜플로 제공합니다 (예: (0, 0, 0) for black)
        self.color = element.get('non_stroking_color', (0, 0, 0))

    def __repr__(self) -> str:
        """객체를 문자열로 표현하여 출력 형식을 정의합니다."""
        return (
            f"Color: {self.color}, "
            f"Size: {self.size}, "
            f"Value: '{self.value}', "
            f"Position: (x0={self.x0:.2f}, y0={self.y0:.2f}, x1={self.x1:.2f}, y1={self.y1:.2f})"
        )

# 부품 정보 그룹을 나타내는 클래스
class PartComponent:
    def __init__(self, page_number: int, part_number_element: TextElement):
        self.page_number = page_number
        self.part_number = part_number_element.value
        # 이 부품에 속한 모든 텍스트 요소들을 저장할 리스트
        self.related_info: List[TextElement] = [part_number_element]

    def add_info(self, element: TextElement):
        """관련 정보를 추가합니다."""
        self.related_info.append(element)

    def __repr__(self) -> str:
        """최종 출력 형식을 정의합니다."""
        # 각 관련 정보들을 쉼표로 구분하여 한 줄로 만듭니다.
        info_str = ", ".join([str(elem) for elem in self.related_info])
        return f"Page: {self.page_number}, PartNumber: {self.part_number}, Details: [{info_str}]"


def find_part_components_from_pdf(pdf_path: str) -> List[PartComponent]:
    """
    PDF 파일에서 부품 컴포넌트와 관련 정보를 추출합니다.

    Args:
        pdf_path (str): 분석할 PDF 파일의 경로

    Returns:
        List[PartComponent]: 추출된 모든 부품 컴포넌트 정보 리스트
    """
    all_part_components = []
    
    # 정규 표현식: xxxx-xxxxxx 형식의 부품 코드를 찾습니다.
    part_number_pattern = re.compile(r"^\d{4}-\d{6}$")

    with pdfplumber.open(pdf_path) as pdf:
        for page_num, page in enumerate(pdf.pages, 1):
            # 100픽셀 이후부터 있는 텍스트만 처리하기 위해 페이지를 크롭합니다.
            # y좌표는 위에서 아래로 증가하므로 page.height - 100 이 아닙니다.
            page_within_bounds = page.crop((0, 100, page.width, page.height))
            
            # 텍스트의 상세 속성(크기, 색상 등)을 함께 추출합니다.
            # x_tolerance: 단어 사이의 작은 수평 간격을 합쳐서 하나의 단어로 인식하도록 설정
            # y_tolerance: 줄 사이의 작은 수직 간격을 합쳐서 하나의 줄로 인식하도록 설정
            words = page_within_bounds.extract_words(
                extra_attrs=["size", "non_stroking_color"],
                x_tolerance=3, 
                y_tolerance=3
            )
            
            if not words:
                continue

            # 1. '앵커'가 되는 부품 코드를 모두 찾습니다.
            anchors = []
            for i, word in enumerate(words):
                if part_number_pattern.match(word['text']):
                    # 앵커 정보: (단어의 y0 위치, 단어 인덱스, 단어 객체)
                    anchors.append((word['y0'], i, word))
            
            # 앵커가 없으면 다음 페이지로 넘어갑니다.
            if not anchors:
                continue
                
            # 앵커를 y좌표(위치) 기준으로 정렬합니다. 
            # 이렇게 하면 페이지에 나타나는 순서대로 처리할 수 있습니다.
            anchors.sort()

            # 2. 각 앵커를 기준으로 정보 그룹핑
            for i, (y0, anchor_idx, anchor_word_obj) in enumerate(anchors):
                part_element = TextElement(anchor_word_obj)
                part_component = PartComponent(page_num, part_element)
                
                # 그룹의 수직적 경계를 정의합니다.
                # 현재 앵커의 시작은 바로 위 앵커 그룹의 끝으로 간주합니다.
                # 예: 03L의 y좌표가 50이고, 다음 4L의 y좌표가 100이라면, 03L 그룹의 범위는 y=50~99
                # 첫 번째 앵커의 시작은 페이지의 시작(크롭된 100)
                group_start_y = anchors[i-1][0] if i > 0 else 100
                # 현재 앵커 그룹의 끝은 다음 앵커의 시작 직전
                group_end_y = anchors[i+1][0] if i < len(anchors) - 1 else page.height
                
                # 3. 전체 단어를 탐색하며 현재 그룹에 속하는지 판단합니다.
                # 이 방식보다 더 효율적인 방법은 앵커 주변의 인덱스를 탐색하는 것입니다.
                
                # 이전 앵커의 단어 인덱스 + 1 부터 현재 앵커의 단어 인덱스 - 1 까지가
                # 보통 이전 그룹에 속합니다. 이 로직을 개선해봅시다.
                
                # 개선된 로직: 각 앵커 사이의 단어들을 해당 앵커의 그룹으로 할당
                start_word_idx = anchors[i-1][1] + 1 if i > 0 else 0
                end_word_idx = anchor_idx # 현재 앵커까지
                
                # 실제 그룹핑: 다음 앵커 직전까지의 모든 단어를 현재 그룹에 포함
                group_word_start_idx = anchors[i-1][1] + 1 if i > 0 else 0
                group_word_end_idx = anchor_idx if i == len(anchors) - 1 else anchors[i+1][1]

                # part_number 자체는 이미 추가되었으므로 그 외의 단어들을 추가합니다.
                for word_idx in range(group_word_start_idx, group_word_end_idx):
                    # 현재 앵커(부품번호) 자체는 중복 추가하지 않도록 건너뜁니다.
                    if word_idx == anchor_idx:
                        continue
                    
                    word_obj = words[word_idx]
                    # 수평적 위치도 고려: 너무 멀리 떨어진 텍스트는 제외할 수 있습니다.
                    # 예: 부품 코드 x좌표와 200픽셀 이상 차이나면 다른 열의 정보로 간주
                    horizontal_distance = abs(word_obj['x0'] - anchor_word_obj['x0'])
                    if horizontal_distance < 300: # 이 값은 PDF 레이아웃에 따라 조정
                        part_component.add_info(TextElement(word_obj))

                all_part_components.append(part_component)

    return all_part_components

# --- 메인 실행 부분 ---
if __name__ == "__main__":
    # 여기에 실제 PDF 파일 경로를 입력하세요.
    # 예: pdf_file_path = "C:/Users/YourUser/Documents/parts_list.pdf"
    pdf_file_path = "YOUR_PDF_FILE_PATH.pdf" 

    try:
        extracted_data = find_part_components_from_pdf(pdf_file_path)
        
        if not extracted_data:
            print("PDF에서 부품 정보를 찾을 수 없습니다.")
        else:
            print(f"총 {len(extracted_data)}개의 부품을 찾았습니다.")
            print("-" * 50)
            for component in extracted_data:
                print(component)
                print("-" * 50)

    except FileNotFoundError:
        print(f"오류: 파일을 찾을 수 없습니다. 경로를 확인하세요: {pdf_file_path}")
    except Exception as e:
        print(f"오류가 발생했습니다: {e}")