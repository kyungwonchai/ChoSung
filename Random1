네, 알겠습니다. 마스터 키 확인 후 "마스터 데이터 관리" 탭에서 항목 이름(예: 소파트 이름)을 변경하고 저장했을 때, 연관된 사물함 데이터(LockerAssignments 테이블)가 자동으로 업데이트되지 않는 문제를 해결해야 하는군요.

이 연쇄 업데이트 로직은 MasterDataViewModel.cs 파일의 SaveMasterDataChangesAsync 메서드 내부에 구현되어 있습니다. 해당 로직이 올바르게 작동하지 않는 몇 가지 이유가 있을 수 있습니다 (예: SQL 실행 오류, 트랜잭션 문제, 변경 감지 오류 등).

문제를 진단하고 해결하기 위해 SaveMasterDataChangesAsync 메서드를 중심으로 코드를 점검하고, 디버깅 출력을 추가하여 실행 과정을 더 명확히 볼 수 있도록 수정한 MasterDataViewModel.cs 파일 전체 코드를 다시 드리겠습니다.

수정해야 할 파일:

ViewModels/MasterDataViewModel.cs
ViewModels/MasterDataViewModel.cs (수정)

SaveMasterDataChangesAsync 메서드 내 연쇄 업데이트 로직 전후에 디버그 출력문 추가
오류 처리 구체화 시도
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics; // Debug.WriteLine 사용

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (연쇄 업데이트 디버깅 강화)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) ((RelayCommand)DeleteItemCommand).RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }

            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync()); AddItemCommand = new RelayCommand(AddItem, CanAddItem); DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItem); SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync());
            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }
        private bool CanAddItem(object parameter) => _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private void AddItem(object parameter) { if (_context == null) return; if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private bool CanDeleteItem(object parameter) => _context != null && SelectedItem != null;
        private void DeleteItem(object parameter) { if (_context == null || SelectedItem == null) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = null; if (SelectedItem is LockerType lt) entityToDelete = lt; else if (SelectedItem is Floor f) entityToDelete = f; else if (SelectedItem is Zone z) entityToDelete = z; else if (SelectedItem is SubPart sp) entityToDelete = sp; else if (SelectedItem is Administrator ad) entityToDelete = ad; else return; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }
        #endregion

        #region Save Changes Logic (Including Cascade Update)

        /// <summary>
        /// 마스터 데이터의 변경 사항(추가, 수정, 삭제)을 데이터베이스에 저장합니다.
        /// 이름(Name)이 변경된 경우, 관련된 LockerAssignment 레코드도 연쇄적으로 업데이트합니다.
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            if (_context == null) return;
            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); // 롤백용

            using (var transaction = _context.Database.BeginTransaction())
            {
                try
                {
                    Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨.");

                    // 1. 이름이 변경된 마스터 데이터 항목들을 찾습니다.
                    var modifiedNameEntries = _context.ChangeTracker.Entries()
                        .Where(e => e.State == EntityState.Modified &&
                                    (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator))
                        .Select(e => new
                        {
                            Entry = e,
                            EntityType = e.Entity.GetType(), // 엔티티 타입 저장
                            OriginalName = e.OriginalValues["Name"]?.ToString(),
                            CurrentName = e.CurrentValues["Name"]?.ToString()
                        })
                        .Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName)
                        .ToList();

                    Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}");

                    // 2. 각 이름 변경 건에 대해 연쇄 업데이트 SQL을 실행합니다.
                    foreach (var modified in modifiedNameEntries)
                    {
                        StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중...";
                        Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'");

                        int updatedCount = 0;
                        string updateSql = "";
                        string targetColumn = "";

                        // 엔티티 타입에 따라 업데이트할 컬럼과 SQL 결정
                        if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType";
                        else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor";
                        else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone";
                        else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart";
                        else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator";

                        if (!string.IsNullOrEmpty(targetColumn))
                        {
                            updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}";
                            try
                            {
                                // ExecuteSqlCommandAsync 실행 및 결과 로깅
                                updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName);
                                StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 사물함 정보 업데이트 완료).";
                                Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}");
                            }
                            catch (Exception sqlEx)
                            {
                                // SQL 실행 오류 시 상세 로그 남기고 예외 다시 던지기
                                Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}");
                                StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!";
                                throw; // 트랜잭션 롤백을 위해 예외 다시 던짐
                            }
                        }
                        else
                        {
                             Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다.");
                        }
                    }

                    // 3. 모든 변경 사항(마스터 데이터 추가/수정/삭제)을 DB에 저장합니다.
                    Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)...");
                    int masterDataChanges = await _context.SaveChangesAsync(); // 로그는 DbContext에서 자동 기록
                    Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}");

                    // 4. 트랜잭션을 커밋합니다.
                    transaction.Commit();
                    Debug.WriteLine("트랜잭션 커밋 완료.");
                    StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다.";

                    // 5. 메인 ViewModel의 콤보박스용 마스터 데이터 목록도 갱신 필요
                    //    (MainViewModel에서 RefreshMasterDataCommand 사용 또는 이벤트 방식)

                }
                catch (Exception ex)
                {
                    // 6. 오류 발생 시 트랜잭션을 롤백합니다.
                    Debug.WriteLine($"*** 마스터 데이터 저장 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}");
                    try
                    {
                        transaction.Rollback();
                        Debug.WriteLine("트랜잭션 롤백 완료.");
                    }
                    catch (Exception rollbackEx)
                    {
                         Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rollbackEx.ToString()}");
                    }

                    StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}";
                    MessageBox.Show($"{StatusMessage}\n\n자세한 내용은 출력 창을 확인하세요.", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);

                    // 오류 발생 시 컨텍스트의 변경 내용을 되돌리는 것이 좋습니다.
                    RollbackMasterDataChanges(changesForRollback);
                }
            }

            // 7. 작업 완료 후 마스터 데이터 목록을 다시 로드하여 UI를 최신 상태로 유지합니다.
            await LoadAllMasterDataAsync();
        }

        // 마스터 데이터 롤백 헬퍼
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries)
        {
            if (_context == null || changedEntries == null) return;
            foreach (var entry in changedEntries)
            {
                switch (entry.State)
                {
                    case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; // Reload 시도, 실패 시 Unchanged
                    case EntityState.Added: entry.State = EntityState.Detached; break;
                    case EntityState.Deleted: entry.State = EntityState.Unchanged; break; // 삭제 취소
                }
            }
            StatusMessage = "마스터 데이터 변경 롤백됨.";
            // UI 목록도 다시 로드하여 동기화
            _ = LoadAllMasterDataAsync();
        }

        #endregion

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
주요 변경 및 확인 사항:

디버그 출력 추가: SaveMasterDataChangesAsync 메서드 내부에 Debug.WriteLine을 사용하여 트랜잭션 시작/커밋/롤백 시점, 이름 변경 감지 수, 실행되는 SQL 문과 파라미터, 결과 등을 Visual Studio의 출력(Output) 창에 표시하도록 했습니다.
사용법: 디버그 모드(F5)로 실행 후, 마스터 데이터를 수정하고 저장할 때 Visual Studio의 보기(View) -> 출력(Output) 창을 확인하여 연쇄 업데이트 로직이 예상대로 실행되는지, SQL 실행 중 오류는 없는지 확인합니다.
SQL 실행 오류 처리: ExecuteSqlCommandAsync 호출 부분을 try-catch로 감싸서 SQL 실행 자체에서 오류가 발생하면 즉시 로그를 남기고 트랜잭션이 롤백되도록 수정했습니다.
롤백 로직: 오류 발생 시 RollbackMasterDataChanges 헬퍼 메서드를 호출하여 컨텍스트의 변경 상태를 되돌리고 UI 목록을 다시 로드하도록 했습니다.
이제 다시 실행해 보시고 다음을 확인해 주세요:

마스터 데이터 항목(예: 소파트 이름)을 변경하고 저장 버튼을 누릅니다.
Visual Studio의 출력(Output) 창에 "연쇄 업데이트 시도", "SQL 실행 성공" 또는 "SQL 실행 오류" 등의 메시지가 나타나는지 확인합니다.