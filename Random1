인하고, 서비스가 중지되었을 때 자동으로 다시 시작하는 기능을 구현하기 위해서는 ServiceController를 사용하여 서비스의 상태를 주기적으로 확인하고, 상태가 "Stopped"일 경우 서비스를 다시 시작하는 로직을 추가해야 합니다.

아래에 MainViewModel에 필요한 코드와 주석을 포함하여 설명해 드리겠습니다.

수정된 MainViewModel 코드
주기적으로 서비스 상태를 확인하기 위해 DispatcherTimer 사용:

DispatcherTimer를 사용하여 일정 시간 간격으로 서비스 상태를 체크합니다.
서비스가 중지되었을 경우, ServiceController를 사용하여 서비스를 다시 시작합니다.
서비스 상태 체크 및 자동 재시작 로직 추가:

CheckServiceStatus 메서드를 통해 서비스의 상태를 확인하고, 필요에 따라 서비스를 다시 시작합니다.
MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.ServiceProcess;
using System.Windows.Threading;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private DispatcherTimer _serviceStatusTimer;
        private ServiceController _serviceController;
        private string _serviceName = "RouterMiddleACRService"; // 서비스 이름 설정

        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();

        public MainViewModel()
        {
            InitializeServiceStatusChecker();
        }

        // 서비스 상태 확인을 위한 초기화 메서드
        private void InitializeServiceStatusChecker()
        {
            _serviceController = new ServiceController(_serviceName);
            _serviceStatusTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(10) // 10초마다 상태 체크
            };
            _serviceStatusTimer.Tick += CheckServiceStatus;
            _serviceStatusTimer.Start();
        }

        // 서비스 상태를 확인하고, 중지되었을 경우 재시작하는 메서드
        private void CheckServiceStatus(object sender, EventArgs e)
        {
            try
            {
                _serviceController.Refresh();
                string status = _serviceController.Status.ToString();
                LogMessages.Add($"서비스 상태: {status}");

                if (_serviceController.Status == ServiceControllerStatus.Stopped)
                {
                    LogMessages.Add("서비스가 중지되었습니다. 재시작합니다...");
                    RestartService();
                }
            }
            catch (Exception ex)
            {
                LogMessages.Add($"서비스 상태 확인 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 재시작하는 메서드
        private void RestartService()
        {
            try
            {
                _serviceController.Start(); // 서비스 시작
                _serviceController.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(30)); // 최대 30초 동안 서비스 상태가 Running이 될 때까지 대기
                LogMessages.Add("서비스가 성공적으로 재시작되었습니다.");
            }
            catch (Exception ex)
            {
                LogMessages.Add($"서비스 재시작 중 오류 발생: {ex.Message}");
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
코드 설명
DispatcherTimer를 사용한 주기적인 상태 체크:

DispatcherTimer는 WPF 애플리케이션에서 주기적인 작업을 수행하기 위한 타이머로, UI 스레드에서 실행됩니다.
이 타이머는 10초 간격으로 CheckServiceStatus 메서드를 호출하여 서비스의 상태를 확인합니다.
서비스 상태 확인 및 재시작 로직:

CheckServiceStatus 메서드는 ServiceController.Refresh()를 호출하여 최신 서비스 상태를 가져옵니다.
서비스 상태가 Stopped로 확인되면, RestartService 메서드를 호출하여 서비스를 다시 시작합니다.
RestartService 메서드는 서비스가 시작될 때까지 최대 30초 동안 기다리고, 성공적으로 시작되었는지 확인합니다.
ObservableCollection<string>을 사용한 로그 기록:

LogMessages는 ObservableCollection<string> 타입으로, 서비스 상태와 작업 로그를 저장합니다.
이 컬렉션은 ListBox와 같은 UI 컨트롤에 바인딩되어 있어, 로그가 추가될 때마다 자동으로 UI에 업데이트됩니다.
요약
MainViewModel에 주기적인 서비스 상태 체크와 자동 재시작 기능을 추가했습니다.
DispatcherTimer를 사용하여 10초마다 서비스 상태를 확인하고, 서비스가 중지된 경우 자동으로 다시 시작합니다.
서비스 상태와 작업 로그는 ObservableCollection을 사용하여 UI에 실시간으로 표시됩니다.
이제 MainViewModel이 주기적으로 서비스 상태를 확인하고, 필요한 경우 서비스를 자동으로 재시작할 수 있습니다. 이 기능을 통해 서비스가 항상 실행 상태를 유지하도록 보장할 수 있습니다