습 중 상태와 학습 완료 상태를 UI에 표시하고, 학습 결과를 명확히 보여주도록 개선하겠습니다. 이를 위해 MainWindow.xaml과 MainWindow.xaml.cs 파일을 수정하여 학습 상태와 결과를 표시하도록 하겠습니다.

수정된 MainWindow.xaml
xml
코드 복사
<Window x:Class="SMDFileCleaner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="SMD File Cleaner" Height="600" Width="800">
    <Grid>
        <TabControl>
            <TabItem Header="Main">
                <StackPanel Margin="10">
                    <StackPanel Orientation="Horizontal" Margin="10">
                        <TextBox Name="txtFolderPath" Width="400" Margin="10" Text="D:\" IsReadOnly="True"/>
                        <Button Name="btnSelectFolder" Content="Select Folder" Width="150" Margin="10" Click="btnSelectFolder_Click"/>
                    </StackPanel>
                    <StackPanel Orientation="Horizontal" Margin="10">
                        <TextBlock Text="File Extension:" VerticalAlignment="Center" Margin="10"/>
                        <ComboBox Name="cmbFileExtension" Width="150" Margin="10">
                            <ComboBoxItem Content=".jpg" IsSelected="True"/>
                            <ComboBoxItem Content=".png"/>
                            <ComboBoxItem Content=".bmp"/>
                        </ComboBox>
                    </StackPanel>
                    <Button Name="btnStart" Content="Start Cleaning" Width="200" Margin="10" Click="btnStart_Click"/>
                    <Button Name="btnSaveSettings" Content="Save Settings" Width="200" Margin="10" Click="btnSaveSettings_Click"/>
                    <Button Name="btnLoadSettings" Content="Load Settings" Width="200" Margin="10" Click="btnLoadSettings_Click"/>
                    <ListBox Name="lstRecentLogs" Width="750" Height="100" Margin="10"/>
                    <ListBox Name="lstDeletionLogs" Width="750" Height="100" Margin="10"/>
                    <TextBlock Text="Current Pattern Rules:" Margin="10"/>
                    <TextBlock Name="txtCurrentPatterns" Width="750" Height="50" Margin="10"/>
                    <TextBlock Text="Files to Delete (Priority Order):" Margin="10"/>
                    <ListBox Name="lstPriorityFiles" Width="750" Height="100" Margin="10"/>
                    <TextBlock Text="Training Status:" Margin="10"/>
                    <TextBlock Name="txtTrainingStatus" Width="750" Height="50" Margin="10" Text="Not Started"/>
                </StackPanel>
            </TabItem>
            <TabItem Header="ML Data">
                <StackPanel Margin="10">
                    <TextBlock Text="Training Data:" Margin="10"/>
                    <DataGrid Name="dataGridTrainingData" Width="750" Height="200" Margin="10" AutoGenerateColumns="True"/>
                    <TextBlock Text="Training Results:" Margin="10"/>
                    <DataGrid Name="dataGridTrainingResults" Width="750" Height="200" Margin="10" AutoGenerateColumns="True"/>
                </StackPanel>
            </TabItem>
        </TabControl>
    </Grid>
</Window>
수정된 MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Forms;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private const long MinimumFreeSpace = 20L * 1024 * 1024 * 1024; // 20 GB
        private const int MinimumSampleSize = 10; // 최소 샘플 수
        private string logDirectory = @"C:\Agent\SMDClean\Logs";
        private string settingsDirectory = @"C:\Agent\SMDClean";
        private MLModelBuilder _mlModelBuilder;
        private SettingsManager _settingsManager;
        private FileCleaner _fileCleaner;
        private List<FileRecord> _trainingData;

        public MainWindow()
        {
            InitializeComponent();
            _mlModelBuilder = new MLModelBuilder();
            _settingsManager = new SettingsManager(settingsDirectory);
            _fileCleaner = new FileCleaner(logDirectory, _mlModelBuilder, Dispatcher, LogRecentActivity, LogDeletionActivity, UpdateFolderStatistics);
            LoadSettings();
        }

        private void btnSaveSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                SaveSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnLoadSettings_Click(object sender, RoutedEventArgs e)
        {
            try
            {
                LoadSettings();
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void btnSelectFolder_Click(object sender, RoutedEventArgs e)
        {
            using (var dialog = new FolderBrowserDialog())
            {
                dialog.SelectedPath = txtFolderPath.Text;
                if (dialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
                {
                    txtFolderPath.Text = dialog.SelectedPath;
                }
            }
        }

        private void SaveSettings()
        {
            try
            {
                _settingsManager.SaveSettings(new Settings
                {
                    FolderPath = txtFolderPath.Text,
                    FileExtension = cmbFileExtension.Text,
                    DriveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\"
                });
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private void LoadSettings()
        {
            try
            {
                var settings = _settingsManager.LoadSettings();
                if (settings != null)
                {
                    txtFolderPath.Text = settings.FolderPath ?? "D:\\";
                    cmbFileExtension.Text = settings.FileExtension ?? ".jpg";
                }
            }
            catch (Exception ex)
            {
                LogError(ex.Message);
            }
        }

        private async void btnStart_Click(object sender, RoutedEventArgs e)
        {
            string folderPath = txtFolderPath.Text;
            string fileExtension = cmbFileExtension.Text;
            string driveName = txtFolderPath.Text.Split('\\').FirstOrDefault() + "\\";

            if (string.IsNullOrEmpty(folderPath) || folderPath == "Enter folder path" ||
                string.IsNullOrEmpty(fileExtension))
            {
                MessageBox.Show("Please provide all inputs.");
                return;
            }

            try
            {
                Dispatcher.Invoke(() => { txtTrainingStatus.Text = "Training in progress..."; });
                
                _trainingData = CollectInitialFileData(folderPath, fileExtension);
                if (_trainingData.Count < MinimumSampleSize)
                {
                    MessageBox.Show($"Not enough samples to train the model. Minimum required samples: {MinimumSampleSize}");
                    Dispatcher.Invoke(() => { txtTrainingStatus.Text = "Training failed: Not enough samples"; });
                    return;
                }

                dataGridTrainingData.ItemsSource = _trainingData;
                _mlModelBuilder.TrainModel(_trainingData);

                Dispatcher.Invoke(() => { txtTrainingStatus.Text = "Training completed"; });

                await MonitorAndDisplayFilesToDelete(folderPath, fileExtension, driveName);
            }
            catch (Exception ex)
            {
                LogError("Failed to train model: " + ex.Message);
                Dispatcher.Invoke(() => { txtTrainingStatus.Text = "Training failed: " + ex.Message; });
            }
        }

        private List<FileRecord> CollectInitialFileData(string folderPath, string fileExtension)
        {
            var fileDataList = new List<FileRecord>();
            try
            {
                var files = GetFiles(folderPath, fileExtension);
                if (files != null && files.Count > 0)
                {
                    fileDataList = files.Select(f => new FileRecord
                    {
                        FilePath = f.FullName,
                        Extension = f.Extension,
                        Size = (float)f.Length, // float 형식으로 변환
                        FolderPath = f.DirectoryName
                    }).ToList();

                    Dispatcher.Invoke(() =>
                    {
                        txtCurrentPatterns.Text = $"Training on {files.Count} files";
                    });
                }
                else
                {
                    Dispatcher.Invoke(() =>
                    {
                        txtCurrentPatterns.Text = "No files found to train on.";
                    });
                }
            }
            catch (Exception ex)
            {
                LogError("Failed to collect initial file data: " + ex.Message);
                Dispatcher.Invoke(() =>
                {
                    txtCurrentPatterns.Text = "Error collecting file data.";
                });
            }
            return fileDataList;
        }

        private List<FileInfo> GetFiles(string folderPath, string fileExtension)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles($"*{fileExtension}", SearchOption.TopDirectoryOnly)
                    .Where(f => f.Length > 1 * 1024 * 1024)); // 1MB 이상의 파일

                foreach (var subDir in directory.GetDirectories())
                {
                    if (!IsSystemVolumeInformation(subDir))
                    {
                        files.AddRange(GetFiles(subDir.FullName, fileExtension));
                    }
                }
            }
            catch (UnauthorizedAccessException ex)
            {
                LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        private bool IsSystemVolumeInformation(DirectoryInfo dirInfo)
        {
            return dirInfo.FullName.Contains("System Volume Information");
        }

        private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
        {
            while (true)
            {
                try
                {
                    long freeSpace = _fileCleaner.GetDriveFreeSpace(driveName);
                    if (freeSpace < MinimumFreeSpace)
                    {
                        List<FileInfo> filesToDelete = _fileCleaner.GetFilesToDelete(folderPath, fileExtension);
                        DisplayFilesToDelete(filesToDelete);
                        //await _fileCleaner.DeleteFilesAsync(filesToDelete); // 실제 삭제 코드 (주석 처리)
                    }

                    _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension);
                    await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
                }
                catch (Exception ex)
                {
                    LogError("Failed during monitoring: " + ex.Message);
                }
            }
        }

        private void DisplayFilesToDelete(List<FileInfo> filesToDelete)
        {
            Dispatcher.Invoke(() =>
            {
                lstPriorityFiles.Items.Clear();
                foreach (var file in filesToDelete)
                {
                    lstPriorityFiles.Items.Add(file.FullName);
                }
                dataGridTrainingResults.ItemsSource = filesToDelete.Select(f => new { f.Name, f.CreationTime });
            });
        }

        private void LogRecentActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                lstRecentLogs.Items.Add(message);
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogDeletionActivity(string message)
        {
            Dispatcher.Invoke(() =>
            {
                lstDeletionLogs.Items.Add(message);
                if (lstDeletionLogs.Items.Count > 200)
                {
                    lstDeletionLogs.Items.RemoveAt(0);
                }
            });
        }

        private void UpdateFolderStatistics(long totalSize, string folderPath)
        {
            Dispatcher.Invoke(() =>
            {
                lstRecentLogs.Items.Add($"Folder: {folderPath}, Total Size: {totalSize / (1024 * 1024)} MB");
                if (lstRecentLogs.Items.Count > 200)
                {
                    lstRecentLogs.Items.RemoveAt(0);
                }
            });
        }

        private void LogError(string message)
        {
            try
            {
                string logPath = Path.Combine(logDirectory, DateTime.Now.ToString("yyyyMMdd"), "errorlog.txt");
                Directory.CreateDirectory(Path.GetDirectoryName(logPath));
                string logMessage = $"{DateTime.Now}: {message}";

                File.AppendAllText(logPath, logMessage + Environment.NewLine);

                Dispatcher.Invoke(() =>
                {
                    lstRecentLogs.Items.Add(logMessage);
                    if (lstRecentLogs.Items.Count > 200)
                    {
                        lstRecentLogs.Items.RemoveAt(0);
                    }
                });
            }
            catch (Exception ex)
            {
                // 에러 로깅에 실패한 경우 추가 조치 없음
                Console.WriteLine("Error logging failed: " + ex.Message);
            }
        }
    }
}
수정된 FileRecord.cs
csharp
코드 복사
public class FileRecord
{
    public string FilePath { get; set; }
    public string Extension { get; set; }
    public float Size { get; set; } // float 형식으로 변경
    public string FolderPath { get; set; }
    public int Count { get; set; } // 추가된 카운터 변수
}
이제 UI에 학습 상태(txtTrainingStatus)를 추가하고 학습 중, 학습 완료, 학습 실패 등의 상태를 표시하도록 했습니다. 학습이 완료되면 학습된 데이터로부터 정규 패턴을 표시하도록 개선했습니다