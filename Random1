, 알겠습니다. 단 하나의 오해도 발생하지 않도록, 모든 단계를 극도로 세밀하고 명확하게 기술하여 최종 지시사항을 다시 작성하겠습니다.

이 스크립트는 AI가 따라야 할 생각의 흐름과 행동 규칙을 명확히 정의하는 것을 목표로 합니다.

[AI-CLI 자동 리팩토링 작업 스크립트 V4.0 - 최종 종합 지시서]
[BEGIN SCRIPT]

# 0. 작업 개요 및 철학 (Overview & Philosophy)

최상위 목표: 이 작업의 최종 목표는 단순히 빌드를 성공시키는 것이 아니라, 코드의 품질을 본질적으로 향상시키는 것이다. 리팩토링이 주(主)이고, 빌드 검증은 각 리팩토링 단계의 안정성을 보장하기 위한 보조(補助) 수단이다.
작업 흐름: 전체 프로세스는 '리팩토링-검증'이라는 큰 사이클을 반복하는 형태로 진행된다. 하나의 리팩토링을 적용하고, 그것이 문제를 일으키지 않는지 즉시 검증하고, 성공하면 다음 리팩토링으로 넘어간다.
행동 원칙: 당신은 지시된 프로토콜을 기계적으로, 그리고 정확하게 따라야 한다. 임의로 단계를 생략하거나 순서를 변경해서는 안 된다.
# 1. 초기화 및 준비 단계 (Phase 1: Initialization & Preparation)

명령: 아래 3개의 준비 단계를 순서대로, 그리고 완벽하게 수행한 후에만 다음 단계로 넘어갈 수 있다.

1.1. 대상 확정 (Target Confirmation)

행동: 현재 당신의 작업 환경에 로드되어 활성화된 Visual Studio 솔루션을 이번 작업의 유일한 대상으로 확정한다.
1.2. 메타데이터 추출 (Metadata Extraction)

행동: 확정된 대상으로부터 다음 두 가지 핵심 정보를 추출하여 내부 변수로 저장한다.
솔루션 이름 (SolutionName): 예: MyLegacyApp.sln
솔루션 루트 디렉토리 절대 경로 (SolutionRootPath): 예: C:\Users\User\Documents\Projects\MyLegacyApp\
분석: 솔루션에 포함된 모든 .csproj 파일을 읽어 원본 .NET Framework 버전과 **기본 빌드 구성(예: Debug|Any CPU)**을 파악하고, 이 정보 또한 모든 후속 작업에서 일관되게 사용한다.
1.3. 안전 백업 생성 (Safety Backup Creation)

필수 행동: SolutionRootPath의 전체 내용을 ZIP 압축 파일로 만들어 원본 코드의 백업을 생성한다.
파일명 규칙: {SolutionName}_backup_{yyyyMMddHHmmss}.zip
위치: 찾기 쉬운 경로 (예: C:\backups\)
# 2. 리팩토링 지시사항 (Phase 2: Refactoring Directives)

정의: 아래 목록은 당신이 수행해야 할 개선 작업의 종류이다. 4단계의 리팩토링 사이클에서 어떤 작업을 할지 결정하는 기준이 된다.

P0 (최우선 - 안정성): 메모리 누수(IDisposable 미해제), CPU/GDI 핸들 누수, UI 스레드 동결을 유발하는 동기 I/O.
P1 (차선 - 구조): 수천 줄에 달하는 거대 클래스 파일 분리, 300줄 이상의 거대 메서드 분해.
P2 (일반 - 설계): SOLID 원칙 위반 사례 수정 (특히 단일 책임 원칙), 적절한 곳에 디자인 패턴(싱글톤, 팩토리 등) 적용.
P3 (후순위 - 최적화): 비효율적인 루프, 중복 코드, 레거시 비동기 패턴을 async/await로 현대화.
# 3. 절대 규칙 및 예외 조항 (Phase 3: Golden Rules & Exceptions)

경고: 아래 규칙은 모든 단계에 걸쳐 최우선으로 적용된다.

실행 금지: 어떠한 상황에서도 빌드 결과물인 .exe 파일을 실행해서는 안 된다. 작업의 범위는 코드 수정과 빌드 검증까지이다.
민감 정보 보호: 명백한 DB 연결 문자열이나 API 키는 절대 수정하지 않는다.
password 예외: password라는 단어 자체는 이 프로젝트에서 민감 정보가 아니다. 따라서 일반 코드로 취급하여 리팩토링 대상에 자유롭게 포함한다.
smdDBConntction.dll 참조 오류 특수 처리: 빌드 실패 원인이 smdDBConntction 관련 참조 누락일 경우, 4단계의 프로토콜에 따라 지정된 DLL 파일을 복사하고 참조를 추가해야 한다.
# 4. '리팩토링-검증' 실행 프로토콜 (Phase 4: The Refactor-Verify Execution Protocol)

지시: 이제부터 코드 개선을 위한 주(主) 반복문을 시작한다. 더 이상 적용할 리팩토링이 없거나 최대 50회 사이클을 돌면 종료된다.

[주(主) 반복문: 리팩토링 적용 및 검증]
4.1. 다음 리팩토링 작업 결정 및 수행

분석: #2 지시사항의 우선순위(P0→P1→P2→P3)에 따라, 현재 코드베이스에서 가장 시급하고 개선 효과가 큰 리팩토링 대상을 단 하나만 식별한다.
종료 조건: 만약 분석 결과 더 이상 적용할 의미 있는 리팩토링 대상이 없다면, 이 프로토콜 전체를 종료하고 #5 단계로 넘어간다.
수정 실행: 식별된 대상에 대한 코드 리팩토링을 실제로 적용한다.
4.2. 보조(補助) 반복문: 빌드 안정화 루프 (최대 5회 재시도)

목표: 4.1에서 적용한 변경사항이 빌드를 깨뜨렸는지 확인하고, 깨졌다면 즉시 바로잡는다.

a. 빌드 및 로그 캡처:

명령: MSBuild를 사용하여 솔루션을 빌드한다. 이때, 모든 표준 출력과 표준 에러를 1.log 파일에 덮어쓰기 모드로 저장해야 한다.
정확한 커맨드 예시: msbuild YourSolutionName.sln /nologo > 1.log 2>&1
b. 로그 파일 정밀 분석:

명령: 1.log 파일을 열어 그 내용을 처음부터 끝까지 읽는다. 'Error', '오류' 키워드가 포함되어 있는지 대소문자 구분 없이 확인한다.
c. 분기 처리:

[빌드 성공 시]: 1.log에 에러가 없다면, 4.1의 리팩토링이 성공적으로 검증되었다.

조치: 이 보조 반복문을 즉시 종료하고, 주 반복문의 시작점(4.1)으로 돌아가 다음 리팩토링 대상을 찾는다.
[빌드 실패 시]: 1.log에 에러가 있다면,

조치 1 (특수 오류 검사): 에러가 #3 규칙의 smdDBConntction 참조 오류인지 최우선으로 확인한다. 맞다면, 지정된 DLL을 복사하고 프로젝트 참조를 추가한 뒤, 다시 **a 단계(빌드)**로 돌아간다.
조치 2 (일반 오류 수정): 위가 아니라면, 로그에서 에러 메시지, 파일명, 라인 번호를 정확히 추출한다. 리팩토링의 큰 틀은 유지하되, 이 빌드 에러를 해결하기 위한 최소한의 구문 수정(세미콜론 누락, 변수명 오타 등)을 가한다. 그리고 다시 **a 단계(빌드)**로 돌아간다.
d. 재시도 한도 초과 시:

조건: 이 보조 루프를 5번 반복했음에도 빌드가 계속 실패하는 경우.
조치: 이번 리팩토링은 실패로 간주한다. 4.1에서 적용했던 모든 코드 변경 사항을 **완벽하게 원상 복구(Revert)**한다. 이 보조 반복문을 종료하고, 주 반복문의 시작점(4.1)으로 돌아가 다른 리팩토링 대상을 찾는다.
# 5. 최종 결과 보고 (Phase 5: Final Reporting)

명령: #4 프로토콜이 종료되면, 즉시 아래의 보고 절차를 수행한다.

로그 파일 경로 준비: D:\refactoringhistory\ 디렉토리와 그 하위의 {SolutionFolderName} 디렉토리가 있는지 확인하고, 없으면 생성한다.
결과 파일 생성: 위 경로에 {SolutionName}_{yyyyMMddHHmmss}.txt 이름으로 최종 보고 파일을 생성한다.
상세 내용 기록: 생성된 파일에 다음 정보를 포함하여 전체 작업 이력을 기록한다.
작업 요약: 총 수행한 리팩토링 사이클 수, 성공 횟수, 실패 및 원상 복구 횟수.
개별 변경 이력: 각 리팩토링 시도에 대해 아래 내용을 상세히 기록한다.
상태: SUCCESS 또는 FAILED_AND_REVERTED
리팩토링 유형: 예) "메모리 누수 수정", "거대 메서드 분해"
대상 파일/라인: 변경이 일어난 위치
코드 변경점: diff 형식의 Before/After 코드 스니펫
[END SCRIPT]







이거 영어로된거도 줘바요



생각하는 과정 표시
Of course. Here is the same set of meticulous, detailed instructions translated into English.

[AI-CLI Automated Refactoring Job Script V4.0 - Final Comprehensive Directive]
[BEGIN SCRIPT]

# 0. Overview & Philosophy

Top-Level Goal: The ultimate objective of this operation is not merely to achieve a successful build, but to fundamentally improve the quality of the code. Refactoring is the primary objective (the "main mission"), and build verification is a secondary, supporting action (the "sub-mission") to ensure stability at each step.
Workflow: The entire process proceeds by repeating a primary "Refactor-Verify" cycle. You will apply one refactoring change, immediately verify that it does not break the build, and, upon success, move on to the next refactoring task.
Principle of Action: You must follow the instructed protocol mechanically and precisely. You must not arbitrarily skip steps or alter their order.
# 1. Phase 1: Initialization & Preparation

COMMAND: You may only proceed to the next phase after completing the following three preparation steps sequentially and perfectly.

1.1. Target Confirmation

ACTION: Confirm that the Visual Studio solution currently loaded and active in your work environment is the sole target for this operation.
1.2. Metadata Extraction

ACTION: From the confirmed target, extract the following two key pieces of information and store them as internal variables:
SolutionName: e.g., MyLegacyApp.sln
SolutionRootPath: The absolute path to the solution's root directory, e.g., C:\Users\User\Documents\Projects\MyLegacyApp\
ANALYSIS: Read all .csproj files included in the solution to identify the original .NET Framework version and the default build configuration (e.g., Debug|Any CPU). This information must also be used consistently in all subsequent operations.
1.3. Safety Backup Creation

MANDATORY ACTION: Create a backup of the original code by creating a ZIP archive of the entire contents of the SolutionRootPath.
FILENAME RULE: {SolutionName}_backup_{YYYYMMDDHHMMSS}.zip
LOCATION: An easily accessible path (e.g., C:\backups\)
# 2. Phase 2: Refactoring Directives

DEFINITION: The following list defines the types of improvements you must perform. This serves as the criteria for deciding which action to take during the refactoring cycle in Phase 4.

P0 (Top Priority - Stability): Memory leaks (IDisposable not disposed), CPU/GDI Handle leaks, synchronous I/O that freezes the UI thread.
P1 (High Priority - Structure): Splitting massive class files (thousands of lines), decomposing huge methods (over 300 lines).
P2 (Normal Priority - Design): Fixing SOLID principle violations (especially Single Responsibility Principle), applying appropriate design patterns where needed (Singleton, Factory, etc.).
P3 (Low Priority - Optimization): Inefficient loops, duplicated code, modernizing legacy asynchronous patterns to async/await.
# 3. Phase 3: Golden Rules & Exceptions

WARNING: The following rules apply above all others and throughout all phases.

Execution Prohibition: Under no circumstances are you to execute the compiled build artifact (.exe file). The scope of this operation ends at code modification and build verification.
Sensitive Information Protection: Do not modify any obvious credential patterns, such as full database connection strings or API keys.
password Exception: The literal string password is not sensitive information in this project. Therefore, treat it as normal code and freely include it in refactoring operations.
smdDBConntction.dll Special Handling: If a build fails due to a missing reference related to smdDBConntction, you must follow the protocol in Phase 4 to copy the specified DLL and add a reference to it.
# 4. Phase 4: The Refactor-Verify Execution Protocol

DIRECTIVE: You will now begin the main loop for code improvement. This loop terminates only when no more refactoring targets can be found or after a maximum of 50 main refactoring cycles have been completed.

[Main Loop: The Refactoring Cycle]
4.1. Analyze and Apply the Next Refactoring Job

ANALYSIS: Based on the priority list from Phase 2 (P0→P1→P2→P3), analyze the entire current codebase to identify the single most urgent and impactful refactoring target. (e.g., the longest method, a class suspected of an IDisposable leak).
TERMINATION CONDITION: If the analysis finds no more meaningful refactoring targets, terminate this main loop and proceed to Phase 5.
EXECUTE MODIFICATION: Apply the code change that refactors the identified target.
4.2. Sub-Loop: Build Stabilization (Max 5 retries)

GOAL: To verify that the change applied in 4.1 did not break the build, and if it did, to fix it immediately.

a. Execute Build & Capture Log (Mandatory Action):

COMMAND: Build the solution using MSBuild. You must redirect all standard output and all standard error to a text file named 1.log in overwrite mode.
EXACT COMMAND EXAMPLE: msbuild YourSolutionName.sln /nologo > 1.log 2>&1
b. Meticulously Analyze Log File:

COMMAND: Open the newly created 1.log file and read its entire content from beginning to end. Perform a case-insensitive search for the keywords 'Error' or 'Failed'.
c. Branching Logic:

[IF BUILD SUCCEEDS]: The file 1.log contains no error keywords. The refactoring from 4.1 is successfully validated.

ACTION: Immediately exit this sub-loop and return to the beginning of the main loop (4.1) to find the next refactoring target.
[IF BUILD FAILS]: The file 1.log contains an error keyword.

ACTION 1 (Special Error Check): First, check if the error is the smdDBConntction reference error mentioned in the Golden Rules. If it is, immediately copy the specified DLL, add the project reference, and then go back to step 'a' (Execute Build) of this sub-loop.
ACTION 2 (General Error Fix): If it is not the special case, extract the exact error message, file name, and line number from the log. Apply a minimal, syntactic correction (e.g., fix a missing semicolon, correct a variable name typo) to resolve only this build error while preserving the intent of the refactoring. Then, go back to step 'a' (Execute Build).
d. Handling Exceeded Retries:

CONDITION: If this sub-loop has been attempted 5 times and the build continues to fail.
ACTION: The refactoring attempt is deemed a failure. You must perfectly revert all code changes made in step 4.1. Log this failure, exit this sub-loop, and return to the beginning of the main loop (4.1) to find a different refactoring target.
[Safety Rule]
No Execution: Regardless of build success, do not execute the compiled output (.exe).
# 5. Phase 5: Final Reporting

COMMAND: As soon as the protocol in Phase 4 terminates, you must immediately perform the following reporting procedure.

Prepare Log Directory: Ensure the directory D:\refactoringhistory\ and its subdirectory {SolutionFolderName} exist. If not, create them.
Create Report File: In the path above, create the final report file named {SolutionName}_{YYYYMMDDHHMMSS}.txt.
Record Detailed History: In the generated file, record the entire operational history, including the following information:
Job Summary: Total number of refactoring cycles performed, number of successes, number of failures/reverts.
Individual Change History: For each refactoring attempt, log the following details:
Status: SUCCESS or FAILED_AND_REVERTED
Refactoring Type: e.g., "Memory Leak Fix," "Decomposition of Large Method"
Target File(s)/Line(s): The location where the change occurred.
Code Change: A diff-style Before/After code snippet.
[END SCRIPT]