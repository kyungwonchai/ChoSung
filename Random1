습니다. 이어서 파일 목록의 7, 8, 9번째 파일(PasswordHelper.cs, RelayCommand.cs, ViewModelBase.cs)의 전체 코드를 여기에 바로 작성해 드리겠습니다. 이 파일들은 모두 Infrastructure 폴더에 위치합니다.

7. Infrastructure/PasswordHelper.cs

WPF PasswordBox의 Password 속성을 ViewModel의 SecureString 타입 속성에 양방향으로 바인딩할 수 있도록 돕는 헬퍼 클래스입니다.

C#

using System;
using System.Security; // SecureString 사용
using System.Windows;
using System.Windows.Controls; // PasswordBox 사용
using System.Windows.Data; // Binding 사용 (TwoWay)
// using System.Windows.Interactivity; // Behavior 사용 시 필요 (여기서는 Attached Property 사용)

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// PasswordBox의 Password 속성을 ViewModel의 SecureString에 양방향 바인딩할 수 있도록 돕는 헬퍼 클래스입니다.
    /// Attached Property를 사용합니다.
    /// </summary>
    public static class PasswordHelper
    {
        // Attach Attached Property 정의: PasswordHelper 기능을 사용할지 여부
        public static readonly DependencyProperty AttachProperty =
            DependencyProperty.RegisterAttached("Attach", typeof(bool), typeof(PasswordHelper), new PropertyMetadata(false, AttachChanged));

        public static bool GetAttach(DependencyObject dp) => (bool)dp.GetValue(AttachProperty);
        public static void SetAttach(DependencyObject dp, bool value) => dp.SetValue(AttachProperty, value);

        // Password Attached Property 정의: ViewModel의 SecureString 속성과 바인딩될 대상
        public static readonly DependencyProperty PasswordProperty =
            DependencyProperty.RegisterAttached("Password", typeof(SecureString), typeof(PasswordHelper),
                new FrameworkPropertyMetadata(null, FrameworkPropertyMetadataOptions.BindsTwoWayByDefault, PasswordPropertyChanged));

        public static SecureString GetPassword(DependencyObject dp) => (SecureString)dp.GetValue(PasswordProperty);
        public static void SetPassword(DependencyObject dp, SecureString value) => dp.SetValue(PasswordProperty, value);

        // 내부 플래그: PasswordBox의 값이 변경되어 ViewModel을 업데이트 중인지 여부 (무한 루프 방지)
        private static readonly DependencyProperty IsUpdatingProperty =
           DependencyProperty.RegisterAttached("IsUpdating", typeof(bool), typeof(PasswordHelper));

        private static bool GetIsUpdating(DependencyObject dp) => (bool)dp.GetValue(IsUpdatingProperty);
        private static void SetIsUpdating(DependencyObject dp, bool value) => dp.SetValue(IsUpdatingProperty, value);


        // Attach 속성이 변경될 때 호출되는 콜백
        private static void AttachChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            if (!(sender is PasswordBox passwordBox)) return; // PasswordBox가 아니면 무시

            // Attach 속성이 true로 설정되면 PasswordChanged 이벤트 핸들러 연결
            if ((bool)e.NewValue)
            {
                passwordBox.PasswordChanged += PasswordBox_PasswordChanged;
                // 초기 로드 시 ViewModel의 값으로 PasswordBox 설정 (선택 사항)
                // SetPasswordBoxPassword(passwordBox, GetPassword(passwordBox));
            }
            // Attach 속성이 false로 설정되면 이벤트 핸들러 연결 해제
            else
            {
                passwordBox.PasswordChanged -= PasswordBox_PasswordChanged;
            }
        }

        // Password Attached Property 값이 변경될 때 호출되는 콜백 (주로 ViewModel -> View 방향)
        private static void PasswordPropertyChanged(DependencyObject sender, DependencyPropertyChangedEventArgs e)
        {
            if (!(sender is PasswordBox passwordBox)) return;

            // PasswordBox_PasswordChanged 내부에서 업데이트 중인 경우는 제외 (무한 루프 방지)
            if (!GetIsUpdating(passwordBox))
            {
                // ViewModel의 SecureString 값이 변경되면 PasswordBox의 Password를 업데이트
                // 직접 Password 속성 설정은 보안상 권장되지 않으므로 주석 처리.
                // 필요 시 passwordBox.Password = ConvertToUnsecureString(e.NewValue as SecureString); 와 같이 구현 가능.
                // 일반적으로 ViewModel -> View 업데이트는 초기 로드 시 또는 명시적 클리어 시 필요할 수 있음.
            }
        }

        // PasswordBox의 PasswordChanged 이벤트 핸들러 (View -> ViewModel 방향)
        private static void PasswordBox_PasswordChanged(object sender, RoutedEventArgs e)
        {
            if (!(sender is PasswordBox passwordBox)) return;

            // 내부 업데이트 플래그 설정
            SetIsUpdating(passwordBox, true);
            // PasswordBox의 현재 SecurePassword 값을 Password Attached Property에 설정 (ViewModel 업데이트 트리거)
            SetPassword(passwordBox, passwordBox.SecurePassword);
            // 내부 업데이트 플래그 해제
            SetIsUpdating(passwordBox, false);
        }

        // 참고: SecureString을 일반 string으로 변환하는 메서드 (필요 시 ViewModel의 메서드 사용)
        // private static string ConvertToUnsecureString(SecureString securePassword) { ... }
    }
}
8. Infrastructure/RelayCommand.cs

MVVM 패턴에서 ViewModel의 메서드를 UI 요소(예: 버튼)의 Command 속성에 바인딩하기 위한 ICommand 인터페이스 구현 클래스입니다.

C#

using System;
using System.Windows.Input; // ICommand, CommandManager 사용

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// ICommand 인터페이스의 간단한 구현체입니다. ViewModel에서 UI 작업을 처리하는 데 사용됩니다.
    /// (.NET Framework 환경에 맞춰 Nullable 참조 타입(?) 제거)
    /// </summary>
    public class RelayCommand : ICommand
    {
        // 실행될 Action 델리게이트 (파라미터 타입: object)
        private readonly Action<object> _execute;
        // 실행 가능 여부를 판단할 Predicate 델리게이트 (파라미터 타입: object)
        private readonly Predicate<object> _canExecute;

        /// <summary>
        /// 명령의 실행 가능 상태가 변경될 수 있음을 WPF CommandManager에 알리는 이벤트입니다.
        /// CommandManager.RequerySuggested 이벤트를 사용하여 UI 상태 변경 시 자동으로 CanExecute가 다시 평가되도록 합니다.
        /// </summary>
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        /// <summary>
        /// 새로운 RelayCommand 인스턴스를 생성합니다.
        /// </summary>
        /// <param name="execute">명령 실행 시 호출될 Action입니다. null일 수 없습니다.</param>
        /// <param name="canExecute">명령 실행 가능 여부를 반환하는 Predicate입니다. null이면 항상 실행 가능한 것으로 간주됩니다.</param>
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute)); // execute는 필수
            _canExecute = canExecute;
        }

        /// <summary>
        /// 현재 상태에서 명령을 실행할 수 있는지 여부를 결정합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        /// <returns>실행 가능하면 true, 그렇지 않으면 false입니다.</returns>
        public bool CanExecute(object parameter)
        {
            // _canExecute 델리게이트가 null이면 항상 true, 아니면 해당 델리게이트의 결과를 반환합니다.
            return _canExecute == null || _canExecute(parameter);
        }

        /// <summary>
        /// 명령을 실행합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        public void Execute(object parameter)
        {
            _execute(parameter); // 등록된 Action을 실행합니다.
        }

        /// <summary>
        /// CanExecuteChanged 이벤트를 강제로 발생시켜 명령의 실행 가능 상태를 다시 평가하도록 요청합니다.
        /// (ViewModel 속성 변경 시 이 메서드를 호출하여 버튼 활성화/비활성화 등을 수동으로 업데이트할 때 사용 가능)
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            // CommandManager에게 CanExecute 상태를 다시 확인하도록 요청합니다.
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
9. Infrastructure/ViewModelBase.cs

모든 ViewModel 클래스가 상속받는 기본 클래스입니다. INotifyPropertyChanged 인터페이스를 구현하여 속성 변경 시 UI에 알림을 보내는 기능을 제공합니다.

C#

using System.Collections.Generic; // EqualityComparer 사용
using System.ComponentModel; // INotifyPropertyChanged 사용
using System.Runtime.CompilerServices; // CallerMemberName 사용

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// 모든 ViewModel 클래스가 상속받는 기본 클래스입니다.
    /// INotifyPropertyChanged 인터페이스 구현을 제공하여 속성 변경 알림을 단순화합니다.
    /// </summary>
    public abstract class ViewModelBase : INotifyPropertyChanged
    {
        /// <summary>
        /// 속성 값이 변경될 때 발생하는 이벤트입니다. UI 바인딩 업데이트에 사용됩니다.
        /// </summary>
        public event PropertyChangedEventHandler PropertyChanged;

        /// <summary>
        /// PropertyChanged 이벤트를 발생시키는 보호된(protected) 가상(virtual) 메서드입니다.
        /// 파생 클래스에서 필요 시 재정의할 수 있습니다.
        /// </summary>
        /// <param name="propertyName">변경된 속성의 이름입니다. [CallerMemberName] 특성 덕분에 자동으로 채워집니다.</param>
        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            // 이벤트 핸들러가 연결되어 있으면(null이 아니면) 이벤트를 발생시킵니다.
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        /// <summary>
        /// 속성 값을 설정하고, 값이 실제로 변경된 경우에만 PropertyChanged 이벤트를 발생시킵니다.
        /// </summary>
        /// <typeparam name="T">속성의 타입입니다.</typeparam>
        /// <param name="storage">속성 값을 저장하는 private 필드 (backing field)입니다.</param>
        /// <param name="value">설정하려는 새로운 값입니다.</param>
        /// <param name="propertyName">변경된 속성의 이름입니다. [CallerMemberName] 특성 덕분에 자동으로 채워집니다.</param>
        /// <returns>값이 성공적으로 변경되었으면 true, 그렇지 않으면 false를 반환합니다.</returns>
        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            // 기존 값과 새 값이 동일하면 아무 작업도 수행하지 않고 false 반환
            if (EqualityComparer<T>.Default.Equals(storage, value))
                return false;

            // 새 값으로 필드를 업데이트합니다.
            storage = value;
            // 속성 변경 알림 이벤트를 발생시킵니다.
            OnPropertyChanged(propertyName);
            // 값 변경이 성공했음을 나타내는 true 반환
            return true;
        }
    }