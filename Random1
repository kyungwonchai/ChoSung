아! 요청사항을 완벽하게 반영해서 다시 정리할게. 아래는 최신 조건들을 모두 반영한 MSSQL 2014 쿼리이며, 아주 상세한 주석 포함이야.

반영된 요구 조건 정리:
1. 분석 대상:
테이블: ExcelData

2. 주요 컬럼:
Composite Key: line1, model1, type1, ecn1, edition1

측정 컬럼 (총 16개, 모두 float):

ACT2_1 ~ ACT2_8

ACT2BEST_1 ~ ACT2BEST_8

3. 주어진 조건:
최근 5시간(time1 기준)의 데이터만 사용

각 Key + time1 단위마다:

ACT2 그룹의 이상치(Q1~Q3 범위) 중 최댓값

ACT2BEST 그룹의 이상치(Q1~Q3 범위) 중 최댓값

→ 둘 중 더 작은 값 = NeckCT

각 Key 그룹마다 NeckCT가 가장 작은 시간(time1) 의 데이터 1건만 조회

0보다 큰 값만 이상치 후보로 인정 (0은 무시)

최종 쿼리 (MSSQL 2014 + 주석 완전 상세)
sql
코드 복사
-- 1. 최근 5시간 이내의 데이터 필터링
WITH RawData AS (
    SELECT
        id1, line1, model1, type1, ecn1, edition1, time1,
        ACT2_1, ACT2_2, ACT2_3, ACT2_4,
        ACT2_5, ACT2_6, ACT2_7, ACT2_8,
        ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
        ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- 2. 16개 CT 컬럼을 행 단위로 UNPIVOT + 값이 0보다 큰 경우만 유지
Unpivoted AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT2_1, ACT2_2, ACT2_3, ACT2_4,
            ACT2_5, ACT2_6, ACT2_7, ACT2_8,
            ACT2BEST_1, ACT2BEST_2, ACT2BEST_3, ACT2BEST_4,
            ACT2BEST_5, ACT2BEST_6, ACT2BEST_7, ACT2BEST_8
        )
    ) AS u
    WHERE Value > 0
),

-- 3. 컬럼별 분위수 계산 (1사분위 Q1, 3사분위 Q3)
WithQuantiles AS (
    SELECT
        ColName,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3,
        line1, model1, type1, ecn1, edition1, time1, Value
    FROM Unpivoted
),

-- 4. 이상치 제거 (Q1~Q3 사이 값만 유지)
FilteredCT AS (
    SELECT *
    FROM WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

-- 5. 군 구분: ACT2 / ACT2BEST
WithGroupType AS (
    SELECT *,
        CASE 
            WHEN ColName LIKE 'ACT2BEST[_]%' THEN 'ACT2BEST'
            WHEN ColName LIKE 'ACT2[_]%' THEN 'ACT2'
        END AS GroupType
    FROM FilteredCT
),

-- 6. 각 (Key + time1) 조합에서 군별 최대값 추출
MaxPerRow AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(CASE WHEN GroupType = 'ACT2' THEN Value END) AS Max_ACT2,
        MAX(CASE WHEN GroupType = 'ACT2BEST' THEN Value END) AS Max_ACT2BEST
    FROM WithGroupType
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- 7. NeckCT 계산: 두 군의 최대값 중 더 작은 값
WithNeckCT AS (
    SELECT *,
        CASE 
            WHEN Max_ACT2 < Max_ACT2BEST THEN Max_ACT2
            ELSE Max_ACT2BEST
        END AS NeckCT
    FROM MaxPerRow
),

-- 8. 각 고유 Key 그룹에서 NeckCT가 가장 낮은 시간만 추출 (ROW_NUMBER 이용)
Ranked AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY line1, model1, type1, ecn1, edition1
            ORDER BY NeckCT ASC
        ) AS RN
    FROM WithNeckCT
)

-- 9. 최종 결과: RN=1인 행만 조회 (즉, NeckCT 가장 낮은 1건)
SELECT
    line1, model1, type1, ecn1, edition1, time1,
    Max_ACT2, Max_ACT2BEST,
    NeckCT
FROM Ranked
WHERE RN = 1
ORDER BY line1, model1, type1, ecn1, edition1;
결과 예시
line1	model1	type1	ecn1	edition1	time1	Max_ACT2	Max_ACT2BEST	NeckCT
SMD_12	A100	PKG1	E321	R1	2025-03-28 13:00	0.48	0.52	0.48
이 쿼리는:

각 ACT2, ACT2BEST 컬럼별 이상치 제거 후

시간대별로 군별 max를 계산하고

NeckCT (두 군 중 작은 값)를 구해

각 고유 조합별로 가장 이상적인 시간(time1)을 뽑아주는 구조야.
