

import React, { useState, useMemo, useEffect, useCallback } from 'react';
import { Note, LinkedMemo, ScratchpadItem, AIAgent, CodeSnapshot, LinkItem, ImageMemo, BackupData, Prompt, HtmlDoc, MarkdownDoc, PlantUMLDoc, SecretMemo } from './types';

// Import Components
import Sidebar from './components/Header';
import NoteEditor from './components/NoteEditor';
import SearchBar from './components/SearchBar';
import TagFilter from './components/TagFilter';
import Dashboard from './components/Dashboard';
import NoteDetailModal from './components/NoteDetailModal';
import ConfirmationModal, { ModalConfig } from './components/ConfirmationModal';
import Scratchpad from './components/Scratchpad';
import CodeDiffTool from './components/CodeDiffTool';
import AIAgentTool from './components/AIAgentTool';
import LinkTool from './components/LinkTool';
import ImageMemoTool from './components/ImageMemoTool';
import SettingsTool from './components/SettingsTool';
import AllMemosBoard from './components/AllMemosBoard';
import AIFilter from './components/AIFilter';
import KnowledgeGraph from './components/KnowledgeGraph';
import PromptLibrary from './components/PromptLibrary';
import AITextbook from './components/AITextbook';
import LoginScreen from './components/LoginScreen';
import HtmlDocTool from './components/HtmlDocTool';
import MarkdownDocTool from './components/MarkdownDocTool';
import PlantUMLTool from './components/PlantUMLTool';
import SecretMemoTool from './components/SecretMemoTool';
import SecretLoginModal from './components/SecretLoginModal';


type View = 'dashboard' | 'editor' | 'scratchpad' | 'diff' | 'agents' | 'links' | 'images' | 'all' | 'settings' | 'prompts' | 'graph' | 'textbook' | 'html' | 'markdown' | 'plantuml' | 'secret';
type DashboardView = 'calendar' | 'chart' | 'kanban';

const API_URL = 'http://localhost:5000/api'; // Assume the backend runs here

function App() {
  // --- AUTHENTICATION CONTROL ---
  // Note: Auth state is kept in local storage for simplicity, but in a real app, this would use JWT tokens from the backend.
  const [isAuthenticated, setIsAuthenticated] = useState(() => !!localStorage.getItem('zenith-auth-token'));
  const [isSecretAuthenticated, setIsSecretAuthenticated] = useState(() => !!localStorage.getItem('zenith-secret-auth-token'));
  const [showSecretLogin, setShowSecretLogin] = useState(false);

  const handleLogin = (password: string): boolean => {
    if (password === 'kwkw2323') {
      localStorage.setItem('zenith-auth-token', 'true');
      setIsAuthenticated(true);
      return true;
    }
    return false;
  };
  
  const handleSecretLogin = (password: string): boolean => {
      if (password === 'kw1121') {
          localStorage.setItem('zenith-secret-auth-token', 'true');
          setIsSecretAuthenticated(true);
          setShowSecretLogin(false);
          setView('secret');
          return true;
      }
      return false;
  }

  const handleLogout = () => {
    localStorage.removeItem('zenith-auth-token');
    localStorage.removeItem('zenith-secret-auth-token');
    setIsAuthenticated(false);
    setIsSecretAuthenticated(false);
  };

  // --- STATE MANAGEMENT ---
  const [notes, setNotes] = useState<Note[]>([]);
  const [linkedMemos, setLinkedMemos] = useState<LinkedMemo[]>([]);
  const [scratchpads, setScratchpads] = useState<ScratchpadItem[]>([]);
  const [agents, setAgents] = useState<AIAgent[]>([]);
  const [snapshots, setSnapshots] = useState<CodeSnapshot[]>([]);
  const [links, setLinks] = useState<LinkItem[]>([]);
  const [imageMemos, setImageMemos] = useState<ImageMemo[]>([]);
  const [prompts, setPrompts] = useState<Prompt[]>([]);
  const [htmlDocs, setHtmlDocs] = useState<HtmlDoc[]>([]);
  const [markdownDocs, setMarkdownDocs] = useState<MarkdownDoc[]>([]);
  const [plantUMLDocs, setPlantUMLDocs] = useState<PlantUMLDoc[]>([]);
  const [secretMemos, setSecretMemos] = useState<SecretMemo[]>([]);
  
  const [isLoading, setIsLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  
  const [view, setView] = useState<View>('dashboard');
  const [dashboardView, setDashboardView] = useState<DashboardView>('kanban');

  const [searchTerm, setSearchTerm] = useState('');
  const [selectedTag, setSelectedTag] = useState<string | null>(null);
  const [selectedAISource, setSelectedAISource] = useState<string | null>(null);
  
  const [noteToEdit, setNoteToEdit] = useState<Note | null>(null);
  const [viewingNote, setViewingNote] = useState<Note | null>(null);
  const [selectedPromptId, setSelectedPromptId] = useState<string | null>(null);
  
  const [modalConfig, setModalConfig] = useState<ModalConfig | null>(null);
  
  // --- API HELPER ---
  const apiCall = useCallback(async (endpoint: string, options: RequestInit = {}) => {
    try {
      const response = await fetch(`${API_URL}${endpoint}`, {
        ...options,
        headers: {
          'Content-Type': 'application/json',
          ...options.headers,
        },
      });
      if (!response.ok) {
        const errorData = await response.json().catch(() => ({ message: 'An unknown error occurred' }));
        throw new Error(errorData.message || `HTTP error! status: ${response.status}`);
      }
      return response.json();
    } catch (err: any) {
      console.error(`API call to ${endpoint} failed:`, err);
      setError(err.message);
      showModal({type: 'alert', title: 'API Error', message: `Could not connect to the backend.\n\nDetails: ${err.message}`});
      throw err; // Re-throw to be caught by caller
    }
  }, []);

  // --- DATA FETCHING ---
  const fetchData = useCallback(async () => {
    setIsLoading(true);
    setError(null);
    try {
      const [
        notesData, linkedMemosData, scratchpadsData, agentsData, snapshotsData, 
        linksData, imageMemosData, promptsData, htmlDocsData, markdownDocsData, 
        plantUMLDocsData, secretMemosData
      ] = await Promise.all([
        apiCall('/notes'),
        apiCall('/linked_memos'),
        apiCall('/scratchpads'),
        apiCall('/agents'),
        apiCall('/snapshots'),
        apiCall('/links'),
        apiCall('/image_memos'),
        apiCall('/prompts'),
        apiCall('/html_docs'),
        apiCall('/markdown_docs'),
        apiCall('/plantuml_docs'),
        apiCall('/secret_memos'),
      ]);
      setNotes(notesData);
      setLinkedMemos(linkedMemosData);
      setScratchpads(scratchpadsData);
      setAgents(agentsData);
      setSnapshots(snapshotsData);
      setLinks(linksData);
      setImageMemos(imageMemosData);
      setPrompts(promptsData);
      setHtmlDocs(htmlDocsData);
      setMarkdownDocs(markdownDocsData);
      setPlantUMLDocs(plantUMLDocsData);
      setSecretMemos(secretMemosData);
    } catch (err) {
      // Error is already set and shown in modal by apiCall helper
    } finally {
      setIsLoading(false);
    }
  }, [apiCall]);
  
  useEffect(() => {
    if (isAuthenticated) {
        fetchData();
    }
  }, [isAuthenticated, fetchData]);

  // --- DATA FILTERING ---
  const filteredNotes = useMemo(() => {
    return notes
      .filter(note => {
        const searchMatch = searchTerm
          ? note.content.toLowerCase().includes(searchTerm.toLowerCase()) ||
            (Array.isArray(note.tags) && note.tags.some(t => t.toLowerCase().includes(searchTerm.toLowerCase())))
          : true;
        const tagMatch = selectedTag ? (Array.isArray(note.tags) && note.tags.includes(selectedTag)) : true;
        const aiSourceMatch = selectedAISource ? note.aiSource === selectedAISource : true;
        return searchMatch && tagMatch && aiSourceMatch;
      })
      .sort((a, b) => new Date(b.updatedAt).getTime() - new Date(a.updatedAt).getTime());
  }, [notes, searchTerm, selectedTag, selectedAISource]);

  // --- HANDLERS ---
  const handleSetView = (newView: View) => {
      if (newView === 'secret') {
          if (isSecretAuthenticated) {
              setView('secret');
          } else {
              setShowSecretLogin(true);
          }
      } else {
          setView(newView);
      }
  };

  const handleSaveNote = async (data: Omit<Note, 'id' | 'createdAt' | 'updatedAt' | 'viewCount'>) => {
    try {
      if (noteToEdit) {
        const updatedNote = await apiCall(`/notes/${noteToEdit.id}`, {
          method: 'PUT',
          body: JSON.stringify(data),
        });
        setNotes(prev => prev.map(n => (n.id === noteToEdit.id ? updatedNote : n)));
        setNoteToEdit(null);
      } else {
        const newNote = await apiCall('/notes', {
          method: 'POST',
          body: JSON.stringify(data),
        });
        setNotes(prev => [newNote, ...prev]);
      }
      if (view === 'editor') {
        setView('dashboard');
      }
    } catch(e) { /* error handled by apiCall */ }
  };

  const handleDeleteNote = (id: string) => {
    apiCall(`/notes/${id}`, { method: 'DELETE' })
      .then(() => {
        setNotes(prev => prev.filter(n => n.id !== id));
        // Also remove linked memos on the frontend for responsiveness
        setLinkedMemos(prev => prev.filter(memo => memo.parentId !== id)); 
        setViewingNote(null);
      })
      .catch(e => { /* error handled by apiCall */});
  };
  
  const handleEditNote = (note: Note) => {
    setNoteToEdit(note);
    setViewingNote(null);
    setView('editor');
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };
  
  const handleCancelEdit = () => {
    setNoteToEdit(null);
  };
  
  const handleViewNote = (note: Note) => {
     apiCall(`/notes/${note.id}/view`, { method: 'POST'})
        .then(updatedNote => setNotes(prev => prev.map(n => n.id === note.id ? updatedNote : n)))
        .catch(e => {/* if this fails, it's not critical */});
     setViewingNote(note);
  };

  const handleViewPrompt = (prompt: Prompt) => {
    setView('prompts');
    setSelectedPromptId(prompt.id);
    window.scrollTo({ top: 0, behavior: 'smooth' });
  };

  const handleConvertToTask = async (item: { id: string; content: string; type: 'Linked Memo' | 'Scratchpad' }) => {
    try {
        const newNote = await apiCall('/notes/from_task', {
            method: 'POST',
            body: JSON.stringify(item)
        });
        setNotes(prev => [newNote, ...prev]);

        if (item.type === 'Linked Memo') {
          const updatedMemo = await apiCall(`/linked_memos/${item.id}`, { method: 'PUT', body: JSON.stringify({ isTask: true }) });
          setLinkedMemos(prev => prev.map(memo => memo.id === item.id ? updatedMemo : memo));
        } else if (item.type === 'Scratchpad') {
          const updatedPad = await apiCall(`/scratchpads/${item.id}`, { method: 'PUT', body: JSON.stringify({ isTask: true }) });
          setScratchpads(prev => prev.map(pad => pad.id === item.id ? updatedPad : pad));
        }
        
        showModal({ type: 'alert', title: 'Success', message: `${item.type} has been converted to a new task in the 'To Do' column.` });

    } catch(e) { /* error handled by apiCall */ }
  };

  const showModal = (config: ModalConfig) => {
    setModalConfig(config);
  };

  const setters = { setNotes, setLinkedMemos, setScratchpads, setAgents, setSnapshots, setLinks, setImageMemos, setPrompts, setHtmlDocs, setMarkdownDocs, setPlantUMLDocs, setSecretMemos };

  // --- RENDER LOGIC ---
  const renderContent = () => {
    // The textbook view has no data dependencies and must be accessible
    // even if the API connection fails, as it contains setup instructions.
    if (view === 'textbook') {
      return <AITextbook />;
    }

    if (isLoading) {
        return <div className="flex justify-center items-center h-full"><div className="animate-spin rounded-full h-16 w-16 border-t-2 border-b-2 border-accent"></div></div>;
    }
    
    if (error) {
         return <div className="text-center py-24 bg-secondary rounded-xl animate-fade-in">
          <h3 className="text-xl font-semibold text-red-400">Connection Error</h3>
          <p className="text-medium mt-2">Failed to fetch data from the API server.</p>
          <p className="text-sm text-gray-400 mt-2">
            Please ensure the backend server is running and accessible at <code className="bg-primary px-1.5 py-0.5 rounded-md font-mono">{API_URL}</code>.
          </p>
          <p className="text-sm text-gray-400 mt-1">
            You can find server setup instructions in the <button className="text-accent hover:underline font-semibold" onClick={() => setView('textbook')}>EDU Section</button>.
          </p>
          <button onClick={fetchData} className="mt-6 px-5 py-2.5 bg-accent text-white font-semibold rounded-lg hover:brightness-125 transition">
            Try Again
          </button>
        </div>
    }

    switch (view) {
      case 'dashboard':
        return (
          <>
            <div className="space-y-4 mb-6">
                <SearchBar onSearch={setSearchTerm} />
                <div className="flex flex-col sm:flex-row gap-4">
                    <TagFilter notes={notes} selectedTag={selectedTag} onSelectTag={setSelectedTag} />
                    <AIFilter notes={notes} selectedSource={selectedAISource} onSelectSource={setSelectedAISource} />
                </div>
            </div>
            <Dashboard 
              notes={filteredNotes} 
              linkedMemos={linkedMemos} 
              onViewNote={handleViewNote}
              onEditNote={handleEditNote}
              view={dashboardView}
              setDashboardView={setDashboardView}
            />
          </>
        );
      case 'editor':
          return <NoteEditor onSave={handleSaveNote} noteToEdit={noteToEdit} onCancelEdit={handleCancelEdit} showModal={showModal}/>;
      case 'scratchpad':
        return <Scratchpad scratchpads={scratchpads} setScratchpads={setScratchpads} showModal={showModal} onConvertToTask={handleConvertToTask} apiCall={apiCall}/>;
      case 'diff':
        return <CodeDiffTool snapshots={snapshots} setSnapshots={setSnapshots} showModal={showModal} apiCall={apiCall} />;
      case 'agents':
        return <AIAgentTool agents={agents} setAgents={setAgents} showModal={showModal} apiCall={apiCall} />;
      case 'html':
        return <HtmlDocTool docs={htmlDocs} setDocs={setHtmlDocs} showModal={showModal} apiCall={apiCall}/>;
      case 'markdown':
        return <MarkdownDocTool docs={markdownDocs} setDocs={setMarkdownDocs} showModal={showModal} apiCall={apiCall} />;
      case 'plantuml':
        return <PlantUMLTool docs={plantUMLDocs} setDocs={setPlantUMLDocs} showModal={showModal} apiCall={apiCall} />;
      case 'links':
        return <LinkTool links={links} setLinks={setLinks} showModal={showModal} apiCall={apiCall} />;
      case 'images':
        return <ImageMemoTool memos={imageMemos} setMemos={setImageMemos} showModal={showModal} apiCall={apiCall} />;
      case 'all':
        // This component is complex, so for now we pass the setters and let it manage its state.
        // A full refactor would involve creating specific handlers here.
        return <AllMemosBoard 
                  notes={notes} setNotes={setNotes}
                  linkedMemos={linkedMemos} setLinkedMemos={setLinkedMemos}
                  scratchpads={scratchpads} setScratchpads={setScratchpads}
                  snapshots={snapshots} setSnapshots={setSnapshots}
                  htmlDocs={htmlDocs} setHtmlDocs={setHtmlDocs}
                  markdownDocs={markdownDocs} setMarkdownDocs={setMarkdownDocs}
                  plantUMLDocs={plantUMLDocs} setPlantUMLDocs={setPlantUMLDocs}
                  showModal={showModal}
                  onConvertToTask={handleConvertToTask}
                  apiCall={apiCall}
                />
      case 'prompts':
        return <PromptLibrary 
                  prompts={prompts} 
                  setPrompts={setPrompts} 
                  showModal={showModal} 
                  selectedPromptId={selectedPromptId}
                  setSelectedPromptId={setSelectedPromptId}
                  apiCall={apiCall}
                />;
      case 'graph':
        return <KnowledgeGraph 
                  notes={notes} 
                  prompts={prompts} 
                  onViewNote={handleViewNote}
                  onViewPrompt={handleViewPrompt}
                />;
      case 'secret':
        // Fix: Pass `setSecretMemos` instead of the non-existent `setMemos`.
        return <SecretMemoTool memos={secretMemos} setMemos={setSecretMemos} showModal={showModal} apiCall={apiCall} />;
      case 'settings':
        return <SettingsTool apiCall={apiCall} showModal={showModal} onRefreshData={fetchData} />;
      default:
        return null;
    }
  };
  
  if (!isAuthenticated) {
    return <LoginScreen onLogin={handleLogin} />;
  }

  return (
    <div className="bg-primary min-h-screen text-light font-sans flex">
      <Sidebar currentView={view} setView={handleSetView} onLogout={handleLogout} />
      
      <div className="flex-grow pl-20 w-full overflow-y-auto">
        <main className="px-4 sm:px-6 lg:px-8 py-8 h-full">
          {renderContent()}
        </main>
      </div>
      
      {showSecretLogin && <SecretLoginModal onLogin={handleSecretLogin} onClose={() => setShowSecretLogin(false)} />}

      {viewingNote && (
        <NoteDetailModal
          note={viewingNote}
          linkedMemos={linkedMemos}
          setLinkedMemos={setLinkedMemos}
          onClose={() => setViewingNote(null)}
          onDelete={handleDeleteNote}
          onEdit={handleEditNote}
          showModal={showModal}
          onConvertToTask={handleConvertToTask}
          apiCall={apiCall}
        />
      )}
      
      <ConfirmationModal config={modalConfig} onClose={() => setModalConfig(null)} />
    </div>
  );
}
