5. 마스터 데이터 ViewModel (ViewModels/MasterDataViewModel.cs) (신규)

마스터 데이터 목록 관리 및 CRUD 로직 포함.
이름 변경 시 연쇄 업데이트 로직 구현.
C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.Data.Entity;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    public class MasterDataViewModel : ViewModelBase
    {
        private readonly LockerDbContext _context;

        // 각 마스터 데이터 타입별 컬렉션
        private ObservableCollection<LockerType> _lockerTypes;
        private ObservableCollection<Floor> _floors;
        private ObservableCollection<Zone> _zones;
        private ObservableCollection<SubPart> _subParts;
        private ObservableCollection<Administrator> _administrators;

        // 각 리스트에서 선택된 항목
        private MasterDataBase _selectedItem; // 공통 선택 항목 (타입 구분 필요)
        private string _newItemName; // 새 항목 추가 시 이름 입력용

        public ObservableCollection<LockerType> LockerTypes { get => _lockerTypes; set => SetProperty(ref _lockerTypes, value); }
        public ObservableCollection<Floor> Floors { get => _floors; set => SetProperty(ref _floors, value); }
        public ObservableCollection<Zone> Zones { get => _zones; set => SetProperty(ref _zones, value); }
        public ObservableCollection<SubPart> SubParts { get => _subParts; set => SetProperty(ref _subParts, value); }
        public ObservableCollection<Administrator> Administrators { get => _administrators; set => SetProperty(ref _administrators, value); }

        public MasterDataBase SelectedItem { get => _selectedItem; set => SetProperty(ref _selectedItem, value); }
        public string NewItemName { get => _newItemName; set => SetProperty(ref _newItemName, value); }

        // Commands
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; } // 마스터 데이터 변경 저장

        // 이벤트 (마스터 데이터 변경 시 MainViewModel에 알림)
        public event EventHandler<string> MasterDataChanged;

        public MasterDataViewModel(LockerDbContext context)
        {
            _context = context;
            // 컬렉션 초기화
            LockerTypes = new ObservableCollection<LockerType>();
            Floors = new ObservableCollection<Floor>();
            Zones = new ObservableCollection<Zone>();
            SubParts = new ObservableCollection<SubPart>();
            Administrators = new ObservableCollection<Administrator>();

            // Command 초기화 (parameter로 어떤 타입의 마스터 데이터인지 구분)
            AddItemCommand = new RelayCommand(AddItem, _ => !string.IsNullOrWhiteSpace(NewItemName));
            DeleteItemCommand = new RelayCommand(DeleteItem, _ => SelectedItem != null);
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync());

            // 초기 데이터 로드
            _ = LoadAllMasterDataAsync();
        }

        // 모든 마스터 데이터 로드
        public async Task LoadAllMasterDataAsync()
        {
            try
            {
                LockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).ToListAsync());
                Floors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(t => t.Name).ToListAsync());
                Zones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(t => t.Name).ToListAsync());
                SubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(t => t.Name).ToListAsync());
                Administrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(t => t.Name).ToListAsync());
            }
            catch (Exception ex)
            {
                MessageBox.Show($"마스터 데이터 로딩 중 오류 발생:\n{ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        // 새 항목 추가 (UI 컬렉션에만 추가, 저장은 별도)
        private void AddItem(object parameter)
        {
            string itemType = parameter as string;
            if (string.IsNullOrWhiteSpace(itemType) || string.IsNullOrWhiteSpace(NewItemName)) return;

            // 중복 이름 체크 (UI 컬렉션 기준)
            bool exists = false;
            switch (itemType)
            {
                case "LockerType": exists = LockerTypes.Any(i => i.Name.Equals(NewItemName, StringComparison.OrdinalIgnoreCase)); break;
                case "Floor": exists = Floors.Any(i => i.Name.Equals(NewItemName, StringComparison.OrdinalIgnoreCase)); break;
                case "Zone": exists = Zones.Any(i => i.Name.Equals(NewItemName, StringComparison.OrdinalIgnoreCase)); break;
                case "SubPart": exists = SubParts.Any(i => i.Name.Equals(NewItemName, StringComparison.OrdinalIgnoreCase)); break;
                case "Administrator": exists = Administrators.Any(i => i.Name.Equals(NewItemName, StringComparison.OrdinalIgnoreCase)); break;
            }
            if (exists)
            {
                MessageBox.Show($"'{NewItemName}' 항목이 이미 존재합니다.", "중복 오류", MessageBoxButton.OK, Warning);
                return;
            }


            MasterDataBase newItem = null;
            switch (itemType)
            {
                case "LockerType": newItem = new LockerType { Name = NewItemName }; LockerTypes.Add((LockerType)newItem); break;
                case "Floor": newItem = new Floor { Name = NewItemName }; Floors.Add((Floor)newItem); break;
                case "Zone": newItem = new Zone { Name = NewItemName }; Zones.Add((Zone)newItem); break;
                case "SubPart": newItem = new SubPart { Name = NewItemName }; SubParts.Add((SubPart)newItem); break;
                case "Administrator": newItem = new Administrator { Name = NewItemName }; Administrators.Add((Administrator)newItem); break;
            }

            if (newItem != null)
            {
                _context.Entry(newItem).State = EntityState.Added; // 컨텍스트에 추가 상태로 등록
                NewItemName = string.Empty; // 입력 필드 초기화
                SelectedItem = newItem; // 새로 추가된 항목 선택
            }
        }

        // 선택된 항목 삭제 (UI 컬렉션에서 제거, DB 삭제는 저장 시)
        private void DeleteItem(object parameter)
        {
            if (SelectedItem == null) return;

            // 삭제 확인 메시지
            if (MessageBox.Show($"'{SelectedItem.Name}' 항목을 정말 삭제하시겠습니까?\n연결된 사물함 정보가 있다면 문제가 발생할 수 있습니다.", "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) != MessageBoxResult.Yes)
            {
                return;
            }

            // DB 컨텍스트에서 삭제 상태로 표시
            _context.Entry(SelectedItem).State = EntityState.Deleted;

            // UI 컬렉션에서도 제거
            if (SelectedItem is LockerType lt) LockerTypes.Remove(lt);
            else if (SelectedItem is Floor fl) Floors.Remove(fl);
            else if (SelectedItem is Zone zo) Zones.Remove(zo);
            else if (SelectedItem is SubPart sp) SubParts.Remove(sp);
            else if (SelectedItem is Administrator ad) Administrators.Remove(ad);

            SelectedItem = null; // 선택 해제
        }

        // 마스터 데이터 변경 사항 저장 (연쇄 업데이트 포함)
        private async Task SaveMasterDataChangesAsync()
        {
            // 변경된 항목들 (특히 이름이 변경된 경우) 식별
            var changedEntries = _context.ChangeTracker.Entries<MasterDataBase>()
                                       .Where(e => e.State == EntityState.Modified)
                                       .ToList(); // 원본 값 비교 위해 리스트로 복사

            var renamedItems = new List<(MasterDataBase item, string oldName)>();
            foreach (var entry in changedEntries)
            {
                // 이름 속성의 원본 값 가져오기
                var originalName = entry.OriginalValues["Name"] as string;
                var currentName = entry.CurrentValues["Name"] as string;

                // 이름이 실제로 변경되었는지 확인
                if (originalName != null && currentName != null && originalName != currentName)
                {
                    renamedItems.Add((entry.Entity, originalName));
                }
            }

            try
            {
                // 1. 마스터 테이블 변경 사항 저장 (추가/삭제/이름 외 수정)
                int masterChanges = await _context.SaveChangesAsync();

                // 2. 이름 변경에 따른 연쇄 업데이트 수행
                if (renamedItems.Any())
                {
                    bool cascadeSuccess = await PerformCascadeUpdate(renamedItems);
                    if (!cascadeSuccess)
                    {
                        MessageBox.Show("연쇄 업데이트 중 오류가 발생했습니다. 일부 데이터가 업데이트되지 않았을 수 있습니다.", "연쇄 업데이트 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                        // 필요 시 롤백 또는 추가 조치
                    }
                }

                MessageBox.Show($"마스터 데이터 변경 사항({masterChanges}건) 및 연쇄 업데이트가 저장되었습니다.", "저장 완료", MessageBoxButton.OK, Information);

                // 변경 사항 저장 후 목록 새로고침 및 이벤트 발생
                await LoadAllMasterDataAsync();
                // 어떤 타입이 변경되었는지 이벤트 발생 (MainViewModel에서 콤보박스 갱신 위함)
                if (changedEntries.Any()) MasterDataChanged?.Invoke(this, changedEntries.First().Entity.GetType().Name);
                else if (renamedItems.Any()) MasterDataChanged?.Invoke(this, renamedItems.First().item.GetType().Name);

            }
            catch (DbUpdateException dbEx)
            {
                // UNIQUE 제약 조건 위반 등 DB 오류 처리
                MessageBox.Show($"데이터베이스 저장 오류: {dbEx.InnerException?.Message ?? dbEx.Message}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                // 변경 사항 롤백 또는 재시도 로직 필요
            }
            catch (Exception ex)
            {
                MessageBox.Show($"마스터 데이터 저장 중 오류 발생:\n{ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }


        /// <summary>
        /// 마스터 데이터 이름 변경 시 LockerAssignments 테이블의 관련 필드를 연쇄적으로 업데이트합니다.
        /// </summary>
        private async Task<bool> PerformCascadeUpdate(List<(MasterDataBase item, string oldName)> renamedItems)
        {
            bool success = true;
            foreach (var renameInfo in renamedItems)
            {
                var item = renameInfo.item;
                var oldName = renameInfo.oldName;
                var newName = item.Name; // 현재 이름 (새 이름)

                string fieldToUpdate = "";
                Type itemType = item.GetType();

                if (itemType == typeof(LockerType)) fieldToUpdate = nameof(LockerAssignment.LockerType);
                else if (itemType == typeof(Floor)) fieldToUpdate = nameof(LockerAssignment.Floor);
                else if (itemType == typeof(Zone)) fieldToUpdate = nameof(LockerAssignment.Zone);
                else if (itemType == typeof(SubPart)) fieldToUpdate = nameof(LockerAssignment.SubPart);
                else if (itemType == typeof(Administrator)) fieldToUpdate = nameof(LockerAssignment.Administrator);
                else continue; // 해당 없는 타입이면 건너뜀

                try
                {
                    // EF6에서 동적 업데이트 또는 Raw SQL 사용 필요
                    // 예: Raw SQL 사용 (SQL Injection 주의 - 파라미터화 권장)
                    string sql = $"UPDATE LockerAssignments SET [{fieldToUpdate}] = {{0}} WHERE [{fieldToUpdate}] = {{1}}";
                    int updatedCount = await _context.Database.ExecuteSqlCommandAsync(sql, newName, oldName);

                    // 연쇄 업데이트 로그 기록
                    var log = new ActivityLog
                    {
                        Timestamp = DateTime.Now,
                        UserName = "System", // 또는 실제 관리자
                        Action = "CascadeUpdate",
                        EntityType = itemType.Name,
                        EntityId = item.Id,
                        Description = $"마스터 [{itemType.Name}] 이름 변경 ('{oldName}' -> '{newName}')으로 인해 LockerAssignments {updatedCount}건 업데이트됨."
                    };
                    _context.ActivityLogs.Add(log);

                    // 개별 저장 또는 마지막에 한번에 저장
                    await _context.SaveChangesAsync(); // 로그 저장
                }
                catch (Exception ex)
                {
                     MessageBox.Show($"'{oldName}' -> '{newName}' 연쇄 업데이트 중 오류 ({fieldToUpdate} 필드):\n{ex.Message}", "연쇄 업데이트 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                     success = false; // 하나라도 실패하면 실패로 표시
                     // 오류 발생 시 해당 항목 업데이트 중단 또는 롤백 고려
                }
            }
            return success;
        }