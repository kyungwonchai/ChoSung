송합니다. 다시 한 번 정확하게 반영하여, 요청하신 요구 사항을 바탕으로 **파일의 시퀀스 플래그(1, 2, 3)**에 따른 작업 처리, 각 내부 함수에 따라 도형을 여러 개 배치하여 작업이 완료될 때마다 각각의 도형 색상이 변경되도록 수정하겠습니다. 또한, 작업이 순차적으로 실행되어 이전 작업이 완료되기 전에는 다음 작업이 시작되지 않도록 변경하겠습니다.

주요 요구 사항:
**파일의 시퀀스 플래그(1, 2, 3)**에 따라 작업이 다르게 구성.
각 작업 내부에 여러 함수가 있고, 각 함수마다 도형이 있으며, 함수가 완료될 때마다 해당 도형의 색상이 변환.
작업은 행 순서대로 실행되며, 위의 작업이 끝나야 다음 작업이 시작.
모든 작업은 동시 실행되지 않도록 구현.
1. TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;

/// <summary>
/// TaskModel은 개별 작업의 상태를 관리하고, 작업의 시작 및 상태를 업데이트합니다.
/// PLC 시퀀스 플래그에 따라 다른 작업을 묶어 실행하며, 각 함수는 도형과 연동되어 상태를 표시합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }

    // 도형 색상 리스트 (각 함수에 따른 도형 색상 상태를 반영)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        // 각 함수마다 도형을 설정 (시퀀스에 따라 다른 개수)
        FunctionStatusColors = new ObservableCollection<Brush>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);

        InitializeFunctionColors(); // 초기 도형 상태 설정
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트

        switch (SequenceFlag)
        {
            case 1: // 시퀀스 플래그가 1인 경우: 함수 A, B, C 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskA));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskC));
                break;
            case 2: // 시퀀스 플래그가 2인 경우: 함수 C, B, D 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskC));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskD));
                break;
            case 3: // 시퀀스 플래그가 3인 경우: 함수 A, B, E 실행
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(0, ExecuteTaskA));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(1, ExecuteTaskB));
                _taskQueue.EnqueueTask(() => ExecuteTaskWithColor(2, ExecuteTaskE));
                break;
        }
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
        OnPropertyChanged(nameof(FunctionStatusColors));

        await task(); // 작업 실행

        FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
        OnPropertyChanged(nameof(FunctionStatusColors));
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        // 시퀀스 플래그에 따라 함수 개수가 다름 (각 함수당 도형 1개)
        int functionCount = SequenceFlag == 1 || SequenceFlag == 3 ? 3 : 4;

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task A Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task B Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task C Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task D Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task E Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
설명:
**FunctionStatusColors**는 각 작업에 대한 함수의 도형 색상을 저장합니다. 작업이 진행되면 스카이블루, 작업이 완료되면 녹색으로 변경됩니다.
**시퀀스 플래그(1, 2, 3)**에 따라 각기 다른 함수 묶음이 실행되며, 각 함수는 도형과 연동되어 완료 시 색상이 변합니다.
각 함수 완료 시 도형 색상이 실시간으로 업데이트되며, 모든 함수가 순차적으로 실행됩니다.
2. MainWindow.xaml (UI 업데이트)
xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- MAG_NO를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                
                <!-- MAG_QTY를 표시하는 열 -->
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*"/>

                <!-- PO_NO를 표시하는 열 -->
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>
                
                <!-- 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Progress Status" Binding="{Binding ProgressText}" Width="2*"/>

                <!-- 각 함수 상태 도형을 표시하는 열 -->
                <DataGridTemplateColumn Header="Function Status" Width="2*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <ItemsControl ItemsSource="{Binding FunctionStatusColors}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <Ellipse Width="20" Height="20" Fill="{Binding}" Margin="5"/>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                                <ItemsControl.ItemsPanel>
                                    <ItemsPanelTemplate>
                                        <StackPanel Orientation="Horizontal"/>
                                    </ItemsPanelTemplate>
                                </ItemsControl.ItemsPanel>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
                
                <!-- 일시정지 및 재개 버튼 -->
                <DataGridTemplateColumn Header="Controls">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <Button Content="Pause" Command="{Binding PauseCommand}" Margin="5"/>
                                <Button Content="Resume" Command="{Binding ResumeCommand}" Margin="5"/>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
설명:
**ItemsControl**을 사용해 각 작업 함수에 대한 도형을 나열하고, 함수가 실행될 때마다 색상이 실시간으로 업데이트되도록 구성했습니다.
각 작업이 순차적으로 실행되며, 작업의 상태를 실시간으로 업데이트합니다.
3. MainViewModel.cs (수정된 코드)
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

/// <summary>
/// MainViewModel은 UI와 로직을 연결하는 ViewModel입니다.
/// 로그 파일을 감지하고 작업을 처리하는 역할을 합니다.
/// </summary>
public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 파일 처리기(FileProcessor) 인스턴스 (새 파일을 감지하여 작업 큐에 추가)
    private FileProcessor _fileProcessor;

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    // 명령어: 모든 작업 일시정지
    public ICommand PauseAllCommand { get; }

    // 명령어: 모든 작업 재개
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 파일 프로세서를 초기화하고 파일 감지 처리
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", OnLogEntryDetected);
        _fileProcessor.StartProcessing(); // 파일 감지 시작

        // 명령어 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    private void OnLogEntryDetected(LogEntry logEntry)
    {
        var task = new TaskModel(logEntry, _taskQueue);
        TaskList.Add(task); // 작업 목록에 추가

        // 바로 작업 시작
        task.StartTask(); // 작업 바로 시작
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();
    }
}
설명:
MainViewModel에서 새로운 파일이 감지될 때마다 작업을 순차적으로 실행하고, 작업 내 함수들이 완료될 때마다 도형의 색상을 업데이트합니다.
결론:
이제 시퀀스 플래그에 따라 각기 다른 작업을 묶어 실행하며, 각 함수마다 도형이 있고 함수가 완료될 때마다 실시간으로 도형 색상이 변환됩니다. 또한 작업은 순차적으로 실행되며, 이전 작업이 끝나기 전에는 다음 작업이 시작되지 않습니다.

이 구조는 모든 요청 사항을 반영한 최종 코드입니다. 추가적으로 수정이나 보완이 필요하다면 언제든지 말씀해 주세요!