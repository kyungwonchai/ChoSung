// MGSPMonitorControl/Services/BrokerClientService.cs
using System;
using System.IO;
using System.Net; // IPAddress 사용
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MGSPMonitorControl.Models;    // 로컬 모델 (여기서는 직접 사용 안 함)
using MonitorControl.SharedModels; // BrokerMessage 등 공용 모델
using Newtonsoft.Json;
using System.Configuration;     // App.config 사용

namespace MGSPMonitorControl.Services
{
    public interface IBrokerClientService
    {
        bool IsConnected { get; }
        Task<bool> ConnectAsync(); // 연결 성공 여부 반환
        Task DisconnectAsync();
        Task SendMessageAsync(BrokerMessage message);

        event Action<BrokerMessage> MessageReceived;
        event Action Connected;
        event Action Disconnected;
    }

    public class BrokerClientService : IBrokerClientService, IDisposable
    {
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;
        private volatile bool _isConnecting = false; // 동시 연결 시도 방지 (volatile 추가)
        private volatile bool _explicitlyDisconnected = false; // 사용자가 명시적으로 연결 끊었는지

        private readonly string _brokerIp = "127.0.0.1"; // 설정 실패 시 기본값
        private readonly int _brokerPort = 9001;      // 설정 실패 시 기본값
        private bool _configValid = false;          // 설정이 유효하게 로드되었는지

        public bool IsConnected => !_isDisposed && _tcpClient != null && _tcpClient.Connected &&
                                  _networkStream != null && _streamReader != null && _streamWriter != null;

        public event Action<BrokerMessage> MessageReceived;
        public event Action Connected;
        public event Action Disconnected;

        public BrokerClientService()
        {
            SafeConsoleLog("BrokerClientService: Constructor - Initializing...");
            string brokerAddressSetting = null;
            try
            {
                brokerAddressSetting = ConfigurationManager.AppSettings["BrokerAddress"];
                if (string.IsNullOrWhiteSpace(brokerAddressSetting))
                {
                    SafeConsoleLog($"[CONFIG_WARN] 'BrokerAddress' not found or empty in App.config. Using default: {_brokerIp}:{_brokerPort}");
                    // 기본값을 사용하므로 _configValid는 true로 설정될 수 있음 (만약 기본값이 유효하다면)
                }
            }
            catch (ConfigurationErrorsException confEx)
            {
                SafeConsoleLog($"[CRITICAL_CONFIG_ERROR] Failed to load App.config or AppSettings section: {confEx.Message}. Using default: {_brokerIp}:{_brokerPort}");
                // 이 경우에도 기본값을 사용하므로 _configValid는 기본값에 따라 결정
            }
            catch (Exception ex)
            {
                SafeConsoleLog($"[ERROR] Unexpected error reading BrokerAddress from App.config. Using default: {_brokerIp}:{_brokerPort}. Error: {ex.Message}");
            }

            string addressToParse = string.IsNullOrWhiteSpace(brokerAddressSetting) ? $"{_brokerIp}:{_brokerPort}" : brokerAddressSetting;
            var parts = addressToParse.Split(':');

            if (parts.Length == 2 &&
                IPAddress.TryParse(parts[0], out IPAddress ip) &&
                int.TryParse(parts[1], System.Globalization.NumberStyles.None, System.Globalization.CultureInfo.InvariantCulture, out int port) &&
                port > 0 && port <= 65535)
            {
                _brokerIp = ip.ToString();
                _brokerPort = port;
                _configValid = true; // 설정이 유효하게 파싱됨
                SafeConsoleLog($"BrokerClientService: Target Broker configured to {_brokerIp}:{_brokerPort}");
            }
            else
            {
                SafeConsoleLog($"[CONFIG_ERROR] Invalid 'BrokerAddress' format: '{addressToParse}'. Using default: {_brokerIp}:{_brokerPort}. This service might not connect.");
                // 기본값(_brokerIp, _brokerPort)이 설정되어 있으므로, _configValid는 true로 둘 수 있음.
                // 만약 기본값도 유효하지 않다면 false로 설정해야 함. 여기서는 기본값이 유효하다고 가정.
                _configValid = true; // 기본값으로라도 시도 가능하도록
            }
        }

        public async Task<bool> ConnectAsync()
        {
            if (!_configValid)
            {
                SafeConsoleLog("BrokerClientService: Broker configuration is invalid. Cannot attempt connection.");
                Disconnected?.Invoke();
                return false;
            }
            if (IsConnected)
            {
                SafeConsoleLog("BrokerClientService: Already connected.");
                return true;
            }
            if (_isDisposed)
            {
                SafeConsoleLog("BrokerClientService: Object is disposed. Cannot connect.");
                return false;
            }
            if (_isConnecting)
            {
                SafeConsoleLog("BrokerClientService: Connection attempt already in progress.");
                return false;
            }

            _isConnecting = true;
            _explicitlyDisconnected = false; // 새로운 연결 시도 시 명시적 끊김 플래그 리셋
            _cts?.Cancel();
            _cts?.Dispose();
            _cts = new CancellationTokenSource();
            var token = _cts.Token;

            try
            {
                SafeConsoleLog($"BrokerClientService: Attempting to connect to Broker: {_brokerIp}:{_brokerPort}");
                _tcpClient = new TcpClient();

                var connectTask = _tcpClient.ConnectAsync(_brokerIp, _brokerPort);
                var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(7), token);

                Task completedTask = await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false);

                if (token.IsCancellationRequested)
                {
                    SafeConsoleLog("BrokerClientService: Connection attempt cancelled by token during WhenAny.");
                    _tcpClient?.Close();
                    throw new OperationCanceledException("Connection cancelled by token.");
                }

                if (completedTask == timeoutDelayTask || !connectTask.IsCompleted)
                {
                    _tcpClient?.Close();
                    SafeConsoleLog($"BrokerClientService: Timeout or connect task did not complete connecting to Broker {_brokerIp}:{_brokerPort}.");
                    throw new TimeoutException("Connection attempt timed out.");
                }

                if (connectTask.IsFaulted) // 연결 중 예외 발생 (예: 서버 거부, 네트워크 경로 없음)
                {
                    _tcpClient?.Close();
                    SafeConsoleLog($"[ERROR] BrokerClientService: Connection task faulted: {connectTask.Exception?.GetBaseException().Message}");
                    throw connectTask.Exception?.GetBaseException() ?? new SocketException((int)SocketError.SocketError);
                }
                
                // 이 시점에서 connectTask.Status == TaskStatus.RanToCompletion 가정
                if (_tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    if (_networkStream == null) throw new NullReferenceException("NetworkStream is null after TcpClient connection.");
                    
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    
                    SafeConsoleLog("BrokerClientService: Successfully connected to Broker. Streams initialized.");
                    _isConnecting = false;
                    Connected?.Invoke();

                    _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(token), token);
                    return true;
                }
                else // RanToCompletion이지만 Connected가 false인 드문 경우
                {
                    _tcpClient?.Close();
                    SafeConsoleLog("[ERROR] BrokerClientService: Connection task RanToCompletion but TcpClient is not connected.");
                    throw new SocketException((int)SocketError.NotConnected);
                }
            }
            catch (OperationCanceledException opCancelledEx) // Task.Delay에서 발생 가능
            {
                SafeConsoleLog($"BrokerClientService: Connection operation cancelled: {opCancelledEx.Message}");
            }
            catch (SocketException sockEx)
            {
                SafeConsoleLog($"[ERROR] BrokerClientService: SocketException during ConnectAsync: {sockEx.Message} (ErrorCode: {sockEx.SocketErrorCode})");
            }
            catch (Exception ex)
            {
                SafeConsoleLog($"[ERROR] BrokerClientService: General error during ConnectAsync: {ex.ToString()}");
            }
            finally
            {
                _isConnecting = false; // 어떤 경우든 isConnecting은 해제
            }

            // 여기까지 왔다면 연결 실패
            CleanupConnectionResourcesInternal(false); // 예외 발생 시 리소스 정리
            Disconnected?.Invoke();
            return false;
        }

        private async Task ReceiveMessagesAsync(CancellationToken token)
        {
            SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync loop started.");
            try
            {
                while (!token.IsCancellationRequested && IsConnected)
                {
                    string messageJson = null;
                    try
                    {
                        // ReadLineAsync가 null을 반환하면 연결이 정상적으로 닫힌 것
                        // IOException은 비정상적 종료 가능성
                        messageJson = await _streamReader.ReadLineAsync().ConfigureAwait(false);
                    }
                    catch (ObjectDisposedException) when (token.IsCancellationRequested || _isDisposed) { SafeConsoleLog("BrokerClientService: StreamReader disposed in ReceiveMessagesAsync."); break; }
                    catch (IOException) when (token.IsCancellationRequested || !IsConnected) { SafeConsoleLog("BrokerClientService: IOException in ReceiveMessagesAsync (connection likely lost or cancelled)."); break; }

                    if (messageJson == null) { SafeConsoleLog("BrokerClientService: Broker disconnected (ReadLineAsync returned null)."); break; }
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null) { SafeConsoleLog($"BrokerClientService: Message received: Type={message.Type}, CorrId={message.CorrelationId}"); MessageReceived?.Invoke(message); }
                        else { SafeConsoleLog($"[WARNING] BrokerClientService: Failed to deserialize message: {messageJson}"); }
                    }
                    catch (JsonException jsonEx) { SafeConsoleLog($"[ERROR] BrokerClientService: JSON deserialization error: {jsonEx.Message}. Received: {messageJson}"); }
                }
            }
            catch (OperationCanceledException) { SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync cancelled."); }
            catch (Exception ex) { if(!token.IsCancellationRequested && !_isDisposed) SafeConsoleLog($"[ERROR] BrokerClientService: Unexpected error in ReceiveMessagesAsync: {ex.ToString()}"); }
            finally
            {
                SafeConsoleLog("BrokerClientService: ReceiveMessagesAsync loop ended.");
                if (!_isDisposed && !token.IsCancellationRequested && !_explicitlyDisconnected)
                {
                    CleanupConnectionResourcesInternal(false);
                    Disconnected?.Invoke();
                }
            }
        }

        public async Task SendMessageAsync(BrokerMessage message)
        {
            if (!IsConnected || _streamWriter == null || _isDisposed || (_cts != null && _cts.IsCancellationRequested))
            { SafeConsoleLog($"BrokerClientService: Cannot send message. Invalid state. Type: {message.Type}"); return; }

            string messageJson = "";
            try
            {
                messageJson = JsonConvert.SerializeObject(message);
                // SendMessageAsync는 UI 스레드에서도 호출될 수 있으므로, WriteLineAsync 사용 권장.
                // 하지만 StreamWriter.WriteLineAsync는 .NET 4.5에 없음. Write + FlushAsync.
                // 여기서는 동기 Write 후 Flush를 가정 (이전 코드 유지)
                bool sent = false;
                lock (_sendLock)
                {
                    if (IsConnected && _streamWriter != null && !_isDisposed && (_cts == null || !_cts.IsCancellationRequested))
                    {
                        _streamWriter.WriteLine(messageJson); // AutoFlush = true
                        sent = true;
                    }
                }
                if (sent) { SafeConsoleLog($"BrokerClientService: Message sent: {message.Type}, CorrId: {message.CorrelationId}"); }
                else { SafeConsoleLog($"[WARNING] BrokerClientService: Send cancelled or not possible for {message.Type} inside lock."); }
            }
            catch (ObjectDisposedException) { SafeConsoleLog($"[WARNING] BrokerClientService: Attempted to send {message.Type} on a disposed object."); HandleSendErrorInternal(); }
            catch (IOException ioEx) { SafeConsoleLog($"[ERROR] BrokerClientService: IOException sending {message.Type}: {ioEx.Message}"); HandleSendErrorInternal(); }
            catch (JsonException jsonEx) { SafeConsoleLog($"[ERROR] BrokerClientService: Error serializing {message.Type}: {jsonEx.Message}. Payload: {message.Payload}"); }
            catch (Exception ex) { SafeConsoleLog($"[ERROR] BrokerClientService: Error sending {message.Type}: {ex.ToString()}"); HandleSendErrorInternal(); }
        }
        
        private void HandleSendErrorInternal()
        {
            if (!_isDisposed) { CleanupConnectionResourcesInternal(false); Disconnected?.Invoke(); }
        }

        public Task DisconnectAsync()
        {
            SafeConsoleLog("BrokerClientService: DisconnectAsync called by user.");
            if (_isDisposed) return Task.FromResult(false);
            _explicitlyDisconnected = true; // 사용자가 명시적으로 연결 끊음
            _cts?.Cancel(); // 연결 시도 또는 수신 루프 취소
            CleanupConnectionResourcesInternal(false); // 즉시 리소스 정리
            Disconnected?.Invoke(); // 즉시 이벤트 발생
            return Task.FromResult(true);
        }

        // calledFromDispose 플래그는 이 메서드가 Dispose()에 의해 호출되었는지, 아니면 일반적인 연결 끊김으로 호출되었는지 구분
        private void CleanupConnectionResourcesInternal(bool calledFromDispose)
        {
            if (!calledFromDispose && _isDisposed) return;
            // Dispose 중이고 이미 리소스가 null이면 중복 정리 방지
            if (calledFromDispose && _isDisposed && _tcpClient == null && _networkStream == null) return;

            SafeConsoleLog($"BrokerClientService: Cleaning up connection resources. Called from Dispose: {calledFromDispose}");
            _isConnecting = false;

            lock(_sendLock)
            {
                try { _streamWriter?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing StreamWriter: {ex.Message}"); }
                _streamWriter = null;
            }
            try { _streamReader?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing StreamReader: {ex.Message}"); }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch (Exception ex){ SafeConsoleLog($"Error disposing NetworkStream: {ex.Message}"); }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch (Exception ex){ SafeConsoleLog($"Error closing TcpClient: {ex.Message}"); }
            _tcpClient = null;
            
            if (!calledFromDispose) SafeConsoleLog("BrokerClientService: Connection resources released (not from Dispose).");
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            SafeConsoleLog("BrokerClientService: Disposing...");
            _explicitlyDisconnected = true; // Dispose는 명시적 종료로 간주

            _cts?.Cancel(); // 모든 진행 중인 비동기 작업 취소
            
            if (_receiveLoopTask != null && !_receiveLoopTask.IsCompleted && !_receiveLoopTask.IsCanceled && !_receiveLoopTask.IsFaulted)
            {
               SafeConsoleLog("BrokerClientService: Waiting briefly for receive loop to complete disposal...");
               try { _receiveLoopTask.Wait(TimeSpan.FromMilliseconds(200)); } // 짧게 대기
               catch { /* 무시 */ }
            }

            CleanupConnectionResourcesInternal(true); // Dispose 중임을 알림

            _cts?.Dispose();
            _cts = null;
            
            SafeConsoleLog("BrokerClientService: Disposed.");
            GC.SuppressFinalize(this);
        }

        // 콘솔 출력을 위한 안전한 메서드 (로거가 없을 경우 대비)
        private void SafeConsoleLog(string message)
        {
            // if (_logger != null) _logger.LogInfo(message); // 로거가 있다면 로거 사용
            // else Console.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] {message}");
            Console.WriteLine(message); // 여기서는 항상 콘솔 출력
        }
    }
}