일 요약
1. MainViewModel.cs (비동기 함수 정의)
csharp
코드 복사
using System;
using System.Threading.Tasks;

public class MainViewModel
{
    // 비동기 작업 함수
    public async Task PerformLongRunningTask(int value)
    {
        Console.WriteLine($"Task started with value: {value}");

        // 2초 대기 (가상의 작업)
        await Task.Delay(2000);

        Console.WriteLine($"Task completed with value: {value}");
    }
}
2. OtherClass.cs (생성자를 통해 함수를 전달받고, 실행)
csharp
코드 복사
using System;
using System.Threading.Tasks;

public class OtherClass
{
    // 비동기 함수 참조를 위한 델리게이트
    private readonly Func<int, Task> _taskFunction;

    // 생성자를 통해 MainViewModel의 함수를 전달받음
    public OtherClass(Func<int, Task> taskFunction)
    {
        _taskFunction = taskFunction;
    }

    // 전달받은 함수를 실행하는 메서드
    public async Task RunTaskInOtherClass(int parameter)
    {
        Console.WriteLine("OtherClass: Task execution started.");
        
        // 파라미터와 함께 함수 호출
        await _taskFunction(parameter);

        Console.WriteLine("OtherClass: Task execution completed.");
    }
}
3. Program.cs (실행 파일)
csharp
코드 복사
using System;
using System.Threading.Tasks;

public class Program
{
    public static async Task Main(string[] args)
    {
        // MainViewModel 인스턴스 생성
        MainViewModel viewModel = new MainViewModel();

        // OtherClass 인스턴스 생성, MainViewModel의 함수를 전달
        OtherClass otherClass = new OtherClass(viewModel.PerformLongRunningTask);

        // OtherClass에서 함수 실행 (파라미터 42 전달)
        await otherClass.RunTaskInOtherClass(42);

        // 프로그램이 종료되지 않도록 대기
        Console.ReadLine();
    }
}
요약:
MainViewModel에서 정의된 비동기 함수를 다른 클래스의 생성자를 통해 전달하고, 그 클래스에서 함수 호출 시 파라미터를 전달하여 실행할 수 있도록 했습니다.
이제 **OtherCla