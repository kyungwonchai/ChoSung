이 설명한 시나리오에 따르면, 파일 감지 클래스가 있고, COM 포트 처리 클래스가 생성자를 통해 전달되어 파일이 감지되면 COM 포트의 특정 함수를 실행하는 구조입니다. 이때, COM 포트의 함수를 명령 큐에 추가하여 처리하는 방식으로 명령 큐 시스템과 접목할 수 있습니다. 파일이 감지되면 그 작업을 큐에 추가하고, 큐에서 순차적으로 COM 포트 작업을 처리하게 되는 구조로 변경할 수 있습니다.

다음은 이 구조를 설명하고, 전체 코드를 수정해 드리겠습니다.

작업 흐름
파일 감지 클래스는 파일을 감지하면 COM 포트 클래스의 특정 함수를 호출합니다.
COM 포트 함수는 CommandQueueViewModel에 작업으로 큐에 추가되고, 순차적으로 처리됩니다.
파일이 여러 개 감지되면, 큐에 작업이 차곡차곡 쌓이고 FIFO 방식으로 COM 포트 작업이 실행됩니다.
전체 파일 구조
CommandQueueViewModel.cs: 명령 큐를 관리하는 파일. 이 클래스에 작업을 추가하여 COM 포트 작업을 처리합니다.
ComPortHandler.cs: COM 포트를 처리하는 클래스. 이 클래스의 특정 함수가 명령 큐에 추가됩니다.
FileWatcher.cs: 파일을 감지하는 클래스. 파일이 감지되면 COM 포트의 함수를 실행하며, 이 함수는 명령 큐를 통해 처리됩니다.
MainViewModel.cs: 전체 시스템을 조율하는 메인 뷰모델로, 파일 감지와 명령 큐 처리를 연결합니다.
1. CommandQueueViewModel.cs (명령 큐 관리)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    private Queue<Func<Task>> commandQueue = new Queue<Func<Task>>();

    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();

    public event PropertyChangedEventHandler PropertyChanged;

    private int _progress;
    public int Progress
    {
        get => _progress;
        set { _progress = value; OnPropertyChanged(nameof(Progress)); }
    }

    // 비동기 작업 추가 (Task 반환하는 함수)
    public void AddAsyncTaskCommand(Func<Task> asyncTask)
    {
        EnqueueTask(asyncTask);
    }

    private async void EnqueueTask(Func<Task> taskFunc)
    {
        var newCommand = new CommandItem { CommandText = "Custom Task" };
        RemainingCommands.Add(newCommand);

        commandQueue.Enqueue(async () =>
        {
            await taskFunc(); // 비동기 함수 실행
            newCommand.Result = 1; // 명령 성공으로 처리
        });

        if (commandQueue.Count == 1)
        {
            await ProcessCommandQueue();
        }

        UpdateProgress();
    }

    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue();
            await command(); // 비동기 명령 실행
            UpdateProgress();
        }
    }

    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 큐에 남은 명령 수를 UI에 반영
    }

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}

public class CommandItem
{
    public string CommandText { get; set; }
    public int Result { get; set; }
}
2. ComPortHandler.cs (COM 포트 처리 클래스)
csharp
코드 복사
using System;
using System.Threading.Tasks;

public class ComPortHandler
{
    // COM 포트와 통신하는 예시 함수 (실제 구현에서는 COM 포트 관련 코드)
    public async Task SendDataAsync(string data)
    {
        Console.WriteLine($"Sending data to COM port: {data}");
        await Task.Delay(500); // COM 포트 통신 시뮬레이션
        Console.WriteLine($"Data sent to COM port: {data}");
    }
}
3. FileWatcher.cs (파일 감지 클래스)
csharp
코드 복사
using System;
using System.IO;

public class FileWatcher
{
    private readonly ComPortHandler _comPortHandler;
    private readonly CommandQueueViewModel _commandQueue;

    // 생성자에서 COM 포트 핸들러와 명령 큐를 주입받음
    public FileWatcher(ComPortHandler comPortHandler, CommandQueueViewModel commandQueue)
    {
        _comPortHandler = comPortHandler;
        _commandQueue = commandQueue;

        // 파일 감지 설정
        var watcher = new FileSystemWatcher(@"C:\watched_folder");
        watcher.Filter = "*.txt"; // 텍스트 파일 감지
        watcher.Changed += OnFileChanged;
        watcher.EnableRaisingEvents = true;
    }

    // 파일이 변경될 때 실행되는 함수
    private void OnFileChanged(object sender, FileSystemEventArgs e)
    {
        Console.WriteLine($"File detected: {e.Name}");
        
        // 파일 감지 시, COM 포트 핸들러의 작업을 명령 큐에 추가
        _commandQueue.AddAsyncTaskCommand(async () =>
        {
            string dataToSend = File.ReadAllText(e.FullPath);
            await _comPortHandler.SendDataAsync(dataToSend); // COM 포트에 데이터 전송
        });
    }
}
4. MainViewModel.cs (전체 시스템 조율)
csharp
코드 복사
public class MainViewModel : INotifyPropertyChanged
{
    public CommandQueueViewModel CommandQueue { get; set; }
    public FileWatcher FileWatcher { get; set; }

    public MainViewModel()
    {
        CommandQueue = new CommandQueueViewModel();
        var comPortHandler = new ComPortHandler();
        
        // FileWatcher에 COM 포트 핸들러와 명령 큐를 전달
        FileWatcher = new FileWatcher(comPortHandler, CommandQueue);
    }

    public event PropertyChangedEventHandler PropertyChanged;
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
파일별 변경 사항 설명
CommandQueueViewModel.cs:

비동기 작업 큐 관리를 담당합니다. 각 작업을 순차적으로 실행하고, 큐에 남은 작업 개수를 관리하여 UI에 반영합니다.
ComPortHandler.cs:

COM 포트 통신을 처리하는 클래스입니다. 파일이 감지되었을 때, 파일의 내용을 읽고 COM 포트를 통해 데이터를 전송하는 작업을 합니다.
FileWatcher.cs:

파일 감지를 담당하는 클래스입니다. 감지된 파일의 내용을 읽고, COM 포트로 데이터를 전송하는 작업을 명령 큐에 추가하여 순차적으로 처리합니다.
MainViewModel.cs:

CommandQueueViewModel과 FileWatcher를 조율하는 메인 뷰모델입니다. FileWatcher에서 파일이 감지되면 COM 포트 작업을 큐에 추가합니다.
작동 방식 설명
파일 감지: FileWatcher가 텍스트 파일을 감지하면, OnFileChanged 메서드가 호출되어 감지된 파일의 데이터를 읽습니다.

명령 큐에 작업 추가: 파일의 데이터를 읽은 후, COM 포트로 데이터를 전송하는 작업을 CommandQueueViewModel에 비동기 작업으로 추가합니다.

큐 처리: CommandQueueViewModel은 FIFO 방식으로 큐에 쌓인 작업을 처리하며, 한 작업이 끝나면 다음 작업을 실행합니다.

이 방식은 파일 감지 작업과 COM 포트 처리를 명령 큐에 넣어 순차적으로 처리할 수 있도록 구성되어 있어, 파일이 여러 개 감지되더라도 COM 포트 작업이 안정적으로 처리됩니다.