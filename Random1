이 코드는 최신 버전의 pymssql, openpyxl 라이브러리를 사용하여 구현됩니다. 각 단계별로 한국어 설명을 추가하였습니다.

    pymssql을 이용해 서버 시간 가져오기
    가져온 시간을 yyyyMMdd 형식으로 변환하여 DDD 변수에 저장
    openpyxl을 이용해 엑셀 파일을 읽고 B2셀이 "Reel 번호"인지 확인
    B2셀이 맞다면 B열의 3행부터 끝까지의 데이터를 읽어 중복 없이 리스트 생성
    D열에 데이터가 없는 행은 제외하고, 지정된 형식으로 문자열을 만들어 딕셔너리의 키로 사용
    pymssql로 오늘 날짜의 yyyyMMdd 형식과 일치하는 N_RKey를 가져옴
    가져온 N_RKey와 TB2의 N_RKey를 비교
    일치하는 N_RKey의 NDesignVer을 업데이트

python

import pymssql
import openpyxl
from datetime import datetime
import os

# 서버에서 시간 값을 가져옵니다.
conn = pymssql.connect(server='서버주소', user='유저명', password='비밀번호', database='데이터베이스명')
cursor = conn.cursor()
cursor.execute('SELECT GETDATE()') # 혹은 서버 시간을 가져오는 쿼리를 사용하세요.
server_time = cursor.fetchone()[0]
conn.close()

# yyyyMMdd 형식으로 변환합니다.
DDD = server_time.strftime('%Y%m%d')

# 엑셀 파일을 읽습니다.
def process_excel(file_path):
    wb = openpyxl.load_workbook(file_path)
    sheet = wb.active
    
    # B2셀이 "Reel 번호"인지 확인합니다.
    if sheet['B2'].value != 'Reel 번호':
        raise ValueError('B2셀이 "Reel 번호"가 아닙니다.')

    # 데이터를 추출합니다.
    unique_values = {}
    for row in sheet.iter_rows(min_row=3, min_col=2, max_col=9):  # B열부터 I열까지 확인
        d_value = row[3].value  # D열 값
        if d_value:  # D열 값이 비어있지 않은 경우에만 처리
            key = f"{DDD}_{row[8].value}_{row[4].value}_{d_value}"  # 키 생성: DDD_I열_E열_D열
            unique_values[key] = row[7].value  # P열 값을 딕셔너리 값으로 사용

    return unique_values

# 실행 예:
# my_values = process_excel('경로/파일명.xlsx')

데이터베이스 업데이트 부분과 나머지 코드는 비즈니스 로직과 DB 스키마에 맞게 추가 구현이 필요합니다. 데이터베이스 접속 정보, 테이블 이름, SQL 쿼리 구문 등은 보안상의 이유로 제공받은 정보에 따라 적절히 변경해야 합니다.

코드를 실행하기 전에, 필요한 모듈들이 설치되어 있는지 확인하고, 필요에 따라 pip install pymssql open