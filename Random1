죄송합니다. 요청하신 대로 함수의 개수에 맞춰 도형의 개수가 자동으로 생성되게 하고, 추가된 함수에 맞게 도형과 작업이 자동으로 동작하도록 수정해드리겠습니다. 또한, 어떻게 함수를 추가할 때 도형 개수가 자동으로 증가하는지와 함수 실행이 어떻게 이루어지는지에 대한 설명도 추가해드리겠습니다.

수정된 TaskModel.cs
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;
using System.Diagnostics;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 실행된 함수가 몇 초 동안 실행되었는지 경과 시간을 표시하며, 추가된 함수에 따라 도형 개수가 자동으로 반영됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }

    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }

    // 경과 시간을 측정하기 위한 Stopwatch
    private Stopwatch _stopwatch;

    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    // 다음 작업 행을 관리하는 Action 델리게이트 (현재 작업 완료 후 호출)
    public Action<TaskModel> StartNextTask { get; set; }

    private int _functionCount;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending"; // 처음엔 대기 상태
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        _stopwatch = new Stopwatch(); // Stopwatch 초기화

        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);

        // 함수 개수를 시퀀스에 맞게 설정
        InitializeFunctions(); // 시퀀스 플래그에 따라 함수 개수를 설정하고 도형을 생성
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// 작업의 경과 시간을 Stopwatch로 계산합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running...";
        _stopwatch.Restart(); // Stopwatch를 시작하여 경과 시간을 기록

        _taskQueue.EnqueueTask(ExecuteTaskSequence); // 작업 큐에 시퀀스 작업 추가
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행합니다.
    /// 각 작업이 완료될 때마다 경과 시간을 ProgressText로 표시합니다.
    /// </summary>
    private async Task ExecuteTaskSequence()
    {
        for (int i = 0; i < _functionCount; i++)
        {
            await ExecuteTaskWithColor(i, ExecuteDynamicTask(FunctionNames[i]));
        }

        // 작업 완료 후 상태 변경 및 경과 시간 표시
        Status = "Completed";
        ProgressText = $"Completed in {_stopwatch.Elapsed.Seconds} seconds";

        StartNextTask?.Invoke(this);
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    public async void ExecuteSpecificTask(int taskIndex)
    {
        await ExecuteTaskWithColor(taskIndex, ExecuteDynamicTask(FunctionNames[taskIndex]));
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// 작업 완료 시 경과 시간을 갱신합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            ProgressText = $"Running... ({_stopwatch.Elapsed.Seconds} seconds elapsed)";
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 동적으로 함수 실행을 정의합니다.
    /// </summary>
    private Func<Task> ExecuteDynamicTask(string taskName)
    {
        return async () =>
        {
            await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
            ProgressText = $"{taskName} Completed in {_stopwatch.Elapsed.Seconds} seconds";
        };
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상 및 이름을 설정합니다.
    /// 함수의 개수는 시퀀스 플래그에 따라 다르게 설정됩니다.
    /// </summary>
    private void InitializeFunctions()
    {
        // 시퀀스 플래그에 따라 함수와 도형 개수 설정
        switch (SequenceFlag)
        {
            case 1:
                AddFunction("Task A");
                AddFunction("Task B");
                AddFunction("Task C");
                break;
            case 2:
                AddFunction("Task C");
                AddFunction("Task B");
                AddFunction("Task D");
                break;
            case 3:
                AddFunction("Task A");
                AddFunction("Task B");
                AddFunction("Task E");
                break;
        }

        _functionCount = FunctionNames.Count; // 함수 개수를 도형 개수로 설정
    }

    /// <summary>
    /// 함수 및 도형을 추가하는 메서드입니다.
    /// 함수가 추가되면 도형도 자동으로 회색으로 추가됩니다.
    /// </summary>
    private void AddFunction(string functionName)
    {
        FunctionNames.Add(functionName);
        FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused";
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed";
    }
}
설명:
도형 개수와 함수 개수 자동 조정:

함수 개수는 시퀀스 플래그에 따라 자동으로 설정됩니다.
InitializeFunctions() 함수는 시퀀스 플래그를 확인하여 해당 함수들을 추가하고, 도형 개수도 함수 개수에 맞춰 추가됩니다.
AddFunction() 메서드는 함수를 추가할 때마다 자동으로 회색 도형을 추가합니다.
동적 함수 실행:

ExecuteDynamicTask() 함수는 추가된 함수 이름에 맞게 동적으로 실행됩니다. 예를 들어, **"Task A"**라는 함수가 추가되면 해당 함수가 실행되고, 도형에 상태와 실행 시간이 표시됩니다.
순차 작업 실행:

각 함수는 순차적으로 실행됩니다. 첫 번째 함수가 끝나면 다음 함수가 실행되며, 모든 함수가 완료되면 작업이 종료됩니다.
단독 함수 실행:

ExecuteSpecificTask() 메서드를 사용하면 특정 함수만 우클릭으로 실행할 수 있습니다.
추가하는 방법:

새로운 함수를 추가하려면 InitializeFunctions() 메서드에 새로운 함수 이름을 추가하면 됩니다. 예를 들어, **"Task F"**를 추가하고 싶다면 AddFunction("Task F")를 호출하여 함수를 추가할 수 있습니다.
해당 함수는 자동으로 도형이 생성되며, 실행 순서에 맞춰 도형의 상태와 시간이 업데이트됩니다.
함수 추가 방법 설명:
만약 새로운 함수를 추가하고 싶다면:

**InitializeFunctions()**에 새로운 함수를 추가합니다:

csharp
코드 복사
case 1:
    AddFunction("Task A");
    AddFunction("Task B");
    AddFunction("Task C");
    AddFunction("Task F"); // 새로운 함수 추가
    break;
**ExecuteDynamicTask()**가 해당 함수 이름을 인식하고, 함수가 실행되며 도형의 상태가 업데이트됩니다.

이제 함수의 개수에 맞춰 도형이 자동으로 생성되며, 순차적으로 작업이 진행되고 실시간으로 상태가 반영됩니다.

궁금한 점이 있거나 추가적인 도움이 필요하면 언제든지 알려주세요