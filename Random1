알겠습니다. 요청하신 대로 SocketClientMergeOI 클래스를 사용하여 서버와의 연결 상태를 도형과 텍스트로 UI에 반영하고, 연결이 되면 녹색, 연결이 끊기면 빨간색으로 표시되는 형태로 다시 작성하겠습니다.

구성은 아래와 같이 하겠습니다:

SocketClientMergeOI 클래스는 클라이언트 측에서 서버와의 연결을 처리합니다.
MainWindow.xaml에서는 연결 상태를 표시하는 UI(도형과 텍스트)를 구성하고, SocketClientMergeOI 클래스에서 서버와 연결되었을 때, 끊겼을 때 상태가 반영되도록 합니다.
SocketClientMergeOI.cs (클라이언트 소켓 처리)
기존의 SocketClientMergeOI 클래스는 그대로 사용하며, 이벤트를 통해 연결 상태 변경을 MainWindow에 알릴 수 있도록 ConnectionStatusChanged 이벤트를 활용합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class SocketClientMergeOI
{
    private TcpClient _client; // TCP 클라이언트 객체
    private NetworkStream _stream; // 네트워크 스트림
    private readonly string _ipAddress; // 접속할 서버의 IP 주소
    private readonly int _port; // 접속할 서버의 포트 번호
    private bool _isConnected; // 서버와의 연결 여부 플래그
    private readonly int _retryInterval = 10000; // 10초 간격으로 재연결 시도

    // ObservableCollection을 사용하여 메시지 목록 관리
    public ObservableCollection<MessageLog> MessageLogs { get; private set; } // 읽기 전용

    // 연결 상태가 변경될 때 호출될 이벤트
    public event Action<bool> ConnectionStatusChanged;

    // 생성자: IP 주소와 포트로 소켓 클라이언트를 초기화
    public SocketClientMergeOI(string ipAddress, int port)
    {
        _ipAddress = ipAddress; // 입력받은 IP 저장
        _port = port; // 입력받은 포트 저장
        _client = new TcpClient(); // TCP 클라이언트 생성
        _isConnected = false; // 초기 연결 상태 false
        MessageLogs = new ObservableCollection<MessageLog>(); // 메시지 로그 초기화
        StartConnectionAttemptAsync(); // 연결 시도 시작
    }

    // 서버에 연결 시도하는 비동기 함수
    private async void StartConnectionAttemptAsync()
    {
        while (!_isConnected) // 연결이 될 때까지 반복
        {
            try
            {
                await _client.ConnectAsync(_ipAddress, _port); // 서버에 연결 시도
                _isConnected = true; // 연결 성공
                _stream = _client.GetStream(); // 스트림 생성
                ConnectionStatusChanged?.Invoke(true); // 연결 성공 시 이벤트 발생 (연결됨 상태)
                StartReceiving(); // 메시지 수신 대기
            }
            catch (Exception)
            {
                ConnectionStatusChanged?.Invoke(false); // 연결 실패 시 이벤트 발생 (연결 끊김 상태)
                await Task.Delay(_retryInterval); // 10초 대기 후 재시도
            }
        }
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async void StartReceiving()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼 생성

        while (_isConnected) // 연결된 동안 메시지 수신을 계속 시도
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 읽음
                if (bytesRead > 0)
                {
                    string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신된 데이터를 문자열로 변환
                    LogMessage(_ipAddress, "Client", "", receivedMessage); // 수신 메시지를 로그에 기록
                }
            }
            catch (Exception)
            {
                _isConnected = false; // 연결이 끊긴 경우
                ConnectionStatusChanged?.Invoke(false); // 연결 끊김 이벤트 발생
                StartConnectionAttemptAsync(); // 다시 연결 시도
            }
        }
    }

    // 메시지를 전송하고 응답을 받는 비동기 함수
    public async Task<string> SendAndReceiveMessageAsync(string message)
    {
        // 연결 상태 확인 후 연결이 안 되어 있으면 로그 남기기
        if (!_isConnected) // 연결이 되어 있지 않으면
        {
            LogMessage("Client", _ipAddress, message, "Failed: Not connected"); // 연결 실패 로그 남기기
            return "Not connected"; // 연결되지 않았음을 반환
        }

        string fullMessage = $"\x02{message}\x03"; // STX 및 ETX 추가
        byte[] messageBytes = Encoding.ASCII.GetBytes(fullMessage); // 메시지를 바이트 배열로 변환

        try
        {
            await _stream.WriteAsync(messageBytes, 0, messageBytes.Length); // 서버에 전송
            LogMessage("Client", _ipAddress, message, ""); // 전송 로그 남김
        }
        catch (Exception)
        {
            LogMessage("Client", _ipAddress, message, "Failed: Send Error"); // 전송 실패 로그 남기기
            return "Send Failed"; // 전송 실패 시 에러 반환
        }

        // 서버로부터 응답 대기 및 검증
        string response = await ReceiveMessageAsync();
        LogMessage(_ipAddress, "Client", message, response); // 응답 로그 기록
        return ValidateResponse(message, response); // 응답 검증 후 결과 반환
    }

    // 서버로부터 메시지를 수신하는 비동기 함수
    private async Task<string> ReceiveMessageAsync()
    {
        byte[] buffer = new byte[1024]; // 수신할 데이터를 담을 버퍼

        try
        {
            int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 데이터를 비동기적으로 수신
            if (bytesRead > 0)
            {
                string receivedMessage = Encoding.ASCII.GetString(buffer, 0, bytesRead); // 수신된 데이터를 문자열로 변환
                return receivedMessage; // 변환된 메시지 반환
            }
        }
        catch (Exception)
        {
            _isConnected = false; // 연결이 끊긴 경우
            ConnectionStatusChanged?.Invoke(false); // 연결 끊김 이벤트 발생
            StartConnectionAttemptAsync(); // 다시 연결 시도
        }

        return string.Empty;
    }

    // 메시지 로그 추가 함수
    private void LogMessage(string sender, string receiver, string sentMessage, string responseMessage)
    {
        // 로그 항목 추가
        MessageLog log = new MessageLog
        {
            Timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss"),
            Sender = sender,
            Receiver = receiver,
            SentMessage = sentMessage,
            ResponseMessage = responseMessage
        };

        if (MessageLogs.Count >= 50) // 최대 50개 로그 유지
        {
            MessageLogs.RemoveAt(0); // 오래된 항목 삭제
        }

        MessageLogs.Add(log); // 새로운 항목 추가
    }

    // 응답 검증 함수
    private string ValidateResponse(string sentMessage, string receivedMessage)
    {
        if (receivedMessage.StartsWith("\x02") && receivedMessage.EndsWith("\x03"))
        {
            string cleanMessage = receivedMessage.Trim('\x02', '\x03');
            if (cleanMessage == "OK")
            {
                return "OK";
            }
            else if (cleanMessage == sentMessage)
            {
                return "NG";
            }
        }
        return "Invalid Response";
    }

    // 연결을 중지하는 함수
    public void StopConnection()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        ConnectionStatusChanged?.Invoke(false); // 연결 종료 시 이벤트 발생
    }
}

// 메시지 로그를 위한 클래스
public class MessageLog
{
    public string Timestamp { get; set; } // 메시지의 타임스탬프
    public string Sender { get; set; } // 발신자
    public string Receiver { get; set; } // 수신자
    public string SentMessage { get; set; } // 전송된 메시지
    public string ResponseMessage { get; set; } // 수신된 응답 메시지
}
MainWindow.xaml (UI 정의 및 도형 상태)
xml
코드 복사
<Window x:Class="SocketClientApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Socket Client" Height="450" Width="600">
    <Grid>
        <!-- 연결 상태를 표시할 도형 및 텍스트 -->
        <Grid HorizontalAlignment="Center" VerticalAlignment="Top" Margin="0,20,0,0" Width="100" Height="100">
            <!-- 원형 도형 -->
            <Ellipse x:Name="ConnectionEllipse" Fill="Red" Width="100" Height="100"/>
            <!-- 상태 텍스트 (연결 상태에 따라 변경) -->
            <TextBlock x:Name="ConnectionStatusText" Text="연결 필요" Foreground="White" FontWeight="Bold" HorizontalAlignment="Center" VerticalAlignment="Center"/>
        </Grid>

        <!-- 서버에 메시지 전송 버튼 -->
        <Button Content="Send Command" HorizontalAlignment="Center" VerticalAlignment="Center" Width="150" Height="30" Click="SendCommand_Click"/>

        <!-- 메시지 로그를 보여줄 DataGrid -->
        <DataGrid ItemsSource="{Binding MessageLogs}" AutoGenerateColumns="False" IsReadOnly="True" Width="580" Height="200" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="0,0,0,10">
            <DataGrid.Columns>
                <!-- 수신된 메시지 -->
                <DataGridTextColumn Header="Timestamp" Binding="{Binding Timestamp}" Width="150"/>
                <DataGridTextColumn Header="Sender" Binding="{Binding Sender}" Width="100"/>
                <DataGridTextColumn Header="Receiver" Binding="{Binding Receiver}" Width="100"/>
                <DataGridTextColumn Header="Sent Message" Binding="{Binding SentMessage}" Width="150"/>
                <DataGridTextColumn Header="Response Message" Binding="{Binding ResponseMessage}" Width="150"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
MainWindow.xaml.cs (클라이언트와 UI 연결)
csharp
코드 복사
using System;
using System.Windows;
using System.Windows.Media;

namespace SocketClientApp
{
    public partial class MainWindow : Window
    {
        private SocketClientMergeOI _socketClient; // 소켓 클라이언트 객체

        public MainWindow()
        {
            InitializeComponent();
            _socketClient = new SocketClientMergeOI("127.0.0.1", 2400); // 서버와의 소켓 클라이언트 설정

            // 연결 상태가 변경되었을 때 호출될 이벤트 핸들러 설정
            _socketClient.ConnectionStatusChanged += OnConnectionStatusChanged;
            DataContext = _socketClient; // 소켓 클라이언트의 로그를 DataContext로 설정하여 DataGrid에 바인딩
        }

        // 연결 상태가 변경되면 도형 색상 및 텍스트를 변경하는 함수
        private void OnConnectionStatusChanged(bool isConnected)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (isConnected)
                {
                    ConnectionEllipse.Fill = Brushes.Green; // 연결되면 녹색으로 변경
                    ConnectionStatusText.Text = "연결됨"; // 텍스트 변경
                }
                else
                {
                    ConnectionEllipse.Fill = Brushes.Red; // 연결되지 않았을 때 빨간색
                    ConnectionStatusText.Text = "연결 필요"; // 텍스트 변경
                }
            });
        }

        // 서버로 명령어를 전송하는 버튼 클릭 이벤트
        private async void SendCommand_Click(object sender, RoutedEventArgs e)
        {
            string command = "TestCommand"; // 예시 명령어
            string result = await _socketClient.SendAndReceiveMessageAsync(command); // 명령어 전송 및 응답 수신
            MessageBox.Show(result); // 결과 메시지를 보여줌
        }
    }
}
설명:
SocketClientMergeOI 클래스:

ConnectionStatusChanged 이벤트를 사용하여 서버와의 연결 상태가 변경되면 이를 알립니다.
연결 상태가 변경될 때마다 MainWindow의 UI에 반영됩니다.
MainWindow.xaml:

**Ellipse**와 **TextBlock**을 사용하여 연결 상태를 시각적으로 표시합니다.
빨간색: 연결되지 않은 상태.
녹색: 서버와 연결된 상태.
SendCommand_Click 버튼을 통해 서버로 명령어를 전송하고, 응답 결과를 보여줍니다.
MainWindow.xaml.cs:

OnConnectionStatusChanged 함수에서 연결 상태에 따라 도형의 색상과 텍스트를 변경합니다.