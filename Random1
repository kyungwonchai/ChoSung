ystem.Windows.Forms.NotifyIcon 대신 WPF 환경에 더 적합하고 많이 사용되는 Hardcodet.NotifyIcon.Wpf 라이브러리를 사용하여 시스템 트레이 아이콘 기능을 구현하도록 코드를 수정해 드리겠습니다. 이 라이브러리를 사용하면 XAML에서 트레이 아이콘의 속성이나 컨텍스트 메뉴를 더 쉽게 정의할 수 있습니다.

수정 및 신규 파일:

SAgentM.App.csproj (수정): Hardcodet.NotifyIcon.Wpf NuGet 패키지를 추가하고, 기존 System.Windows.Forms 참조는 제거합니다.
아이콘 파일: 이전과 동일하게 agent_icon.ico 파일이 프로젝트에 필요합니다.
App.xaml (수정): TaskbarIcon (라이브러리의 트레이 아이콘 컨트롤)을 XAML 리소스로 정의하고 컨텍스트 메뉴 등을 설정합니다.
App.xaml.cs (수정): TaskbarIcon 관련 로직을 처리하고, MainWindow 관리 및 AgentCoreService 시작/종료 로직을 담당합니다.
MainWindow.xaml.cs (수정): 창을 닫을 때 숨겨지는 로직은 유지됩니다.
1. SAgentM.App.csproj 파일 수정 - NuGet 패키지 추가
SAgentM.App 프로젝트에 다음 NuGet 패키지를 설치합니다:

Hardcodet.NotifyIcon.Wpf: (PowerShell: Install-Package Hardcodet.NotifyIcon.Wpf)
만약 이전에 System.Windows.Forms 참조를 수동으로 추가했다면, 이 라이브러리를 사용하면서 해당 참조가 더 이상 필요하지 않으므로 제거해도 됩니다 (Hardcodet.NotifyIcon.Wpf 라이브러리가 내부적으로 필요한 부분을 처리할 수 있습니다. 다만, 다른 용도로 System.Windows.Forms를 사용 중이지 않다면 제거 가능).

2. 아이콘 파일 준비
(이전과 동일) agent_icon.ico 파일을 프로젝트 루트에 추가하고, 빌드 작업을 "Resource"로 설정합니다.
3. 수정: App.xaml (전체 파일 - TaskbarIcon 정의)
StartupUri를 제거하고, Application.Resources 내에 Hardcodet.NotifyIcon.Wpf의 TaskbarIcon을 정의합니다.

XML

<Application x:Class="SAgentM.App.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:SAgentM.App"
             xmlns:tb="http://www.hardcodet.net/taskbar" ShutdownMode="OnExplicitShutdown">
    <Application.Resources>
        <tb:TaskbarIcon x:Key="AppNotifyIcon"
                        IconSource="/agent_icon.ico" ToolTipText="SAgentM 에이전트"
                        TrayMouseDoubleClick="AppNotifyIcon_TrayMouseDoubleClick">
            <tb:TaskbarIcon.ContextMenu>
                <ContextMenu>
                    <MenuItem Header="상태 보기/숨기기" Click="ShowHideMainWindow_MenuItemClick"/>
                    <Separator />
                    <MenuItem Header="종료" Click="ExitApplication_MenuItemClick"/>
                </ContextMenu>
            </tb:TaskbarIcon.ContextMenu>
            
            </tb:TaskbarIcon>
    </Application.Resources>
</Application>
App.xaml 주요 변경 사항:

xmlns:tb 네임스페이스 추가: Hardcodet.NotifyIcon.Wpf 라이브러리의 컨트롤을 사용하기 위해 XML 네임스페이스를 추가합니다.
ShutdownMode="OnExplicitShutdown": Application.Current.Shutdown()이 호출될 때만 애플리케이션이 종료되도록 설정합니다. (모든 창이 닫혀도 바로 종료되지 않음)
<tb:TaskbarIcon x:Key="AppNotifyIcon" ...>:
AppNotifyIcon이라는 키로 TaskbarIcon 리소스를 정의합니다.
IconSource: agent_icon.ico 파일의 경로를 지정합니다. (프로젝트에 Resource로 포함된 경우 이 경로가 일반적입니다.)
ToolTipText: 트레이 아이콘에 마우스를 올렸을 때 표시될 텍스트입니다.
TrayMouseDoubleClick: 트레이 아이콘 더블 클릭 시 호출될 이벤트 핸들러 이름입니다 (App.xaml.cs에서 구현).
ContextMenu: WPF의 ContextMenu를 사용하여 트레이 아이콘의 우클릭 메뉴를 정의합니다. "상태 보기/숨기기"와 "종료" 메뉴 항목을 만들고, 각 항목 클릭 시 호출될 이벤트 핸들러를 지정합니다.
4. 수정: App.xaml.cs (전체 파일 - TaskbarIcon 로직 처리)
System.Windows.Forms.NotifyIcon 관련 코드를 제거하고, XAML에 정의된 TaskbarIcon을 사용하여 로직을 처리합니다.

C#

// SAgentM.App/App.xaml.cs
using SAgentM.App.Services;
using SAgentM.App.ViewModels;
using System;
using System.Configuration;
using System.IO;
using System.Windows;
// using System.Windows.Forms; // System.Windows.Forms 관련 using 제거
using Hardcodet.Wpf.TaskbarNotification; // Hardcodet.NotifyIcon.Wpf 라이브러리 using
using Serilog;

namespace SAgentM.App
{
    public partial class App : Application
    {
        private TaskbarIcon _notifyIcon; // Hardcodet 라이브러리의 TaskbarIcon 사용
        private MainWindow _mainWindow;

        private ILoggingService _loggingService;
        private IAgentCoreService _agentCoreService;
        private MainViewModel _mainViewModel;

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Serilog 파일 로거 설정 (이전과 동일)
            var logFilePath = ConfigurationManager.AppSettings["LogFilePath"] ?? "Logs_SAgentM\\SAgentM_App_.log";
            var baseDir = AppDomain.CurrentDomain.BaseDirectory;
            var fullLogPath = Path.Combine(baseDir, logFilePath);
            if (!Directory.Exists(Path.GetDirectoryName(fullLogPath))) { Directory.CreateDirectory(Path.GetDirectoryName(fullLogPath)); }
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .MinimumLevel.Override("Microsoft", Serilog.Events.LogEventLevel.Warning)
                .Enrich.FromLogContext().Enrich.WithThreadId().Enrich.WithProcessId()
                .WriteTo.File(fullLogPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7, shared: true, flushToDiskInterval: TimeSpan.FromSeconds(5))
                .CreateLogger();
            Log.Information("SAgentM.App Application_Startup: Logging initialized. Path: {LogPath}", fullLogPath);

            // 서비스 및 ViewModel 초기화
            _loggingService = new LoggingService();
            _agentCoreService = new AgentCoreService(_loggingService);
            _mainViewModel = new MainViewModel(_loggingService, _agentCoreService);

            // MainWindow 인스턴스 생성 및 ViewModel 연결
            _mainWindow = new MainWindow { DataContext = _mainViewModel };
            // MainWindow는 처음에는 숨김 (MainWindow.xaml.cs의 Loaded 이벤트에서 Hide() 호출)

            // App.xaml에 정의된 TaskbarIcon 리소스 가져오기
            _notifyIcon = (TaskbarIcon)FindResource("AppNotifyIcon");
            if (_notifyIcon == null)
            {
                _loggingService.UiError("App.xaml에서 AppNotifyIcon 리소스를 찾을 수 없습니다.", null);
                // 대체 NotifyIcon 생성 또는 앱 종료 처리 가능
                // 여기서는 간단히 로그만 남기고 진행 (아이콘 없이 실행될 수 있음)
            }
            else
            {
                // 이벤트 핸들러 연결 (XAML에서 이미 연결했지만, 코드에서도 확인/추가 가능)
                // _notifyIcon.TrayMouseDoubleClick += AppNotifyIcon_TrayMouseDoubleClick; 
                // ContextMenu의 MenuItem 이벤트는 XAML에서 직접 연결했으므로 여기서는 불필요.
                // 만약 MenuItem을 코드에서 동적으로 생성한다면 여기서 이벤트 연결.
                 _loggingService.UiInfo("TaskbarIcon 리소스 로드 완료.");
            }


            // AgentCoreService 시작
            if (!_agentCoreService.IsRunning)
            {
                _loggingService.UiInfo("App.xaml.cs: AgentCoreService 시작 시도...");
                try
                {
                    // ViewModel을 통해 시작하거나 직접 시작 가능
                    // _mainViewModel.StartAgentCommand.Execute(null); // ViewModel 명령 사용 시
                    _agentCoreService.Start(); // 직접 시작
                    
                    // ViewModel 상태 업데이트 (AgentCoreService 시작 후)
                    _mainViewModel.UpdateAgentStatus(); 
                }
                catch (Exception ex)
                {
                     _loggingService.UiError("App.xaml.cs: AgentCoreService 시작 중 오류.", ex);
                     if (_mainViewModel != null) _mainViewModel.AgentStatus = "에이전트 시작 오류";
                }
            }
        }

        // App.xaml에서 TaskbarIcon의 TrayMouseDoubleClick 이벤트에 연결된 핸들러
        private void AppNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e)
        {
            ShowHideMainWindow();
        }

        // App.xaml에서 ContextMenu의 MenuItem 클릭 이벤트에 연결된 핸들러
        private void ShowHideMainWindow_MenuItemClick(object sender, RoutedEventArgs e)
        {
            ShowHideMainWindow();
        }
        
        private void ShowHideMainWindow()
        {
            if (_mainWindow == null) return;
            if (_mainWindow.IsVisible)
            {
                _mainWindow.Hide();
                _loggingService?.UiDebug("MainWindow 숨김.");
            }
            else
            {
                _mainWindow.Show();
                if (_mainWindow.WindowState == WindowState.Minimized)
                {
                    _mainWindow.WindowState = WindowState.Normal;
                }
                _mainWindow.Activate();
                _loggingService?.UiDebug("MainWindow 표시.");
            }
        }

        // App.xaml에서 ContextMenu의 MenuItem 클릭 이벤트에 연결된 핸들러
        private async void ExitApplication_MenuItemClick(object sender, RoutedEventArgs e)
        {
            _loggingService?.UiInfo("애플리케이션 종료 요청 (트레이 메뉴).");
            
            // ViewModel 및 서비스 정리 작업 호출 (비동기적으로)
            if (_mainViewModel != null)
            {
                await _mainViewModel.CleanupAsync(); // 비동기 정리 대기
            }
            // AgentCoreService는 ViewModel의 CleanupAsync 내부에서 Stop 호출될 것으로 예상
            // 또는 여기서 명시적으로 _agentCoreService?.Stop(); 호출

            if (_notifyIcon != null)
            {
                _notifyIcon.Dispose(); // 트레이 아이콘 정리
            }
            Current.Shutdown();     // 애플리케이션 완전히 종료
        }

        protected override void OnExit(ExitEventArgs e)
        {
            _loggingService?.UiInfo("SAgentM.App Application_Exit: 최종 정리 및 로거 닫기.");
            _notifyIcon?.Dispose(); // 만약을 위해 한번 더
            Log.CloseAndFlush();    // Serilog 파일 로거 닫기
            base.OnExit(e);
        }
    }
}
5. 수정: MainWindow.xaml.cs (창 동작 변경)
Window_Loaded 이벤트에서 창을 숨기고, Closing 이벤트에서 실제 종료 대신 창을 숨기도록 합니다.

C#

// SAgentM.App/MainWindow.xaml.cs
using SAgentM.App.ViewModels;
using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls; // ListView 접근용

namespace SAgentM.App
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel => DataContext as MainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            // DataContext는 App.xaml.cs에서 MainWindow 인스턴스 생성 시 주입됨
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // ViewModel의 LoadedCommand는 App.xaml.cs에서 AgentCoreService를 시작하므로,
            // 여기서는 ViewModel 상태 업데이트나 UI 관련 초기화만 수행할 수 있음.
            // 또는 App.xaml.cs에서 ViewModel의 해당 명령을 호출하도록 할 수 있음.
            // _viewModel?.LoadedCommand?.Execute(null); // App.xaml.cs에서 이미 처리했다면 중복 불필요

            // 로그 자동 스크롤 이벤트 핸들러 등록
            if (_viewModel != null && _viewModel.UiLogEntries != null)
            {
                 _viewModel.UiLogEntries.CollectionChanged += UiLogEntries_CollectionChanged;
            }
            
            // 창이 로드된 후 바로 숨깁니다 (애플리케이션 시작 시 트레이로만 가도록)
            this.Hide(); 
            _viewModel?.UiInfo("MainWindow 로드 완료 및 숨김 처리됨 (트레이 모드).");
        }
        
        private void UiLogEntries_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            // XAML에서 ListView에 x:Name="LogListView"가 설정되어 있어야 함
            if (LogListView != null && LogListView.Items.Count > 0)
            {
               var lastItem = LogListView.Items[LogListView.Items.Count - 1];
               LogListView.ScrollIntoView(lastItem);
            }
        }

        protected override void OnClosing(CancelEventArgs e)
        {
            // 창의 닫기 버튼(X)을 눌렀을 때 애플리케이션을 종료하는 대신 창을 숨김
            e.Cancel = true; // 실제 종료 방지
            this.Hide();     // 창 숨기기
            _viewModel?.UiInfo("MainWindow 창 숨김 (트레이 아이콘으로 최소화).");
            // base.OnClosing(e)는 e.Cancel=true일 때 호출하지 않는 것이 일반적일 수 있으나,
            // WPF 기본 동작에 따라 필요하다면 호출. 여기서는 생략해도 무방할 수 있음.
        }

        // 이 메서드는 이제 App.xaml.cs의 ExitApplication_MenuItemClick에서 Shutdown을 호출하므로,
        // MainWindow에서 직접적인 Shutdown 호출은 필요 없을 수 있습니다.
        // public async Task PerformCleanupAndShutdown()
        // {
        //     if (_viewModel != null)
        //     {
        //         await _viewModel.CleanupAsync();
        //     }
        //     Application.Current.Shutdown();
        // }
    }
}
MainWindow.xaml.cs 주요 변경 사항:

Window_Loaded: this.Hide()를 호출하여 창이 처음 나타나자마자 바로 숨깁니다. 로그 자동 스크롤을 위한 이벤트 핸들러도 여기에 등록합니다.
OnClosing: 창의 닫기(X) 버튼을 클릭했을 때 e.Cancel = true;로 설정하여 실제 종료를 막고, this.Hide()를 호출하여 창만 숨깁니다.
PerformCleanupAndShutdown 메서드는 이제 App.xaml.cs의 ExitApplication_MenuItemClick에서 Application.Current.Shutdown()을 직접 호출하므로, MainWindow에서 중복으로 호출할 필요는 없습니다.
6. ViewModels/MainViewModel.cs (약간의 조정 - 선택 사항)
App.xaml.cs에서 AgentCoreService의 시작을 담당하므로, MainViewModel의 LoadedCommand는 이제 필수가 아니게 됩니다. UpdateAgentStatus()는 App.xaml.cs에서 서비스 상태 변경 시 호출해주거나, AgentCoreService의 상태를 바인딩 가능한 속성으로 만들어 연동할 수 있습니다.

이전 답변(#52)에서 MainViewModel 코드는 이미 LoadedCommand를 선택적으로 만들고, UpdateAgentStatus를 통해 상태를 반영하도록 되어 있으므로, 큰 변경 없이 사용할 수 있습니다. App.xaml.cs에서 _mainViewModel.UpdateAgentStatus()를 서비스 시작/중지 직후에 호출하는 것이 좋습니다. (위 App.xaml.cs 코드에 반영됨)

실행 및 확인:

NuGet 패키지 Hardcodet.NotifyIcon.Wpf를 SAgentM.App 프로젝트에 설치합니다.
agent_icon.ico 파일을 프로젝트에 올바르게 추가하고 Resource로 설정합니다. (App.xaml의 IconSource 경로 확인)
위 코드들을 각 파일에 적용하고 프로젝트를 빌드합니다.
SAgentM.App.exe를 (관리자 권한으로) 실행합니다.
이제 메인 창이 바로 뜨지 않고 시스템 트레이에 아이콘만 나타나야 합니다.
AgentCoreService는 자동으로 시작되어야 합니다 (로그 확인).
트레이 아이콘을 더블 클릭하거나, 우클릭 메뉴에서 "상태 보기/숨기기"를 선택하여 MainWindow가 나타나고 사라지는지 확인합니다.
MainWindow의 X 버튼을 누르면 창이 숨겨지는지 확인합니다.