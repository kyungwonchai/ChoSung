PLC 시뮬레이터 프로그램을 만들어서 Mewtocol 프로토콜을 모방하는 방법으로, WPF 애플리케이션을 사용해 가상으로 PLC의 기능을 시뮬레이션할 수 있습니다. 이 시뮬레이터는 실제 PLC 장비가 없는 상황에서 테스트 목적으로 사용할 수 있습니다.

다음은 요청하신 시뮬레이터의 요구사항을 충족하는 WPF 프로젝트 예제입니다.

프로젝트 개요
솔루션명: PLCPanaSimul
기능:
뮤토콜 명령 수신: 시리얼 포트를 통해 명령을 수신하고, 해당 명령을 해석하여 시뮬레이션된 메모리 공간에 데이터를 씁니다.
D2300, D2330, D2310 레지스터 처리: D2300에 값을 쓰면, 일정 시간 후 D2330에 해당 값을 써서 동작 완료를 시뮬레이션합니다.
R520, R521 센서 시뮬레이션: 버튼을 통해 센서의 감지 상태를 시뮬레이션합니다.
기본 응답 전송: PLC가 명령을 처리한 후, 기본 응답 메시지를 전송합니다.
주요 구성 요소
MainWindow.xaml: UI를 정의하는 XAML 파일입니다.
MainWindow.xaml.cs: UI 이벤트를 처리하는 코드 비하인드 파일입니다.
PLCSimulator.cs: PLC 시뮬레이션 로직을 처리하는 클래스입니다.
ComPortManager.cs: 시리얼 포트 통신을 관리하는 클래스입니다.
1. MainWindow.xaml
xml
코드 복사
<Window x:Class="PLCPanaSimul.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Panasonic Simulator" Height="300" Width="400">
    <Grid>
        <!-- D2300 데이터 전송 버튼 -->
        <Button x:Name="BtnSendD2300" Content="Send D2300" HorizontalAlignment="Left" VerticalAlignment="Top" Width="100" Height="30" Margin="10" Click="BtnSendD2300_Click"/>
        <!-- D2330 완료 신호 전송 버튼 -->
        <Button x:Name="BtnCompleteD2330" Content="Complete D2330" HorizontalAlignment="Left" VerticalAlignment="Top" Width="100" Height="30" Margin="120,10,0,0" Click="BtnCompleteD2330_Click"/>
        <!-- 센서 버튼 -->
        <Button x:Name="BtnSensorR520" Content="Sensor R520" HorizontalAlignment="Left" VerticalAlignment="Top" Width="100" Height="30" Margin="10,50,0,0" MouseDown="BtnSensorR520_MouseDown" MouseUp="BtnSensorR520_MouseUp"/>
        <Button x:Name="BtnSensorR521" Content="Sensor R521" HorizontalAlignment="Left" VerticalAlignment="Top" Width="100" Height="30" Margin="120,50,0,0" MouseDown="BtnSensorR521_MouseDown" MouseUp="BtnSensorR521_MouseUp"/>
        <!-- 로그 출력 -->
        <ListBox x:Name="LogListBox" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="360" Height="150" Margin="10,100,0,0"/>
    </Grid>
</Window>
2. MainWindow.xaml.cs
csharp
코드 복사
using System.Windows;
using PLCPanaSimul.Services;

namespace PLCPanaSimul
{
    public partial class MainWindow : Window
    {
        private PLCSimulator _plcSimulator;

        public MainWindow()
        {
            InitializeComponent();
            _plcSimulator = new PLCSimulator(LogMessage);
        }

        // D2300 데이터를 전송하는 버튼 클릭 이벤트
        private void BtnSendD2300_Click(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SendDataToPLC("D2300", "SomeValue");
        }

        // D2330 완료 신호를 전송하는 버튼 클릭 이벤트
        private void BtnCompleteD2330_Click(object sender, RoutedEventArgs e)
        {
            _plcSimulator.CompleteOperation("D2330");
        }

        // R520 센서가 감지되었을 때 호출
        private void BtnSensorR520_MouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            _plcSimulator.SetSensorStatus("R520", true);
        }

        // R520 센서가 감지가 해제되었을 때 호출
        private void BtnSensorR520_MouseUp(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            _plcSimulator.SetSensorStatus("R520", false);
        }

        // R521 센서가 감지되었을 때 호출
        private void BtnSensorR521_MouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            _plcSimulator.SetSensorStatus("R521", true);
        }

        // R521 센서가 감지가 해제되었을 때 호출
        private void BtnSensorR521_MouseUp(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            _plcSimulator.SetSensorStatus("R521", false);
        }

        // 로그 메시지를 출력하는 메서드
        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() => LogListBox.Items.Add(message));
        }
    }
}
3. PLCSimulator.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

namespace PLCPanaSimul.Services
{
    public class PLCSimulator
    {
        private Dictionary<string, int> _memory; // PLC의 메모리 시뮬레이션
        private Action<string> _logCallback; // 로그 출력 콜백

        public PLCSimulator(Action<string> logCallback)
        {
            _memory = new Dictionary<string, int>
            {
                { "D2300", 0 },
                { "D2330", 0 },
                { "R520", 0 },
                { "R521", 0 }
            };
            _logCallback = logCallback;
        }

        // PLC로 데이터를 전송하는 메서드 (시뮬레이션)
        public void SendDataToPLC(string address, string value)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = int.Parse(value);
                _logCallback?.Invoke($"Data sent to {address}: {value}");
                Task.Delay(3000).ContinueWith(_ => CompleteOperation("D2330")); // 3초 후 D2330에 동작 완료
            }
        }

        // 동작 완료를 시뮬레이션하는 메서드
        public void CompleteOperation(string address)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = 1;
                _logCallback?.Invoke($"Operation completed at {address}");
            }
        }

        // 센서 상태를 설정하는 메서드
        public void SetSensorStatus(string sensor, bool status)
        {
            if (_memory.ContainsKey(sensor))
            {
                _memory[sensor] = status ? 1 : 0;
                _logCallback?.Invoke($"Sensor {sensor} status: {(status ? "Active" : "Inactive")}");
            }
        }
    }
}
4. ComPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;

namespace PLCPanaSimul.Services
{
    public class ComPortManager
    {
        private SerialPort _port;

        public ComPortManager(string portName)
        {
            _port = new SerialPort(portName, 9600, Parity.None, 8, StopBits.One);
            _port.DataReceived += Port_DataReceived;
        }

        public void OpenPort()
        {
            if (!_port.IsOpen)
            {
                _port.Open();
            }
        }

        public void ClosePort()
        {
            if (_port.IsOpen)
            {
                _port.Close();
            }
        }

        private void Port_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            var sp = (SerialPort)sender;
            string data = sp.ReadExisting();
            Console.WriteLine($"Data received: {data}");
        }
    }
}
설명
MainWindow.xaml:

UI 요소와 관련된 정의입니다. 각 버튼은 특정 작업을 트리거하고, ListBox는 로그 출력을 보여줍니다.
MainWindow.xaml.cs:

UI 이벤트를 처리하는 코드입니다. 각 버튼 클릭과 센서 상태 변경 이벤트를 처리하여 PLCSimulator 클래스에 작업을 위임합니다.
로그 메시지를 표시하는 LogMessage 메서드를 통해, 모든 이벤트와 작업 로그가 ListBox에 추가됩니다.
PLCSimulator.cs:

PLC 동작을 시뮬레이션하는 핵심 로직을 담당합니다. 데이터 전송, 동작 완료, 센서 상태 설정을 시뮬레이션합니다.
D2300에 값을 전송하고 3초 뒤에 D2330에 동작 완료 값을 쓰는 작업을 비동기적으로 처리합니다.
ComPortManager.cs:

시리얼 포트 통신을 관리합니다. PLC 시뮬레이터가 시리얼 통신을 모방할 수 있도록 기본적인 포트 열기, 닫기, 데이터 수신 이벤트를 처리합니다.
결론
위의 예제는 PLC 시뮬레이터를 만들기 위한 기본적인 구조를 제공합니다. 실제 PLC 없이도 Mewtocol 프로토콜을 사용하는 장비와의 통신을 테스트할 수 있습니다. 각 컴포넌트는 독립적으로 설계되어 있으며, WPF와 시리얼 통신을 활용하여 실제와 유사한 환경을 시뮬레이션합니다