
import React, { useState, useEffect, useCallback } from 'react';
import { nanoid } from 'https://esm.sh/nanoid';
import sql from 'https://esm.sh/mssql';
import ElementToolbox from './components/ElementToolbox';
import EditorCanvas from './components/EditorCanvas';
import PrintPreview from './components/PrintPreview';
import SettingsPanel from './components/SettingsPanel';
import LayoutList from './components/LayoutList';
import BackendInstructionsModal from './components/BackendInstructionsModal';


// --- TYPE DEFINITIONS ---
export type ElementType = 'label' | 'textbox' | 'line' | 'rectangle' | 'relative-time';

export interface LabelElement {
  id: string;
  type: ElementType;
  x: number; // position from left in px
  y: number; // position from top in px
  width: number; // in px
  height: number; // in px
  content: string; // for text or data
  fontSize: number; // in px, for text-based elements
  color: string; // text color
  backgroundColor: string; // fill color
  borderWidth: number; // in px
  borderColor: string;
  hoursAgo?: number; // for relative-time
}

export interface Layout {
  id: string;
  name: string;
  elements: LabelElement[];
}

export interface DbConfig {
    server: string;
    port: string;
    user: string;
    password: string;
    database: string;
    table: string;
}

const CANVAS_WIDTH = 400;
const CANVAS_HEIGHT = 300;
const LOCAL_STORAGE_KEY = 'canvasEditorLayouts_v1';

const App: React.FC = () => {
  const [layouts, setLayouts] = useState<Layout[]>([]);
  const [selectedLayoutId, setSelectedLayoutId] = useState<string | null>(null);
  const [selectedElementId, setSelectedElementId] = useState<string | null>(null);
  const [isInstructionsModalOpen, setIsInstructionsModalOpen] = useState(false);
  const [printSettings, setPrintSettings] = useState({
    width: 300,
    height: 200,
  });
  const [dbConfig, setDbConfig] = useState<DbConfig>({
      server: 'your-server.database.windows.net',
      port: '1433',
      user: '',
      password: '',
      database: '',
      table: 'Layouts',
  });
  
  const [isEditMode, setIsEditMode] = useState(false);
  const [passwordInput, setPasswordInput] = useState('');

  // Load from local storage or initialize on mount
  useEffect(() => {
    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    let loadedSuccessfully = false;
    if (savedData) {
        try {
            const { layouts: savedLayouts, printSettings: savedPrintSettings } = JSON.parse(savedData);
            if (Array.isArray(savedLayouts) && savedLayouts.length > 0) {
              setLayouts(savedLayouts);
              setSelectedLayoutId(savedLayouts[0].id);
              if (savedPrintSettings) setPrintSettings(savedPrintSettings);
              loadedSuccessfully = true;
            }
        } catch (e) {
            console.error("Failed to parse layouts from local storage.", e);
        }
    }

    if (!loadedSuccessfully) {
        // Initialize with 20 empty layouts
        const initialLayouts = Array.from({ length: 20 }, (_, i) => ({
            id: nanoid(),
            name: `Label ${i + 1}`,
            elements: [],
        }));
        setLayouts(initialLayouts);
        setSelectedLayoutId(initialLayouts[0].id);
    }
  }, []);
  
  const handleEnableEditMode = (e: React.FormEvent) => {
    e.preventDefault();
    if (passwordInput === '시스템2@') {
      setIsEditMode(true);
    } else {
      alert('암호가 올바르지 않습니다.');
      setPasswordInput('');
    }
  };

  const handleDisableEditMode = () => {
    setIsEditMode(false);
    setPasswordInput('');
    setSelectedElementId(null);
  };

  const handlePrint = () => {
    window.print();
  };
  
  const addElement = (type: ElementType) => {
    if (!isEditMode || !selectedLayoutId) return;

    const baseElement = {
      id: nanoid(),
      type,
      x: CANVAS_WIDTH / 2 - 50,
      y: CANVAS_HEIGHT / 2 - 25,
      width: 100,
      height: 50,
      fontSize: 16,
      color: '#1e293b', // slate-800
      backgroundColor: 'transparent',
      borderWidth: 0,
      borderColor: 'transparent',
    };

    let newElement: LabelElement;

    switch (type) {
        case 'label':
            newElement = { ...baseElement, content: 'Label' };
            break;
        case 'textbox':
            newElement = { ...baseElement, content: 'Editable Text', borderWidth: 1, borderColor: '#64748b', backgroundColor: '#f8fafc' }; // slate-500 border, slate-50 bg
            break;
        case 'line':
            newElement = { ...baseElement, content: '', height: 2, backgroundColor: '#1e293b' };
            break;
        case 'rectangle':
            newElement = { ...baseElement, content: '', width: 100, height: 80, y: CANVAS_HEIGHT / 2 - 40, backgroundColor: 'transparent', borderWidth: 1, borderColor: '#64748b' }; // slate-200 bg, slate-500 border
            break;
        case 'relative-time':
            newElement = { ...baseElement, content: '', hoursAgo: 1 };
            break;
        default:
            return;
    }
    
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: [...layout.elements, newElement] }
            : layout
    ));
    setSelectedElementId(newElement.id);
  };
  
  const updateElement = useCallback((id: string, newProps: Partial<LabelElement>) => {
    if (!isEditMode) return;
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: layout.elements.map(el => el.id === id ? { ...el, ...newProps } : el) }
            : layout
    ));
  }, [selectedLayoutId, isEditMode]);

  const updatePrintSettings = useCallback((newSettings: Partial<typeof printSettings>) => {
    setPrintSettings(prev => ({
        ...prev,
        ...newSettings
    }));
  }, []);
  
  const deleteElement = useCallback((id: string) => {
    if (!isEditMode) return;
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: layout.elements.filter(el => el.id !== id) }
            : layout
    ));

    if (selectedElementId === id) {
      setSelectedElementId(null);
    }
  }, [selectedLayoutId, selectedElementId, isEditMode]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isEditMode) return;
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementId) {
        const target = e.target as HTMLElement;
        if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA'){
          e.preventDefault();
          deleteElement(selectedElementId);
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementId, deleteElement, isEditMode]);
  
  const handleSaveLayout = useCallback(() => {
    const layoutData = { layouts, printSettings };
    const layoutJson = JSON.stringify(layoutData, null, 2);
    localStorage.setItem(LOCAL_STORAGE_KEY, layoutJson);
    alert('All layouts have been saved to your browser\'s local storage.');
  }, [layouts, printSettings]);

  const handleLoadLayout = useCallback(() => {
    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (savedData) {
        try {
            const { layouts: savedLayouts, printSettings: savedPrintSettings } = JSON.parse(savedData);
            if (Array.isArray(savedLayouts)) {
                setLayouts(savedLayouts);
                setSelectedLayoutId(savedLayouts.length > 0 ? savedLayouts[0].id : null);
                setSelectedElementId(null);
                if (savedPrintSettings) setPrintSettings(savedPrintSettings);
                alert('All layouts loaded from local storage.');
            } else {
                throw new Error("Saved data is not in the correct format.");
            }
        } catch (e) {
            alert('Could not parse layouts from local storage.');
            console.error(e);
        }
    } else {
        alert('No saved layouts found in local storage.');
    }
  }, []);

  const handleSaveToDb = async () => {
    if (!confirm('This will attempt to save all layouts to the database, potentially overwriting existing data. Are you sure?')) {
        return;
    }

    alert('⚠️ SECURITY WARNING: You are connecting directly to a database from the browser. This is INSECURE and exposes your credentials. This feature is for development/testing ONLY. Use a backend API in production.');

    try {
        const connectionConfig = {
            user: dbConfig.user,
            password: dbConfig.password,
            server: dbConfig.server,
            port: parseInt(dbConfig.port, 10),
            database: dbConfig.database,
            options: {
                encrypt: true, // Necessary for Azure SQL
                trustServerCertificate: false,
            },
            pool: {
                max: 10,
                min: 0,
                idleTimeoutMillis: 30000
            }
        };

        await sql.connect(connectionConfig);

        for (const layout of layouts) {
            const elementsJson = JSON.stringify(layout.elements);
            const request = new sql.Request();
            await request
                .input('id', sql.NVarChar, layout.id)
                .input('name', sql.NVarChar, layout.name)
                .input('elements', sql.NText, elementsJson)
                .query(`
                    MERGE INTO ${dbConfig.table} AS target
                    USING (SELECT @id AS id, @name AS name, @elements AS elements) AS source
                    ON (target.id = source.id)
                    WHEN MATCHED THEN
                        UPDATE SET name = source.name, elements = source.elements, lastModified = GETDATE()
                    WHEN NOT MATCHED THEN
                        INSERT (id, name, elements) VALUES (source.id, source.name, source.elements);
                `);
            console.log(`Successfully saved layout "${layout.name}" to DB table "${dbConfig.table}".`);
        }

        alert('All layouts were successfully saved to the database.');
        await sql.close();

    } catch (err: any) {
        console.error('Database save error:', err);
        alert(`Failed to save layouts to the database. See console for details. Error: ${err.message}`);
        if (sql.connected) {
            await sql.close();
        }
    }
  };

  const handleLoadFromDb = async () => {
      if (!confirm('This will replace your current layouts with data from the database. Are you sure?')) {
          return;
      }
      
      alert('⚠️ SECURITY WARNING: You are connecting directly to a database from the browser. This is INSECURE and exposes your credentials. This feature is for development/testing ONLY. Use a backend API in production.');

      try {
          const connectionConfig = {
              user: dbConfig.user,
              password: dbConfig.password,
              server: dbConfig.server,
              port: parseInt(dbConfig.port, 10),
              database: dbConfig.database,
              options: {
                  encrypt: true,
                  trustServerCertificate: false,
              },
              pool: {
                  max: 10,
                  min: 0,
                  idleTimeoutMillis: 30000
              }
          };

          await sql.connect(connectionConfig);
          const result = await sql.query(`SELECT id, name, elements FROM ${dbConfig.table}`);
          
          const dbLayouts: Layout[] = result.recordset.map((record: any) => {
             try {
                return {
                   id: record.id,
                   name: record.name,
                   elements: JSON.parse(record.elements)
                };
             } catch(e) {
                console.error(`Could not parse elements for layout id ${record.id}`, e);
                return {
                    id: record.id,
                    name: record.name,
                    elements: []
                };
             }
          });

          if (dbLayouts.length > 0) {
              setLayouts(dbLayouts);
              setSelectedLayoutId(dbLayouts[0].id);
              setSelectedElementId(null);
              alert(`Successfully loaded ${dbLayouts.length} layouts from the database.`);
          } else {
              alert('No layouts found in the database table.');
          }
          await sql.close();

      } catch (err: any) {
          console.error('Database load error:', err);
          alert(`Failed to load layouts from the database. See console for details. Error: ${err.message}`);
          if (sql.connected) {
              await sql.close();
          }
      }
  };

  const handleSelectLayout = (id: string) => {
    setSelectedLayoutId(id);
    setSelectedElementId(null); // Deselect element when switching layouts
  };

  const selectedLayout = layouts.find(l => l.id === selectedLayoutId);
  const elements = selectedLayout ? selectedLayout.elements : [];
  const selectedElement = elements.find(el => el.id === selectedElementId) || null;

  return (
    <div className="flex flex-col h-screen bg-slate-100 font-sans text-slate-800">
      <header className="bg-white shadow-md p-3 print:hidden z-20">
        <div className="container mx-auto flex justify-between items-center">
            <h1 className="text-xl font-bold text-slate-700 flex-shrink-0">Multi-Label Canvas Editor</h1>

            <div className="flex-1 flex justify-center px-8">
                {!isEditMode ? (
                    <form onSubmit={handleEnableEditMode} className="flex items-center gap-2">
                        <input
                            type="password"
                            value={passwordInput}
                            onChange={(e) => setPasswordInput(e.target.value)}
                            placeholder="암호"
                            className="w-40 px-3 py-2 text-sm border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500"
                            aria-label="Password for edit mode"
                        />
                        <button type="submit" className="px-5 py-2 text-sm font-semibold bg-slate-600 text-white rounded-lg shadow-sm hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500">
                            편집
                        </button>
                    </form>
                ) : (
                    <button onClick={handleDisableEditMode} className="px-5 py-2 text-sm font-semibold bg-red-600 text-white rounded-lg shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                        편집 종료
                    </button>
                )}
            </div>
            
            <div className="flex items-center gap-3">
                <button
                    onClick={() => setIsInstructionsModalOpen(true)}
                    className="px-5 py-2 text-sm font-semibold bg-slate-200 text-slate-800 rounded-lg shadow-sm hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-400 transition-colors"
                >
                    설명
                </button>
                <button
                    onClick={handlePrint}
                    className="px-5 py-2 text-sm font-semibold bg-indigo-600 text-white rounded-lg shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors"
                >
                    Print
                </button>
            </div>
        </div>
      </header>

      <main className="flex flex-1 overflow-hidden">
        <LayoutList
            layouts={layouts}
            selectedLayoutId={selectedLayoutId}
            onSelectLayout={handleSelectLayout}
        />
        {isEditMode && <ElementToolbox onAddElement={addElement} />}
        <div id="editor-wrapper" className="flex-1 p-4 sm:p-6 lg:p-8 overflow-auto bg-slate-200">
          <EditorCanvas
            elements={elements}
            selectedElementId={selectedElementId}
            onSelectElement={setSelectedElementId}
            onUpdateElement={updateElement}
            canvasWidth={CANVAS_WIDTH}
            canvasHeight={CANVAS_HEIGHT}
            printSettings={printSettings}
            isEditMode={isEditMode}
          />
        </div>
        {isEditMode && <SettingsPanel
            selectedElement={selectedElement}
            onUpdateElement={updateElement}
            onDeleteElement={deleteElement}
            printSettings={printSettings}
            onUpdatePrintSettings={updatePrintSettings}
            dbConfig={dbConfig}
            onUpdateDbConfig={setDbConfig}
            onSaveLayout={handleSaveLayout}
            onLoadLayout={handleLoadLayout}
            onSaveToDb={handleSaveToDb}
            onLoadFromDb={handleLoadFromDb}
        />}
      </main>
      <PrintPreview elements={elements} canvasWidth={CANVAS_WIDTH} canvasHeight={CANVAS_HEIGHT} printSettings={printSettings} />
      <BackendInstructionsModal
        isOpen={isInstructionsModalOpen}
        onClose={() => setIsInstructionsModalOpen(false)}
      />
    </div>
  );
};
