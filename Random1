알겠습니다. 요청하신 내용을 바탕으로 Flask의 app.py 파일을 수정하고, Kotlin에서 APK 버전 체크와 다운로드를 수행하는 코드를 다시 제공해 드리겠습니다.

수정된 Flask app.py 파일
Flask 서버에서 여러 APK에 대한 버전 정보를 관리하고, 각 APK 파일을 다운로드할 수 있도록 수정된 전체 코드입니다.

python
코드 복사
from flask import Flask, jsonify, send_from_directory, abort, request
import os
import json

app = Flask(__name__)

# 여러 APK의 버전 정보를 제공하는 엔드포인트
@app.route('/api/version', methods=['GET'])
def get_version():
    apk_name = request.args.get('apk')  # 쿼리 파라미터에서 APK 이름을 가져옴
    if not apk_name:
        return jsonify({"error": "APK name is required"}), 400
    
    version_file = f'version_files/{apk_name}_version.json'
    
    try:
        with open(version_file, 'r') as f:
            version_info = json.load(f)
        return jsonify(version_info)
    except FileNotFoundError:
        return jsonify({"error": "Version file not found"}), 404
    except Exception as e:
        return jsonify({"error": str(e)}), 500

# 여러 APK 파일을 제공하는 엔드포인트
@app.route('/download/<apk_name>', methods=['GET'])
def download_apk(apk_name):
    try:
        return send_from_directory('static/apks', f'{apk_name}.apk')
    except FileNotFoundError:
        abort(404)

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=8116)
설명
/api/version 엔드포인트:

이 엔드포인트는 쿼리 파라미터 apk를 통해 특정 APK의 버전 정보를 요청할 수 있습니다.
예를 들어, /api/version?apk=apk1는 apk1_version.json 파일의 내용을 반환합니다.
version_files 폴더에는 각 APK의 버전 정보가 저장된 JSON 파일이 있어야 합니다.
/download/<apk_name> 엔드포인트:

이 엔드포인트는 apk_name에 따라 동적으로 APK 파일을 제공하는 역할을 합니다.
예를 들어, /download/apk1는 static/apks/apk1.apk 파일을 다운로드합니다.
수정된 Kotlin 코드 (버전 체크 및 APK 다운로드)
이 코드는 앱이 시작될 때 현재 버전을 서버의 최신 버전과 비교하여 필요하면 업데이트를 수행하는 역할을 합니다.

kotlin
코드 복사
import android.content.Context
import android.content.Intent
import android.content.pm.PackageInfo
import android.content.pm.PackageManager
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.FileProvider
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // APK 이름을 정의합니다 (예: apk1, apk2 등)
        val apkName = "apk1"

        // 업데이트 체크를 비동기로 수행
        CoroutineScope(Dispatchers.IO).launch {
            checkForUpdates(apkName)
        }
    }

    private suspend fun checkForUpdates(apkName: String) {
        try {
            val packageManager: PackageManager = this.packageManager
            val packageInfo: PackageInfo = packageManager.getPackageInfo(this.packageName, 0)
            val currentVersion = packageInfo.versionName

            val latestVersion = getLatestVersionFromServer(apkName)

            if (latestVersion != null) {
                Log.d("AppVersion", "Current Version: $currentVersion, Latest Version: $latestVersion")

                if (isUpdateRequired(currentVersion, latestVersion)) {
                    Log.d("AppVersion", "Update is required. Downloading new APK.")
                    downloadAndInstallApk(this, apkName)
                } else {
                    Log.d("AppVersion", "App is up to date.")
                }
            } else {
                Log.e("AppVersion", "Failed to fetch the latest version from the server.")
            }
        } catch (e: PackageManager.NameNotFoundException) {
            e.printStackTrace()
            Log.e("AppVersion", "Failed to get app version info")
        }
    }

    private suspend fun getLatestVersionFromServer(apkName: String): String? {
        val client = OkHttpClient()
        val request = Request.Builder()
            .url("http://10.244.122.222:8116/api/version?apk=$apkName")  // 서버 URL을 적절히 수정하세요.
            .build()

        return try {
            val response = client.newCall(request).execute()
            if (response.isSuccessful) {
                val jsonResponse = response.body?.string()
                val jsonObject = JSONObject(jsonResponse)
                jsonObject.getString("version")
            } else {
                null
            }
        } catch (e: Exception) {
            e.printStackTrace()
            null
        }
    }

    private suspend fun downloadAndInstallApk(context: Context, apkName: String) {
        val client = OkHttpClient()
        val request = Request.Builder().url("http://10.244.122.222:8116/download/$apkName").build()

        try {
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                Log.e("AppVersion", "Failed to download APK: ${response.code}")
                return
            }

            val apkFile = File(context.getExternalFilesDir(null), "$apkName.apk")
            FileOutputStream(apkFile).use { fos ->
                fos.write(response.body?.bytes())
            }

            val apkUri: Uri = FileProvider.getUriForFile(
                context,
                context.applicationContext.packageName + ".provider",
                apkFile
            )

            withContext(Dispatchers.Main) {
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
                    setDataAndType(apkUri, "application/vnd.android.package-archive")
                }
                context.startActivity(intent)
            }

        } catch (e: Exception) {
            e.printStackTrace()
            Log.e("AppVersion", "Error during APK download and install: ${e.message}")
        }
    }

    private fun isUpdateRequired(currentVersion: String, latestVersion: String): Boolean {
        val currentVersionParts = currentVersion.split(".")
        val latestVersionParts = latestVersion.split(".")

        val length = maxOf(currentVersionParts.size, latestVersionParts.size)
        for (i in 0 until length) {
            val currentPart = currentVersionParts.getOrNull(i)?.toIntOrNull() ?: 0
            val latestPart = latestVersionParts.getOrNull(i)?.toIntOrNull() ?: 0

            if (currentPart < latestPart) {
                return true
            } else if (currentPart > latestPart) {
                return false
            }
        }
        return false
    }
}
설명
checkForUpdates() 함수:

현재 앱의 버전을 가져와 서버의 최신 버전과 비교합니다.
버전이 낮을 경우 downloadAndInstallApk() 함수를 호출하여 새로운 APK를 다운로드하고 설치합니다.
getLatestVersionFromServer() 함수:

서버에서 특정 APK의 최신 버전 정보를 받아옵니다.
downloadAndInstallApk() 함수:

서버에서 APK 파일을 다운로드하고, 설치를 진행합니다.
isUpdateRequired() 함수:

현재 버전과 최신 버전을 비교하여 업데이트가 필요한지 확인합니다.
이 코드와 서버 설정을 통해 Android 앱이 실행될 때마다 APK의 최신 버전을 확인하고, 필요할 경우 업데이트하도록 설정할 수 있습니다. 문제가 해결되지 않거나 추가적인 도움이 필요하시면 말씀해 