문제 해결을 위한 제안 (응답을 더 확실히 먼저 보내는 방식):

SAgentM.App의 로직을 수정하여, "모니터 끄기" 명령에 대한 "조기 확인" 응답을 SControlM으로 완전히 전송한 후, 실제 모니터 끄기 동작을 수행하도록 변경하는 것입니다.

1. SAgentM.App/Services/AgentCoreService.cs의 ExecuteDirectCommandAsync 수정:
MonitorAction.Off의 경우, 실제 LocalDeviceControl.SetMonitorState(MonitorAction.Off) 호출을 제거하고, 메시지를 약간 수정하여 "곧 꺼질 것"임을 명시합니다.

C#

// SAgentM.App/Services/AgentCoreService.cs - ExecuteDirectCommandAsync 메서드 내
// ...
case CommandNames.MonitorControl:
    // ... (payload deserialization 등의 코드는 동일)
    if (monitorPayload.Action == MonitorAction.Off)
    {
        success = true;
        // 메시지를 변경하여, 응답이 먼저 가고 모니터가 잠시 후 꺼질 것임을 명확히 함
        message = $"Monitor Off command acknowledged. Monitor will turn off shortly. Early confirmation sent.";
        _loggingService.Info($"[{clientIp}] {message} (Packet ID: {requestPacket.PacketId})");
        responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
        // 여기서 LocalDeviceControl.SetMonitorState(MonitorAction.Off)를 호출하지 않습니다!
    }
    else 
    {
        LocalDeviceControl.SetMonitorState(monitorPayload.Action); // 켜기/대기는 즉시 실행
        success = true;
        message = $"Monitor state set to {monitorPayload.Action} successfully.";
        _loggingService.Info($"[{clientIp}] {message}");
        responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
    }
    break;
// ...
2. SAgentM.App/Services/AgentCoreService.cs의 HandleClientAsync 수정:
ProcessCommandAsync로부터 응답 패킷을 받은 후, 만약 해당 명령이 "모니터 끄기"였고 "조기 확인" 응답이었다면, 응답을 클라이언트에게 전송한 후에 실제 모니터 끄기 작업을 백그라운드에서 수행합니다.

C#

// SAgentM.App/Services/AgentCoreService.cs - HandleClientAsync 메서드 내
// ...
if (requestPacket != null)
{
    _loggingService.Info($"[{clientIpInfo}] 명령 수신: ID={requestPacket.PacketId}, Command={requestPacket.CommandName}, Instruction={requestPacket.Instruction}");
    CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);

    if (responsePacket != null)
    {
        string responseJson = JsonConvert.SerializeObject(responsePacket);
        if (token.IsCancellationRequested)
        {
            _loggingService.Debug($"[{clientIpInfo}] 응답 전송 전 취소 감지됨.");
            token.ThrowIfCancellationRequested();
        }
        await writer.WriteLineAsync(responseJson); // <<--- 먼저 응답 전송
        _loggingService.Debug($"[{clientIpInfo}] 응답 전송: ID={responsePacket.PacketId}, Command={responsePacket.CommandName}");

        // 만약 방금 처리한 요청이 "모니터 끄기" 직접 실행이었고, 응답이 성공(조기 확인)이었다면,
        // 여기서 실제 모니터 끄기 작업을 수행합니다.
        if (requestPacket.Instruction == CommandInstruction.DirectExecute &&
            requestPacket.CommandName == CommandNames.MonitorControl)
        {
            try
            {
                var originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson);
                if (originalPayload != null && originalPayload.Action == MonitorAction.Off)
                {
                    // 응답 페이로드에서 성공 여부 확인 (선택적이지만 더 안전)
                    bool wasEarlyConfirmSuccess = false;
                    if (!string.IsNullOrEmpty(responsePacket.PayloadJson)) {
                        var responsePayload = JsonConvert.DeserializeObject<GenericResponsePayload>(responsePacket.PayloadJson);
                        if (responsePayload != null) wasEarlyConfirmSuccess = responsePayload.Success;
                    }

                    if (wasEarlyConfirmSuccess) // 조기 확인 응답이 '성공'이었을 경우에만
                    {
                        _loggingService.Info($"[{clientIpInfo}] 조기 확인 응답 전송 완료. 실제 모니터 끄기 작업 시작 (백그라운드). Packet ID: {requestPacket.PacketId}");
                        // 이 작업은 현재 HandleClientAsync의 흐름을 막지 않도록 Task.Run으로 분리
                        Task.Run(() =>
                        {
                            try
                            {
                                LocalDeviceControl.SetMonitorState(MonitorAction.Off);
                                _loggingService.Info($"[{clientIpInfo}] 실제 모니터 끄기 작업 완료 (백그라운드). Packet ID: {requestPacket.PacketId}");
                            }
                            catch (Exception ex)
                            {
                                _loggingService.Error($"[{clientIpInfo}] 백그라운드 모니터 끄기 작업 중 오류 발생. Packet ID: {requestPacket.PacketId}", ex);
                            }
                        }); // 이 Task는 await하지 않음 (Fire and forget)
                    }
                }
            }
            catch (JsonException jsonEx)
            {
                _loggingService.Error($"[{clientIpInfo}] 모니터 끄기 후처리 중 PayloadJson 역직렬화 오류. Packet ID: {requestPacket.PacketId}", jsonEx);
            }
        }
    }
}
// ...
위 수정의 핵심 아이디어:

ExecuteDirectCommandAsync에서 MonitorAction.Off의 경우, 실제 P/Invoke 호출 없이 "곧 꺼질 것"이라는 메시지를 담은 성공 응답만 생성해서 반환합니다.
HandleClientAsync에서는 이 "조기 확인" 응답을 SControlM에 먼저 보냅니다.
응답을 성공적으로 보낸 후, 만약 해당 명령이 MonitorAction.Off였음을 확인하고 Task.Run을 사용하여 별도의 백그라운드 작업으로 실제 모니터 끄기(LocalDeviceControl.SetMonitorState(MonitorAction.Off))를 실행합니다. 이 작업은 await하지 않으므로, 모니터가 꺼지면서 네트워크가 끊기더라도 이미 응답은 전송된 상태가 됩니다.
확인 요청:

이 코드를 적용하기 전에, 혹시 현재 SControlM에 표시되는 정확한 "명령 실패" 메시지 내용과, 해당 시점의 SAgentM.App 로그를 조금 더 자세히 알려주실 수 있나요? 특히 SAgentM.App의 ClientHandler 로그에서 IOException이나 다른 오류가 기록되는지 확인해주시면 진단에 큰 도움이 됩니다.