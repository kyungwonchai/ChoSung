// 필요한 네임스페이스 추가
using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.Generic; // List<T> 사용
using System.Collections.ObjectModel;
using System.Configuration; // AppSettings 및 ConnectionStrings 사용 위해 추가
using System.Data.Entity;
using System.Data.Entity.Infrastructure; // DbEntityEntry, DbUpdateException 사용
using System.Linq;
using System.Security;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Runtime.InteropServices; // Marshal 사용

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 윈도우(MainWindow)와 연결되는 주 ViewModel 클래스입니다.
    /// (.NET Framework 4.8 버전 - 오류 수정 최종)
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable
    {
        private LockerDbContext _context;
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment;
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A";

        private SecureString _masterPasswordInput;
        private bool _isMasterModeEnabled = false;

        private ObservableCollection<LockerType> _allLockerTypes;
        private ObservableCollection<Floor> _allFloors;
        private ObservableCollection<Zone> _allZones;
        private ObservableCollection<SubPart> _allSubParts;
        private ObservableCollection<Administrator> _allAdministrators;

        public MasterDataViewModel MasterDataVM { get; private set; }
        public LogViewModel LogVM { get; private set; }

        #region Public Properties
        public ObservableCollection<LockerAssignment> LockerAssignments { get => _lockerAssignments; set => SetProperty(ref _lockerAssignments, value); }
        public LockerAssignment SelectedAssignment { get => _selectedAssignment; set { if (SetProperty(ref _selectedAssignment, value)) { ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged(); ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged(); } } }
        public string StatusBarText { get => _statusBarText; set => SetProperty(ref _statusBarText, value); }
        public SecureString MasterPasswordInput { get => _masterPasswordInput; set => SetProperty(ref _masterPasswordInput, value); }
        public bool IsMasterModeEnabled { get => _isMasterModeEnabled; set => SetProperty(ref _isMasterModeEnabled, value); }
        public ObservableCollection<LockerType> AllLockerTypes { get => _allLockerTypes; set => SetProperty(ref _allLockerTypes, value); }
        public ObservableCollection<Floor> AllFloors { get => _allFloors; set => SetProperty(ref _allFloors, value); }
        public ObservableCollection<Zone> AllZones { get => _allZones; set => SetProperty(ref _allZones, value); }
        public ObservableCollection<SubPart> AllSubParts { get => _allSubParts; set => SetProperty(ref _allSubParts, value); }
        public ObservableCollection<Administrator> AllAdministrators { get => _allAdministrators; set => SetProperty(ref _allAdministrators, value); }
        #endregion

        #region Commands
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }
        public ICommand CheckMasterPasswordCommand { get; }
        public ICommand RefreshMasterDataCommand { get; }
        #endregion

        public MainViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusBarText = "DB 연결 오류!"; return; }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();
            _allLockerTypes = new ObservableCollection<LockerType>();
            _allFloors = new ObservableCollection<Floor>();
            _allZones = new ObservableCollection<Zone>();
            _allSubParts = new ObservableCollection<SubPart>();
            _allAdministrators = new ObservableCollection<Administrator>();

            MasterDataVM = new MasterDataViewModel(_context);
            LogVM = new LogViewModel(_context);

            LoadDataCommand = new RelayCommand(async _ => await LoadInitialDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);
            CheckMasterPasswordCommand = new RelayCommand(CheckMasterPassword);
            RefreshMasterDataCommand = new RelayCommand(async _ => await LoadMasterDataAsync());

            if (_context != null) { _ = LoadInitialDataAsync(); }
        }

        /// <summary>
        /// 초기 데이터 로드 (순서 중요: 마스터 데이터 먼저 로드 시도)
        /// </summary>
        private async Task LoadInitialDataAsync()
        {
            // 마스터 데이터를 먼저 로드해야 ComboBox 등이 제대로 표시될 수 있음
            await LoadMasterDataAsync();
            // 마스터 데이터 로딩 성공 여부와 관계없이 사물함 목록 로드 시도
            await LoadAssignmentsAsync();
        }

        /// <summary>
        /// 사물함 배정 목록 로드
        /// </summary>
        private async Task LoadAssignmentsAsync()
        {
            if (_context == null) return;
            StatusBarText = "사물함 목록 로딩 중...";
            try
            {
                // MARS가 활성화되어 있어야 여러 작업을 원활히 처리 가능
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor).ThenBy(l => l.Zone).ThenBy(l => l.SpecificLocation)
                                               .ToListAsync();
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"총 {LockerAssignments.Count}개의 사물함 정보를 로드했습니다.";
            }
            catch (Exception ex) { HandleGenericException("사물함 목록 로딩", ex); }
        }

        /// <summary>
        /// 마스터 데이터 목록 로드 (콤보박스용)
        /// </summary>
        private async Task LoadMasterDataAsync()
        {
            if (_context == null) return;
            StatusBarText = "마스터 데이터 로딩 중...";
            try
            {
                // 각 목록을 순차적으로 로드 (MARS 활성화 권장)
                AllLockerTypes = new ObservableCollection<LockerType>(await _context.LockerTypes.OrderBy(t => t.Name).ToListAsync());
                AllFloors = new ObservableCollection<Floor>(await _context.Floors.OrderBy(f => f.Name).ToListAsync());
                AllZones = new ObservableCollection<Zone>(await _context.Zones.OrderBy(z => z.Name).ToListAsync());
                AllSubParts = new ObservableCollection<SubPart>(await _context.SubParts.OrderBy(p => p.Name).ToListAsync());
                AllAdministrators = new ObservableCollection<Administrator>(await _context.Administrators.OrderBy(a => a.Name).ToListAsync());
                StatusBarText = "마스터 데이터 로드 완료.";

                // MasterDataViewModel의 목록 갱신은 해당 ViewModel에서 처리
                // 필요하다면 여기서 MasterDataVM.LoadAllMasterDataAsync() 호출 가능 (단, DataReader 충돌 주의)
            }
            catch (InvalidOperationException ioEx) when (ioEx.Message.Contains("DataReader")) // DataReader 오류 특정 처리
            {
                 HandleGenericException("마스터 데이터 로딩 (DataReader 충돌 가능성)", ioEx);
                 MessageBox.Show("데이터 로딩 중 충돌이 발생했습니다. App.config 연결 문자열에 MultipleActiveResultSets=True; 옵션이 있는지 확인하거나, 잠시 후 다시 시도해 주세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
            }
            catch (Exception ex) { HandleGenericException("마스터 데이터 로딩", ex); }
        }


        /// <summary>
        /// 마스터 키 비밀번호 확인 로직
        /// </summary>
        private void CheckMasterPassword(object parameter)
        {
            try
            {
                string storedMasterKey = ConfigurationManager.AppSettings["MasterKey"];
                if (string.IsNullOrEmpty(storedMasterKey)) { MessageBox.Show("App.config에 마스터 키(MasterKey)가 정의되지 않았습니다.", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; }
                string plainPassword = ConvertToUnsecureString(MasterPasswordInput);
                if (plainPassword == storedMasterKey) { IsMasterModeEnabled = true; StatusBarText = "마스터 관리자 모드 활성화."; MessageBox.Show("마스터 키 확인 완료.", "성공", MessageBoxButton.OK, MessageBoxImage.Information); }
                else { IsMasterModeEnabled = false; MessageBox.Show("마스터 키가 일치하지 않습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
            }
            catch (ConfigurationErrorsException confEx) { MessageBox.Show($"설정 파일(App.config) 처리 오류:\n{confEx.Message}", "설정 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
            catch (Exception ex) { MessageBox.Show($"마스터 키 확인 오류: {ex.Message}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        }

        #region CRUD 및 기타 메서드

        /// <summary>
        /// 사물함 관리 탭의 변경 사항 저장
        /// </summary>
        private async Task SaveChangesAsync()
        {
             if (_context == null) return;
            StatusBarText = "변경 사항 저장 중...";
            List<DbEntityEntry> changedContextEntries = null; // 롤백을 위해 변경 전 엔트리 목록 저장
            try
            {
                 changedContextEntries = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList(); // 모든 변경 내용 추적

                 var changedLockerEntries = changedContextEntries
                    .Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified))
                    .Select(e => (DbEntityEntry<LockerAssignment>)e) // 타입 캐스팅
                    .ToList();

                 var allItemsToCheck = LockerAssignments.ToList();
                 var duplicates = allItemsToCheck
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key);
                 if (duplicates.Any())
                 {
                     MessageBox.Show($"저장 불가: 중복 위치 발견 - {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                     RollbackChanges(changedContextEntries); // 전체 변경 롤백
                     return;
                 }

                foreach(var entry in changedLockerEntries)
                {
                    entry.Entity.Administrator = _currentAdmin;
                }

                int changedCount = await _context.SaveChangesAsync();
                StatusBarText = $"성공적으로 {changedCount}개의 변경 사항을 저장했습니다.";
            }
            catch (DbUpdateException dbEx)
            {
                HandleDbUpdateException(dbEx);
                // *** 수정된 부분: dbEx.Entries를 ToList()로 변환하여 전달 ***
                RollbackChanges(dbEx.Entries.ToList()); // 예외 발생 시 포함된 엔트리 롤백
            }
            catch (Exception ex)
            {
                HandleGenericException("저장", ex);
                // *** 수정된 부분: Where 결과에 ToList() 적용 ***
                // 오류 발생 시점의 모든 변경된 엔트리 롤백 시도
                RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList());
            }
        }

        /// <summary>
        /// EF6에서 변경 사항 롤백 (간단 버전)
        /// </summary>
        /// <param name="changedEntries">롤백할 엔티티 목록 (List<DbEntityEntry> 타입으로 변경)</param>
        private void RollbackChanges(List<DbEntityEntry> changedEntries) // *** 매개변수 타입을 List<DbEntityEntry>로 변경 ***
        {
            if (_context == null || changedEntries == null) return;

            // 이미 List 타입이므로 ToList() 호출 불필요
            foreach (var entry in changedEntries)
            {
                switch (entry.State)
                {
                    case EntityState.Modified:
                        entry.CurrentValues.SetValues(entry.OriginalValues);
                        entry.State = EntityState.Unchanged;
                        break;
                    case EntityState.Added:
                        entry.State = EntityState.Detached;
                        if (entry.Entity is LockerAssignment addedEntity && LockerAssignments.Contains(addedEntity))
                        {
                            LockerAssignments.Remove(addedEntity);
                        }
                        break;
                    case EntityState.Deleted:
                        entry.State = EntityState.Unchanged;
                        break;
                }
            }
             StatusBarText = "변경 사항이 롤백되었습니다.";
        }

        /// <summary>
        /// 새 사물함 추가 (UI 및 Context)
        /// </summary>
        private void AddNewLocker(object parameter)
        {
            if (_context == null) return;
            var newAssignment = new LockerAssignment {
                LockerType = AllLockerTypes.FirstOrDefault()?.Name ?? "개인사물함",
                Floor = AllFloors.FirstOrDefault()?.Name ?? "1",
                Zone = AllZones.FirstOrDefault()?.Name ?? "A",
                SpecificLocation = "새 위치-" + Guid.NewGuid().ToString("N").Substring(0, 4),
                Administrator = _currentAdmin,
                LastUpdated = DateTime.Now
            };
            LockerAssignments.Add(newAssignment);
            _context.LockerAssignments.Add(newAssignment);
            SelectedAssignment = newAssignment;
            StatusBarText = "새 사물함 추가됨. 세부 정보 입력 후 저장 필요.";
        }

        /// <summary>
        /// 선택된 사물함 삭제
        /// </summary>
        private async Task DeleteSelectedAsync()
        {
             if (_context == null || SelectedAssignment == null) return;
            if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함 정보를 정말 삭제하시겠습니까?", "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "삭제 중...";
                try
                {
                    var assignmentToDelete = SelectedAssignment;
                    var entry = _context.Entry(assignmentToDelete);
                    if (entry.State == EntityState.Detached) { _context.LockerAssignments.Attach(assignmentToDelete); }
                     _context.LockerAssignments.Remove(assignmentToDelete);
                    int changedCount = await _context.SaveChangesAsync();
                    LockerAssignments.Remove(assignmentToDelete); SelectedAssignment = null;
                    StatusBarText = $"성공적으로 {changedCount}개의 레코드를 삭제했습니다.";
                }
                catch (DbUpdateException dbEx) { HandleDbUpdateException(dbEx); await LoadAssignmentsAsync(); }
                catch (Exception ex) { HandleGenericException("삭제", ex); await LoadAssignmentsAsync(); }
            }
        }

        /// <summary>
        /// 선택된 사물함의 사용자 배정 정보 해제
        /// </summary>
        private void ClearSelectedAssignment(object parameter)
        {
             if (_context == null || SelectedAssignment == null) return;
            SelectedAssignment.UserName = null;
            SelectedAssignment.KnoxId = null;
            SelectedAssignment.SubPart = null;
            _context.Entry(SelectedAssignment).State = EntityState.Modified;
            SelectedAssignment.Administrator = _currentAdmin;
            StatusBarText = "배정 해제됨. 변경 사항 저장 필요.";
        }

        #endregion

        #region Helper Methods

        private void HandleGenericException(string operation, Exception ex) { StatusBarText = $"{operation} 오류: {ex.Message}"; MessageBox.Show($"{operation} 중 오류 발생:\n{ex.ToString()}", "오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        private void HandleDbUpdateException(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusBarText = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); try { foreach(var entry in dbEx.Entries) { entry.Reload(); } } catch { /* Reload 실패 무시 */ } }
        private string ConvertToUnsecureString(SecureString securePassword) { if (securePassword == null) return string.Empty; IntPtr ptr = IntPtr.Zero; try { ptr = Marshal.SecureStringToGlobalAllocUnicode(securePassword); return Marshal.PtrToStringUni(ptr); } finally { Marshal.ZeroFreeGlobalAllocUnicode(ptr); } }

        #endregion

        #region IDisposable 구현 (DbContext 해제)
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
```

**주요 수정 사항:**

1.  **`RollbackChanges` 메서드 시그니처 변경:** 메서드가 받는 매개변수 타입을 `IEnumerable<DbEntityEntry>`에서 `List<DbEntityEntry>`로 명시적으로 변경했습니다.
    ```csharp
    // 변경 전: private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries)
    // 변경 후:
    private void RollbackChanges(List<DbEntityEntry> changedEntries)
    ```
2.  **`SaveChangesAsync`의 `catch` 블록 수정:** `RollbackChanges`를 호출할 때 전달하는 인수가 `List<DbEntityEntry>` 타입이 되도록 `.ToList()` 호출을 확인하고 적용했습니다.
    ```csharp
    catch (DbUpdateException dbEx)
    {
        HandleDbUpdateException(dbEx);
        // dbEx.Entries는 ReadOnlyCollection<DbEntityEntry> 이므로 ToList() 필요
        RollbackChanges(dbEx.Entries.ToList());
    }
    catch (Exception ex)
    {
        HandleGenericException("저장", ex);
        // Where 결과는 IEnumerable<DbEntityEntry> 이므로 ToList() 필요
        RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList());
    }
    ```
3.  **데이터 로딩 순서 변경:** `LoadInitialDataAsync`에서 마스터 데이터를 먼저 로드하도록 순서를 조정했습니다. (콤보박스 목록이 먼저 채워져야 할 수 있으므로)
4.  **DataReader 오류 처리 강화:** `LoadMasterDataAsync`의 `catch` 블록에 `InvalidOperationException` 중 DataReader 관련 오류를 특정하여 처리하고 사용자에게 MARS 설정을 확인하도록 안내하는 메시지를 추가했습니다.

**추가 확인:**

* **`App.config` 연결 문자열:** 다시 한번, 연결 문자열에 `MultipleActiveResultSets=True;` 가 포함되어 있는지 꼭 확인해 주세요. 이것이 "열린 연결..." 오류의 근본적인 해결책일 가능성이 높습니다.