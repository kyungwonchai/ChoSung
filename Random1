, 알겠습니다. Flask 웹 애플리케이션의 관리자 기능들을 처리하는 app/routes_admin.py 파일의 최종 전체 코드를 한국어 설명과 함께 다시 제공해 드리겠습니다.

이 파일에는 다음 관리 기능들에 대한 라우트(웹 페이지 경로 및 처리 함수)가 포함됩니다:

대상 PC 관리: 목록 조회, 추가, 수정, 삭제
허용된 사용자 IP 관리: 목록 조회, 추가, 수정, 삭제
관리자 IP 관리: 목록 조회, 추가, 수정, 삭제 (자신 IP 삭제 방지 등 안전장치 포함)
모든 관리자 기능은 @ip_auth_required('admin') 데코레이터를 사용하여 관리자 IP로 등록된 사용자만 접근할 수 있도록 제한됩니다.

최종 수정: app/routes_admin.py (전체 코드)
Python

# scontrol_flask_web/app/routes_admin.py
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app, g
from . import db  # app/__init__.py 에서 생성된 db SQLAlchemy 객체
from .models import TargetPC, AllowedUserIP, AdminIP  # SQLAlchemy 모델 클래스들
from .forms import TargetPCForm, AllowedUserIPForm, AdminIPForm  # WTForms 폼 클래스들
from .auth import ip_auth_required, get_current_user_role # IP 인증 데코레이터 및 현재 사용자 역할 함수

# 'admin' 이름으로 블루프린트 생성. url_prefix='/admin'은 app/__init__.py 에서 설정.
admin_bp = Blueprint('admin', __name__)

# --- 1. 대상 PC 관리 (Target PC Management) ---
@admin_bp.route('/pcs')
@ip_auth_required('admin') # 관리자만 접근 가능
def manage_target_pcs():
    """대상 PC 목록을 조회하고 페이지네이션하여 표시합니다."""
    page = request.args.get('page', 1, type=int)
    per_page = 10 # 페이지 당 보여줄 항목 수 (설정 파일에서 관리 가능)
    # TargetPC 모델에서 pc_name 순으로 정렬하여 페이지네이션 객체 생성
    pagination = TargetPC.query.order_by(TargetPC.pc_name).paginate(page=page, per_page=per_page, error_out=False)
    pcs_on_current_page = pagination.items # 현재 페이지의 PC 목록
    return render_template('admin/manage_target_pcs.html', 
                           pcs=pcs_on_current_page, 
                           pagination=pagination, 
                           title="대상 PC 관리")

@admin_bp.route('/pcs/add', methods=['GET', 'POST'])
@ip_auth_required('admin')
def add_target_pc():
    """새로운 대상 PC 정보를 추가합니다."""
    form = TargetPCForm()
    if form.validate_on_submit(): # POST 요청이고 폼 데이터가 유효하면
        # address2가 비어있으면 None으로 처리하여 DB에 NULL로 저장되도록 함
        addr2_value = form.address2.data if form.address2.data and form.address2.data.strip() else None
        
        new_pc = TargetPC(
            pc_name=form.pc_name.data,
            address1=form.address1.data,
            address2=addr2_value,
            description=form.description.data
        )
        try:
            db.session.add(new_pc)
            db.session.commit()
            flash(f"PC '{new_pc.pc_name}' 정보가 성공적으로 추가되었습니다.", 'success')
            return redirect(url_for('admin.manage_target_pcs')) # PC 관리 목록 페이지로 이동
        except Exception as e: # 주로 UNIQUE 제약조건 위반 (pc_name 중복 등)
            db.session.rollback() # 오류 발생 시 롤백
            error_message = f"PC 정보 추가 중 오류 발생: {e}"
            if 'UNIQUE constraint failed' in str(e) or 'UNIQUE KEY constraint' in str(e).upper():
                 error_message = f"이미 등록된 PC 이름입니다: {form.pc_name.data}"
            flash(error_message, 'error')
            current_app.logger.error(f"Error adding PC '{form.pc_name.data}': {e}")
            
    return render_template('admin/edit_target_pc.html', form=form, title="새 PC 추가")

@admin_bp.route('/pcs/edit/<int:pc_id>', methods=['GET', 'POST'])
@ip_auth_required('admin')
def edit_target_pc(pc_id):
    """기존 대상 PC 정보를 수정합니다."""
    pc_to_edit = TargetPC.query.get_or_404(pc_id) # 해당 ID의 PC가 없으면 404 오류 발생
    form = TargetPCForm(obj=pc_to_edit) # 폼에 기존 PC 데이터 채우기
    
    if form.validate_on_submit():
        pc_to_edit.pc_name = form.pc_name.data
        pc_to_edit.address1 = form.address1.data
        pc_to_edit.address2 = form.address2.data if form.address2.data and form.address2.data.strip() else None
        pc_to_edit.description = form.description.data
        try:
            db.session.commit() # 변경사항 DB에 저장
            flash(f"PC '{pc_to_edit.pc_name}' 정보가 성공적으로 수정되었습니다.", 'success')
            return redirect(url_for('admin.manage_target_pcs'))
        except Exception as e:
            db.session.rollback()
            error_message = f"PC 정보 수정 중 오류 발생: {e}"
            if 'UNIQUE constraint failed' in str(e) or 'UNIQUE KEY constraint' in str(e).upper():
                 error_message = f"수정하려는 PC 이름 '{form.pc_name.data}'가 이미 다른 항목에 등록되어 있습니다."
            flash(error_message, 'error')
            current_app.logger.error(f"Error editing PC ID {pc_id}: {e}")

    return render_template('admin/edit_target_pc.html', form=form, title=f"PC 정보 수정: {pc_to_edit.pc_name}", pc=pc_to_edit)

@admin_bp.route('/pcs/delete/<int:pc_id>', methods=['POST']) # CSRF 방지를 위해 POST 권장
@ip_auth_required('admin')
def delete_target_pc(pc_id):
    """대상 PC 정보를 삭제합니다."""
    pc_to_delete = TargetPC.query.get_or_404(pc_id)
    pc_name_deleted = pc_to_delete.pc_name # 삭제 메시지용 이름 저장
    try:
        db.session.delete(pc_to_delete)
        db.session.commit()
        flash(f"PC '{pc_name_deleted}' 정보가 성공적으로 삭제되었습니다.", 'success')
    except Exception as e:
        db.session.rollback()
        flash(f"PC 정보 삭제 중 오류 발생: {e}", 'error')
        current_app.logger.error(f"Error deleting PC ID {pc_id}: {e}")
    return redirect(url_for('admin.manage_target_pcs'))


# --- 2. 허용된 사용자 IP 관리 (Allowed User IP Management) ---
@admin_bp.route('/users')
@ip_auth_required('admin')
def manage_user_ips():
    """허용된 사용자 IP 목록을 조회하고 페이지네이션하여 표시합니다."""
    page = request.args.get('page', 1, type=int)
    per_page = 10
    pagination = AllowedUserIP.query.order_by(AllowedUserIP.ip_address).paginate(page=page, per_page=per_page, error_out=False)
    user_ips_on_current_page = pagination.items
    return render_template('admin/manage_user_ips.html', 
                           user_ips=user_ips_on_current_page, 
                           pagination=pagination, 
                           title="허용된 사용자 IP 관리")

@admin_bp.route('/users/add', methods=['GET', 'POST'])
@ip_auth_required('admin')
def add_user_ip():
    """새로운 허용 사용자 IP를 추가합니다."""
    form = AllowedUserIPForm()
    if form.validate_on_submit():
        # 현재 접속한 관리자(g.user_ip)의 AdminIP 레코드를 찾아 ID를 가져옴
        admin_record = AdminIP.query.filter_by(ip_address=g.user_ip).first()
        admin_id = admin_record.id if admin_record else None
        
        new_user_ip = AllowedUserIP(
            ip_address=form.ip_address.data,
            description=form.description.data,
            added_by_admin_id=admin_id
        )
        try:
            db.session.add(new_user_ip)
            db.session.commit()
            flash(f"사용자 IP '{new_user_ip.ip_address}'가 성공적으로 추가되었습니다.", 'success')
            return redirect(url_for('admin.manage_user_ips'))
        except Exception as e:
            db.session.rollback()
            error_message = f"사용자 IP 추가 중 오류 발생: {e}"
            if 'UNIQUE constraint failed' in str(e) or 'UNIQUE KEY constraint' in str(e).upper():
                 error_message = f"이미 등록된 IP 주소입니다: {form.ip_address.data}"
            flash(error_message, 'error')
            current_app.logger.error(f"Error adding user IP '{form.ip_address.data}': {e}")
    return render_template('admin/edit_user_ip.html', form=form, title="새 사용자 IP 추가")

@admin_bp.route('/users/edit/<int:user_ip_id>', methods=['GET', 'POST'])
@ip_auth_required('admin')
def edit_user_ip(user_ip_id):
    """기존 허용 사용자 IP 정보를 수정합니다."""
    user_ip_to_edit = AllowedUserIP.query.get_or_404(user_ip_id)
    form = AllowedUserIPForm(obj=user_ip_to_edit)
    if form.validate_on_submit():
        user_ip_to_edit.ip_address = form.ip_address.data
        user_ip_to_edit.description = form.description.data
        # added_by_admin_id는 일반적으로 수정하지 않음
        try:
            db.session.commit()
            flash(f"사용자 IP '{user_ip_to_edit.ip_address}' 정보가 성공적으로 수정되었습니다.", 'success')
            return redirect(url_for('admin.manage_user_ips'))
        except Exception as e:
            db.session.rollback()
            error_message = f"사용자 IP 수정 중 오류 발생: {e}"
            if 'UNIQUE constraint failed' in str(e) or 'UNIQUE KEY constraint' in str(e).upper():
                 error_message = f"수정하려는 IP 주소 '{form.ip_address.data}'가 이미 다른 항목에 등록되어 있습니다."
            flash(error_message, 'error')
            current_app.logger.error(f"Error editing user IP ID {user_ip_id}: {e}")
    return render_template('admin/edit_user_ip.html', form=form, title=f"사용자 IP 수정: {user_ip_to_edit.ip_address}", user_ip_obj=user_ip_to_edit)

@admin_bp.route('/users/delete/<int:user_ip_id>', methods=['POST'])
@ip_auth_required('admin')
def delete_user_ip(user_ip_id):
    """허용 사용자 IP 정보를 삭제합니다."""
    user_ip_to_delete = AllowedUserIP.query.get_or_404(user_ip_id)
    ip_address_deleted = user_ip_to_delete.ip_address
    try:
        db.session.delete(user_ip_to_delete)
        db.session.commit()
        flash(f"사용자 IP '{ip_address_deleted}' 정보가 성공적으로 삭제되었습니다.", 'success')
    except Exception as e:
        db.session.rollback()
        flash(f"사용자 IP 삭제 중 오류 발생: {e}", 'error')
        current_app.logger.error(f"Error deleting user IP ID {user_ip_id}: {e}")
    return redirect(url_for('admin.manage_user_ips'))


# --- 3. 관리자 IP 관리 (Admin IP Management) ---
@admin_bp.route('/admins')
@ip_auth_required('admin') # 이 기능은 최상위 관리자만 접근하도록 더 세분화된 권한 관리가 필요할 수 있음
def manage_admin_ips():
    """관리자 IP 목록을 조회하고 페이지네이션하여 표시합니다."""
    page = request.args.get('page', 1, type=int)
    per_page = 10
    pagination = AdminIP.query.order_by(AdminIP.ip_address).paginate(page=page, per_page=per_page, error_out=False)
    admin_ips_on_current_page = pagination.items
    return render_template('admin/manage_admin_ips.html', 
                           admin_ips=admin_ips_on_current_page, 
                           pagination=pagination, 
                           title="관리자 IP 관리")

@admin_bp.route('/admins/add', methods=['GET', 'POST'])
@ip_auth_required('admin')
def add_admin_ip():
    """새로운 관리자 IP를 추가합니다."""
    form = AdminIPForm()
    if form.validate_on_submit():
        new_admin_ip = AdminIP(
            ip_address=form.ip_address.data,
            description=form.description.data
        )
        try:
            db.session.add(new_admin_ip)
            db.session.commit()
            flash(f"관리자 IP '{new_admin_ip.ip_address}'가 성공적으로 추가되었습니다.", 'success')
            return redirect(url_for('admin.manage_admin_ips'))
        except Exception as e:
            db.session.rollback()
            error_message = f"관리자 IP 추가 중 오류 발생: {e}"
            if 'UNIQUE constraint failed' in str(e) or 'UNIQUE KEY constraint' in str(e).upper():
                 error_message = f"이미 등록된 IP 주소입니다: {form.ip_address.data}"
            flash(error_message, 'error')
            current_app.logger.error(f"Error adding admin IP '{form.ip_address.data}': {e}")
    return render_template('admin/edit_admin_ip.html', form=form, title="새 관리자 IP 추가")

@admin_bp.route('/admins/edit/<int:admin_ip_id>', methods=['GET', 'POST'])
@ip_auth_required('admin')
def edit_admin_ip(admin_ip_id):
    """기존 관리자 IP 정보를 수정합니다 (주로 설명)."""
    admin_ip_to_edit = AdminIP.query.get_or_404(admin_ip_id)
    form = AdminIPForm(obj=admin_ip_to_edit) # 폼에 기존 데이터 채우기
    
    original_ip = admin_ip_to_edit.ip_address # 수정 전 IP 저장

    if form.validate_on_submit():
        new_ip = form.ip_address.data
        # IP 주소 변경 시도 확인
        if original_ip != new_ip:
            # 현재 접속한 관리자 자신의 IP를 변경하려는 경우 방지
            if original_ip == g.user_ip:
                flash("보안상의 이유로 현재 접속 중인 자신의 관리자 IP 주소는 변경할 수 없습니다. 설명을 수정하거나, 다른 관리자 IP를 통해 시도하세요.", 'error')
                return render_template('admin/edit_admin_ip.html', form=form, title=f"관리자 IP 수정: {original_ip}", admin_ip_obj=admin_ip_to_edit)
            
            # 변경하려는 새 IP가 이미 다른 관리자 IP로 등록되어 있는지 확인
            existing_admin_with_new_ip = AdminIP.query.filter(AdminIP.ip_address == new_ip, AdminIP.id != admin_ip_id).first()
            if existing_admin_with_new_ip:
                flash(f"수정하려는 IP 주소 '{new_ip}'가 이미 다른 관리자 항목에 등록되어 있습니다.", 'error')
                return render_template('admin/edit_admin_ip.html', form=form, title=f"관리자 IP 수정: {original_ip}", admin_ip_obj=admin_ip_to_edit)
        
        admin_ip_to_edit.ip_address = new_ip
        admin_ip_to_edit.description = form.description.data
        try:
            db.session.commit()
            flash(f"관리자 IP '{admin_ip_to_edit.ip_address}' 정보가 성공적으로 수정되었습니다.", 'success')
            return redirect(url_for('admin.manage_admin_ips'))
        except Exception as e: # 주로 UNIQUE 제약조건 위반
            db.session.rollback()
            flash(f"관리자 IP 수정 중 오류 발생: {e}", 'error')
            current_app.logger.error(f"Error editing admin IP ID {admin_ip_id}: {e}")
            
    return render_template('admin/edit_admin_ip.html', form=form, title=f"관리자 IP 수정: {original_ip}", admin_ip_obj=admin_ip_to_edit)

@admin_bp.route('/admins/delete/<int:admin_ip_id>', methods=['POST'])
@ip_auth_required('admin')
def delete_admin_ip(admin_ip_id):
    """관리자 IP 정보를 삭제합니다."""
    admin_ip_to_delete = AdminIP.query.get_or_404(admin_ip_id)
    ip_address_deleted = admin_ip_to_delete.ip_address

    # 현재 접속한 관리자 자신의 IP는 삭제하지 못하도록 방지
    if admin_ip_to_delete.ip_address == g.user_ip:
        flash("현재 접속 중인 관리자 자신의 IP는 삭제할 수 없습니다.", 'error')
        return redirect(url_for('admin.manage_admin_ips'))

    # 시스템에 최소 1개의 관리자 IP는 남아 있어야 함
    if AdminIP.query.count() <= 1:
        flash("최소 1개의 관리자 IP는 시스템에 남아 있어야 합니다. 마지막 관리자 IP는 삭제할 수 없습니다.", 'error')
        return redirect(url_for('admin.manage_admin_ips'))
        
    try:
        # 이 관리자 IP에 의해 추가된 AllowedUserIP들의 added_by_admin_id를 NULL로 설정
        # (DB에서 ON DELETE SET NULL 제약조건이 설정되어 있다면 자동 처리됨. SQLAlchemy 모델에서도 설정 가능)
        # 여기서는 명시적으로 처리하지 않음. DB 스키마의 ON DELETE SET NULL에 의존.
        # 필요시: AllowedUserIP.query.filter_by(added_by_admin_id=admin_ip_id).update({'added_by_admin_id': None})

        db.session.delete(admin_ip_to_delete)
        db.session.commit()
        flash(f"관리자 IP '{ip_address_deleted}' 정보가 성공적으로 삭제되었습니다.", 'success')
    except Exception as e:
        db.session.rollback()
        flash(f"관리자 IP 삭제 중 오류 발생: {e}", 'error')
        current_app.logger.error(f"Error deleting admin IP ID {admin_ip_id}: {e}")
    return redirect(url_for('admin.manage_admin_ips'))
routes_admin.py 주요 변경 사항:

임포트: AdminIP 모델, AdminIPForm 폼, 그리고 g (Flask의 요청 컨텍스트 전역 객체)와 get_current_user_role 함수를 임포트 목록에 추가했습니다.
관리자 IP 관리 CRUD:
manage_admin_ips: 관리자 IP 목록을 페이지네이션하여 표시합니다.
add_admin_ip: 새 관리자 IP를 추가합니다.
edit_admin_ip: 기존 관리자 IP 정보를 수정합니다. 자신의 현재 접속 IP를 다른 IP로 변경하려고 할 때, 또는 변경하려는 IP가 이미 다른 관리자 IP로 존재할 때를 방지하는 로직이 추가되었습니다.
delete_admin_ip: 관리자 IP를 삭제합니다. 현재 접속 중인 자신의 IP를 삭제하거나, 시스템에 관리자 IP가 하나만 남았을 경우 삭제를 방지하는 안전장치가 포함되었습니다.
오류 메시지 상세화: 데이터베이스 제약조건 위반(예: UNIQUE) 시 사용자에게 좀 더 명확한 오류 메시지를 보여주도록 수정했습니다 (MSSQL 오류 메시지 패턴도 일부 고려).
로깅: current_app.logger를 사용하여 서버 측 로그를 남기도록 했습니다.
이것으로 app/routes_admin.py 파일에 관리자 IP 관리 기능까지 포함한 전체 코드가 되었습니다.
이전에 제공해 드린 app/templates/admin/manage_admin_ips.html 과 새로 추가/수정할 app/templates/admin/edit_admin_ip.html 템플릿을 함께 사용하시면 됩니다. (edit_admin_ip.html은 edit_user_ip.html과 내용이 거의 동일하므로, 이전 응답의 edit_user_ip.html을 복사하여 파일 이름을 바꾸고, 내부의 url_for 경로만 admin.manage_admin_ips로 수정하시면 됩니다.)

다음 단계는 사용자용 "원격 제어판" 페이지를 만들고, SAgentM.App 에이전트와 통신하는 Python 소켓 클라이언트 로직을 구현하는 것입니다.

이어서 사용자 제어판 관련 코드를 드릴까요?


init.pty 그게 에러고쳐서다시




생각하는 과정 표시
네, app/__init__.py 파일에 오류가 있다고 하시니 해당 파일을 수정하여 다시 전체 코드를 제공해 드리겠습니다. Flask에서 __init__.py 파일은 애플리케이션의 초기 설정, 블루프린트 등록, 확장 기능 초기화 등 중요한 역할을 하므로 오류 없이 구성하는 것이 중요합니다.

일반적으로 __init__.py에서 발생할 수 있는 오류는 다음과 같습니다:

순환 참조 (Circular Imports): __init__.py에서 다른 모듈(예: 라우트 파일)을 임포트하고, 그 다른 모듈에서도 __init__.py의 app 객체 등을 다시 임포트하려고 할 때 발생합니다. 블루프린트를 사용하면 이런 문제를 많이 줄일 수 있습니다.
애플리케이션 컨텍스트 문제: Flask의 current_app이나 g 객체, 또는 데이터베이스 세션(db.session)을 애플리케이션 컨텍스트 외부에서 (예: 모듈 로드 시점) 사용하려고 할 때 발생할 수 있습니다.
설정 또는 초기화 순서 문제: 확장 기능(예: SQLAlchemy)이 앱 객체에 제대로 초기화되기 전에 사용하려고 할 때 문제가 생길 수 있습니다.
구조 개선 제안:
이전 __init__.py에 직접 정의했던 main_bp (메인 페이지 / 라우트)를 별도의 파일 app/routes_main.py로 분리하여 다른 블루프린트(admin, user)와 일관된 구조를 갖도록 하겠습니다. 이렇게 하면 __init__.py는 더욱 깔끔하게 애플리케이션 생성과 초기화에만 집중할 수 있습니다.

1. 신규: app/routes_main.py (메인 페이지 라우트)
app 폴더에 routes_main.py 파일을 새로 생성하고 다음 내용을 작성합니다.

Python

# scontrol_flask_web/app/routes_main.py
from flask import Blueprint, render_template, flash, redirect, url_for, g
from .auth import ip_auth_required, get_current_user_role # g는 auth 모듈에서 설정됨

main_bp = Blueprint('main', __name__)

@main_bp.route('/')
@ip_auth_required() # 로그인된 사용자 (admin 또는 user)만 접근 가능
def index():
    # get_current_user_role() 호출 시 g.user_ip와 g.current_user_role이 설정됩니다.
    # auth.py의 inject_user_info_to_templates 컨텍스트 프로세서 덕분에
    # 템플릿에서는 이미 current_user_ip와 current_user_role 변수를 사용할 수 있습니다.
    # 여기서 flash 메시지는 사용자에게 추가 정보를 제공합니다.
    
    # 현재 역할을 한 번 더 명시적으로 가져와서 로깅이나 조건부 로직에 사용할 수 있습니다.
    current_role = get_current_user_role() 
    flash(f"환영합니다! IP: {g.user_ip}, 역할: {current_role}", "info")

    # 역할에 따른 리다이렉션 로직 (선택 사항)
    # if current_role == 'admin':
    #     # 관리자면 바로 PC 관리 페이지로 리다이렉트 할 수도 있습니다.
    #     # return redirect(url_for('admin.manage_target_pcs'))
    #     pass 
    # elif current_role == 'user':
    #     # 일반 사용자면 제어판으로 리다이렉트 할 수도 있습니다.
    #     # return redirect(url_for('user.control_panel')) # user_bp 등록 후 사용 가능
    #     pass
        
    return render_template('index.html') # 기본 index.html 템플릿 렌더링
2. 수정: app/__init__.py (애플리케이션 팩토리 및 초기화)
이제 app/__init__.py 파일을 수정하여 main_bp를 routes_main.py에서 임포트하고, 전체적인 구조를 정리합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask
from flask_sqlalchemy import SQLAlchemy
from config import config # 프로젝트 루트의 config.py 임포트
import datetime # datetime 필터용

db = SQLAlchemy() # SQLAlchemy 객체 전역 선언

def create_app(config_name='default'):
    """
    Flask 애플리케이션 인스턴스를 생성하고 초기화하는 팩토리 함수입니다.
    """
    app = Flask(__name__)
    
    # 1. 설정 로드
    app.config.from_object(config[config_name])
    config[config_name].init_app(app) # Config 클래스의 init_app 호출 (현재는 비어있음)

    # 2. 확장 기능 초기화 (예: SQLAlchemy)
    db.init_app(app)

    # 3. Jinja2 커스텀 필터 및 컨텍스트 프로세서 등록
    # datetime 필터 등록
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'): # fmt로 파라미터 이름 변경
        if not value: # None이거나 빈 문자열이면 빈 문자열 반환
            return ""
        if isinstance(value, str): # 문자열인 경우 datetime 객체로 파싱 시도
            try: 
                # ISO 형식 (+00:00 같은 UTC 오프셋 제거 시도)
                if '.' in value and ('Z' in value.upper() or '+' in value or '-' in value[10:]): # 2023-10-27T10:30:00.123Z 또는 2023-10-27T10:30:00.123+09:00
                    value_no_offset = value.split('+')[0].split('-')[0:3] # YYYY-MM-DDTHH:MM:SS.ffffff부분만
                    value_no_offset_str = "".join(value_no_offset) if isinstance(value_no_offset, list) else value_no_offset
                    if 'Z' in value.upper(): value_no_offset_str = value.upper().split('Z')[0]

                    # 소수점 처리
                    if '.' in value_no_offset_str:
                         dt_part, ms_part = value_no_offset_str.split('.')
                         value = datetime.datetime.strptime(dt_part, "%Y-%m-%dT%H:%M:%S")
                    else: # 소수점 없는 경우
                         value = datetime.datetime.strptime(value_no_offset_str, "%Y-%m-%dT%H:%M:%S")
            except ValueError:
                try: # 기본 YYYY-MM-DD HH:MM:SS 형식 시도
                    value = datetime.datetime.strptime(value, "%Y-%m-%d %H:%M:%S")
                except ValueError:
                    return value # 파싱 실패 시 원본 값 반환
        
        if not isinstance(value, (datetime.datetime, datetime.date)): # datetime 객체가 아니면 변환 불가
             return value

        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    
    @app.context_processor
    def inject_now(): # 모든 템플릿에서 'now' 변수로 현재 UTC 시간 사용 가능
        return {'now': datetime.datetime.utcnow()}

    # IP 주소 및 사용자 역할 정보를 모든 템플릿에 주입하는 컨텍스트 프로세서 등록
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)


    # 4. 블루프린트(Blueprint) 등록
    # 각 기능별 라우트 모듈을 임포트하고 애플리케이션에 등록합니다.
    
    from .routes_main import main_bp # 메인 페이지 블루프린트
    app.register_blueprint(main_bp) # URL 접두사 없이 루트에 등록

    from .routes_admin import admin_bp # 관리자 기능 블루프린트
    app.register_blueprint(admin_bp, url_prefix='/admin') # '/admin' URL 접두사로 등록
    
    from .routes_user import user_bp # 사용자 기능 블루프린트
    app.register_blueprint(user_bp, url_prefix='/user') # '/user' URL 접두사로 등록
    # 만약 '/control_panel'을 루트 레벨로 하고 싶다면, url_prefix 없이 등록하고
    # routes_user.py 내의 @user_bp.route('/')를 @user_bp.route('/control_panel')로 변경


    # 5. 애플리케이션 컨텍스트가 필요한 기타 초기화 (예: DB 테이블 생성)
    # with app.app_context():
    #     db.create_all() # 모든 SQLAlchemy 모델에 해당하는 테이블 생성 (Flask-Migrate 사용 시에는 불필요)
    # 주의: db.create_all()은 개발 중에만 사용하고, 운영 환경에서는 Flask-Migrate 같은 도구로 관리하는 것이 좋습니다.

    current_app.logger.info("Flask application created successfully.")
    return app
__init__.py 주요 변경 사항 및 설명:

main_bp 분리 및 등록: routes_main.py에서 정의한 main_bp를 임포트하여 등록했습니다. URL 접두사 없이 등록하여 / 경로를 처리합니다.
user_bp 등록: 이전 응답에서 작성한 routes_user.py의 user_bp도 임포트하여 /user 접두사로 등록했습니다. (예: /user/control_panel)
datetimeformat 필터 개선: 문자열로 된 날짜/시간 값을 파싱할 때 ISO 형식 및 다양한 경우를 좀 더 너그럽게 처리하도록 수정하고, datetime 객체가 아닐 경우 원본을 반환하도록 방어 코드를 추가했습니다. fmt로 파라미터 이름을 변경했습니다.
주석 및 로깅 추가: 코드 이해를 돕기 위한 주석과 애플리케이션 생성 성공 로그를 추가했습니다.
db.create_all() 주석 처리: 이 코드는 개발 초기에는 편리하지만, 모델이 변경될 때마다 기존 테이블을 삭제하지 않고는 스키마를 업데이트하기 어렵습니다. 실제 운영 및 지속적인 개발에는 Flask-Migrate와 같은 데이터베이스 마이그레이션 도구를 사용하는 것이 좋습니다. 지금은 주석 처리해두었습니다. (테이블은 이전에 제공된 MSSQL DDL 스크립트로 이미 생성했다고 가정합니다.)
실행 전 확인:

app 폴더 내에 routes_main.py, routes_admin.py, routes_user.py, auth.py, models.py, forms.py, socket_client.py 파일들이 올바르게 위치해 있는지 확인합니다.
templates 폴더와 그 하위 폴더(admin, user)에 필요한 HTML 파일들(layout.html, index.html, manage_target_pcs.html 등)이 있는지 확인합니다.
위와 같이 수정한 app/__init__.py와 새로 추가된 app/routes_main.py 파일을 프로젝트에 적용해 보십시오. 이렇게 하면 라우트 관리가 좀 더 체계적으로 이루어지고, __init__.py 파일은 애플리케이션 설정 및 초기화에 집중할 수 있게 됩니다.