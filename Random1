using System;
using System.Collections.Generic; // 큐 자료구조 사용을 위해 포함
using System.IO; // 파일 입출력을 위해 포함
using System.Net.Sockets; // 네트워크 소켓을 사용하기 위해 포함
using System.Text; // 문자열 인코딩을 위해 포함
using System.Threading; // 쓰레드 작업을 위해 포함
using System.Threading.Tasks; // 비동기 작업을 위해 포함

namespace RouterMiddleACRService
{
    public class LogService
    {
        // 싱글톤 인스턴스
        private static LogService _instance;

        // 로그 파일이 저장될 디렉터리 경로
        private readonly string _logDirectory;

        // TCP 클라이언트 객체 (메인 UI 서버에 연결하기 위함)
        private TcpClient _tcpClient;

        // 네트워크 스트림 객체 (TCP 클라이언트와 서버 간의 데이터 송수신을 위함)
        private NetworkStream _networkStream;

        // 메인 UI 서버의 IP 주소 (클라이언트가 연결할 대상)
        private string _serverIp = "127.0.0.1";

        // 메인 UI 서버의 포트 번호 (클라이언트가 연결할 포트)
        private int _serverPort = 9000;

        // 작업을 취소하기 위한 CancellationTokenSource (서버 연결을 중지할 때 사용)
        private CancellationTokenSource _cancellationTokenSource;

        // 서버에 현재 연결 상태를 나타내는 불리언 변수
        private bool _isConnected = false;

        // 로그 메시지를 임시로 저장할 큐 (서버에 연결되지 않았을 때 로그를 저장하기 위함)
        private Queue<string> _logQueue = new Queue<string>();

        // 싱글톤 패턴을 통해 LogService 인스턴스를 제공하는 프로퍼티
        public static LogService Instance
        {
            get
            {
                // 인스턴스가 아직 생성되지 않은 경우 생성
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance; // 생성된 인스턴스 반환
            }
        }

        // 생성자 (private로 설정하여 외부에서 인스턴스 생성 방지)
        private LogService()
        {
            // 로그 파일을 저장할 디렉터리 경로 설정 (년/월 형식으로 폴더 생성)
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory); // 디렉터리 생성
        }

        // LogService를 시작하는 메서드
        public void Start()
        {
            // CancellationTokenSource 초기화 (취소 토큰 생성)
            _cancellationTokenSource = new CancellationTokenSource();

            // 서버에 연결을 시작하는 비동기 작업을 실행
            Task.Run(() => ConnectToServer(_cancellationTokenSource.Token));
        }

        // LogService를 중지하는 메서드
        public void Stop()
        {
            // 작업 취소 요청
            _cancellationTokenSource.Cancel();

            // 네트워크 스트림 및 TCP 클라이언트 닫기
            _networkStream?.Close();
            _tcpClient?.Close();
        }

        // 서버에 연결을 시도하는 비동기 메서드
        private async Task ConnectToServer(CancellationToken cancellationToken)
        {
            // 작업이 취소되지 않는 한 계속 실행
            while (!cancellationToken.IsCancellationRequested)
            {
                // 현재 연결되어 있지 않은 경우에만 연결 시도
                if (!_isConnected)
                {
                    try
                    {
                        _tcpClient = new TcpClient(); // TCP 클라이언트 객체 생성
                        await _tcpClient.ConnectAsync(_serverIp, _serverPort); // 서버에 연결 시도
                        _networkStream = _tcpClient.GetStream(); // 네트워크 스트림 가져오기
                        _isConnected = true; // 연결 성공 시 연결 상태를 true로 설정
                        Console.WriteLine("Connected to main UI server.");

                        // 재연결 후 로그 큐에 저장된 메시지 전송
                        await SendQueuedLogs();
                    }
                    catch (Exception ex)
                    {
                        // 연결 실패 시 예외 처리
                        Console.WriteLine($"Error connecting to server: {ex.Message}");
                        _isConnected = false; // 연결 실패 시 연결 상태를 false로 설정
                        await Task.Delay(5000); // 5초 후 재연결 시도
                    }
                }
                else
                {
                    // 연결되어 있는 경우 1초마다 상태 체크
                    await Task.Delay(1000);
                }
            }
        }

        // 로그 메시지를 기록하는 메서드
        public void LogMessage(string message)
        {
            try
            {
                // 현재 시간과 메시지를 조합하여 로그 항목 생성
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";

                // 로그 파일 경로 설정
                string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");

                // 로그 파일에 로그 항목 추가
                File.AppendAllText(logFilePath, logEntry + Environment.NewLine);

                // 서버에 연결된 경우 로그 메시지를 전송
                if (_isConnected && _tcpClient != null && _tcpClient.Connected)
                {
                    SendLogMessage(logEntry); // 연결된 경우 바로 전송
                }
                else
                {
                    // 연결되지 않은 경우 로그 큐에 저장
                    _logQueue.Enqueue(logEntry);
                }
            }
            catch (Exception ex)
            {
                // 로그 기록 중 예외 발생 시 콘솔에 출력
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }

        // 로그 메시지를 서버에 전송하는 비동기 메서드
        private async Task SendLogMessage(string message)
        {
            try
            {
                if (_networkStream != null)
                {
                    // 메시지를 바이트 배열로 변환하여 전송
                    byte[] data = Encoding.UTF8.GetBytes(message);
                    await _networkStream.WriteAsync(data, 0, data.Length); // 메시지 전송
                    Console.WriteLine("Log message sent to main UI server.");
                }
            }
            catch (Exception ex)
            {
                // 전송 중 예외 발생 시 예외 처리 및 연결 끊김 상태로 설정
                Console.WriteLine($"Error sending log message: {ex.Message}");
                _isConnected = false;
            }
        }

        // 큐에 저장된 로그 메시지를 서버에 전송하는 비동기 메서드
        private async Task SendQueuedLogs()
        {
            // 큐가 비어 있지 않고 연결된 상태에서 실행
            while (_logQueue.Count > 0 && _isConnected)
            {
                var logMessage = _logQueue.Dequeue(); // 큐에서 로그 메시지 꺼내기
                await SendLogMessage(logMessage); // 큐에 저장된 로그 메시지 전송
            }
        }

        // 추가적으로 활용할 수 있는 함수들의 형태
        // 1. 서버 연결 상태 확인 함수
        public bool IsServerConnected()
        {
            // 현재 서버와의 연결 상태를 반환
            return _isConnected && _tcpClient != null && _tcpClient.Connected;
        }

        // 2. 특정 이벤트 발생 시 로그를 기록하는 함수
        public void LogEvent(string eventName)
        {
            // 이벤트 발생 시 로그 메시지 기록
            LogMessage($"Event triggered: {eventName}");
        }

        // 3. 주기적으로 서버에 연결 상태를 체크하는 함수
        public async Task MonitorConnection()
        {
            while (true)
            {
                if (!IsServerConnected())
                {
                    // 연결 상태가 끊겼을 경우 재연결 시도
                    await ConnectToServer(new CancellationToken());
                }
                await Task.Delay(10000); // 10초마다 연결 상태 확인
            }
        }

        // 4. 로그 파일을 읽어오는 함수
        public List<string> ReadLogFile()
        {
            // 로그 파일의 내용을 읽어 리스트로 반환
            string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");
            if (File.Exists(logFilePath))
            {
                return new List<string>(File.ReadAllLines(logFilePath));
            }
            return new List<string>();
        }

        // 5. 로그 큐를 비우는 함수
        public void ClearLogQueue()
        {
            // 로그 큐를 비우기
            _logQueue.Clear();
        }

        // 6. 사용자 지정 IP 및 포트로 서버에 연결하는 함수
        public void SetServerDetails(string ip, int port)
        {
            // 서버 IP와 포트 설정
            _serverIp = ip;
            _serverPort = port;
            Console.WriteLine($"Server details updated: IP = {_serverIp}, Port = {_serverPort}");
        }
    }
}
