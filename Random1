ì£¼ì†Œë²•(Open Addressing)ì—ì„œ ê°’ì„ ì°¾ëŠ” ì›ë¦¬ëŠ” ì¶©ëŒ ë°œìƒ ì‹œ ì €ì¥ëœ íƒìƒ‰ ìˆœì„œë¥¼ ê·¸ëŒ€ë¡œ ë”°ë¼ê°€ë©° ë°ì´í„°ë¥¼ ê²€ìƒ‰í•˜ëŠ” ë°©ì‹ì…ë‹ˆë‹¤. ê¸°ë³¸ì ìœ¼ë¡œ í•´ì‹œ ì¶©ëŒì´ ë°œìƒí–ˆì„ ë•Œ, ë°ì´í„°ë¥¼ ì‚½ì…í•  ë•Œì™€ ë™ì¼í•œ ê·œì¹™ìœ¼ë¡œ íƒìƒ‰í•˜ë©´ ê°’ì„ ì°¾ì„ ìˆ˜ ìˆìŠµë‹ˆë‹¤.

ğŸ”¹ ê°œë°© ì£¼ì†Œë²•ì˜ ê²€ìƒ‰ ì›ë¦¬
1ï¸âƒ£ ê¸°ë³¸ì ì¸ íƒìƒ‰ ê³¼ì •
í•´ì‹œ í•¨ìˆ˜ë¥¼ ì‚¬ìš©í•´ ê¸°ë³¸ì ì¸ **í•´ì‹œ ì¸ë±ìŠ¤(hash index)**ë¥¼ ì°¾ìŒ.
í•´ë‹¹ ì¸ë±ìŠ¤ì— ê°’ì´ ì¡´ì¬í•˜ëŠ”ì§€ í™•ì¸.
ë§Œì•½ ì°¾ëŠ” ê°’ì´ ì—†ê³ , í•´ë‹¹ ì¸ë±ìŠ¤ì— ë‹¤ë¥¸ ê°’ì´ ìˆë‹¤ë©´(ì¶©ëŒ ë°œìƒ), ì¶©ëŒ í•´ê²° ë°©ì‹(ì„ í˜• íƒìƒ‰, ì´ì°¨ íƒìƒ‰, ì´ì¤‘ í•´ì‹± ë“±)ì— ë”°ë¼ ë‹¤ìŒ ìœ„ì¹˜ë¥¼ ìˆœì°¨ì ìœ¼ë¡œ ê²€ì‚¬.
ë¹ˆ ìŠ¬ë¡¯(empty slot)ì„ ë§Œë‚˜ë©´ íƒìƒ‰ ì¢…ë£Œ(í•´ë‹¹ ê°’ì´ ì¡´ì¬í•˜ì§€ ì•ŠìŒ).
ğŸ”¹ ê°œë°© ì£¼ì†Œë²•ì˜ íƒìƒ‰ êµ¬í˜„
âœ… 1. ì„ í˜• íƒìƒ‰(Linear Probing)
ğŸ”¹ íƒìƒ‰ ë°©ë²•:

ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
=
hash
(
ğ‘˜
ğ‘’
ğ‘¦
)
index=hash(key)
ì¶©ëŒ ë°œìƒ ì‹œ 
ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
=
(
ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
+
1
)
m
o
d
â€‰
â€‰
TABLE_SIZE
index=(index+1)modTABLE_SIZE ë°©ì‹ìœ¼ë¡œ íƒìƒ‰.
ë¹ˆ ìŠ¬ë¡¯ì„ ë§Œë‚˜ë©´ ê°’ì´ ì—†ëŠ” ê²ƒìœ¼ë¡œ íŒë‹¨.
cpp
ì½”ë“œ ë³µì‚¬
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0}; // 0ì„ ë¹ˆ ìŠ¬ë¡¯ìœ¼ë¡œ ê°€ì •

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    void insert(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) { // ì¶©ëŒ ë°œìƒ ì‹œ ë‹¤ìŒ ìŠ¬ë¡¯ íƒìƒ‰
            index = (index + 1) % TABLE_SIZE;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction(key);
        while (table[index] != 0) { // ë¹ˆ ìŠ¬ë¡¯ ë§Œë‚˜ë©´ íƒìƒ‰ ì¢…ë£Œ
            if (table[index] == key) return true;
            index = (index + 1) % TABLE_SIZE;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
âœ… ì„ í˜• íƒìƒ‰ì˜ íŠ¹ì§•

ìºì‹œ íš¨ìœ¨ì´ ì¢‹ì§€ë§Œ, ì¶©ëŒì´ ë§ì•„ì§ˆ ê²½ìš° í´ëŸ¬ìŠ¤í„°ë§ ë¬¸ì œê°€ ë°œìƒ.
ì—°ì†ëœ ìŠ¬ë¡¯ì´ ì°¨ë©´ íƒìƒ‰ ì‹œê°„ì´ ê¸¸ì–´ì§ˆ ìˆ˜ ìˆìŒ.
âœ… 2. ì´ì°¨ íƒìƒ‰(Quadratic Probing)
ğŸ”¹ íƒìƒ‰ ë°©ë²•:

ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
=
hash
(
ğ‘˜
ğ‘’
ğ‘¦
)
index=hash(key)
ì¶©ëŒ ë°œìƒ ì‹œ 
ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
=
(
ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
+
ğ‘–
2
)
m
o
d
â€‰
â€‰
TABLE_SIZE
index=(index+i 
2
 )modTABLE_SIZE ë°©ì‹ìœ¼ë¡œ ì í”„í•˜ë©° íƒìƒ‰.
cpp
ì½”ë“œ ë³µì‚¬
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0};

    int hashFunction(int key) {
        return key % TABLE_SIZE;
    }

public:
    void insert(int key) {
        int index = hashFunction(key);
        int i = 1;
        while (table[index] != 0) { // ì¶©ëŒ ì‹œ ì´ì°¨ íƒìƒ‰
            index = (index + i * i) % TABLE_SIZE;
            i++;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction(key);
        int i = 1;
        while (table[index] != 0) {
            if (table[index] == key) return true;
            index = (index + i * i) % TABLE_SIZE;
            i++;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
âœ… ì´ì°¨ íƒìƒ‰ì˜ íŠ¹ì§•

ì„ í˜• íƒìƒ‰ë³´ë‹¤ ì¶©ëŒ íšŒí”¼ê°€ ë›°ì–´ë‚˜ í´ëŸ¬ìŠ¤í„°ë§ ë¬¸ì œ ê°ì†Œ.
í•˜ì§€ë§Œ, í•´ì‹œ í…Œì´ë¸”ì´ ê½‰ ì°¨ë©´ ë¬´í•œ ë£¨í”„ì— ë¹ ì§ˆ ìˆ˜ë„ ìˆìŒ.
âœ… 3. ì´ì¤‘ í•´ì‹±(Double Hashing)
ğŸ”¹ íƒìƒ‰ ë°©ë²•:

ê¸°ë³¸ í•´ì‹œ í•¨ìˆ˜ 
â„
1
(
ğ‘˜
ğ‘’
ğ‘¦
)
=
ğ‘˜
ğ‘’
ğ‘¦
m
o
d
â€‰
â€‰
ğ‘‡
ğ´
ğµ
ğ¿
ğ¸
_
ğ‘†
ğ¼
ğ‘
ğ¸
h1(key)=keymodTABLE_SIZE.
ì¶©ëŒ ë°œìƒ ì‹œ **
â„
2
(
ğ‘˜
ğ‘’
ğ‘¦
)
=
7
âˆ’
(
ğ‘˜
ğ‘’
ğ‘¦
m
o
d
â€‰
â€‰
7
)
h2(key)=7âˆ’(keymod7)**ì„ ì‚¬ìš©í•˜ì—¬ ìƒˆë¡œìš´ ì¸ë±ìŠ¤ë¥¼ ê³„ì‚°.
ìƒˆë¡œìš´ ì¸ë±ìŠ¤: 
ğ‘–
ğ‘›
ğ‘‘
ğ‘’
ğ‘¥
=
(
â„
1
(
ğ‘˜
ğ‘’
ğ‘¦
)
+
ğ‘–
Ã—
â„
2
(
ğ‘˜
ğ‘’
ğ‘¦
)
)
m
o
d
â€‰
â€‰
ğ‘‡
ğ´
ğµ
ğ¿
ğ¸
_
ğ‘†
ğ¼
ğ‘
ğ¸
index=(h1(key)+iÃ—h2(key))modTABLE_SIZE.
cpp
ì½”ë“œ ë³µì‚¬
#include <iostream>
#define TABLE_SIZE 10

class HashTable {
private:
    int table[TABLE_SIZE] = {0};

    int hashFunction1(int key) {
        return key % TABLE_SIZE;
    }

    int hashFunction2(int key) {
        return 7 - (key % 7); // ë‘ ë²ˆì§¸ í•´ì‹œ í•¨ìˆ˜
    }

public:
    void insert(int key) {
        int index = hashFunction1(key);
        int step = hashFunction2(key);
        int i = 0;
        while (table[index] != 0) { // ì¶©ëŒ ì‹œ ì´ì¤‘ í•´ì‹± ì ìš©
            index = (index + step) % TABLE_SIZE;
        }
        table[index] = key;
    }

    bool search(int key) {
        int index = hashFunction1(key);
        int step = hashFunction2(key);
        while (table[index] != 0) {
            if (table[index] == key) return true;
            index = (index + step) % TABLE_SIZE;
        }
        return false;
    }
};

int main() {
    HashTable ht;
    ht.insert(10);
    ht.insert(20);
    ht.insert(30);

    std::cout << ht.search(20) << "\n"; // 1 (true)
    std::cout << ht.search(40) << "\n"; // 0 (false)
}
âœ… ì´ì¤‘ í•´ì‹±ì˜ íŠ¹ì§•

ì¶©ëŒ ë°œìƒ ì‹œ í•´ì‹œ ê°’ì„ í¬ê²Œ ì´ë™í•˜ë¯€ë¡œ í´ëŸ¬ìŠ¤í„°ë§ ìµœì†Œí™”.
ê°€ì¥ ì¶©ëŒ ë°©ì§€ íš¨ê³¼ê°€ í¬ì§€ë§Œ, ì—°ì‚°ëŸ‰ì´ ë§ìŒ.
ğŸ”¹ ê²°ë¡ 
ë°©ë²•	ì¥ì 	ë‹¨ì 	ì ì ˆí•œ ìƒí™©
ì„ í˜• íƒìƒ‰(Linear Probing)	ê°„ë‹¨í•˜ê³  ìºì‹œ íš¨ìœ¨ ë†’ìŒ	1ì°¨ í´ëŸ¬ìŠ¤í„°ë§ ë¬¸ì œ ë°œìƒ	ì¶©ëŒì´ ì ì„ ë•Œ
ì´ì°¨ íƒìƒ‰(Quadratic Probing)	í´ëŸ¬ìŠ¤í„°ë§ ê°ì†Œ	íƒìƒ‰ ë²”ìœ„ ì œí•œ	ì ë‹¹í•œ ì¶©ëŒ í—ˆìš© ê°€ëŠ¥í•  ë•Œ
ì´ì¤‘ í•´ì‹±(Double Hashing)	ì¶©ëŒ ë°©ì§€ íš¨ê³¼ í¼	ì—°ì‚°ëŸ‰ ì¦ê°€	ì¶©ëŒì´ ë§ì„ ë•Œ
ğŸ’¡ ì¶”ì²œ:

ì¶©ëŒì´ ì ë‹¤ë©´? â†’ ì„ í˜• íƒìƒ‰
ì ë‹¹í•œ ì„±ëŠ¥ + ì¶©ëŒ ë°©ì§€ â†’ ì´ì°¨ íƒìƒ‰
ì¶©ëŒì´ ë§ë‹¤ë©´? â†’ ì´ì¤‘ í•´ì‹±