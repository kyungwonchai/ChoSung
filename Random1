네, 엑셀 VBA에서 On Error Resume Next와 같이 코드를 작성할 때 유용하게 사용되는 "꿀팁"들을 설명과 함께 알려드릴게요. 이 팁들은 코드의 안정성, 가독성, 성능, 그리고 유지보수성을 크게 향상시켜 줍니다.

On Error Resume Next는 오류 발생 시 다음 줄로 넘어가 오류를 무시하는 기능인데, 이는 강력하지만 잘못 사용하면 오히려 디버깅을 어렵게 만들 수 있습니다. 더 나은 오류 처리 방법과 함께 다양한 팁들을 살펴보겠습니다.

1. Option Explicit 사용하기 (필수!)
설명: 모듈 상단에 Option Explicit를 선언하면, VBA 코드를 실행하기 전에 사용된 모든 변수를 반드시 사전에 Dim, Public, Private 등으로 선언해야만 합니다. 선언되지 않은 변수가 사용되면 컴파일 오류를 발생시킵니다.
왜 꿀팁인가: 변수 이름 오타 등으로 발생하는 찾기 어려운 버그를 사전에 방지해 줍니다. 예를 들어 CustmerName이라고 써야 할 것을 CustomerName이라고 오타를 냈다면, Option Explicit가 없으면 VBA는 새로운 CustomerName 변수를 Variant 타입으로 생성하고 초기값(Nothing 또는 Empty)을 할당해 버립니다. 이로 인해 코드가 예상과 다르게 작동하지만 오류는 나지 않아 문제를 찾기 매우 힘들어집니다. Option Explicit를 사용하면 오타가 난 변수는 선언되지 않았으므로 오류가 즉시 발생하여 문제를 쉽게 해결할 수 있습니다.
사용법: VBA 에디터에서 도구(Tools) -> 옵션(Options) -> 편집기(Editor) 탭으로 이동하여 변수 선언 요구(Require Variable Declaration) 체크박스를 선택합니다. 이렇게 설정하면 새 모듈을 만들 때마다 자동으로 Option Explicit가 추가됩니다. 또는 각 모듈의 맨 위에 직접 Option Explicit라고 입력해도 됩니다.
VBA

' 모듈 최상단에 삽입
Option Explicit

Sub ExampleSub()
    Dim i As Integer ' 변수 선언
    Dim ws As Worksheet ' 변수 선언

    Set ws = ThisWorkbook.Sheets("Sheet1") ' 변수 사용

    For i = 1 To 10 ' 변수 사용
        ' 코드 작성
    Next i

    ' Dim j As Integer 를 빠뜨리고 j를 사용하면 Option Explicit 때문에 오류 발생
    ' j = 5
End Sub
2. With 문 사용하기
설명: 동일한 개체(Object)의 여러 속성(Property)이나 메서드(Method)를 사용할 때, 개체 이름을 반복해서 쓰는 대신 With 문 안에 묶어서 사용할 수 있습니다.
왜 꿀팁인가:
코드 가독성 향상: 어떤 개체에 대해 작업하는지 명확하게 보여줍니다.
코드 작성 시간 단축: 개체 이름을 반복해서 입력할 필요가 없습니다.
성능 향상: VBA가 개체에 접근하는 횟수를 줄여주어 특히 반복문 안에서 개체의 속성에 여러 번 접근할 때 성능이 좋아집니다.
사용법: With 개체로 시작하여 End With로 닫고, 그 안에 해당 개체의 속성이나 메서드를 사용할 때는 앞에 마침표(.)만 붙이면 됩니다.
VBA

' With 문 미사용 예시
Sub WithoutWith()
    Sheets("Sheet1").Range("A1").Value = "Hello"
    Sheets("Sheet1").Range("A1").Font.Bold = True
    Sheets("Sheet1").Range("A1").Interior.Color = vbYellow
End Sub

' With 문 사용 예시
Sub WithExample()
    With Sheets("Sheet1").Range("A1")
        .Value = "Hello"
        .Font.Bold = True
        .Interior.Color = vbYellow
    End With ' With 문 종료
End Sub
3. 개체 참조 시 명시적으로 지정하기 (Qualify Your Objects)
설명: 워크시트나 셀 등의 개체를 다룰 때, 해당 개체가 어느 통합 문서의 어느 워크시트에 속해 있는지 명시적으로 지정하는 습관을 들여야 합니다. 예를 들어 단순히 Range("A1")라고 쓰는 대신 ThisWorkbook.Sheets("Sheet1").Range("A1")처럼 쓰는 것입니다.
왜 꿀팁인가: VBA는 코드를 실행할 때 활성화된(Active) 통합 문서나 워크시트를 기본으로 가정합니다. 만약 코드를 실행하는 도중에 사용자가 다른 시트나 통합 문서를 클릭하여 활성 시트/통합 문서가 바뀌면, VBA는 예상치 못한 곳에서 작업을 수행하여 오류가 발생하거나 데이터가 손상될 수 있습니다. 명시적으로 지정하면 현재 활성화 상태와 관계없이 항상 지정된 개체에 대해 작업하게 됩니다.
사용법: Application -> Workbook -> Worksheet -> Range 와 같은 계층 구조를 따라가며 대상을 정확히 지정합니다. ThisWorkbook은 매크로 코드가 포함된 현재 통합 문서를 가리키므로 매우 유용합니다.
VBA

' 잘못된 예시 (현재 활성 시트에 따라 결과가 달라짐)
Sub UnqualifiedExample()
    Range("A1").Value = "Data" ' 어느 시트의 A1인지 불분명
End Sub

' 올바른 예시 (항상 Sheet1의 A1에 데이터를 씀)
Sub QualifiedExample()
    ' 매크로가 포함된 통합 문서의 Sheet1
    ThisWorkbook.Sheets("Sheet1").Range("A1").Value = "Data"

    ' 특정 이름의 통합 문서의 Sheet2 (통합 문서가 열려있어야 함)
    ' Workbooks("MyData.xlsx").Sheets("Sheet2").Range("B1").Value = "More Data"
End Sub
4. 오류 처리 (Error Handling) - On Error GoTo 활용
설명: On Error Resume Next는 오류를 무시하고 넘어가지만, 오류가 발생했다는 사실조차 알 수 없어 문제가 심각해질 수 있습니다. 보다 체계적인 오류 처리를 위해 On Error GoTo 라벨이름을 사용합니다. 오류 발생 시 지정된 라벨 위치로 이동하여 오류의 종류를 확인하고 적절한 조치를 취할 수 있습니다. 처리가 끝난 후에는 Resume Next나 Resume를 사용하여 오류 발생 지점 다음으로 돌아가거나, 오류가 발생했던 줄을 다시 시도하거나, Sub/Function을 종료할 수 있습니다.
왜 꿀팁인가: 코드 실행 중 예상치 못한 오류가 발생했을 때 프로그램이 비정상적으로 종료되는 것을 막고, 사용자에게 오류 정보를 제공하거나, 복구 작업을 시도하는 등 안정적인 코드 실행을 가능하게 합니다. On Error Resume Next는 단순 무시이기 때문에 사용에 주의가 필요합니다. On Error GoTo 방식은 오류 발생 시 제어 흐름을 한 곳으로 모아주어 오류 처리를 중앙 집중식으로 관리할 수 있습니다.
사용법:
On Error GoTo [라벨이름] 을 코드 시작 부분에 선언합니다.
코드 끝 부분에 Exit Sub 또는 Exit Function으로 정상 종료 루틴을 만듭니다. (오류 처리 라벨로 넘어가지 않도록).
[라벨이름]: 으로 시작하는 오류 처리 루틴을 만듭니다.
오류 처리 루틴 안에서 Err.Number와 Err.Description 속성을 사용하여 오류 정보를 얻습니다.
오류 처리가 끝난 후 Resume Next, Resume, 또는 Resume [줄번호]를 사용하거나 End Sub / End Function으로 프로시저를 종료합니다. 오류 처리가 끝났음을 VBA에 알리기 위해 On Error GoTo 0을 사용하여 오류 처리를 비활성화하는 것이 일반적입니다.
VBA

Sub ErrorHandlingExample()
    ' 오류 발생 시 'ErrorHandler:' 라벨로 이동
    On Error GoTo ErrorHandler

    Dim ws As Worksheet
    ' 존재하지 않는 시트에 접근하여 오류 발생 유도
    Set ws = ThisWorkbook.Sheets("NonExistentSheet")

    ' 이 부분은 오류 발생 시 실행되지 않음
    MsgBox "이 메시지는 보이지 않습니다."

' 정상 종료 지점 (오류가 발생하지 않았을 때 이리로 와서 종료)
Exit Sub

' 오류 처리 루틴 시작
ErrorHandler:
    ' 오류 정보를 메시지 박스로 보여줌
    MsgBox "오류 발생!" & vbCrLf & _
           "오류 번호: " & Err.Number & vbCrLf & _
           "오류 설명: " & Err.Description & vbCrLf & _
           "오류 발생 시점 다음 줄부터 계속합니다.", vbCritical

    ' 오류 처리를 비활성화 (중요!)
    On Error GoTo 0

    ' 오류 발생 시점의 다음 줄부터 코드를 재개
    ' Resume Next

    ' (옵션) 오류 발생 지점으로 돌아가 다시 시도 (보통 복구 작업을 수행한 후 사용)
    ' Resume

    ' (옵션) 오류 발생 시 이 Sub/Function을 즉시 종료
    ' End Sub ' 또는 Exit Sub

End Sub
팁: On Error Resume Next는 아주 간단한 오류(예: 특정 파일이 없을 때 무시하고 넘어가야 하는 경우)에만 제한적으로 사용하고, 대부분의 경우에는 On Error GoTo 방식으로 체계적인 오류 처리를 구현하는 것이 좋습니다.
5. 성능 향상 팁 (Performance Optimization)
대량의 데이터를 처리하거나 복잡한 작업을 수행할 때 VBA 코드 속도가 매우 느려질 수 있습니다. 다음 팁들을 사용하면 성능을 극적으로 향상시킬 수 있습니다.

화면 업데이트 끄기: VBA가 코드를 실행할 때마다 화면에 변경 사항을 반영하면 속도가 느려집니다. 화면 업데이트를 끄면 VBA는 백그라운드에서 작업을 처리하고 코드가 끝날 때 한 번만 화면을 업데이트합니다.

VBA

Application.ScreenUpdating = False
' 작업 코드
Application.ScreenUpdating = True ' 작업 완료 후 다시 켜기 (필수!)
계산 모드 수동으로 변경: Excel의 자동 계산 기능은 셀 값이 바뀔 때마다 수식을 다시 계산하여 VBA 코드 속도를 저하시킬 수 있습니다. 계산 모드를 수동으로 변경하고 코드 끝에서 필요할 때만 계산하도록 합니다.

VBA

Application.Calculation = xlCalculationManual
' 작업 코드
Application.Calculation = xlCalculationAutomatic ' 작업 완료 후 다시 자동 계산으로 변경 (필수!)
' 필요하다면 특정 시점에서 수동 계산
' Application.Calculate
' Sheets("Sheet1").Calculate
이벤트 일시 중지: 워크시트나 통합 문서 이벤트(예: Worksheet_Change, Workbook_Open 등)가 활성화되어 있으면 VBA 코드 실행 중에 원치 않는 이벤트가 발생하여 코드가 복잡해지거나 느려질 수 있습니다.

VBA

Application.EnableEvents = False
' 작업 코드
Application.EnableEvents = True ' 작업 완료 후 다시 켜기 (필수!)
셀 단위 작업 피하고 범위 단위 또는 배열 사용: 가장 중요한 성능 팁 중 하나입니다. VBA에서 각 셀에 접근하는 것은 매우 느립니다. 대량의 데이터를 읽거나 쓸 때는 범위를 통째로 읽어와 배열에 저장한 후 배열에서 작업을 수행하고, 작업이 완료되면 배열의 내용을 다시 범위에 한 번에 쓰는 것이 훨씬 빠릅니다.

VBA

Sub ArrayPerformanceExample()
    Dim dataRange As Range
    Dim dataArray As Variant
    Dim i As Long, j As Long
    Dim startTime As Double

    ' 10000 x 10 범위에 데이터 채우기 예시
    Set dataRange = Sheets("Sheet1").Range("A1:J10000")
    dataRange.Value = WorksheetFunction.RandBetween(1, 100)

    startTime = Timer()

    ' **느린 방법: 셀 단위로 읽고 쓰기**
    ' For i = 1 To dataRange.Rows.Count
    '     For j = 1 To dataRange.Columns.Count
    '         dataRange.Cells(i, j).Value = dataRange.Cells(i, j).Value * 2
    '     Next j
    ' Next i
    ' MsgBox "셀 단위 처리 시간: " & Timer() - startTime & " 초"


    startTime = Timer()
    ' **빠른 방법: 배열 사용**

    ' 범위를 배열로 읽어오기
    dataArray = dataRange.Value

    ' 배열 안에서 작업 수행 (메모리 안에서 이루어지므로 빠름)
    For i = LBound(dataArray, 1) To UBound(dataArray, 1)
        For j = LBound(dataArray, 2) To UBound(dataArray, 2)
            dataArray(i, j) = dataArray(i, j) * 2
        Next j
    Next i

    ' 작업이 완료된 배열을 다시 범위에 한 번에 쓰기
    dataRange.Value = dataArray

    MsgBox "배열 처리 시간: " & Timer() - startTime & " 초"

End Sub
6. Debug.Print 활용하기
설명: 코드를 실행하는 도중에 변수 값이나 코드의 진행 상황을 확인하고 싶을 때 사용합니다. VBE(VBA Editor)의 직접 실행 창(Immediate Window, Ctrl + G 또는 보기(View) -> 직접 실행 창(Immediate Window))에 지정한 내용을 출력합니다.
왜 꿀팁인가: 코드를 일시 중지하고 변수 값을 확인하는 것(Breakpoints)보다 훨씬 비침입적이고, 코드 실행 흐름을 추적하거나 특정 지점의 상태를 기록하는 데 유용합니다. 특히 반복문 안에서 각 단계별 변수 값을 확인하거나, 특정 조건이 충족되었는지 확인할 때 효과적입니다.
사용법: 코드 중간에 Debug.Print 변수이름 또는 Debug.Print "메시지" & 변수이름 형식으로 삽입합니다. 코드를 실행하면 직접 실행 창에 결과가 출력됩니다.
VBA

Sub DebugPrintExample()
    Dim i As Integer
    Dim total As Integer
    total = 0

    For i = 1 To 5
        total = total + i
        ' 각 단계별 i와 total 값 출력
        Debug.Print "i = " & i & ", Total = " & total
    Next i

    ' 최종 결과 출력
    Debug.Print "최종 합계: " & total
End Sub
7. 의미 있는 변수 및 프로시저 이름 사용 & 들여쓰기
설명: 변수, 서브(Sub), 함수(Function) 등의 이름을 정할 때 그 역할이나 목적을 명확하게 나타내는 이름을 사용하고, 코드 블록(If ~ End If, For ~ Next, With ~ End With 등) 안의 코드는 들여쓰기를 합니다.
왜 꿀팁인가: 코드의 가독성을 극적으로 향상시켜 코드를 이해하고 수정하기 쉽게 만듭니다. 특히 다른 사람이 작성한 코드나, 시간이 지난 후 자신이 다시 보게 되는 코드의 경우, 잘 작성된 이름과 들여쓰기는 코드 분석 시간을 크게 단축시켜 줍니다. 유지보수성 측면에서 매우 중요합니다.
사용법:
변수 이름: rngData, wsSource, lRowLast, strFileName 등 데이터 타입이나 역할을 알 수 있도록 접두사(헝가리언 표기법의 일종)를 사용하거나 설명적인 이름을 사용합니다.
프로시저 이름: Sub ProcessSalesData(), Function GetLastRow(ws As Worksheet) 등 기능이나 반환 값을 명확히 알 수 있도록 합니다.
들여쓰기: Tab 키나 스페이스 바를 사용하여 코드 블록마다 일정하게 들여씁니다. VBE의 편집(Edit) 메뉴에서 전체 모듈 들여쓰기/내어쓰기 기능(Tab/Shift+Tab)을 사용할 수 있습니다.
VBA

' 나쁜 예시
Sub Process()
    Dim a As Range
    Dim b As Worksheet
    Dim c As Long
    Set b = ActiveSheet
    c = b.Cells(Rows.Count, 1).End(xlUp).Row
    Set a = b.Range("A1:A" & c)
    ' ... 코드 ...
End Sub

' 좋은 예시
Sub ProcessSalesData()
    Dim wsSource As Worksheet ' 원본 데이터 워크시트
    Dim lRowLast As Long ' 마지막 행 번호
    Dim rngSalesData As Range ' 판매 데이터 범위

    ' 매크로가 포함된 통합 문서의 "Sales" 시트 지정
    Set wsSource = ThisWorkbook.Sheets("Sales")

    ' "Sales" 시트의 A열 마지막 행 찾기
    lRowLast = wsSource.Cells(Rows.Count, "A").End(xlUp).Row

    ' A1부터 마지막 행까지의 데이터 범위 지정
    Set rngSalesData = wsSource.Range("A1:A" & lRowLast)

    ' ... rngSalesData를 사용하는 코드 ...

End Sub
8. 주석 달기 (Commenting)
설명: 코드 중간중간에 ; 기호를 사용하여 코드의 특정 부분이 무엇을 하는지, 왜 그렇게 작성되었는지 등을 설명하는 글(주석)을 삽입합니다.
왜 꿀팁인가: 코드 자체만으로는 이해하기 어려운 복잡한 로직, 비표준적인 처리 방식, 또는 코드 작성자의 의도 등을 기록하여 다른 사람이 코드를 이해하고 수정할 때 큰 도움을 줍니다. 미래의 자신에게 남기는 메모라고 생각하세요!
사용법: 설명하려는 코드 줄 앞에 ; 를 붙이거나, 코드 줄 끝에 ;를 붙여 주석을 답니다. 주석은 VBA가 실행할 때 무시됩니다.
VBA

Sub CommentExample()
    ' 이 서브 프로시저는 Sheet1의 A1 셀에 현재 날짜를 입력합니다.

    Dim wsTarget As Worksheet ' 대상 워크시트 변수 선언

    ' 매크로가 포함된 통합 문서의 "Sheet1"을 대상으로 설정
    Set wsTarget = ThisWorkbook.Sheets("Sheet1")

    ' 대상 시트의 A1 셀에 현재 시스템 날짜 입력
    wsTarget.Range("A1").Value = Date ; 현재 날짜를 Value 속성에 할당

    ' 작업 완료 메시지 박스 표시
    MsgBox "Sheet1의 A1 셀에 날짜가 입력되었습니다.", vbInformation

End Sub
9. 상수(Const) 사용하기
설명: 코드 내에서 변하지 않는 특정 값(예: 특정 시트 이름, 파일 경로, 고정 비율 등)을 사용할 때, 리터럴 값(예: "Sheet1", 3.14)을 직접 사용하는 대신 Const 키워드를 사용하여 상수로 선언하고 사용합니다.
왜 꿀팁인가:
가독성 향상: 숫자나 문자열만 보고는 그 의미를 알기 어렵지만, 상수 이름을 보면 그 값이 무엇을 의미하는지 쉽게 알 수 있습니다.
유지보수성 향상: 만약 상수 값이 변경되어야 한다면(Sheet1이 DataSheet로 바뀌는 경우), 코드를 일일이 찾아 수정하는 대신 상수 선언 부분 한 곳만 수정하면 됩니다. 이는 휴먼 에러를 줄이고 수정 시간을 단축합니다.
오타 방지: 상수 이름을 사용하면 오타가 발생했을 때 Option Explicit에 의해 즉시 오류를 발견할 수 있습니다 (리터럴 값은 오타가 나도 오류가 나지 않을 수 있습니다).
사용법: Const 상수이름 As 데이터타입 = 값 형식으로 선언합니다. 상수 이름은 일반적으로 모두 대문자로 작성하여 변수와 구분하는 관례가 있습니다.
VBA

Sub ConstantExample()
    ' 상수 선언
    Const SHEET_NAME_DATA As String = "데이터시트"
    Const DISCOUNT_RATE As Double = 0.1 ' 10% 할인율
    Const MAX_COUNT As Long = 1000

    Dim wsData As Worksheet

    ' 상수를 사용하여 시트 접근
    On Error Resume Next ' 시트가 없을 경우를 대비 (오류 처리 예시를 위함)
    Set wsData = ThisWorkbook.Sheets(SHEET_NAME_DATA)
    On Error GoTo 0 ' 오류 처리 다시 끄기 (또는 GoTo ErrorHandler 사용)

    If wsData Is Nothing Then
        MsgBox SHEET_NAME_DATA & " 시트를 찾을 수 없습니다.", vbCritical
        Exit Sub
    End If

    ' 상수를 사용하여 계산
    Dim originalPrice As Double
    Dim discountedPrice As Double

    originalPrice = wsData.Range("A1").Value ' 예시: A1 셀에 원본 가격이 있다고 가정
    discountedPrice = originalPrice * (1 - DISCOUNT_RATE)

    ' 결과 출력
    MsgBox "할인된 가격: " & discountedPrice

    ' 상수를 조건문에 사용
    Dim itemCount As Long
    itemCount = wsData.Cells(Rows.Count, "B").End(xlUp).Row ' 예시: B열 행 수
    If itemCount > MAX_COUNT Then
        MsgBox "아이템 수가 최대 허용치(" & MAX_COUNT & ")를 초과했습니다.", vbExclamation
    End If

End Sub
이 외에도 사용자 정의 함수(UDF)를 활용하여 반복되는 계산 로직을 분리하거나, 클래스 모듈을 사용하여 객체 지향적으로 코드를 작성하는 등 다양한 고급 팁들이 있지만, 위에 설명된 팁들은 VBA 코드를 작성할 때 기본적인 습관처럼 적용하면 코드의 품질을 눈에 띄게 향상시킬 수 있는 핵심적인 "꿀팁"들입니다.