네, ComPortManager를 메인 UI뿐만 아니라 다른 클래스에서도 사용할 계획이라면, 인스턴스 개념을 사용하여 공유하는 것이 좋습니다. 여기서는 여러 클래스에서 동일한 COM 포트를 사용하기 위해 ComPortManager의 인스턴스를 관리하는 몇 가지 방법을 소개하겠습니다.

1. 싱글톤 패턴 (Singleton Pattern) 사용
싱글톤 패턴은 클래스의 인스턴스를 전역에서 하나만 유지하도록 보장하는 패턴입니다. 이렇게 하면 애플리케이션 전체에서 동일한 ComPortManager 인스턴스를 공유할 수 있습니다.

싱글톤 패턴을 적용한 ComPortManager
csharp
코드 복사
using System.IO.Ports;

public class ComPortManager
{
    private static ComPortManager _instance;
    private static readonly object _lock = new object();
    private SerialPort _serialPort;

    // 생성자를 private으로 설정하여 외부에서 인스턴스 생성을 막음
    private ComPortManager(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate);
        _serialPort.Open();
    }

    // 싱글톤 인스턴스 생성 메서드
    public static ComPortManager GetInstance(string portName, int baudRate)
    {
        if (_instance == null)
        {
            lock (_lock) // 쓰레드 안전하게 처리
            {
                if (_instance == null)
                {
                    _instance = new ComPortManager(portName, baudRate);
                }
            }
        }
        return _instance;
    }

    // 데이터를 전송하는 메서드
    public void SendData(string data)
    {
        if (_serialPort != null && _serialPort.IsOpen)
        {
            _serialPort.WriteLine(data);
        }
    }

    // 포트를 닫는 메서드
    public void ClosePort()
    {
        if (_serialPort != null && _serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }
}
MainWindow에서의 사용
ComPortManager 싱글톤 인스턴스를 메인 UI와 다른 클래스에서도 사용할 수 있습니다. 이때는 동일한 인스턴스가 계속 사용되기 때문에 포트도 한 번만 열리고 여러 곳에서 공유됩니다.

csharp
코드 복사
public partial class MainWindow : Window
{
    private ComPortManager _comPortManager;

    public MainWindow()
    {
        InitializeComponent();
        
        // COM 포트 생성 (싱글톤 인스턴스)
        _comPortManager = ComPortManager.GetInstance("COM3", 9600);
        _comPortManager.SendData("Hello from MainWindow!");
    }

    protected override void OnClosed(EventArgs e)
    {
        _comPortManager.ClosePort();
        base.OnClosed(e);
    }
}
다른 클래스에서의 사용
다른 클래스에서도 동일한 ComPortManager 인스턴스를 사용하여 데이터를 전송할 수 있습니다.

csharp
코드 복사
public class OtherClass
{
    private ComPortManager _comPortManager;

    public OtherClass()
    {
        // 동일한 싱글톤 인스턴스를 가져옴
        _comPortManager = ComPortManager.GetInstance("COM3", 9600);
    }

    public void SendDataFromOtherClass(string data)
    {
        _comPortManager.SendData(data);
    }
}
2. 의존성 주입 (Dependency Injection, DI) 사용
싱글톤 대신, **의존성 주입(Dependency Injection)**을 사용할 수 있습니다. DI를 사용하면, 각 클래스에 필요한 인스턴스를 전달하여 관리합니다. 이를 통해 코드의 테스트 가능성과 유지보수성을 높일 수 있습니다.

ComPortManager 클래스
별도의 수정은 필요 없습니다.

DI 설정 (App.xaml.cs)
Microsoft.Extensions.DependencyInjection을 사용하여 DI 컨테이너를 설정할 수 있습니다.

csharp
코드 복사
public partial class App : Application
{
    public IServiceProvider ServiceProvider { get; private set; }

    protected override void OnStartup(StartupEventArgs e)
    {
        var services = new ServiceCollection();
        ConfigureServices(services);
        ServiceProvider = services.BuildServiceProvider();

        var mainWindow = ServiceProvider.GetRequiredService<MainWindow>();
        mainWindow.Show();
    }

    private void ConfigureServices(ServiceCollection services)
    {
        // ComPortManager를 싱글톤으로 등록
        services.AddSingleton<ComPortManager>(sp => new ComPortManager("COM3", 9600));

        // MainWindow 및 다른 클래스 등록
        services.AddTransient<MainWindow>();
        services.AddTransient<OtherClass>();
    }
}
MainWindow에서 DI로 ComPortManager 사용
csharp
코드 복사
public partial class MainWindow : Window
{
    private readonly ComPortManager _comPortManager;

    public MainWindow(ComPortManager comPortManager)
    {
        InitializeComponent();
        _comPortManager = comPortManager;
        _comPortManager.SendData("Hello from MainWindow!");
    }

    protected override void OnClosed(EventArgs e)
    {
        _comPortManager.ClosePort();
        base.OnClosed(e);
    }
}
다른 클래스에서 DI로 사용
csharp
코드 복사
public class OtherClass
{
    private readonly ComPortManager _comPortManager;

    public OtherClass(ComPortManager comPortManager)
    {
        _comPortManager = comPortManager;
    }

    public void SendDataFromOtherClass(string data)
    {
        _comPortManager.SendData(data);
    }
}
결론
싱글톤 패턴을 사용하면 애플리케이션 전역에서 하나의 ComPortManager 인스턴스를 공유할 수 있습니다. 각 클래스는 GetInstance를 호출하여 동일한 인스턴스를 사용하게 됩니다.

**의존성 주입(DI)**은 더 유연한 설계를 가능하게 하며, 특히 테스트 가능성과 유지보수성을 고려할 때 유리합니다. DI를 사용하면 동일한 인스턴스를 여러 클래스에서 주입받아 사용할 수 있습니다.

두 방법 모두 ComPortManager 인스턴스를 공유할 수 있게 해주며, 사용 