신규 SQL 내용: action_logs 테이블 DDL (MSSQL Server 2014)
이전에 제공한 mssql_db_schema.sql 파일에 추가하거나, 별도의 파일로 만들어 실행할 수 있습니다. SControlFlaskDB (또는 사용하시는 데이터베이스)에서 실행해주세요.

SQL

-- USE SControlFlaskDB; -- 해당 데이터베이스 선택
-- GO

PRINT '--- action_logs 테이블 생성 시작 ---';

IF OBJECT_ID('dbo.action_logs', 'U') IS NOT NULL
    DROP TABLE dbo.action_logs;
GO
CREATE TABLE dbo.action_logs (
    id INT IDENTITY(1,1) PRIMARY KEY,           -- 로그 ID (자동 증가)
    log_timestamp DATETIME DEFAULT GETDATE(),   -- 로그 기록 시간
    
    target_pc_id INT NULL,                      -- 제어 대상 PC의 ID (target_pcs 테이블 참조)
                                                -- PC가 삭제될 경우를 대비해 NULL 허용 또는 pc_name 등을 직접 저장
    target_pc_name NVARCHAR(100) NULL,         -- 제어 대상 PC 이름 (기록 시점의 이름)
    target_ip_sent_to VARCHAR(50) NOT NULL,     -- 실제 명령이 전송된 IP 주소 (릴레이인 경우 릴레이 서버 IP)
    final_target_ip VARCHAR(50) NULL,           -- 릴레이 시 최종 목적지 IP
    
    command_name VARCHAR(50) NOT NULL,          -- 실행된 명령 이름 (예: SET_DISPLAY_TIMEOUT, MONITOR_CONTROL)
    command_payload_summary NVARCHAR(255) NULL, -- 실행된 명령의 주요 내용 요약 (예: "Timeout: 1 min", "Action: On")
    
    action_type NVARCHAR(50) NOT NULL,          -- 사용자 친화적 작업 유형 (예: "디스플레이 1분 후 끄기 설정", "모니터 즉시 켜기")
    
    result_success BIT NOT NULL,                -- 명령 실행 결과 (성공/실패)
    result_message NVARCHAR(MAX) NULL,          -- 에이전트 응답 메시지 또는 오류 메시지
    
    triggered_by_ip VARCHAR(50) NULL,           -- 이 명령을 실행한 사용자의 IP 주소 (웹 UI 접속자)
                                                -- 스케줄러에 의한 실행 시 'SYSTEM' 또는 'SCHEDULER' 등으로 기록

    CONSTRAINT FK_action_logs_target_pcs FOREIGN KEY (target_pc_id) 
        REFERENCES dbo.target_pcs (id) 
        ON DELETE SET NULL -- 대상 PC 정보가 삭제되어도 로그는 남도록 설정
);
GO
PRINT 'Table action_logs created.';
GO

PRINT '--- action_logs 테이블 생성 완료 ---';
GO
action_logs 테이블 설명:

log_timestamp: 명령이 기록된 시간입니다.
target_pc_id, target_pc_name, target_ip_sent_to, final_target_ip: 어떤 PC에 명령이 내려졌는지에 대한 정보입니다. target_pc_id는 target_pcs 테이블을 참조하며, PC 정보가 삭제되더라도 로그는 남도록 ON DELETE SET NULL로 설정했습니다. target_pc_name과 target_ip_sent_to는 기록 시점의 정보를 저장합니다.
command_name, command_payload_summary: 실제 실행된 내부 명령과 그 요약입니다.
action_type: 사용자에게 보여줄 친숙한 작업 이름입니다 (예: "디스플레이 1분 후 끄기 설정").
result_success, result_message: 명령의 성공 여부와 에이전트로부터 받은 상세 메시지입니다.
triggered_by_ip: 웹 UI를 통해 명령을 실행한 사용자의 IP 주소입니다. 스케줄러가 실행한 경우 'SCHEDULER' 등으로 기록합니다.
2. 수정: scontrol_flask_web/app/routes_user.py (명령 실행 시 로그 기록 추가)
send_batch_command 함수 내에서 SAgentM.App 에이전트로 명령을 보내고 응답을 받은 후, 그 결과를 action_logs 테이블에 기록하는 로직을 추가합니다. 이를 위해 새로운 헬퍼 함수 _log_control_action를 만들겠습니다.

Python

# scontrol_flask_web/app/routes_user.py
from flask import Blueprint, render_template, request, redirect, url_for, flash, current_app, g
from app.db_utils import get_db_connection
from app.auth import ip_auth_required, get_current_user_role # get_current_user_role 추가
from app.socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone # dt로 별칭 사용
import math
import pymssql # 명시적으로 임포트 (예외 처리 등에 사용될 수 있음)

user_bp = Blueprint('user', __name__)

# --- 신규: 제어 이력 로깅을 위한 헬퍼 함수 ---
def _log_control_action(pc_data, command_name, payload_summary, action_type, agent_response, triggered_by_ip):
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            sql = """
                INSERT INTO dbo.action_logs 
                (target_pc_id, target_pc_name, target_ip_sent_to, final_target_ip, 
                 command_name, command_payload_summary, action_type, 
                 result_success, result_message, triggered_by_ip)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            
            is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
            ip_sent_to = pc_data.get('address1')
            final_ip = pc_data.get('address2') if is_relay else None

            # 에이전트 응답에서 성공 여부 및 메시지 추출
            op_success = False
            op_message = agent_response.get('message', 'No agent response message.')
            raw_agent_resp_packet = agent_response.get('raw_response')

            if agent_response.get('success') and raw_agent_resp_packet and \
               isinstance(raw_agent_resp_packet, dict) and 'PayloadJson' in raw_agent_resp_packet:
                payload_json_str = raw_agent_resp_packet.get('PayloadJson')
                if payload_json_str:
                    try:
                        resp_payload_dict = json.loads(payload_json_str)
                        op_success = resp_payload_dict.get('Success', False)
                        op_message = resp_payload_dict.get('Message', op_message)
                    except json.JSONDecodeError:
                        op_message = "Failed to parse agent response payload JSON."
                        current_app.logger.error(f"LogAction: JSONDecodeError for PayloadJson: {payload_json_str}")
                else: # PayloadJson is None or empty
                    op_message = "Agent response payload was empty."


            params = (
                pc_data.get('id'), 
                pc_data.get('pc_name'),
                ip_sent_to,
                final_ip,
                command_name,
                payload_summary,
                action_type,
                op_success,
                str(op_message)[:2000], # 메시지 길이 제한 (DB 컬럼 크기에 맞게)
                triggered_by_ip
            )
            cursor.execute(sql, params)
        conn.commit()
        current_app.logger.info(f"Action logged: {action_type} for PC {pc_data.get('pc_name')} by {triggered_by_ip}. Result Success: {op_success}")
    except Exception as e:
        if conn: conn.rollback()
        current_app.logger.error(f"Failed to log control action for PC {pc_data.get('pc_name')}: {e}", exc_info=True)


# control_panel 라우트는 이전과 동일
@user_bp.route('/control_panel')
@ip_auth_required('user')
def control_panel():
    # ... (이전 control_panel 코드 전체 - 변경 없음, #51 답변 참고) ...
    page = request.args.get('page', 1, type=int); per_page = 20; search_term = request.args.get('search', '').strip() 
    offset = (page - 1) * per_page; pcs_on_current_page = []; total_pcs = 0; conn = None
    pagination_data = {'page': page, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 'items': [], 'has_prev': False, 'has_next': False, 'prev_num': 1, 'next_num': 1, 'search_term': search_term }
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            count_query_base = "SELECT COUNT(*) AS total FROM dbo.target_pcs"; data_query_base = "SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs"
            where_clauses = []; query_params = []
            if search_term: like_search_term = f"%{search_term}%"; where_clauses.append("(LOWER(pc_name) LIKE LOWER(%s) OR LOWER(ISNULL(address1,'')) LIKE LOWER(%s) OR LOWER(ISNULL(address2,'')) LIKE LOWER(%s) OR LOWER(ISNULL(description,'')) LIKE LOWER(%s))"); query_params.extend([like_search_term] * 4)
            sql_where = ""; 
            if where_clauses: sql_where = " WHERE " + " AND ".join(where_clauses)
            final_count_query = count_query_base + sql_where; cursor.execute(final_count_query, tuple(query_params)); total_pcs_result = cursor.fetchone()
            if total_pcs_result: total_pcs = total_pcs_result.get('total', 0)
            if total_pcs > 0: final_data_query = f"{data_query_base} {sql_where} ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY "; data_query_params_for_page = query_params + [offset, per_page]; cursor.execute(final_data_query, tuple(data_query_params_for_page)); pcs_on_current_page = cursor.fetchall()
            total_pages = math.ceil(total_pcs / per_page) if total_pcs > 0 else 1
            pagination_data.update({'total_items': total_pcs, 'total_pages': total_pages, 'items': pcs_on_current_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1 if page > 1 else 1, 'next_num': page + 1 if page < total_pages else total_pages})
    except Exception as e: current_app.logger.error(f"제어판 PC 목록 조회 오류 (검색어: '{search_term}'): {e}", exc_info=True); flash("PC 목록을 불러오는 중 오류가 발생했습니다.", "error")
    title = "원격 제어판"; 
    if search_term: title += f" (검색: '{search_term}')"
    if g.current_user_role == 'admin': title = "원격 제어판 (관리자)" + (f" (검색: '{search_term}')" if search_term else "")
    return render_template('user/control_panel.html', pcs=pcs_on_current_page, pagination=pagination_data, title=title)


@user_bp.route('/send_batch_command', methods=['POST'])
@ip_auth_required('user')
def send_batch_command():
    selected_pc_ids_str = request.form.getlist('selected_pcs')
    command_action_str = request.form.get('command_action') # "켜기" 또는 "끄기"
    current_search_term_hidden = request.form.get('current_search_term', '')
    redirect_params = {'search': current_search_term_hidden} if current_search_term_hidden else {}

    if not selected_pc_ids_str: flash("PC를 선택하세요.", 'warning'); return redirect(url_for('user.control_panel', **redirect_params))
    if not command_action_str or command_action_str not in ["켜기", "끄기"]: flash("명령(켜기/끄기) 지정 오류.", 'warning'); return redirect(url_for('user.control_panel', **redirect_params))

    selected_pc_ids = [int(id_str) for id_str in selected_pc_ids_str]
    conn = None; target_pcs_to_control = []
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            if selected_pc_ids:
                placeholders = ', '.join(['%s'] * len(selected_pc_ids))
                sql_select_pcs = f"SELECT id, pc_name, address1, address2 FROM dbo.target_pcs WHERE id IN ({placeholders})"
                cursor.execute(sql_select_pcs, tuple(selected_pc_ids))
                target_pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"명령 대상 PC 정보 조회 오류: {e}", exc_info=True)
        flash("명령 대상 PC 정보 DB 조회 오류.", "error"); return redirect(url_for('user.control_panel', **redirect_params))
    if not target_pcs_to_control:
        flash("선택된 PC 정보 없음.", "warning"); return redirect(url_for('user.control_panel', **redirect_params))

    timeout_minutes_for_command = 0 if command_action_str == "켜기" else 1
    action_type_log_main = "디스플레이 항상 켜기 설정" if command_action_str == "켜기" else "디스플레이 1분 후 자동 꺼짐 설정"
    payload_summary_main = f"Timeout: {timeout_minutes_for_command} min"
    payload_for_agent_timeout = {'TimeoutMinutes': timeout_minutes_for_command}

    triggered_by = g.user_ip # auth.py에서 설정된 g.user_ip 사용

    for pc_data in target_pcs_to_control:
        packet_set_timeout = {
            'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': "SET_DISPLAY_TIMEOUT", 'PayloadJson': json.dumps(payload_for_agent_timeout),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_send = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            packet_set_timeout.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026})
            target_ip_for_send = pc_data['address1']
        else:
            packet_set_timeout.update({'Instruction': "DirectExecute"})
            target_ip_for_send = pc_data['address1']
        
        log_prefix_flash = f"PC '{pc_data.get('pc_name','N/A')}' ({target_ip_for_send})"
        flash(f"{log_prefix_flash} '{action_type_log_main}' 전송 시도...", 'info')
        
        agent_response_timeout = send_command_to_agent(target_ip_for_send, packet_set_timeout)
        _process_agent_response(agent_response_timeout, log_prefix_flash, action_type_log_main)
        # --- ▼▼▼ 제어 이력 로깅 ▼▼▼ ---
        _log_control_action(pc_data, "SET_DISPLAY_TIMEOUT", payload_summary_main, action_type_log_main, agent_response_timeout, triggered_by)

        if command_action_str == "켜기": # "켜기"일 때만 즉시 모니터 켜기 명령 추가 전송
            action_type_log_immediate_on = "모니터 즉시 켜기"
            payload_summary_immediate_on = "Action: On"
            payload_monitor_on = {'Action': -1} # MonitorAction.On에 해당하는 C# enum 값
            
            packet_monitor_on = {
                'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
                'CommandName': "MONITOR_CONTROL", 'PayloadJson': json.dumps(payload_monitor_on),
                'ResponseAddress': None, 'ResponsePort': None,
                'Instruction': packet_set_timeout['Instruction'], # 이전 SetDisplayTimeout과 동일한 Instruction
                'FinalTargetIpForRelayedCommand': packet_set_timeout.get('FinalTargetIpForRelayedCommand'),
                'FinalTargetPortForRelayedCommand': packet_set_timeout.get('FinalTargetPortForRelayedCommand')
            }
            flash(f"{log_prefix_flash} '{action_type_log_immediate_on}' 추가 전송 시도...", 'info')
            agent_response_monitor_on = send_command_to_agent(target_ip_for_send, packet_monitor_on)
            _process_agent_response(agent_response_monitor_on, log_prefix_flash, action_type_log_immediate_on)
            # --- ▼▼▼ 제어 이력 로깅 ▼▼▼ ---
            _log_control_action(pc_data, "MONITOR_CONTROL", payload_summary_immediate_on, action_type_log_immediate_on, agent_response_monitor_on, triggered_by)
            
    return redirect(url_for('user.control_panel', **redirect_params))

# _process_agent_response 헬퍼 함수는 이전과 동일
def _process_agent_response(agent_response, log_prefix, command_description):
    # ... (이전 _process_agent_response 코드 전체 - 변경 없음, #51 답변 참고) ...
    if agent_response.get('success'):
        raw_pkt = agent_response.get('raw_response')
        if raw_pkt and isinstance(raw_pkt, dict) and 'PayloadJson' in raw_pkt:
            payload_str = raw_pkt.get('PayloadJson')
            current_app.logger.info(f"{log_prefix} - '{command_description}' 응답 PayloadJson: >>>{payload_str}<<<")
            if payload_str is not None:
                try:
                    resp_pl = json.loads(payload_str);
                    if resp_pl.get('Success'): flash(f"{log_prefix} ({command_description}): 성공 - {resp_pl.get('Message', 'OK')}", 'success'); current_app.logger.info(f"{log_prefix} ({command_description}) 성공: {resp_pl.get('Message')}")
                    else: flash(f"{log_prefix} ({command_description}): 실패 (에이전트) - {resp_pl.get('Message', 'Agent error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 에이전트 실패: {resp_pl.get('Message')}")
                except json.JSONDecodeError as je: flash(f"{log_prefix} ({command_description}): 응답 JSON 형식 오류 - {je.msg}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 파싱 오류: {je.msg}. 원본: {payload_str}", exc_info=True)
                except Exception as e: flash(f"{log_prefix} ({command_description}): 응답 처리 중 알 수 없는 오류 - {e}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) PayloadJson 처리 중 알 수 없는 오류: {e}. 원본: {payload_str}", exc_info=True)
            else: flash(f"{log_prefix} ({command_description}): 전송 성공 (페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 페이로드 없음. RawPkt: {raw_pkt}")
        else: flash(f"{log_prefix} ({command_description}): 전송 성공 (상세 응답/페이로드 없음)", 'warning'); current_app.logger.warning(f"{log_prefix} ({command_description}) 전송 성공, 상세 응답/페이로드 없음. RawPkt: {raw_pkt}")
    else: flash(f"{log_prefix} ({command_description}): 전송 실패 - {agent_response.get('message', 'Socket error')}", 'error'); current_app.logger.error(f"{log_prefix} ({command_description}) 전송 실패: {agent_response.get('message')}")

app/routes_user.py 주요 변경 사항:

_log_control_action 함수 추가: 이 헬퍼 함수는 실행된 명령의 상세 정보와 결과를 받아 dbo.action_logs 테이블에 기록합니다.
pc_data (제어 대상 PC 정보), command_name (내부 명령 이름), payload_summary (페이로드 요약), action_type (사용자 친화적 작업 설명), agent_response (에이전트 응답), triggered_by_ip (작업 실행자 IP)를 인자로 받습니다.
pymssql을 사용하여 DB에 INSERT 쿼리를 실행합니다.
send_batch_command 함수 내 로깅 호출:
SetDisplayTimeout 명령 전송 후 _log_control_action을 호출하여 결과를 기록합니다.
"켜기" 작업 시 추가로 전송되는 MONITOR_CONTROL 명령에 대해서도 전송 후 _log_control_action을 호출하여 결과를 기록합니다.
triggered_by_ip 값으로 g.user_ip (현재 접속한 사용자의 IP)를 사용합니다.
3. 수정: scontrol_flask_web/app/scheduler_tasks.py (스케줄 작업 시 로그 기록 추가)
스케줄러에 의해 자동으로 실행되는 작업들도 그 결과를 action_logs 테이블에 기록하도록 수정합니다. _send_display_timeout_to_all_pcs와 새로 추가할 _send_immediate_monitor_control_to_all_pcs 함수 내부에 _log_control_action 호출 로직을 추가합니다. (이때 triggered_by_ip는 'SCHEDULER' 등으로 설정)

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date
import holidays
from flask import current_app # app_context 내에서 current_app 사용
from .db_utils import get_db_connection
from .socket_client import send_command_to_agent
# routes_user.py에서 _log_control_action를 가져오거나, 여기에 유사한 함수를 만듭니다.
# 순환 참조를 피하기 위해, 여기에 로깅 함수를 간소화하여 다시 만들거나,
# 로깅 로직을 별도 유틸리티 파일로 분리하는 것이 좋습니다.
# 여기서는 간결성을 위해 scheduler_tasks.py에 직접 로깅 SQL을 작성합니다.
# from .routes_user import _log_control_action # 직접 임포트 시 순환 참조 주의!

import json
import uuid
from datetime import datetime as dt, timezone
import pymssql


# --- is_operational_day 함수는 이전과 동일 ---
def is_operational_day(target_date, app_instance_logger):
    # ... (이전 코드와 동일) ...
    conn = None
    try:
        conn = get_db_connection(); 
        if not conn: app_instance_logger.error(f"is_operational_day ({target_date}): DB 연결 실패. 기본 가동일 처리."); return True 
        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"; cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),)); exception_day = cursor.fetchone()
            if exception_day: is_op = bool(exception_day['is_operational']); app_instance_logger.info(f"{target_date} 사용자 지정 예외: {'가동일' if is_op else '비가동일'}"); return is_op
        if target_date.weekday() >= 5: app_instance_logger.info(f"{target_date} 주말(비가동일)."); return False
        kr_holidays = holidays.KR(years=target_date.year, observed=True) 
        if target_date in kr_holidays: app_instance_logger.info(f"{target_date} 공휴일('{kr_holidays.get(target_date)}'). (비가동일)"); return False
        app_instance_logger.info(f"{target_date} 평일(가동일)."); return True
    except Exception as e: app_instance_logger.error(f"is_operational_day ({target_date}) 오류: {e}", exc_info=True); return True 


# --- 신규: 스케줄러 작업 로깅을 위한 헬퍼 함수 ---
def _log_scheduled_action(pc_data, command_name, payload_summary, action_type, agent_response, app_instance_logger):
    conn = None
    try:
        conn = get_db_connection() # app_context 내에서 호출되므로 current_app 사용 가능
        with conn.cursor() as cursor:
            sql = """
                INSERT INTO dbo.action_logs 
                (target_pc_id, target_pc_name, target_ip_sent_to, final_target_ip, 
                 command_name, command_payload_summary, action_type, 
                 result_success, result_message, triggered_by_ip)
                VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
            """
            is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
            ip_sent_to = pc_data.get('address1')
            final_ip = pc_data.get('address2') if is_relay else None
            op_success = False; op_message = agent_response.get('message', 'No agent response message.')
            raw_agent_resp_packet = agent_response.get('raw_response')
            if agent_response.get('success') and raw_agent_resp_packet and isinstance(raw_agent_resp_packet, dict) and 'PayloadJson' in raw_agent_resp_packet:
                payload_json_str = raw_agent_resp_packet.get('PayloadJson')
                if payload_json_str:
                    try: resp_payload_dict = json.loads(payload_json_str); op_success = resp_payload_dict.get('Success', False); op_message = resp_payload_dict.get('Message', op_message)
                    except json.JSONDecodeError: op_message = "Failed to parse agent response payload JSON."
                else: op_message = "Agent response payload was empty."
            
            params = (pc_data.get('id'), pc_data.get('pc_name'), ip_sent_to, final_ip, command_name, payload_summary, action_type, op_success, str(op_message)[:2000], 'SCHEDULER')
            cursor.execute(sql, params)
        conn.commit()
        app_instance_logger.info(f"[Scheduler] Action logged: {action_type} for PC {pc_data.get('pc_name')}. Result Success: {op_success}")
    except Exception as e:
        if conn: conn.rollback()
        app_instance_logger.error(f"[Scheduler] Failed to log scheduled action for PC {pc_data.get('pc_name')}: {e}", exc_info=True)


# --- _send_display_timeout_to_all_pcs 수정: 로깅 호출 추가 ---
def _send_display_timeout_to_all_pcs(timeout_minutes_val, action_description, app_instance_logger):
    # ... (PC 목록 조회 로직은 이전과 동일) ...
    conn = None; pcs_to_control = []
    try:
        conn = get_db_connection();
        if not conn: app_instance_logger.error(f"_send_display_timeout_to_all_pcs: DB 연결 실패."); return
        with conn.cursor() as cursor: cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs"); pcs_to_control = cursor.fetchall()
    except Exception as e: app_instance_logger.error(f"스케줄 PC 목록 조회 오류: {e}", exc_info=True); return 
    if not pcs_to_control: app_instance_logger.info("스케줄: 제어할 PC 없음."); return

    app_instance_logger.info(f"스케줄: '{action_description}' ({len(pcs_to_control)}대 PC).")
    payload_obj = {'TimeoutMinutes': timeout_minutes_val} 
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        # ... (command_packet 생성 및 target_ip 결정 로직은 이전과 동일) ...
        command_packet = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: command_packet.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: command_packet.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip})]"
        app_instance_logger.info(f"{log_prefix} - '{action_description}' 전송 시도. PktID: {command_packet['PacketId']}")
        
        agent_response = None # 초기화
        try:
            agent_response = send_command_to_agent(target_ip, command_packet)
            # ... (응답 성공/실패 로깅은 이전과 동일) ...
            if agent_response.get('success'):
                raw_pkt = agent_response.get('raw_response')
                if raw_pkt and isinstance(raw_pkt, dict) and raw_pkt.get('PayloadJson'):
                    resp_pl = json.loads(raw_pkt['PayloadJson'])
                    if resp_pl.get('Success'): app_instance_logger.info(f"{log_prefix} - 성공: {resp_pl.get('Message', 'OK')}")
                    else: app_instance_logger.error(f"{log_prefix} - 실패 (에이전트): {resp_pl.get('Message', 'Agent error')}")
                else: app_instance_logger.warning(f"{log_prefix} - 전송 성공, 상세 응답 확인 불가. Raw: {raw_pkt}")
            else: app_instance_logger.error(f"{log_prefix} - 전송 실패: {agent_response.get('message', 'Socket error')}")
        except Exception as e_send:
            app_instance_logger.error(f"{log_prefix} - 명령 전송 중 예외: {e_send}", exc_info=True)
            # 예외 발생 시 agent_response가 success:false를 포함하도록 구성
            agent_response = {'success': False, 'message': str(e_send)}
        
        # --- ▼▼▼ 제어 이력 로깅 호출 ▼▼▼ ---
        payload_summary = f"Timeout: {timeout_minutes_val} min"
        _log_scheduled_action(pc_data, common_command_name, payload_summary, action_description, agent_response, app_instance_logger)


# --- _send_immediate_monitor_control_to_all_pcs 수정: 로깅 호출 추가 ---
def _send_immediate_monitor_control_to_all_pcs(monitor_action_value, action_description, app_instance_logger):
    # ... (PC 목록 조회 로직은 이전과 동일) ...
    conn = None; pcs_to_control = []
    try:
        conn = get_db_connection();
        if not conn: app_instance_logger.error(f"_send_immediate_monitor_control: DB 연결 실패."); return
        with conn.cursor() as cursor: cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs"); pcs_to_control = cursor.fetchall()
    except Exception as e: app_instance_logger.error(f"스케줄 즉시 모니터 제어 PC 목록 조회 오류: {e}", exc_info=True); return
    if not pcs_to_control: app_instance_logger.info("스케줄 즉시 모니터 제어: 대상 PC 없음."); return

    app_instance_logger.info(f"스케줄 즉시 모니터 제어 시작: '{action_description}' ({len(pcs_to_control)}대 PC).")
    payload_obj = {'Action': monitor_action_value} 
    common_command_name = "MONITOR_CONTROL"

    for pc_data in pcs_to_control:
        # ... (command_packet 생성 및 target_ip 결정 로직은 이전과 동일) ...
        command_packet = { 'PacketId': str(uuid.uuid4()), 'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'), 'CommandName': common_command_name, 'PayloadJson': json.dumps(payload_obj), 'ResponseAddress': None, 'ResponsePort': None }
        target_ip = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay: command_packet.update({'Instruction': "RelayToTarget", 'FinalTargetIpForRelayedCommand': pc_data['address2'], 'FinalTargetPortForRelayedCommand': 4026}); target_ip = pc_data['address1']
        else: command_packet.update({'Instruction': "DirectExecute"}); target_ip = pc_data['address1']
        log_prefix = f"[Scheduler-Immediate][PC: {pc_data.get('pc_name','N/A')}({target_ip})]"
        app_instance_logger.info(f"{log_prefix} - '{action_description}' 전송 시도. PktID: {command_packet['PacketId']}")
        
        agent_response = None # 초기화
        try:
            agent_response = send_command_to_agent(target_ip, command_packet)
            if agent_response.get('success'): app_instance_logger.info(f"{log_prefix} - '{action_description}' 명령 전송 성공 또는 에이전트 응답 수신.")
            else: app_instance_logger.error(f"{log_prefix} - '{action_description}' 명령 전송 실패: {agent_response.get('message')}")
        except Exception as e_send: 
            app_instance_logger.error(f"{log_prefix} - '{action_description}' 명령 전송 중 예외: {e_send}", exc_info=True)
            agent_response = {'success': False, 'message': str(e_send)}

        # --- ▼▼▼ 제어 이력 로깅 호출 ▼▼▼ ---
        payload_summary = f"Action: {monitor_action_value} (On=-1,Off=2,Standby=1)"
        _log_scheduled_action(pc_data, common_command_name, payload_summary, action_description, agent_response, app_instance_logger)


# scheduled_task_monitor_on 및 scheduled_task_monitor_off 함수는 이전과 동일 (app_instance.logger 사용)
def scheduled_task_monitor_on(app_instance): 
    with app_instance.app_context(): 
        today = date.today(); app_instance.logger.info(f"[Scheduler] 모니터 켜기 작업 (06:00) 시작, 오늘: {today}")
        if is_operational_day(today, app_instance.logger): 
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 켜기(타임아웃 0분)' 명령 전송.")
            _send_display_timeout_to_all_pcs(0, "디스플레이 항상 켜기 (타임아웃 0분)", app_instance.logger) 
            app_instance.logger.info(f"[Scheduler] 가동일: '모니터 즉시 켜기' 명령 추가 전송.")
            _send_immediate_monitor_control_to_all_pcs(-1, "모니터 즉시 켜기 (SC_MONITORPOWER)", app_instance.logger)
        else: app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 켜기' 명령 미실행.")
        app_instance.logger.info(f"[Scheduler] 모니터 켜기 작업 완료.")

def scheduled_task_monitor_off(app_instance): 
    with app_instance.app_context():
        today = date.today(); app_instance.logger.info(f"[Scheduler] 모니터 끄기 작업 (07:00) 시작, 오늘: {today}")
        if not is_operational_day(today, app_instance.logger): 
            app_instance.logger.info(f"[Scheduler] 비가동일: '모니터 끄기(1분 후 타임아웃)' 명령 전송.")
            _send_display_timeout_to_all_pcs(1, "디스플레이 1분 후 자동 꺼짐 설정", app_instance.logger)
        else: app_instance_logger.info(f"[Scheduler] 가동일: '모니터 끄기' 명령 미실행.")
        app_instance.logger.info(f"[Scheduler] 모니터 끄기 작업 완료.")
app/scheduler_tasks.py 주요 변경 사항:

_log_scheduled_action 함수 신규 추가: 스케줄러에 의해 실행된 작업의 결과를 dbo.action_logs 테이블에 기록하는 전용 헬퍼 함수입니다. routes_user.py의 _log_control_action 함수와 유사하지만, triggered_by_ip를 'SCHEDULER'로 고정하고 로거를 app_instance_logger로 받습니다.
명령 전송 함수 내 로깅 호출: _send_display_timeout_to_all_pcs와 _send_immediate_monitor_control_to_all_pcs 함수 내부에서 각 PC에 명령을 보내고 응답을 받은 후, _log_scheduled_action 함수를 호출하여 그 결과를 DB에 기록합니다.
agent_response가 예외 발생 등으로 인해 None이 될 경우를 대비하여 초기화하고, 예외 발생 시 기본 실패 응답 구조를 만들어 로깅 함수에 전달합니다.
이제 send_batch_command (사용자 수동 실행) 및 스케줄된 작업들 (자동 실행) 모두 action_logs 테이블에 실행 이력을 기록하게 됩니다.

다음 단계는 이 action_logs 테이블의 내용을 웹 페이지에 표시하고, 요청하신 차트 기능을 구현하는 app/routes_logs.py (신규) 와 app/templates/logs/view_logs.html (신규) 파일을 만드는 것입니다.