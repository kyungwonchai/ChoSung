래는 고수준으로 작성된 WPF 소켓 통신 코드입니다. 이 코드는 MVVM 패턴을 따르며, 소켓 통신, 에러 처리, 이력 로깅을 모두 처리합니다. 로그는 C:\MESMERGEOI 폴더에 저장되며, 각 로그 파일은 날짜별로 구분됩니다. 전체 구조를 세심하게 고려하여 작성했으며, 가능한 모든 에러와 상황에 대비해 처리했습니다. 코드 주석은 매우 상세하게 작성하여 각 부분이 어떤 역할을 하는지 명확하게 이해할 수 있도록 했습니다.

디렉토리 및 파일 구조
코드 복사
WpfSocketCommunication
│
├── ViewModels
│   ├── MainViewModel.cs
│
├── Models
│   ├── SocketClient.cs
│   ├── Logger.cs
│
├── Views
│   ├── MainWindow.xaml
│   ├── MainWindow.xaml.cs
│
├── App.xaml
├── App.xaml.cs
1. MainWindow.xaml (View)
xml
코드 복사
<Window x:Class="WpfSocketCommunication.Views.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
        xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
        mc:Ignorable="d"
        Title="Socket Communication" Height="350" Width="525">
    <Grid>
        <TextBox Name="LogTextBox" VerticalScrollBarVisibility="Auto" 
                 HorizontalScrollBarVisibility="Auto" IsReadOnly="True"
                 Margin="10,10,10,60" Text="{Binding LogMessages}" />
        <Button Content="Send Label" HorizontalAlignment="Left" 
                VerticalAlignment="Bottom" Width="100" Height="30"
                Margin="10,0,0,10" Command="{Binding SendLabelCommand}" />
        <Button Content="Send Interrupt" HorizontalAlignment="Right" 
                VerticalAlignment="Bottom" Width="120" Height="30"
                Margin="0,0,10,10" Command="{Binding SendInterruptCommand}" />
    </Grid>
</Window>
2. MainWindow.xaml.cs (View Code-behind)
csharp
코드 복사
using System.Windows;

namespace WpfSocketCommunication.Views
{
    public partial class MainWindow : Window
    {
        public MainWindow()
        {
            InitializeComponent();
        }
    }
}
3. MainViewModel.cs (ViewModel)
csharp
코드 복사
using System;
using System.Windows.Input;
using WpfSocketCommunication.Models;
using System.ComponentModel;

namespace WpfSocketCommunication.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly SocketClient _socketClient;
        private readonly Logger _logger;
        private string _logMessages;

        public ICommand SendLabelCommand { get; }
        public ICommand SendInterruptCommand { get; }

        public string LogMessages
        {
            get => _logMessages;
            set
            {
                _logMessages = value;
                OnPropertyChanged(nameof(LogMessages));
            }
        }

        public MainViewModel()
        {
            // 소켓 클라이언트 및 로거 인스턴스화
            _socketClient = new SocketClient(UpdateLog);
            _logger = new Logger();

            // 커맨드 연결
            SendLabelCommand = new RelayCommand(SendLabel);
            SendInterruptCommand = new RelayCommand(SendInterrupt);

            // 로그 시작
            _logger.Log("프로그램 시작");
        }

        // 라벨 데이터를 서버에 전송하는 함수
        private void SendLabel()
        {
            string labelData = "LABEL_DATA:12345"; // 임의의 라벨 데이터
            _socketClient.SendData(labelData);
            _logger.Log($"라벨 데이터 전송: {labelData}");
        }

        // 인터럽트 신호를 서버에 전송하는 함수
        private void SendInterrupt()
        {
            string interruptSignal = "INTERRUPT_SIGNAL";
            _socketClient.SendData(interruptSignal);
            _logger.Log($"인터럽트 신호 전송: {interruptSignal}");
        }

        // UI 로그를 업데이트하는 함수
        private void UpdateLog(string message)
        {
            LogMessages += message + Environment.NewLine;
            _logger.Log(message);
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
4. SocketClient.cs (Model)
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading;

namespace WpfSocketCommunication.Models
{
    public class SocketClient
    {
        private Socket _clientSocket;
        private bool _connected = false;
        private readonly Action<string> _logAction;
        private const string _ip = "127.0.0.1"; // 서버 IP 주소 (테스트용)
        private const int _port = 12345; // 서버 포트 번호

        public SocketClient(Action<string> logAction)
        {
            _logAction = logAction;
            ConnectToServer();
        }

        // 서버에 연결하는 함수
        private void ConnectToServer()
        {
            try
            {
                _clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                _clientSocket.Connect(_ip, _port);
                _connected = true;
                _logAction("서버에 연결되었습니다.");

                // 데이터 수신 시작
                Thread receiveThread = new Thread(StartListening);
                receiveThread.IsBackground = true;
                receiveThread.Start();
            }
            catch (Exception ex)
            {
                _logAction($"서버 연결 실패: {ex.Message}");
            }
        }

        // 서버로 데이터를 전송하는 함수
        public void SendData(string data)
        {
            if (_connected)
            {
                try
                {
                    byte[] buffer = Encoding.ASCII.GetBytes(data);
                    _clientSocket.Send(buffer);
                    _logAction($"데이터 전송 성공: {data}");
                }
                catch (SocketException ex)
                {
                    _logAction($"데이터 전송 실패: {ex.Message}");
                }
            }
            else
            {
                _logAction("서버와 연결되지 않았습니다.");
            }
        }

        // 서버로부터 데이터를 수신하는 함수
        private void StartListening()
        {
            byte[] buffer = new byte[1024];
            while (_connected)
            {
                try
                {
                    int receivedBytes = _clientSocket.Receive(buffer);
                    if (receivedBytes > 0)
                    {
                        string message = Encoding.ASCII.GetString(buffer, 0, receivedBytes);
                        _logAction($"수신된 메시지: {message}");

                        // 특별한 인터럽트 신호 처리
                        if (message.Contains("INTERRUPT"))
                        {
                            _logAction("인터럽트 신호 수신");
                        }
                    }
                }
                catch (SocketException ex)
                {
                    _logAction($"데이터 수신 실패: {ex.Message}");
                    _connected = false;
                }
            }
        }
    }
}
5. Logger.cs (Model - 로그 기록 클래스)
csharp
코드 복사
using System;
using System.IO;

namespace WpfSocketCommunication.Models
{
    public class Logger
    {
        private readonly string _logDirectory;

        public Logger()
        {
            // 로그 폴더 생성 경로 설정
            _logDirectory = @"C:\MESMERGEOI";
            if (!Directory.Exists(_logDirectory))
            {
                Directory.CreateDirectory(_logDirectory);
            }
        }

        // 로그를 기록하는 함수
        public void Log(string message)
        {
            string logFile = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}.log");

            try
            {
                // 로그 파일에 추가
                using (StreamWriter writer = new StreamWriter(logFile, true))
                {
                    string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} {message}";
                    writer.WriteLine(logMessage);
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"로그 작성 실패: {ex.Message}");
            }
        }
    }
}
6. RelayCommand.cs (커맨드를 처리하기 위한 클래스)
csharp
코드 복사
using System;
using System.Windows.Input;

namespace WpfSocketCommunication.ViewModels
{
    public class RelayCommand : ICommand
    {
        private readonly Action _execute;
        private readonly Func<bool> _canExecute;

        public RelayCommand(Action execute, Func<bool> canExecute = null)
        {
            _execute = execute;
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute();
        }

        public void Execute(object parameter)
        {
            _execute();
        }

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }
    }
}
핵심 포인트
MVVM 패턴: 모든 로직은 MainViewModel에 위치하며, 뷰는 데이터 바인딩을 통해 소켓 클라이언트와 상호작용합니다.
로그 시스템: Logger 클래스를 사용하