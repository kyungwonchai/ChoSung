경원님, 이번에는 특정 대역을 스캔하여 기존 리스트(ipall.txt)에 없는 새로운 라즈베리파이를 찾아내는 작업을 진행하시려는군요.

네트워크 대역(100~253)을 하나씩 접속하면 시간이 꽤 걸릴 수 있으므로, **멀티스레딩(Concurrent Futures)**을 사용하여 빠르게 스캔하고, 결과만 깔끔하게 출력하는 최적화된 스크립트를 작성했습니다.

1. 작업 개요
스캔 대역: 10.249.142.100 ~ 10.249.142.253

인증 정보: ID pi / PW raspberry

필터링 조건: 접속 성공한 IP 중 ipall.txt 파일에 존재하지 않는 IP만 출력

2. 원샷 파이썬 스크립트
이 코드는 파이참에서 바로 실행하시면 됩니다. paramiko가 설치되어 있어야 합니다.

Python

import paramiko
import concurrent.futures
import os

def check_ssh_login(ip, username, password):
    """SSH 접속 가능 여부를 확인합니다."""
    ssh = paramiko.SSHClient()
    ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    try:
        # timeout을 짧게 설정하여 스캔 속도를 높임
        ssh.connect(ip, port=22, username=username, password=password, timeout=3)
        return ip, True
    except:
        return ip, False
    finally:
        ssh.close()

def find_new_raspberry_pis():
    # --- 설정 영역 ---
    base_ip_prefix = "10.249.142."
    start_last_octet = 100
    end_last_octet = 253
    known_ips_file = 'ipall.txt'
    user = 'pi'
    pw = 'raspberry'
    
    # 1. 기존 ipall.txt 읽기 (중복 체크용)
    known_ips = set()
    if os.path.exists(known_ips_file):
        with open(known_ips_file, 'r') as f:
            known_ips = {line.strip() for line in f if line.strip()}
    else:
        print(f"[참고] {known_ips_file} 파일이 없습니다. 모든 접속 성공 IP를 출력합니다.")

    # 2. 스캔할 IP 리스트 생성
    target_ips = [f"{base_ip_prefix}{i}" for i in range(start_last_octet, end_last_octet + 1)]
    
    print(f"--- {base_ip_prefix}{start_last_octet}~{end_last_octet} 대역 스캔 시작 ---")
    print(f"--- (기존 {len(known_ips)}개의 IP 제외 대상) ---")

    new_found_count = 0
    
    # 3. 멀티스레딩을 이용한 병렬 스캔 (Max 20개 스레드)
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        future_to_ip = {executor.submit(check_ssh_login, ip, user, pw): ip for ip in target_ips}
        
        for future in concurrent.futures.as_completed(future_to_ip):
            ip, is_success = future.result()
            
            # 접속 성공했고, 기존 리스트에 없는 경우만 출력
            if is_success and ip not in known_ips:
                print(f"[발견!] 새로운 장치: {ip}")
                new_found_count += 1

    if new_found_count == 0:
        print("\n새롭게 발견된 라즈베리파이가 없습니다.")
    else:
        print(f"\n총 {new_found_count}개의 새로운 장치를 찾았습니다.")

if __name__ == "__main__":
    find_new_raspberry_pis()
3. 주요 특징 및 주의사항
멀티스레딩 적용: 하나씩 접속하면 타임아웃 대기 시간 때문에 매우 오래 걸립니다. ThreadPoolExecutor를 사용해 20개씩 동시에 체크하도록 설계하여 속도를 극대화했습니다.

중복 제거: set() 자료구조를 사용하여 ipall.txt에 있는 IP를 효율적으로 필터링합니다.

타임아웃 설정: timeout=3으로 설정하여 응답이 없는 IP에서 너무 오래 머물지 않도록 했습니다. 네트워크 환경에 따라 너무 빠르다 싶으면 5 정도로 늘려주세요.

다음 단계 제안
경원님, 발견된 이 새로운 IP들을 자동으로 ipall.txt 하단에 추가하거나, 아까 하셨던 것처럼 자동으로 SSH 키를 심는 작업까지 한 번에 연결해 드릴까요? 필요하시면 말씀해 주세요!