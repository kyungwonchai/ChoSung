하신 문제는 작업이 자동으로 실행되지 않는 상황입니다. 이 문제는 작업 큐가 비어있거나, 새로운 작업이 큐에 들어갔을 때 즉시 실행되지 않는 상황에서 발생할 수 있습니다.

작업 큐가 비어있을 때, 새로운 작업이 들어오면 바로 실행되어야 합니다. 그럼에도 불구하고 작업이 펜딩(Pending) 상태로 남아 있다면, 작업 큐가 실행 중인지 확인하고 자동 실행 로직을 다시 점검해야 합니다.

다음은 이 문제를 해결하기 위해 필요한 함수와 수정된 코드입니다.

1. TaskQueue.cs - 자동 실행 문제 해결
csharp
코드 복사
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;  // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;   // 작업이 일시정지 상태인지 여부

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        // 현재 작업이 실행 중이 아니면 즉시 실행
        if (!_isRunning && !_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        // 작업 큐가 비어있거나 일시정지 상태면 리턴
        if (_tasks.Count == 0 || _isPaused)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;  // 현재 작업 실행 중

        // 큐에서 작업을 가져와 실행
        var task = _tasks.Dequeue();
        await task();  // 비동기 작업 실행

        // 작업 완료 후 실행 중 상태 해제
        _isRunning = false;

        // 다음 작업을 실행
        RunNextTask();
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;  // 전체 작업 일시정지
    }

    /// <summary>
    /// 일시정지된 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        _isPaused = false;  // 일시정지 상태 해제

        // 작업이 실행 중이지 않으면 다음 작업을 실행
        if (!_isRunning)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐를 초기화하고 비웁니다.
    /// </summary>
    public void ClearQueue()
    {
        _tasks.Clear();  // 작업 큐 비우기
        _isRunning = false;  // 실행 상태 해제
    }
}
2. TaskModel.cs - 작업 큐와 연동
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 작업 큐에 작업을 추가하고 실행합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수 상태를 관리하는 컬렉션
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }  // 리쥼 커맨드

    private TaskQueue _taskQueue;

    public TaskModel(TaskQueue taskQueue)
    {
        _taskQueue = taskQueue;

        // 작업 상태 초기화
        FunctionStatusList = new ObservableCollection<FunctionStatus>();

        Status = "Pending";  // 처음엔 대기 상태

        // 각 함수 및 도형 상태 추가
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);

        // 리쥼 커맨드 설정
        ResumeCommand = new RelayCommand(StartTask);
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행합니다.
    /// </summary>
    public void StartTask()
    {
        // 작업 상태 업데이트
        Status = "Running";

        // 작업 큐에 시퀀스 작업 추가
        _taskQueue.EnqueueTask(ExecuteTaskSequence);
    }

    /// <summary>
    /// 시퀀스 작업을 비동기적으로 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);
        }
        
        Status = "Completed";  // 모든 작업 완료
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    public async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);  // 진행 중 상태
        });

        await task();  // 비동기 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);  // 완료 상태
        });
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    /// <summary>
    /// 함수 이름, 작업, 도형 색상을 함께 관리
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);
    }
}
3. MainViewModel.cs - 작업 추가 및 자동 실행
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    public ICommand PauseAllCommand { get; }
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 전체 작업 정지와 재개 명령 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(_taskQueue);
            TaskList.Add(task);  // 작업 목록에 추가
            task.StartTask();  // 작업을 자동으로 시작
        });
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();  // 모든 작업을 일시정지
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();  // 모든 작업 재개
    }
}
요약:
작업이 추가될 때 자동 실행:

EnqueueTask 메서드에서 작업이 추가될 때, 현재 작업이 실행 중이 아니면 즉시 실행하도록 구현하였습니다.
새로운 작업이 큐에 들어가면 자동으로 실행됩니다.
작업 큐가 비어 있거나 일시정지 중일 때:

큐가 비어 있거나 일시정지 상태라면 작업이 실행되지 않도록 하였습니다.
**ExecuteTaskWithColor**는 각 작업을 실행할 때, 도형의 색상을 변경하여 진행 상태를 시각적으로 표현합니다.

이 코드를 적용하면, 작업이 펜딩 상태로 남지 않고 자동으로 실행될 것입