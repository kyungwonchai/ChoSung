아래는 MergeOIErrLogManager를 개선하여 3초마다 폴더를 검사하고, 최근 2일치 로그 파일에서 데이터만 가져오는 방식으로 구현한 코드입니다. 기존의 파일 감시(FileSystemWatcher)를 제거하고 타이머 기반 방식으로 변경했습니다.

1. MergeOIErrLogManager (로그 관리 클래스)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.IO;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;

public class MergeOIErrLogManager
{
    private readonly string _logDirectory = @"C:\prod_file_logs"; // 로그 폴더 경로
    private readonly object _lock = new object(); // 스레드 동기화용
    private Timer _timer;
    private DateTime _lastLogTime = DateTime.MinValue; // 마지막 로그 시간 기록

    public ObservableCollection<MergeOIErrLogEntry> LogEntries { get; private set; } = new ObservableCollection<MergeOIErrLogEntry>();

    public MergeOIErrLogManager()
    {
    }

    /// <summary>
    /// 로그 관리 초기화
    /// </summary>
    public void Initialize()
    {
        _timer = new Timer(async _ => await CheckLogsAsync(), null, 0, 3000); // 3초 간격으로 검사
    }

    /// <summary>
    /// 로그 폴더를 검사하고 새 로그를 로드
    /// </summary>
    private async Task CheckLogsAsync()
    {
        try
        {
            // 최근 2일치 폴더 검색
            var targetDates = Enumerable.Range(0, 2)
                                        .Select(offset => DateTime.Now.AddDays(-offset).ToString("yyyyMMdd"))
                                        .ToList();
            var files = targetDates.Select(date => Path.Combine(_logDirectory, $"{date}.txt"))
                                   .Where(File.Exists)
                                   .ToList();

            var allLines = new List<string>();

            foreach (var file in files)
            {
                // 파일의 모든 라인 읽기
                var lines = await Task.Run(() => File.ReadAllLines(file));
                allLines.AddRange(lines);
            }

            // 새로운 로그 필터링
            var parsedEntries = allLines
                .Where(line => !string.IsNullOrWhiteSpace(line))
                .Select(ParseLogLine)
                .Where(entry => entry != null && entry.Time > _lastLogTime) // 마지막 시간 이후의 로그만
                .OrderByDescending(entry => entry.Time) // 시간 내림차순
                .ToList();

            if (parsedEntries.Any())
            {
                _lastLogTime = parsedEntries.Max(entry => entry.Time); // 마지막 로그 시간 업데이트

                // UI 스레드에서 컬렉션 갱신
                Application.Current.Dispatcher.Invoke(() =>
                {
                    lock (_lock)
                    {
                        foreach (var entry in parsedEntries)
                        {
                            LogEntries.Add(entry);
                        }

                        // 최근 2일치까지만 유지
                        var cutoffTime = DateTime.Now.AddDays(-2);
                        for (int i = LogEntries.Count - 1; i >= 0; i--)
                        {
                            if (LogEntries[i].Time < cutoffTime)
                            {
                                LogEntries.RemoveAt(i);
                            }
                        }
                    }
                });
            }
        }
        catch (Exception ex)
        {
            // 오류 처리
            Console.WriteLine($"로그 처리 중 오류 발생: {ex.Message}");
        }
    }

    /// <summary>
    /// 로그 라인 파싱
    /// </summary>
    private MergeOIErrLogEntry ParseLogLine(string line)
    {
        try
        {
            var timeEndIndex = line.IndexOf("]");
            var timePart = line.Substring(1, timeEndIndex - 1); // [시간] 부분
            var messageStartIndex = timeEndIndex + 2;
            var messageEndIndex = line.LastIndexOf(":");
            var messagePart = line.Substring(messageStartIndex, messageEndIndex - messageStartIndex);
            var detailsPart = line.Substring(messageEndIndex + 1);

            return new MergeOIErrLogEntry
            {
                Time = DateTime.Parse(timePart),
                Message = messagePart,
                Details = detailsPart
            };
        }
        catch
        {
            return null; // 잘못된 로그는 무시
        }
    }
}

/// <summary>
/// 로그 항목 클래스
/// </summary>
public class MergeOIErrLogEntry
{
    public DateTime Time { get; set; } // 로그 시간
    public string Message { get; set; } // 메시지
    public string Details { get; set; } // 세부 내용
}
2. MainViewModel
MergeOIErrLogManager를 사용하여 뷰모델에 로그 데이터를 바인딩합니다.

csharp
코드 복사
public class MainViewModel : BaseViewModel
{
    public MergeOIErrLogManager LogManager { get; private set; }

    public ObservableCollection<MergeOIErrLogEntry> LogEntries => LogManager.LogEntries;

    public MainViewModel()
    {
        LogManager = new MergeOIErrLogManager();
        LogManager.Initialize(); // 로그 관리 초기화
    }
}
3. XAML
LogEntries를 DataGrid에 바인딩하여 UI에서 로그를 표시합니다.

xml
코드 복사
<Window x:Class="LogViewer.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Viewer" Height="450" Width="800">
    <Window.DataContext>
        <local:MainViewModel />
    </Window.DataContext>
    <Grid>
        <DataGrid ItemsSource="{Binding LogEntries}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <!-- 시간 컬럼 -->
                <DataGridTextColumn Header="시간" Binding="{Binding Time, StringFormat=yyyy-MM-dd HH:mm:ss.fff}" Width="*"/>
                <!-- 메시지 컬럼 -->
                <DataGridTextColumn Header="메시지" Binding="{Binding Message}" Width="2*"/>
                <!-- 세부 내용 컬럼 -->
                <DataGridTextColumn Header="세부 내용" Binding="{Binding Details}" Width="2*"/>
            </DataGrid.Columns>
        </DataGrid>
    </Grid>
</Window>
4. 코드 설명
폴더 검사 방식:

CheckLogsAsync 메서드에서 최근 2일치 폴더(yyyyMMdd.txt 파일)를 찾아 읽습니다.
각 파일을 비동기로 읽어 라인을 수집하고, 새로운 로그만 추가합니다.
최적화:

마지막으로 처리된 로그 시간(_lastLogTime) 이후의 로그만 필터링하여 중복 처리 방지.
로그가 추가될 때 UI 스레드에서만 LogEntries를 갱신.
타이머 기반 처리:

System.Threading.Timer를 사용하여 3초마다 폴더를 검사합니다.
최근 2일치 유지:

오래된 로그는 자동으로 LogEntries에서 제거하여 메모리 사용을 최소화합니다.
5. 결과
3초마다 폴더 검사: 새 로그가 발견되면 UI에 자동 반영.