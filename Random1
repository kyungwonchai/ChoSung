, 두 가지 오류 메시지에 대해 자세히 살펴보겠습니다.

"unexpected utf-8 bom": 이 메시지는 일반적으로 데이터 스트림의 시작 부분에서 예기치 않은 UTF-8 BOM(Byte Order Mark) 문자를 만났을 때 발생합니다. Flask(socket_client.py)에서 SAgentM.App으로 JSON 데이터를 보낼 때, Python의 표준 json.dumps().encode('utf-8') 방식은 BOM을 추가하지 않습니다. SAgentM.App의 StreamReader 또한 Encoding.UTF8로 설정되어 있어 BOM이 있더라도 보통 투명하게 처리합니다.

이 메시지가 어디에서 표시되는지 알려주시면 원인 파악에 도움이 됩니다 (예: SAgentM.App의 로그, Flask 앱의 로그 또는 UI).
만약 SAgentM.App이 Flask로부터 받은 요청을 파싱하는 단계에서 이 문제가 발생한다면, powercfg 명령 실행 단계까지 가지 못했을 수 있습니다.
"fauked ti set dusokay timeout . ac exit:1, dc exit :1" (Failed to set display timeout. AC ExitCode: 1, DC ExitCode: 1):

이 메시지는 SAgentM.App이 powercfg.exe를 실행했지만, powercfg.exe가 오류를 반환하며 종료되었음을 의미합니다 (종료 코드 0이 아닌 1).
이것은 SAgentM.App.exe가 powercfg.exe를 실행할 충분한 권한(관리자 권한)을 갖지 못했기 때문일 가능성이 매우 높습니다.
두 오류의 연관성:

만약 "unexpected utf-8 bom" 오류가 SAgentM.App에서 Flask가 보낸 요청을 처리하는 초기에 발생한다면, SetDisplayTimeout 명령 자체가 제대로 인식되지 않아 powercfg 관련 로직이 아예 실행되지 않았거나 다른 방식으로 실패했을 수 있습니다.

그러나 "AC ExitCode: 1, DC ExitCode: 1" 메시지가 Flask UI에 표시되었다면, 이는 SAgentM.App이 Flask의 요청을 일단 성공적으로 파싱하고, SetDisplayTimeout 명령을 인지하여 powercfg를 실행했으나, powercfg 실행 자체가 권한 등의 문제로 실패했고, 그 실패 결과를 Flask로 다시 응답했음을 의미합니다. 이 경우, "utf-8 bom" 메시지는 부수적인 경고이거나, Flask가 응답을 받는 과정에서 발생했을 수도 있습니다 (가능성 낮음).

가장 가능성이 높은 시나리오는 powercfg 실행 권한 문제입니다.

문제 해결을 위한 핵심 점검 사항 및 코드
1. SAgentM.App.exe의 관리자 권한 실행 재확인 (매우 중요!)

app.manifest 파일 확인: SAgentM.App 프로젝트에 app.manifest 파일이 있고, 내용에 <requestedExecutionLevel level="requireAdministrator" uiAccess="false" /> 가 올바르게 설정되어 있는지 다시 확인합니다. (이전 답변 #33의 1번 항목 참고)
프로젝트 재빌드: app.manifest 수정 후에는 반드시 프로젝트를 재빌드해야 적용됩니다.
실행 방법:
Visual Studio에서 직접 실행할 경우: Visual Studio 자체를 관리자 권한으로 실행한 후 SAgentM.App을 시작합니다.
컴파일된 SAgentM.App.exe 파일(예: bin\Debug 또는 bin\Release 폴더 내)을 직접 실행할 경우: 마우스 우클릭 후 **"관리자 권한으로 실행"**을 선택합니다. 또는, app.manifest가 올바르게 적용되었다면 실행 시 Windows의 사용자 계정 컨트롤(UAC) 프롬프트가 나타나 관리자 권한을 요청해야 합니다. 이 프롬프트에서 "예"를 선택해야 합니다.
2. powercfg.exe 직접 실행 테스트 (Windows 대상 PC에서)

SAgentM.App이 실행될 Windows PC에서, **"관리자 권한으로 명령 프롬프트(cmd)를 실행"**한 후 다음 명령을 직접 입력하여 오류 없이 실행되는지 확인합니다.

DOS

powercfg /CHANGE DISPLAYTIMEOUTAC 1
powercfg /CHANGE DISPLAYTIMEOUTDC 1
만약 이 단계에서 "이 작업을 수행할 권한이 없습니다." 등의 오류가 발생한다면, 해당 Windows 시스템의 권한 설정 문제이므로 SAgentM.App 코드 수정만으로는 해결이 어렵습니다. 이 직접 실행이 성공해야 합니다.

3. SAgentM.App/Services/AgentCoreService.cs 파일 (코드 자체는 이전과 동일)

powercfg 실행 로직 및 JSON 처리 로직은 이전 답변(#31, #33)에서 제공된 AgentCoreService.cs의 내용이 표준적인 방식입니다. 코드 자체의 문제보다는 실행 환경, 특히 권한 문제가 주 원인으로 보입니다.

"unexpected utf-8 bom" 오류가 정확히 어느 시점의 어떤 로그(SAgentM.App 또는 Flask)에서 나타나는지 알려주시면 해당 부분의 코드(예: HandleClientAsync의 JSON 역직렬화 부분)를 더 자세히 살펴볼 수 있습니다.

일단, AgentCoreService.cs의 전체 코드를 다시 제공해 드리며, 특히 RunPowerCfgCommand와 SetDisplayTimeout 처리 부분을 다시 한번 확인해 보시기 바랍니다. 가장 중요한 것은 이 코드를 실행하는 SAgentM.App.exe가 확실하게 관리자 권한을 가지고 있느냐는 점입니다.

C#

// SAgentM.App/Services/AgentCoreService.cs
// (이전 답변 #33에서 제공된 AgentCoreService.cs 전체 코드를 여기에 붙여넣습니다.)
// 이전 답변의 코드는 이미 Newtonsoft.Json을 사용한 역직렬화, 
// powercfg 실행 로직, "모니터 끄기" 조기 응답 처리 등을 포함하고 있습니다.
// 다시 한번 해당 코드 전체를 아래에 첨부합니다.

using Newtonsoft.Json;
using SControl.Common; 
using System;
using System.Configuration;
using System.Diagnostics; 
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace SAgentM.App.Services
{
    public interface IAgentCoreService { /* 이전과 동일 */ void Start(); void Stop(); bool IsRunning { get; } }

    public class AgentCoreService : IAgentCoreService
    {
        private readonly ILoggingService _loggingService;
        private readonly int _port;
        private TcpListener _listener;
        private Thread _listenThread;
        private volatile bool _isRunning;
        private CancellationTokenSource _cancellationTokenSource;

        public bool IsRunning => _isRunning;

        public AgentCoreService(ILoggingService loggingService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            if (!int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out _port))
            {
                _port = 4026; 
                _loggingService.UiWarn($"ListenPort 설정이 App.config에 없거나 잘못되어 기본값 {_port} 포트를 사용합니다.");
            }
        }

        public void Start()
        {
            if (_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 실행 중."); return; }
            _isRunning = true;
            _cancellationTokenSource = new CancellationTokenSource();
            _listenThread = new Thread(ListenLoop) { IsBackground = true, Name = "AgentListenThread" };
            _listenThread.Start();
            _loggingService.UiInfo($"AgentCoreService 시작됨. 포트: {_port}");
        }

        public void Stop()
        {
            if (!_isRunning) { _loggingService.UiWarn("AgentCoreService 이미 중지됨."); return; }
            _loggingService.UiInfo("AgentCoreService 중지 요청 중...");
            _isRunning = false;
            _cancellationTokenSource?.Cancel();
            _listener?.Stop();
            if (_listenThread != null && _listenThread.IsAlive)
            {
                if (!_listenThread.Join(TimeSpan.FromSeconds(5))) { _loggingService.UiWarn("리스닝 스레드 시간 내 종료 안됨."); }
            }
            _cancellationTokenSource?.Dispose(); _cancellationTokenSource = null;
            _loggingService.UiInfo("AgentCoreService 중지됨.");
        }

        private void ListenLoop()
        {
            try
            {
                _listener = new TcpListener(IPAddress.Any, _port);
                _listener.Start();
                _loggingService.UiInfo($"포트 {_port}에서 클라이언트 연결 대기 중...");
                while (_isRunning)
                {
                    try
                    {
                        TcpClient client = _listener.AcceptTcpClient();
                        if (!_isRunning) { client.Close(); break; }
                        string clientIp = client.Client.RemoteEndPoint?.ToString() ?? "Unknown IP";
                        _loggingService.UiInfo($"클라이언트 연결됨: {clientIp}");
                        var currentToken = _cancellationTokenSource?.Token ?? CancellationToken.None;
                        Task.Run(() => HandleClientAsync(client, clientIp, currentToken), currentToken);
                    }
                    catch (SocketException se)
                    {
                        if (!_isRunning && (se.SocketErrorCode == SocketError.Interrupted || se.SocketErrorCode == SocketError.OperationAborted))
                        { _loggingService.UiInfo("리스너 소켓 정상 중단됨."); break; }
                        _loggingService.UiError("클라이언트 연결 수락 중 소켓 오류.", se);
                        if (!_isRunning) break; Thread.Sleep(100);
                    }
                    catch (InvalidOperationException ioe) when (!_isRunning)
                    { _loggingService.UiInfo($"리스너 중지 후 InvalidOperationException (무시): {ioe.Message}"); break; }
                    catch (Exception ex)
                    { _loggingService.UiError("클라이언트 연결 수락 중 예기치 않은 오류.", ex); if (!_isRunning) break; Thread.Sleep(100); }
                }
            }
            catch (Exception ex) { _loggingService.UiError("ListenLoop 심각한 오류. 리스너 중단.", ex); }
            finally
            {
                if (_listener != null && _listener.Server.IsBound) { _listener.Stop(); }
                _loggingService.UiInfo("ListenLoop 종료됨.");
            }
        }

        private async Task HandleClientAsync(TcpClient client, string clientIpInfo, CancellationToken token)
        {
            CommandPacket receivedRequestPacket = null; CommandPacket sentResponsePacket = null;
            try
            {
                _loggingService.UiDebug($"[{clientIpInfo}] 클라이언트 처리 시작.");
                using (client) using (NetworkStream stream = client.GetStream())
                using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                {
                    while (_isRunning && client.Connected && !token.IsCancellationRequested)
                    {
                        string requestJson = null;
                        try
                        {
                            var readTask = reader.ReadLineAsync(); // 클라이언트로부터 한 줄 읽기 (JSON 문자열)
                            if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, token)) == readTask)
                            {
                                if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 후 취소 감지."); token.ThrowIfCancellationRequested(); }
                                requestJson = await readTask;
                            }
                            else { _loggingService.UiDebug($"[{clientIpInfo}] ReadLineAsync 대기 중 취소 감지."); token.ThrowIfCancellationRequested(); }

                            if (requestJson == null) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 연결 종료 (스트림 끝)."); break; }
                            _loggingService.UiReceived($"[{clientIpInfo}] 수신: {requestJson}"); // 수신된 JSON 로깅

                            CommandPacket requestPacket = null;
                            try
                            {
                                // Newtonsoft.Json을 사용하여 역직렬화
                                requestPacket = JsonConvert.DeserializeObject<CommandPacket>(requestJson);
                                receivedRequestPacket = requestPacket;
                            }
                            catch (JsonException jsonEx)
                            {
                                _loggingService.UiError($"[{clientIpInfo}] JSON 역직렬화 실패: {requestJson}", jsonEx);
                                // 오류 응답 생성 및 전송
                                await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(null, $"Invalid JSON format: {jsonEx.Message}")));
                                continue; // 다음 메시지 대기
                            }

                            if (requestPacket != null)
                            {
                                _loggingService.UiInfo($"[{clientIpInfo}] 명령 처리 시작: ID={requestPacket.PacketId}, Cmd={requestPacket.CommandName}");
                                CommandPacket responsePacket = await ProcessCommandAsync(requestPacket, clientIpInfo, token);
                                sentResponsePacket = responsePacket;
                                if (responsePacket != null)
                                {
                                    string responseJson = JsonConvert.SerializeObject(responsePacket);
                                    if (token.IsCancellationRequested) { _loggingService.UiDebug($"[{clientIpInfo}] 응답 전송 전 취소 감지."); token.ThrowIfCancellationRequested(); }
                                    await writer.WriteLineAsync(responseJson); // 응답 전송
                                    _loggingService.UiSent($"[{clientIpInfo}] 응답 전송: {responseJson}");
                                    
                                    // 모니터 끄기 명령의 경우, 응답 전송 후 실제 끄기 작업 수행
                                    HandleMonitorOffPostProcessing(receivedRequestPacket, sentResponsePacket, clientIpInfo);
                                }
                            }
                        }
                        catch (IOException ioEx) { _loggingService.UiWarn($"[{clientIpInfo}] 네트워크 IO 오류 (연결 끊김 예상): {ioEx.Message}"); break; }
                        catch (ObjectDisposedException odEx) { _loggingService.UiWarn($"[{clientIpInfo}] 객체 이미 해제됨 (연결 끊김 예상): {odEx.Message}"); break; }
                        catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 작업 취소됨."); break; }
                        catch (Exception ex)
                        {
                            _loggingService.UiError($"[{clientIpInfo}] 클라이언트 처리 중 예기치 않은 오류.", ex);
                            if (client.Connected && stream.CanWrite)
                            { try { await writer.WriteLineAsync(JsonConvert.SerializeObject(CreateErrorResponse(receivedRequestPacket, $"Server error: {ex.Message}"))); } catch (Exception writeEx){ _loggingService.UiError($"[{clientIpInfo}] 오류 응답 전송 실패.", writeEx); }}
                        }
                    }
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIpInfo}] HandleClientAsync 작업 자체가 취소됨."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIpInfo}] HandleClientAsync 외부에서 심각한 오류.", ex); }
            finally { _loggingService.UiInfo($"[{clientIpInfo}] 클라이언트 처리 종료."); }
        }

        private void HandleMonitorOffPostProcessing(CommandPacket request, CommandPacket response, string clientIp)
        {
            if (request != null && request.Instruction == CommandInstruction.DirectExecute && request.CommandName == CommandNames.MonitorControl)
            {
                MonitorControlPayload originalPayload = null;
                try { originalPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(request.PayloadJson); } catch { /* 무시 */ }
                if (originalPayload != null && originalPayload.Action == MonitorAction.Off)
                {
                    bool earlyConfirmWasSuccess = false;
                    if (response != null && !string.IsNullOrEmpty(response.PayloadJson))
                    { try { var genericRespPayload = JsonConvert.DeserializeObject<GenericResponsePayload>(response.PayloadJson); if (genericRespPayload != null) earlyConfirmWasSuccess = genericRespPayload.Success; } catch {/* 무시 */} }
                    if(earlyConfirmWasSuccess)
                    {
                        _loggingService.UiInfo($"[{clientIp}] 조기 확인 응답 전송 완료. 실제 모니터 끄기 (백그라운드). ID: {request.PacketId}");
                        Task.Run(() => { try { LocalDeviceControl.SetMonitorState(MonitorAction.Off); _loggingService.UiInfo($"[{clientIp}] 실제 모니터 끄기 완료 (백그라운드). ID: {request.PacketId}"); } catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 백그라운드 모니터 끄기 오류. ID: {request.PacketId}", ex); }}); 
                    } else { _loggingService.UiWarn($"[{clientIp}] 모니터 끄기 조기 확인 실패 또는 페이로드 없어 실제 끄기 스킵. ID: {request.PacketId}"); }
                }
            }
        }
        
        private async Task<CommandPacket> ProcessCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiDebug($"[{clientIp}] 명령 처리 시작: {requestPacket.CommandName}, ID: {requestPacket.PacketId}");
            try
            {
                if (token.IsCancellationRequested) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 시작 전 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); token.ThrowIfCancellationRequested(); }
                switch (requestPacket.Instruction)
                {
                    case CommandInstruction.DirectExecute: return await ExecuteDirectCommandAsync(requestPacket, clientIp, token);
                    case CommandInstruction.RelayToTarget: return await RelayCommandAsync(requestPacket, clientIp, token); // 이 부분은 이전 답변 #31, #33 등 참조
                    default: _loggingService.UiWarn($"[{clientIp}] 알 수 없는 Instruction: {requestPacket.Instruction}, Packet ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, $"Unknown instruction: {requestPacket.Instruction}");
                }
            }
            catch (OperationCanceledException) { _loggingService.UiInfo($"[{clientIp}] 명령 처리 중 취소됨: {requestPacket.CommandName}, ID: {requestPacket.PacketId}"); return CreateErrorResponse(requestPacket, "Operation was canceled during command processing."); }
            catch (Exception ex) { _loggingService.UiError($"[{clientIp}] 명령 처리 중 오류: {requestPacket.CommandName}, ID: {requestPacket.PacketId}", ex); return CreateErrorResponse(requestPacket, $"Error processing command '{requestPacket.CommandName}': {ex.Message}"); }
        }

        private async Task<CommandPacket> ExecuteDirectCommandAsync(CommandPacket requestPacket, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 직접 실행 명령: {requestPacket.CommandName}");
            bool success = false; string message = "Command execution failed or not implemented."; CommandPacket responsePacketToReturn = null;
            try
            {
                token.ThrowIfCancellationRequested();
                switch (requestPacket.CommandName)
                {
                    case CommandNames.MonitorControl:
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "MonitorControl: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        MonitorControlPayload monitorPayload = null;
                        try { monitorPayload = JsonConvert.DeserializeObject<MonitorControlPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"MonitorControl: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (monitorPayload == null) { message = "MonitorControl: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        _loggingService.UiInfo($"[{clientIp}] 모니터 상태 변경 시도: {monitorPayload.Action}");
                        if (monitorPayload.Action == MonitorAction.Off)
                        { success = true; message = $"Monitor Off command acknowledged. Monitor will turn off shortly. Early confirm sent."; _loggingService.UiInfo($"[{clientIp}] {message} (ID: {requestPacket.PacketId})"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        else { LocalDeviceControl.SetMonitorState(monitorPayload.Action); success = true; message = $"Monitor state set to {monitorPayload.Action}."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message); }
                        break;
                    
                    case CommandNames.SetDisplayTimeout: 
                        if (string.IsNullOrEmpty(requestPacket.PayloadJson)) { message = "SetDisplayTimeout: PayloadJson missing."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        SetDisplayTimeoutPayload timeoutPayload = null; 
                        try { timeoutPayload = JsonConvert.DeserializeObject<SetDisplayTimeoutPayload>(requestPacket.PayloadJson); } catch (JsonException jsonEx) { message = $"SetDisplayTimeout: Payload JSON error - {jsonEx.Message}"; _loggingService.UiError($"[{clientIp}] {message}", jsonEx); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        if (timeoutPayload == null) { message = "SetDisplayTimeout: Payload deserialization null."; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break; }
                        _loggingService.UiInfo($"[{clientIp}] 디스플레이 타임아웃 설정 시도: {timeoutPayload.TimeoutMinutes}분");
                        try
                        {
                            string outputAc, errorAc, outputDc, errorDc; int exitCodeAc, exitCodeDc;
                            RunPowerCfgCommand($"/CHANGE DISPLAYTIMEOUTAC {timeoutPayload.TimeoutMinutes}", out outputAc, out errorAc, out exitCodeAc);
                            RunPowerCfgCommand($"/CHANGE DISPLAYTIMEOUTDC {timeoutPayload.TimeoutMinutes}", out outputDc, out errorDc, out exitCodeDc);
                            if (exitCodeAc == 0 && exitCodeDc == 0) { success = true; message = $"Display timeout set to {timeoutPayload.TimeoutMinutes} min for AC/DC."; _loggingService.UiInfo($"[{clientIp}] {message}"); }
                            else { success = false; message = $"Failed to set display timeout. AC ExitCode: {exitCodeAc}, DC ExitCode: {exitCodeDc}."; if (!string.IsNullOrEmpty(errorAc)) message += $"\nAC Err: {errorAc.Trim()}"; if (!string.IsNullOrEmpty(errorDc)) message += $"\nDC Err: {errorDc.Trim()}"; _loggingService.UiError($"[{clientIp}] {message}"); }
                        } catch (Exception ex) { success = false; message = $"Error executing powercfg: {ex.Message}"; _loggingService.UiError($"[{clientIp}] {message}", ex); }
                        responsePacketToReturn = CreateExecutionResponse(requestPacket, success, message);
                        break;
                        
                    default: message = $"Unknown direct command: {requestPacket.CommandName}"; _loggingService.UiWarn($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); break;
                }
            }
            catch (OperationCanceledException) { message = $"Direct command {requestPacket.CommandName} execution canceled."; _loggingService.UiInfo($"[{clientIp}] {message}"); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            catch (Exception ex) { message = $"Error executing direct command {requestPacket.CommandName}: {ex.Message}"; _loggingService.UiError($"[{clientIp}] {message}", ex); responsePacketToReturn = CreateExecutionResponse(requestPacket, false, message); }
            return responsePacketToReturn;
        }

        private void RunPowerCfgCommand(string arguments, out string output, out string error, out int exitCode)
        {
            output = string.Empty; error = string.Empty; exitCode = -1;
            try
            {
                ProcessStartInfo startInfo = new ProcessStartInfo("powercfg.exe") { Arguments = arguments, UseShellExecute = false, RedirectStandardOutput = true, RedirectStandardError = true, CreateNoWindow = true, Verb = "runas" }; // Verb = "runas" 추가
                using (Process process = Process.Start(startInfo))
                {
                    if (process == null) { error = "Failed to start powercfg.exe."; _loggingService.UiError(error); return; }
                    output = process.StandardOutput.ReadToEnd(); error = process.StandardError.ReadToEnd(); 
                    if (!process.WaitForExit(5000)) // WaitForExit에 타임아웃 추가
                    {
                         process.Kill(); error += "\npowercfg.exe process timed out and was killed."; 
                         _loggingService.UiWarn($"powercfg process for '{arguments}' timed out.");
                    }
                    exitCode = process.HasExited ? process.ExitCode : -99; // 타임아웃 시 임의의 종료 코드
                }
            } catch (Win32Exception w32Ex) { // "runas" 사용 시 권한 거부될 경우 발생 가능
                error = $"powercfg.exe Win32Exception (possibly UAC denied or not admin): {w32Ex.Message} (NativeErrorCode: {w32Ex.NativeErrorCode})"; 
                _loggingService.UiError(error, w32Ex); exitCode = w32Ex.NativeErrorCode; 
            } catch (Exception ex) { error = $"powercfg.exe exception: {ex.Message}"; _loggingService.UiError(error, ex); exitCode = -2; }
        }

        // RelayCommandAsync는 이전 답변 #33의 코드를 그대로 사용하시면 됩니다.
        // (매우 길어서 여기서는 생략합니다. 필요시 다시 요청해주세요.)
        private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
        {
            _loggingService.UiInfo($"[{clientIp}] 릴레이 명령: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
            // ... (이전 답변의 RelayCommandAsync 전체 로직) ...
            // 여기서는 예시로 간단히 에러 응답만 반환합니다. 실제 코드는 이전 답변을 참조하세요.
            await Task.Delay(100, token); // 비동기 메서드임을 나타내기 위한 임시 Delay
            return CreateErrorResponse(originalRelayRequest, "Relay functionality to be pasted from previous response.");
        }


        private CommandPacket CreateExecutionResponse(CommandPacket req, bool success, string msg, object data = null)
        {
            // 요청 패킷이 null일 수 있으므로 (예: JSON 파싱 실패 시 CreateErrorResponse에서 호출) null 체크 추가
            Guid packetIdToRespond = req?.PacketId ?? Guid.NewGuid(); // 요청 ID가 없으면 새 ID
            string commandNameToRespond = req?.CommandName ?? "UNKNOWN";

            return new CommandPacket {
                PacketId = packetIdToRespond, Instruction = CommandInstruction.DirectExecute, 
                CommandName = $"{commandNameToRespond}_Response", 
                PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = success, Message = msg, Data = data }),
                ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort
            };
        }
        private CommandPacket CreateErrorResponse(CommandPacket req, string errorMsg)
        {
            Guid pId = req?.PacketId ?? Guid.NewGuid(); 
            string cmdName = req?.CommandName ?? "UNKNOWN_COMMAND";
            _loggingService.UiError($"Error response for Packet ID {pId} (Cmd: {cmdName}): {errorMsg}");
            return new CommandPacket {
                PacketId = pId, Instruction = CommandInstruction.DirectExecute, 
                CommandName = $"{cmdName}_ErrorResponse", 
                PayloadJson = JsonConvert.SerializeObject(new GenericResponsePayload { Success = false, Message = errorMsg }),
                ResponseAddress = req?.ResponseAddress, ResponsePort = req?.ResponsePort
            };
        }
    }
}
주요 점검 포인트 및 설명:

RunPowerCfgCommand 메서드 내 Verb = "runas": ProcessStartInfo에 이 설정을 추가하면 powercfg.exe 실행 시 관리자 권한 상승을 시도합니다. SAgentM.App.exe 자체가 이미 관리자 권한으로 실행 중이라면 이 설정은 그대로 관리자 권한을 사용하게 하고, 아니라면 UAC 프롬프트를 띄울 수 있습니다 (서비스가 아닌 WPF 앱이므로 UAC 프롬프트 표시 가능).
Win32Exception 처리: RunPowerCfgCommand에서 Process.Start()가 실패할 경우 (특히 Verb="runas" 사용 시 UAC 거부 등) Win32Exception이 발생할 수 있으므로 해당 예외 처리를 추가했습니다.
process.WaitForExit() 타임아웃 추가: powercfg.exe가 응답하지 않는 경우를 대비해 타임아웃을 설정하고, 시간 초과 시 프로세스를 강제 종료하도록 수정했습니다.
CreateExecutionResponse 및 CreateErrorResponse의 Null 체크: requestPacket이 null일 수 있는 경우 (예: HandleClientAsync에서 JSON 역직렬화 실패 시 CreateErrorResponse 호출)를 대비하여 PacketId와 CommandName 접근 시 null 조건부 접근 또는 기본값을 사용하도록 수정했습니다.
JSON 역직렬화 (BOM 관련): Newtonsoft.Json은 일반적으로 UTF-8 BOM을 잘 처리합니다. 만약 "unexpected utf-8 bom" 메시지가 SAgentM.App의 JsonConvert.DeserializeObject 호출 시점에서 발생하는 것이 확실하다면, Flask (socket_client.py)에서 JSON 문자열을 encode('utf-8-sig') 대신 encode('utf-8')로 보내고 있는지 다시 한번 확인이 필요합니다 (현재 코드는 utf-8로 되어 있어 BOM을 보내지 않아야 정상입니다). StreamReader도 new StreamReader(stream, Encoding.UTF8, true, ...)로 BOM 자동 감지 및 UTF-8을 사용하고 있습니다.