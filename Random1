적으로 실행되는 함수 체인에서 AddFunc라는 함수가 void 리턴이며 체이닝처럼 기다렸다가 실행되도록** 구현하려면, 비동기 흐름을 제어할 수 있는 구조를 만들어야 합니다.

아래는 체이닝처럼 기다렸다가 AddFunc를 추가하고 실행하도록 구현하는 방법입니다.

1. TaskCompletionSource를 활용한 체이닝
TaskCompletionSource는 특정 작업의 완료를 기다릴 수 있도록 비동기 흐름을 제어합니다. 이를 이용해 AddFunc 호출이 완료된 후에만 새로운 작업을 추가하도록 할 수 있습니다.

코드 구현:
csharp
코드 복사
public class TaskModel
{
    private TaskCompletionSource<bool> _lastTaskCompletionSource = new TaskCompletionSource<bool>();

    // AddFunc 체이닝 메서드
    public void AddFunc(Func<Task> func)
    {
        // 이전 작업이 완료되기를 기다렸다가 실행
        var currentTaskCompletionSource = new TaskCompletionSource<bool>();
        _lastTaskCompletionSource.Task.ContinueWith(async _ =>
        {
            await func(); // 함수 실행
            currentTaskCompletionSource.SetResult(true); // 완료 표시
        });

        // 새 작업을 다음 체인에 연결
        _lastTaskCompletionSource = currentTaskCompletionSource;
    }

    // AddFunc 끝까지 실행
    public async Task WaitForCompletionAsync()
    {
        await _lastTaskCompletionSource.Task;
    }
}
사용 예:
csharp
코드 복사
var taskModel = new TaskModel();

// 첫 번째 함수 추가
taskModel.AddFunc(async () =>
{
    await Task.Delay(1000);
    Console.WriteLine("첫 번째 함수 완료");
});

// 두 번째 함수 추가
taskModel.AddFunc(async () =>
{
    await Task.Delay(2000);
    Console.WriteLine("두 번째 함수 완료");
});

// 세 번째 함수 추가
taskModel.AddFunc(async () =>
{
    await Task.Delay(500);
    Console.WriteLine("세 번째 함수 완료");
});

// 모든 함수가 실행 완료될 때까지 대기
await taskModel.WaitForCompletionAsync();
Console.WriteLine("모든 함수 실행 완료");
2. Queue를 사용한 체이닝 흐름 제어
동적으로 추가되는 함수가 실행 대기열(queue)에 쌓이고, 이전 함수가 완료될 때 다음 함수가 실행되도록 제어할 수 있습니다.

코드 구현:
csharp
코드 복사
using System.Collections.Concurrent;

public class TaskModel
{
    private ConcurrentQueue<Func<Task>> _taskQueue = new ConcurrentQueue<Func<Task>>();
    private bool _isExecuting = false;

    // AddFunc: 대기열에 함수 추가
    public void AddFunc(Func<Task> func)
    {
        _taskQueue.Enqueue(func);
        ExecuteQueue();
    }

    // 대기열 실행
    private async void ExecuteQueue()
    {
        if (_isExecuting) return; // 이미 실행 중인 경우 종료
        _isExecuting = true;

        while (_taskQueue.TryDequeue(out var func))
        {
            await func(); // 큐의 작업 실행
        }

        _isExecuting = false; // 실행 종료
    }
}
사용 예:
csharp
코드 복사
var taskModel = new TaskModel();

// AddFunc 호출
taskModel.AddFunc(async () =>
{
    await Task.Delay(1000);
    Console.WriteLine("첫 번째 함수 완료");
});

taskModel.AddFunc(async () =>
{
    await Task.Delay(2000);
    Console.WriteLine("두 번째 함수 완료");
});

taskModel.AddFunc(async () =>
{
    await Task.Delay(500);
    Console.WriteLine("세 번째 함수 완료");
});
3. await를 활용한 체이닝
async/await 키워드를 직접 사용하여 함수가 비동기적으로 실행되는 동안 다음 작업을 기다리는 체인을 구현할 수도 있습니다.

코드 구현:
csharp
코드 복사
public class TaskModel
{
    private Task _lastTask = Task.CompletedTask;

    // AddFunc: 체이닝
    public void AddFunc(Func<Task> func)
    {
        _lastTask = _lastTask.ContinueWith(async _ => await func()).Unwrap();
    }

    // 모든 작업이 완료될 때까지 대기
    public async Task WaitForCompletionAsync()
    {
        await _lastTask;
    }
}
사용 예:
csharp
코드 복사
var taskModel = new TaskModel();

// AddFunc 호출
taskModel.AddFunc(async () =>
{
    await Task.Delay(1000);
    Console.WriteLine("첫 번째 함수 완료");
});

taskModel.AddFunc(async () =>
{
    await Task.Delay(2000);
    Console.WriteLine("두 번째 함수 완료");
});

taskModel.AddFunc(async () =>
{
    await Task.Delay(500);
    Console.WriteLine("세 번째 함수 완료");
});

// 모든 작업이 완료될 때까지 대기
await taskModel.WaitForCompletionAsync();
Console.WriteLine("모든 함수 실행 완료");
4. 비교: 어떤 방식이 적합한가?
방식	장점	단점
TaskCompletionSource	간단한 체이닝 구현, 유연한 비동기 제어	작성 코드가 약간 길어질 수 있음
Queue 사용	큐 관리로 함수 실행 순서 명확	약간의 추가 리소스 사용
await 체이닝	자연스러운 비동기 흐름 구현	체인의 중단 및 관리가 어렵다
추천:

단순한 체이닝에는 TaskCompletionSource.
다양한 함수 대기열 관리에는 Queue.