SingleR 연결이 성공했지만 이미지 업데이트가 자동으로 이루어지지 않는 문제를 해결하려면, 업데이트 로직과 상태 관리에 대한 부분을 다시 한 번 점검해야 합니다.

MainActivity.kt
먼저, SingleR 이벤트가 수신되었을 때 selectedImage와 currentBitmap을 업데이트하는 로직이 제대로 작동하는지 확인합니다. updateImage 함수에서 상태를 업데이트할 때 반드시 UI 스레드에서 실행되도록 해야 합니다. 이를 위해 withContext(Dispatchers.Main)를 사용합니다.

또한, ImageDisplayScreen의 LaunchedEffect를 사용하여 isRefreshing 상태에 따라 이미지를 주기적으로 갱신하도록 합니다.

수정된 MainActivity.kt 코드
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.*
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import kotlin.concurrent.fixedRateTimer

class MainActivity : ComponentActivity() {
    private lateinit var hubConnection: HubConnection
    private var selectedImageTitle: String = ""
    private var selectedDatetime: String = ""
    private var selectedImage: Bitmap? = null
    private var currentBitmap: Bitmap? = null

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        Log.d("MainActivity", "onCreate called")
        setupSignalR()

        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
                    var isRefreshing by remember { mutableStateOf(false) }

                    LaunchedEffect(selectedImage) {
                        currentBitmap = selectedImage
                    }

                    ImageListScreen(
                        imageList = imageList,
                        selectedImage = selectedImage,
                        selectedImageTitle = selectedImageTitle,
                        selectedDatetime = selectedDatetime,
                        onFetchData = {
                            CoroutineScope(Dispatchers.IO).launch {
                                imageList = fetchDataFromDatabase()
                            }
                        },
                        onImageSelected = { imageTitle, datetime ->
                            selectedImageTitle = imageTitle
                            selectedDatetime = datetime
                            CoroutineScope(Dispatchers.IO).launch {
                                val image = fetchImageFromDatabase(imageTitle, datetime)
                                withContext(Dispatchers.Main) {
                                    selectedImage = image
                                    currentBitmap = image
                                }
                            }
                        },
                        onBack = {
                            selectedImage = null
                            currentBitmap = null
                        },
                        onFit = {
                            currentBitmap = selectedImage
                        },
                        currentBitmap = currentBitmap,
                        isRefreshing = isRefreshing,
                        onToggleRefresh = { isRefreshing = it }
                    )
                }
            }
        }
    }

    private fun setupSignalR() {
        Log.d("SignalR", "setupSignalR called")
        hubConnection = HubConnectionBuilder.create("https://yourserver/signalrhub").build()

        hubConnection.on("UpdateImage", { imageTitle: String, datetime: String ->
            Log.d("SignalR", "UpdateImage event received with title: $imageTitle and datetime: $datetime")
            if (imageTitle == selectedImageTitle && datetime == selectedDatetime) {
                CoroutineScope(Dispatchers.Main).launch {
                    updateImage(imageTitle, datetime)
                }
            }
        }, String::class.java, String::class.java)

        hubConnection.start()
            .doOnComplete {
                Log.d("SignalR", "Hub connection started successfully")
            }
            .doOnError { error ->
                Log.e("SignalR", "Error starting hub connection: ${error.message}")
            }
            .blockingAwait()
    }

    private suspend fun updateImage(imageTitle: String, datetime: String) {
        val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
        newBitmap?.let {
            Log.d("SignalR", "Image updated for title: $imageTitle and datetime: $datetime")
            withContext(Dispatchers.Main) {
                selectedImage = newBitmap
                currentBitmap = newBitmap
            }
        }
    }

    override fun onDestroy() {
        Log.d("SignalR", "onDestroy called")
        hubConnection.stop()
            .doOnComplete {
                Log.d("SignalR", "Hub connection stopped successfully")
            }
            .doOnError { error ->
                Log.e("SignalR", "Error stopping hub connection: ${error.message}")
            }
            .blockingAwait()
        super.onDestroy()
    }
}

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    currentBitmap: Bitmap?,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    Column {
        if (selectedImage == null) {
            Button(
                onClick = { onFetchData() },
                modifier = Modifier.padding(16.dp)
            ) {
                Text(if (imageList.isEmpty()) "Fetch Data" else "Reload Data")
            }
        }

        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            currentBitmap?.let { bitmap ->
                ImageDisplayScreen(
                    bitmap = bitmap,
                    imageTitle = selectedImageTitle,
                    datetime = selectedDatetime,
                    onBack = onBack,
                    onFit = onFit,
                    isRefreshing = isRefreshing,
                    onToggleRefresh = onToggleRefresh
                )
            }
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        currentBitmap = newBitmap
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        scale *= zoom
                        offset = Offset(offset.x + pan.x, offset.y + pan.y)
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            null
        }
    }
}
주요 변경 사항:
updateImage 함수: selectedImage와 currentBitmap을 동시에 업데이트하도록 수정했습니다.
상태 변경: selectedImage와 currentBitmap이 변경될 때 UI가 즉시 업데이트되도록 withContext(Dispatchers.Main)를 사용했습니다.
SignalR 이벤트 로그: 이벤트 수신 시 로그를 추가하여 업데이트를 확인할 수 있도록 했습니다.
이제 SingleR 이벤트가 수신되었을 때 selectedImage와 currentBitmap이 동시에 업데이트되고 UI가 즉시 변경된 이미지를 반영할 것입니다.






