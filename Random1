 명확히 이해하지 못한 점에 대해 사과드립니다. 이제 툴팁 대신에 **뷰박스(ViewBox)**를 사용하여 도형 앞에 글자를 표시하도록 하겠습니다. 즉, 각 도형 앞에 함수 이름을 배치하고, 이를 뷰박스로 감싸서 크기 조정이 가능하게 할 것입니다.

목표:
**ViewBox**를 사용하여 도형 앞에 함수 이름이 표시되도록 하고, 글자 크기를 조정할 수 있게 합니다.
FunctionNames 배열에 있는 함수 이름을 각 도형 앞에 표시합니다.
1. XAML 코드 수정 (뷰박스와 텍스트 추가)
xml
코드 복사
<ItemsControl ItemsSource="{Binding FunctionStatusColors}" AlternationCount="{Binding FunctionNames.Count}">
    <ItemsControl.ItemTemplate>
        <DataTemplate>
            <StackPanel Orientation="Horizontal" Margin="5">
                <!-- ViewBox를 사용하여 글자 크기 조정 -->
                <ViewBox Width="100" Height="30">
                    <TextBlock Text="{Binding DataContext.FunctionNames[ItemsControl.AlternationIndex], 
                                     RelativeSource={RelativeSource AncestorType=ItemsControl}}" 
                               VerticalAlignment="Center" HorizontalAlignment="Left"/>
                </ViewBox>

                <!-- 도형 (Ellipse) -->
                <Ellipse Width="30" Height="30" Fill="{Binding}" />
            </StackPanel>
        </DataTemplate>
    </ItemsControl.ItemTemplate>
</ItemsControl>
설명:
ViewBox: **TextBlock**을 **ViewBox**로 감싸서 글자 크기를 조정할 수 있습니다. **Width**와 **Height**를 설정해 줌으로써 글자의 크기를 자동으로 조절할 수 있게 합니다.
StackPanel: 도형과 텍스트를 가로로 나란히 배치하기 위해 **StackPanel**의 Orientation을 Horizontal로 설정합니다.
TextBlock.Text: 각 도형 앞에 표시할 함수 이름을 FunctionNames 배열에서 가져옵니다. **AlternationIndex**를 통해 각 도형에 맞는 함수 이름을 가져오게 됩니다.
Ellipse: 각 도형의 색상은 **FunctionStatusColors**를 통해 관리되고, 함수의 실행 상태에 따라 색상이 변경됩니다.
2. TaskModel.cs (변경 없음)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows;

public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수와 도형 상태 컬렉션
    public List<Func<Task>> FunctionTasks { get; set; } // 비동기 함수 리스트
    public ObservableCollection<string> FunctionNames { get; set; } // 함수 이름 리스트
    public ObservableCollection<Brush> FunctionStatusColors { get; set; } // 도형 상태 리스트

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }

    private TaskQueue _taskQueue;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;
        _taskQueue = taskQueue;

        // 리스트 초기화
        FunctionTasks = new List<Func<Task>>();
        FunctionNames = new ObservableCollection<string>();
        FunctionStatusColors = new ObservableCollection<Brush>();

        Status = "Pending";
        ResumeCommand = new RelayCommand(ResumeTask);

        // 함수 추가 (예시)
        AddFunction("Task A", ExecuteTaskA);
        AddFunction("Task B", ExecuteTaskB);
        AddFunction("Task C", ExecuteTaskC);
    }

    /// <summary>
    /// 함수를 추가하고 함수 이름과 도형 색상을 함께 관리합니다.
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task)
    {
        FunctionTasks.Add(task); // 함수 추가
        FunctionNames.Add(functionName); // 함수 이름 추가
        FunctionStatusColors.Add(Brushes.Gray); // 기본 도형 상태
    }

    /// <summary>
    /// 특정 행부터 작업을 재개하는 함수 (Resume 버튼 클릭 시 호출)
    /// </summary>
    public async void ResumeTask()
    {
        Status = "Running";  // 상태를 Running으로 변경
        _taskQueue.EnqueueTask(async () => await ExecuteTaskSequence());  // 작업을 큐에 등록
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        for (int i = 0; i < FunctionTasks.Count; i++)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[i] = Brushes.SkyBlue; // 실행 중
            });

            await FunctionTasks[i]();  // 비동기 작업 실행

            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[i] = Brushes.Green; // 완료됨
            });
        }
        Status = "Completed";
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}
결과:
각 도형 앞에 해당 함수 이름이 표시되고, ViewBox를 통해 글자의 크기가 조정됩니다.
도형은 여전히 FunctionStatusColors에 따라 상태를 나타내며, 해당 상태가 변경될 때마다 도형 색상이 바뀝니다.
이제 함수 이름을 도형 앞에 텍스트로 표시할 수 있고, 이를 ViewBox로 감싸서 크기 조절도 가능합니다.