겠습니다. 요청하신 프로토콜 형식에 맞게 코드를 수정하겠습니다. 여기서는 특정 **PLC 주소(DT 번지)**에 값을 쓰거나 읽을 때 %01#WDD02300023000100**처럼 프로토콜에 맞는 형식으로 명령을 만들어 전송합니다.

프로토콜 형식 설명:
%01#WDD02300023000100:
%01: 시작 구분자.
#WDD: 명령어 유형(쓰기 명령어).
023000: PLC 번지(예: DT2300번지).
0001: 전송할 값 (예: 1).
끝에 체크섬(**)은 각 명령의 끝에 붙는 체크섬 구분자입니다.
이제 이 프로토콜 형식을 기반으로 코드의 모든 읽기, 쓰기, 단순 전달을 처리하도록 수정하겠습니다.

전체 코드
1. MainWindow.xaml (UI 구성)
xml
코드 복사
<Window x:Class="PlcApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Mutocol 통신" Height="500" Width="700">
    <Grid>
        <StackPanel>
            <TextBlock Text="PLC 통신 테스트" FontSize="18" HorizontalAlignment="Center" Margin="10" />

            <!-- 응답 대기 체크박스 -->
            <CheckBox x:Name="ChkWaitForResponse" Content="응답 대기" Margin="10"/>

            <!-- 주소 입력 텍스트박스 -->
            <TextBlock Text="주소 입력 (DT번지 예: 2300):" Margin="5"/>
            <TextBox x:Name="TxtAddress" Width="200" Margin="5"/>

            <!-- 값 입력 텍스트박스 -->
            <TextBlock Text="값 입력:" Margin="5"/>
            <TextBox x:Name="TxtValue" Width="200" Margin="5"/>

            <!-- 읽기 버튼 -->
            <Button Content="읽기" Click="BtnRead_Click" Width="200" Height="40" Margin="5"/>

            <!-- 덮어쓰기 버튼 -->
            <Button Content="덮어쓰기" Click="BtnOverwrite_Click" Width="200" Height="40" Margin="5"/>

            <!-- 단순 전달 버튼 -->
            <Button Content="단순 전달" Click="BtnSendSimple_Click" Width="200" Height="40" Margin="5"/>

            <!-- 결과 이력 리스트박스 -->
            <ListBox x:Name="LstHistory" Width="400" Height="200" Margin="10"/>

            <!-- 결과 출력 -->
            <TextBlock x:Name="OutputText" Text="결과 출력:" FontSize="14" Margin="10" TextWrapping="Wrap"/>
        </StackPanel>
    </Grid>
</Window>
2. MainWindow.xaml.cs (C# 코드 - MainWindow 클래스)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows;

namespace PlcApp
{
    public partial class MainWindow : Window
    {
        private PlcMutocolCommunication _plc;

        public MainWindow()
        {
            InitializeComponent();
            _plc = new PlcMutocolCommunication("COM3", 9600); // 포트와 보드레이트 설정
        }

        // 읽기 버튼 클릭
        private async void BtnRead_Click(object sender, RoutedEventArgs e)
        {
            string address = TxtAddress.Text; // 텍스트박스에서 주소 가져옴
            bool waitForResponse = ChkWaitForResponse.IsChecked ?? false; // 체크박스에서 응답 대기 여부

            await ExecutePlcFunctionAsync(() => _plc.ReadAsync(address, waitForResponse), "읽기", address, "");
        }

        // 덮어쓰기 버튼 클릭
        private async void BtnOverwrite_Click(object sender, RoutedEventArgs e)
        {
            string address = TxtAddress.Text; // 텍스트박스에서 주소 가져옴
            string value = TxtValue.Text; // 텍스트박스에서 값 가져옴
            bool waitForResponse = ChkWaitForResponse.IsChecked ?? false; // 체크박스에서 응답 대기 여부

            await ExecutePlcFunctionAsync(() => _plc.OverwriteAsync(address, value, waitForResponse), "덮어쓰기", address, value);
        }

        // 단순 전달 버튼 클릭
        private async void BtnSendSimple_Click(object sender, RoutedEventArgs e)
        {
            string address = TxtAddress.Text; // 텍스트박스에서 주소 가져옴
            string value = TxtValue.Text; // 텍스트박스에서 값 가져옴
            bool waitForResponse = ChkWaitForResponse.IsChecked ?? false; // 체크박스에서 응답 대기 여부

            await ExecutePlcFunctionAsync(() => _plc.SendSimpleAsync(address, value, waitForResponse), "단순 전달", address, value);
        }

        // 공통적으로 사용할 비동기 함수 실행 로직
        private async Task ExecutePlcFunctionAsync(Func<Task<string>> plcFunc, string actionDescription, string address, string value)
        {
            try
            {
                _plc.OpenPort();
                string result = await plcFunc.Invoke();

                // 결과를 리스트박스에 추가
                string log = $"{actionDescription}: 주소={address}, 값={value}, 결과={result}";
                LstHistory.Items.Add(log);
                
                // 출력 텍스트 업데이트
                OutputText.Text = $"{actionDescription} 결과: {result}";
            }
            catch (Exception ex)
            {
                OutputText.Text = $"에러: {ex.Message}";
                LstHistory.Items.Add($"에러: {ex.Message}"); // 리스트박스에 에러도 기록
            }
            finally
            {
                _plc.ClosePort();
            }
        }
    }
}
3. PlcMutocolCommunication.cs (PLC 통신 클래스)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

public class PlcMutocolCommunication
{
    private SerialPort _serialPort;
    private const int _timeout = 30000; // 30초 타임아웃

    public PlcMutocolCommunication(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate);
        _serialPort.DataBits = 8;
        _serialPort.Parity = Parity.None;
        _serialPort.StopBits = StopBits.One;
        _serialPort.ReadTimeout = _timeout;
        _serialPort.WriteTimeout = _timeout;
    }

    public void OpenPort()
    {
        if (!_serialPort.IsOpen)
        {
            _serialPort.Open();
        }
    }

    public void ClosePort()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }

    // 1. 읽기 함수 (응답 대기 여부 선택)
    public async Task<string> ReadAsync(string address, bool waitForResponse)
    {
        string command = CreateReadCommand(address);
        await WriteCommandAsync(command);

        return waitForResponse ? await ReadResponseAsync() : "응답 없음 (대기 안 함)";
    }

    // 2. 덮어쓰기 함수 (응답 대기 여부 선택)
    public async Task<string> OverwriteAsync(string address, string value, bool waitForResponse)
    {
        string command = CreateWriteCommand(address, value);
        await WriteCommandAsync(command);

        string response = await ReadResponseAsync();
        return waitForResponse ? response.Contains("OK") ? "덮어쓰기 성공" : "덮어쓰기 실패" : "응답 없음 (대기 안 함)";
    }

    // 3. 단순 전달 함수 (응답 대기 여부 선택)
    public async Task<string> SendSimpleAsync(string address, string value, bool waitForResponse)
    {
        string command = CreateWriteCommand(address, value);
        await WriteCommandAsync(command);

        return waitForResponse ? await ReadResponseAsync() : "단순 전달 완료 (응답 없음)";
    }

    // 명령어 전송
    private async Task WriteCommandAsync(string command)
    {
        byte[] commandBytes = Encoding.ASCII.GetBytes(command);
        await _serialPort.BaseStream.WriteAsync(commandBytes, 0, commandBytes.Length);
    }

    // 응답 읽기
    private async Task<string> ReadResponseAsync()
    {
        byte[] buffer = new byte[256];
        int bytesRead = await _serialPort.BaseStream.ReadAsync(buffer, 0, buffer.Length);
        return Encoding.ASCII.GetString(buffer, 0, bytesRead);
    }

    // 명령어 생성 (쓰기)
    private string CreateWriteCommand(string address, string value)
    {
        // PLC 주소를 프로토콜에 맞는 형식으로 변환 (DT 번지 + 값)
        string plcAddress = FormatAddress(address);
        string formattedValue = FormatValue(value);
        
        // %01#WDD02300002300001**
        string command = $"%01#WDD{plcAddress}{plcAddress}{formattedValue}**";
        return command;
    }

    // 명령어 생성 (읽기)
    private string CreateReadCommand(string address)
    {
        // PLC 주소를 프로토콜에 맞는 형식으로 변환 (DT 번지)
        string plcAddress = FormatAddress(address);
        
        // %01#RDD023000**
        string command = $"%01#RDD{plcAddress}**";
        return command;
    }

    // 주소 형식 변환
    private string FormatAddress(string address)
    {
        if (int.TryParse(address, out int numericAddress))
        {
            return numericAddress.ToString("D6"); // 주소를 6자리로 변환 (예: 2300 -> 023000)
        }
        return "000000"; // 잘못된 주소일 경우 기본값
    }

    // 값 변환 함수 (숫자와 문자열 구분)
    private string FormatValue(string value)
    {
        // 값이 숫자인지 문자열인지 확인 후 프로토콜 형식에 맞게 변환
        if (int.TryParse(value, out int numericValue))
        {
            return numericValue.ToString("D4"); // 숫자인 경우 4자리로 변환 (예: 1 -> 0001)
        }
        else
        {
            return "0000"; // 잘못된 값일 경우 기본값
        }
    }
}
주요 변경 사항:
프로토콜 형식에 맞게 명령어를 생성:

쓰기 명령어는 %01#WDD주소주소값** 형식으로 생성되며, 주소와 값은 입력받은 값을 바탕으로 변환합니다.
읽기 명령어는 %01#RDD주소** 형식으로 생성됩니다.
주소 변환 및 값 변환 함수:

FormatAddress: 입력받은 주소(DT 번지)를 6자리 형식으로 변환합니다.
FormatValue: 입력받은 값을 4자리 형식으로 변환하여 프로토콜에 맞게 처리합니다.
사용자의 입력에 따라 명령어가 생성되고, 그 명령어를 PLC에 전송한 후, 응답을 처리합니다.

이렇게 하면, %01#WDD02300002300001** 형식으로 PLC에 명령어를 전송하고, 응답을 기다릴지 여부를 체크할 수 있습니다