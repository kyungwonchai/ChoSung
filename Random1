네, 죄송합니다. AuditLogInterceptor.cs 파일의 GetPrimaryKeyValue 메서드에서 오류가 발생했군요.

오류 원인:

DbEntityEntry 타입의 객체(entry)에는 직접적으로 Context 속성이 없습니다. DbContext 정보는 인터셉터 메서드(NonQueryExecuting 등)에 전달되는 DbCommandInterceptionContext 객체를 통해 얻어야 합니다. GetPrimaryKeyValue 헬퍼 메서드를 호출할 때 이 DbContext 정보를 함께 전달해야 합니다.

수정해야 할 파일 목록:

Infrastructure/AuditLogInterceptor.cs
아래는 이 문제를 수정한 AuditLogInterceptor.cs 파일 전체 코드(주석 제외)입니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using Newtonsoft.Json;
using System;
using System.Collections.Generic;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Infrastructure.Interception;
using System.Diagnostics;
using System.Linq;
using System.Data.Entity.Core.Objects; // ObjectContext 사용

namespace LockerManagementApp.Infrastructure
{
    public class AuditLogInterceptor : IDbCommandInterceptor
    {
        private static readonly JsonSerializerSettings jsonSettings = new JsonSerializerSettings
        {
            ReferenceLoopHandling = ReferenceLoopHandling.Ignore,
            PreserveReferencesHandling = PreserveReferencesHandling.None,
            Formatting = Formatting.None
        };
        private const string AuditLogEntriesKey = "AuditLogEntries_{0}"; // Context 해시코드 포함하여 고유 키 생성

        public void NonQueryExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            GenerateAuditLogs(interceptionContext);
        }
        public void NonQueryExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<int> interceptionContext)
        {
            SaveAuditLogs(interceptionContext);
        }

        public void ReaderExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ReaderExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<System.Data.Common.DbDataReader> interceptionContext) { }
        public void ScalarExecuting(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }
        public void ScalarExecuted(System.Data.Common.DbCommand command, DbCommandInterceptionContext<object> interceptionContext) { }


        private void GenerateAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            foreach (var context in interceptionContext.DbContexts)
            {
                if (context == null || !(context is DbContext dbContext) || !dbContext.ChangeTracker.HasChanges()) continue;

                string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
                var auditEntries = new List<AuditLog>();
                var changedEntries = dbContext.ChangeTracker.Entries()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified || e.State == EntityState.Deleted)
                    .ToList();

                if (!changedEntries.Any()) continue;

                Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavingChanges: Context '{dbContext.GetHashCode()}' 에서 {changedEntries.Count}개 변경 감지됨.");

                foreach (var entry in changedEntries)
                {
                    if (entry.Entity is AuditLog) continue;

                    var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = GetTableName(entry), Action = entry.State.ToString() };

                    // *** 수정: GetPrimaryKeyValue 호출 시 dbContext 전달 ***
                    try { auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext); }
                    catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }

                    var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();
                    if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                    else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                    else if (entry.State == EntityState.Modified) { bool hasChanges = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { hasChanges = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (hasChanges) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }
                    auditEntries.Add(auditEntry);
                    Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}");
                }
                UpdateLockerAssignmentTimestamps(changedEntries);

                if (auditEntries.Any())
                {
                    // Context별 고유 키 생성하여 UserState에 저장
                    string userStateKey = string.Format(AuditLogEntriesKey, dbContext.GetHashCode());
                    interceptionContext.UserState = auditEntries; // UserState는 하나만 저장 가능하므로 마지막 Context의 로그만 저장될 수 있음 -> 개선 필요 시 다른 방식 사용
                    Debug.WriteLine($"  -> Context '{dbContext.GetHashCode()}'의 로그 {auditEntries.Count}개를 UserState에 저장.");
                }
            }
        }


        private void SaveAuditLogs(DbCommandInterceptionContext<int> interceptionContext)
        {
            // UserState에서 로그 목록 가져오기
            if (interceptionContext.Exception == null && interceptionContext.UserState is List<AuditLog> auditEntries && auditEntries.Any())
            {
                try
                {
                    // 중요: 로그 저장을 위해 새 DbContext 사용 (무한 루프 방지)
                    using (var logContext = new Data.LockerDbContext())
                    {
                        Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: {auditEntries.Count}개 로그 저장 시도...");
                        logContext.AuditLogs.AddRange(auditEntries);
                        logContext.SaveChanges();
                        Debug.WriteLine($"  -> 로그 저장 완료.");
                    }
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 저장 실패 (Interceptor): {ex.ToString()}"); }
            }
            else if (interceptionContext.Exception != null) { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: 원본 SaveChanges 실패로 로그 저장 안 함. 오류: {interceptionContext.Exception.Message}"); }
            else { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] AuditLogInterceptor.SavedChanges: 저장할 로그 없음."); }

            // UserState 초기화 (선택 사항)
            interceptionContext.UserState = null;
        }


        private string GetTableName(DbEntityEntry entry) { return entry.Entity.GetType().Name; }

        /// <summary>
        /// 엔티티의 기본 키 값 가져오기 (DbContext 전달받도록 수정)
        /// </summary>
        private string GetPrimaryKeyValue(DbEntityEntry entry, DbContext context) // *** 수정: DbContext 파라미터 추가 ***
        {
            try
            {
                // *** 수정: 전달받은 context 사용 ***
                var objectContext = ((IObjectContextAdapter)context).ObjectContext;
                var objectStateEntry = objectContext.ObjectStateManager.GetObjectStateEntry(entry.Entity);

                if (objectStateEntry.EntityKey.EntityKeyValues != null && objectStateEntry.EntityKey.EntityKeyValues.Length > 0)
                {
                    return string.Join(",", objectStateEntry.EntityKey.EntityKeyValues.Select(kv => kv.Value));
                }
                if (entry.State == EntityState.Added) return "New"; // Added 상태는 키 없음
            }
            catch (Exception ex) { Debug.WriteLine($"GetPrimaryKeyValue 오류: {ex.Message}"); }
            return "N/A";
        }

        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps (Interceptor): {count}개 LockerAssignment 타임스탬프 업데이트됨."); }
    }
}
핵심 변경 사항:

GetPrimaryKeyValue 메서드:
매개변수로 DbContext context를 추가했습니다.
내부에서 ObjectContext를 가져올 때 entry.Context 대신 전달받은 context를 사용하도록 수정했습니다: var objectContext = ((IObjectContextAdapter)context).ObjectContext;
GenerateAuditLogs 메서드:
GetPrimaryKeyValue 메서드를 호출할 때 현재 루프의 dbContext 인스턴스를 함께 전달하도록 수정했습니다: auditEntry.RecordId = GetPrimaryKeyValue(entry, dbContext);