지하려는 창이 화면 가운데에 떠 있으며, Y 방향 150 이상에 위치해 있다고 했으므로 다음과 같은 조건을 추가해야 합니다.

기존 감지 조건 (Width > 50, Height > 50)
새로운 감지 조건
창의 y 좌표가 150보다 커야 함 (rect.Y > 150)
창이 화면 가운데에 위치해야 함 (rect.X가 화면 중심 근처)
2. 수정된 코드 (Form1.cs)
csharp
코드 복사
using System;
using System.Drawing;
using System.IO;
using System.Windows.Forms;
using OpenCvSharp;
using OpenCvSharp.Extensions;

namespace WinFormsOpenCv
{
    public partial class Form1 : Form
    {
        public Form1()
        {
            InitializeComponent();
            pictureBox1.SizeMode = PictureBoxSizeMode.StretchImage; // 이미지 맞추기
        }

        // 버튼 클릭 시 실행
        private void btnProcess_Click(object sender, EventArgs e)
        {
            // 화면 캡처
            Bitmap screenshot = CaptureScreen();

            // OpenCV Mat 변환 및 이진화 적용
            Mat matImage = BitmapConverter.ToMat(screenshot);
            Mat gray = new Mat();
            Cv2.CvtColor(matImage, gray, ColorConversionCodes.BGR2GRAY);
            Mat binary = new Mat();
            Cv2.Threshold(gray, binary, 200, 255, ThresholdTypes.Binary);

            // 창 감지
            Rect detectedWindow = DetectWindow(binary);

            if (detectedWindow != Rect.Empty)
            {
                // 우측 상단 기준 좌표에서 x -10, y -10 지점 클릭
                int clickX = detectedWindow.Right - 10;
                int clickY = detectedWindow.Top - 10;
                Cursor.Position = new System.Drawing.Point(clickX, clickY);
                mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);

                Console.WriteLine($"닫기 버튼 클릭: ({clickX}, {clickY})");
            }
            else
            {
                Console.WriteLine("해당 조건의 창을 찾을 수 없습니다.");
            }

            // PictureBox에 표시
            pictureBox1.Image = ConvertMatToBitmap(binary);
            pictureBox1.Refresh();
        }

        // 화면 캡처 함수 (전체 화면 캡처)
        private Bitmap CaptureScreen()
        {
            Rectangle bounds = Screen.PrimaryScreen.Bounds;
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);
            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(Point.Empty, Point.Empty, bounds.Size);
            }
            return bitmap;
        }

        // Mat → Bitmap 변환 함수
        private Bitmap ConvertMatToBitmap(Mat mat)
        {
            return BitmapConverter.ToBitmap(mat);
        }

        // 창 감지 함수
        private Rect DetectWindow(Mat binary)
        {
            // 컨투어 찾기
            Cv2.FindContours(binary, out OpenCvSharp.Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

            Rect detectedWindow = Rect.Empty;
            int screenWidth = Screen.PrimaryScreen.Bounds.Width;
            int screenCenterX = screenWidth / 2;
            double maxArea = 0;

            foreach (var contour in contours)
            {
                Rect rect = Cv2.BoundingRect(contour);
                double area = rect.Width * rect.Height;

                // 창 감지 조건 (너무 작은 것 제외, 화면 중앙, y > 150)
                if (rect.Width > 100 && rect.Height > 50 && rect.Y > 150 && 
                    Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 200 && area > maxArea)
                {
                    maxArea = area;
                    detectedWindow = rect;
                }
            }

            return detectedWindow;
        }

        // 마우스 클릭을 위한 WinAPI
        [DllImport("user32.dll", SetLastError = true)]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;
    }
}
3. 주요 변경점
✅ 1) 창 감지 조건 추가 (DetectWindow 함수)
csharp
코드 복사
if (rect.Width > 100 && rect.Height > 50 && rect.Y > 150 && 
    Math.Abs(rect.X + rect.Width / 2 - screenCenterX) < 200 && area > maxArea)
너무 작은 창 제외 (Width > 100, Height > 50)
화면 중앙에 있는지 확인 (rect.X가 화면 중심과 ±200px 이내)
창의 y 좌표가 150보다 큰지 확인 (rect.Y > 150)
✅ 2) 감지된 창의 닫기 버튼 클릭 (btnProcess_Click)
csharp
코드 복사
int clickX = detectedWindow.Right - 10;
int clickY = detectedWindow.Top - 10;
Cursor.Position = new System.Drawing.Point(clickX, clickY);
mouse_event(MOUSEEVENTF_LEFTDOWN | MOUSEEVENTF_LEFTUP, clickX, clickY, 0, IntPtr.Zero);
감지된 창의 우측 상단에서 (x-10, y-10)을 클릭하여 닫기 버튼 클릭 수행.
4. 실행 결과
"이진화 적용" 버튼 클릭
화면에서 중앙에 위치하며 Y 좌표가 150 이상인 창을 감지
감지된 창의 닫기 버튼 위치 (x-10, y-10)를 클릭
PictureBox에 감지된 이진화 이미지 표시
해당 창이 자동으로 닫힘
✅ 이제 원하는 조건의 창을 정확하게 감지하고 자동으로 닫을 수 있음! 🚀




