UI 비동기 처리가 필요하므로, 메시지 전송과 수신을 비동기로 처리하고 UI 스레드를 차단하지 않도록 개선하겠습니다. 여기서는 async와 await를 사용해 비동기 처리를 구현하고, UI 업데이트는 WPF의 Dispatcher를 이용하여 안전하게 비동기 작업 후 UI를 갱신하도록 하겠습니다.

1. MainViewModel 개선 (비동기 처리 추가)
SendMessage 메서드를 비동기로 수정하여, UI 스레드가 차단되지 않도록 합니다.

MainViewModel.cs (수정)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.Threading.Tasks;

public class MainViewModel : ViewModelBase
{
    private readonly SocketClient _socketClient;
    public ObservableCollection<string> Messages { get; set; } // ListBox에 바인딩할 메시지 리스트
    public string InputText { get; set; } // TextBox에서 입력받은 텍스트

    public ICommand SendCommand { get; set; } // 전송 버튼에 바인딩할 커맨드

    public MainViewModel()
    {
        Messages = new ObservableCollection<string>();
        _socketClient = new SocketClient("10.22.22.22", 2400, Messages);

        SendCommand = new RelayCommand(async (parameter) => await SendMessageAsync());
    }

    private async Task SendMessageAsync()
    {
        if (!string.IsNullOrWhiteSpace(InputText))
        {
            await _socketClient.SendMessageAsync(InputText); // 비동기 송신
            InputText = string.Empty;
        }
    }
}
2. SocketClient 비동기 처리
SocketClient의 모든 네트워크 관련 작업을 비동기로 처리하고, UI 스레드를 차단하지 않도록 async/await 패턴을 적용합니다. UI 업데이트는 WPF의 Dispatcher를 통해 안전하게 처리합니다.

SocketClient.cs (수정)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Windows.Threading;

public class SocketClient
{
    private readonly string _ip;
    private readonly int _port;
    private TcpClient _client;
    private NetworkStream _stream;
    private readonly ObservableCollection<string> _messages;
    private bool _isConnected;
    private readonly Dispatcher _dispatcher;

    public SocketClient(string ip, int port, ObservableCollection<string> messages)
    {
        _ip = ip;
        _port = port;
        _messages = messages;
        _dispatcher = Dispatcher.CurrentDispatcher; // UI 스레드 Dispatcher 가져오기
        Connect();
    }

    private async void Connect()
    {
        while (!_isConnected)
        {
            try
            {
                _client = new TcpClient();
                await _client.ConnectAsync(_ip, _port);
                _stream = _client.GetStream();
                _isConnected = true;
                AddMessageToUI("Connected to server.");

                await StartReceivingAsync(); // 비동기 수신 시작
            }
            catch (Exception ex)
            {
                AddMessageToUI($"Connection failed: {ex.Message}");
                await Task.Delay(5000); // 5초 후 재시도
            }
        }
    }

    public async Task SendMessageAsync(string message)
    {
        if (_isConnected)
        {
            try
            {
                byte[] data = Encoding.ASCII.GetBytes($"\x02{message}\x03"); // STX와 ETX로 감싸서 송신
                await _stream.WriteAsync(data, 0, data.Length); // 비동기로 송신
                AddMessageToUI($"Sent: {message}");
            }
            catch (Exception ex)
            {
                AddMessageToUI($"Send failed: {ex.Message}");
            }
        }
        else
        {
            AddMessageToUI("Not connected to the server.");
        }
    }

    private async Task StartReceivingAsync()
    {
        byte[] buffer = new byte[1024];
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(buffer, 0, buffer.Length); // 비동기로 수신
                if (bytesRead > 0)
                {
                    string response = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    string extractedMessage = ExtractMessage(response); // STX와 ETX 사이의 메시지 추출
                    AddMessageToUI($"Received: {extractedMessage}");
                }
            }
            catch (Exception ex)
            {
                AddMessageToUI($"Receive failed: {ex.Message}");
                _isConnected = false;
                _client.Close();
                Connect(); // 연결 재시도
            }
        }
    }

    private string ExtractMessage(string response)
    {
        // STX(시작 문자, '\x02')와 ETX(종료 문자, '\x03') 사이의 텍스트 추출
        int stxIndex = response.IndexOf('\x02');
        int etxIndex = response.IndexOf('\x03');
        if (stxIndex >= 0 && etxIndex > stxIndex)
        {
            return response.Substring(stxIndex + 1, etxIndex - stxIndex - 1);
        }
        return "Invalid response format";
    }

    // UI 스레드에서 안전하게 메시지 추가
    private void AddMessageToUI(string message)
    {
        _dispatcher.Invoke(() => _messages.Add(message));
    }
}
3. Dispatcher를 이용한 UI 업데이트
Dispatcher를 사용하여 다른 스레드에서 UI에 접근할 때 발생하는 문제를 해결합니다.
네트워크 작업은 UI 스레드와 분리되어 실행되며, Dispatcher.Invoke를 통해 UI가 안전하게 업데이트됩니다.
4. XAML 유지
기존 XAML 코드에서는 변경이 필요하지 않습니다. UI 요소들은 그대로 두되, 비동기로 작업을 처리하면서 UI는 원활하게 작동하게 됩니다.

주요 개선 사항 요약
비동기 처리: SendMessageAsync, StartReceivingAsync 메서드를 비동기로 처리하여 네트워크 작업 동안 UI 스레드가 차단되지 않도록 했습니다.