는 것도 가능합니다. 하지만, WPF에서는 Bitmap 형식의 이미지를 직접 Image 컨트롤에 할당할 수 없으므로, 메모리에 있는 Bitmap을 BitmapImage로 변환해야 합니다. 이를 위해서는 메모리 스트림을 사용합니다.

아래 코드는 워터마크를 추가하고, 그 결과를 직접 Image 컨트롤에 업데이트하는 방법을 보여줍니다:

csharp
Copy code
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.IO;
using System.Windows;
using System.Windows.Media.Imaging;

private void UpdateImageWithWatermark()
{
    string watermarkText = "변수 ABC의 값"; // 워터마크 텍스트
    string imagePath = "path/to/your/image.jpg"; // 원본 이미지 경로

    Bitmap bitmap = new Bitmap(imagePath);
    using (Graphics graphics = Graphics.FromImage(bitmap))
    {
        // 워터마크 그리기 로직 동일...
    }

    // Bitmap을 BitmapImage로 변환
    BitmapImage bitmapImage = ConvertBitmapToBitmapImage(bitmap);

    // 이미지 컨트롤 업데이트
    imageControl.Source = bitmapImage;
}

private BitmapImage ConvertBitmapToBitmapImage(Bitmap bitmap)
{
    using (MemoryStream memory = new MemoryStream())
    {
        bitmap.Save(memory, ImageFormat.Bmp);
        memory.Position = 0;
        BitmapImage bitmapImage = new BitmapImage();
        bitmapImage.BeginInit();
        bitmapImage.StreamSource = memory;
        bitmapImage.CacheOption = BitmapCacheOption.OnLoad;
        bitmapImage.EndInit();
        bitmapImage.Freeze(); // WPF에서 사용하기 위해 필요
합니다.
return bitmapImage;
}
}

go
Copy code

이 코드는 워터마크를 추가한 후, `Bitmap`을 `BitmapImage`로 변환하고, 이를 `Image` 컨트롤의 `Source`로 설정합니다. `BitmapImage`로 변환하기 위해 `MemoryStream`을 사용하고, 이미지를 메모리에 저장한 후 이를 읽어서 `BitmapImage`로 변환합니다.

`Freeze` 메소드는 WPF에서 UI 스레드 외부에서 생성된 오브젝트를 UI 스레드에서 사용할 수 있도록 만드는 데 사용됩니다. 이는 멀티스레딩 환경에서 중요한 부분입니다.

이 방법으로 이미지를 저장하지 않고 바로 `Imag