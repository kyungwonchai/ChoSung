 예시는 “QR 문자열을 입력하면, 기존에 학습(저장)된 (모델명, QR) 데이터 중 가장 유사한(편집거리 최소) QR을 찾아 해당 모델명을 예측”하는 아주 기초적인 예시 코드입니다.

실제 현업에서는 딥러닝(예: RNN, BERT 등 자연어처리 기반), 머신러닝(예: TF-IDF + 분류기 등), 혹은 그 외 다양한 고급 기법을 씁니다. 그러나 여기서는 “절대 내장함수를 쓰지 말고, 임포트도 하지 말고, 재귀함수도 쓰지 말고, BFS/DP/해시 등을 적극적으로 사용하라” 라는 제약이 있기 때문에, 다음과 같은 간단한 DP(동적 계획법) 기반 문자열 유사도(편집거리: Levenshtein Distance) 방식을 예시로 보여 드립니다.

주의:

파이썬에서 len, range, append, try-except 등도 내부적으로는 빌트인 기능입니다만, 여기서는 엄격한 알고리즘 테스트 상황을 가정하고(“가능한 빌트인 함수를 최소화 혹은 거의 사용하지 말라” 정도로 이해) 작성했습니다.
정말로 아무 빌트인도 전혀 안 쓰려면, 문자열의 길이조차도 try-except를 이용하여 직접 구해야 하고, 리스트에 값을 넣을 때도 인덱스로 일일이 처리해야 합니다. 여기서는 그 과정을 최대한 직접 구현하는 방향을 보여 드리지만, try-except와 기본 타입(list, index 접근 등)을 최소로 사용했습니다.
실제로 이렇게까지 구현하는 일은 매우 극단적인 알고리즘 테스트가 아니라면 드물며, 이해를 돕기 위한 참고용 예시 코드임을 양해 바랍니다.
아이디어 요약
**훈련 데이터(모델명, QR)**를 저장해둔다.

예: train_data = [("ModelA", "QR_ABC"), ("ModelB", "QR_XYZ"), ... ]
DP를 이용한 편집 거리(Edit Distance) 계산 함수를 만든다.

두 문자열 s1, s2가 주어졌을 때, 한 문자를 삽입·삭제·교체하는 최솟값 횟수를 구한다.
편집거리가 작을수록 두 문자열이 유사하다고 판단한다.
새로운 QR이 입력되면, 위의 편집 거리 함수를 사용하여

훈련 데이터에 있는 모든 (모델명, QR) 쌍에 대해 거리를 계산
가장 거리(=유사도가 높은) 작은 쪽의 모델명을 예측 결과로 반환
해시/DP/BFS 활용

핵심 로직은 DP(편집 거리)이다.
해시는 문자열을 빠르게 조회하거나 중복검사를 할 때 쓰일 수 있지만, 여기서는 편집거리를 구하는 로직으로 충분하다.
BFS는 문자열을 점진적으로 변환해가며 최단 변환 과정을 찾는 방식(=편집거리)을 그래프 탐색으로 볼 수도 있으나, 이 역시 일반적으로는 DP가 계산 속도가 더 빠르므로 DP 방식을 직접 구현한다.
예시 코드
아래 코드는 이해를 돕기 위해 한글 주석을 매우 상세하게 달았습니다.
(실무에선 이렇게 과도하게 주석 달 일은 드뭅니다.)

python
코드 복사
# -------------------------------------------------------------
# 1) 문자열 길이를 직접 구하기 위한 함수 (len 미사용 예시)
#    - 인덱스로 하나씩 접근 시도 -> 실패 시 길이를 알 수 있음
#    - try ~ except 를 쓰는 것도 내장기능이긴 하지만,
#      여기서는 index out of range를 잡기 위해 최소한으로만 활용.
# -------------------------------------------------------------
def my_str_length(s):
    count = 0
    while True:
        try:
            temp = s[count]  # count 인덱스 접근 시도
            count = count + 1
        except:
            # 인덱스 접근 실패 -> 길이에 도달했다는 뜻
            break
    return count

# -------------------------------------------------------------
# 2) 2차원 리스트를 생성하는 함수 (append 등 최소 사용)
#    - Python 기본 리스트 기능 말고는 import/built-in 없이 만듦
#    - 'rows x cols' 크기의 2차원 배열을 생성하여 0으로 초기화
# -------------------------------------------------------------
def create_2d_array(rows, cols):
    # rows, cols 만큼 0으로 초기화된 2차원 배열 생성
    result = []
    r = 0
    while r < rows:
        row_list = []
        c = 0
        while c < cols:
            row_list = row_list + [0]  # 파이썬 list + [값] 형태로 확장
            c = c + 1
        result = result + [row_list]
        r = r + 1
    return result

# -------------------------------------------------------------
# 3) 편집거리(Levenshtein Distance) 계산을 위한 DP 함수 (비재귀)
#    - s1, s2: 문자열 (QR이라 가정)
#    - 동적 계획법(DP) 테이블을 직접 구성해서 편집거리를 구한다.
#      편집거리 = 한 문자를 삽입/삭제/교체해서 같게 만드는 최소 횟수
#
#    * 점화식(전형적인 Levenshtein Distance):
#      D[i][j] = min(
#         D[i-1][j] + 1,    (문자 하나 삭제)
#         D[i][j-1] + 1,    (문자 하나 삽입)
#         D[i-1][j-1] 
#            + (두 문자가 다르면 1, 같으면 0)   (교체 or 그대로)
#      )
#
#    * 인덱스(파이썬은 0부터 시작) 주의:
#      D[i][0], D[0][j] 초기값도 설정 필요
# -------------------------------------------------------------
def edit_distance(s1, s2):
    len_s1 = my_str_length(s1)
    len_s2 = my_str_length(s2)
    
    # DP 테이블 생성 (크기: (len_s1+1) x (len_s2+1))
    dp = create_2d_array(len_s1 + 1, len_s2 + 1)
    
    # 초기값 채우기
    # dp[i][0] = i
    i = 0
    while i <= len_s1:
        dp[i][0] = i
        i = i + 1
    
    # dp[0][j] = j
    j = 0
    while j <= len_s2:
        dp[0][j] = j
        j = j + 1

    # 편집거리 DP 테이블 채우기(이중 반복)
    i = 1
    while i <= len_s1:
        j = 1
        while j <= len_s2:
            # 현재 s1의 i-1 위치 문자, s2의 j-1 위치 문자 비교
            # (파이썬 인덱스는 0부터 시작이므로)
            if s1[i-1] == s2[j-1]:
                cost = 0  # 같은 문자라면 교체 비용 0
            else:
                cost = 1  # 다른 문자라면 교체 비용 1
            
            # dp 점화식 적용
            # 삭제(delete) = dp[i-1][j] + 1
            # 삽입(insert) = dp[i][j-1] + 1
            # 교체(replace) = dp[i-1][j-1] + cost (문자가 다르면 +1)
            del_cost = dp[i-1][j] + 1
            ins_cost = dp[i][j-1] + 1
            rep_cost = dp[i-1][j-1] + cost

            # 셋 중 최솟값을 dp[i][j]에 대입
            min_val = del_cost
            if ins_cost < min_val:
                min_val = ins_cost
            if rep_cost < min_val:
                min_val = rep_cost
            
            dp[i][j] = min_val

            j = j + 1
        i = i + 1

    # 최종 편집거리 = dp[len_s1][len_s2] 값
    return dp[len_s1][len_s2]

# -------------------------------------------------------------
# 4) (모델명, QR) 훈련 데이터를 바탕으로
#    "가장 유사한 모델"을 찾는 함수 (1-NN 방식)
#    - 입력: test_qr (새로 들어온 QR 문자열)
#    - 출력: 가장 가까운(편집거리 최소) 모델명
# -------------------------------------------------------------
def predict_model(train_data, test_qr):
    # train_data: [ (model1, qr1), (model2, qr2), ... ]
    
    best_model = None
    best_distance = 999999999  # 매우 큰 수로 초기화
    
    idx = 0
    # train_data 길이를 직접 얻어오기 위해 my_str_length를 응용 (리스트도 일일이 접근)
    # 여기서는 예제라 간단히 "while idx < list 길이" 식으로 돌려야 하므로,
    # 별도의 my_list_length 함수를 만들 수도 있지만, 예시에선 편의상 직접 try로 작성.
    while True:
        try:
            pair = train_data[idx]  # (모델명, QR)
            current_model = pair[0]
            current_qr = pair[1]
            
            # 편집거리 계산
            dist = edit_distance(current_qr, test_qr)
            
            # 최소 거리 갱신 확인
            if dist < best_distance:
                best_distance = dist
                best_model = current_model
            
            idx = idx + 1
        
        except:
            # 인덱스 초과로 train_data의 끝에 도달하면 반복 종료
            break
    
    return best_model

# -------------------------------------------------------------
# 아래는 실제 사용 예시
# -------------------------------------------------------------
def main():
    # 1) 훈련 데이터 준비 (예시)
    #    실제로는 CSV로부터 읽어오거나 하는 과정이 필요하지만,
    #    여기서는 하드코딩 예시
    train_data = [
        ("ModelA", "QRAAA111"),
        ("ModelB", "QRBBB222"),
        ("ModelC", "QRC-XYZ"),
        ("ModelD", "QRDDDDDD")
    ]
    
    # 2) 예측할 QR 입력(예시)
    #    여기서는 코드 내 하드코딩, 실제론 input() 등으로 받을 수 있음
    new_qr = "QRABB122"  
    
    # 3) 예측 실행
    result = predict_model(train_data, new_qr)
    
    # 4) 결과 출력
    #    (내장 print 자체도 사용을 제한한다고 하면, 파일에 쓰거나 하는 별도 방식 필요하겠지만
    #     여기서는 간단히 print로 예시합니다.)
    print("입력된 QR:", new_qr)
    print("예측된 모델명:", result)

# 메인 실행 예시
main()
코드 동작 원리
my_str_length(s)

문자열 s에 대해, 인덱스가 넘어가면 예외가 발생한다는 점을 이용하여 길이를 구한다.
빌트인 len(s)를 쓰는 대신 이렇게 수작업으로 길이를 구했다.
create_2d_array(rows, cols)

2차원 리스트를 직접 만들기 위해, while문을 돌며 [0] 등을 붙여서 확장한다.
append도 빌트인이므로 사용하지 않고 리스트 + [값] 방식을 썼다.
edit_distance(s1, s2)

문자열 s1, s2에 대한 편집거리(Levenshtein Distance)를 DP로 계산한다.
재귀함수 없이, 이중 while문으로 DP 테이블을 채운다.
최종적으로 dp[len_s1][len_s2] 값이 편집거리.
predict_model(train_data, test_qr)

훈련 데이터의 모든 (모델, QR)에 대해 edit_distance(기존QR, test_qr)를 구한다.
최소 거리인 모델을 찾아 반환한다.
main()

예시 훈련 데이터를 준비하고,
예측할 새 QR 문자열 new_qr를 집어넣어서 결과 모델명을 출력한다.
이런 방식의 한계와 확장
한계

문자열 기반의 거리(편집거리)만 가지고 모델명을 예측하므로, 데이터가 많아질수록 속도가 느려질 수 있다. (O(N * 길이1 * 길이2))
딥러닝/머신러닝 기법(예: 임베딩, RNN, CNN, Transformer 등)을 사용하면 더 정교하게 학습 가능.
하지만 질문에서 “내장함수, 임포트 없이, BFS나 DP, 해시로 구현”을 강조하여, 이론적으로는 이렇게도 할 수 있다는 예시를 보여준 것임.
확장

(딥러닝) 임베딩 벡터로 변환 후 유사도를 코사인 거리 등으로 계산 -> 분류 모델(MLP, CNN, RNN, Transformer 등) 훈련
(머신러닝) TF-IDF, n-gram 벡터화 -> SVM/Logistic Regression/RandomForest 등
(실무) QR 코드가 규칙적으로 생성된다면, 정규식(Regex)나 일부 파싱 로직, 혹은 DB와 매핑 테이블을 사용하는 간단한 방식이 더 정확하고 빠를 수 있음.
결론
위 코드는 **“QR 문자열 -> 모델명”**을 매우 단순하게 편집거리 최소 기준으로 찾는 1-NN(Nearest Neighbor) 분류 예시입니다.
내장 라이브러리를 전혀 쓰지 않고(거의) 직접 구현하라는 극단적 제약 때문에 다소 비효율적으로 보이지만,
핵심 아이디어인 “두 문자열이 얼마나 가까운지(=편집거리) 계산하고, 그중 최솟값을 갖는 모델을 선택한다”라는 점은 이해에 도움이 될 것입니다.