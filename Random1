미지를 캡처해서 실시간으로 처리하려면 ScreenCapture 기능을 사용하여 데스크톱의 특정 영역 또는 전체 화면을 캡처한 후 OpenCV로 분석해야 합니다. 아래는 캡처와 분석을 통합한 코드입니다.

전체 코드
csharp
코드 복사
using OpenCvSharp;
using System;
using System.Drawing;
using System.Drawing.Imaging;
using System.Linq;
using System.Threading;
using System.Windows.Forms;

public partial class MainForm : Form
{
    private int clickAttempts = 10; // 최대 클릭 시도 횟수

    public MainForm()
    {
        InitializeComponent();
    }

    private void StartProcess()
    {
        for (int attempt = 0; attempt < clickAttempts; attempt++)
        {
            using (var screenshot = CaptureScreen())
            {
                using (var mat = OpenCvSharp.Extensions.BitmapConverter.ToMat(screenshot))
                {
                    // 900,200의 RGB 값 확인
                    var rgbValue = GetPixelRgb(mat, 900, 200);
                    if (rgbValue.All(c => c > 30))
                    {
                        Console.WriteLine("조건 위배: (900,200) 픽셀이 어두운 색상이 아님");
                        break;
                    }

                    // 흰색 사각형 탐지
                    var topRight = DetectWhiteRectangle(mat);
                    if (topRight == null)
                    {
                        Console.WriteLine("흰색 사각형을 찾지 못했습니다.");
                        break;
                    }

                    // 우측 상단 좌표에서 (x - 15, y - 15) 계산
                    var targetX = topRight.Value.X - 15;
                    var targetY = topRight.Value.Y - 15;

                    // 클릭 동작
                    Close(targetX, targetY);
                    Console.WriteLine($"클릭: ({targetX}, {targetY})");

                    // 5초 대기
                    Thread.Sleep(5000);
                }
            }
        }
    }

    private Bitmap CaptureScreen()
    {
        // 전체 화면 캡처
        var screenBounds = Screen.PrimaryScreen.Bounds;
        var bitmap = new Bitmap(screenBounds.Width, screenBounds.Height, PixelFormat.Format32bppArgb);

        using (var g = Graphics.FromImage(bitmap))
        {
            g.CopyFromScreen(screenBounds.X, screenBounds.Y, 0, 0, screenBounds.Size, CopyPixelOperation.SourceCopy);
        }

        return bitmap;
    }

    private int[] GetPixelRgb(Mat image, int x, int y)
    {
        var pixel = image.At<Vec3b>(y, x); // OpenCV는 (y, x) 좌표 순서를 사용
        return new[] { pixel[2], pixel[1], pixel[0] }; // BGR -> RGB
    }

    private Point? DetectWhiteRectangle(Mat image)
    {
        // 흰색 범위 탐지 (BGR: 255,255,255)
        var lowerBound = new Scalar(250, 250, 250); // 거의 흰색
        var upperBound = new Scalar(255, 255, 255);
        var mask = new Mat();
        Cv2.InRange(image, lowerBound, upperBound, mask);

        // 컨투어 탐지
        var contours = Cv2.FindContoursAsArray(mask, RetrievalModes.External, ContourApproximationModes.ApproxSimple);
        if (contours.Length == 0)
            return null;

        // 사각형 크기 계산 및 가장 우측 상단 부분 확인
        var largestContour = contours.OrderByDescending(Cv2.ContourArea).FirstOrDefault();
        var rect = Cv2.BoundingRect(largestContour);
        var topRight = new Point(rect.Right, rect.Top);

        return topRight;
    }

    private void Close(int x, int y)
    {
        // 제공된 닫기 함수를 호출합니다.
        Console.WriteLine($"Close 호출: ({x}, {y})");
    }

    private void buttonStart_Click(object sender, EventArgs e)
    {
        StartProcess();
    }
}
주요 기능 설명
화면 캡처

CaptureScreen 함수는 현재 화면을 캡처합니다.
Graphics.CopyFromScreen 메서드를 사용하여 화면 데이터를 Bitmap에 복사합니다.
OpenCV로 이미지 처리

Bitmap 이미지를 OpenCV Mat 형식으로 변환해 분석합니다.
흰색 사각형을 감지하고, 가장 우측 상단 좌표를 찾습니다.
RGB 값 확인

(900, 200) 좌표의 픽셀 RGB 값을 가져옵니다.
조건에 따라 처리를 계속할지 중단할지 결정합니다.
흰색 사각형 탐지

흰색 범위를 마스크로 만들어 흰색 픽셀만 남깁니다.
외곽선을 찾아 가장 큰 흰색 사각형의 경계 박스를 계산합니다.
클릭 좌표 계산

우측 상단 좌표에서 (x - 15, y - 15)를 계산합니다.
클릭을 수행하는 Close(x, y)를 호출합니다.
루프 제어

캡처-분석-클릭 과정을 최대 10번 반복합니다.
5초 간격으로 작업을 수행하며, 조건이 위배되면 중단합니다.
추가 설정
OpenCvSharp4와 OpenCvSharp4.Windows를 NuGet에서 설치해야 합니다.