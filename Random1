주어진 요구 사항에 따라 WPF 애플리케이션에서 PLC로 데이터를 전송하는 기능을 구현하기 위해 다음과 같은 설계 및 구현 방법을 제안합니다. 이 기능은 사용자가 버튼을 클릭하면 해당 번호에 매핑된 값이 PLC로 전송되는 방식입니다. 디자인 패턴을 유지하면서 기존 기능에 추가될 수 있도록 합니다.

설계 개요
서비스와 통신: MainWindow에서 버튼 클릭 이벤트를 통해 소켓을 통해 서비스에 메시지를 전송합니다.
서비스 측 구현: 서비스는 메시지를 수신하고, Mewtocol 형식으로 변환하여 PLC로 전송합니다.
데이터 매핑: 각 번호에 문자열로 된 이름이 매핑되어 있으며, 이 정보는 ViewModel에 저장됩니다.
MVVM 패턴 유지: MainWindow.xaml에 UI 요소를 정의하고, MainViewModel에서 로직을 처리합니다.
구현 계획
UI 구현 (MainWindow.xaml):

버튼을 생성하고 클릭 시 명령을 ViewModel로 전달합니다.
각 버튼은 번호와 매핑된 문자열을 표시합니다.
ViewModel (MainViewModel.cs):

번호와 문자열 매핑을 관리하고, 명령을 통해 PLC로 메시지를 전송합니다.
서비스 측 (LogService.cs 수정):

소켓을 통해 수신된 메시지를 Mewtocol 형식으로 변환하여 PLC로 전송합니다.
소켓 통신 관리:

MainWindow와 LogService 간의 소켓 통신을 통해 명령을 전달합니다.
1. MainWindow.xaml 구현
WPF의 ItemsControl을 사용하여 동적으로 버튼을 생성하고, 각 버튼은 ViewModel의 명령을 통해 소켓을 통해 서비스에 메시지를 보냅니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:RouterMiddleACR"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <!-- 번호와 매핑된 문자열을 동적으로 표시할 ItemsControl -->
        <ItemsControl ItemsSource="{Binding ButtonMappings}">
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <WrapPanel />
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <Button Content="{Binding DisplayName}" 
                            Command="{Binding DataContext.SendToPLCCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                            CommandParameter="{Binding Number}"
                            Width="100" Height="30" Margin="5"/>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>
    </Grid>
</Window>
2. MainViewModel.cs 구현
ViewModel에서는 버튼 클릭 명령을 처리하고, 소켓을 통해 서비스를 호출하는 로직을 구현합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Net.Sockets;
using System.Text;
using System.Windows.Input;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        // PLC에 전송할 데이터의 매핑
        public ObservableCollection<ButtonMapping> ButtonMappings { get; } = new ObservableCollection<ButtonMapping>
        {
            new ButtonMapping { Number = 0, DisplayName = "Zero" },
            new ButtonMapping { Number = 1, DisplayName = "One" },
            new ButtonMapping { Number = 2, DisplayName = "Two" },
            new ButtonMapping { Number = 3, DisplayName = "Three" },
            new ButtonMapping { Number = 4, DisplayName = "Four" }
        };

        private TcpClient _tcpClient;
        private NetworkStream _networkStream;

        public ICommand SendToPLCCommand { get; }

        public MainViewModel()
        {
            SendToPLCCommand = new RelayCommand<int>(SendToPLC);
            ConnectToService();
        }

        private void ConnectToService()
        {
            try
            {
                _tcpClient = new TcpClient("127.0.0.1", 9000);
                _networkStream = _tcpClient.GetStream();
            }
            catch (Exception ex)
            {
                // 에러 처리 로직
            }
        }

        private async void SendToPLC(int number)
        {
            if (_networkStream != null)
            {
                string message = $"%01#WDD0230002300{number:D2}00**\r"; // Mewtocol 메시지 형식
                byte[] data = Encoding.ASCII.GetBytes(message);
                await _networkStream.WriteAsync(data, 0, data.Length);
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ButtonMapping
    {
        public int Number { get; set; }
        public string DisplayName { get; set; }
    }
}
3. 서비스 측 (LogService.cs 수정)
서비스에서는 소켓으로 수신된 메시지를 PLC로 전송하는 로직을 구현합니다.

csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        // 기존 코드 생략...
        
        public async Task StartTcpListener()
        {
            TcpListener listener = new TcpListener(System.Net.IPAddress.Any, 9000);
            listener.Start();
            Console.WriteLine("Listening for connections...");

            while (true)
            {
                TcpClient client = await listener.AcceptTcpClientAsync();
                Console.WriteLine("Client connected.");
                _ = Task.Run(() => HandleClient(client));
            }
        }

        private async Task HandleClient(TcpClient client)
        {
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length)) != 0)
                {
                    string message = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    SendToPLC(message);
                }
            }
        }

        private void SendToPLC(string message)
        {
            try
            {
                // PLC와의 시리얼 통신 코드 구현
                // 예: 시리얼 포트로 데이터 전송
                Console.WriteLine($"Sending to PLC: {message}");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending to PLC: {ex.Message}");
            }
        }
    }
}
요약
UI 구현: MainWindow.xaml에서 동적으로 버튼을 생성하고, 각 버튼 클릭 시 ViewModel로 명령을 전달합니다.

ViewModel 구현: MainViewModel.cs에서 번호와 매핑된 문자열을 관리하고, 버튼 클릭 시 소켓을 통해 메시지를 서비스에 전송합니다.

서비스 구현: LogService.cs에서 소켓을 통해 수신된 메시지를 PLC로 전송합니다.

연결 및 통신 관리: ViewModel에서 서비스와의 TCP 연결을 관리하고, 명령을 통해 데이터를 전송합니다.

이 구현을 통해 WPF 애플리케이션에서 PLC로 데이터를 전송하는 기능을 쉽게 확장할 수 있습니다. 각 기능이 MVVM 패턴을 유지하면서 모듈화되어 있어 유지보수와 확장이 용이합니다