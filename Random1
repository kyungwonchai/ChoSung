송합니다. 이전에 요청하신 시간대 분류 조건을 정확히 이해하지 못했습니다. 주어진 특정 시간대에 따라 datev1을 분류하기 위해 CASE 문과 DATEPART 함수를 사용하여 다음과 같이 쿼리를 작성할 수 있습니다:

sql
코드 복사
WITH view1 AS (
    SELECT 
        Line,
        DATEADD(MINUTE, -10, datev) AS datev1,
        pickupcnt
    FROM table_lossdata
)
SELECT 
    Line,
    pickupcnt,
    datev1,
    CONVERT(VARCHAR(13), datev1, 120) AS 시간,
    CASE
        WHEN DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) BETWEEN 0 AND 20 THEN '21'
        WHEN DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '22'
        WHEN DATEPART(HOUR, datev1) = 23 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '23'
        WHEN DATEPART(HOUR, datev1) = 0 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '00'
        WHEN DATEPART(HOUR, datev1) = 1 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '01'
        WHEN DATEPART(HOUR, datev1) = 2 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '02'
        WHEN DATEPART(HOUR, datev1) = 3 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '03'
        WHEN DATEPART(HOUR, datev1) = 4 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '04'
        WHEN DATEPART(HOUR, datev1) = 5 AND DATEPART(MINUTE, datev1) BETWEEN 30 AND 59 THEN '05'
        WHEN DATEPART(HOUR, datev1) = 6 AND DATEPART(MINUTE, datev1) BETWEEN 0 AND 50 THEN '05'
        ELSE RIGHT('0' + CONVERT(VARCHAR, DATEPART(HOUR, datev1)), 2)
    END AS 분류시간
FROM view1
ORDER BY datev1;
쿼리 설명:

view1 CTE(Common Table Expression):

table_lossdata 테이블에서 datev 컬럼의 값에 10분을 빼서 datev1 컬럼을 생성합니다.
Line과 pickupcnt 컬럼을 선택합니다.
CASE 문을 통한 시간대 분류:

DATEPART 함수를 사용하여 datev1의 시간(HOUR)과 분(MINUTE)을 추출합니다.
각 시간대 조건에 따라 분류시간을 지정합니다:
21시: 21:00 ~ 21:20
22시: 22:30 ~ 22:59
23시: 23:30 ~ 23:59
00시: 00:30 ~ 00:59
01시: 01:30 ~ 01:59
02시: 02:30 ~ 02:59
03시: 03:30 ~ 03:59
04시: 04:30 ~ 04:59
05시: 05:30 ~ 05:59 및 06:00 ~ 06:50
위 조건에 해당하지 않는 경우, 기본적으로 해당 시간의 HOUR 값을 반환합니다.
결과 정렬:
