이해했습니다. 파일 경로는 **C:\PROD_FILE_LOG**이고, 로그 파일 규칙은 명확히 알려주셨습니다. 또한, 처음 실행 시 마지막 10개의 파일을 가져와서 화면에 표시하며, 새로 추가된 파일에 대해서는 순차적으로 작업을 처리해야 합니다.

요약 수정 사항:
경로는 **C:\PROD_FILE_LOG**로 고정.
처음 실행 시 마지막 10개의 파일을 불러와 DataGrid에 추가.
Dispatcher.Invoke를 사용해 UI 스레드에서 작업을 추가.
새로 감지된 파일은 임의 함수에 파라미터를 전달하고 처리.
작업 목록은 MAG_NO, PO_NO, 기타 항목 및 상태 정보를 표시.
**파일 추가 시 시퀀스 번호(1, 2, 3)**에 따라 처리.
FileProcessor.cs (파일 처리 및 감시, 초기 10개 처리 포함)
Services/FileProcessor.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Timers;

public class FileProcessor
{
    private readonly string _logFolder;  // 로그 파일이 저장된 폴더 경로
    private readonly PlcCommunication _plcCommunication;  // PLC 통신 클래스 참조
    private List<string> _processedFiles = new List<string>();  // 이미 처리한 파일명 저장
    private DateTime _lastProcessedFileTime;  // 마지막으로 처리한 파일의 시간
    private Timer _fileCheckTimer;
    private Dictionary<string, List<LogEntry>> _poFiles = new Dictionary<string, List<LogEntry>>(); // PO별 파일 관리

    public event Action<LogEntry> NewFileDetected;  // 파일이 감지되면 발생하는 이벤트

    public FileProcessor(string logFolder, PlcCommunication plcCommunication)
    {
        _logFolder = logFolder;
        _plcCommunication = plcCommunication;
        _lastProcessedFileTime = DateTime.MinValue;  // 기본값으로 설정

        // 처음 실행 시 마지막 10개 파일 가져오기
        LoadInitialFiles();

        // 5초마다 파일을 감시하는 타이머 설정
        _fileCheckTimer = new Timer(5000);
        _fileCheckTimer.Elapsed += CheckForNewFiles;
        _fileCheckTimer.Start();
    }

    /// <summary>
    /// 파일명에서 연월일시분초.fff 값을 추출하여 DateTime으로 변환합니다.
    /// </summary>
    private DateTime ExtractDateTimeFromFileName(string fileName)
    {
        var datePart = Path.GetFileNameWithoutExtension(fileName).Split('_')[1];
        return DateTime.ParseExact(datePart, "yyyyMMddHHmmssfff", CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// 초기 실행 시, 최근 10개의 파일을 로드합니다.
    /// </summary>
    public void LoadInitialFiles()
    {
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderByDescending(f => ExtractDateTimeFromFileName(f))
            .Take(10)
            .OrderBy(f => ExtractDateTimeFromFileName(f))
            .ToList();

        foreach (var file in files)
        {
            var logEntry = ParseFile(file);

            // 시퀀스 플래그 설정: 첫 파일(1), 중간 파일(2), 마지막 파일(3)
            logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

            // 이벤트 발생 (MainViewModel에서 처리)
            NewFileDetected?.Invoke(logEntry);
        }
    }

    /// <summary>
    /// 5초마다 폴더를 확인하고 마지막 파일 시간 이후에 생성된 파일만 처리합니다.
    /// </summary>
    private void CheckForNewFiles(object sender, ElapsedEventArgs e)
    {
        var files = Directory.GetFiles(_logFolder, "*.txt")
            .OrderBy(f => ExtractDateTimeFromFileName(f))
            .ToList();

        foreach (var file in files)
        {
            var fileTime = ExtractDateTimeFromFileName(file);

            if (fileTime > _lastProcessedFileTime)
            {
                // 로그 파일을 파싱하여 LogEntry 생성
                var logEntry = ParseFile(file);

                // 시퀀스 플래그 설정: 첫 파일(1), 중간 파일(2), 마지막 파일(3)
                logEntry.SequenceFlag = DetermineSequenceFlag(logEntry);

                // 이벤트 발생 및 PLC 통신 트리거
                NewFileDetected?.Invoke(logEntry);

                // PLC 신호 전송
                _plcCommunication.SendSignalForFile(file);

                // 마지막 처리 시간 업데이트
                _lastProcessedFileTime = fileTime;

                // 처리된 파일 기록
                _processedFiles.Add(Path.GetFileName(file));

                // PO별로 파일을 관리 (시퀀스 관리)
                if (!_poFiles.ContainsKey(logEntry.PO_NO))
                {
                    _poFiles[logEntry.PO_NO] = new List<LogEntry>();
                }
                _poFiles[logEntry.PO_NO].Add(logEntry);
            }
        }
    }

    /// <summary>
    /// 로그 파일을 읽어 LogEntry 모델로 변환합니다.
    /// </summary>
    private LogEntry ParseFile(string filePath)
    {
        var lines = File.ReadAllLines(filePath);

        var logEntry = new LogEntry
        {
            FileName = Path.GetFileName(filePath),
            MAG_NO = GetValueFromLine(lines, "MAG_NO"),
            PO_NO = GetValueFromLine(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(GetValueFromLine(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(GetValueFromLine(lines, "PO_PROD_QTY")),
            MAG_QTY = int.Parse(GetValueFromLine(lines, "MAG_QTY")),
            BASIC_MODEL = GetValueFromLine(lines, "BASIC_MODEL"),
            MODEL_CODE = GetValueFromLine(lines, "MODEL_CODE")
        };

        return logEntry;
    }

    /// <summary>
    /// 파일에서 특정 키에 해당하는 값을 추출합니다.
    /// </summary>
    private string GetValueFromLine(string[] lines, string key)
    {
        var line = lines.FirstOrDefault(l => l.Contains(key));
        return line?.Split('=')[1].Trim('\'');
    }

    /// <summary>
    /// PO_NO별 첫 파일(1), 마지막 파일(3), 중간 파일(2) 판단
    /// </summary>
    private int DetermineSequenceFlag(LogEntry logEntry)
    {
        if (!_poFiles.ContainsKey(logEntry.PO_NO))
        {
            // 첫 파일이면 1 반환
            return 1;
        }

        // 이미 파일이 있는 경우, 생산 수량과 계획 수량이 같으면 마지막 파일로 처리 (3)
        var poFiles = _poFiles[logEntry.PO_NO];
        if (logEntry.PO_PLAN_QTY == logEntry.PO_PROD_QTY)
        {
            return 3; // 마지막 파일
        }

        return 2; // 중간 파일
    }
}
MainViewModel.cs (ViewModel 수정, Dispatcher.Invoke 추가)
ViewModels/MainViewModel.cs

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;
    private FileProcessor _fileProcessor;

    public ICommand CancelAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();
        _taskQueue = new TaskQueue();

        // PLC 통신 클래스 생성
        var plcCommunication = new PlcCommunication();

        // 파일 처리 클래스 생성 (경로와 PLC 통신 클래스 전달)
        _fileProcessor = new FileProcessor(@"C:\PROD_FILE_LOG", plcCommunication);

        // 파일 감지 이벤트 연결
        _fileProcessor.NewFileDetected += OnNewFileDetected;

        CancelAllCommand = new RelayCommand(CancelAllTasks);
    }

    /// <summary>
    /// 새로운 파일이 감지되었을 때 호출되는 메서드.
    /// Dispatcher.Invoke를 사용하여 UI 스레드에서 안전하게 작업 추가.
    /// </summary>
    private void OnNewFileDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var taskModel = new TaskModel(logEntry, _taskQueue, true);
            TaskList.Add(taskModel);
        });
    }

    /// <summary>
    /// 모든 작업을 취소합니다.
    /// </summary>
    private void CancelAllTasks()
    {
        _taskQueue.CancelAll();
        foreach (var task in TaskList)
        {
            task.Status = "Cancelled";
        }
    }
}
MainWindow.xaml (UI 변경, Dispatcher 고려)
Views/MainWindow.xaml

xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />

                <!-- 작업 진행 상태를 표시하는 열 -->
                <DataGridTextColumn Header="Task Status" Binding="{Binding Status}" Width="2*" />
            </DataGrid.Columns>

            <!-- DataGrid Row 스타일을 변경하여 작업 상태에 따른 배경 색상을 지정합니다 -->
            <DataGrid.RowStyle>
                <Style TargetType="DataGridRow">
                    <Style.Triggers>
                        <!-- 완료된 작업은 녹색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCompleted}" Value="True">
                            <Setter Property="Background" Value="LightGreen"/>
                        </DataTrigger>
                        <!-- 에러가 발생한 작업은 빨간색 배경으로 -->
                        <DataTrigger Binding="{Binding IsError}" Value="True">
                            <Setter Property="Background" Value="Red"/>
                        </DataTrigger>
                        <!-- 취소된 작업은 흰색 배경으로 -->
                        <DataTrigger Binding="{Binding IsCancelled}" Value="True">
                            <Setter Property="Background" Value="White"/>
                        </DataTrigger>
                        <!-- 진행 중인 작업은 스카이블루 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="True">
                            <Setter Property="Background" Value="SkyBlue"/>
                        </DataTrigger>
                        <!-- 초기 10개는 회색 배경으로 -->
                        <DataTrigger Binding="{Binding IsRunning}" Value="False">
                            <Setter Property="Background" Value="LightGray"/>
                        </DataTrigger>
                    </Style.Triggers>
                </Style>
            </DataGrid.RowStyle>
        </DataGrid>

        <!-- 모든 작업을 취소하는 버튼 -->
        <Button Content="Cancel All" Command="{Binding CancelAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
    </Grid>
</Window>
설명:
FileProcessor:

처음 실행 시 최근 10개의 파일을 가져와서 처리합니다.
이후 5초마다 폴더를 체크하여 새로운 파일이 추가되면 NewFileDetected 이벤트를 통해 MainViewModel로 전달합니다.
파일의 시퀀스 번호(첫 번째: 1, 중간: 2, 마지막: 3)를 계산하여 로그 항목에 추가합니다.
MainViewModel:

Dispatcher를 사용해 UI 스레드에서 안전하게 작업을 추가합니다.
작업 목록에 MAG_NO, PO_NO, 시퀀스 번호 등 8개의 항목을 표시하고 상태에 따른 배경색을 변경합니다.
MainWindow.xaml:

DataGrid에서 각 항목을 표시하고, 작업 상태에 따라 배경색이 변경됩니다 (녹색, 스카이블루, 빨강, 회색).
이제 이 코드는 파일 경로와 파일 규칙을 완전히 반영한 상태로, 처음 10개의 파일을 로드하고, 이후 새로운 파일이 추가되면 UI에서 순차적으로 작업을 처리할 수 있습