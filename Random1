기존에 만든 Zero부터 4까지 동적으로 버튼을 생성하여 신호를 보내는 기능을 확장하여, 새로운 요구 사항을 반영하는 두 가지 기능을 추가해 보겠습니다:

텍스트박스에 적힌 값을 PLC로 전송: 사용자가 텍스트박스에 직접 값을 입력하고, 해당 값을 Mewtocol 프로토콜을 통해 PLC로 전송하는 기능.
DT2330 번지의 값을 처리하는 기능을 기존 버튼 방식과 통합: 기존에 만든 Zero부터 4까지 버튼을 동적으로 생성하여 값을 전송하는 것과 유사하게, DT2330 번지의 값을 처리할 수 있도록 UI를 확장.
아래는 이러한 기능을 추가하는 방법에 대한 상세한 코드와 설명입니다.

1. MainWindow.xaml 수정
MainWindow.xaml에서 텍스트박스를 추가하여 사용자가 값을 입력하고, 이를 전송할 수 있는 버튼을 추가합니다. 또한, DT2330 번지의 값을 처리할 수 있는 새로운 버튼들도 추가합니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:RouterMiddleACR.Controls"
        Title="RouterMiddleACR" Height="450" Width="800">
    <Grid>
        <StackPanel Orientation="Vertical" Margin="10">
            <!-- 기존 PLC 상태 표시 -->
            <TextBlock Text="PLC 상태:" FontWeight="Bold" FontSize="16" />
            <TextBlock Text="{Binding R520Status}" Margin="5" />
            <TextBlock Text="{Binding R521Status}" Margin="5" />

            <!-- 사용자 입력 텍스트박스와 전송 버튼 -->
            <TextBox x:Name="ValueInputTextBox" Width="200" Margin="5"/>
            <Button Content="텍스트 값 전송" Click="SendTextBoxValue_Click" Margin="5" />

            <!-- Zero부터 4까지 동적 버튼 생성 -->
            <ItemsControl ItemsSource="{Binding ButtonCommands}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Button Content="{Binding Key}" Command="{Binding Value}" Margin="2"/>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- DT2330 처리용 버튼 추가 -->
            <Button Content="DT2330 처리" Click="ProcessDT2330_Click" Margin="5" />
        </StackPanel>
    </Grid>
</Window>
2. MainWindow.xaml.cs 수정
MainWindow.xaml.cs 파일에서 텍스트박스의 값을 PLC로 전송하는 버튼 클릭 이벤트와 DT2330을 처리하는 버튼 클릭 이벤트를 추가합니다.

csharp
코드 복사
using System;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;
        }

        // 텍스트박스에 적힌 값을 PLC로 전송
        private async void SendTextBoxValue_Click(object sender, RoutedEventArgs e)
        {
            if (int.TryParse(ValueInputTextBox.Text, out int value))
            {
                await _viewModel.SendTextBoxValueToPLC(value);
            }
            else
            {
                MessageBox.Show("유효한 숫자를 입력하세요.");
            }
        }

        // DT2330 번지의 값을 처리하는 버튼 클릭 이벤트
        private async void ProcessDT2330_Click(object sender, RoutedEventArgs e)
        {
            await _viewModel.ReadAndClearDT2330Data();
        }
    }
}
3. MainViewModel.cs 수정
MainViewModel에서 텍스트박스의 값을 PLC로 전송하는 메서드와 DT2330 번지를 처리하는 메서드를 추가합니다. 또한, 기존의 버튼들을 동적으로 생성하기 위해 ButtonCommands라는 딕셔너리를 사용하여 UI와 바인딩합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 0; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Button {i}",
                    new RelayCommand(async () => await SendNumberToPLC(value))));
            }

            // DT2330 관련 버튼 추가
            ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                "Process DT2330",
                new RelayCommand(async () => await ReadAndClearDT2330Data())));
        }

        public async Task SendNumberToPLC(int number)
        {
            string command = $"%01#WDD0230000230{number:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(command);
            LogMessage($"Sent {number} to PLC");
        }

        public async Task SendTextBoxValueToPLC(int value)
        {
            string command = $"%01#WDD0230000230{value:D2}00**\r";
            await _comPortManager.SendDataToPLCAsync(command);
            LogMessage($"Sent {value} from TextBox to PLC");
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            // DT2330 값에 따라 상태 설명을 업데이트
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
4. 설명 및 적용 방법
텍스트박스와 전송 버튼: MainWindow.xaml에 텍스트박스와 "텍스트 값 전송" 버튼을 추가하여 사용자가 직접 값을 입력할 수 있도록 하였습니다. 이 값은 버튼 클릭 시 SendTextBoxValue_Click 이벤트 핸들러를 통해 MainViewModel의 SendTextBoxValueToPLC 메서드로 전달됩니다.

DT2330 처리용 버튼: "DT2330 처리" 버튼을 추가하여, 해당 버튼을 클릭할 때 ReadAndClearDT2330Data 메서드가 호출되도록 하였습니다. 이 메서드는 PLC의 DT2330 번지에서 값을 읽어와 처리한 후 값을 초기화합니다.

동적 버튼 생성: 기존의 Zero부터 4까지의 버튼을 생성하던 로직을 MainViewModel의 InitializeCommands 메서드로 이동하여, 버튼들이 동적으로 생성되도록 했습니다. 이를 통해 UI에서 여러 개의 버튼이 동적으로 생성되고, 각 버튼이 클릭될 때마다 해당 숫자를 PLC로 전송합니다.

PLC 상태 업데이트: UpdatePLCStatusAsync 메서드는 주기적으로 R520과 R521 번지의 값을 읽어와 UI에 표시합니다. 이 메서드는 백그라운드에서 실행되어 실시간으로 PLC의 상태를 모니터링합니다.

최종 적용 방법
코드 추가 및 수정: 위의 코드들을 각각의 파일에 추가하거나 수정합니다.
PLC 연결 테스트: 실제 PLC와의 연결을 설정하고, 각 버튼을 클릭하여 신호가 제대로 전송되는지, 텍스트박스에 입력한 값이 전송되는지 테스트합니다.
UI 업데이트 확인: DT2330 번지의 값이 처리되었는지, R520과 R521 상태가 올바르게 업데이트되는지 확인합니다.
이로써 텍스트박스를 통한 값 전송 기능과 DT2330 번지의 값을 처리하는 기능이 추가되었습니다. 이를 통해 더 유연하고 다양한 입력 및 출력 옵션을 제공할 수 있습니