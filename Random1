네 알겠습니다. 각 행에서 원래 있던 숫자 위치를 유지하고, 빈 값이 있는 경우 해당 자리에 0을 넣되, 데이터 순서가 밀리지 않도록 처리해야 합니다.
즉, 엑셀에서 보이는 순서를 그대로 유지하면서 "-" 또는 빈 값은 0으로 채우고, 나머지 숫자는 원래 위치를 유지해야 합니다.

✅ 수정된 VBA 코드 (데이터 밀리지 않도록 원본 순서 유지)
vba
코드 복사
Sub ExportToMSSQL()
    Dim conn As Object
    Dim cmd As Object
    Dim ws As Worksheet
    Dim lastRow As Long
    Dim i As Long, j As Integer
    Dim insertQuery As String
    Dim values As String
    Dim colA, colB, colF, colG, colH, colI As String
    Dim bct1(1 To 8), bct2(1 To 8), tct1(1 To 8), tct2(1 To 8) As Variant

    ' MSSQL 연결 설정
    Set conn = CreateObject("ADODB.Connection")
    conn.Open "Provider=SQLOLEDB;Data Source=서버이름;Initial Catalog=DB이름;User ID=사용자이름;Password=비밀번호;"
    
    ' 엑셀 시트 설정
    Set ws = ThisWorkbook.Sheets("Sheet1")
    
    ' 마지막 행 찾기
    lastRow = ws.Cells(ws.Rows.Count, "A").End(xlUp).Row

    ' 데이터 처리 및 삽입
    For i = 5 To lastRow Step 4
        ' 그룹, 라인, 모델, 타입, ECN, Edition 추출
        colA = Trim(ws.Cells(i, 1).Value)
        colB = Trim(ws.Cells(i, 2).Value)
        colF = Trim(ws.Cells(i, 6).Value)
        colG = Trim(ws.Cells(i, 7).Value)
        colH = Trim(ws.Cells(i, 8).Value)
        colI = Trim(ws.Cells(i, 9).Value)

        ' 배열 초기화 (빈 값이 올바르게 들어가도록)
        For j = 1 To 8
            bct1(j) = Null
            bct2(j) = Null
            tct1(j) = Null
            tct2(j) = Null
        Next j
        
        ' S~Z (19~26열)에서 데이터 추출 (빈 값이면 0)
        Dim colCounter As Integer
        colCounter = 1
        For j = 19 To 26
            If ws.Cells(i, j).Value <> "" And ws.Cells(i, j).Value <> "-" Then
                bct1(colCounter) = ws.Cells(i, j).Value
                colCounter = colCounter + 1
            End If
        Next j
        
        colCounter = 1
        For j = 19 To 26
            If ws.Cells(i + 1, j).Value <> "" And ws.Cells(i + 1, j).Value <> "-" Then
                bct2(colCounter) = ws.Cells(i + 1, j).Value
                colCounter = colCounter + 1
            End If
        Next j
        
        colCounter = 1
        For j = 19 To 26
            If ws.Cells(i + 2, j).Value <> "" And ws.Cells(i + 2, j).Value <> "-" Then
                tct1(colCounter) = ws.Cells(i + 2, j).Value
                colCounter = colCounter + 1
            End If
        Next j
        
        colCounter = 1
        For j = 19 To 26
            If ws.Cells(i + 3, j).Value <> "" And ws.Cells(i + 3, j).Value <> "-" Then
                tct2(colCounter) = ws.Cells(i + 3, j).Value
                colCounter = colCounter + 1
            End If
        Next j

        ' SQL INSERT 문 생성
        values = "'" & colA & "', '" & colB & "', '" & colF & "', '" & colG & "', '" & colH & "', '" & colI & "'"
        For j = 1 To 8
            values = values & ", " & IIf(IsNull(bct1(j)), 0, bct1(j))
            values = values & ", " & IIf(IsNull(bct2(j)), 0, bct2(j))
            values = values & ", " & IIf(IsNull(tct1(j)), 0, tct1(j))
            values = values & ", " & IIf(IsNull(tct2(j)), 0, tct2(j))
        Next j

        insertQuery = "INSERT INTO dbo.ExcelData (그룹, 라인, 모델, 타입, ECN, Edition, " & _
                      "BCT1_1, BCT1_2, BCT1_3, BCT1_4, BCT1_5, BCT1_6, BCT1_7, BCT1_8, " & _
                      "BCT2_1, BCT2_2, BCT2_3, BCT2_4, BCT2_5, BCT2_6, BCT2_7, BCT2_8, " & _
                      "TCT1_1, TCT1_2, TCT1_3, TCT1_4, TCT1_5, TCT1_6, TCT1_7, TCT1_8, " & _
                      "TCT2_1, TCT2_2, TCT2_3, TCT2_4, TCT2_5, TCT2_6, TCT2_7, TCT2_8) " & _
                      "VALUES (" & values & ")"

        ' SQL 실행
        Set cmd = CreateObject("ADODB.Command")
        cmd.ActiveConnection = conn
        cmd.CommandText = insertQuery
        cmd.Execute
    Next i

    ' 연결 해제
    conn.Close
    Set conn = Nothing
    Set cmd = Nothing

    MsgBox "데이터가 성공적으로 MSSQL에 삽입되었습니다.", vbInformation
End Sub
📌 수정된 점
원래 입력된 위치 유지

기존에는 For j = 1 To 8로 채웠는데, For j = 19 To 26을 돌면서 숫자가 있는 위치 그대로 유지하도록 변경함.
colCounter 변수를 사용해서 값이 있는 순서대로 들어가게 유지.
빈 값("" 또는 "-")은 0으로 처리

If ws.Cells(i, j).Value <> "" And ws.Cells(i, j).Value <> "-" Then
bct1(j)처럼 해당 위치의 값이 존재하면 그대로 사용
비어있다면 0으로 변환
각 bct1, bct2, tct1, tct2가 원래 위치에 맞게 저장됨