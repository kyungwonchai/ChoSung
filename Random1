갤럭시 탭 S8 울트라에서 구동되는 충전 상태 감지 및 보안 기능을 구현하는 Android 애플리케이션을 최신 Kotlin 코드와 함께 제공하겠습니다. 주요 기능은 다음과 같습니다:

충전기 해제 감지: 충전기가 해제되면 알림음이 최대 볼륨으로 재생됩니다.
카메라로 사진 촬영: 충전기가 해제될 때 기기에서 자동으로 사진을 촬영합니다.
이미지 서버로 전송: 촬영된 이미지를 서버로 전송하여 보관합니다.
갤럭시 탭 S8 울트라에 최적화: 최신 기기와 API 수준에 맞게 구현합니다.
이 기능을 구현하기 위해 다음 주요 단계들을 따릅니다.

1. 프로젝트 준비 및 권한 설정
갤럭시 탭 S8 울트라에서 앱이 정상적으로 실행되기 위해 필요한 권한을 AndroidManifest에 추가합니다.

AndroidManifest.xml
카메라, 인터넷, 알림음, 서비스 권한 등을 설정해야 합니다.

xml
코드 복사
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    package="com.example.chargerlistener">

    <!-- 카메라와 저장소 권한 -->
    <uses-permission android:name="android.permission.CAMERA" />
    <uses-permission android:name="android.permission.INTERNET" />
    <uses-permission android:name="android.permission.WAKE_LOCK" />
    <uses-permission android:name="android.permission.FOREGROUND_SERVICE" />
    <uses-permission android:name="android.permission.RECORD_AUDIO" />
    <uses-permission android:name="android.permission.READ_EXTERNAL_STORAGE" />
    <uses-permission android:name="android.permission.WRITE_EXTERNAL_STORAGE" />

    <application
        android:allowBackup="true"
        android:label="@string/app_name"
        android:supportsRtl="true"
        android:theme="@style/Theme.AppCompat.Light.NoActionBar">

        <!-- 충전 상태를 감지하는 브로드캐스트 리시버 -->
        <receiver android:name=".ChargerReceiver">
            <intent-filter>
                <action android:name="android.intent.action.ACTION_POWER_CONNECTED" />
                <action android:name="android.intent.action.ACTION_POWER_DISCONNECTED" />
            </intent-filter>
        </receiver>

        <!-- 카메라 서비스를 등록 -->
        <service android:name=".CameraService" android:exported="false"/>

    </application>
</manifest>
2. ChargerReceiver 클래스 (충전 상태 감지)
BroadcastReceiver를 사용하여 충전 상태를 감지합니다. 충전기가 해제되면 알림음을 최대 볼륨으로 재생하고, 카메라를 작동시킵니다.

kotlin
코드 복사
import android.content.BroadcastReceiver
import android.content.Context
import android.content.Intent
import android.media.AudioManager
import android.media.MediaPlayer
import android.media.RingtoneManager
import android.util.Log

class ChargerReceiver : BroadcastReceiver() {

    override fun onReceive(context: Context, intent: Intent) {
        if (intent.action == Intent.ACTION_POWER_DISCONNECTED) {
            Log.d("ChargerReceiver", "충전기가 해제되었습니다.")

            // 알림음 재생
            playAlarm(context)

            // 카메라 촬영 서비스 시작
            val cameraIntent = Intent(context, CameraService::class.java)
            context.startForegroundService(cameraIntent)
        }
    }

    private fun playAlarm(context: Context) {
        try {
            val audioManager = context.getSystemService(Context.AUDIO_SERVICE) as AudioManager
            audioManager.setStreamVolume(AudioManager.STREAM_ALARM, audioManager.getStreamMaxVolume(AudioManager.STREAM_ALARM), 0)

            val ringtoneUri = RingtoneManager.getDefaultUri(RingtoneManager.TYPE_ALARM)
            val mediaPlayer = MediaPlayer.create(context, ringtoneUri)
            mediaPlayer?.apply {
                isLooping = false
                start()
            }
        } catch (e: Exception) {
            e.printStackTrace()
        }
    }
}
3. CameraService 클래스 (카메라 촬영 및 서버 전송)
카메라를 이용하여 이미지를 촬영하고 서버로 전송하는 작업을 서비스로 구현했습니다. 이 서비스는 ForegroundService로 등록하여 기기 슬립 상태에서도 작업을 지속할 수 있게 합니다.

kotlin
코드 복사
import android.app.Notification
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.Service
import android.content.Context
import android.content.Intent
import android.graphics.Bitmap
import android.graphics.SurfaceTexture
import android.hardware.camera2.CameraAccessException
import android.hardware.camera2.CameraCaptureSession
import android.hardware.camera2.CameraDevice
import android.hardware.camera2.CameraManager
import android.os.Build
import android.os.IBinder
import android.util.Log
import android.view.Surface
import androidx.annotation.RequiresApi
import okhttp3.*
import java.io.ByteArrayOutputStream
import java.io.IOException

class CameraService : Service() {

    private lateinit var cameraManager: CameraManager
    private var cameraDevice: CameraDevice? = null

    override fun onCreate() {
        super.onCreate()
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            startForeground(1, createNotification())
        }
    }

    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        openCamera()
        return START_NOT_STICKY
    }

    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)
    private fun openCamera() {
        cameraManager = getSystemService(Context.CAMERA_SERVICE) as CameraManager
        try {
            val cameraId = cameraManager.cameraIdList[0] // 후면 카메라 사용
            cameraManager.openCamera(cameraId, object : CameraDevice.StateCallback() {
                override fun onOpened(camera: CameraDevice) {
                    cameraDevice = camera
                    startCaptureSession(camera)
                }

                override fun onDisconnected(camera: CameraDevice) {
                    camera.close()
                }

                override fun onError(camera: CameraDevice, error: Int) {
                    camera.close()
                }
            }, null)
        } catch (e: CameraAccessException) {
            Log.e("CameraService", "카메라 접근 오류: ${e.message}")
        }
    }

    @RequiresApi(Build.VERSION_CODES.LOLLIPOP)
    private fun startCaptureSession(camera: CameraDevice) {
        val surfaceTexture = SurfaceTexture(0)
        val surface = Surface(surfaceTexture)

        camera.createCaptureSession(listOf(surface), object : CameraCaptureSession.StateCallback() {
            override fun onConfigured(session: CameraCaptureSession) {
                val captureRequest = camera.createCaptureRequest(CameraDevice.TEMPLATE_STILL_CAPTURE).apply {
                    addTarget(surface)
                }.build()

                session.capture(captureRequest, object : CameraCaptureSession.CaptureCallback() {
                    override fun onCaptureCompleted(session: CameraCaptureSession, request: CaptureRequest, result: TotalCaptureResult) {
                        // 이미지 캡처 완료 후 서버로 전송
                        val bitmap = surfaceTexture.bitmap
                        uploadImage(bitmap)
                    }
                }, null)
            }

            override fun onConfigureFailed(session: CameraCaptureSession) {
                Log.e("CameraService", "캡처 세션 구성 실패")
            }
        }, null)
    }

    private fun uploadImage(bitmap: Bitmap) {
        val client = OkHttpClient()
        val byteArrayOutputStream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.JPEG, 90, byteArrayOutputStream)
        val byteArray = byteArrayOutputStream.toByteArray()

        val requestBody = MultipartBody.Builder()
            .setType(MultipartBody.FORM)
            .addFormDataPart("image", "captured.jpg", RequestBody.create(MediaType.parse("image/jpeg"), byteArray))
            .build()

        val request = Request.Builder()
            .url("http://yourserver.com/upload") // 서버 URL로 변경
            .post(requestBody)
            .build()

        client.newCall(request).enqueue(object : Callback {
            override fun onFailure(call: Call, e: IOException) {
                Log.e("CameraService", "이미지 업로드 실패: ${e.message}")
            }

            override fun onResponse(call: Call, response: Response) {
                if (response.isSuccessful) {
                    Log.d("CameraService", "이미지 업로드 성공")
                }
            }
        })
    }

    private fun createNotification(): Notification {
        val channelId = "camera_service_channel"
        val channelName = "Camera Service"
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val notificationChannel = NotificationChannel(channelId, channelName, NotificationManager.IMPORTANCE_LOW)
            val notificationManager = getSystemService(NotificationManager::class.java)
            notificationManager.createNotificationChannel(notificationChannel)
        }

        return Notification.Builder(this, channelId)
            .setContentTitle("Camera Service")
            .setContentText("카메라를 사용하여 이미지를 촬영하고 있습니다.")
            .setSmallIcon(R.drawable.ic_launcher_foreground)
            .build()
    }

    override fun onBind(intent: Intent?): IBinder? {
        return null
    }
}
4. 주요 기능 설명 및 최적화
충전 상태 감지: BroadcastReceiver를 통해 충전 상태가 변경될 때마다 이벤트를 수신하여 처리합니다.
카메라 사용 시 주의사항: 최신 Android 기기에서는 카메라 권한뿐만 아니라 기기 잠금 해제 상태를 고려해야 합니다. ForegroundService를 사용하여 앱이 백그라운드 상태에서도 정상적으로 작동할 수 있게 합니다.
이미지 서버 전송: 이미지를 촬영한 후, OkHttp 라이브러리를 사용하여 서버로 이미지를 전송합니다. 서버 주소는 프로젝트 요구사항에 맞게 설정해 주세요.