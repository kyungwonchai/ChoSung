lR 메시지를 수신하면 최근 메시지 보기 버튼을 자동으로 클릭하는 것처럼 보이도록 효과를 구현하려면, 버튼 클릭 이벤트를 수신 시 직접 호출하면 됩니다. 이를 통해 사용자가 버튼을 누른 것처럼 DataActivity가 열리고, 최근 메시지가 표시됩니다.

수정된 MainActivity.kt 코드
kotlin
코드 복사
package com.dxmxsmd.routeracralarm

import android.Manifest
import android.app.NotificationChannel
import android.app.NotificationManager
import android.app.PendingIntent
import android.content.Context
import android.content.Intent
import android.content.pm.PackageManager
import android.os.Build
import android.os.Bundle
import android.os.PowerManager
import android.util.Log
import android.widget.Button
import android.widget.CheckBox
import androidx.activity.ComponentActivity
import androidx.activity.result.contract.ActivityResultContracts
import androidx.core.app.ActivityCompat
import androidx.core.app.NotificationCompat
import androidx.lifecycle.lifecycleScope
import com.microsoft.signalr.HubConnection
import com.microsoft.signalr.HubConnectionBuilder
import kotlinx.coroutines.launch

class MainActivity : ComponentActivity() {

    private lateinit var hubConnection: HubConnection
    private lateinit var notificationManager: NotificationManager
    private lateinit var vibrationCheckBox: CheckBox
    private lateinit var viewMessagesButton: Button

    // 런타임 권한 요청을 위한 launcher 정의
    private val requestPermissionLauncher = registerForActivityResult(
        ActivityResultContracts.RequestPermission()
    ) { isGranted: Boolean ->
        if (isGranted) {
            Log.d("Permission", "Notification permission granted")
        } else {
            Log.d("Permission", "Notification permission denied")
        }
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 진동 체크박스 초기화
        vibrationCheckBox = findViewById(R.id.vibrationCheckBox)

        // 최근 메시지 보기 버튼 초기화 및 클릭 리스너 설정
        viewMessagesButton = findViewById(R.id.viewMessagesButton)
        viewMessagesButton.setOnClickListener {
            openDataActivity() // DataActivity 열기
        }

        // 알림 채널 생성
        createNotificationChannel()

        // Android 13 이상에서 알림 권한 요청
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.TIRAMISU) {
            requestNotificationPermission()
        }

        // SignalR 서버 연결 설정
        hubConnection = HubConnectionBuilder.create("https://your-signalr-server-address")
            .build()

        // SignalR 메시지 수신 대기
        hubConnection.on("ReceiveMessage", { message: String ->
            showNotification(message) // 메시지 수신 시 알림
            wakeUpScreen() // 화면 켜기
            openDataActivity() // 최근 메시지 보기 버튼 클릭 효과
        }, String::class.java)

        lifecycleScope.launch {
            try {
                hubConnection.start().blockingAwait()
                Log.d("SignalR", "Connected to SignalR server.")
            } catch (e: Exception) {
                Log.e("SignalR", "SignalR connection failed", e)
            }
        }
    }

    private fun showNotification(message: String) {
        val intent = Intent(this, MainActivity::class.java)
        val pendingIntent: PendingIntent =
            PendingIntent.getActivity(this, 0, intent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)

        val builder = NotificationCompat.Builder(this, "SIGNALR_CHANNEL")
            .setSmallIcon(R.drawable.ic_notification)
            .setContentTitle("New SignalR Message")
            .setContentText(message)
            .setPriority(NotificationCompat.PRIORITY_HIGH)
            .setAutoCancel(true)
            .setContentIntent(pendingIntent)

        if (vibrationCheckBox.isChecked) {
            builder.setVibrate(longArrayOf(0, 500, 1000))
        }

        notificationManager.notify(1, builder.build())
    }

    private fun wakeUpScreen() {
        val powerManager = getSystemService(Context.POWER_SERVICE) as PowerManager
        val isScreenOn = if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.KITKAT_WATCH) {
            powerManager.isInteractive
        } else {
            @Suppress("DEPRECATION")
            powerManager.isScreenOn
        }

        if (!isScreenOn) {
            val wakeLock = powerManager.newWakeLock(
                PowerManager.SCREEN_BRIGHT_WAKE_LOCK or PowerManager.ACQUIRE_CAUSES_WAKEUP,
                "RouterACRAlarm::WakeLockTag"
            )
            wakeLock.acquire(3000) // 3초 동안 화면 켜짐 유지
        }
    }

    private fun createNotificationChannel() {
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.O) {
            val name = "SignalR Channel"
            val descriptionText = "Channel for SignalR notifications"
            val importance = NotificationManager.IMPORTANCE_HIGH
            val channel = NotificationChannel("SIGNALR_CHANNEL", name, importance).apply {
                description = descriptionText
            }
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
            notificationManager.createNotificationChannel(channel)
        } else {
            notificationManager = getSystemService(Context.NOTIFICATION_SERVICE) as NotificationManager
        }
    }

    private fun requestNotificationPermission() {
        when {
            ActivityCompat.checkSelfPermission(
                this, Manifest.permission.POST_NOTIFICATIONS
            ) == PackageManager.PERMISSION_GRANTED -> {
                Log.d("Permission", "Notification permission already granted")
            }
            else -> {
                requestPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)
            }
        }
    }

    // DataActivity를 여는 함수
    private fun openDataActivity() {
        val intent = Intent(this, DataActivity::class.java)
        startActivity(intent)
    }
}
변경 사항 및 설명
viewMessagesButton을 자동으로 클릭:

openDataActivity라는 함수를 만들어 DataActivity를 여는 기능을 분리했습니다.
SignalR 메시지를 수신하면 openDataActivity를 호출하여 최근 메시지 보기 버튼이 눌린 것처럼 DataActivity가 열리도록 설정했습니다.
자동으로 화면 열기:

SignalR 메시지를 수신하면 openDataActivity가 호출되어 최근 메시지를 표시하는 DataActivity가 자동으로 열리며, 사용자가 버튼을 누르지 않아도 동일한 효과를 얻을 수 있습니다.
권한 처리 및 알림 설정:

알림 권한 처리 및 알림 생성 부분은 이전과 동일하게 유지되었습니다.