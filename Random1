이미지 업로드 시 그린 선이 포함되도록 하려면 Bitmap에 그린 선을 추가해야 합니다. 이를 위해 Canvas와 Paint를 사용하여 비트맵에 드로잉을 적용한 후 업로드하는 방식을 구현하겠습니다.

MainActivity.kt
기존 코드에 변동사항 없습니다.

ImageListScreen.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.Canvas
import android.graphics.Paint
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageListScreen(
    imageList: List<ImageData>,
    selectedImage: Bitmap?,
    selectedImageTitle: String,
    selectedDatetime: String,
    onFetchData: () -> Unit,
    onImageSelected: (String, String) -> Unit,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    Column {
        if (selectedImage == null) {
            Button(
                onClick = { onFetchData() },
                modifier = Modifier.padding(20.dp)
            ) {
                Text(if (imageList.isEmpty()) "Fetch Data" else "Reload Data")
            }
        }

        LazyColumn(modifier = Modifier.weight(1f).padding(horizontal = 20.dp)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(vertical = 8.dp)
                ) {
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        onImageSelected(imageData.imageTitle, imageData.datetime)
                    }) {
                        Text(imageData.imageTitle)
                    }
                }
            }
        }

        selectedImage?.let {
            ImageDisplayScreen(
                bitmap = it,
                imageTitle = selectedImageTitle,
                datetime = selectedDatetime,
                onBack = onBack,
                onFit = onFit,
                isRefreshing = isRefreshing,
                onToggleRefresh = onToggleRefresh
            )
        }
    }
}

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        Image(
            bitmap = currentBitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .fillMaxSize()
                .pointerInput(drawMode) {
                    detectTransformGestures { _, pan, zoom, _ ->
                        if (!drawMode) {
                            scale *= zoom
                            offset = Offset(offset.x + pan.x, offset.y + pan.y)
                        }
                    }
                }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
        if (drawMode) {
            Canvas(modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { offset -> currentPathPoints = listOf(offset) },
                        onDragEnd = {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                            currentPathPoints = listOf()
                        },
                        onDrag = { change, _ ->
                            currentPathPoints = currentPathPoints + change.position
                            change.consume()
                        }
                    )
                }
            ) {
                for (path in drawingPaths) {
                    for (i in 1 until path.points.size) {
                        drawLine(
                            color = path.color,
                            start = path.points[i - 1],
                            end = path.points[i],
                            strokeWidth = 3f
                        )
                    }
                }
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(20.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    scope.launch {
                        val bitmapWithDrawing = mergeBitmapWithDrawing(currentBitmap, drawingPaths)
                        uploadBitmap(bitmapWithDrawing)
                    }
                }) {
                    Text("Upload")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

suspend fun mergeBitmapWithDrawing(bitmap: Bitmap, drawingPaths: List<DrawingPath>): Bitmap {
    return withContext(Dispatchers.Default) {
        val resultBitmap = bitmap.copy(Bitmap.Config.ARGB_8888, true)
        val canvas = Canvas(resultBitmap)
        val paint = Paint().apply {
            isAntiAlias = true
            style = Paint.Style.STROKE
            strokeWidth = 3f
        }

        drawingPaths.forEach { path ->
            paint.color = path.color.toArgb()
            for (i in 1 until path.points.size) {
                val startX = path.points[i - 1].x
                val startY = path.points[i - 1].y
                val stopX = path.points[i].x
                val stopY = path.points[i].y
                canvas.drawLine(startX, startY, stopX, stopY, paint)
            }
        }

        resultBitmap
    }
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
ImageData.kt
기존 코드에 변동사항 없습니다.

DatabaseHelper.kt
기존 코드에 변동사항 없습니다.

위 코드에서:

mergeBitmapWithDrawing 함수를 추가하여 현재 비트맵과 드로잉 경로를 합성합니다.
Canvas와 Paint를 사용하여 각 드로잉 경로를 비트맵에 그립니다.
Upload 버튼 클릭 시 mergeBitmapWithDrawing을 호출하여 드로잉이 포함된 비트맵을 생성한 후 이를 데이터베이스에 업로드합니다.
이제 Upload 버튼을 클릭하면 현재 화면에 그린 선이 포함된 비트맵이 데이터베이스에 저장됩니다.