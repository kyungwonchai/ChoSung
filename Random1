상태가 두 가지가 아니라 여러 가지일 수 있다면, 상태를 관리하는 방식과 유저 컨트롤의 디자인을 확장해야 합니다. 이러한 경우, **상태를 나타내는 열거형(enum)**을 사용하고, 각 상태에 대해 다른 색상이나 설명을 표시하도록 설정할 수 있습니다.

최적화된 접근 방법
열거형(enum)으로 상태 정의: 상태를 나타내는 열거형을 정의합니다.
유저 컨트롤 수정: 유저 컨트롤이 여러 상태를 표시할 수 있도록 수정합니다.
데이터 바인딩 사용: 상태에 따라 UI를 업데이트하도록 데이터 바인딩을 활용합니다.
1. 열거형으로 상태 정의
서비스 상태를 나타내는 열거형을 정의하여 각 상태를 명확하게 표현합니다.

ServiceStatusType.cs
csharp
코드 복사
namespace RouterMiddleACR.Models
{
    // 서비스 상태를 나타내는 열거형 정의
    public enum ServiceStatusType
    {
        Unknown,    // 상태를 알 수 없음
        Running,    // 서비스가 실행 중
        Stopped,    // 서비스가 중지됨
        Paused,     // 서비스가 일시 중지됨
        Error,      // 서비스에 오류 발생
        Restarting  // 서비스가 재시작 중
        // 필요한 다른 상태를 추가
    }
}
2. ServiceStatus 클래스 수정
상태를 열거형으로 관리하고, 상태에 따라 설명을 업데이트하도록 ServiceStatus 클래스를 수정합니다.

수정된 ServiceStatus.cs
csharp
코드 복사
using System.ComponentModel;

namespace RouterMiddleACR.Models
{
    public class ServiceStatus : INotifyPropertyChanged
    {
        private ServiceStatusType _status;
        private string _name;
        private string _description;

        public ServiceStatusType Status
        {
            get => _status;
            set
            {
                _status = value;
                OnPropertyChanged(nameof(Status));
                UpdateDescription(); // 상태에 따른 설명 업데이트
            }
        }

        public string Name
        {
            get => _name;
            set
            {
                _name = value;
                OnPropertyChanged(nameof(Name));
            }
        }

        public string Description
        {
            get => _description;
            set
            {
                _description = value;
                OnPropertyChanged(nameof(Description));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // 상태에 따른 설명 업데이트 메서드
        private void UpdateDescription()
        {
            switch (Status)
            {
                case ServiceStatusType.Running:
                    Description = "Running";
                    break;
                case ServiceStatusType.Stopped:
                    Description = "Stopped";
                    break;
                case ServiceStatusType.Paused:
                    Description = "Paused";
                    break;
                case ServiceStatusType.Error:
                    Description = "Error";
                    break;
                case ServiceStatusType.Restarting:
                    Description = "Restarting";
                    break;
                default:
                    Description = "Unknown";
                    break;
            }
        }
    }
}
3. 유저 컨트롤 수정
StatusIndicatorControl이 여러 상태를 표시할 수 있도록 수정하고, 상태에 따라 색상이나 설명을 업데이트합니다.

수정된 StatusIndicatorControl.xaml
xml
코드 복사
<UserControl x:Class="RouterMiddleACR.Controls.StatusIndicatorControl"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:mc="http://schemas.openxmlformats.org/markup-compatibility/2006"
             xmlns:d="http://schemas.microsoft.com/expression/blend/2008"
             mc:Ignorable="d"
             d:DesignHeight="100" d:DesignWidth="100">
    <StackPanel Orientation="Vertical" HorizontalAlignment="Center" VerticalAlignment="Center">
        <!-- 상태를 표시할 원형 도형 -->
        <Ellipse x:Name="IndicatorEllipse" Width="30" Height="30" Fill="Gray" />
        <!-- 상태명을 표시할 텍스트 블록 -->
        <TextBlock Text="{Binding StatusName}" FontSize="14" FontWeight="Bold" HorizontalAlignment="Center" Margin="5"/>
        <!-- 상태 설명을 표시할 텍스트 블록 -->
        <TextBlock Text="{Binding StatusDescription}" FontSize="12" HorizontalAlignment="Center" Margin="5"/>
    </StackPanel>
</UserControl>
수정된 StatusIndicatorControl.xaml.cs
csharp
코드 복사
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using RouterMiddleACR.Models;

namespace RouterMiddleACR.Controls
{
    public partial class StatusIndicatorControl : UserControl
    {
        public StatusIndicatorControl()
        {
            InitializeComponent();
        }

        public static readonly DependencyProperty StatusProperty =
            DependencyProperty.Register("Status", typeof(ServiceStatusType), typeof(StatusIndicatorControl), new PropertyMetadata(ServiceStatusType.Unknown, OnStatusChanged));

        public static readonly DependencyProperty StatusNameProperty =
            DependencyProperty.Register("StatusName", typeof(string), typeof(StatusIndicatorControl), new PropertyMetadata("Unknown"));

        public static readonly DependencyProperty StatusDescriptionProperty =
            DependencyProperty.Register("StatusDescription", typeof(string), typeof(StatusIndicatorControl), new PropertyMetadata(string.Empty));

        private static void OnStatusChanged(DependencyObject d, DependencyPropertyChangedEventArgs e)
        {
            var control = d as StatusIndicatorControl;
            if (control != null)
            {
                // 상태에 따라 색상 변경
                control.IndicatorEllipse.Fill = control.GetBrushForStatus((ServiceStatusType)e.NewValue);
            }
        }

        private Brush GetBrushForStatus(ServiceStatusType status)
        {
            // 상태에 따라 색상 반환
            switch (status)
            {
                case ServiceStatusType.Running:
                    return Brushes.Green;
                case ServiceStatusType.Stopped:
                    return Brushes.Red;
                case ServiceStatusType.Paused:
                    return Brushes.Yellow;
                case ServiceStatusType.Error:
                    return Brushes.DarkRed;
                case ServiceStatusType.Restarting:
                    return Brushes.Orange;
                default:
                    return Brushes.Gray;
            }
        }

        public ServiceStatusType Status
        {
            get => (ServiceStatusType)GetValue(StatusProperty);
            set => SetValue(StatusProperty, value);
        }

        public string StatusName
        {
            get => (string)GetValue(StatusNameProperty);
            set => SetValue(StatusNameProperty, value);
        }

        public string StatusDescription
        {
            get => (string)GetValue(StatusDescriptionProperty);
            set => SetValue(StatusDescriptionProperty, value);
        }
    }
}
4. MainViewModel에서 상태 관리 최적화
ObservableCollection을 사용하여 여러 서비스 상태를 관리하고, 데이터 바인딩을 활용하여 UI와 상호작용합니다.

수정된 MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using RouterMiddleACR.Models;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        // 서비스 상태를 관리하는 ObservableCollection
        public ObservableCollection<ServiceStatus> ServiceStatuses { get; }

        public MainViewModel()
        {
            ServiceStatuses = new ObservableCollection<ServiceStatus>
            {
                new ServiceStatus { Name = "Service 1", Status = ServiceStatusType.Unknown },
                new ServiceStatus { Name = "Service 2", Status = ServiceStatusType.Unknown },
                new ServiceStatus { Name = "Service 3", Status = ServiceStatusType.Unknown },
                // 필요한 만큼 더 추가 가능
            };
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        // 서비스 상태를 주기적으로 갱신하는 메서드
        public void UpdateServiceStatuses()
        {
            // 실제 서비스 상태를 확인하여 값을 업데이트
            // 예를 들어, ServiceController를 사용하여 서비스 상태를 확인하는 로직을 구현할 수 있음
            foreach (var serviceStatus in ServiceStatuses)
            {
                // 임의로 상태 변경 (실제 로직으로 대체 필요)
                serviceStatus.Status = ServiceStatusType.Running; // 예시: 상태를 변경
            }
        }
    }
}
설명과 주석
ServiceStatusType 열거형: 여러 상태를 정의하고 사용자가 명확히 이해할 수 있도록 합니다. 상태가 다양할 때 유용합니다.

ServiceStatus 클래스:

Status 속성은 ServiceStatusType 열거형을 사용하여 상태를 관리합니다.
UpdateDescription 메서드는 상태에 따라 설명을 업데이트합니다.
MainViewModel 클래스:

ObservableCollection<ServiceStatus>를 사용하여 여러 서비스 상태를 관리합니다.
UpdateServiceStatuses 메서드는 서비스 상태를 주기적으로 업데이트하는 예시를 제공합니다.
StatusIndicatorControl:

DependencyProperty를 사용하여 여러 상태를 바인딩합니다.
GetBrushForStatus 메서드는 상태에 따라 다른 색상을 반환하여 시각적으로 상태를 구분합니다.
이 최적화된 접근 방식은 다양한 상태




