약 data의 shape가 (2, 5)이고 슬라이싱 시 여전히 오류가 발생한다면, data의 실제 데이터 구조를 확인해야 합니다. shape는 (2, 5)로 표시되지만, 데이터가 numpy 배열이 아닌 다른 형식으로 처리될 가능성이 있습니다. 문제 해결을 위해 아래 절차를 따라주세요.

1. 데이터 형식 확인
data의 구조를 자세히 확인합니다. data가 numpy 배열인지 또는 pandas 데이터프레임인지, 리스트인지 확인해야 합니다.

python
코드 복사
# 데이터 형식 확인
print(type(data))
print(data)
출력 결과가 numpy.ndarray인지 확인하세요:

numpy 배열인 경우: 다음 단계로 진행.
numpy 배열이 아닌 경우: numpy 배열로 변환합니다:
python
코드 복사
data = np.array(data)
2. 슬라이싱 디버깅
슬라이싱 과정에서 디버깅 코드 추가
python
코드 복사
print("Data before slicing:")
print(data)
print(f"Shape: {data.shape}")

# 슬라이싱 시도
features = data[:, 2:5]
print("Sliced features:")
print(features)
위 코드를 실행하여 data[:, 2:5]가 작동하지 않는 이유를 파악합니다.

3. 수정된 슬라이싱 처리 코드
만약 슬라이싱에서 문제가 발생한다면, 데이터를 명시적으로 numpy 배열로 변환 후 슬라이싱을 수행합니다.

python
코드 복사
# numpy 배열로 강제 변환
if not isinstance(data, np.ndarray):
    data = np.array(data)

# 슬라이싱
features = data[:, 2:5]
actual_value = data[0, 1]
4. 최종 수정된 코드
아래는 문제 해결을 위한 전체 코드를 다시 작성한 것입니다:

python
코드 복사
# 저장된 모델 로드
try:
    model = joblib.load("best_model.pkl")
    print("Best model loaded successfully.")
except Exception as e:
    print(f"Error loading model: {e}")
    exit()

# PRealAandB 데이터 불러오기
data = fetch_data_from_db("PRealAandB")  # PRealAandB 저장 프로시저 호출

# 데이터 확인
print(f"Fetched data:\n{data}")
print(f"Data type: {type(data)}")
print(f"Data shape: {data.shape}")

# 데이터가 비어 있는지 확인
if data.size == 0:
    print("Error: No data fetched from PRealAandB.")
    exit()

# 데이터가 numpy 배열이 아닌 경우 배열로 변환
if not isinstance(data, np.ndarray):
    data = np.array(data)
    print("Converted to numpy array.")

# 데이터 준비
try:
    features = data[:, 2:5]  # 3~5열 (입력값)
    actual_value = data[0, 1]  # 2열 (실제값)
    print("Features and actual value extracted successfully.")
except Exception as e:
    print(f"Error during slicing: {e}")
    exit()

# 예측 수행
predicted_value = model.predict(features)[0]  # 예측값
print(f"Predicted value for column 2: {predicted_value}")
print(f"Actual value for column 2: {actual_value}")

# 시각화
plt.figure(figsize=(8, 6))

# 예측값과 실제값 시각화
plt.bar(["Predicted", "Actual"], [predicted_value, actual_value], color=['blue', 'red'], alpha=0.7)
plt.title("Predicted vs Actual Value for Column 2")
plt.ylabel("Value")
plt.grid(axis='y')

# 오차 표시
error = np.abs(predicted_value - actual_value)
plt.text(0, predicted_value, f"Pred: {predicted_value:.2f}", ha='center', va='bottom')
plt.text(1, actual_value, f"Actual: {actual_value:.2f}", ha='center', va='bottom')
plt.text(0.5, max(predicted_value, actual_value) + 0.1, f"Error: {error:.2f}", ha='center', color='black')

plt.show()

# 정확도 계산
max_possible_value = max(predicted_value, actual_value)
error_score = 100 - (error / max_possible_value * 100)
print(f"Accuracy Score: {error_score:.2f}/100")
추가 확인 사항
1. data의 데이터 타입
data가 numpy 배열인지 확인하세요. 만약 data가 데이터프레임, 리스트 또는 다른 형식이라면 numpy 배열로 변환해야 합니다.

2. fetch_data_from_db의 반환값
fetch_data_from_db 함수가 반환하는 데이터가 정상적으로 (2, 5) 크기인지 확인하세요.

python
코드 복사
# 반환값 디버깅
print(f"Returned data:\n{data}")
3. 데이터 확인 후 공유 요청
디버깅 후 아래 정보를 제공해 주시면 추가 지원을 드릴 수 있습니다:

data의 type 출력 결과.