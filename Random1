네, 요청하신 사항에 맞게 센서 데이터를 실시간으로 받아 UI와 연동하는 MVVM 모델의 코드를 작성해보겠습니다. 설명하신 규칙과 요구사항을 모두 반영하여, 센서 데이터를 R520부터 R530까지 (17개) 및 R540까지(총 18개)를 처리하고 상하 교체(비트 스왑) 규칙을 적용한 후, 실시간으로 UI에 반영하는 구조를 제시하겠습니다.

규칙 요약:
센서 데이터 범위: R520 ~ R540까지 총 18개 센서 데이터를 처리.
상하 교체: 4자리씩 데이터를 받으면, 각 데이터에서 상하 비트를 교체하여 처리.
실시간 연동: 데이터를 주기적으로 받아 MVVM 패턴으로 UI에 실시간 반영.
1. Model: SensorModel.cs
각 센서의 상태를 저장하는 Model 클래스입니다.

csharp
코드 복사
public class SensorModel
{
    public string SensorName { get; set; } // 예: R520, R521 등
    public bool IsDetected { get; set; }   // 감지 여부: true -> 빨간색, false -> 녹색
}
2. ViewModel: MainViewModel.cs
센서 데이터를 받아서 UI와 연동하는 역할을 합니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Threading.Tasks;

public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<SensorModel> Sensors { get; set; }
    private readonly SensorService _sensorService;

    public MainViewModel()
    {
        Sensors = new ObservableCollection<SensorModel>();
        _sensorService = new SensorService();
        InitializeSensors();

        // 주기적으로 데이터를 업데이트
        Task.Run(async () => await UpdateSensorDataAsync());
    }

    // 센서 목록 초기화 (R520 ~ R540)
    private void InitializeSensors()
    {
        for (int i = 0; i < 18; i++)
        {
            Sensors.Add(new SensorModel
            {
                SensorName = $"R{520 + i:X}",
                IsDetected = false // 초기 상태는 감지되지 않음
            });
        }
    }

    // 데이터를 주기적으로 받아서 센서 상태 업데이트
    private async Task UpdateSensorDataAsync()
    {
        while (true)
        {
            string response = await _sensorService.SendCommandAsync(); // PLC 데이터 수신
            if (response != null)
            {
                ParseResponseAndUpdateSensors(response);
            }
            await Task.Delay(1000); // 1초마다 업데이트
        }
    }

    // 응답 데이터를 파싱하고 센서 상태를 업데이트하는 메서드
    private void ParseResponseAndUpdateSensors(string response)
    {
        // 예: 응답 "%01$RC21840200040018"에서 R520~R540의 데이터를 추출
        if (response.StartsWith("%01$RC") && response.EndsWith("18"))
        {
            string[] wordData = new string[3];
            wordData[0] = response.Substring(6, 4); // R520~R52F의 데이터 (4자리)
            wordData[1] = response.Substring(10, 4); // R530~R53F의 데이터
            wordData[2] = response.Substring(14, 4); // R540까지의 데이터

            for (int i = 0; i < 3; i++)
            {
                UpdateSensorStates(wordData[i], i * 8); // 각 16비트를 8비트씩 상하교체
            }
        }
    }

    // 상하 교체 비트 처리 후 센서 상태 업데이트
    private void UpdateSensorStates(string wordData, int sensorStartIndex)
    {
        // 16진수를 2진수로 변환하고 상하 비트를 교체
        string swappedBinary = GetSwappedBinary(wordData);

        // 2진수로 변환된 값을 감지 여부에 따라 센서 상태에 반영
        for (int i = 0; i < swappedBinary.Length; i++)
        {
            Sensors[sensorStartIndex + i].IsDetected = swappedBinary[i] == '1';
        }

        OnPropertyChanged(nameof(Sensors)); // UI 갱신
    }

    // 상하 교체 비트 처리 함수
    private string GetSwappedBinary(string hex)
    {
        // 16진수를 2진수로 변환 (4자리 -> 16비트)
        string binary = Convert.ToString(Convert.ToInt32(hex, 16), 2).PadLeft(16, '0');

        // 상하 비트 교체: 앞의 8비트와 뒤의 8비트를 교체
        string swappedBinary = binary.Substring(8, 8) + binary.Substring(0, 8);

        return swappedBinary;
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
3. SensorService: PLC 데이터 송수신 처리
csharp
코드 복사
using System;
using System.Threading.Tasks;

public class SensorService
{
    // PLC에서 데이터를 수신하는 비동기 메서드
    public async Task<string> SendCommandAsync()
    {
        // PLC로부터 데이터를 수신하는 코드 (비동기 처리)
        await Task.Delay(500); // 예시로 지연 시간 추가 (실제 통신 대기 시간)
        return "%01$RC21840200040018"; // 예시 응답 데이터 (R520~R540의 데이터)
    }
}
4. View: MainWindow.xaml
센서 데이터를 UI에 실시간으로 표시하는 부분입니다.

xml
코드 복사
<Window x:Class="SensorApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Sensor Monitoring" Height="450" Width="800">
    <Grid>
        <ItemsControl ItemsSource="{Binding Sensors}">
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <StackPanel Orientation="Horizontal" Margin="5">
                        <!-- 센서 이름 표시 -->
                        <TextBlock Text="{Binding SensorName}" Width="50" VerticalAlignment="Center" />

                        <!-- 감지 상태를 도형으로 표시 (감지되면 빨간색, 감지되지 않으면 녹색) -->
                        <Ellipse Width="20" Height="20" 
                                 Fill="{Binding IsDetected, Converter={StaticResource BoolToColorConverter}}" />
                    </StackPanel>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
            <ItemsControl.ItemsPanel>
                <ItemsPanelTemplate>
                    <UniformGrid Columns="6" /> <!-- 18개의 센서를 3열에 나눠서 표시 -->
                </ItemsPanelTemplate>
            </ItemsControl.ItemsPanel>
        </ItemsControl>
    </Grid>
</Window>
5. BoolToColorConverter: 센서 감지 상태에 따른 색상 변환
센서의 감지 여부를 UI에서 빨간색/녹색으로 표시합니다.

csharp
코드 복사
using System;
using System.Globalization;
using System.Windows.Data;
using System.Windows.Media;

public class BoolToColorConverter : IValueConverter
{
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture)
    {
        bool isDetected = (bool)value;
        return isDetected ? Brushes.Red : Brushes.Green; // 감지되면 빨간색, 감지되지 않으면 녹색
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture)
    {
        throw new NotImplementedException();
    }
}
6. App.xaml: 리소스 등록
BoolToColorConverter를 리소스로 등록합니다.

xml
코드 복사
<Application x:Class="SensorApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             StartupUri="MainWindow.xaml">
    <Application.Resources>
        <local:BoolToColorConverter x:Key="BoolToColorConverter"/>
    </Application.Resources>
</Application>
설명:
센서 데이터 파싱 및 상하 교체: 응답 데이터에서 16진수 값을 받아 2진수로 변환한 후, 앞뒤 비트를 교체하는 방식으로 처리합니다. 이를 통해 각 센서의 감지 상태를 업데이트합니다.
센서 상태 UI 연동: 센서 데이터를 ObservableCollection으로 관리하며, PropertyChanged 이벤트를 통해 UI가 실시간으로 업데이트됩니다.
센서 감지 상태 표시: UI에서는 각 센서의 이름과 감지 여부를 **Ellipse(원)**로 표시하며, 감지 여부에 따라 빨간색/녹색으로 색상이 변경됩니다.
이 구조를 통해 **센서 데이터(R520~R540)**를 실시간으로 받아서 UI와 연동할 수 있습