네, 좋습니다! .NET Framework 4.6을 기준으로 SControl.Common 라이브러리부터 시작해서 SAgentM.App (WPF 에이전트)의 소스 코드를 순서대로 제공해 드리겠습니다.

1. SControl.Common 프로젝트 (.NET Framework 4.6)
이 프로젝트는 다른 프로젝트들 (SAgentM.App, SControlM)에서 공유될 핵심 로직과 데이터 모델을 포함합니다.

NuGet 패키지:
이 프로젝트 자체는 외부 라이브러리 의존성이 없을 수 있지만, CommandPacket 등을 JSON으로 직렬화/역직렬화하는 쪽 (SAgentM.App, SControlM)에서는 Newtonsoft.Json을 사용하게 됩니다.

SControl.Common.csproj (일부 내용 예시):

코드 스니펫

<Project ToolsVersion="15.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <PropertyGroup>
    <TargetFrameworkVersion>v4.6</TargetFrameworkVersion>
    </PropertyGroup>
  <ItemGroup>
    <Reference Include="System" />
    <Reference Include="System.Core" />
    <Reference Include="System.Xml.Linq" />
    <Reference Include="System.Data.DataSetExtensions" />
    <Reference Include="Microsoft.CSharp" />
    <Reference Include="System.Data" />
    <Reference Include="System.Net.Http" />
    <Reference Include="System.Xml" />
  </ItemGroup>
  <ItemGroup>
    <Compile Include="CommandPacket.cs" />
    <Compile Include="Enums.cs" />
    <Compile Include="LocalDeviceControl.cs" />
    <Compile Include="Payloads.cs" />
    <Compile Include="Properties\AssemblyInfo.cs" />
  </ItemGroup>
  </Project>
Enums.cs

C#

// SControl.Common/Enums.cs
namespace SControl.Common
{
    public enum CommandInstruction
    {
        DirectExecute,
        RelayToTarget
    }

    public static class CommandNames
    {
        public const string MonitorControl = "MONITOR_CONTROL";
        // 예시: public const string SystemShutdown = "SYSTEM_SHUTDOWN";
    }

    public enum MonitorAction
    {
        On = -1,
        Standby = 1,
        Off = 2
    }
}
Payloads.cs

C#

// SControl.Common/Payloads.cs
namespace SControl.Common
{
    public class MonitorControlPayload
    {
        public MonitorAction Action { get; set; }
    }

    public class GenericResponsePayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string ErrorCode { get; set; } // 선택적 오류 코드
        public object Data { get; set; }      // 선택적 추가 데이터
    }

    // --- 다른 명령 페이로드 예시 ---
    // public class SystemShutdownPayload
    // {
    //     public int DelaySeconds { get; set; }
    //     public bool ForceShutdown { get; set; }
    // }
}
CommandPacket.cs

C#

// SControl.Common/CommandPacket.cs
using System;

namespace SControl.Common
{
    public class CommandPacket
    {
        public Guid PacketId { get; set; }
        public CommandInstruction Instruction { get; set; }
        public string CommandName { get; set; }
        public string PayloadJson { get; set; } // Newtonsoft.Json으로 직렬화된 JSON 문자열

        public string FinalTargetIpForRelayedCommand { get; set; }
        public int? FinalTargetPortForRelayedCommand { get; set; }

        public DateTime TimestampUtc { get; set; }

        public string ResponseAddress { get; set; }
        public int? ResponsePort { get; set; }

        public CommandPacket()
        {
            PacketId = Guid.NewGuid();
            TimestampUtc = DateTime.UtcNow;
        }
    }
}
LocalDeviceControl.cs

C#

// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception

namespace SControl.Common
{
    public static class LocalDeviceControl
    {
        private const int HWND_BROADCAST = 0xFFFF;
        private const uint WM_SYSCOMMAND = 0x0112;
        private const uint SC_MONITORPOWER = 0xF170;

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,
            uint Msg,
            UIntPtr wParam,
            IntPtr lParam,
            SendMessageTimeoutFlags fuFlags,
            uint uTimeout,
            out UIntPtr lpdwResult);

        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,
            SMTO_BLOCK = 0x1,
            SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8,
            SMTO_ERRORONEXIT = 0x20
        }

        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException("action", "유효하지 않은 MonitorAction 값입니다.");
            }

            IntPtr lParam = (IntPtr)action;
            UIntPtr commandResult;

            IntPtr apiResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,
                WM_SYSCOMMAND,
                (UIntPtr)SC_MONITORPOWER,
                lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, // 1초 타임아웃
                out commandResult);

            if (apiResult == IntPtr.Zero)
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0)
                {
                    throw new Win32Exception(errorCode, string.Format("모니터 상태 변경 실패 (동작:{0}). Win32 오류 코드: {1}", action, errorCode));
                }
            }
        }
    }
}
Properties/AssemblyInfo.cs (기본 생성된 내용에서 수정 필요 없음)

코드 스니펫

// SControl.Common/Properties/AssemblyInfo.cs
using System.Reflection;
using System.Runtime.CompilerServices;
using System.Runtime.InteropServices;

// 어셈블리에 대한 일반 정보는 다음 특성 집합을 통해 
// 제어됩니다. 어셈블리와 관련된 정보를 수정하려면
// 이러한 특성 값을 변경하세요.
[assembly: AssemblyTitle("SControl.Common")]
[assembly: AssemblyDescription("SControl Common Library")]
[assembly: AssemblyConfiguration("")]
[assembly: AssemblyCompany("")] // 회사 이름
[assembly: AssemblyProduct("SControl.Common")]
[assembly: AssemblyCopyright("Copyright ©  2025")] // 현재 연도로 변경
[assembly: AssemblyTrademark("")]
[assembly: AssemblyCulture("")]

// ComVisible을 false로 설정하면 이 어셈블리의 형식이 COM 구성 요소에 
// 표시되지 않습니다. COM에서 이 어셈블리의 형식에 액세스하려면
// 해당 형식에 대해 ComVisible 특성을 true로 설정하세요.
[assembly: ComVisible(false)]

// 이 프로젝트가 COM에 노출되는 경우 다음 GUID는 typelib의 ID를 나타냅니다.
[assembly: Guid("여기에-고유-guid-넣기")] // 프로젝트 생성 시 자동으로 GUID가 할당됩니다.

// 어셈블리의 버전 정보는 다음 네 가지 값으로 구성됩니다.
//
//      주 버전
//      부 버전 
//      빌드 번호
//      수정 버전
//
// 모든 값을 지정하거나 아래와 같이 '*'를 사용하여 빌드 번호 및 수정 번호를
// 기본값으로 할 수 있습니다.
// [assembly: AssemblyVersion("1.0.*")]
[assembly: AssemblyVersion("1.0.0.0")]
[assembly: AssemblyFileVersion("1.0.0.0")]
참고: AssemblyInfo.cs의 Guid는 프로젝트 생성 시 자동으로 부여되므로, 실제 값으로 대체해야 합니다.
