, 요청하신 대로 각 작업을 인터페이스를 통해 관리하는 방식으로 리팩터링한 TaskModel 코드를 제공해드리겠습니다.

1. 작업 인터페이스 정의 (ITaskAction)
우선, 각 작업을 처리할 인터페이스를 만듭니다.

csharp
코드 복사
public interface ITaskAction
{
    Task ExecuteAsync();  // 비동기 작업 실행 메서드
    string GetTaskName();  // 작업 이름을 반환
}
2. 구체적인 작업 클래스들
인터페이스를 구현하는 구체적인 작업들을 정의합니다. 아래는 TaskA, TaskB 등의 작업 클래스 예시입니다.

csharp
코드 복사
public class TaskA : ITaskAction
{
    public async Task ExecuteAsync()
    {
        await Task.Delay(1000);  // Task A 수행 로직
    }

    public string GetTaskName()
    {
        return "Task A";
    }
}

public class TaskB : ITaskAction
{
    public async Task ExecuteAsync()
    {
        await Task.Delay(1500);  // Task B 수행 로직
    }

    public string GetTaskName()
    {
        return "Task B";
    }
}

public class TaskC : ITaskAction
{
    public async Task ExecuteAsync()
    {
        await Task.Delay(2000);  // Task C 수행 로직
    }

    public string GetTaskName()
    {
        return "Task C";
    }
}

// 필요시 더 많은 작업 클래스들을 동일한 방식으로 구현
3. TaskModel 클래스 (인터페이스 기반으로 리팩터링)
이제 TaskModel에서 인터페이스를 활용하여 작업을 관리하고 실행하는 방식으로 수정합니다.

csharp
코드 복사
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }   // 물류표 번호
    public string PO_NO { get; set; }    // 주문 번호

    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }  // 함수 상태 리스트
    public string Status { get; set; }   // 전체 작업 상태 (Pending, Running, Completed)

    private Stopwatch _stopwatch;  // 전체 작업 시간 측정용

    // 총 소요 시간을 표시할 컬럼
    private int _totalSeconds;
    public int TotalSeconds
    {
        get => _totalSeconds;
        set
        {
            _totalSeconds = value;
            OnPropertyChanged(nameof(TotalSeconds));
        }
    }

    public TaskModel()
    {
        FunctionStatusList = new ObservableCollection<FunctionStatus>();  // 함수 상태 리스트 초기화
        Status = "Pending";  // 기본 상태 (대기 중)
        _stopwatch = new Stopwatch();  // 총 작업 시간 측정을 위한 스톱워치 초기화

        // 시퀀스 플래그에 따라 작업 초기화
        InitializeFunctions(1);  // SequenceFlag = 1 (예시)
    }

    // 시퀀스 플래그에 따라 작업을 초기화하고, 함수 이름, 함수 로직, 초기 색상을 설정
    private void InitializeFunctions(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                AddFunction(new TaskA(), Brushes.Gray);
                AddFunction(new TaskB(), Brushes.Gray);
                AddFunction(new TaskC(), Brushes.Gray);
                break;
            case 2:
                AddFunction(new TaskC(), Brushes.Gray);
                AddFunction(new TaskB(), Brushes.Gray);
                AddFunction(new TaskD(), Brushes.Gray);
                break;
            case 3:
                AddFunction(new TaskA(), Brushes.Gray);
                AddFunction(new TaskB(), Brushes.Gray);
                AddFunction(new TaskE(), Brushes.Gray);
                break;
        }
    }

    // 함수를 추가하는 메서드 (작업 클래스, 초기 색상)
    public void AddFunction(ITaskAction taskAction, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(taskAction.GetTaskName(), taskAction.ExecuteAsync, initialColor);
        FunctionStatusList.Add(functionStatus);  // 리스트에 추가
    }

    // 전체 작업을 순차적으로 실행
    public async Task StartTask()
    {
        _stopwatch.Restart();  // 작업 시작 시간 기록
        Status = "Running";    // 상태를 Running으로 변경
        await ExecuteTaskSequence();  // 작업 실행
        Status = "Completed";  // 작업 완료
        TotalSeconds = (int)_stopwatch.Elapsed.TotalSeconds;  // 총 소요 시간을 기록
        _stopwatch.Stop();     // 스톱워치 멈춤
    }

    // 각 작업을 순차적으로 실행하고, 상태 색상 및 실행 시간을 업데이트
    private async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            Stopwatch functionStopwatch = new Stopwatch();  // 각 함수의 시간 측정용 스톱워치
            functionStopwatch.Start();  // 함수 시작 시간 기록

            // 각 작업의 상태를 업데이트하며 실행
            await ExecuteTaskWithColor(FunctionStatusList.IndexOf(functionStatus), functionStatus.Task);

            functionStopwatch.Stop();  // 함수 종료 시간 기록
            functionStatus.ExecutionTime = $"{functionStopwatch.Elapsed.TotalSeconds:F2} seconds";  // 실행 시간을 기록
        }
    }

    // 작업을 실행하면서 도형의 색상을 업데이트 (실행 중 -> 완료)
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        // 작업 시작 시 색상을 변경 (진행 중 색상)
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.SkyBlue);
        });

        await task();  // 작업 실행

        // 작업 완료 시 색상을 변경 (완료 색상)
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusList[index].UpdateStatus(Brushes.Green);
        });
    }
}
4. 동작 설명
ITaskAction 인터페이스를 통해 모든 작업 클래스는 ExecuteAsync 메서드를 반드시 구현해야 하며, 이를 통해 작업 실행을 할 수 있습니다.
**InitializeFunctions**에서 TaskA, TaskB 등의 작업을 추가할 때 ITaskAction 인터페이스를 구현한 클래스를 사용해 추가합니다.
이렇게 하면 각 작업의 이름, 함수 로직, 초기 색상을 함께 관리할 수 있습니다.
인터페이스를 활용하면 작업을 추가하거나 관리할 때 코드 중복이 줄어들고 더 유연하게 작업을 관리할 수 있습니다.
이 방식은 작업을 인터페이스를 통해 관리함으로써 코드의 가독성과 확장성을 크게 개선합니다.