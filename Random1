네, 정말 죄송합니다. 제가 여러 번의 수정 요청을 처리하는 과정에서 코드 버전을 혼동하여 SaveChanges 재정의(override)가 제거된 LockerDbContext.cs 파일을 잘못 드렸습니다. 로그 기록 기능(특히 추가 로그 누락 문제)과 DB 기반 비밀번호 저장 기능을 모두 구현하려면 DbContext의 SaveChanges 재정의 방식을 사용하면서 AppSettings 테이블을 위한 DbSet을 추가하는 것이 맞습니다.

인터셉터 방식은 잊으시고, 아래는 로그 기록을 위한 SaveChanges 재정의 로직과 DbSet<AppSetting> 이 올바르게 포함된 LockerDbContext.cs 파일의 최종 수정본 코드(주석 제외)입니다.

수정해야 할 파일 목록:

Data/LockerDbContext.cs
Data/LockerDbContext.cs (수정 - SaveChanges 재정의 복원, DbSet<AppSetting> 추가)

C#

// FILE_ID: Data/LockerDbContext_20250410110000
using LockerManagementApp.Models;
using System;
using System.Collections.Generic;
using System.Configuration;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Data.Entity.Validation;
using System.Linq;
using System.Threading.Tasks;
using Newtonsoft.Json;
using System.Diagnostics;
using System.Data.SqlClient;
using System.Data.Entity.Core;
using System.Threading;
using System.ComponentModel.DataAnnotations.Schema;

namespace LockerManagementApp.Data
{
    public class LockerDbContext : DbContext
    {
        public DbSet<LockerAssignment> LockerAssignments { get; set; }
        public DbSet<AuditLog> AuditLogs { get; set; }
        public DbSet<LockerType> LockerTypes { get; set; }
        public DbSet<Floor> Floors { get; set; }
        public DbSet<Zone> Zones { get; set; }
        public DbSet<SubPart> SubParts { get; set; }
        public DbSet<Administrator> Administrators { get; set; }
        public DbSet<AppSetting> AppSettings { get; set; } // AppSetting DbSet 추가

        private const string ConnectionStringName = "LockerDbConnection";

        // IsMasterSave 속성 제거됨

        public LockerDbContext() : base(GetConnectionString())
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] LockerDbContext instance created.");
        }

        private static string GetConnectionString()
        {
            try { var cs = ConfigurationManager.ConnectionStrings[ConnectionStringName]; if (cs == null || string.IsNullOrWhiteSpace(cs.ConnectionString)) throw new ConfigurationErrorsException($"App.config에서 '{ConnectionStringName}' 연결 문자열 없음/비어있음."); Debug.WriteLine($"ConnectionString '{ConnectionStringName}' 로드 성공."); return cs.ConnectionString; }
            catch (ConfigurationErrorsException confEx) { Debug.WriteLine($"!!! 설정 파일 오류: {confEx.ToString()}"); throw new Exception("App.config 설정 오류.", confEx); }
            catch (Exception ex) { Debug.WriteLine($"!!! 연결 문자열 로드 중 예외: {ex.ToString()}"); throw new Exception($"App.config 연결 문자열 읽기 오류.", ex); }
        }

        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            modelBuilder.Entity<LockerAssignment>().Property(p => p.UserName).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.KnoxId).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.SubPart).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Administrator).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.TransferStatus).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Details).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Remarks).IsOptional();
            modelBuilder.Entity<LockerAssignment>().Property(p => p.Notes).IsOptional();

            modelBuilder.Entity<AppSetting>().HasKey(s => s.SettingKey); // AppSetting 키 설정

            base.OnModelCreating(modelBuilder);
        }

        protected override DbEntityValidationResult ValidateEntity(DbEntityEntry entityEntry, IDictionary<object, object> items)
        {
            var result = base.ValidateEntity(entityEntry, items);
            if (entityEntry.Entity is LockerAssignment assignment && (entityEntry.State == EntityState.Added || entityEntry.State == EntityState.Modified)) { var userNameErrors = result.ValidationErrors.Where(err => err.PropertyName == nameof(LockerAssignment.UserName) && string.IsNullOrWhiteSpace(assignment.UserName)).ToList(); if (userNameErrors.Any()) { Debug.WriteLine($"경고: LockerAssignment(ID:{assignment.Id})의 UserName 필수 오류 무시."); foreach (var error in userNameErrors) { result.ValidationErrors.Remove(error); } } }
            return result;
        }

        #region SaveChanges Overrides for Audit Logging (재정의 방식 복원 및 수정)

        public override int SaveChanges()
        {
            Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 시작...");
            List<AuditLog> auditEntries = null;
            try
            {
                auditEntries = CreateAuditEntries();
                Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}");
            }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    this.AuditLogs.AddRange(auditEntries);
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); }
            }
            else { Debug.WriteLine("  -> 추가할 로그 없음."); }

            try
            {
                Debug.WriteLine($"  -> base.SaveChanges() 호출 시도...");
                var result = base.SaveChanges(); // 원본 변경 + 로그 동시 저장
                Debug.WriteLine($"  -> base.SaveChanges() 완료. 결과 = {result}");
                return result;
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChanges 중 일반 오류 (동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChanges(동기) Override 종료."); }
        }

        public override async Task<int> SaveChangesAsync(CancellationToken cancellationToken)
        {
             Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(CancellationToken) Override 시작...");
             List<AuditLog> auditEntries = null;
            try
            {
                auditEntries = CreateAuditEntries();
                Debug.WriteLine($"  -> 생성된 로그 수 = {auditEntries?.Count ?? 0}");
            }
            catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 생성 중 오류 발생: {ex.ToString()}"); }

            if (auditEntries != null && auditEntries.Any())
            {
                try
                {
                    this.AuditLogs.AddRange(auditEntries);
                    Debug.WriteLine($"  -> 로그 {auditEntries.Count}개 AddRange 완료.");
                }
                catch (Exception ex) { Debug.WriteLine($"!!! 감사 로그 AddRange 중 오류 발생: {ex.ToString()}"); }
            }
             else { Debug.WriteLine("  -> 추가할 로그 없음."); }

            try
            {
                Debug.WriteLine($"  -> base.SaveChangesAsync(cancellationToken) 호출 시도...");
                var result = await base.SaveChangesAsync(cancellationToken); // 원본 변경 + 로그 동시 저장 + CancellationToken 전달
                Debug.WriteLine($"  -> base.SaveChangesAsync(cancellationToken) 완료. 결과 = {result}");
                return result;
            }
            catch (DbEntityValidationException vex) { LogValidationErrors(vex); throw; }
            catch (DbUpdateException dbEx) { LogDbUpdateException(dbEx); throw; }
            catch (OperationCanceledException) { Debug.WriteLine("SaveChangesAsync(CancellationToken) 작업 취소됨."); throw; }
            catch (Exception ex) { Debug.WriteLine($"!!! SaveChangesAsync(CancellationToken) 중 일반 오류 (비동기): {ex.ToString()}"); throw; }
            finally { Debug.WriteLine($"[{DateTime.Now:HH:mm:ss.fff}] SaveChangesAsync(CancellationToken) Override 종료."); }
        }

        private List<AuditLog> CreateAuditEntries()
        {
            Debug.WriteLine("  CreateAuditEntries 시작...");
            string currentUserName = System.Threading.Thread.CurrentPrincipal?.Identity?.Name ?? "UnknownUser";
            var auditEntries = new List<AuditLog>();
            var changedEntries = ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged && e.State != EntityState.Detached).ToList();

            if (!changedEntries.Any()) { Debug.WriteLine("  CreateAuditEntries: 감지된 변경 엔티티 없음."); return auditEntries; }

            Debug.WriteLine($"  CreateAuditEntries: 감지된 변경 엔티티 수 = {changedEntries.Count}");
            var jsonSettings = new JsonSerializerSettings { ReferenceLoopHandling = ReferenceLoopHandling.Ignore, PreserveReferencesHandling = PreserveReferencesHandling.None, Formatting = Formatting.None };

            foreach (var entry in changedEntries)
            {
                if (entry.Entity is AuditLog) { Debug.WriteLine("    - AuditLog 엔티티 변경 감지됨 (로깅 건너뜀)."); continue; }

                var auditEntry = new AuditLog { Timestamp = DateTime.Now, UserName = currentUserName, TableName = entry.Entity.GetType().Name, Action = entry.State.ToString() };
                try { auditEntry.RecordId = entry.State == EntityState.Deleted ? entry.OriginalValues["Id"]?.ToString() : entry.CurrentValues["Id"]?.ToString() ?? "N/A"; } catch (Exception ex) { Debug.WriteLine($"    - 감사 로그: 'Id' PK 조회 실패 ({auditEntry.TableName}) - {ex.Message}"); auditEntry.RecordId = "PK Error"; }
                var oldValues = new Dictionary<string, object>(); var newValues = new Dictionary<string, object>(); var affectedColumns = new List<string>();
                if (entry.State == EntityState.Added) { foreach (var pn in entry.CurrentValues.PropertyNames) newValues[pn] = entry.CurrentValues[pn]; try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Added 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Deleted) { foreach (var pn in entry.OriginalValues.PropertyNames) oldValues[pn] = entry.OriginalValues[pn]; try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Deleted 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } }
                else if (entry.State == EntityState.Modified) { bool propertyChanged = false; foreach (var pn in entry.OriginalValues.PropertyNames) { var ov = entry.OriginalValues[pn]; var cv = entry.CurrentValues[pn]; if (!Equals(ov, cv)) { propertyChanged = true; affectedColumns.Add(pn); oldValues[pn] = ov; newValues[pn] = cv; } } if (propertyChanged) { auditEntry.AffectedColumns = string.Join(",", affectedColumns); try { auditEntry.OldValues = JsonConvert.SerializeObject(oldValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified Old 직렬화 오류: {serEx.Message}"); auditEntry.OldValues = "Serialization Error"; } try { auditEntry.NewValues = JsonConvert.SerializeObject(newValues, jsonSettings); } catch (Exception serEx) { Debug.WriteLine($"    !!! 감사 로그 Modified New 직렬화 오류: {serEx.Message}"); auditEntry.NewValues = "Serialization Error"; } } else { Debug.WriteLine($"    - 엔티티 {auditEntry.TableName} (ID: {auditEntry.RecordId})는 Modified 상태지만 실제 값 변경 없음. 로그 건너뜀."); continue; } }
                auditEntries.Add(auditEntry);
                Debug.WriteLine($"    - 로그 생성됨: {auditEntry.TableName}, Action: {auditEntry.Action}, RecordId: {auditEntry.RecordId}");
            }
            UpdateLockerAssignmentTimestamps(changedEntries);
            Debug.WriteLine("  CreateAuditEntries 종료.");
            return auditEntries;
        }
        private void UpdateLockerAssignmentTimestamps(List<DbEntityEntry> changedEntries) { var lockerEntries = changedEntries.Where(e => e.Entity is LockerAssignment && (e.State == EntityState.Added || e.State == EntityState.Modified)); int count = 0; foreach (var entry in lockerEntries) { ((LockerAssignment)entry.Entity).LastUpdated = DateTime.Now; count++; } if (count > 0) Debug.WriteLine($"UpdateLockerAssignmentTimestamps: {count}개 LockerAssignment 타임스탬프 업데이트됨."); }

        #endregion

        #region Error Logging Helpers
        private void LogDbUpdateException(DbUpdateException dbEx) { Debug.WriteLine($"!!! DbUpdateException 발생: {dbEx.ToString()}"); if (dbEx.InnerException != null) Debug.WriteLine($"  InnerException: {dbEx.InnerException.ToString()}"); foreach (var entry in dbEx.Entries) { Debug.WriteLine($"  - 오류 엔티티: {entry.Entity.GetType().Name}, 상태: {entry.State}"); } }
        private void LogValidationErrors(DbEntityValidationException vex) { Debug.WriteLine($"!!! DbEntityValidationException 발생: {vex.Message}"); foreach (var validationErrors in vex.EntityValidationErrors) { Debug.WriteLine($"  - 엔티티 타입: {validationErrors.Entry.Entity.GetType().Name}, 상태: {validationErrors.Entry.State}"); foreach (var validationError in validationErrors.ValidationErrors) { Debug.WriteLine($"    - 속성: {validationError.PropertyName}, 오류: {validationError.ErrorMessage}"); } } }
        #endregion
    }
}
핵심 변경 사항:

DbSet<AppSetting> 추가: 데이터베이스의 AppSettings 테이블과 매핑될 DbSet 속성을 추가했습니다.
OnModelCreating 수정: AppSetting 모델의 기본 키(SettingKey)를 Fluent API로 설정하는 코드를 추가했습니다.
SaveChanges/SaveChangesAsync 재정의 복원: 인터셉터 방식 대신 이 메서드들을 재정의하여 로그를 기록하는 방식으로 복원했습니다. 로직은 로그 생성(CreateAuditEntries) -> 로그 추가(AddRange) -> 단일 base.SaveChanges() 호출 순서입니다.
IsMasterSave 속성 및 관련 로직 제거: 인터셉터 방식에서 사용했던 IsMasterSave 속성과 SaveChanges 메서드의 bool isMaster 파라미터를 제거했습니다. (사용자 구분은 현재 Thread.CurrentPrincipal만 사용합니다. 필요 시 다른 방식으로 구현해야 합니다.)
CreateAuditEntries 수정: AuditLog 엔티티 자체는 로그 대상에서 제외하는 필터 로직(if (entry.Entity is AuditLog) continue;)을 루프 시작 부분에 명확히 두어 무한 루프 가능성을 최소화했습니다.
이제 이 DbContext를 사용하면 SaveChanges가 호출될 때마다 재정의된 메서드가 실행되어 로그 기록을 시도할 것입니다. 다음 단계로 이 DbContext를 사용하는 ViewModel(MainViewModel, MasterDataViewModel)에서 SaveChangesAsync 호출 시 불필요한 isMaster 플래그 전달 코드를 제거해야 합니다.

