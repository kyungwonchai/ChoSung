겠습니다. 요청하신 서비스 구현 클래스 4개 (ApiMemoService, MockMemoService, SignalRNotificationService, DialogService)의 초기 코드를 .NET Framework 4.8 호환(C# 7.3 기준) 및 MemoAppMGSP 네임스페이스 기준으로 작성하여 드리겠습니다.

주의: 이 코드들은 실제 완전한 구현이 아니며, 각 서비스의 기본 구조와 인터페이스 구현 형태를 보여주는 템플릿입니다. 실제 기능을 위해서는 // TODO: 주석 부분을 실제 로직으로 채우고, 필요한 NuGet 패키지(예: HttpClient, Newtonsoft.Json, Microsoft.AspNetCore.SignalR.Client)를 설치해야 합니다.

22. 스물두 번째 파일: Services/Implementations/ApiMemoService.cs

IMemoService 인터페이스를 구현하며, 실제 백엔드 Web API와 HTTP 통신하여 메모 데이터를 처리하는 클래스입니다.

C#

// MemoAppMGSP/Services/Implementations/ApiMemoService.cs
using MemoAppMGSP.Models;
using MemoAppMGSP.Services.Interfaces;
using Newtonsoft.Json; // Newtonsoft.Json NuGet 패키지 필요
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.Net.Http; // System.Net.Http NuGet 패키지 또는 .NET Framework 참조 필요
using System.Net.Http.Headers;
using System.Text;
using System.Threading.Tasks;

namespace MemoAppMGSP.Services.Implementations
{
    /// <summary>
    /// 백엔드 API 서버와 통신하여 IMemoService 기능을 구현합니다.
    /// </summary>
    public class ApiMemoService : IMemoService
    {
        private readonly HttpClient _httpClient;
        private readonly string _apiBaseUrl; // 예: "http://yourserver.com/api"

        /// <summary>
        /// ApiMemoService의 새 인스턴스를 초기화합니다.
        /// HttpClient 인스턴스와 API 기본 URL을 주입받는 것이 좋습니다.
        /// </summary>
        /// <param name="httpClient">HTTP 통신을 위한 HttpClient</param>
        /// <param name="apiBaseUrl">백엔드 API의 기본 주소</param>
        public ApiMemoService(HttpClient httpClient, string apiBaseUrl)
        {
            _httpClient = httpClient ?? throw new ArgumentNullException(nameof(httpClient));
            _apiBaseUrl = apiBaseUrl ?? throw new ArgumentNullException(nameof(apiBaseUrl));

            // 기본 헤더 설정 (필요 시)
            _httpClient.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
            // TODO: 인증 토큰이 필요하다면 여기에 추가 (예: Authorization 헤더)
            // _httpClient.DefaultRequestHeaders.Authorization = new AuthenticationHeaderValue("Bearer", "your_token");
        }

        public async Task<IEnumerable<UserMemoInfo>> GetUserMemosWithStatusAsync(Guid userId)
        {
            string requestUri = $"{_apiBaseUrl}/memos/user/{userId}"; // API 엔드포인트 확인 필요
            try
            {
                HttpResponseMessage response = await _httpClient.GetAsync(requestUri);
                if (response.IsSuccessStatusCode)
                {
                    string jsonResponse = await response.Content.ReadAsStringAsync();
                    // API가 UserMemoInfo 리스트를 반환한다고 가정
                    var userMemos = JsonConvert.DeserializeObject<List<UserMemoInfo>>(jsonResponse);
                    return userMemos ?? new List<UserMemoInfo>();
                }
                else
                {
                    // TODO: API 오류 처리 (로깅 등)
                    Debug.WriteLine($"API Error: {response.StatusCode} - {await response.Content.ReadAsStringAsync()}");
                    return new List<UserMemoInfo>(); // 또는 예외 발생
                }
            }
            catch (Exception ex)
            {
                // TODO: 네트워크 오류 등 예외 처리 (로깅 등)
                Debug.WriteLine($"Network/Deserialization Error: {ex.Message}");
                return new List<UserMemoInfo>(); // 또는 예외 발생
            }
        }

        public async Task<Memo> GetMemoByIdAsync(Guid memoId)
        {
            string requestUri = $"{_apiBaseUrl}/memos/{memoId}"; // API 엔드포인트 확인 필요
            try
            {
                 HttpResponseMessage response = await _httpClient.GetAsync(requestUri);
                if (response.IsSuccessStatusCode)
                {
                    string jsonResponse = await response.Content.ReadAsStringAsync();
                    return JsonConvert.DeserializeObject<Memo>(jsonResponse);
                }
                // ... 오류 처리 ...
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ }
            return null; // 실패 시 null 반환
        }


        public async Task<bool> CreateMemoAsync(Memo memo)
        {
            string requestUri = $"{_apiBaseUrl}/memos"; // API 엔드포인트 확인 필요
            try
            {
                string jsonPayload = JsonConvert.SerializeObject(memo);
                HttpContent content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await _httpClient.PostAsync(requestUri, content);
                // TODO: API가 성공 시 201 Created 등을 반환한다고 가정, 필요 시 상세 응답 처리
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex)
            {
                // ... 예외 처리 ...
                return false;
            }
        }

        public async Task<bool> UpdateMemoAsync(Memo memo)
        {
            string requestUri = $"{_apiBaseUrl}/memos/{memo.Id}"; // API 엔드포인트 확인 필요
            try
            {
                string jsonPayload = JsonConvert.SerializeObject(memo);
                HttpContent content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await _httpClient.PutAsync(requestUri, content);
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ return false; }
        }

        public async Task<bool> MarkMemoAsReadAsync(Guid userId, Guid memoId, bool isRead)
        {
            // API 엔드포인트 설계 필요 (예: PUT /api/usermemos/{userId}/{memoId}/read)
            string requestUri = $"{_apiBaseUrl}/usermemos/{userId}/{memoId}/read";
            try
            {
                 // isRead 상태를 본문에 담아 전송 (API 설계에 따라 다름)
                var payload = new { IsRead = isRead };
                string jsonPayload = JsonConvert.SerializeObject(payload);
                HttpContent content = new StringContent(jsonPayload, Encoding.UTF8, "application/json");

                HttpResponseMessage response = await _httpClient.PutAsync(requestUri, content); // 또는 PATCH
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ return false; }
        }

        public async Task<bool> SetPersonalStatusAsync(Guid userId, Guid memoId, bool isPersonal)
        {
            // API 엔드포인트 설계 필요 (예: PUT /api/usermemos/{userId}/{memoId}/personal)
            string requestUri = $"{_apiBaseUrl}/usermemos/{userId}/{memoId}/personal";
            try
            {
                var payload = new { IsPersonal = isPersonal };
                // ... PUT 또는 PATCH 요청 ...
                await Task.Delay(10); // 임시
                return true; // 임시 반환
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ return false; }
        }

        public async Task<bool> MarkMemoAsDeletedByReceiverAsync(Guid userId, Guid memoId)
        {
            // API 엔드포인트 설계 필요 (예: DELETE /api/usermemos/{userId}/{memoId})
            string requestUri = $"{_apiBaseUrl}/usermemos/{userId}/{memoId}";
            try
            {
                HttpResponseMessage response = await _httpClient.DeleteAsync(requestUri); // 또는 PUT/PATCH
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ return false; }
        }

        public async Task<bool> MarkMemoAsDeletedBySenderAsync(Guid senderId, Guid memoId)
        {
            // API 엔드포인트 설계 필요 (예: DELETE /api/memos/{memoId}/senderdelete)
            string requestUri = $"{_apiBaseUrl}/memos/{memoId}/senderdelete?senderId={senderId}"; // 권한 확인용 senderId 전달 방식 고려
             try
            {
                HttpResponseMessage response = await _httpClient.DeleteAsync(requestUri); // 또는 PUT/PATCH
                return response.IsSuccessStatusCode;
            }
            catch (Exception ex) { /* ... 예외 처리 ... */ return false; }
        }
    }
}
23. 스물세 번째 파일: Services/Implementations/MockMemoService.cs

IMemoService 인터페이스를 구현하며, 실제 서버 통신 없이 메모리에 임시 데이터를 사용하여 기능을 흉내 내는 클래스입니다. 개발 초기나 테스트 시 유용합니다.

C#

// MemoAppMGSP/Services/Implementations/MockMemoService.cs
using MemoAppMGSP.Models;
using MemoAppMGSP.Services.Interfaces;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks; // Task 사용

namespace MemoAppMGSP.Services.Implementations
{
    /// <summary>
    /// 개발 및 테스트 목적으로 IMemoService의 기능을 메모리 내 데이터로 흉내 냅니다.
    /// </summary>
    public class MockMemoService : IMemoService
    {
        // 임시 메모리 저장소
        private readonly List<Memo> _memos = new List<Memo>();
        private readonly Dictionary<(Guid UserId, Guid MemoId), UserMemoState> _userMemoStates = new Dictionary<(Guid, Guid), UserMemoState>();

        // 사용자 정보 (테스트용)
        private readonly User _currentUser = new User { UserId = Guid.NewGuid(), Username = "testuser", DisplayName = "테스트 사용자" };
        private readonly User _otherUser = new User { UserId = Guid.NewGuid(), Username = "otheruser", DisplayName = "다른 사용자" };

        public MockMemoService()
        {
            // 초기 Mock 데이터 생성
            var memo1 = new Memo { Id = Guid.NewGuid(), Title = "회의 준비 (Mock)", Content = "팀 회의 안건 정리", SenderId = _otherUser.UserId, ReceiverId = _currentUser.UserId, CreatedAtUtc = DateTime.UtcNow.AddDays(-1) };
            var memo2 = new Memo { Id = Guid.NewGuid(), Title = "점심 약속 (Mock)", Content = "김대리님과 12시", SenderId = _currentUser.UserId, ReceiverId = _otherUser.UserId, CreatedAtUtc = DateTime.UtcNow, IsPopup = true };
            var memo3 = new Memo { Id = Guid.NewGuid(), Title = "보고서 작성 (Mock)", Content = "분기 보고서 초안 작성 완료하기", SenderId = _otherUser.UserId, ReceiverId = _currentUser.UserId, CreatedAtUtc = DateTime.UtcNow.AddHours(-2) };

            _memos.AddRange(new[] { memo1, memo2, memo3 });

            // UserMemo 상태 초기화
            _userMemoStates.Add((_currentUser.UserId, memo1.Id), new UserMemoState { IsRead = true, IsPersonal = false });
            _userMemoStates.Add((_currentUser.UserId, memo3.Id), new UserMemoState { IsRead = false, IsPersonal = true });
             _userMemoStates.Add((_otherUser.UserId, memo2.Id), new UserMemoState { IsRead = false, IsPersonal = false }); // memo2의 수신자 상태
        }

        public Task<IEnumerable<UserMemoInfo>> GetUserMemosWithStatusAsync(Guid userId)
        {
            var results = new List<UserMemoInfo>();
            // 현재 사용자가 수신한 메모만 필터링
            var receivedMemos = _memos.Where(m => m.ReceiverId == userId && !m.IsDeletedBySender);

            foreach (var memo in receivedMemos)
            {
                // 해당 메모에 대한 사용자 상태 조회 (삭제되지 않은 것만)
                UserMemoState state = null;
                 _userMemoStates.TryGetValue((userId, memo.Id), out state);

                if (state == null || !state.IsDeletedByReceiver) // 상태가 없거나, 수신자가 삭제하지 않은 경우
                {
                    results.Add(new UserMemoInfo
                    {
                        Memo = memo,
                        IsRead = state?.IsRead ?? false,
                        IsPersonal = state?.IsPersonal ?? false
                    });
                }
            }
            // 최신순 정렬
            return Task.FromResult(results.OrderByDescending(r => r.Memo.CreatedAtUtc).AsEnumerable());
        }

        public Task<Memo> GetMemoByIdAsync(Guid memoId)
        {
            var memo = _memos.FirstOrDefault(m => m.Id == memoId);
            return Task.FromResult(memo);
        }

        public Task<bool> CreateMemoAsync(Memo memo)
        {
            memo.Id = Guid.NewGuid(); // 새 ID 보장
            memo.CreatedAtUtc = DateTime.UtcNow;
            memo.UpdatedAtUtc = DateTime.UtcNow;
            _memos.Add(memo);

            // 받는 사람에 대한 UserMemo 상태 레코드 생성
            _userMemoStates[(memo.ReceiverId, memo.Id)] = new UserMemoState();

            return Task.FromResult(true);
        }

        public Task<bool> UpdateMemoAsync(Memo memo)
        {
            var existingMemo = _memos.FirstOrDefault(m => m.Id == memo.Id);
            if (existingMemo != null)
            {
                existingMemo.Title = memo.Title;
                existingMemo.Content = memo.Content;
                existingMemo.IsPopup = memo.IsPopup;
                existingMemo.UpdatedAtUtc = DateTime.UtcNow;
                return Task.FromResult(true);
            }
            return Task.FromResult(false);
        }

        public Task<bool> MarkMemoAsReadAsync(Guid userId, Guid memoId, bool isRead)
        {
            if (_userMemoStates.TryGetValue((userId, memoId), out UserMemoState state))
            {
                state.IsRead = isRead;
                if (isRead && state.ReadAtUtc == null) state.ReadAtUtc = DateTime.UtcNow;
                return Task.FromResult(true);
            }
            return Task.FromResult(false); // 해당 UserMemo 상태 레코드 없음
        }

        public Task<bool> SetPersonalStatusAsync(Guid userId, Guid memoId, bool isPersonal)
        {
            if (_userMemoStates.TryGetValue((userId, memoId), out UserMemoState state))
            {
                state.IsPersonal = isPersonal;
                 if (isPersonal && state.SavedAtUtc == null) state.SavedAtUtc = DateTime.UtcNow;
                return Task.FromResult(true);
            }
             // 상태 레코드가 없으면 새로 만들어 줄 수도 있음 (정책에 따라)
            // else { _userMemoStates[(userId, memoId)] = new UserMemoState { IsPersonal = isPersonal }; return Task.FromResult(true); }
            return Task.FromResult(false);
        }

        public Task<bool> MarkMemoAsDeletedByReceiverAsync(Guid userId, Guid memoId)
        {
             if (_userMemoStates.TryGetValue((userId, memoId), out UserMemoState state))
            {
                state.IsDeletedByReceiver = true;
                 state.DeletedAtUtc = DateTime.UtcNow;
                return Task.FromResult(true);
            }
            // 상태 레코드가 없으면 새로 만들어서 삭제 상태로 만들 수도 있음
            // else { _userMemoStates[(userId, memoId)] = new UserMemoState { IsDeletedByReceiver = true }; return Task.FromResult(true); }
            return Task.FromResult(false);
        }

        public Task<bool> MarkMemoAsDeletedBySenderAsync(Guid senderId, Guid memoId)
        {
            var memo = _memos.FirstOrDefault(m => m.Id == memoId);
            // 보낸 사람 ID 확인 (실제 구현 시 더 엄격한 권한 확인 필요)
            if (memo != null && memo.SenderId == senderId)
            {
                memo.IsDeletedBySender = true;
                return Task.FromResult(true);
            }
            return Task.FromResult(false);
        }

        // Mock 데이터용 내부 클래스
        private class UserMemoState
        {
            public bool IsRead { get; set; } = false;
            public bool IsPersonal { get; set; } = false;
            public bool IsDeletedByReceiver { get; set; } = false;
             public DateTime? ReadAtUtc { get; set; }
             public DateTime? SavedAtUtc { get; set; }
             public DateTime? DeletedAtUtc { get; set; }
        }
    }
}

24. 스물네 번째 파일: Services/Implementations/SignalRNotificationService.cs

INotificationService 인터페이스를 구현하며, SignalR 클라이언트 라이브러리를 사용하여 서버의 SignalR Hub에 연결하고 실시간 메모 수신 이벤트를 처리하는 클래스입니다.

주의: Microsoft.AspNetCore.SignalR.Client NuGet 패키지 설치가 필요합니다. .NET Framework 4.8 환경과의 호환성을 위해 적절한 버전을 선택해야 합니다 (예: 5.x 또는 6.x 버전 중 .NET Standard 2.0을 지원하는 버전).

C#

// MemoAppMGSP/Services/Implementations/SignalRNotificationService.cs
using MemoAppMGSP.Models;
using MemoAppMGSP.Services.Interfaces;
using Microsoft.AspNetCore.SignalR.Client; // Microsoft.AspNetCore.SignalR.Client NuGet 패키지 필요
using System;
using System.Diagnostics;
using System.Threading.Tasks; // Task 사용

namespace MemoAppMGSP.Services.Implementations
{
    /// <summary>
    /// SignalR을 사용하여 서버로부터 실시간 알림을 수신하는 INotificationService 구현체입니다.
    /// </summary>
    public class SignalRNotificationService : INotificationService, IDisposable // IDisposable 추가 권장
    {
        private HubConnection _hubConnection;
        private readonly string _hubUrl; // 예: "http://yourserver.com/memohub"
        private bool _isStarted = false;

        /// <summary>
        /// MemoReceived 이벤트입니다. 새 메모 수신 시 발생합니다.
        /// </summary>
        public event EventHandler<MemoEventArgs> MemoReceived;

        /// <summary>
        /// SignalRNotificationService의 새 인스턴스를 초기화합니다.
        /// </summary>
        /// <param name="hubUrl">연결할 SignalR Hub의 URL</param>
        public SignalRNotificationService(string hubUrl)
        {
            _hubUrl = hubUrl ?? throw new ArgumentNullException(nameof(hubUrl));

            // HubConnection 빌드 및 설정
            _hubConnection = new HubConnectionBuilder()
                .WithUrl(_hubUrl, options =>
                {
                    // TODO: 인증 토큰이 필요하다면 여기서 설정
                    // options.AccessTokenProvider = () => Task.FromResult("your_token");
                })
                .WithAutomaticReconnect() // 자동 재연결 설정 (권장)
                .Build();

            // 서버에서 클라이언트로 호출하는 메서드 핸들러 등록
            // "ReceiveMemo"는 서버 Hub에서 클라이언트를 호출할 때 사용하는 메서드 이름과 일치해야 함
            _hubConnection.On<Memo>("ReceiveMemo", (receivedMemo) =>
            {
                Debug.WriteLine($"SignalR: Memo received - Title: {receivedMemo?.Title}");
                // 이벤트 발생시키기 (UI 스레드 고려 필요 시 Dispatcher 사용)
                OnMemoReceived(new MemoEventArgs(receivedMemo));
            });

            // 연결 상태 변경 이벤트 처리 (로깅 등)
            _hubConnection.Closed += HubConnection_Closed;
            _hubConnection.Reconnecting += HubConnection_Reconnecting;
            _hubConnection.Reconnected += HubConnection_Reconnected;
        }

        public async Task StartAsync()
        {
            if (_isStarted && _hubConnection.State != HubConnectionState.Disconnected)
            {
                 Debug.WriteLine("SignalR: Already started or starting.");
                return;
            }

            try
            {
                Debug.WriteLine("SignalR: Starting connection...");
                await _hubConnection.StartAsync();
                 _isStarted = true;
                Debug.WriteLine($"SignalR: Connection successful. State: {_hubConnection.State}");
            }
            catch (Exception ex)
            {
                 _isStarted = false; // 시작 실패
                Debug.WriteLine($"SignalR: Connection failed - {ex.Message}");
                // TODO: 연결 실패 처리 (예: 사용자 알림)
            }
        }

        public async Task StopAsync()
        {
            if (!_isStarted || _hubConnection == null || _hubConnection.State == HubConnectionState.Disconnected)
            {
                 Debug.WriteLine("SignalR: Already stopped or not started.");
                return;
            }
            try
            {
                Debug.WriteLine("SignalR: Stopping connection...");
                await _hubConnection.StopAsync();
                 _isStarted = false;
                 Debug.WriteLine($"SignalR: Connection stopped. State: {_hubConnection.State}");
            }
            catch (Exception ex)
            {
                Debug.WriteLine($"SignalR: Error stopping connection - {ex.Message}");
            }
        }

        /// <summary>
        /// MemoReceived 이벤트를 안전하게 발생시킵니다.
        /// </summary>
        /// <param name="e">MemoEventArgs</param>
        protected virtual void OnMemoReceived(MemoEventArgs e)
        {
            // 중요: 이 이벤트 핸들러를 구독하는 UI 코드가 있다면,
            //       UI 스레드에서 실행되도록 Dispatcher.Invoke 등을 사용해야 할 수 있습니다.
            //       ViewModel 등에서 구독하는 경우 ViewModel이 스레드 마샬링을 처리할 수 있습니다.
            EventHandler<MemoEventArgs> handler = MemoReceived;
            if (handler != null)
            {
                handler.Invoke(this, e);
            }
            // 또는 Application.Current.Dispatcher.Invoke(() => handler?.Invoke(this, e));
        }

        // --- Connection Lifecycle Event Handlers ---
        private Task HubConnection_Reconnected(string connectionId)
        {
             Debug.WriteLine($"SignalR: Connection reconnected. ConnectionId: {connectionId}");
             return Task.CompletedTask;
        }

        private Task HubConnection_Reconnecting(Exception error)
        {
             Debug.WriteLine($"SignalR: Connection reconnecting due to error: {error?.Message}");
             return Task.CompletedTask;
        }

        private Task HubConnection_Closed(Exception error) // 'Exception?' -> 'Exception'
        {
             _isStarted = false; // 연결이 닫혔으므로 상태 업데이트
             Debug.WriteLine($"SignalR: Connection closed. Error (if any): {error?.Message}");
             // TODO: 연결 종료 처리 (예: 재시작 시도 로직 또는 사용자 알림)
             return Task.CompletedTask;
        }


        // --- IDisposable Implementation ---
        public void Dispose()
        {
            // 비동기 Dispose 패턴 사용 권장 (IAsyncDisposable은 .NET Core)
            // 여기서는 간단히 StopAsync 호출 시도
             _ = StopAsync(); // 결과 기다리지 않음
             if (_hubConnection != null)
             {
                _hubConnection.Closed -= HubConnection_Closed;
                _hubConnection.Reconnecting -= HubConnection_Reconnecting;
                _hubConnection.Reconnected -= HubConnection_Reconnected;
                // HubConnection 자체의 DisposeAsync 또는 Dispose 호출 (버전 확인 필요)
                // Task.Run(async () => await _hubConnection.DisposeAsync()); // 예시
             }
        }
    }
}
25. 스물다섯 번째 파일: Services/Implementations/DialogService.cs

IDialogService 인터페이스를 구현하며, WPF의 MessageBox를 사용하여 사용자에게 대화상자를 표시하는 클래스입니다.

C#

// MemoAppMGSP/Services/Implementations/DialogService.cs
using MemoAppMGSP.Services.Interfaces;
using System.Threading.Tasks; // Task 사용
using System.Windows; // MessageBox 사용 (PresentationFramework 참조 필요)

namespace MemoAppMGSP.Services.Implementations
{
    /// <summary>
    /// WPF의 MessageBox를 사용하여 IDialogService 기능을 구현합니다.
    /// </summary>
    public class DialogService : IDialogService
    {
        // MessageBox는 UI 스레드에서 호출되어야 합니다.
        // 이 서비스가 백그라운드 스레드에서 호출될 가능성이 있다면,
        // Application.Current.Dispatcher.Invoke를 사용하여 UI 스레드로 마샬링해야 합니다.
        // 여기서는 ViewModel 등 UI 스레드 컨텍스트에서 호출된다고 가정합니다.

        public void ShowMessage(string title, string message)
        {
            MessageBox.Show(message, title, MessageBoxButton.OK, MessageBoxImage.Information);
        }

        public void ShowError(string title, string message)
        {
            MessageBox.Show(message, title, MessageBoxButton.OK, MessageBoxImage.Error);
        }

        public bool ShowConfirmation(string title, string message)
        {
            MessageBoxResult result = MessageBox.Show(message, title, MessageBoxButton.YesNo, MessageBoxImage.Question);
            return result == MessageBoxResult.Yes;
        }

        // --- Async Wrappers ---
        // 아래 비동기 메서드들은 MessageBox가 동기/블로킹 방식이므로
        // 실제 비동기 이점을 제공하지는 않지만, 인터페이스 계약을 만족시키고
        // 호출하는 쪽에서 async/await 패턴을 일관되게 사용할 수 있게 합니다.

        public Task ShowMessageAsync(string title, string message)
        {
            // UI 스레드에서 실행 보장 (필요 시)
            // Application.Current.Dispatcher.Invoke(() => ShowMessage(title, message));
            ShowMessage(title, message);
            return Task.CompletedTask; // 즉시 완료되는 Task 반환
        }

        public Task ShowErrorAsync(string title, string message)
        {
            ShowError(title, message);
            return Task.CompletedTask;
        }

        public Task<bool> ShowConfirmationAsync(string title, string message)
        {
            bool result = ShowConfirmation(title, message);
            return Task.FromResult(result); // 결과를 포함하는 완료된 Task 반환
        }
    }
}
이제 주요 서비스들의 기본적인 구현체 뼈대가 준비되었습니다. 다음 단계는 이 서비스들을 실제로 사용하도록 의존성 주입(Dependency Injection) 컨테이너를 설정하고 V