WPF에서 PLC와 통신하기 위해 C#으로 작성된 프로그램을 만들고, 사용자가 버튼을 눌러 특정 값을 PLC에 전달하는 기능을 구현할 수 있습니다. 이 프로그램에서는 MVVM (Model-View-ViewModel) 디자인 패턴을 사용하여 데이터 바인딩과 커맨드를 활용해 중복 코드를 줄이고, 깔끔한 코드를 유지합니다.

1. 모델 (Model)
먼저, 각 번호와 연결된 이름을 담고 있는 모델 클래스를 정의합니다.

csharp
코드 복사
public class PLCCommand
{
    public int Number { get; set; }
    public string Name { get; set; }
}
2. 뷰 모델 (ViewModel)
다음으로, 버튼의 동작을 제어하고 데이터 바인딩을 위해 뷰 모델 클래스를 작성합니다. 뷰 모델은 버튼 클릭 시 PLC로 메시지를 전송하는 로직을 포함합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Runtime.CompilerServices;
using System.Windows.Input;

public class MainViewModel : INotifyPropertyChanged
{
    public ObservableCollection<PLCCommand> Commands { get; set; }
    
    private string _selectedCommandName;
    public string SelectedCommandName
    {
        get => _selectedCommandName;
        set
        {
            _selectedCommandName = value;
            OnPropertyChanged();
        }
    }

    public ICommand SendCommand { get; }

    public MainViewModel()
    {
        // PLCCommand 객체 리스트를 초기화하고 각 번호와 이름을 설정합니다.
        Commands = new ObservableCollection<PLCCommand>
        {
            new PLCCommand { Number = 0, Name = "Command Zero" },
            new PLCCommand { Number = 1, Name = "Command One" },
            new PLCCommand { Number = 2, Name = "Command Two" },
            // 추가적인 명령어는 여기서 정의하세요.
        };

        // SendCommand 커맨드를 초기화합니다.
        SendCommand = new RelayCommand(ExecuteSendCommand);
    }

    private void ExecuteSendCommand(object parameter)
    {
        if (parameter is PLCCommand command)
        {
            // PLC로 보낼 메시지를 구성합니다.
            string message = $"%01#WDD0230002300{command.Number:D2}00**\r";
            // 실제 메시지를 PLC로 보내는 코드를 여기에 추가합니다.
            // 예를 들어, TCP 클라이언트를 사용하여 PLC로 메시지를 전송할 수 있습니다.
            SelectedCommandName = command.Name;
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged([CallerMemberName] string name = null)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(name));
    }
}
여기서 RelayCommand는 MVVM 패턴에서 자주 사용하는 커맨드 클래스로, 사용자 인터페이스의 이벤트를 처리하는 데 사용됩니다.

3. 뷰 (View)
이제 XAML 파일에서 버튼과 바인딩을 설정합니다.

xml
코드 복사
<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Command Sender" Height="200" Width="300">
    <Grid>
        <StackPanel>
            <!-- 버튼 목록을 동적으로 생성하고 각 버튼의 Content와 Command를 바인딩합니다. -->
            <ItemsControl ItemsSource="{Binding Commands}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <Button Content="{Binding Name}"
                                Command="{Binding DataContext.SendCommand, RelativeSource={RelativeSource AncestorType=Window}}"
                                CommandParameter="{Binding}" />
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>

            <!-- 선택된 명령어 이름을 표시합니다. -->
            <TextBlock Text="{Binding SelectedCommandName}" Margin="10" HorizontalAlignment="Center"/>
        </StackPanel>
    </Grid>
</Window>
4. 뷰와 뷰 모델 연결
MainWindow.xaml.cs 파일에서 데이터 컨텍스트를 설정합니다.

csharp
코드 복사
public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        DataContext = new MainViewModel();
    }
}
5. 커맨드 클래스 정의
RelayCommand 클래스를 정의합니다.

csharp
코드 복사
using System;
using System.Windows.Input;

public class RelayCommand : ICommand
{
    private readonly Action<object> _execute;
    private readonly Func<object, bool> _canExecute;

    public event EventHandler CanExecuteChanged;

    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        _execute = execute;
        _canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return _canExecute == null || _canExecute(parameter);
    }

    public void Execute(object parameter)
    {
        _execute(parameter);
    }

    public void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}
최종 구성
이제 프로그램을 실행하면 각 버튼이 PLCCommand 모델의 Name 속성에 따라 생성되며, 버튼을 클릭하면 PLC에 메시지를 전송하는 동작이 수행됩니다. 이 구조는 MVVM 디자인 패턴을 따르며, 데이터 바인딩과 커맨드를 통해 UI와 비즈니스 로직을 깔끔하게 분리합니