WPF 애플리케이션에서 DispatcherTimer를 사용하여 주기적으로 프로세스를 모니터링하고 관리하는 코드를 작성하려면 다음과 같은 방식으로 구현할 수 있습니다.

아래는 WPF 애플리케이션에서 DispatcherTimer를 사용하여 주어진 프로세스 목록을 모니터링하고 관리하는 코드 예제입니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Windows.Threading;

namespace WpfProcessMonitor
{
    public partial class MainWindow : Window
    {
        private DispatcherTimer checkTimer;
        private DispatcherTimer forceRestartTimer;
        private string processListPath = @"c:\processfiles.txt";

        public MainWindow()
        {
            InitializeComponent();

            // 1분마다 프로세스 상태를 확인하기 위한 타이머 설정
            checkTimer = new DispatcherTimer();
            checkTimer.Interval = TimeSpan.FromMinutes(1);
            checkTimer.Tick += CheckProcesses;
            checkTimer.Start();

            // 1시간마다 프로세스를 강제 종료하고 재시작하기 위한 타이머 설정
            forceRestartTimer = new DispatcherTimer();
            forceRestartTimer.Interval = TimeSpan.FromHours(1);
            forceRestartTimer.Tick += ForceRestartProcesses;
            forceRestartTimer.Start();

            // 시작시 상태 확인
            CheckProcesses(null, null);
        }

        private void CheckProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processNames = File.ReadAllLines(processListPath);

                    foreach (string processName in processNames)
                    {
                        string trimmedProcessName = processName.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessName))
                            continue;

                        Process[] processes = Process.GetProcessesByName(trimmedProcessName);

                        if (processes.Length == 0)
                        {
                            // 프로세스가 실행 중이지 않으면 실행
                            Process.Start(@"c:\abc\proc1.exe");
                            LogMessage($"{trimmedProcessName}가 실행되지 않아 proc1.exe를 실행했습니다.");
                        }
                        else
                        {
                            LogMessage($"{trimmedProcessName}가 이미 실행 중입니다.");
                        }
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void ForceRestartProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processNames = File.ReadAllLines(processListPath);

                    foreach (string processName in processNames)
                    {
                        string trimmedProcessName = processName.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessName))
                            continue;

                        Process[] processes = Process.GetProcessesByName(trimmedProcessName);

                        if (processes.Length > 0)
                        {
                            // 프로세스 강제 종료
                            foreach (Process proc in processes)
                            {
                                proc.Kill();
                                proc.WaitForExit();
                            }
                            LogMessage($"{trimmedProcessName}를 강제 종료했습니다.");
                        }

                        // 프로세스가 종료된 것을 확인한 후 다시 실행
                        Process.Start(@"c:\abc\proc1.exe");
                        LogMessage($"{trimmedProcessName}를 재실행했습니다.");
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() =>
            {
                // 로그 메시지를 UI에 출력
                LogTextBox.AppendText($"{DateTime.Now}: {message}\n");
                LogTextBox.ScrollToEnd();
            });
        }
    }
}
MainWindow.xaml
xml
코드 복사
<Window x:Class="WpfProcessMonitor.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Process Monitor" Height="350" Width="525">
    <Grid>
        <TextBox Name="LogTextBox" 
                 VerticalScrollBarVisibility="Auto" 
                 HorizontalScrollBarVisibility="Auto"
                 IsReadOnly="True"
                 TextWrapping="Wrap"
                 Margin="10"/>
    </Grid>
</Window>
코드 설명:
DispatcherTimer 사용: DispatcherTimer를 사용하여 1분마다(checkTimer) 프로세스를 확인하고, 1시간마다(forceRestartTimer) 프로세스를 강제 종료하고 다시 시작합니다.

프로세스 상태 확인: CheckProcesses 메서드는 c:\processfiles.txt 파일에 적힌 각 프로세스 이름에 대해 실행 여부를 확인하고, 실행 중이지 않으면 지정된 실행 파일(c:\abc\proc1.exe)을 실행합니다.

강제 종료 및 재실행: ForceRestartProcesses 메서드는 1시간마다 지정된 프로세스를 강제 종료하고 종료된 것을 확인한 후 다시 실행합니다.

로그 메시지 출력: LogMessage 메서드는 UI 스레드에서 로그 메시지를 TextBox에 출력합니다. 이 메서드는 WPF의 Dispatcher를 사용하여 UI 업데이트를 안전하게 수행합니다.

UI 구성: WPF의 기본 UI는 로그를 보여주기 위해 TextBox를 사용합니다. 이 TextBox는 로그 메시지를 실시간으로 업데이트하며, 스크롤이 자동으로 아래로 이동됩니다.

이 코드는 c:\processfiles.txt 파일에 명시된 모든 프로세스를 주기적으로 모니터링하며, 특정 조건에 따라 프로세스를 실행하거나 강제 종료합니다. DispatcherTimer를 사용해 WPF UI와의 동기화를 유지하면서 주기적인 작업을 처리할 수 있습니다.