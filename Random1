NET Framework 3.5에서는 Dispatcher.Invoke 메서드가 지원되지 않습니다. 대신 Dispatcher 클래스의 BeginInvoke 메서드를 사용하여 UI 스레드에서 호출할 수 있습니다. 이 메서드는 비동기적으로 작업을 수행하여 UI 스레드와의 충돌을 피합니다.

아래는 Dispatcher.BeginInvoke를 사용하도록 수정된 코드입니다.

서버 측 프로그램 수정 (C#)
csharp
코드 복사
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Windows;
using System.Windows.Threading; // Dispatcher를 사용하기 위해 추가

namespace SocketServerApp
{
    public partial class MainWindow : Window
    {
        private Socket serverSocket;
        private byte[] buffer = new byte[1024];

        public MainWindow()
        {
            InitializeComponent();
            StartServer();
        }

        private void StartServer()
        {
            try
            {
                serverSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                serverSocket.Bind(new IPEndPoint(IPAddress.Any, 1433));
                serverSocket.Listen(10);
                serverSocket.BeginAccept(new AsyncCallback(AcceptCallback), null);
                UpdateStatus("서버가 시작되었습니다.");
            }
            catch (Exception ex)
            {
                UpdateStatus($"서버 시작 오류: {ex.Message}");
            }
        }

        private void AcceptCallback(IAsyncResult AR)
        {
            Socket clientSocket = serverSocket.EndAccept(AR);
            UpdateStatus("클라이언트가 연결되었습니다.");
            clientSocket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, new AsyncCallback(ReceiveCallback), clientSocket);
            serverSocket.BeginAccept(new AsyncCallback(AcceptCallback), null);
        }

        private void ReceiveCallback(IAsyncResult AR)
        {
            Socket clientSocket = (Socket)AR.AsyncState;
            int received = clientSocket.EndReceive(AR);
            if (received > 0)
            {
                string data = Encoding.UTF8.GetString(buffer, 0, received);
                UpdateStatus($"받은 데이터: {data}");
                clientSocket.BeginReceive(buffer, 0, buffer.Length, SocketFlags.None, new AsyncCallback(ReceiveCallback), clientSocket);
            }
        }

        private void UpdateStatus(string message)
        {
            Dispatcher.BeginInvoke((Action)(() =>
            {
                listBox.Items.Add(message);
            }));
        }
    }
}
클라이언트 측 프로그램 수정 (C#)
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Windows;
using System.Windows.Threading; // Dispatcher를 사용하기 위해 추가

namespace SocketClientApp
{
    public partial class MainWindow : Window
    {
        private Socket clientSocket;

        public MainWindow()
        {
            InitializeComponent();
            ConnectToServer();
        }

        private void ConnectToServer()
        {
            try
            {
                clientSocket = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);
                clientSocket.Connect("서버의_IP_주소", 1433); // 서버의 IP 주소를 설정하세요.
                UpdateStatus("서버에 연결되었습니다.");
            }
            catch (Exception ex)
            {
                UpdateStatus($"서버 연결 오류: {ex.Message}");
            }
        }

        private void SendMessage(string message)
        {
            if (clientSocket != null && clientSocket.Connected)
            {
                byte[] data = Encoding.UTF8.GetBytes(message);
                clientSocket.Send(data);
                UpdateStatus($"전송한 메시지: {message}");
            }
        }

        private void UpdateStatus(string message)
        {
            Dispatcher.BeginInvoke((Action)(() =>
            {
                listBox.Items.Add(message);
            }));
        }

        private void Button_Click(object sender, RoutedEventArgs e)
        {
            string message = textBox.Text;
            SendMessage(message);
        }
    }
}
요약
Dispatcher.BeginInvoke 메서드는 비동기적으로 UI 스레드에서 작업을 수행하도록 하여 UI가 멈추지 않도록 합니다.
위 수정된 코드는 .NET Framework 3.5 환경에서도 정상적으로 동작할 것입니다.
Dispatcher.BeginInvoke를 사용하면, UI 스레드와의 충돌을 피할 수 있어 WPF 애플리케이션의 안정성이 향상됩니다.
이제 서버와 클라이언트 프로그램을 각각 수정된 코드와 함께 빌드하고 실행하여, 원하는 대로 동작하는지 확인하시면 됩니