using UnityEngine;

public class SceneCameraController : MonoBehaviour
{
    [Header("타겟 설정")]
    [Tooltip("카메라가 바라볼 중심 타겟입니다.")]
    public Transform target;

    [Header("카메라 속도 설정")]
    [Tooltip("카메라 회전 속도입니다.")]
    public float orbitSpeed = 10.0f;
    [Tooltip("카메라 이동(패닝) 속도입니다.")]
    public float panSpeed = 0.5f;
    [Tooltip("카메라 줌 속도입니다.")]
    public float zoomSpeed = 10.0f;

    [Header("카메라 제한 설정")]
    [Tooltip("타겟으로부터의 최소 거리입니다.")]
    public float minDistance = 3.0f;
    [Tooltip("타겟으로부터의 최대 거리입니다.")]
    public float maxDistance = 20.0f;
    [Tooltip("카메라의 최소 수직 각도입니다.")]
    public float yMinLimit = -80f;
    [Tooltip("카메라의 최대 수직 각도입니다.")]
    public float yMaxLimit = 80f;

    // 내부 계산용 변수
    private float distance;
    private float x = 0.0f;
    private float y = 0.0f;

    void Start()
    {
        // 초기 각도를 현재 카메라의 각도로 설정
        Vector3 angles = transform.eulerAngles;
        x = angles.y;
        y = angles.x;

        // 초기 거리를 타겟과의 실제 거리로 설정
        if (target != null)
        {
            distance = Vector3.Distance(transform.position, target.position);
        }
    }

    // 모든 Update() 호출이 끝난 후에 실행되어 카메라의 떨림 현상을 방지합니다.
    void LateUpdate()
    {
        // 타겟이 지정되어 있어야만 카메라 로직을 실행합니다.
        if (target == null)
        {
            return;
        }

        // 1. 카메라 회전 (마우스 우클릭)
        if (Input.GetMouseButton(1))
        {
            x += Input.GetAxis("Mouse X") * orbitSpeed;
            y -= Input.GetAxis("Mouse Y") * orbitSpeed;

            // y(수직) 각도를 제한하여 카메라가 땅 밑으로 뒤집히는 것을 방지
            y = ClampAngle(y, yMinLimit, yMaxLimit);
        }
        
        // 2. 카메라 줌 (마우스 휠 스크롤)
        distance -= Input.GetAxis("Mouse ScrollWheel") * zoomSpeed;
        distance = Mathf.Clamp(distance, minDistance, maxDistance);

        // 3. 카메라 이동/패닝 (마우스 휠 클릭)
        if (Input.GetMouseButton(2))
        {
            // 마우스 움직임에 따라 이동할 벡터 계산
            Vector3 pan = -transform.right * Input.GetAxis("Mouse X") * panSpeed;
            pan += -transform.up * Input.GetAxis("Mouse Y") * panSpeed;

            // 타겟의 위치를 이동시켜 카메라를 함께 움직임
            target.Translate(pan, Space.World);
        }

        // 계산된 각도와 거리를 이용해 카메라의 최종 위치와 회전값을 설정
        Quaternion rotation = Quaternion.Euler(y, x, 0);
        Vector3 position = rotation * new Vector3(0.0f, 0.0f, -distance) + target.position;

        transform.rotation = rotation;
        transform.position = position;
    }

    // 각도를 -360 ~ 360도 범위 내로 유지하고, 최소/최대값으로 제한하는 도우미 함수
    public static float ClampAngle(float angle, float min, float max)
    {
        if (angle < -360f)
            angle += 360f;
        if (angle > 360f)
            angle -= 360f;
        return Mathf.Clamp(angle, min, max);
    }
}