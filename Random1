네, 프로그램 이중 실행 방지 기능을 추가해 드리겠습니다. 이 기능은 주로 App.xaml.cs 파일과 MainWindow.xaml.cs 파일의 시작 부분을 수정하여 구현합니다.

이중 실행 방지 원리: 프로그램 시작 시 **뮤텍스(Mutex)**라는 운영체제의 동기화 객체를 사용합니다. 프로그램이 처음 실행될 때 고유한 이름의 뮤텍스를 생성하려고 시도합니다. 만약 뮤텍스 생성이 성공하면, 해당 프로그램이 첫 번째 실행이라는 의미이므로 정상적으로 진행합니다. 하지만 이미 같은 이름의 뮤텍스가 존재한다면 (즉, 다른 인스턴스가 이미 실행 중이라면), 두 번째 프로그램은 이를 감지하고 사용자에게 알린 후 자동으로 종료됩니다.

## 1. App.xaml.cs 파일 수정
이 파일에서 프로그램 시작 시 뮤텍스를 확인하고, 이중 실행이면 종료하는 로직을 추가합니다.

App.xaml.cs 전체 코드:

C#

using System;
using System.IO;
using System.Threading; // Mutex 사용을 위해 추가
using System.Windows;
using System.Windows.Threading;

namespace funcenvget
{
    public partial class App : Application
    {
        // 이중 실행 방지를 위한 Mutex 이름 (고유해야 함)
        private const string MutexName = "##{{FUNCENVGET_MUTEX_UNIQUE_NAME}}##"; // 고유한 이름으로 변경 가능
        private Mutex _mutex;

        protected override void OnStartup(StartupEventArgs e)
        {
            bool createdNew;
            _mutex = new Mutex(true, MutexName, out createdNew);

            if (!createdNew)
            {
                // 이미 프로그램이 실행 중인 경우
                MessageBox.Show("프로그램이 이미 실행 중입니다.", "이중 실행 방지", MessageBoxButton.OK, MessageBoxImage.Warning);
                Application.Current.Shutdown(); // 앱 종료
                return;
            }

            // 기본 시작 로직
            base.OnStartup(e);

            // 글로벌 예외 처리기 등록
            this.DispatcherUnhandledException += Application_DispatcherUnhandledException;
            
            MainWindow mainWindow = new MainWindow();
            mainWindow.Show();
        }

        private void Application_DispatcherUnhandledException(object sender, DispatcherUnhandledExceptionEventArgs e)
        {
            // 로그 경로 및 파일 이름 설정
            string logFolderPath = @"C:\Agent\funcenvget\logs";
            string logFilePath = Path.Combine(logFolderPath, "crash_log.txt");

            try
            {
                Directory.CreateDirectory(logFolderPath);
                string errorMessage = $"[CRASH] {DateTime.Now:yyyy-MM-dd HH:mm:ss}\r\n" +
                                      $"- Message: {e.Exception.Message}\r\n" +
                                      $"- StackTrace: {e.Exception.StackTrace}\r\n\r\n";
                File.AppendAllText(logFilePath, errorMessage);
                MessageBox.Show($"치명적인 오류가 발생하여 프로그램을 종료합니다.\n\nC:\\Agent\\funcenvget\\logs\\crash_log.txt 파일을 확인해주세요.",
                                "프로그램 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            catch (Exception ex)
            {
                MessageBox.Show($"오류 로그 기록에 실패했습니다: {ex.Message}", "심각한 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            finally
            {
                e.Handled = true;
                Application.Current.Shutdown();
            }
        }

        // 프로그램 종료 시 Mutex 해제
        protected override void OnExit(ExitEventArgs e)
        {
            _mutex?.ReleaseMutex();
            _mutex?.Dispose();
            base.OnExit(e);
        }
    }
}
주요 변경점 (App.xaml.cs):

using System.Threading; 추가.
MutexName 상수와 _mutex 멤버 변수 선언. 뮤텍스 이름은 다른 프로그램과 겹치지 않도록 충분히 고유하게 만드는 것이 좋습니다.
OnStartup 메소드:
뮤텍스를 생성하려고 시도합니다.
createdNew가 false이면 (즉, 뮤텍스 생성에 실패하면 = 이미 다른 인스턴스가 뮤텍스를 소유하고 있으면) 메시지를 표시하고 앱을 종료합니다.
DispatcherUnhandledException 이벤트 핸들러 등록 코드를 OnStartup으로 옮겼습니다. (이전 코드에서 혹시 빠져있었다면 추가된 것입니다. 이 핸들러는 프로그램 전체의 예외를 잡는 중요한 역할을 합니다.)
OnExit 메소드: 프로그램이 정상적으로 종료될 때 사용했던 뮤텍스를 해제(Release)하고 폐기(Dispose)합니다.
## 2. MainWindow.xaml.cs 파일 (변경 없음)
이전 답변에서 드린 MainWindow.xaml.cs 파일의 내용은 이중 실행 방지 기능과 직접적인 관련이 없으므로 수정할 필요가 없습니다. 현재 사용 중인 MainWindow.xaml.cs 파일을 그대로 사용하시면 됩니다.

사용 방법 및 참고 사항
위 App.xaml.cs 코드로 교체합니다.
MainWindow.xaml.cs는 이전 답변의 최종 버전을 사용합니다.
프로그램을 빌드하고 실행합니다.