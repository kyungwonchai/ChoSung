확한 요구사항을 반영하지 못해 죄송합니다. 파일 내 PO_NO가 새로 시작된 것인지, 중간인지, 아니면 마무리 단계인지를 판단한 후 작업을 진행하고, 작업 목록에 각 파일의 상태를 시퀀스 플래그로 표시하며, 이를 기반으로 작업을 실행하도록 수정하겠습니다.

아래에서 말씀하신 방식대로, MAG_QTY(현재 생산된 수량), PO_PROD_QTY(누적 생산 수량), **PO_PLAN_QTY(계획된 수량)**에 기반해 **시퀀스 플래그(1: 시작, 2: 중간, 3: 마무리)**를 결정하고, 작업이 순차적으로 실행되도록 코드를 다시 작성하겠습니다.

1. TaskModel.cs (수정된 코드)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Collections.ObjectModel;
using System.Windows;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 각 함수는 도형으로 표현되며, 실행 상태에 따라 도형의 색상이 변경됩니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public int MAG_QTY { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public string PO_NO { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int SequenceFlag { get; set; }  // 시퀀스 플래그 (1: 시작, 2: 중간, 3: 끝)

    // 함수 상태를 위한 도형 색상 리스트 (각 함수에 따른 도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }
    
    // 각 함수 이름을 저장 (마우스 오버 시 함수 이름 표시)
    public ObservableCollection<string> FunctionNames { get; set; }
    
    // 진행 상태를 표시하는 텍스트 (실시간으로 반영)
    private string _progressText;
    public string ProgressText
    {
        get => _progressText;
        set
        {
            _progressText = value;
            OnPropertyChanged(nameof(ProgressText));
        }
    }
    
    private TaskQueue _taskQueue;
    public string Status { get; set; }

    public ICommand PauseCommand { get; }
    public ICommand ResumeCommand { get; }
    public ICommand ExecuteSpecificTaskCommand { get; }  // 도형 우클릭 시 특정 함수만 실행

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        MAG_QTY = logEntry.MAG_QTY;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_NO = logEntry.PO_NO;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        SequenceFlag = logEntry.SequenceFlag; // 시퀀스 플래그는 파일에서 결정됨

        _taskQueue = taskQueue;
        Status = "Pending";
        ProgressText = "Pending"; // 기본 상태 (대기 중)

        // 각 함수마다 도형을 설정 (시퀀스에 따라 다른 개수)
        FunctionStatusColors = new ObservableCollection<Brush>();
        FunctionNames = new ObservableCollection<string>();

        PauseCommand = new RelayCommand(PauseTask);
        ResumeCommand = new RelayCommand(ResumeTask);
        ExecuteSpecificTaskCommand = new RelayCommand<int>(ExecuteSpecificTask);  // 특정 함수 실행

        InitializeFunctionColors(); // 초기 도형 상태 설정
    }

    /// <summary>
    /// 작업을 시작하고 각 함수 완료 시 도형 색상을 변경합니다.
    /// </summary>
    public void StartTask()
    {
        Status = "Running";
        ProgressText = "Running..."; // 실시간 진행 상태 업데이트

        ExecuteTaskSequence(); // 시퀀스 플래그에 따른 함수 실행
    }

    /// <summary>
    /// 시퀀스 플래그에 따라 작업을 순차적으로 실행
    /// </summary>
    private async void ExecuteTaskSequence()
    {
        switch (SequenceFlag)
        {
            case 1:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskC);
                break;
            case 2:
                await ExecuteTaskWithColor(0, ExecuteTaskC);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskD);
                break;
            case 3:
                await ExecuteTaskWithColor(0, ExecuteTaskA);
                await ExecuteTaskWithColor(1, ExecuteTaskB);
                await ExecuteTaskWithColor(2, ExecuteTaskE);
                break;
        }

        // 작업 완료 후 상태 변경
        Status = "Completed";
        ProgressText = "Completed";
    }

    /// <summary>
    /// 각 함수에 대한 작업을 실행하고, 완료되면 해당 인덱스의 도형 색상을 변경합니다.
    /// </summary>
    private async Task ExecuteTaskWithColor(int index, Func<Task> task)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.SkyBlue; // 작업 진행 중 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });

        await task(); // 작업 실행

        Application.Current.Dispatcher.Invoke(() =>
        {
            FunctionStatusColors[index] = Brushes.Green; // 작업 완료 시 색상
            OnPropertyChanged(nameof(FunctionStatusColors));
        });
    }

    /// <summary>
    /// 특정 함수를 우클릭하여 단독 실행합니다.
    /// </summary>
    private async void ExecuteSpecificTask(int taskIndex)
    {
        switch (FunctionNames[taskIndex])
        {
            case "Task A":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskA);
                break;
            case "Task B":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskB);
                break;
            case "Task C":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskC);
                break;
            case "Task D":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskD);
                break;
            case "Task E":
                await ExecuteTaskWithColor(taskIndex, ExecuteTaskE);
                break;
            default:
                throw new ArgumentException("Unknown task");
        }
    }

    /// <summary>
    /// 각 함수의 기본 도형 색상을 설정합니다 (회색).
    /// </summary>
    private void InitializeFunctionColors()
    {
        int functionCount = 3; // 각 시퀀스 플래그에서 기본 3개의 함수

        for (int i = 0; i < functionCount; i++)
        {
            FunctionStatusColors.Add(Brushes.Gray); // 기본 색상 (회색)
        }

        // 각 함수의 이름을 설정
        switch (SequenceFlag)
        {
            case 1:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task C");
                break;
            case 2:
                FunctionNames.Add("Task C");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task D");
                break;
            case 3:
                FunctionNames.Add("Task A");
                FunctionNames.Add("Task B");
                FunctionNames.Add("Task E");
                break;
        }
    }

    /// <summary>
    /// Task A 실행
    /// </summary>
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task A Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task B 실행
    /// </summary>
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task B Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task C 실행
    /// </summary>
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task C Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task D 실행
    /// </summary>
    private async Task ExecuteTaskD()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task D Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// Task E 실행
    /// </summary>
    private async Task ExecuteTaskE()
    {
        await Task.Delay(1000); // 1초 대기 (작업 시뮬레이션)
        ProgressText = "Task E Completed"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    private void PauseTask()
    {
        _taskQueue.Pause();
        ProgressText = "Paused"; // 진행 상태 업데이트
    }

    /// <summary>
    /// 작업을 재개합니다.
    /// </summary>
    private void ResumeTask()
    {
        _taskQueue.Resume();
        ProgressText = "Resumed"; // 진행 상태 업데이트
    }
}
2. FileProcessor.cs (수정된 코드)
csharp
코드 복사
using System;
using System.IO;
using System.Threading.Tasks;

/// <summary>
/// FileProcessor는 특정 경로에서 파일을 감지하고, 파일이 추가되면 LogEntry를 생성하여 전달하는 클래스입니다.
/// </summary>
public class FileProcessor
{
    private readonly string _path;
    private readonly Action<LogEntry> _onLogEntryDetected;
    private FileSystemWatcher _watcher;

    public FileProcessor(string path, Action<LogEntry> onLogEntryDetected)
    {
        _path = path;
        _onLogEntryDetected = onLogEntryDetected;
    }

    /// <summary>
    /// 파일 감지를 시작합니다.
    /// </summary>
    public void StartProcessing()
    {
        _watcher = new FileSystemWatcher(_path, "*.txt");
        _watcher.Created += OnFileCreated;
        _watcher.EnableRaisingEvents = true;
    }

    /// <summary>
    /// 새로운 파일이 생성되었을 때 호출됩니다.
    /// </summary>
    private void OnFileCreated(object sender, FileSystemEventArgs e)
    {
        Task.Delay(1000).Wait(); // 파일 안정성 확보를 위한 지연

        var logEntry = ParseLogFile(e.FullPath);
        _onLogEntryDetected?.Invoke(logEntry);
    }

    /// <summary>
    /// 파일에서 LogEntry 데이터를 파싱합니다.
    /// </summary>
    private LogEntry ParseLogFile(string filePath)
    {
        // 파일 내용 파싱 로직
        var lines = File.ReadAllLines(filePath);
        return new LogEntry
        {
            MAG_NO = ExtractData(lines, "MAG_NO"),
            MAG_QTY = int.Parse(ExtractData(lines, "MAG_QTY")),
            BASIC_MODEL = ExtractData(lines, "BASIC_MODEL"),
            MODEL_CODE = ExtractData(lines, "MODEL_CODE"),
            PO_NO = ExtractData(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(ExtractData(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(ExtractData(lines, "PO_PROD_QTY")),
            SequenceFlag = DetermineSequenceFlag(lines)
        };
    }

    /// <summary>
    /// 파일 내용에서 특정 데이터를 추출합니다.
    /// </summary>
    private string ExtractData(string[] lines, string key)
    {
        foreach (var line in lines)
        {
            if (line.StartsWith(key))
            {
                return line.Split('=')[1].Trim();
            }
        }
        return string.Empty;
    }

    /// <summary>
    /// SequenceFlag(시작, 중간, 끝)를 결정합니다.
    /// </summary>
    private int DetermineSequenceFlag(string[] lines)
    {
        int poProdQty = int.Parse(ExtractData(lines, "PO_PROD_QTY"));
        int poPlanQty = int.Parse(ExtractData(lines, "PO_PLAN_QTY"));

        if (poProdQty == 0)
        {
            return 1; // 시작
        }
        else if (poProdQty >= poPlanQty)
        {
            return 3; // 끝
        }
        else
        {
            return 2; // 중간
        }
    }
}
설명
**TaskModel.cs**에서는 각 작업의 상태(시작, 중간, 끝)를 PO_NO에 따라 **시퀀스 플래그(1, 2, 3)**로 구분하여 작업을 실행합니다.
**FileProcessor.cs**에서는 파일을 읽고, **PO_PROD_QTY**와 **PO_PLAN_QTY**를 기준으로 시퀀스 플래그를 결정하여 1(시작), 2(중간), **3(끝)**을 반환합니다.
이렇게 하면 각 작업이 파일에서 처음, 중간, 끝인지에 따라 구분되고, 이에 맞게 작업을