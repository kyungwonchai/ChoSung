유지하면서 새로운 데이터만 추가 학습하는 방법을 설명해준다.

📌 기존 모델 + 새로운 데이터 추가 학습 방법
✅ 기존 모델을 유지하고 새로운 데이터만 학습
✅ 기존 가중치를 그대로 가져와 추가 학습 진행
✅ 새 데이터를 반영한 후 기존 모델을 덮어쓰기

✅ 1. 기존 모델 불러오기 (load_model)
먼저, 기존 모델(model.pth)이 있으면 불러오고, 없으면 새로운 모델을 학습해야 한다.

python
Copy code
def load_model():
    if os.path.exists(MODEL_PATH):
        checkpoint = torch.load(MODEL_PATH, map_location=device)
        num_classes = len(checkpoint["encoder_classes"])
        input_size = len(checkpoint["scaler_mean"])

        model = QRModel(input_size, num_classes).to(device)
        model.load_state_dict(checkpoint["model_state_dict"])  # 기존 모델 가중치 로드
        model.train()  # 🔥 추가 학습을 위해 train 모드

        encoder = LabelEncoder()
        encoder.classes_ = checkpoint["encoder_classes"]

        scaler = StandardScaler()
        scaler.mean_ = checkpoint["scaler_mean"]
        scaler.scale_ = checkpoint["scaler_scale"]

        max_qr_length = checkpoint["max_qr_length"]

        return model, encoder, scaler, max_qr_length
    return None, None, None, None
✅ 2. 기존 모델과 새로운 데이터로 추가 학습 (train_model)
기존 모델이 있으면 그대로 로드
새로운 데이터만 추가 학습
학습 후 기존 모델 덮어쓰기
python
Copy code
def train_model(new_df_data, epochs=10, batch_size=64):
    new_df_data = filter_recent_data(new_df_data)  # 🔥 3개월 지난 데이터 제외

    # 기존 모델 불러오기
    model, encoder, scaler, max_qr_length = load_model()

    if model is None:
        print("🔴 기존 모델 없음. 새로 학습 시작.")
        encoder = LabelEncoder()
        full_df_data = new_df_data  # 새 데이터만 학습
    else:
        print("🟢 기존 모델 로드됨. 추가 학습 진행.")
        full_df_data = new_df_data  # 🔥 기존 데이터 필요 없이 새 데이터만 학습

    # QR 값, 모델명 추출
    qr_values = full_df_data["QR"].values
    model_names = full_df_data["Model"].values

    y_encoded = encoder.fit_transform(model_names)

    max_qr_length = max(len(qr) for qr in qr_values)
    X_vectorized = vectorize_qr(qr_values, max_qr_length)
    scaler = StandardScaler()
    X_scaled = scaler.fit_transform(X_vectorized)

    X_train, X_test, y_train, y_test = train_test_split(X_scaled, y_encoded, test_size=0.2, random_state=42)

    train_dataset = data_utils.TensorDataset(torch.tensor(X_train, dtype=torch.float32),
                                             torch.tensor(y_train, dtype=torch.long))
    train_loader = data_utils.DataLoader(train_dataset, batch_size=batch_size, shuffle=True)

    # 기존 모델이 있으면 추가 학습
    if model is None:
        num_classes = len(encoder.classes_)
        model = QRModel(X_train.shape[1], num_classes).to(device)
    else:
        num_classes = len(encoder.classes_)
        model.fc4 = nn.Linear(32, num_classes).to(device)  # 새로운 클래스 반영

    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    # 🔥 추가 학습 진행
    model.train()
    for epoch in range(epochs):
        total_loss = 0
        for inputs, targets in train_loader:
            inputs, targets = inputs.to(device), targets.to(device)
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            total_loss += loss.item()

        print(f"Epoch [{epoch+1}/{epochs}], Loss: {total_loss/len(train_loader):.4f}")

    save_model(model, encoder, scaler, max_qr_length)
    print("🎉 추가 학습 완료! 모델 업데이트됨.")
✅ 3. 추가 학습 실행
이제 새로운 데이터만 추가 학습할 수 있다.

python
Copy code
if __name__ == "__main__":
    new_df_data = load_data_from_txt("runwait.txt")  # 🔥 새로운 데이터 가져옴
    train_model(new_df_data, epochs=20, batch_size=128)  # 기존 모델에 추가 학습
    test_qr = "123ABC456"  # 예측할 QR 값
    predict_qr(test_qr)  # 예측 실행
📌 최종 정리 (100% 추가 학습 가능)
✅ 추가 학습 로직
기존 모델(model.pth)이 있으면 불러오기
새로운 데이터만 학습
기존 모델 가중치를 유지하면서 추가 학습 진행
학습 후 기존 모델 업데이트 (save_model)
새 모델로 예측 가능
이제 기존 모델을 유지하면서 추가 데이터로 학습할 수 있다. 🚀 이제 돌려서 테스트하면 된다!











Search


ChatGPT can make mistakes. Check important info.