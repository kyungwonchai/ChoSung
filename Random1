
조건 요약
상대방이 보내는 선제 신호는 하나뿐: OP_CLEAR (STX/ETX로 감싸짐)

그 외 모든 수신은 내가 보낸 명령에 대한 응답

그러면 OP_CLEAR만 별도로 처리하고, 나머지는 응답 처리하면 돼!

전략 (간단하고 명확하게)
수신 메시지를 STX/ETX로 클린하게 정리

메시지가 "OP_CLEAR"이면 → 선제 이벤트로 처리

나머지는 모두 → 응답용으로 처리

전문가 코드 (주석 포함)
(딱 너 상황 맞게 OP_CLEAR 구분만 추가한 구조야)

csharp
코드 복사
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client;
    private NetworkStream _stream;
    private byte[] _buffer = new byte[1024];
    private bool _isConnected = false;

    // 응답 대기 중인 요청 ID 맵
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseWaiters
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    /// <summary>
    /// 서버 연결 및 수신 루프 시작
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        _ = Task.Run(ReceiveLoopAsync);
    }

    /// <summary>
    /// 명령 전송 후 응답 대기 (ID 사용)
    /// </summary>
    public async Task<string> SendAndWaitResponseAsync(string command)
    {
        if (!_isConnected) return "[ERROR] Not connected.";

        string id = Guid.NewGuid().ToString("N").Substring(0, 8);
        string fullCommand = $"REQ:{id}:{command}";
        string wrapped = '\x02' + fullCommand + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrapped);

        var tcs = new TaskCompletionSource<string>();
        _responseWaiters.TryAdd(id, tcs);

        await _stream.WriteAsync(data, 0, data.Length);
        Console.WriteLine($"[SEND] {fullCommand}");

        string response = await tcs.Task;
        return response;
    }

    /// <summary>
    /// 항상 도는 수신 루프. 선제 메시지(OP_CLEAR)와 응답 메시지를 구분함
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);
                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                string raw = Encoding.ASCII.GetString(_buffer, 0, bytesRead);
                string message = raw.Trim('\x02', '\x03');

                Console.WriteLine($"[RECV] {message}");

                if (message == "OP_CLEAR")
                {
                    // 서버가 먼저 보낸 신호 (선제 이벤트)
                    Console.WriteLine("[EVENT] OP_CLEAR received!");
                    ProcessOpClearEvent();
                }
                else if (message.StartsWith("RES:"))
                {
                    // 내가 보낸 명령에 대한 응답 처리
                    string[] parts = message.Split(':');
                    if (parts.Length >= 3)
                    {
                        string id = parts[1];
                        string result = string.Join(':', parts, 2, parts.Length - 2);

                        if (_responseWaiters.TryRemove(id, out var tcs))
                        {
                            tcs.SetResult(result);
                        }
                    }
                }
                else
                {
                    Console.WriteLine($"[WARN] Unknown message format: {message}");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// OP_CLEAR 신호 처리 (UI, 상태변경 등)
    /// </summary>
    private void ProcessOpClearEvent()
    {
        // TODO: 필요 시 이벤트, UI 알림, 로그 처리 등
        Console.WriteLine("[ACTION] Handling OP_CLEAR signal...");
    }

    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
서버 통신 예시 포맷 요약
타입	메시지 예시	설명
내가 보낸 명령	REQ:abc12345:STATUS	명령 송신
서버 응답	RES:abc12345:OK	명령 응답
서버 선제신호	OP_CLEAR	서버가 먼저 보내는 신호 (유일)
정리
OP_CLEAR → ReceiveLoop에서 문자열로 직접 구분 처리

나머지 메시지 → 응답 포맷(RES:...)만 응답 대기로 넘김

구분 조건이 명확하니 코드도 간결, 실무에도 강력