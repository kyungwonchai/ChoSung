네, RouterMiddleACR 프로젝트에서 메인 UI와 서비스를 분리하여 각각 독립적으로 동작하게 구성했었는데, 지금은 서비스를 제거하고 메인 UI에서 모든 기능을 통합하려고 하시는 거군요. 이를 위해 어떤 부분을 수정하고 삭제해야 하는지, 그리고 어떻게 통합할 수 있는지 설명드리겠습니다.

1. 서비스 제거 및 통합 개요
RouterMiddleACR 프로젝트에서 서비스를 제거하고 메인 UI에 통합하려면 다음을 수행해야 합니다:

서비스 관련 파일 및 코드 제거:

서비스 설치, 삭제, 시작, 중지 등과 관련된 모든 코드를 제거해야 합니다.
RouterMiddleACRService 클래스 및 기타 서비스 관련 파일들을 삭제합니다.
서비스 기능을 메인 UI로 이동:

기존 서비스가 담당하던 PLC 통신, 데이터 처리, 상태 체크 등의 기능을 메인 UI 코드로 이동해야 합니다.
서비스에서 사용하던 통신 메서드를 메인 UI에 직접 구현하여 호출합니다.
소켓 통신 제거:

서비스와 UI 간의 소켓 통신 코드를 제거하고, 모든 통신을 메인 UI에서 직접 처리하도록 변경합니다.
2. 수정해야 할 파일과 코드
기존 서비스와 메인 UI의 기능을 통합하기 위해 주요 파일들을 어떻게 수정해야 하는지 자세히 설명하겠습니다.

2.1 MainWindow.xaml.cs 수정
메인 UI에서 모든 기능을 통합 관리하도록 수정합니다. 서비스의 역할을 하던 코드가 메인 UI로 이동합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;
        private DispatcherTimer _plcStatusTimer; // PLC 상태 체크를 위한 타이머

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;

            InitializeTimers(); // 타이머 초기화
        }

        // 타이머를 초기화하고 시작하는 메서드
        private void InitializeTimers()
        {
            _plcStatusTimer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1)
            };
            _plcStatusTimer.Tick += async (s, e) => await _viewModel.UpdatePLCStatusAsync();
            _plcStatusTimer.Start();
        }

        // 윈도우 닫기 이벤트 핸들러
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _viewModel.ClosePort(); // 포트를 닫음
        }
    }
}
2.2 MainViewModel.cs 수정
메인 UI가 서비스의 역할을 모두 수행하도록 MainViewModel을 수정합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();

            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            _comPortManager.OpenPort();
        }

        private void InitializeCommands()
        {
            for (int i = 1; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value))));
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";
            string response = await _comPortManager.SendDataToPLCAsync(writeCommand);

            if (!CheckMewtocolResponse(response))
            {
                LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                return;
            }

            LogMessage($"Sent {number} to DT2300, waiting for response...");
            await Task.Delay(3000);

            bool success = false;
            DateTime startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalSeconds < 30)
            {
                string dt2330Response = await _comPortManager.ReadFromPLCAsync("023300");

                if (dt2330Response.Contains(number.ToString()))
                {
                    LogMessage($"Operation completed successfully. Value {number} correctly received from DT2330.");
                    success = true;
                    await _comPortManager.ClearPLCValueAsync("023300");
                    break;
                }
                else if (dt2330Response != "0000")
                {
                    LogMessage($"ERROR: Unexpected value {dt2330Response} found in DT2330. Expected {number}.");
                    break;
                }

                await Task.Delay(1000);
            }

            if (!success)
            {
                LogMessage($"ERROR: Operation failed. Expected value {number} not received from DT2330 within 30 seconds.");
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                string response = await _comPortManager.SendDataToPLCAsync(command);

                if (!CheckMewtocolResponse(response))
                {
                    LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                    return;
                }

                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            LogMessage($"Processed value from DT2330: {value}");
        }

        public async Task UpdatePLCStatusAsync()
        {
            string r520 = await _comPortManager.ReadFromPLCAsync("005200");
            string r521 = await _comPortManager.ReadFromPLCAsync("005201");

            R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
            R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        private bool CheckMewtocolResponse(string response)
        {
            return response.Contains("%01");
        }

        public void ClosePort()
        {
            _comPortManager.ClosePort();
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
2.3 ComPortManager.cs 수정
ComPortManager를 메인 UI에서 직접 호출할 수 있도록 변경합니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class ComPortManager
    {
        private SerialPort _port;

        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);
        }

        public async Task<string> SendDataToPLCAsync(string command)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);

                string response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending data to PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task<string> ReadFromPLCAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#RDD{address}**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);
                
                var response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading from PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task ClearPLCValueAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#WDD{address}0000**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                await Task.Run(() => _port.Write(commandBytes, 0, commandBytes.Length));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error clearing PLC value: {ex.Message}");
            }
        }

        public void OpenPort()
        {
            if (_port != null && !_port.IsOpen)
            {
                _port.Open();
            }
        }

        public void ClosePort()
        {
            if (_port != null && _port.IsOpen)
            {
                _port.Close();
            }
        }
    }
}
3. 불필요한 파일 및 코드 제거
서비스 관련 파일: RouterMiddleACRService 클래스와 그 외 서비스 관련된 파일들을 삭제합니다.
소켓 통신 코드: MainWindow.xaml.cs와 MainViewModel.cs에서 소켓 통신을 위한 모든 코드를 제거합니다.
서비스 상태 체크 코드: 서비스 상태를 체크하고 관리하는 코드를 모두 제거합니다.
4. UI와 기능 테스트
모든 기능이 메인 UI에서 동작하는지 확인하기 위해, 메인 윈도우를 실행하고 모든 버튼과 기능이 정상적으로 작동하는지 테스트합니다.

5. 요약
이제 모든 기능이 하나의 프로젝트 내에서 관리되므로, 배포와 업데이트가 더 간편해지고, 유지보수와 확장이 더 쉬워졌습니다. 필요한 기능을 더 추가하거나 수정할 때도 훨씬 용이합니다.