MasterDataViewModel.cs 파일에서 SaveChangesCommand를 초기화할 때 CanSaveChangesExecute 메서드 부분에 빨간 줄(컴파일 오류)이 표시된다는 말씀이시군요.

RelayCommand 생성자는 두 번째 인자로 Predicate<object> 타입의 델리게이트(메서드)를 받습니다. 이 델리게이트는 object 타입의 매개변수 하나를 받고 bool 값을 반환해야 합니다.

이전에 제공해 드린 MasterDataViewModel.cs 코드의 CanSaveChangesExecute 메서드는 다음과 같이 정의되어 있습니다.

C#

private bool CanSaveChangesExecute(object parameter) => _context != null && _context.ChangeTracker.HasChanges();
이 메서드 시그니처(object 매개변수, bool 반환)는 Predicate<object>와 정확히 일치하므로 문법적으로는 문제가 없어야 합니다.

오류가 발생하는 가능한 이유는 다음과 같습니다.

코드 복사/수정 중 오타: CanSaveChangesExecute 메서드 이름이나 RelayCommand 생성자 호출 부분에 오타가 있을 수 있습니다.
Visual Studio IntelliSense/캐시 오류: 간혹 Visual Studio가 코드 변경 사항을 즉시 인식하지 못하거나 내부 캐시 문제로 잘못된 오류를 표시할 수 있습니다.
RelayCommand 클래스 문제: 드물지만 Infrastructure 폴더의 RelayCommand.cs 파일 자체에 문제가 있을 수도 있습니다.
해결 방법:

아래에 제공하는 MasterDataViewModel.cs 전체 코드로 파일 내용을 완전히 교체해 보세요.
Visual Studio 메뉴에서 빌드(Build) -> 솔루션 정리(Clean Solution) 를 실행합니다.
이어서 빌드(Build) -> 솔루션 다시 빌드(Rebuild Solution) 를 실행합니다.
이렇게 하면 코드 오타 문제가 해결되고 Visual Studio 캐시 문제도 해결될 수 있습니다.

ViewModels/MasterDataViewModel.cs (CanSaveChangesExecute 확인)

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (CanExecute 확인)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        // IsMasterModeEnabled 속성 제거됨
        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }

            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();

            // Command 초기화 (CanExecute 메서드 연결 확인)
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItemExecute);
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItemExecute);
            // *** 이 부분에서 CanSaveChangesExecute 메서드 이름 및 시그니처 확인 ***
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync(), CanSaveChangesExecute);

            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        // CanExecute 메서드 정의 확인
        private bool CanAddItemExecute(object parameter) => _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private bool CanDeleteItemExecute(object parameter) => _context != null && SelectedItem != null;
        private bool CanSaveChangesExecute(object parameter) => _context != null && _context.ChangeTracker.HasChanges(); // 변경 사항이 있을 때만 true

        private void AddItem(object parameter) { if (!CanAddItemExecute(parameter)) return; if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private void DeleteItem(object parameter) { if (!CanDeleteItemExecute(parameter)) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = null; if (SelectedItem is LockerType lt) entityToDelete = lt; else if (SelectedItem is Floor f) entityToDelete = f; else if (SelectedItem is Zone z) entityToDelete = z; else if (SelectedItem is SubPart sp) entityToDelete = sp; else if (SelectedItem is Administrator ad) entityToDelete = ad; else return; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }

        /// <summary>
        /// 마스터 데이터 변경 사항 저장 (연쇄 업데이트 포함)
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            if (!CanSaveChangesExecute(null)) { StatusMessage = "저장할 변경 사항이 없습니다."; return; }
            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList();

            using (var transaction = _context.Database.BeginTransaction()) { try { Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨."); var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, EntityType = e.Entity.GetType(), OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList(); Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}"); foreach (var modified in modifiedNameEntries) { StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'"); int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType"; else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor"; else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone"; else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart"; else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator"; if (!string.IsNullOrEmpty(targetColumn)) { updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}"; try { updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}"); } catch (Exception sqlEx) { Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}"); StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!"; throw new Exception($"연쇄 업데이트 실패 ({modified.OriginalName} -> {modified.CurrentName}): {sqlEx.Message}", sqlEx); } } else { Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다."); } } Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)..."); int masterDataChanges = await _context.SaveChangesAsync(); Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}"); transaction.Commit(); Debug.WriteLine("트랜잭션 커밋 완료."); StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다."; } catch (Exception ex) { Debug.WriteLine($"*** 마스터 데이터 저장 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rollbackEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rollbackEx.ToString()}"); } StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}"; MessageBox.Show($"{StatusMessage}\n\n자세한 내용은 출력 창을 확인하세요.", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error); RollbackMasterDataChanges(changesForRollback); } } await LoadAllMasterDataAsync(); RaiseCanExecuteChanged(); // 저장 후 CanExecute 상태 갱신
        }
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries) { if (_context == null || changedEntries == null) return; foreach (var entry in changedEntries) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusMessage = "마스터 데이터 변경 롤백됨."; _ = LoadAllMasterDataAsync(); }
        #endregion

        /// <summary>
        /// 모든 Command의 CanExecute 상태를 갱신합니다.
        /// </summary>
        private void RaiseCanExecuteChanged()
        {
            // 각 RelayCommand 인스턴스의 RaiseCanExecuteChanged 메서드를 호출합니다.
            // 형변환 후 null 체크를 포함하는 것이 안전합니다.
            (LoadAllMasterDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (AddItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (DeleteItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }

        #region IDisposable 구현
        private bool disposed = false;
        protected virtual void Dispose(bool disposing) { if (!disposed) { if (disposing) { _context?.Dispose(); } disposed = true; } }
        public void Dispose() { Dispose(true); GC.SuppressFinalize(this); }
        #endregion
    }
}
 1 이 코드로 파일을 완전히 교체하신 후, 솔루션 정리 및 다시 빌드를 꼭 실행해 보시기 바랍니다. 만약 그래도 CanSaveChangesExecute 부분에 빨간 줄이 표시된다면, Visual Studio의 오류 목록 창에 표시되는 정확한 오류 코드와 메시지를 알려주시면 원인 파악에 도움이 됩니다.   
1.
github.com
github.com


relaycommadㅍ파일쪽이 수정되었나요 혹시 ? 그파일 전체코드줘보세요




생각하는 과정 표시
아니요, 이전에 CanSaveChangesExecute 오류나 다른 문제들을 해결하면서 RelayCommand.cs 파일은 수정하지 않았습니다. 이 파일은 MVVM 패턴에서 Command를 구현하는 표준적인 방식이며, 일반적으로 한번 작성된 후에는 크게 변경되지 않습니다.

혹시 모르니, 현재 애플리케이션에서 사용해야 하는 .NET Framework 4.8 환경 기준의 RelayCommand.cs 파일 전체 코드를 다시 드리겠습니다. 이 코드가 Infrastructure 폴더에 있는지, 내용이 동일한지 확인해 보세요.

C#

using System;
using System.Windows.Input; // ICommand, CommandManager 사용

namespace LockerManagementApp.Infrastructure
{
    /// <summary>
    /// ICommand 인터페이스의 간단한 구현체입니다. ViewModel에서 UI 작업을 처리하는 데 사용됩니다.
    /// (.NET Framework 환경에 맞춰 Nullable 참조 타입(?) 제거)
    /// </summary>
    public class RelayCommand : ICommand
    {
        // 실행될 Action 델리게이트 (파라미터 타입: object)
        private readonly Action<object> _execute;
        // 실행 가능 여부를 판단할 Predicate 델리게이트 (파라미터 타입: object)
        private readonly Predicate<object> _canExecute;

        /// <summary>
        /// 명령의 실행 가능 상태가 변경될 수 있음을 WPF CommandManager에 알리는 이벤트입니다.
        /// CommandManager.RequerySuggested 이벤트를 사용하여 UI 상태 변경 시 자동으로 CanExecute가 다시 평가되도록 합니다.
        /// </summary>
        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        /// <summary>
        /// 새로운 RelayCommand 인스턴스를 생성합니다.
        /// </summary>
        /// <param name="execute">명령 실행 시 호출될 Action입니다. null일 수 없습니다.</param>
        /// <param name="canExecute">명령 실행 가능 여부를 반환하는 Predicate입니다. null이면 항상 실행 가능한 것으로 간주됩니다.</param>
        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute)); // execute는 필수
            _canExecute = canExecute;
        }

        /// <summary>
        /// 현재 상태에서 명령을 실행할 수 있는지 여부를 결정합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        /// <returns>실행 가능하면 true, 그렇지 않으면 false입니다.</returns>
        public bool CanExecute(object parameter)
        {
            // _canExecute 델리게이트가 null이면 항상 true, 아니면 해당 델리게이트의 결과를 반환합니다.
            return _canExecute == null || _canExecute(parameter);
        }

        /// <summary>
        /// 명령을 실행합니다.
        /// </summary>
        /// <param name="parameter">명령에 전달되는 매개 변수입니다.</param>
        public void Execute(object parameter)
        {
            _execute(parameter); // 등록된 Action을 실행합니다.
        }

        /// <summary>
        /// CanExecuteChanged 이벤트를 강제로 발생시켜 명령의 실행 가능 상태를 다시 평가하도록 요청합니다.
        /// (ViewModel 속성 변경 시 이 메서드를 호출하여 버튼 활성화/비활성화 등을 수동으로 업데이트할 때 사용 가능)
        /// </summary>
        public void RaiseCanExecuteChanged()
        {
            // CommandManager에게 CanExecute 상태를 다시 확인하도록 요청합니다.
            CommandManager.InvalidateRequerySuggested();
        }
    }