, 알겠습니다. 현재 허용되지 않은 IP로 접속 시 Flask의 기본 "Forbidden" 오류 페이지가 표시되는데, 이를 사용자 친화적인 안내 문구를 포함한 커스텀 403 오류 페이지로 변경하도록 수정하겠습니다.

이렇게 하면 사용자가 자신의 IP가 등록되지 않았음을 명확히 인지하고 다음 단계를 생각하는 데 도움이 됩니다.

수정 및 신규 파일:

신규: app/templates/errors/403.html - 접근 거부 시 보여줄 HTML 페이지입니다.
수정: app/__init__.py - Flask 애플리케이션에 403 오류 발생 시 위에서 만든 커스텀 페이지를 보여주도록 에러 핸들러를 등록합니다.
1. 신규: app/templates/errors/403.html (커스텀 403 오류 페이지)
먼저, app/templates/ 폴더 아래에 errors 라는 새 폴더를 만들고, 그 안에 403.html 파일을 다음 내용으로 생성합니다.

HTML

{% extends "layout.html" %} {# 기본 레이아웃 상속 #}

{% block title %}접근 권한 없음{% endblock %}

{% block content %}
<div style="text-align: center; padding: 40px;">
    <img src="{{ url_for('static', filename='images/access_denied_icon.png') }}" alt="접근 불가" style="width: 100px; height: 100px; margin-bottom: 20px;"> 
    {# 위 이미지는 예시입니다. static/images 폴더에 적절한 아이콘을 넣어주세요. 없으면 img 태그 제거 가능 #}
    
    <h1 style="color: #e74c3c; font-size: 2em;">접근 권한이 없습니다.</h1>
    <p style="font-size: 1.2em; color: #555;">
        이 페이지에 접근할 수 있는 권한이 없습니다.
    </p>
    <p style="color: #777;">
        현재 접속하신 IP 주소는 <strong>{{ current_user_ip if current_user_ip else '확인 불가' }}</strong> 입니다.<br>
        시스템 사용이 필요하신 경우, 관리자에게 연락하여 위 IP 주소에 대한 접근 권한 등록을 요청해주십시오.
    </p>
    <div style="margin-top: 30px;">
        {# 홈으로 돌아가는 버튼은 main.index가 접근 가능할 때 유효합니다. #}
        {# 현재 main.index도 ip_auth_required()로 보호되므로, 게스트는 홈도 못 갈 수 있습니다. #}
        {# 이 경우, 에러 페이지는 외부 링크나 안내만 제공해야 합니다. #}
        {# <a href="{{ url_for('main.index') }}" class="btn btn-primary">홈으로 돌아가기</a> #}
        <p><i>문제가 지속되면 시스템 관리자에게 문의하십시오.</i></p>
    </div>
</div>
{% endblock %}

{% block styles %}
{{ super() }}
<style>
    /* 403 페이지 전용 스타일 (필요시) */
    .container { /* layout.html의 .container 스타일을 약간 덮어쓰거나 여기서만 다르게 */
        max-width: 800px; /* 좀 더 좁게 */
    }
</style>
{% endblock %}
403.html 설명:

layout.html을 상속받아 일관된 디자인을 유지합니다.
접속한 사용자의 IP 주소 (current_user_ip - auth.py의 inject_user_info_to_templates 컨텍스트 프로세서를 통해 전달됨)를 표시하여 관리자에게 문의 시 도움이 되도록 합니다.
아이콘 이미지(access_denied_icon.png)는 예시이며, app/static/images/ 폴더에 해당 이미지를 넣거나 <img> 태그 부분을 삭제/수정해야 합니다. (이미지가 없다면 404 오류가 추가로 발생할 수 있습니다.)
"홈으로 돌아가기" 버튼은 현재 주석 처리했습니다. main.index 라우트 또한 @ip_auth_required()로 보호되어 'guest'는 접근할 수 없기 때문입니다. 만약 모든 사용자가 볼 수 있는 공개적인 홈페이지가 있다면 그곳으로 링크할 수 있습니다.
2. 수정: app/__init__.py (403 에러 핸들러 등록)
create_app 함수 내에 403 오류 발생 시 위에서 만든 403.html 템플릿을 렌더링하도록 에러 핸들러를 등록합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app, render_template # render_template 임포트 추가
from config import config
import datetime
import os
from flask_apscheduler import APScheduler 

scheduler = APScheduler()

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # --- Jinja2 필터 및 컨텍스트 프로세서 (이전과 동일) ---
    # ... (format_datetime, inject_now, inject_user_info_to_templates 등록 코드) ...
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)


    # --- 블루프린트 등록 (이전과 동일) ---
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 
    from .routes_logs import logs_bp 
    app.register_blueprint(logs_bp, url_prefix='/history')


    # --- ▼▼▼ 403 에러 핸들러 등록 (신규 추가) ▼▼▼ ---
    @app.errorhandler(403)
    def forbidden_page(error):
        # 이 함수가 호출될 때 auth.py의 get_current_user_role()이 이미 실행되어
        # g.user_ip와 g.current_user_role이 설정되어 있을 수 있습니다.
        # (inject_user_info_to_templates 컨텍스트 프로세서 덕분)
        # 만약 확실하지 않다면, 여기서 get_current_user_role()을 다시 호출할 수도 있습니다.
        # from .auth import get_current_user_role
        # get_current_user_role() # g 객체에 user_ip, current_user_role 설정 보장
        
        app.logger.warning(f"403 Forbidden error handled for IP: {getattr(g, 'user_ip', 'Unknown IP')}, Path: {request.path}")
        return render_template('errors/403.html'), 403 # 403 상태 코드와 함께 템플릿 렌더링
    # --- ▲▲▲ 403 에러 핸들러 등록 끝 ▲▲▲ ---


    # --- APScheduler 초기화 및 작업 등록 (이전과 동일) ---
    # ... (APScheduler 관련 코드) ...
    if not scheduler.running:
        scheduler.init_app(app)
        app.logger.info("APScheduler init_app(app) 호출됨.")
        from . import scheduler_tasks 
        current_flask_app_for_scheduler = app 
        job_id_on = 'scheduled_task_monitor_on_daily'; job_id_off = 'scheduled_task_monitor_off_daily'
        try:
            scheduler.add_job(id=job_id_on, func=scheduler_tasks.scheduled_task_monitor_on, args=[current_flask_app_for_scheduler], trigger='cron', hour=6, minute=0, misfire_grace_time=3600, replace_existing=True)
            app.logger.info(f"스케줄 작업 '{job_id_on}' 매일 06:00 등록/대체됨.")
            scheduler.add_job(id=job_id_off, func=scheduler_tasks.scheduled_task_monitor_off, args=[current_flask_app_for_scheduler], trigger='cron', hour=7, minute=0, misfire_grace_time=3600, replace_existing=True )
            app.logger.info(f"스케줄 작업 '{job_id_off}' 매일 07:00 등록/대체됨.")
            if not app.config.get('TESTING', False): scheduler.start(); app.logger.info("APScheduler 시작됨.")
            else: app.logger.info("TESTING 모드: APScheduler 자동 시작 안 함.")
        except Exception as e: app.logger.error(f"APScheduler 작업 등록 또는 시작 실패: {e}", exc_info=True)
    else: app.logger.info("APScheduler가 이미 실행 중이거나 다른 방식으로 초기화됨.")


    app.logger.info("Flask application 생성 및 설정 완료 (커스텀 403 핸들러 포함).")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")
        if scheduler.running: app.logger.debug(f"등록된 스케줄러 작업: {scheduler.get_jobs()}")

    return app

app/__init__.py 주요 변경 사항:

from flask import render_template를 임포트 목록에 추가했습니다.
create_app 함수 내에 @app.errorhandler(403) 데코레이터를 사용하여 forbidden_page(error) 함수를 등록했습니다.
이 함수는 auth.py의 ip_auth_required 데코레이터에서 abort(403)가 호출될 때 실행됩니다.
errors/403.html 템플릿을 렌더링하고, HTTP 상태 코드 403을 함께 반환합니다.
로깅을 추가하여 어떤 IP와 경로에 대해 403 오류가 발생했는지 기록합니다. (g.user_ip는 inject_user_info_to_templates 컨텍스트 프로세서에 의해 이미 설정되어 있을 것으로 기대합니다.)
적용 및 테스트:

app/templates/errors/ 폴더를 만들고 그 안에 403.html 파일을 위 내용으로 저장합니다.
app/__init__.py 파일을 위 내용으로 업데이트합니다.
(선택 사항) app/static/images/ 폴더에 access_denied_icon.png와 같은 아이콘 이미지를 준비하거나, 403.html에서 이미지 태그를 제거/수정합니다.
Flask 개발 서버를 재시작합니다.
config.py의 ADMIN_IPS 목록이나 DB의 admin_ips, allowed_user_ips 테이블에 포함되지 않은 IP 주소를 가진 다른 PC나 장치에서 Flask 웹 애플리케이션의 보호된 페이지(예: /, /admin/pcs, /user/control_panel 등)에 접속을 시도합니다.
기본적인 "Forbidden" 메시지 대신, 위에서 만든 커스텀 403 오류 페이지가 표시되는지 확인합니다. 페이지에는 접속 시도한 IP 주소도 함께 표시되어야 합니다.