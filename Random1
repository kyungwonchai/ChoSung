네, 배터리와 AP(CPU) 온도 외에도 안드로이드 앱에서 직접 접근하여 측정할 수 있는 핵심적인 폰 상태 정보들이 여러 가지 있습니다. 이 정보들은 주로 기기의 성능과 직접적인 관련이 있습니다.

아래에 앱 개발 시 유용하게 사용할 수 있는 주요 항목들을 정리해 드릴게요.

## 🔋 배터리 (Battery)
BatteryManager를 통해 가장 많은 정보를 얻을 수 있습니다.

배터리 잔량 (%): 현재 남아있는 배터리 양을 퍼센트로 알 수 있습니다. (EXTRA_LEVEL, EXTRA_SCALE)

충전 상태: 현재 충전 중인지, 방전 중인지, 또는 완충 상태인지 확인할 수 있습니다. (EXTRA_STATUS)

충전 방식: USB로 충전 중인지, AC 어댑터(고속 충전)로 충전 중인지 구분할 수 있습니다. (EXTRA_PLUGGED)

배터리 전압 (Voltage): 현재 배터리의 전압을 측정할 수 있습니다.

배터리 상태 (Health): 배터리가 정상인지, 과열되었는지, 수명이 다 되었는지 등의 상태를 알 수 있습니다. (EXTRA_HEALTH)

## 🧠 메모리 (RAM)
ActivityManager를 통해 시스템의 메모리 상태를 파악할 수 있습니다.

전체 RAM 용량: 기기에 탑재된 총 RAM 용량을 알 수 있습니다.

사용 가능한 RAM 용량: 현재 시스템에서 즉시 사용할 수 있는 여유 RAM 용량을 확인할 수 있습니다. 이 값이 너무 낮으면 앱이 버벅이거나 종료될 수 있습니다.

메모리 부족 상태 (Low Memory): 시스템이 메모리 부족 상태에 진입했는지 여부를 알 수 있어, 앱에서 불필요한 리소스를 정리하는 등의 대응을 할 수 있습니다.

## ⚙️ CPU (Central Processing Unit)
CPU 관련 정보는 파일 시스템(proc/stat)을 직접 읽거나 관련 API를 통해 간접적으로 확인해야 해서 조금 더 복잡하지만, 중요한 정보들을 얻을 수 있습니다.

CPU 사용률: 전체 CPU 또는 각 코어(Core)별 사용률을 실시간으로 파악할 수 있습니다. 특정 작업 시 CPU 사용률이 급증하는 것을 모니터링할 수 있습니다.

CPU 클럭 속도 (Frequency): 현재 CPU가 어느 정도의 속도로 동작하고 있는지 확인할 수 있습니다. (예: 저전력 모드에서는 클럭이 낮아짐)

## 💾 저장 공간 (Storage)
StatFs 클래스를 통해 내부 저장 공간의 상태를 알 수 있습니다.

전체 저장 공간: 내장 메모리의 총 용량을 확인할 수 있습니다.

사용 가능한 저장 공간: 현재 남아있는 여유 공간을 확인할 수 있어, 대용량 파일 다운로드 전에 공간이 충분한지 미리 체크할 수 있습니다.

이러한 정보들을 조합하면, 조도 값과 함께 현재 기기의 부하 상태, 배터리 소모 패턴 등을 종합적으로 모니터링하는 강력한 관리 앱을 만들 수 있습니다.


충전상태.방식.잔량.배터리온도.배터리상태. ap온도 이거 10분마다 insert하되 가속도계로 지진여부 감지및 모니터링할수있게 수집하게 관련코드모두수정.단 ui는그대로(lux) 데이터 수집부분만 추가수정하면되





생각하는 과정 표시
네, 그럼요! 기존 기능은 그대로 유지하면서, 요청하신 휴대폰 상태 상세 로깅과 가속도계를 이용한 진동 감지 기능을 모두 추가하여 프로젝트를 업그레이드해 드리겠습니다.

UI는 그대로 두고 백그라운드에서 모든 데이터 수집이 이루어지도록 코드를 수정했습니다. 말씀하신 대로, 조금이라도 수정된 파일은 전체 코드를 제공하고, 수정된 부분은 주석으로 명확하게 표시했습니다.

## 개선 사항 요약
휴대폰 상태 로깅 (10분 간격):

10분마다 배터리 잔량, 온도, 상태, 충전 여부/방식 및 AP(CPU) 온도를 수집합니다.

수집된 데이터를 새로운 API 주소인 /logStatus로 INSERT합니다.

진동 감지 및 로깅 (실시간):

가속도 센서를 이용해 휴대폰의 움직임을 실시간으로 모니터링합니다.

지진과 유사한 강한 흔들림이 감지되면, 해당 시점의 X, Y, Z축 가속도 값을 새로운 API 주소인 /logVibration으로 INSERT합니다.

서버에 과도한 요청이 가지 않도록, 한번 감지된 후에는 30초의 쿨다운을 갖습니다.

코드 구조:

기능별로 코드를 함수로 분리하여 가독성과 유지보수성을 높였습니다.

## 1단계: API 서버 수정 (server.js)
먼저, 새로운 데이터를 받아 저장할 수 있도록 우분투 서버의 server.js 파일을 수정해야 합니다. 2개의 새로운 주소(logStatus, logVibration)와 각각에 맞는 INSERT 쿼리가 추가됩니다.

서버 측에서 준비할 DB 테이블 (쿼리 예시)
새로운 데이터를 저장하기 위해 MSSQL에 아래와 같은 테이블 2개를 미리 만들어두시는 것을 추천합니다.

SQL

-- 10분마다 폰 상태를 저장할 테이블
CREATE TABLE PhoneStatusLog (
    LogID INT PRIMARY KEY IDENTITY(1,1),
    DeviceId VARCHAR(100),
    BatteryLevel INT,
    BatteryTemp FLOAT,
    IsCharging BIT,
    ChargeType VARCHAR(50),
    BatteryHealth VARCHAR(50),
    ApTemp FLOAT,
    Timestamp DATETIME DEFAULT GETDATE()
);

-- 진동 감지 시 데이터를 저장할 테이블
CREATE TABLE VibrationLog (
    LogID INT PRIMARY KEY IDENTITY(1,1),
    DeviceId VARCHAR(100),
    AccelX FLOAT,
    AccelY FLOAT,
    AccelZ FLOAT,
    Timestamp DATETIME DEFAULT GETDATE()
);
server.js 최종 코드
기존 server.js 파일의 내용을 모두 지우고 아래 코드로 완전히 덮어쓰세요.

JavaScript

const express = require('express');
const sql = require('mssql');

const app = express();
app.use(express.json());

const SECRET_API_KEY = "LightMeter-Secret-Key-1234";

const apiKeyMiddleware = (req, res, next) => {
    const apiKey = req.get('x-api-key');
    if (!apiKey || apiKey !== SECRET_API_KEY) {
        return res.status(401).send('Unauthorized');
    }
    next();
};

const dbConfig = {
    user: '사용자ID',
    password: '비밀번호',
    server: '내서버IP',
    database: '데이터베이스이름',
    pool: { max: 10, min: 0, idleTimeoutMillis: 30000 },
    options: { encrypt: false, trustServerCertificate: true }
};

const poolPromise = new sql.ConnectionPool(dbConfig)
    .connect()
    .then(pool => {
        console.log('✅ DB 연결 풀 생성 완료');
        return pool;
    })
    .catch(err => console.error('DB 연결 풀 생성 실패', err));


// 실시간 조도 UPDATE (기존과 동일)
app.post('/log', apiKeyMiddleware, async (req, res) => {
    const { deviceId, lux } = req.body;
    if (deviceId === undefined || lux === undefined) return res.status(400).send('값이 없습니다.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('LuxValue', sql.Float, lux)
            .input('DeviceId', sql.VarChar, deviceId)
            .query('UPDATE Table_Lux2 SET lux1 = @LuxValue WHERE ip1 = @DeviceId');
        res.status(200).send('실시간 데이터 업데이트 성공');
    } catch (err) {
        console.error('DB 오류 (실시간 UPDATE):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// 1분 평균 조도 INSERT (기존과 동일)
app.post('/log1min', apiKeyMiddleware, async (req, res) => {
    const { deviceId, avgLux } = req.body;
    if (deviceId === undefined || avgLux === undefined) return res.status(400).send('값이 없습니다.');
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('LuxValue', sql.Float, avgLux)
            .query('INSERT Table_Lux1min (ip1, lux1) VALUES (@DeviceId, @LuxValue)');
        console.log(`[1분 평균] 데이터 저장 성공: ${deviceId} - ${avgLux} lux`);
        res.status(200).send('1분 평균 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (1분 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// --- [추가] 10분 폰 상태 INSERT ---
app.post('/logStatus', apiKeyMiddleware, async (req, res) => {
    const { deviceId, batteryLevel, batteryTemp, isCharging, chargeType, batteryHealth, apTemp } = req.body;
    if (deviceId === undefined) return res.status(400).send('deviceId가 없습니다.');
    
    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('BatteryLevel', sql.Int, batteryLevel)
            .input('BatteryTemp', sql.Float, batteryTemp)
            .input('IsCharging', sql.Bit, isCharging)
            .input('ChargeType', sql.VarChar, chargeType)
            .input('BatteryHealth', sql.VarChar, batteryHealth)
            .input('ApTemp', sql.Float, apTemp)
            .query('INSERT INTO PhoneStatusLog (DeviceId, BatteryLevel, BatteryTemp, IsCharging, ChargeType, BatteryHealth, ApTemp) VALUES (@DeviceId, @BatteryLevel, @BatteryTemp, @IsCharging, @ChargeType, @BatteryHealth, @ApTemp)');
        
        console.log(`[10분 상태] 데이터 저장 성공: ${deviceId}`);
        res.status(200).send('10분 상태 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (10분 상태 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});

// --- [추가] 진동 감지 INSERT ---
app.post('/logVibration', apiKeyMiddleware, async (req, res) => {
    const { deviceId, x, y, z } = req.body;
    if (deviceId === undefined) return res.status(400).send('deviceId가 없습니다.');

    try {
        const pool = await poolPromise;
        await pool.request()
            .input('DeviceId', sql.VarChar, deviceId)
            .input('AccelX', sql.Float, x)
            .input('AccelY', sql.Float, y)
            .input('AccelZ', sql.Float, z)
            .query('INSERT INTO VibrationLog (DeviceId, AccelX, AccelY, AccelZ) VALUES (@DeviceId, @AccelX, @AccelY, @AccelZ)');
        
        console.log(`[진동 감지] 데이터 저장 성공: ${deviceId}`);
        res.status(200).send('진동 감지 데이터 저장 성공');
    } catch (err) {
        console.error('DB 오류 (진동 감지 INSERT):', err);
        res.status(500).send('서버 오류 발생');
    }
});


const PORT = 3000;
app.listen(PORT, () => {
    console.log(`API 서버가 ${PORT}번 포트에서 실행 중입니다.`);
});
## 2단계: 안드로이드 앱 수정 (MainActivity.kt)
이제 안드로이드 앱이 백그라운드에서 새로운 데이터들을 수집하고 서버로 보내도록 수정합니다.

파일 위치: app/src/main/java/com/sec/lightmeter/MainActivity.kt

수정 방법: 기존 파일 내용을 모두 지우고 아래 코드로 완전히 덮어쓰세요.

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.content.Intent
import android.content.IntentFilter
import android.content.SharedPreferences
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.BatteryManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import android.view.WindowManager
import android.widget.Toast
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import okhttp3.Interceptor
import okhttp3.OkHttpClient
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.converter.scalars.ScalarsConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST
import java.io.File
import kotlin.math.sqrt

// --- [수정] 데이터 클래스 추가 ---
data class RealtimeLog(val deviceId: String, val lux: Float)
data class MinuteLog(val deviceId: String, val avgLux: Float)
data class PhoneStatusLog(val deviceId: String, val batteryLevel: Int, val batteryTemp: Float, val isCharging: Boolean, val chargeType: String, val batteryHealth: String, val apTemp: Float)
data class VibrationLog(val deviceId: String, val x: Float, val y: Float, val z: Float)


// --- [수정] API 인터페이스 추가 ---
interface ApiService {
    @POST("log")
    fun postRealtimeLog(@Body data: RealtimeLog): Call<String>
    @POST("log1min")
    fun postMinuteLog(@Body data: MinuteLog): Call<String>
    @POST("logStatus")
    fun postPhoneStatus(@Body data: PhoneStatusLog): Call<String>
    @POST("logVibration")
    fun postVibration(@Body data: VibrationLog): Call<String>
}

class MainActivity : AppCompatActivity(), SensorEventListener {

    private val API_KEY = "LightMeter-Secret-Key-1234"

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null
    // --- [추가] 가속도 센서 변수 ---
    private var accelerometer: Sensor? = null
    private lateinit var apiService: ApiService
    private lateinit var sharedPreferences: SharedPreferences
    private var currentDeviceId: String = ""
    private var latestLuxValue: Float = 0.0f
    
    // --- [수정] 타이머 핸들러 추가 ---
    private val handlerRealtime = Handler(Looper.getMainLooper())
    private val handlerMinute = Handler(Looper.getMainLooper())
    private val handlerStatus = Handler(Looper.getMainLooper()) // 10분 상태 로깅용
    private val minuteLuxReadings = mutableListOf<Float>()

    // --- [추가] 진동 감지 관련 변수 ---
    private val VIBRATION_THRESHOLD = 20.0f // 진동 감지 임계값 (기본값: 중력가속도(~9.8)의 2배 이상)
    private val VIBRATION_LOG_COOLDOWN = 30000L // 30초 쿨다운 (밀리초)
    private var lastVibrationLogTime = 0L

    // 1초마다 실시간 조도 전송 및 데이터 수집
    private val runnableRealtime = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) sendRealtimeDataToServer(currentDeviceId, latestLuxValue)
            minuteLuxReadings.add(latestLuxValue)
            handlerRealtime.postDelayed(this, 1000)
        }
    }

    // 1분마다 평균 조도 전송
    private val runnableMinute = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty() && minuteLuxReadings.isNotEmpty()) {
                val avgLux = minuteLuxReadings.average().toFloat()
                sendMinuteDataToServer(currentDeviceId, avgLux)
                minuteLuxReadings.clear()
            }
            handlerMinute.postDelayed(this, 60000)
        }
    }
    
    // --- [추가] 10분마다 폰 상태 전송 ---
    private val runnableStatus = object : Runnable {
        override fun run() {
            if (currentDeviceId.isNotEmpty()) {
                val status = getPhoneStatus()
                sendPhoneStatusToServer(status)
            }
            // 10분(600000ms) 후에 다시 실행
            handlerStatus.postDelayed(this, 600000)
        }
    }

    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)
        window.addFlags(WindowManager.LayoutParams.FLAG_KEEP_SCREEN_ON)
        sharedPreferences = getSharedPreferences("LightMeterPrefs", Context.MODE_PRIVATE)
        setupUI()
        loadDeviceId()
        setupSensor()
        setupNetwork()
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        // --- [추가] 가속도 센서 초기화 ---
        accelerometer = sensorManager.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)
        
        if (lightSensor == null) {
            binding.tvLuxValue.text = "조도 센서 없음"
            binding.tvUnit.text = ""
        }
    }

    override fun onResume() {
        super.onResume()
        // --- [수정] 모든 센서 리스너 등록 및 타이머 시작 ---
        sensorManager.registerListener(this, lightSensor, SensorManager.SENSOR_DELAY_UI)
        sensorManager.registerListener(this, accelerometer, SensorManager.SENSOR_DELAY_NORMAL)
        handlerRealtime.post(runnableRealtime)
        handlerMinute.post(runnableMinute)
        handlerStatus.post(runnableStatus)
    }

    override fun onPause() {
        super.onPause()
        // --- [수정] 모든 센서 리스너 해제 및 타이머 중지 ---
        sensorManager.unregisterListener(this)
        handlerRealtime.removeCallbacks(runnableRealtime)
        handlerMinute.removeCallbacks(runnableMinute)
        handlerStatus.removeCallbacks(runnableStatus)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        // --- [수정] 센서 타입에 따라 분기 처리 ---
        when (event?.sensor?.type) {
            Sensor.TYPE_LIGHT -> {
                val luxValue = event.values[0]
                binding.tvLuxValue.text = "%.1f".format(luxValue)
                latestLuxValue = luxValue
                val colorResId = when {
                    luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                    luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                    else -> R.color.spec_in_black
                }
                binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
            }
            Sensor.TYPE_ACCELEROMETER -> {
                val x = event.values[0]
                val y = event.values[1]
                val z = event.values[2]
                // 중력가속도를 제외한 순수 가속도 계산
                val acceleration = sqrt(x * x + y * y + z * z) - SensorManager.GRAVITY_EARTH

                // 임계값을 넘고 쿨다운이 지났으면 진동으로 판단
                if (acceleration > VIBRATION_THRESHOLD) {
                    val currentTime = System.currentTimeMillis()
                    if (currentTime - lastVibrationLogTime > VIBRATION_LOG_COOLDOWN) {
                        lastVibrationLogTime = currentTime
                        Log.d("VibrationDetector", "강한 진동 감지! 값: $acceleration")
                        if (currentDeviceId.isNotEmpty()) {
                            sendVibrationDataToServer(currentDeviceId, x, y, z)
                        }
                    }
                }
            }
        }
    }

    // --- [추가] 폰 상태 정보를 가져오는 함수 ---
    private fun getPhoneStatus(): PhoneStatusLog {
        // 배터리 정보 가져오기
        val batteryIntent: Intent? = IntentFilter(Intent.ACTION_BATTERY_CHANGED).let { filter ->
            applicationContext.registerReceiver(null, filter)
        }
        val level = batteryIntent?.getIntExtra(BatteryManager.EXTRA_LEVEL, -1) ?: -1
        val scale = batteryIntent?.getIntExtra(BatteryManager.EXTRA_SCALE, -1) ?: -1
        val batteryPct = if (level != -1 && scale != -1) (level * 100 / scale.toFloat()).toInt() else -1
        val temp = batteryIntent?.getIntExtra(BatteryManager.EXTRA_TEMPERATURE, -1)?.toFloat()?.div(10) ?: -1.0f
        val status = batteryIntent?.getIntExtra(BatteryManager.EXTRA_STATUS, -1) ?: -1
        val isCharging = status == BatteryManager.BATTERY_STATUS_CHARGING || status == BatteryManager.BATTERY_STATUS_FULL
        val chargePlug = batteryIntent?.getIntExtra(BatteryManager.EXTRA_PLUGGED, -1) ?: -1
        val chargeType = when (chargePlug) {
            BatteryManager.BATTERY_PLUGGED_AC -> "AC"
            BatteryManager.BATTERY_PLUGGED_USB -> "USB"
            BatteryManager.BATTERY_PLUGGED_WIRELESS -> "Wireless"
            else -> "Unplugged"
        }
        val health = batteryIntent?.getIntExtra(BatteryManager.EXTRA_HEALTH, -1) ?: -1
        val batteryHealth = when (health) {
            BatteryManager.BATTERY_HEALTH_GOOD -> "Good"
            BatteryManager.BATTERY_HEALTH_OVERHEAT -> "Overheat"
            BatteryManager.BATTERY_HEALTH_DEAD -> "Dead"
            BatteryManager.BATTERY_HEALTH_OVER_VOLTAGE -> "Over Voltage"
            BatteryManager.BATTERY_HEALTH_UNSPECIFIED_FAILURE -> "Failure"
            else -> "Unknown"
        }

        // AP 온도 가져오기
        val apTemp = getApTemperature()

        return PhoneStatusLog(currentDeviceId, batteryPct, temp, isCharging, chargeType, batteryHealth, apTemp)
    }

    // --- [추가] AP 온도를 읽는 함수 (기기 의존적일 수 있음) ---
    private fun getApTemperature(): Float {
        // 일반적인 AP 온도 파일 경로들을 순회하며 값을 읽음
        val thermalPaths = listOf(
            "/sys/class/thermal/thermal_zone1/temp",
            "/sys/class/thermal/thermal_zone2/temp",
            "/sys/class/thermal/thermal_zone3/temp",
            "/sys/class/thermal/thermal_zone4/temp",
            "/sys/class/thermal/thermal_zone5/temp",
            "/sys/class/thermal/thermal_zone6/temp"
        )
        for (path in thermalPaths) {
            try {
                val tempStr = File(path).readText()
                val temp = tempStr.trim().toFloat()
                // 온도가 비정상적으로 높거나 낮지 않은 경우 반환 (보통 1000단위로 나눔)
                if (temp > 0 && temp < 200000) {
                    return temp / 1000.0f
                }
            } catch (e: Exception) {
                // 파일을 읽을 수 없는 경우 다음 경로 시도
            }
        }
        return -1.0f // 모든 경로에서 실패 시
    }

    // --- [추가] 폰 상태 전송 함수 ---
    private fun sendPhoneStatusToServer(status: PhoneStatusLog) {
        apiService.postPhoneStatus(status).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "10분 상태 전송 성공")
                else Log.e("NetworkError", "10분 상태 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "10분 상태 네트워크 오류: ${t.message}")
            }
        })
    }

    // --- [추가] 진동 데이터 전송 함수 ---
    private fun sendVibrationDataToServer(deviceId: String, x: Float, y: Float, z: Float) {
        val logData = VibrationLog(deviceId, x, y, z)
        apiService.postVibration(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "진동 데이터 전송 성공")
                else Log.e("NetworkError", "진동 데이터 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "진동 데이터 네트워크 오류: ${t.message}")
            }
        })
    }

    // --- 이하 기존 함수들 (변경 없음) ---
    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) { /* Do nothing */ }
    private fun setupNetwork() {
        val apiKeyInterceptor = Interceptor { chain ->
            chain.proceed(chain.request().newBuilder().header("x-api-key", API_KEY).build())
        }
        val okHttpClient = OkHttpClient.Builder().addInterceptor(apiKeyInterceptor).build()
        val retrofit = Retrofit.Builder()
            .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/")
            .client(okHttpClient)
            .addConverterFactory(ScalarsConverterFactory.create())
            .addConverterFactory(GsonConverterFactory.create())
            .build()
        apiService = retrofit.create(ApiService::class.java)
    }
    private fun setupUI() {
        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)
        binding.btnSaveDeviceId.setOnClickListener {
            val deviceId = binding.etDeviceId.text.toString().trim()
            if (deviceId.isNotEmpty()) saveDeviceId(deviceId)
        }
    }
    private fun loadDeviceId() {
        val savedId = sharedPreferences.getString("DEVICE_ID", "") ?: ""
        currentDeviceId = savedId
        binding.tvCurrentDeviceId.text = if (savedId.isNotEmpty()) getString(R.string.current_device_id_label, savedId) else getString(R.string.current_device_id_label, getString(R.string.device_id_not_set))
    }
    private fun saveDeviceId(deviceId: String) {
        sharedPreferences.edit().putString("DEVICE_ID", deviceId).apply()
        currentDeviceId = deviceId
        binding.tvCurrentDeviceId.text = getString(R.string.current_device_id_label, deviceId)
        Toast.makeText(this, getString(R.string.device_id_saved_message), Toast.LENGTH_SHORT).show()
    }
    private fun sendRealtimeDataToServer(deviceId: String, lux: Float) {
        val logData = RealtimeLog(deviceId = deviceId, lux = lux)
        apiService.postRealtimeLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (!response.isSuccessful) Log.e("NetworkError", "실시간 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "실시간 네트워크 오류: ${t.message}")
            }
        })
    }
    private fun sendMinuteDataToServer(deviceId: String, avgLux: Float) {
        val logData = MinuteLog(deviceId = deviceId, avgLux = avgLux)
        apiService.postMinuteLog(logData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) Log.d("NetworkSuccess", "1분 평균 전송 성공")
                else Log.e("NetworkError", "1분 평균 전송 실패: ${response.code()}")
            }
            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "1분 평균 네트워크 오류: ${t.message}")
            }
        })
    }
}

소스
pm2 




동영상
