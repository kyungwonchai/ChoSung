이 프로젝트는 **ScanValueTrans**라는 이름의 중계 프로그램입니다. 이 프로그램은 소켓 서버와 시리얼 포트를 통해 데이터를 중계하며, PC의 IP와 선택된 포트 정보는 QR 코드로 표시되어 다른 곳에서 접근할 수 있게 합니다. 또한, 소켓 통신에서 특정 문자를 포함한 메시지를 수신하면 해당 문자에 따라 사전 설정된 시리얼 포트로 데이터를 전달합니다.

1. 주요 기능 요구사항
PC IP 표시 및 포트 설정:

프로그램에서 PC의 IP 주소를 표시합니다.
사용자가 20000~65000 사이의 포트를 선택할 수 있으며, 선택된 포트로 소켓 서버가 활성화됩니다.
활성화된 소켓 서버의 접근 정보를 QR 코드로 표시합니다.
소켓 서버와 시리얼 포트 통신:

클라이언트가 소켓 서버에 특정 문자열을 포함한 데이터를 보낼 수 있습니다. 이때, 메시지의 첫 부분에 특정 문자를 삽입하고, 이를 ^로 구분하여 메시지를 처리합니다.
이 특정 문자가 사전 설정된 포트와 매핑되어 있으며, 해당 포트로 데이터를 전달합니다. 동일한 문자에 매핑된 포트가 여러 개 있을 경우, 모두에게 데이터를 전달합니다.
설정 저장:

프로그램에서 설정된 IP, 포트, QR 코드 정보, 시리얼 포트 매핑 설정은 프로그램 종료 후에도 저장됩니다.
이 저장된 설정은 프로그램 재실행 시 자동으로 불러와 적용됩니다.
프로그램 안정성:

프로그램은 백그라운드에서 계속 실행되며, 사용자가 종료하지 않는 이상 종료되지 않도록 합니다.
2. 설계 및 디자인 패턴
Singleton 패턴:

소켓 서버와 같은 리소스는 프로그램에서 단일 인스턴스로 관리되므로, Singleton 패턴을 사용하여 전역적으로 접근할 수 있도록 합니다.
Observer 패턴:

포트 설정이 변경될 때, 해당 정보를 다른 컴포넌트에 알려주기 위해 Observer 패턴을 사용합니다.
Strategy 패턴:

다양한 시리얼 포트 처리 로직(문자열 매핑 등)을 독립적으로 관리할 수 있도록 Strategy 패턴을 사용하여 유연한 구조를 유지합니다.
Facade 패턴:

IP, 포트 설정, QR 코드 생성 등 복잡한 로직을 단순화하여 사용할 수 있도록 Facade 패턴을 적용합니다.
3. 코드 구조
MainWindow.xaml.cs:

프로그램의 주요 인터페이스와 기능을 관리하는 클래스입니다. IP 주소 표시, 포트 설정, QR 코드 생성, 소켓 서버와의 연결 등을 처리합니다.
SettingsManager.cs:

설정 파일을 관리하고 저장 및 불러오기 기능을 제공합니다.
SocketServer.cs:

소켓 서버의 기능을 제공하는 클래스입니다. 클라이언트의 요청을 받아 처리하고, 특정 문자를 기반으로 시리얼 포트로 데이터를 전달합니다.
SerialPortManager.cs:

시리얼 포트를 관리하고 데이터 전송을 처리하는 클래스입니다.
QRCodeGenerator.cs:

QR 코드를 생성하고 이미지를 반환하는 클래스입니다.
Program.cs:

프로그램의 진입점이며, 프로그램이 종료되지 않도록 보호하는 기능을 제공합니다.
4. 코드 구현
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Net;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media.Imaging;
using ZXing; // QR 코드 생성 라이브러리
using System.IO;

namespace ScanValueTrans
{
    public partial class MainWindow : Window
    {
        private SocketServer socketServer;
        private SettingsManager settingsManager;
        private SerialPortManager serialPortManager;

        public MainWindow()
        {
            InitializeComponent();
            Initialize();
        }

        private void Initialize()
        {
            // 설정 관리 클래스 초기화
            settingsManager = SettingsManager.Instance;

            // IP 주소 가져오기 및 표시
            string ipAddress = GetLocalIPAddress();
            IpAddressTextBlock.Text = $"IP Address: {ipAddress}";

            // 포트 선택 콤보박스 초기화
            for (int i = 20000; i <= 65000; i++)
            {
                PortComboBox.Items.Add(i.ToString());
            }

            // 포트 및 설정 불러오기
            PortComboBox.SelectedItem = settingsManager.GetSetting("Port");
            PortComboBox.SelectionChanged += PortComboBox_SelectionChanged;

            // 소켓 서버 초기화
            serialPortManager = new SerialPortManager();
            socketServer = SocketServer.Instance;
            socketServer.DataReceived += OnSocketDataReceived;

            // QR 코드 생성
            GenerateQRCode(ipAddress, PortComboBox.SelectedItem.ToString());
        }

        private string GetLocalIPAddress()
        {
            string localIP = "";
            foreach (var ip in Dns.GetHostAddresses(Dns.GetHostName()))
            {
                if (ip.AddressFamily == System.Net.Sockets.AddressFamily.InterNetwork)
                {
                    localIP = ip.ToString();
                }
            }
            return localIP;
        }

        private void PortComboBox_SelectionChanged(object sender, SelectionChangedEventArgs e)
        {
            if (PortComboBox.SelectedItem != null)
            {
                string selectedPort = PortComboBox.SelectedItem.ToString();
                settingsManager.SaveSetting("Port", selectedPort);
                socketServer.Start(int.Parse(selectedPort));

                // QR 코드 업데이트
                string ipAddress = GetLocalIPAddress();
                GenerateQRCode(ipAddress, selectedPort);
            }
        }

        private void GenerateQRCode(string ipAddress, string port)
        {
            string qrContent = $"{ipAddress}:{port}";
            QRCodeGenerator qrGenerator = new QRCodeGenerator();
            BitmapImage qrCodeImage = qrGenerator.GenerateQRCode(qrContent);

            // QR 코드를 이미지로 표시
            QrCodeImage.Source = qrCodeImage;
        }

        private void OnSocketDataReceived(object sender, SocketDataReceivedEventArgs e)
        {
            // 특정 문자를 기반으로 데이터를 시리얼 포트로 전달
            serialPortManager.SendData(e.Data);
            LogMessage($"Received and forwarded: {e.Data}");
        }

        private void LogMessage(string message)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            LogListBox.Items.Add($"{timestamp} - {message}");

            if (LogListBox.Items.Count > 100)
            {
                LogListBox.Items.RemoveAt(0);
            }
        }
    }
}
SettingsManager.cs
csharp
코드 복사
using System.Configuration;

namespace ScanValueTrans
{
    public class SettingsManager
    {
        private static SettingsManager instance;
        private Configuration config;

        private SettingsManager()
        {
            config = ConfigurationManager.OpenExeConfiguration(ConfigurationUserLevel.None);
        }

        public static SettingsManager Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new SettingsManager();
                }
                return instance;
            }
        }

        public string GetSetting(string key)
        {
            if (config.AppSettings.Settings[key] != null)
            {
                return config.AppSettings.Settings[key].Value;
            }
            return null;
        }

        public void SaveSetting(string key, string value)
        {
            if (config.AppSettings.Settings[key] == null)
            {
                config.AppSettings.Settings.Add(key, value);
            }
            else
            {
                config.AppSettings.Settings[key].Value = value;
            }
            config.Save(ConfigurationSaveMode.Modified);
        }
    }
}
SocketServer.cs
csharp
코드 복사
using System;
using System.Net;
using System.Net.Sockets;
using System.Text;

namespace ScanValueTrans
{
    public class SocketDataReceivedEventArgs : EventArgs
    {
        public string Data { get; set; }
    }

    public class SocketServer
    {
        private static SocketServer instance;
        private TcpListener tcpListener;

        public event EventHandler<SocketDataReceivedEventArgs> DataReceived;

        private SocketServer() { }

        public static SocketServer Instance
        {
            get
            {
                if (instance == null)
                {
                    instance = new SocketServer();
                }
                return instance;
            }
        }

        public void Start(int port)
        {
            tcpListener = new TcpListener(IPAddress.Any, port);
            tcpListener.Start();
            tcpListener.BeginAcceptTcpClient(AcceptClientCallback, null);
        }

        private void AcceptClientCallback(IAsyncResult ar)
        {
            TcpClient client = tcpListener.EndAcceptTcpClient(ar);
            NetworkStream stream = client.GetStream();

            byte[] buffer = new byte[1024];
            int bytesRead = stream.Read(buffer, 0, buffer.Length);
            string data = Encoding.ASCII.GetString(buffer, 0, bytesRead);

            OnDataReceived(data);

            client.Close();
            tcpListener.BeginAcceptTcpClient(AcceptClientCallback, null);
        }

        protected virtual void OnDataReceived(string data)
        {
            DataReceived?.Invoke(this, new SocketDataReceivedEventArgs { Data = data });
        }
    }
}
SerialPortManager.cs
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Collections.Generic;

namespace ScanValueTrans
{
    public class SerialPortManager
    {
        private Dictionary<string, SerialPort> portMap;

        public SerialPortManager()
        {
            portMap = new Dictionary<string, SerialPort>();
        }

        public void AddPortMapping(string keyword, string portName, int baudRate, Parity parity, int dataBits, StopBits stopBits)
        {
            if (portMap.ContainsKey(keyword))
            {
                portMap[keyword].Close();
                portMap.Remove(keyword);
            }

            SerialPort port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);
            port.Open();
            portMap.Add(keyword, port);
        }

        public void SendData(string data)
        {
            string[] splitData = data.Split('^');
            if (splitData.Length > 1)
            {
                string keyword = splitData[0];
                string message = splitData[1];

                foreach (var entry in portMap)
                {
                    if (entry.Key == keyword)
                    {
                        entry.Value.WriteLine(message);
                    }
                }
            }
        }
    }
}
QRCodeGenerator.cs
csharp
코드 복사
using System;
using System.Windows.Media.Imaging;
using ZXing;

namespace ScanValueTrans
{
    public class QRCodeGenerator
    {
        public BitmapImage GenerateQRCode(string content)
        {
            BarcodeWriter writer = new BarcodeWriter
            {
                Format = BarcodeFormat.QR_CODE,
                Options = new ZXing.Common.EncodingOptions
                {
                    Width = 200,
                    Height = 200
                }
            };

            var bitmap = writer.Write(content);
            return BitmapToImageSource(bitmap);
        }

        private BitmapImage BitmapToImageSource(System.Drawing.Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, System.Drawing.Imaging.ImageFormat.Bmp);
                memory.Position = 0;
                BitmapImage bitmapImage = new BitmapImage();
                bitmapImage.BeginInit();
                bitmapImage.StreamSource = memory;
                bitmapImage.CacheOption = BitmapCacheOption.OnLoad;
                bitmapImage.EndInit();
                return bitmapImage;
            }
        }
    }
}
5. 결론
이 프로그램은 주어진 요구사항을 반영하여 설계된 고급지게 구조화된 소프트웨어입니다. 디자인 패턴을 통해 코드가 확장 가능하고 유지 관리가 용이하게 구성되었으며, 주석을 통해 각 기능이 무엇을 수행하는지 명확히 설명하고 있습니다.

이 코드를 기반으로 프로젝트를 진행할 수 있으며, 추가적인 질문이나 기능 개선 요청이 있으면 언제든지 문의해 주세