번에 정확히 반영해야 할 핵심은 바로 이거야:

추가 조건 핵심 요약:
ACT1_1 ~ ACT1_8, ACT2BEST1_1 ~ ACT2BEST1_8 의 16개 float 컬럼은

각 컬럼별로 이상치를 제거해야 함

즉, 1사분위수(Q1) ~ 3사분위수(Q3) 사이의 값만 인정

그 안에서 컬럼별 최대값을 구함

그 다음 단계는 이전과 동일:

각 row별로 ACT1군 최대, ACT2BEST군 최대를 구하고

둘 중 작은 값을 NeckCT 로 간주

각 고유 키별로 NeckCT가 가장 낮은 time1만 추출

해결 방법 설계 (MSSQL 2014 스타일로):
MSSQL 2014에는 Python이나 R처럼 컬럼별 분위수를 바로 계산하기 어렵기 때문에 UNPIVOT + PERCENTILE_CONT() + 다시 PIVOT 방식으로 해야 해.

최종 쿼리 (전체 설계 + 아주 상세한 주석 포함):
sql
코드 복사
-- 1. 최근 5시간 이내 데이터 필터링
WITH RawData AS (
    SELECT
        id1, line1, model1, type1, ecn1, edition1, time1,
        ACT1_1, ACT1_2, ACT1_3, ACT1_4,
        ACT1_5, ACT1_6, ACT1_7, ACT1_8,
        ACT2BEST1_1, ACT2BEST1_2, ACT2BEST1_3, ACT2BEST1_4,
        ACT2BEST1_5, ACT2BEST1_6, ACT2BEST1_7, ACT2BEST1_8
    FROM dbo.ExcelData
    WHERE time1 >= DATEADD(HOUR, -5, GETDATE())
),

-- 2. UNPIVOT: 각 ACT 컬럼들을 행(row) 형태로 변환 (컬럼명을 ColName으로)
Unpivoted AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        ColName, Value
    FROM RawData
    UNPIVOT (
        Value FOR ColName IN (
            ACT1_1, ACT1_2, ACT1_3, ACT1_4,
            ACT1_5, ACT1_6, ACT1_7, ACT1_8,
            ACT2BEST1_1, ACT2BEST1_2, ACT2BEST1_3, ACT2BEST1_4,
            ACT2BEST1_5, ACT2BEST1_6, ACT2BEST1_7, ACT2BEST1_8
        )
    ) AS u
    WHERE Value IS NOT NULL
),

-- 3. 분위수 계산: 각 컬럼별(Q1, Q3)
WithQuantiles AS (
    SELECT
        ColName,
        PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q1,
        PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY Value) OVER (PARTITION BY ColName) AS Q3,
        line1, model1, type1, ecn1, edition1, time1, Value
    FROM Unpivoted
),

-- 4. 이상치 제거: Q1~Q3 범위 내 값만 유지
FilteredCT AS (
    SELECT *
    FROM WithQuantiles
    WHERE Value BETWEEN Q1 AND Q3
),

-- 5. 컬럼 이름을 기반으로 ACT 그룹 분류
WithGroupType AS (
    SELECT *,
        CASE 
            WHEN ColName LIKE 'ACT1[_]%' THEN 'ACT1'
            WHEN ColName LIKE 'ACT2BEST1[_]%' THEN 'ACT2BEST'
        END AS GroupType
    FROM FilteredCT
),

-- 6. 각 row(time1 기준)에 대해 ACT1, ACT2BEST 각각의 max 계산
MaxPerRow AS (
    SELECT
        line1, model1, type1, ecn1, edition1, time1,
        MAX(CASE WHEN GroupType = 'ACT1' THEN Value END) AS Max_ACT1,
        MAX(CASE WHEN GroupType = 'ACT2BEST' THEN Value END) AS Max_ACT2BEST
    FROM WithGroupType
    GROUP BY line1, model1, type1, ecn1, edition1, time1
),

-- 7. 두 군 중 작은 값으로 NeckCT 계산
WithNeckCT AS (
    SELECT *,
        CASE 
            WHEN Max_ACT1 < Max_ACT2BEST THEN Max_ACT1
            ELSE Max_ACT2BEST
        END AS NeckCT
    FROM MaxPerRow
),

-- 8. 각 Key(line1~edition1) 그룹에서 NeckCT가 가장 작은 시간만 남기기
Ranked AS (
    SELECT *,
        ROW_NUMBER() OVER (
            PARTITION BY line1, model1, type1, ecn1, edition1
            ORDER BY NeckCT ASC
        ) AS RN
    FROM WithNeckCT
)

-- 9. 최종 결과 출력
SELECT
    line1, model1, type1, ecn1, edition1, time1,
    Max_ACT1, Max_ACT2BEST,
    NeckCT
FROM Ranked
WHERE RN = 1
ORDER BY line1, model1, type1, ecn1, edition1;
결과 컬럼 예시:
line1	model1	type1	ecn1	edition1	time1	Max_ACT1	Max_ACT2BEST	NeckCT
SMD_12	ABC123	PKG1	E123	R1	11:30	0.52	0.60	0.52
SMD_12	DEF456	PKG2	E200	R2	12:00	0.64	0.58	0.58
이제 이 쿼리는:

이상치를 제거한 상태로 군별 Max

NeckCT = 두 군 max 중 더 작은 값

그 값이 가장 작았던 시간 하나만 추출

을 정확히 만족해.
