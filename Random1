import java.time.LocalDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.Queue;
import java.util.UUID;
import java.util.concurrent.CompletableFuture;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentLinkedQueue;

// ============================================================
// == 실행을 위한 메인 클래스
// ============================================================
public class TrackingSystemRunner {

    public static void main(String[] args) {
        System.out.println("====== 수배자 추적 시스템 시뮬레이션 시작 ======");

        // --- 시스템 전체의 구성요소(Component) 생성 (DI 컨테이너 역할) ---

        // 로거 생성
        I로깅서비스 logger = new ConsoleLogger();

        // AI 서버 구성
        I추적데이터저장_AI trackingHistoryRepo = new TrackingHistoryRepository();
        StrategyPlannerFacade strategyPlanner = new StrategyPlannerFacade(trackingHistoryRepo);
        
        // App 서버와 AI 서버를 연결할 가상 메시지 큐 생성
        // TaskReceiver가 strategyPlanner를 통해 상태를 변경하도록 연결
        TaskReceiver taskReceiver = new TaskReceiver(strategyPlanner);
        VirtualMessageBroker messageBroker = new VirtualMessageBroker(taskReceiver);

        // App 서버 구성
        I영상소스제공_App cctvGw = new CctvGateway();
        I비동기이벤트발행_App mqGw = new MqGateway(messageBroker); // 가상 메시지큐 주입
        I명령팩토리 realTimeFactory = new 실시간추적명령팩토리(cctvGw, mqGw);
        커맨드실행기 invoker = new 커맨드실행기();
        I추적오케스트레이션 service = new TrackingOrchestrationService(realTimeFactory, invoker, logger);

        
        // --- 시뮬레이션 시작 ---
        System.out.println("\n--- [시나리오 1] 경찰관 A, 'S-001' 실시간 추적 요청 ---");
        추적요청DTO request = new 추적요청DTO("S-001", "강남역 일대", "officerA");
        CompletableFuture<String> jobIdFuture = service.추적요청처리(request);
        String jobId = jobIdFuture.join(); // 비동기 작업이지만 여기서는 결과를 기다림
        
        System.out.println("\n--- [시나리오 2] AI 서버, 'S-001' 발견! (탐색중 -> 추적중) ---");
        // AI가 용의자를 찾았다고 가정하고, 'FOUND' 이벤트를 강제로 발생시킴
        strategyPlanner.handleEvent(jobId, new EventData("FOUND", "강남역 11번 출구"));
        
        System.out.println("\n--- [시나리오 3] AI 서버, 'S-001' 추적 중 놓침! (추적중 -> 놓침) ---");
        // 용의자가 옷을 갈아입는 등 이유로 놓쳤다고 가정
        strategyPlanner.handleEvent(jobId, new EventData("LOST", "CGV 뒷골목"));

        System.out.println("\n--- [시나리오 4] AI 서버, 재탐색 전략 실행 후 재발견! (놓침 -> 추적중) ---");
        // '놓침' 상태가 된 후, 재탐색 전략(반경확대)을 통해 다시 찾았다고 가정
        strategyPlanner.handleEvent(jobId, new EventData("FOUND", "OO빌딩 앞"));

        System.out.println("\n--- [시나리오 5] 추적 이력 조회 ---");
        strategyPlanner.printHistory(jobId);

        System.out.println("\n====== 시뮬레이션 종료 ======");
    }
}

// ============================================================
// == 가상 메시지 브로커 (시뮬레이션을 위함)
// ============================================================
class VirtualMessageBroker {
    private final TaskReceiver taskReceiver;
    public VirtualMessageBroker(TaskReceiver receiver) { this.taskReceiver = receiver; }
    public void publish(String topic, 분석데이터 data) {
        System.out.println("\n[Virtual MQ] 토픽 '" + topic + "'으로 메시지 수신. AI 서버 TaskReceiver에게 전달...");
        // 실제로는 네트워크를 통해 전달되지만, 여기서는 직접 메서드를 호출하여 흉내
        taskReceiver.onMessageReceived(data);
    }
}

// ============================================================
// == 공통 DTO
// ============================================================
record 추적요청DTO(String suspectId, String area, String requestedBy) {}
record EventData(String type, String location) {}
class 분석데이터 {}


// ============================================================
// == 로깅 서비스
// ============================================================
interface I로깅서비스 { void log(String message); }
class ConsoleLogger implements I로깅서비스 {
    @Override public void log(String message) { System.out.println("[LOG] " + message); }
}

// ============================================================
// == Node 2: 추적 및 관리 서비스 노드 (App Server)
// ============================================================
interface I추적오케스트레이션 { CompletableFuture<String> 추적요청처리(추적요청DTO 요청); }
class TrackingOrchestrationService implements I추적오케스트레이션 {
    private final I명령팩토리 _commandFactory;
    private final 커맨드실행기 _commandInvoker;
    private final I로깅서비스 _logger;
    public TrackingOrchestrationService(I명령팩토리 f, 커맨드실행기 i, I로깅서비스 l) {
        this._commandFactory = f; this._commandInvoker = i; this._logger = l;
    }
    @Override
    public CompletableFuture<String> 추적요청처리(추적요청DTO 요청) {
        _logger.log(요청.requestedBy() + "로부터 추적 요청 수신");
        String 작업ID = "job-" + UUID.randomUUID().toString().substring(0, 8);
        _logger.log(작업ID + ": [" + 요청.area() + "]에 대한 요청 처리 시작...");
        I명령 영상요청 = _commandFactory.영상요청명령생성(요청.area());
        I명령 AI분석요청 = _commandFactory.AI분석요청명령생성(new 분석데이터());
        _commandInvoker.커맨드추가및실행(영상요청);
        _commandInvoker.커맨드추가및실행(AI분석요청);
        _logger.log(작업ID + ": 관련 명령들이 실행기에 전달됨.");
        return CompletableFuture.completedFuture(작업ID);
    }
}
interface I명령 { CompletableFuture<Void> 실행하기(); }
class 커맨드실행기 {
    private final Queue<I명령> _commandQueue = new ConcurrentLinkedQueue<>();
    public void 커맨드추가및실행(I명령 명령) { _commandQueue.add(명령); 명령.실행하기(); }
}
class 영상요청명령 implements I명령 {
    private final I영상소스제공_App _receiver; private final String _area;
    public 영상요청명령(I영상소스제공_App r, String a) { this._receiver = r; this._area = a; }
    @Override public CompletableFuture<Void> 실행하기() { return CompletableFuture.runAsync(() -> _receiver.requestStream(_area)); }
}
class AI분석요청명령 implements I명령 {
    private final I비동기이벤트발행_App _receiver; private final 분석데이터 _data;
    public AI분석요청명령(I비동기이벤트발행_App r, 분석데이터 d) { this._receiver = r; this._data = d; }
    @Override public CompletableFuture<Void> 실행하기() { return CompletableFuture.runAsync(() -> _receiver.publishAnalysisRequest(_data)); }
}
interface I명령팩토리 { I명령 영상요청명령생성(String p); I명령 AI분석요청명령생성(분석데이터 p); }
class 실시간추적명령팩토리 implements I명령팩토리 {
    private final I영상소스제공_App _videoProvider; private final I비동기이벤트발행_App _eventPublisher;
    public 실시간추적명령팩토리(I영상소스제공_App v, I비동기이벤트발행_App e) { this._videoProvider = v; this._eventPublisher = e; }
    @Override public I명령 영상요청명령생성(String p) { return new 영상요청명령(_videoProvider, p); }
    @Override public I명령 AI분석요청명령생성(분석데이터 p) { return new AI분석요청명령(_eventPublisher, p); }
}
interface I영상소스제공_App { void requestStream(String area); }
interface I비동기이벤트발행_App { void publishAnalysisRequest(분석데이터 data); }
class CctvGateway implements I영상소스제공_App {
    @Override public void requestStream(String area) { System.out.println("  > [CctvGateway] " + area + " 실시간 영상 요청"); }
}
class MqGateway implements I비동기이벤트발행_App {
    private final VirtualMessageBroker messageBroker;
    public MqGateway(VirtualMessageBroker broker) { this.messageBroker = broker; }
    @Override public void publishAnalysisRequest(분석데이터 data) {
        System.out.println("  > [MqGateway] AI 분석 작업 발행");
        messageBroker.publish("Analysis_Tasks", data);
    }
}

// ============================================================
// == Node 3: 지능형 영상 분석 노드 (AI Server) - 신규 추가/수정
// ============================================================

// --- Endpoint (System Interaction) ---
class TaskReceiver {
    private final I추적상태및전략관리 _taskHandler;
    public TaskReceiver(I추적상태및전략관리 h) { this._taskHandler = h; }
    public void onMessageReceived(분석데이터 message) {
        System.out.println("[AI-Server] 작업 수신. 초기 탐색 시작...");
        // 실제로는 메시지에서 JobId 등을 추출하여 전달
        _taskHandler.handleEvent("job-id-placeholder", new EventData("INITIAL_SEARCH", ""));
    }
}

// --- Facade & Main Interface ---
interface I추적상태및전략관리 {
    void handleEvent(String jobId, EventData event);
    String getCurrentState(String jobId);
    void printHistory(String jobId); // 시뮬레이션을 위한 편의 메서드
}

/**
 * [코드 리뷰] Facade 패턴
 * 복잡한 내부의 상태(State), 전략(Strategy), 이력(Memento) 관리 로직을
 * 외부에는 handleEvent() 라는 단순한 창구 하나로 보이게 합니다.
 */
class StrategyPlannerFacade implements I추적상태및전략관리 {
    private final Map<String, 추적작업맥락> _contextMap = new ConcurrentHashMap<>();
    private final I추적데이터저장_AI _repo;
    public StrategyPlannerFacade(I추적데이터저장_AI repo) { this._repo = repo; }

    private 추적작업맥락 getOrCreateContext(String jobId) {
        return _contextMap.computeIfAbsent(jobId, id -> new 추적작업맥락(id, _repo));
    }
    @Override
    public void handleEvent(String jobId, EventData event) {
        추적작업맥락 context = getOrCreateContext(jobId);
        System.out.println("\n[AI-Server] " + jobId + "에 " + event.type() + " 이벤트 발생 ("+ event.location() +")");
        context.handle(event);
    }
    @Override public String getCurrentState(String jobId) { return getOrCreateContext(jobId).getCurrentStateName(); }
    @Override public void printHistory(String jobId) { getOrCreateContext(jobId).printHistory(); }
}

// --- Memento Pattern ---
/**
 * [코드 리뷰] Memento: 스냅샷 객체
 * Originator(추적작업맥락)의 특정 시점 상태를 저장합니다.
 * 이 객체 자신은 아무 로직이 없고 데이터만 담는 것이 특징입니다.
 */
class 추적상태메멘토 {
    private final String stateName;
    private final LocalDateTime timestamp;
    private final String location; // 간략화를 위해 location만 저장

    public 추적상태메멘토(String stateName, String location) {
        this.stateName = stateName;
        this.location = location;
        this.timestamp = LocalDateTime.now();
    }
    @Override public String toString() { return timestamp + " | 상태: " + stateName + " | 위치: " + location; }
}

/**
 * [코드 리뷰] Caretaker: 창고 관리자
 * Memento 객체들을 저장하고 관리합니다.
 * Memento의 내용이 무엇인지는 전혀 신경쓰지 않는 것이 핵심입니다.
 */
class 이력관리자 {
    private final List<추적상태메멘토> _mementos = new ArrayList<>();
    private final I추적데이터저장_AI _repository;
    private final String _jobId;
    public 이력관리자(String jobId, I추적데이터저장_AI repository) { this._jobId = jobId; this._repository = repository; }
    public void saveState(추적작업맥락 originator) {
        추적상태메멘토 memento = originator.createMemento();
        _mementos.add(memento);
        _repository.saveHistory(_jobId, _mementos); // DB에도 저장
    }
    public void printHistory() {
        System.out.println("--- 추적 이력 (" + _jobId + ") ---");
        for (추적상태메멘토 m : _mementos) {
            System.out.println("  " + m);
        }
        System.out.println("-------------------------");
    }
}

// --- State & Strategy Pattern ---
/**
 * [코드 리뷰] State 패턴의 Context
 * 자신의 '상태'를 I추적상태 객체에게 위임합니다.
 * Memento 패턴에서는 상태를 저장하고 복원하는 Originator 역할도 합니다.
 */
class 추적작업맥락 {
    private I추적상태 _currentState;
    private final 이력관리자 _caretaker;
    public final String jobId;
    public String lastKnownLocation;

    public 추적작업맥락(String jobId, I추적데이터저장_AI repo) {
        this.jobId = jobId;
        this._caretaker = new 이력관리자(jobId, repo);
        this._currentState = new 탐색중상태(); // 초기 상태
        System.out.println("  >> " + jobId + " 작업 맥락 생성. [초기 상태: 탐색중]");
        saveState(); // 초기 상태 저장
    }
    public void setState(I추적상태 newState) { this._currentState = newState; }
    public void handle(EventData event) {
        this.lastKnownLocation = event.location(); // 마지막 위치 업데이트
        _currentState.handle(this, event);
        saveState(); // 상태 변경 후 항상 저장
    }
    public String getCurrentStateName() { return _currentState.getClass().getSimpleName(); }
    public 추적상태메멘토 createMemento() { return new 추적상태메멘토(getCurrentStateName(), lastKnownLocation); }
    public void saveState() { _caretaker.saveState(this); }
    public void printHistory() { _caretaker.printHistory(); }
}

/**
 * [코드 리뷰] State 패턴의 State 인터페이스
 * 모든 '상태' 클래스가 따라야 할 규칙(handle 메서드)을 정의합니다.
 */
interface I추적상태 { void handle(추적작업맥락 context, EventData event); }

class 탐색중상태 implements I추적상태 {
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("FOUND".equals(event.type())) {
            System.out.println("  >> [탐색중] -> [추적중] 상태로 변경!");
            context.setState(new 추적중상태());
        }
    }
}

class 추적중상태 implements I추적상태 {
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("LOST".equals(event.type())) {
            System.out.println("  >> [추적중] -> [놓침] 상태로 변경!");
            context.setState(new 놓침상태());
        } else if ("FOUND".equals(event.type())) {
            System.out.println("  >> [추적중] 용의자 위치 업데이트: " + event.location());
        }
    }
}

/**
 * [코드 리뷰] State와 Strategy 패턴의 결합
 * '놓침' 상태일 때의 행동으로 '재탐색'을 수행해야 하는데,
 * "어떻게" 재탐색할 것인지를 Strategy 패턴에 위임합니다.
 */
class 놓침상태 implements I추적상태 {
    private I재탐색전략 _strategy;
    public 놓침상태() {
        // 기본 전략으로 '반경확대전략'을 설정
        this._strategy = new 반경확대전략();
        System.out.println("    - (놓침 상태 진입. 재탐색 전략으로 '" + _strategy.getClass().getSimpleName() + "' 설정)");
    }
    @Override public void handle(추적작업맥락 context, EventData event) {
        if ("FOUND".equals(event.type())) {
            System.out.println("  >> [놓침] -> [추적중] 상태로 변경!");
            context.setState(new 추적중상태());
        } else {
            // 재탐색 이벤트가 오면 현재 설정된 전략을 실행
            _strategy.execute(context.lastKnownLocation);
        }
    }
}

/**
 * [코드 리뷰] Strategy 패턴의 Strategy 인터페이스
 * 모든 '재탐색 전략' 클래스가 따라야 할 규칙(execute 메서드)을 정의합니다.
 */
interface I재탐색전략 { void execute(String lastKnownLocation); }

class 반경확대전략 implements I재탐색전략 {
    @Override public void execute(String lastKnownLocation) {
        System.out.println("    - [전략 실행] '" + lastKnownLocation + "' 주변 반경을 2배로 확대하여 재탐색합니다.");
    }
}

class 과거동선기반전략 implements I재탐색전략 {
    @Override public void execute(String lastKnownLocation) {
        System.out.println("    - [전략 실행] '" + lastKnownLocation + "'에서 과거 동선 기반으로 예상 경로를 재탐색합니다.");
    }
}

// --- Repository (Infrastructure) ---
interface I추적데이터저장_AI {
    void saveHistory(String jobId, List<추적상태메멘토> mementos);
}

class TrackingHistoryRepository implements I추적데이터저장_AI {
    @Override public void saveHistory(String jobId, List<추적상태메멘토> mementos) {
        // System.out.println("    - [Repository] " + jobId + "의 추적 이력을 DB에 저장합니다.");
    }
}