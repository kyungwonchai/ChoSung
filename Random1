탭 컨트롤을 사용하여 서로 다른 로그 유형을 각기 다른 탭에 표시하도록 수정하는 것은 매우 유용한 기능입니다. 이를 통해 로그를 유형별로 분리하여 더 쉽게 모니터링할 수 있습니다.

이제 각 로그 유형에 대해 별도의 탭과 ListBox를 만들고, 로그를 각 탭의 ListBox에 선택적으로 표시하도록 코드 혁신을 하겠습니다.

주요 수정 사항
XAML 수정 (MainWindow.xaml):

탭 컨트롤 (TabControl)과 각 탭 항목 (TabItem)을 추가합니다.
각 탭에 로그를 표시할 ListBox를 추가합니다.
ViewModel 수정 (MainViewModel.cs):

각 로그 유형별로 ObservableCollection<string>을 추가하여, 특정 유형의 로그를 해당 컬렉션에 추가합니다.
서비스 헬퍼 수정 (ServiceControllerHelper.cs):

각 로그 유형을 구분하여, 적절한 메서드를 통해 로그를 전송합니다.
1. MainWindow.xaml 수정
다음 XAML 코드는 탭 컨트롤과 여러 개의 탭 항목을 추가하여 각기 다른 로그를 표시하는 UI를 설정합니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="350" Width="525">
    <Grid>
        <TabControl Name="LogTabControl" Margin="10">
            <!-- 일반 로그 탭 -->
            <TabItem Header="General Logs">
                <ListBox Name="GeneralLogListBox" ItemsSource="{Binding GeneralLogs}" />
            </TabItem>
            
            <!-- 서비스 로그 탭 -->
            <TabItem Header="Service Logs">
                <ListBox Name="ServiceLogListBox" ItemsSource="{Binding ServiceLogs}" />
            </TabItem>

            <!-- 시스템 로그 탭 -->
            <TabItem Header="System Logs">
                <ListBox Name="SystemLogListBox" ItemsSource="{Binding SystemLogs}" />
            </TabItem>

            <!-- 에러 로그 탭 -->
            <TabItem Header="Error Logs">
                <ListBox Name="ErrorLogListBox" ItemsSource="{Binding ErrorLogs}" />
            </TabItem>

            <!-- 사용자 로그 탭 -->
            <TabItem Header="User Logs">
                <ListBox Name="UserLogListBox" ItemsSource="{Binding UserLogs}" />
            </TabItem>
        </TabControl>
    </Grid>
</Window>
2. MainViewModel.cs 수정
MainViewModel을 수정하여 각 탭에 해당하는 로그 컬렉션을 추가합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Windows.Threading;
using RouterMiddleACR.Services;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ServiceControllerHelper _serviceControllerHelper;

        // 로그 컬렉션 정의
        public ObservableCollection<string> GeneralLogs { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> ServiceLogs { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> SystemLogs { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> ErrorLogs { get; } = new ObservableCollection<string>();
        public ObservableCollection<string> UserLogs { get; } = new ObservableCollection<string>();

        public MainViewModel()
        {
            _serviceControllerHelper = new ServiceControllerHelper();
            _serviceControllerHelper.OnGeneralLogMessage += LogGeneralMessage;
            _serviceControllerHelper.OnServiceLogMessage += LogServiceMessage;
            _serviceControllerHelper.OnSystemLogMessage += LogSystemMessage;
            _serviceControllerHelper.OnErrorLogMessage += LogErrorMessage;
            _serviceControllerHelper.OnUserLogMessage += LogUserMessage;
        }

        // 일반 로그 메시지를 추가하는 메서드
        private void LogGeneralMessage(string message)
        {
            App.Current.Dispatcher.Invoke(() =>
            {
                GeneralLogs.Add(message);
            });
        }

        // 서비스 로그 메시지를 추가하는 메서드
        private void LogServiceMessage(string message)
        {
            App.Current.Dispatcher.Invoke(() =>
            {
                ServiceLogs.Add(message);
            });
        }

        // 시스템 로그 메시지를 추가하는 메서드
        private void LogSystemMessage(string message)
        {
            App.Current.Dispatcher.Invoke(() =>
            {
                SystemLogs.Add(message);
            });
        }

        // 에러 로그 메시지를 추가하는 메서드
        private void LogErrorMessage(string message)
        {
            App.Current.Dispatcher.Invoke(() =>
            {
                ErrorLogs.Add(message);
            });
        }

        // 사용자 로그 메시지를 추가하는 메서드
        private void LogUserMessage(string message)
        {
            App.Current.Dispatcher.Invoke(() =>
            {
                UserLogs.Add(message);
            });
        }

        // 서비스 시작 메서드
        public void StartService()
        {
            _serviceControllerHelper.StartService();
        }

        // 서비스 중지 메서드
        public void StopService()
        {
            _serviceControllerHelper.StopService();
        }

        // 서비스 상태를 갱신하는 메서드
        public void RefreshServiceStatus()
        {
            var status = _serviceControllerHelper.GetServiceStatus();
            LogServiceMessage($"서비스 상태: {status}");
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
3. ServiceControllerHelper.cs 수정
ServiceControllerHelper 클래스에서 각 로그 유형별로 이벤트를 정의하고, 로그 메시지를 이벤트를 통해 전송합니다.

csharp
코드 복사
using System;
using System.ServiceProcess;
using System.Timers;

namespace RouterMiddleACR.Services
{
    public class ServiceControllerHelper
    {
        private ServiceController _serviceController;
        private Timer _statusCheckTimer;
        private readonly string _serviceName = "RouterMiddleACRService";

        // 로그 메시지를 전달하는 이벤트
        public event Action<string> OnGeneralLogMessage;
        public event Action<string> OnServiceLogMessage;
        public event Action<string> OnSystemLogMessage;
        public event Action<string> OnErrorLogMessage;
        public event Action<string> OnUserLogMessage;

        public ServiceControllerHelper()
        {
            _serviceController = new ServiceController(_serviceName);
            InitializeStatusCheckTimer();
        }

        // 서비스 상태 확인을 위한 타이머 초기화
        private void InitializeStatusCheckTimer()
        {
            _statusCheckTimer = new Timer(10000); // 10초마다 상태 체크
            _statusCheckTimer.Elapsed += (sender, args) => CheckServiceStatus();
            _statusCheckTimer.Start();
        }

        // 서비스 상태를 확인하고 필요한 경우 재시작하는 메서드
        private void CheckServiceStatus()
        {
            try
            {
                _serviceController.Refresh();
                string status = _serviceController.Status.ToString();
                OnServiceLogMessage?.Invoke($"서비스 상태: {status}");

                if (_serviceController.Status == ServiceControllerStatus.Stopped)
                {
                    OnServiceLogMessage?.Invoke("서비스가 중지되었습니다. 재시작합니다...");
                    RestartService();
                }
            }
            catch (Exception ex)
            {
                OnErrorLogMessage?.Invoke($"서비스 상태 확인 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            try
            {
                if (_serviceController.Status == ServiceControllerStatus.Stopped)
                {
                    _serviceController.Start();
                    _serviceController.WaitForStatus(ServiceControllerStatus.Running, TimeSpan.FromSeconds(30));
                    OnServiceLogMessage?.Invoke("서비스가 성공적으로 시작되었습니다.");
                }
            }
            catch (Exception ex)
            {
                OnErrorLogMessage?.Invoke($"서비스 시작 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            try
            {
                if (_serviceController.Status == ServiceControllerStatus.Running)
                {
                    _serviceController.Stop();
                    _serviceController.WaitForStatus(ServiceControllerStatus.Stopped, TimeSpan.FromSeconds(30));
                    OnServiceLogMessage?.Invoke("서비스가 성공적으로 중지되었습니다.");
                }
            }
            catch (Exception ex)
            {
                OnErrorLogMessage?.Invoke($"서비스 중지 중 오류 발생: {ex.Message}");
            }
        }

        // 서비스를 재시작하는 메서드
        public void RestartService()
        {
            StopService();
            StartService();
        }

        // 현재 서비스 상태를 반환하는 메서드
        public string GetServiceStatus()
        {
            try
            {
                _serviceController.Refresh();
                return _serviceController.Status.ToString();
            }
            catch (Exception ex)
            {
                OnErrorLogMessage?.Invoke($"서비스 상태를 가져오는 중 오류 발생: {ex.Message}");
                return "Unknown";
            }
        }
    }
}
요약
XAML 수정: TabControl과 TabItem을 사용하여 각기 다른 유형의 로그를 표시할 UI를 구성했습니다.
MainViewModel 수정: 로그 유형별로 ObservableCollection<string>을 추가하여, 해당 로그를 적절한 탭에 표시할 수 있도록 했습니다. 또한, ServiceControllerHelper의 각 로그 이벤트를 ViewModel의 메서드에 바인딩하여 각 탭의 로그를 관리합니다.
ServiceControllerHelper 수정: 각 로그 유형별로 이벤트를 정의하고, 해당 이벤트를 통해 로그 메시지를 전송하도록 했습니다.
이 구조를 통해 사용자는 다양한 로그를 별도의 탭에서 확인할 수 있으며, UI는 적절히 업데이트됩니다.