IEW1의 데이터를 주어진 조건에 맞게 분류하기 위해 MSSQL에서 CASE 문과 DATEPART 함수, 그리고 CONVERT를 조합하여 작업해야 합니다. 아래는 구현 방법입니다:

쿼리 설명
datev 시간 기반 분류: CASE 문을 사용하여 조건별로 값을 분류합니다.
특정 시간대를 묶어 처리: 07:00 ~ 20:59는 07, 21:30 ~ 22:30는 21, 그리고 다른 시간대는 적절한 기준에 따라 묶습니다.
구현 코드
sql
코드 복사
WITH view1 AS (
    SELECT 
        Line,
        DATEADD(MINUTE, -10, datev) AS datev1,
        pickupcnt
    FROM table_lossdata
),
grouped_view AS (
    SELECT 
        Line,
        pickupcnt,
        datev1,
        CONVERT(VARCHAR(13), datev1, 120) AS 시간,
        CASE
            WHEN DATEPART(HOUR, datev1) BETWEEN 7 AND 20 THEN '07'
            WHEN DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) >= 30 THEN '21'
            WHEN DATEPART(HOUR, datev1) = 22 AND DATEPART(MINUTE, datev1) <= 30 THEN '21'
            WHEN DATEPART(HOUR, datev1) = 6 AND DATEPART(MINUTE, datev1) < 30 THEN '06'
            WHEN DATEPART(HOUR, datev1) = 21 AND DATEPART(MINUTE, datev1) < 30 THEN '21'
            ELSE RIGHT('0' + CONVERT(VARCHAR, DATEPART(HOUR, datev1)), 2)
        END AS 분류시간
    FROM view1
)
SELECT *
FROM grouped_view
ORDER BY datev1;
주요 로직 설명
WITH 절 사용:

view1에서는 datev에 10분을 뺀 데이터를 생성합니다.
grouped_view에서는 view1의 데이터를 기반으로 시간대를 분류합니다.
CASE 문:

DATEPART(HOUR, datev1)와 DATEPART(MINUTE, datev1)로 조건을 세분화.
특정 시간대는 지정된 값으로 반환.
RIGHT와 CONVERT를 사용해 2자리 문자열 형식으로 시간값 출력.
ORDER BY:

결과 데이터를 시간 순서대로 정렬합니다.
예시 결과
Line	pickupcnt	datev1	시간	분류시간
A	10	2025-01-20 06:20:00	2025-01-20 06	06
A	20	2025-01-20 07:30:00	2025-01-20 07	07
A	30	2025-01-20 21:40:00	2025-01-20 21	21
이렇게 하면 주어진 조건에 따라 데이터를 정확히 분류할 수 있습니다.


2/2




