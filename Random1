임드 파이프를 TCP/IP 소켓 통신으로 변경하는 작업은 기존의 네임드 파이프 기반 통신 코드를 TCP/IP 소켓 기반으로 변경하는 것입니다. 이 변경 작업은 서비스와 클라이언트 모두에 적용되어야 하며, TCP/IP 소켓 통신을 위한 TCP 서버와 TCP 클라이언트를 각각 구현해야 합니다.

변경 작업 요약
LogService 클래스:

기존의 네임드 파이프 기반의 로그 전송 방식을 TCP 서버 기반으로 변경합니다.
TCP 서버를 시작하고 클라이언트의 연결을 수락하며 로그 메시지를 전송합니다.
MainWindow.xaml.cs:

네임드 파이프 클라이언트를 TCP 클라이언트로 변경하여, TCP 서버로부터 로그 메시지를 수신합니다.
MainViewModel.cs:

LogMessages 컬렉션과 서비스 제어 로직을 포함하여, UI에서 서비스 상태 및 로그 메시지를 관리합니다.
1. TcpLogService 클래스 (기존 LogService 대체)
기존 LogService를 TCP 서버로 대체하여 클라이언트에 로그 메시지를 전송합니다.

csharp
코드 복사
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class TcpLogService
    {
        private static TcpLogService _instance;
        private TcpListener _listener;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly string _logDirectory;

        public static TcpLogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new TcpLogService();
                }
                return _instance;
            }
        }

        private TcpLogService()
        {
            // 로그 파일이 저장될 디렉터리 설정
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory);
        }

        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => StartServer(_cancellationTokenSource.Token));
        }

        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _listener?.Stop();
        }

        // TCP 서버 시작 메서드
        private async Task StartServer(CancellationToken cancellationToken)
        {
            _listener = new TcpListener(IPAddress.Any, 9000); // 모든 IP의 포트 9000에서 대기
            _listener.Start();
            Console.WriteLine("TCP server started on port 9000.");

            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    TcpClient client = await _listener.AcceptTcpClientAsync(); // 클라이언트 연결 대기
                    Console.WriteLine("Client connected.");
                    _ = Task.Run(() => HandleClient(client, cancellationToken)); // 클라이언트 처리
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Server error: {ex.Message}");
                }
            }

            _listener.Stop();
        }

        // 클라이언트 연결을 처리하는 메서드
        private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)
        {
            using (client)
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;
                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) != 0)
                {
                    string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    // 추가로 로그 메시지 처리 가능
                }
            }
        }

        // 로그 메시지를 기록하고 TCP 클라이언트로 전송하는 메서드
        public void LogMessage(string message)
        {
            try
            {
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
                
                // 로그 메시지를 콘솔에 출력 (필요시 파일에도 저장 가능)
                Console.WriteLine(logEntry);
                // TCP 클라이언트에게 전송할 로직 추가 필요
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }
    }
}
2. MainWindow.xaml.cs 수정
TCP 클라이언트를 사용하여 로그 서버에 연결하고, 로그를 수신합니다.

csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using RouterMiddleACR.ViewModels;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;

            StartListeningToLogs(); // 로그 수신을 시작
        }

        // TCP 서버로부터 로그를 수신하는 메서드
        private void StartListeningToLogs()
        {
            Task.Run(async () =>
            {
                try
                {
                    _tcpClient = new TcpClient("127.0.0.1", 9000); // 로컬호스트의 포트 9000에 연결
                    _networkStream = _tcpClient.GetStream();

                    byte[] buffer = new byte[1024];
                    int bytesRead;

                    // 로그 메시지를 지속적으로 수신하여 UI에 표시
                    while ((bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
                    {
                        string message = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                        Dispatcher.Invoke(() => _viewModel.LogMessages.Add(message)); // UI에 로그 메시지 추가
                    }
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
                }
                finally
                {
                    _networkStream?.Close();
                    _tcpClient?.Close();
                }
            });
        }

        // 필요한 UI 이벤트 핸들러 (예: 서비스 시작/중지 등)
        private void StartService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StartService();
        }

        private void StopService_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.StopService();
        }

        private void RefreshStatus_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.RefreshServiceStatus();
        }
    }
}
3. MainViewModel.cs 수정
MainViewModel에서 LogMessages 컬렉션을 사용하여 로그 메시지를 관리합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ServiceControllerHelper _serviceControllerHelper;
        private string _serviceStatus;

        // 로그 메시지를 저장할 ObservableCollection
        public ObservableCollection<string> LogMessages { get; } = new ObservableCollection<string>();

        public string ServiceStatus
        {
            get => _serviceStatus;
            set
            {
                _serviceStatus = value;
                OnPropertyChanged(nameof(ServiceStatus));
            }
        }

        public MainViewModel()
        {
            _serviceControllerHelper = new ServiceControllerHelper();
            RefreshServiceStatus();
        }

        // 서비스를 시작하는 메서드
        public void StartService()
        {
            _serviceControllerHelper.StartService();
            RefreshServiceStatus();
        }

        // 서비스를 중지하는 메서드
        public void StopService()
        {
            _serviceControllerHelper.StopService();
            RefreshServiceStatus();
        }

        // 서비스 상태를 갱신하는 메서드
        public void RefreshServiceStatus()
        {
            ServiceStatus = _serviceControllerHelper.GetServiceStatus();
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
요약
TcpLogService 클래스:

기존 LogService를 TCP 서버로 대체하여 클라이언트에 로그 메시지를 전송합니다.
클라이언트의 연결을 수락하고 메시지를 수신하여 로그를 처리합니다.
MainWindow.xaml.cs:

StartListeningToLogs 메서드를 통해 TCP 클라이언트를 사용하여 로그 서버에 연결하고 로그를 수신합니다.
UI 이벤트 핸들러를 통해 서비스의 시작, 중지, 상태 갱신 등을 처리합니다.
MainViewModel.cs:

LogMessages 컬렉션을 사용하여 UI에서 로그 메시지를 관리하고, 서비스 상태를 표시합니다.
이 변경 사항을 통해 네임드 파이프 대신 TCP/IP 소켓을 사용하여 로그 통신을 구현할 수 있습니다. TCP 소켓을 사용하면 네트워크 통신이 가능해지므로, 원격 클라이언트에서도 로그를 수