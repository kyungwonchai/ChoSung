, 말씀하신 방식으로 구현할 수 있습니다. 최초 값을 OK로 설정하고, 한 번이라도 NG가 나오면 그 값을 변경하는 방식으로 최종 결과를 처리할 수 있습니다. 이를 구현한 코드는 아래와 같습니다.

코드 구현
csharp
코드 복사
private async Task<string> ProcessMESOI(string val)
{
    // 최초 결과 값을 OK로 설정
    string finalResult = "OK";

    // SendtoMergeOI_MAGNO 실행
    string magnoResult = await SendtoMergeOI_MAGNO(val);
    if (magnoResult != "OK")
    {
        finalResult = $"NG: SendtoMergeOI_MAGNO ({magnoResult})";
    }

    // SendtoMergeOI_ForceSave 실행
    string forceSaveResult = await SendtoMergeOI_ForceSave(val);
    if (forceSaveResult != "OK")
    {
        finalResult = $"NG: SendtoMergeOI_ForceSave ({forceSaveResult})";
    }

    // 최종 결과 반환
    return finalResult;
}

// 예제 함수: SendtoMergeOI_MAGNO
private async Task<string> SendtoMergeOI_MAGNO(string val)
{
    // 실제 로직 대신 샘플 코드
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "MAGNO" ? "OK" : "MG"; // 조건에 따라 결과 반환
}

// 예제 함수: SendtoMergeOI_ForceSave
private async Task<string> SendtoMergeOI_ForceSave(string val)
{
    // 실제 로직 대신 샘플 코드
    await Task.Delay(100); // 비동기 처리 시뮬레이션
    return val == "ForceSave" ? "OK" : "MG"; // 조건에 따라 결과 반환
}
동작 설명
초기 값 설정:
finalResult를 "OK"로 설정합니다.
함수 실행 및 결과 확인:
SendtoMergeOI_MAGNO와 SendtoMergeOI_ForceSave를 순차적으로 실행합니다.
각 함수의 결과를 확인하여 "OK"가 아니면 finalResult를 "NG: 함수명 (리턴값)"으로 업데이트합니다.
한 번이라도 NG가 발생하면 결과가 변경됩니다.
최종 결과 반환:
마지막까지 finalResult에 저장된 값을 반환합니다.
결과 예제
예제 1: 두 함수 모두 정상인 경우
csharp
코드 복사
string result = await ProcessMESOI("MAGNO");
/* 결과:
"OK"
*/
예제 2: 첫 번째 함수가 실패한 경우
csharp
코드 복사
string result = await ProcessMESOI("INVALID");
/* 결과:
"NG: SendtoMergeOI_MAGNO (MG)"
*/
예제 3: 두 번째 함수가 실패한 경우
csharp
코드 복사
string result = await ProcessMESOI("MAGNO_INVALID");
/* 결과:
"NG: SendtoMergeOI_ForceSave (MG)"
*/
주요 포인트