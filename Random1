 있고, 그 모든 기능을 하나의 파일로 통합해달라고 요청하신다면, 이는 매우 복잡하고 방대한 작업입니다. 프로젝트의 모든 기능을 단일 파일로 재작성하는 것은 비효율적일 수 있지만, 요청에 따라 최적화된 코드를 제공해드리겠습니다.

최적화된 C# WPF 프로젝트 (단일 파일 버전)
이 예제는 다양한 기능을 하나의 파일로 통합하여 WPF 프로젝트의 주요 기능들을 구현하는 예시입니다. 각 기능의 세부 사항은 주어진 정보에 기반하여 재작성되었으며, 코드의 구조는 최대한 함수형으로 유지했습니다.

이 프로젝트는 다음과 같은 기능들을 포함합니다:

PLC와의 소켓 통신
명령어 전송 및 로그 출력
기본적인 UI 요소 및 상호 작용
MainWindow.xaml
xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="RouterMiddleACR" Height="400" Width="600">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <StackPanel Orientation="Horizontal" Margin="10">
            <TextBox Name="CommandTextBox" Width="300" Margin="0,0,10,0"/>
            <Button Name="SendButton" Content="Send Command" Width="100" Click="SendButton_Click"/>
        </StackPanel>
        <TextBox Name="LogTextBox" Grid.Row="1" Margin="10" IsReadOnly="True" VerticalScrollBarVisibility="Auto"/>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Net.Sockets;
using System.Text;
using System.Windows;
using System.Windows.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private TcpClient _client;
        private NetworkStream _stream;

        public MainWindow()
        {
            InitializeComponent();
            InitializeSocketConnection();
        }

        // 소켓 연결을 초기화하는 메서드
        private void InitializeSocketConnection()
        {
            Task.Run(() =>
            {
                try
                {
                    // 소켓 초기화 (IP 주소와 포트를 실제 환경에 맞게 수정)
                    _client = new TcpClient("127.0.0.1", 5000);
                    _stream = _client.GetStream();
                    Dispatcher.Invoke(() => Log("Connected to the server."));
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => Log($"Connection failed: {ex.Message}"));
                }
            });
        }

        // 명령어 전송 버튼 클릭 시 호출되는 메서드
        private void SendButton_Click(object sender, RoutedEventArgs e)
        {
            string command = CommandTextBox.Text;
            if (!string.IsNullOrEmpty(command))
            {
                SendCommand(command);
            }
            else
            {
                Log("Command is empty.");
            }
        }

        // 명령어를 PLC에 전송하는 메서드
        private void SendCommand(string command)
        {
            Task.Run(() =>
            {
                try
                {
                    if (_stream == null)
                    {
                        Dispatcher.Invoke(() => Log("No connection to server."));
                        return;
                    }

                    // 명령어를 ASCII로 인코딩하여 전송
                    byte[] data = Encoding.ASCII.GetBytes(command + "\r");
                    _stream.Write(data, 0, data.Length);
                    Dispatcher.Invoke(() => Log($"Sent: {command}"));
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => Log($"Error sending command: {ex.Message}"));
                }
            });
        }

        // 로그를 출력하는 메서드
        private void Log(string message)
        {
            Dispatcher.Invoke(() =>
            {
                LogTextBox.AppendText($"{DateTime.Now:HH:mm:ss} - {message}\n");
                LogTextBox.ScrollToEnd();
            });
        }

        // 윈도우가 닫힐 때 호출되는 메서드
        protected override void OnClosed(EventArgs e)
        {
            base.OnClosed(e);
            CloseSocketConnection();
        }

        // 소켓 연결을 닫는 메서드
        private void CloseSocketConnection()
        {
            try
            {
                _stream?.Close();
                _client?.Close();
                Log("Disconnected from the server.");
            }
            catch (Exception ex)
            {
                Log($"Error disconnecting: {ex.Message}");
            }
        }
    }
}
코드 설명
소켓 연결 초기화:

InitializeSocketConnection 메서드는 비동기적으로 서버와의 TCP 연결을 설정합니다. 서버의 IP 주소와 포트를 지정해야 하며, 실패 시 적절한 로그 메시지를 출력합니다.
명령어 전송:

SendCommand 메서드는 사용자가 입력한 명령어를 ASCII로 인코딩하여 PLC로 전송합니다. 전송 후 성공 여부에 따라 로그를 남깁니다.
로그 출력:

Log 메서드는 로그 메시지를 출력하는 역할을 합니다. 모든 로그는 UI 스레드에서 안전하게 업데이트됩니다.
윈도우 종료 처리:

애플리케이션이 종료될 때 OnClosed 메서드가 호출되어 소켓 연결을 닫고 리소스를 해제합니다.
결론
이 예제에서는 모든 기능을 하나의 WPF 창에 통합하여 구현하였습니다. 기존에 사용하던 복잡한 여러 파일 구조를 단순화하여 한 파일에서 모든 로직을 처리하도록 최적화하였습니다. 이 코드는 일반적인 시나리오에 맞춰 작성되었으며, 실제 프로젝트에 적용할 때는 구체적인 요구 사항과 환경에 맞게 수정이 필요할 수 있습니다.

또한, 이 접근 방식은 유지 보수성에 있어서 비효율적일 수 있으며, 규모가 커질 경우 복잡성과 가독성이 떨어질 수 있다는 점을 고려해야 합니다. 프로덕션 환경에서는 MVC 또는 MVVM 패턴을 사용하는 것이 좋습니다