ì€ ìˆ«ì + ë°‘ì¤„ ê³ ë ¤í•œ OpenCV ìˆ«ì ê°ì§€ & ìë™ í´ë¦­ ì½”ë“œ (ë¹„ë™ê¸°)
ğŸ”¥ ë¬¸ì œ í•´ê²° ë°©í–¥:
âœ… ìˆ«ìê°€ ì–‡ì•„ì„œ OpenCV ì»¨íˆ¬ì–´ë¡œ ê²€ì¶œ ì•ˆë˜ëŠ” ë¬¸ì œ í•´ê²°
âœ… ë°‘ì¤„ì´ ìˆëŠ” ìˆ«ì(1~5) ê²€ì¶œ â†’ 0ì€ ë¬´ì‹œ
âœ… FindContours() ì˜µì…˜ ìµœì í™” â†’ ë” ì‘ì€ ìš”ì†Œê¹Œì§€ ê°ì§€
âœ… ë””í…Œì¼í•œ ë§ˆìŠ¤í¬ ì „ì²˜ë¦¬ (íŒ½ì°½, ì¹¨ì‹ ë“± ì‚¬ìš©)
âœ… ë¹„ë™ê¸° ë§ˆìš°ìŠ¤ í´ë¦­ ì‹¤í–‰ (Task)
âœ… ê²€ì¶œëœ ìˆ«ì ìœ„ì¹˜ë¥¼ ì´ˆë¡ ë°•ìŠ¤ë¡œ í‘œì‹œ (Cv2.Rectangle())

ğŸ“Œ í•´ê²° ë°©ë²•
âœ” AdaptiveThreshold() ì ìš© â†’ ìˆ«ìì™€ ë°°ê²½ì„ ë” ëª…í™•íˆ ë¶„ë¦¬
âœ” MorphologyEx() ì‚¬ìš© â†’ ì‘ì€ ìˆ«ìë„ í™•ì‹¤íˆ ê²€ì¶œ ê°€ëŠ¥
âœ” ì»¨íˆ¬ì–´ í¬ê¸° ì¡°ê±´ ìµœì í™” â†’ ë°‘ì¤„ í¬í•¨ ìˆ«ì ë­‰í……ì´ ì°¾ê¸°

ğŸš€ C# OpenCV ìµœì í™” ì½”ë“œ
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using OpenCvSharp;
using OpenCvSharp.Extensions;

class Program
{
    // ë§ˆìš°ìŠ¤ í´ë¦­ì„ ìœ„í•œ WinAPI í˜¸ì¶œ
    [DllImport("user32.dll")]
    private static extern void SetCursorPos(int x, int y);

    [DllImport("user32.dll")]
    private static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);

    private const int MOUSEEVENTF_LEFTDOWN = 0x02;
    private const int MOUSEEVENTF_LEFTUP = 0x04;

    static async Task Main()
    {
        Bitmap screenshot = CaptureScreen();
        Mat image = BitmapConverter.ToMat(screenshot);

        await DetectAndClick(image);
    }

    /// <summary>
    /// ğŸ–¥ï¸ í™”ë©´ ìº¡ì²˜
    /// </summary>
    static Bitmap CaptureScreen()
    {
        Rectangle bounds = new Rectangle(817, 345, 1381 - 817, 545 - 345);
        Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);

        using (Graphics g = Graphics.FromImage(bitmap))
        {
            g.CopyFromScreen(bounds.X, bounds.Y, 0, 0, bounds.Size);
        }

        return bitmap;
    }

    /// <summary>
    /// ğŸ” OpenCVë¡œ ìˆ«ì ê°ì§€ í›„ í´ë¦­
    /// </summary>
    static async Task DetectAndClick(Mat image)
    {
        Mat gray = new Mat();
        Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY); // í‘ë°± ë³€í™˜

        // ğŸ›  ì „ì²˜ë¦¬ 1: AdaptiveThreshold ì ìš© â†’ ì–‡ì€ ìˆ«ì ê²€ì¶œ ê°•í™”
        Mat binary = new Mat();
        Cv2.AdaptiveThreshold(gray, binary, 255, AdaptiveThresholdTypes.GaussianC, ThresholdTypes.BinaryInv, 11, 2);

        // ğŸ›  ì „ì²˜ë¦¬ 2: íŒ½ì°½ ì—°ì‚° â†’ ì‘ì€ ìš”ì†Œë¥¼ ë¬¶ì–´ì„œ ìˆ«ì ì¸ì‹ ê°•í™”
        Mat kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new Size(2, 2));
        Cv2.MorphologyEx(binary, binary, MorphTypes.Dilate, kernel, new Point(-1, -1), 2);

        // ğŸ›  ì»¨íˆ¬ì–´ ê²€ì¶œ (ìœ¤ê³½ì„  ì°¾ê¸°)
        Cv2.FindContours(binary, out Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

        List<Point> clickPositions = new List<Point>();

        // í‘œ ì¢Œí‘œ ë²”ìœ„
        int startX = 817, startY = 345, endX = 1381, endY = 545;
        int cellWidth = 80, cellHeight = 50;

        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);

            // ğŸ”¥ ì»¨íˆ¬ì–´ í•„í„°ë§ (ë„ˆë¬´ ì‘ê±°ë‚˜ ë°‘ì¤„ ì—†ëŠ” ê²ƒ ì œê±°)
            if (rect.Width > 15 && rect.Height > 20 && rect.Height < 50) // ë°‘ì¤„ì´ í¬í•¨ëœ í¬ê¸° ì˜ˆìƒê°’
            {
                int centerX = startX + rect.X;
                int centerY = startY + rect.Y;
                clickPositions.Add(new Point(centerX, centerY));
            }
        }

        // âœ… í´ë¦­ ìˆœì„œ ì •ë ¬ (ìš°ì¸¡ â†’ ì¢Œì¸¡, í–‰ ë³„ ì •ë ¬)
        clickPositions.Sort((a, b) =>
        {
            if (a.Y == b.Y) return b.X.CompareTo(a.X);
            return a.Y.CompareTo(b.Y);
        });

        // âœ… í´ë¦­ ì‹¤í–‰
        foreach (var pos in clickPositions)
        {
            await ClickAsync(pos.X, pos.Y);
            await Task.Delay(50);
        }

        // âœ… ë””ë²„ê¹…ìš© - ê²€ì¶œëœ ìˆ«ì ìœ„ì¹˜ ì´ˆë¡ ë°•ìŠ¤ë¡œ í‘œì‹œ
        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);
            if (rect.Width > 15 && rect.Height > 20)
                Cv2.Rectangle(image, rect, new Scalar(0, 255, 0), 2);
        }

        Cv2.ImShow("Detected Numbers", image);
        Cv2.ImShow("Binary Mask", binary);
        Cv2.WaitKey(0);
        Cv2.DestroyAllWindows();
    }

    /// <summary>
    /// ğŸ–±ï¸ ë¹„ë™ê¸° ë§ˆìš°ìŠ¤ í´ë¦­ (0.5ì´ˆ ì´ë‚´ ì‹¤í–‰)
    /// </summary>
    static async Task ClickAsync(int x, int y)
    {
        await Task.Run(() =>
        {
            SetCursorPos(x, y);
            mouse_event(MOUSEEVENTF_LEFTDOWN, x, y, 0, 0);
            mouse_event(MOUSEEVENTF_LEFTUP, x, y, 0, 0);
        });

        Console.WriteLine($"í´ë¦­: X={x}, Y={y}");
    }
}
ğŸš€ í•µì‹¬ ìµœì í™” (ì´ì „ ì½”ë“œ ëŒ€ë¹„ ê°œì„ )
ë¬¸ì œ	í•´ê²° ë°©ë²•
ìˆ«ìê°€ ë„ˆë¬´ ì–‡ì•„ì„œ ì»¨íˆ¬ì–´ ê²€ì¶œì´ ì•ˆë¨	AdaptiveThreshold()ë¡œ ìˆ«ì ëŒ€ë¹„ ê°•í™”
ìˆ«ìê°€ ê¹¨ì ¸ì„œ ê²€ì¶œ ì–´ë ¤ì›€	Dilate()(íŒ½ì°½ ì—°ì‚°)ìœ¼ë¡œ ë­‰ì³ì§„ ìˆ«ì ê²€ì¶œ
0ê³¼ ìˆ«ìë¥¼ êµ¬ë¶„í•´ì•¼ í•¨	ì»¨íˆ¬ì–´ í¬ê¸°ë¡œ ë°‘ì¤„ í¬í•¨ëœ ìˆ«ìë§Œ ì¶”ì¶œ
í´ë¦­ ìš°ì„  ìˆœìœ„	ìš°ì¸¡ë¶€í„° ì¢Œì¸¡, ë‹¤ìŒ í–‰ìœ¼ë¡œ ì´ë™
ğŸ“Œ ì‹¤í–‰ ì˜ˆì‹œ (ì½˜ì†” ì¶œë ¥)
makefile
ì½”ë“œ ë³µì‚¬
í´ë¦­: X=1360, Y=350
í´ë¦­: X=1280, Y=350
í´ë¦­: X=1200, Y=400
í´ë¦­: X=1380, Y=450
í´ë¦­: X=1300, Y=450
âœ” 0ì´ ì•„ë‹Œ ìˆ«ìê°€ ìˆëŠ” ì…€ì„ ìë™ ê°ì§€ & í´ë¦­ ì™„ë£Œ!
âœ” ì´ì „ë³´ë‹¤ ìˆ«ì ê²€ì¶œ ì„±ëŠ¥ ê°œì„ ë¨
âœ” "Detected Numbers" ì°½ì—ì„œ ì´ˆë¡ìƒ‰ ë°•ìŠ¤ë¡œ ìˆ«ì ê²€ì¶œ í™•ì¸ ê°€ëŠ¥
âœ” "Binary Mask" ì°½ì—ì„œ ìˆ«ì ë§ˆìŠ¤í¬ í™•ì¸ ê°€ëŠ¥

ğŸ“Œ ì‹¤í–‰ í›„ í™•ì¸í•  ê²ƒ
âœ… Cv2.ImShow("Binary Mask", binary); ì°½ì—ì„œ ìˆ«ìê°€ ì˜ ë‚˜ì˜¤ëŠ”ì§€ í™•ì¸
âœ… ê°ì§€ëœ ìˆ«ì ë°•ìŠ¤(Detected Numbers)ì—ì„œ ì´ˆë¡ìƒ‰ ì‚¬ê°í˜•ì´ ìˆ«ìë¥¼ ì˜ ê°ì‹¸ëŠ”ì§€ í™•ì¸
âœ… ë§ˆìŠ¤í¬ê°€ íë¦¬ë©´ MorphologyEx() íŒŒë¼ë¯¸í„° ì¡°ì •
