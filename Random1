. 최종 RackLayoutGenerator.cs (씬 자동 구성 + 프리팹 자동 수정)
이 스크립트는 씬을 자동으로 구성하고, 프리팹에 필요한 식별 스크립트를 자동으로 추가하는 역할을 합니다.

위치: Project 창의 Editor 폴더

C#

// 유니티와 유니티 에디터의 기능을 사용하겠다고 선언합니다.
using UnityEngine;
using UnityEditor;

// 이 클래스는 유니티 에디터의 기능을 확장하는 스크립트입니다.
public class RackLayoutGenerator
{
    // --- 씬 배치 설정 ---
    private static readonly int RACK_COUNT_PER_ROW = 12;      // 한 줄에 배치될 랙의 개수
    private static readonly float RACK_GAP = 0.01f;           // 랙과 랙 사이의 간격
    private static readonly float AISLE_WIDTH = 4.0f;         // A열과 B열 사이의 복도 넓이

    // 유니티 상단 메뉴에 "Tools/SMD Rack/Generate Final Layout" 버튼을 생성합니다.
    [MenuItem("Tools/SMD Rack/Generate Final Layout")]
    private static void GenerateLayout()
    {
        // 사용자가 Project 창에서 선택한 오브젝트를 가져옵니다.
        GameObject rackPrefab = Selection.activeObject as GameObject;
        if (rackPrefab == null) { EditorUtility.DisplayDialog("오류", "Project 창에서 랙 '프리팹'을 먼저 선택해주세요.", "확인"); return; }

        // 프리팹에 식별 스크립트가 없으면 자동으로 추가합니다.
        AddIdentifierScriptsToPrefab(rackPrefab);

        // 기존에 생성된 랙이 있다면 삭제하고, "Rack_Installations" 부모 오브젝트를 새로 생성합니다.
        if(GameObject.Find("Rack_Installations")) GameObject.DestroyImmediate(GameObject.Find("Rack_Installations"));
        GameObject parentObject = new GameObject("Rack_Installations");
        
        // 프리팹의 전체 너비를 정확하게 계산합니다.
        Bounds totalBounds = new Bounds();
        Renderer[] renderers = rackPrefab.GetComponentsInChildren<Renderer>();
        if(renderers.Length > 0)
        {
            totalBounds = renderers[0].bounds;
            foreach (Renderer renderer in renderers) { totalBounds.Encapsulate(renderer.bounds); }
        }
        float rackWidth = totalBounds.size.x;

        // 모델을 똑바로 세우기 위한 기본 회전 값을 미리 계산합니다.
        Quaternion standingRotation = Quaternion.Euler(-90, 0, 0);

        // 첫 번째 줄 (A열)을 생성합니다.
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            // 이름을 "A01", "A02" ... 형식으로 깨끗하게 짓습니다.
            rackInstance.name = "A" + (i + 1).ToString("D2");
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, 0);
            // 랙을 세우고 Z축으로 180도 회전시킵니다.
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 0, 180);
        }
        
        // 두 번째 줄 (B열)을 생성합니다.
        for (int i = 0; i < RACK_COUNT_PER_ROW; i++)
        {
            GameObject rackInstance = (GameObject)PrefabUtility.InstantiatePrefab(rackPrefab, parentObject.transform);
            rackInstance.name = "B" + (i + 1).ToString("D2");
            float posX = i * (rackWidth + RACK_GAP);
            rackInstance.transform.position = new Vector3(posX, 0, AISLE_WIDTH);
            // 랙을 세우고 Y축으로 180도 회전시켜 A열과 마주보게 합니다.
            rackInstance.transform.rotation = standingRotation * Quaternion.Euler(0, 180, 0);
        }
        EditorUtility.DisplayDialog("완료", "프리팹 자동 수정 및 랙 배치가 완료되었습니다.", "확인");
    }

    // 프리팹 파일 자체를 열어 식별 스크립트를 추가하는 함수
    private static void AddIdentifierScriptsToPrefab(GameObject rackPrefab)
    {
        string prefabPath = AssetDatabase.GetAssetPath(rackPrefab);
        GameObject prefabContents = PrefabUtility.LoadPrefabContents(prefabPath);

        // MaskIdentifier가 하나라도 있는지 확인하여, 이미 작업된 프리팹인지 판단합니다.
        if(prefabContents.GetComponentInChildren<MaskIdentifier>(true) != null)
        {
            PrefabUtility.UnloadPrefabContents(prefabContents);
            return; 
        }

        // MaskIdentifier가 하나도 없을 경우에만 아래 로직을 실행합니다.
        Debug.Log($"'{rackPrefab.name}' 프리팹에 식별 스크립트를 자동으로 추가합니다...");
        foreach(Transform child in prefabContents.GetComponentsInChildren<Transform>(true))
        {
            if(child.name.StartsWith("Mask_") && child.GetComponent<MaskIdentifier>() == null)
                child.gameObject.AddComponent<MaskIdentifier>();
            
            if(child.name.StartsWith("Lamp_") && child.GetComponent<LampIdentifier>() == null)
                child.gameObject.AddComponent<LampIdentifier>();
        }
        PrefabUtility.SaveAsPrefabAsset(prefabContents, prefabPath);
        PrefabUtility.UnloadPrefabContents(prefabContents);
    }
}
## 2. 최종 RackSystemManager.cs (기능 담당 - Point Light 방식)
이 스크립트는 게임이 시작된 후의 모든 실제 동작(바코드 처리, 램프 점등, 애니메이션)을 담당하는 '두뇌' 입니다.

위치: Project 창의 Scripts 폴더

C#

// 유니티의 기본 기능 및 UI 기능을 사용하겠다고 선언합니다.
using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;

// 시뮬레이션의 모든 기능을 총괄하는 메인 클래스입니다.
public class RackSystemManager : MonoBehaviour
{
    // --- Inspector 창에서 유니티 에디터와 연결할 변수들 ---
    [Header("핵심 연결 대상")]
    public Transform rackContainer; // 씬에 배치된 모든 랙들의 최상위 부모("Rack_Installations")를 연결합니다.

    [Header("애니메이션")]
    public float animationDuration = 0.5f; // 마스크가 움직이는 시간 (초)
    public float slideOutDistance = 0.4f;  // 마스크가 튀어나오는 거리

    // --- 스크립트 내부에서 사용할 데이터 저장소 (빠른 검색을 위한 데이터베이스) ---
    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>(); // Key: "A01_Mask_C05", Value: 해당 마스크 오브젝트
    private Dictionary<string, Light> lampLights = new Dictionary<string, Light>();           // Key: "A01_Lamp_C05", Value: 해당 램프의 Light 컴포넌트
    
    // --- 마지막으로 활성화된 오브젝트의 상태를 기억하기 위한 변수들 ---
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Light lastActiveLight; // 마지막으로 켜진 Light를 기억
    private Vector3 lastMaskOriginalLocalPosition;
    private string currentActiveBarcode = ""; // 중복 입력을 방지하기 위해 현재 활성화된 바코드를 저장

    // 게임이 시작될 때 단 한 번만 호출됩니다.
    void Start()
    {
        InitializeAllRacks(); // 모든 랙 정보를 수집하고 정리합니다.
    }

    // 씬에 배치된 모든 램프와 마스크를 찾아 데이터베이스(Dictionary)에 등록합니다.
    void InitializeAllRacks()
    {
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다!"); return; }

        foreach (Transform rackParent in rackContainer)
        {
            string rackName = rackParent.name; // "A01", "B12" 등 깨끗한 이름
            
            // 해당 랙 하위의 모든 Light 컴포넌트를 찾습니다.
            Light[] childLights = rackParent.GetComponentsInChildren<Light>(true);
            foreach(Light light in childLights)
            {
                string localName = light.gameObject.name; // Light가 붙어있는 게임오브젝트의 이름 ("Lamp_A01" 등)
                if (localName.StartsWith("Lamp_"))
                {
                    string globalKey = $"{rackName}_{localName}";
                    if (!lampLights.ContainsKey(globalKey))
                    {
                        lampLights.Add(globalKey, light);
                        light.enabled = false; // 모든 램프를 꺼진 상태로 초기화
                    }
                }
            }

            // 해당 랙 하위의 모든 MaskIdentifier 컴포넌트를 찾아 마스크를 등록합니다.
            MaskIdentifier[] childMasks = rackParent.GetComponentsInChildren<MaskIdentifier>(true);
            foreach(MaskIdentifier mask in childMasks)
            {
                 string localName = mask.gameObject.name; // "Mask_A01" 등
                 string globalKey = $"{rackName}_{localName}";
                 if (!maskObjects.ContainsKey(globalKey))
                    maskObjects.Add(globalKey, mask.gameObject);
            }
        }
        Debug.Log($"초기화 완료: {lampLights.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    // InputField에 입력된 바코드를 받아 처리하는 메인 함수입니다.
    public void ProcessBarcode(string barcode)
    {
        // 현재 활성화된 바코드와 동일한 코드가 입력되면 아무것도 하지 않고 종료합니다.
        if (barcode == currentActiveBarcode) return;
        
        ResetPreviousSlot(); // 먼저 이전에 선택됐던 슬롯을 초기화합니다.
        
        // 입력된 바코드의 유효성을 검사합니다.
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10")) return;

        // 바코드 "MMF10A01C05"를 규칙에 따라 정확히 해석합니다.
        string rackID = barcode.Substring(5, 3);   // "A01"
        string floor = barcode.Substring(8, 1);     // "C"
        string slotNum = barcode.Substring(9, 2);   // "05"
        
        // 해석된 정보로 데이터베이스에서 검색할 내부 주소(키)를 다시 조립합니다.
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}";
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}";
        
        // 조립된 주소로 램프를 찾아 켭니다.
        if (lampLights.TryGetValue(lampKey, out Light targetLight))
        {
            targetLight.enabled = true;
            lastActiveLight = targetLight;
        }

        // 조립된 주소로 마스크를 찾아 애니메이션을 실행합니다.
        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
        currentActiveBarcode = barcode; // 현재 활성화된 바코드로 기록합니다.
    }
    
    #region 보조 함수들
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        // 이전에 켜졌던 Light 컴포넌트를 비활성화하여 끕니다.
        if (lastActiveLight != null)
        {
            lastActiveLight.enabled = false;
            lastActiveLight = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false));
            lastMovedMask = null;
        }
        currentActiveBarcode = "";
    }

    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;
        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; 
        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }
        float timeElapsed = 0;
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null;
        }
        mask.transform.localPosition = endPosition;
        if (rb != null) rb.isKinematic = false;
    }
    
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper());
        }
    }
    #endregion
}

// 프리팹 내부 오브젝트 식별을 위한 태그용 스크립트들 (내용은 비어있는 것이 정상)
public class MaskIdentifier : MonoBehaviour { }
public class LampIdentifier : MonoBehaviour { }
## ❗️ 중요: 식별 스크립트 2개 확인
위 시스템이 작동하려면, Scripts 폴더에 아래의 내용만 들어있는 MaskIdentifier.cs 와 LampIdentifier.cs 파일이 반드시 필요합니다.

MaskIdentifier.cs 파일 내용:

C#

using UnityEngine;
public class MaskIdentifier : MonoBehaviour { }
LampIdentifier.cs 파일 내용:

C#
