네, 맞습니다. 현재 코드는 별도의 메인 윈도우(MainWindow.xaml)를 사용하지 않고, App.xaml.cs에서 직접 AgentCoreService를 초기화하고 트레이 아이콘을 통해 최소한의 상호작용만 제공하는 백그라운드 애플리케이션 형태로 구성되어 있습니다.

지적해주신 코드 오류들에 대해 수정하겠습니다.

1. App.xaml.cs의 SetupTrayIcon 내부 오류 수정

SystemIcons.Shield와 ContextMenuStrip 등은 System.Drawing과 System.Windows.Forms 네임스페이스에 있습니다. 이 네임스페이스를 사용하기 위해서는 해당 어셈블리 참조가 프로젝트에 추가되어야 하고, using 지시문도 포함되어야 합니다.

프로젝트 참조 확인/추가:

솔루션 탐색기에서 프로젝트 이름을 마우스 오른쪽 버튼으로 클릭합니다.
"참조 추가"(Add Reference)를 선택합니다.
"어셈블리" > "프레임워크" 탭으로 이동합니다.
System.Drawing과 System.Windows.Forms를 찾아 체크하고 확인을 누릅니다.
App.xaml.cs 상단에 using 지시문 추가:

<!-- end list -->

C#

// MonitorAgent/App.xaml.cs
using System;
using System.Windows;
// System.Windows.Forms와 System.Drawing 참조 및 using 지시문 추가
using System.Windows.Forms; // NotifyIcon, ContextMenuStrip, ToolStripSeparator 등
using System.Drawing;       // Icon, SystemIcons 등
using MonitorAgent.Core;
using MonitorAgent.Services;
using MonitorAgent.Config;
using System.Threading.Tasks;
// Mutex 사용 시 (중복 실행 방지)
// using System.Threading;
수정된 SetupTrayIcon 메서드:

C#

// MonitorAgent/App.xaml.cs
// ... (다른 코드는 동일)

        private void SetupTrayIcon()
        {
            _notifyIcon = new NotifyIcon
            {
                // Icon 리소스 로드 (프로젝트 리소스에 아이콘 파일(예: agent.ico) 추가 후 사용)
                // 예시: Icon = new Icon(GetType(), "agent.ico"); // 리소스로 포함된 경우
                // 또는 간단하게 시스템 아이콘 사용 (배포 시 적절한 아이콘으로 교체 권장)
                Icon = SystemIcons.Application, // SystemIcons 사용 예시 (System.Drawing 참조 필요)
                Visible = true,
                Text = "Monitor Agent - Initializing..."
            };

            var contextMenu = new ContextMenuStrip(); // System.Windows.Forms.ContextMenuStrip
            contextMenu.Items.Add("Show Status", null, OnShowStatusClicked);
            contextMenu.Items.Add(new ToolStripSeparator()); // System.Windows.Forms.ToolStripSeparator
            contextMenu.Items.Add("Exit", null, OnExitClicked);

            _notifyIcon.ContextMenuStrip = contextMenu;
            _notifyIcon.DoubleClick += OnShowStatusClicked;
        }

// ... (나머지 App.xaml.cs 코드는 이전과 동일)
아이콘 설정 참고:

SystemIcons.Application 또는 SystemIcons.Shield 등은 간단한 테스트용이며, 실제 배포 시에는 프로젝트에 .ico 파일을 추가하고 리소스로 빌드한 후 로드하는 것이 좋습니다.
프로젝트에 agent.ico 파일을 추가하고 속성에서 "빌드 작업(Build Action)"을 "포함 리소스(Embedded Resource)"로 설정합니다.
코드에서 Icon = new System.Drawing.Icon(System.Reflection.Assembly.GetExecutingAssembly().GetManifestResourceStream("MonitorAgent.agent.ico")); 와 같이 로드할 수 있습니다. (네임스페이스와 파일명에 주의)
또는 Icon = new Icon("path/to/your/icon.ico"); 처럼 파일 경로에서 직접 로드할 수도 있지만, 실행 파일과 함께 아이콘 파일이 배포되어야 합니다.
2. ProxiedTcpClient.cs의 ConnectAsync 내부 IsCompletedSuccessfully 오류 수정

.NET Framework 4.5의 Task에는 IsCompletedSuccessfully 속성이 없습니다. 대신 Status 속성을 사용하거나 IsCompleted, IsFaulted, IsCanceled 속성을 조합하여 확인해야 합니다.

수정된 ConnectAsync 메서드 내 연결 시도 부분:

C#

// MonitorAgent/Network/ProxiedTcpClient.cs
// ... (다른 코드는 동일)

        public async Task<bool> ConnectAsync()
        {
            if (IsConnected) return true;

            _cancellationTokenSource = new CancellationTokenSource();
            
            while(!_cancellationTokenSource.IsCancellationRequested)
            {
                try
                {
                    _logger.LogInfo($"Attempting to connect to Gateway: {_gatewayIp}:{_gatewayPort}");
                    _tcpClient = new TcpClient();
                    
                    var connectTask = _tcpClient.ConnectAsync(_gatewayIp, _gatewayPort);
                    var timeoutDelayTask = Task.Delay(TimeSpan.FromSeconds(10), _cancellationTokenSource.Token); // 연결 타임아웃 10초로 증가

                    Task completedTask = await Task.WhenAny(connectTask, timeoutDelayTask).ConfigureAwait(false);

                    if (completedTask == timeoutDelayTask || _cancellationTokenSource.IsCancellationRequested)
                    {
                        _tcpClient.Close(); // 연결 시도 중이던 TcpClient 닫기
                        if (_cancellationTokenSource.IsCancellationRequested) {
                             _logger.LogInfo("Connection attempt cancelled.");
                             return false; // 취소 시 루프 및 메서드 종료
                        }
                        _logger.LogWarning($"Timeout connecting to Gateway {_gatewayIp}:{_gatewayPort}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...");
                        await Task.Delay(_retryConnectDelay, _cancellationTokenSource.Token); // 여기서도 취소 가능성 확인
                        if (_cancellationTokenSource.IsCancellationRequested) return false;
                        continue; // 다음 재시도
                    }
                    
                    // connectTask가 완료되었는지, 그리고 성공적으로 완료되었는지 확인
                    // .NET Framework 4.5에서는 IsCompletedSuccessfully가 없으므로 Status로 확인
                    if (connectTask.Status == TaskStatus.RanToCompletion) // 작업이 성공적으로 완료됨
                    {
                        // _tcpClient.Connected는 ConnectAsync 성공 후 true가 됨.
                         if (!_tcpClient.Connected) // 혹시 모를 상황 대비
                         {
                            _logger.LogWarning($"ConnectAsync RanToCompletion but TcpClient not connected. Retrying...");
                            _tcpClient.Close();
                            await Task.Delay(_retryConnectDelay, _cancellationTokenSource.Token);
                            if (_cancellationTokenSource.IsCancellationRequested) return false;
                            continue;
                         }

                        _networkStream = _tcpClient.GetStream();
                        _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                        _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                        _logger.LogInfo("Successfully connected to Gateway.");

                        _receiveLoopTask = Task.Run(() => ReceiveMessagesAsync(_cancellationTokenSource.Token), _cancellationTokenSource.Token);
                        
                        _heartbeatTimer?.Dispose(); // 이전 타이머가 있다면 정리
                        _heartbeatTimer = new Timer(async _ => await SendHeartbeatAsync(), null, _heartbeatInterval, _heartbeatInterval);

                        return true; // 연결 성공 및 루프 종료
                    }
                    else // connectTask가 실패(Faulted)하거나 취소(Canceled)된 경우
                    {
                        _tcpClient.Close();
                        if (connectTask.IsFaulted)
                        {
                             _logger.LogError($"Connection task faulted: {connectTask.Exception?.GetBaseException().Message}. Retrying...", connectTask.Exception);
                        }
                        else if (connectTask.IsCanceled) // 외부에서 CancellationToken으로 취소된 경우
                        {
                             _logger.LogInfo("Connection task was cancelled. Retrying or exiting if app is stopping...");
                             // 여기서 _cancellationTokenSource.IsCancellationRequested 확인하여 앱 종료인지 판단 가능
                        }
                        else // 기타 상태
                        {
                            _logger.LogWarning($"Connection task completed with status: {connectTask.Status}. Retrying...");
                        }
                        
                        await Task.Delay(_retryConnectDelay, _cancellationTokenSource.Token);
                        if (_cancellationTokenSource.IsCancellationRequested) return false;
                        continue; // 다음 재시도
                    }
                }
                // ... (catch 블록들은 이전과 동일) ...
                catch (SocketException sockEx)
                {
                     _logger.LogError($"SocketException connecting to Gateway: {sockEx.Message}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...", sockEx);
                     // 연결 실패 시 _tcpClient가 null이거나 이미 닫혔을 수 있으므로, 명시적으로 닫아줄 필요는 없음.
                     // 하지만 다음 루프에서 new TcpClient() 하므로 괜찮음.
                }
                catch (OperationCanceledException) when (_cancellationTokenSource.IsCancellationRequested)
                {
                    _logger.LogInfo("Connection to Gateway cancelled by CancellationTokenSource.");
                    return false; // 루프 및 메서드 종료
                }
                catch (Exception ex)
                {
                    _logger.LogError($"Error connecting to Gateway: {ex.Message}. Retrying in {_retryConnectDelay.TotalSeconds} seconds...", ex);
                }
                
                if (_cancellationTokenSource.IsCancellationRequested) break; // 루프 조건 확인
                
                // 재시도 전 딜레이 중에도 취소될 수 있도록 CancellationToken 전달
                try
                {
                    await Task.Delay(_retryConnectDelay, _cancellationTokenSource.Token);
                }
                catch(OperationCanceledException) when (_cancellationTokenSource.IsCancellationRequested)
                {
                    _logger.LogInfo("Retry delay cancelled.");
                    return false; // 루프 및 메서드 종료
                }
            }
            return false; // 최종 연결 실패 (루프가 정상적으로 또는 취소로 종료)
        }

// ... (나머지 ProxiedTcpClient.cs 코드는 이전과 동일)
ConnectAsync 수정 사항 설명:

Task.WhenAny를 사용하여 연결 작업(connectTask)과 타임아웃 지연 작업(timeoutDelayTask) 중 먼저 완료되는 것을 기다립니다.
만약 timeoutDelayTask가 먼저 완료되거나, 전체 작업이 외부에서 취소되면 연결 실패로 간주하고 재시도 또는 종료합니다.
connectTask가 먼저 완료된 경우, connectTask.Status == TaskStatus.RanToCompletion을 통해 연결이 성공했는지 확인합니다.
TaskStatus.Faulted는 예외 발생, TaskStatus.Canceled는 작업 취소를 의미합니다.