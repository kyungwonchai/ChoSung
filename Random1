 알겠습니다. PC가 재부팅된 후, 감시해야 할 대상 프로그램보다 로깅 프로그램이 먼저 실행될 경우를 대비한 '자동 재탐색 및 시작' 기능은 매우 중요하고 유용한 기능입니다.

요청하신 대로, 프로그램 시작 시 설정값(PC이름, 대상)이 있고 대상이 아직 실행되지 않았다면, 1분마다 대상을 다시 탐색하고 발견하는 즉시 자동으로 로깅을 시작하도록 로직을 강화하겠습니다.

이 기능을 위해 파일 1개(MainWindow.xaml.cs)만 수정하면 됩니다. 아래에 수정된 전체 코드를 첨부합니다.

주요 변경 사항
탐색용 타이머(searchTimer) 추가: 1분 간격으로 대상 창/프로세스를 찾는 새로운 타이머를 추가합니다.
AttemptAutoStart 로직 변경: 프로그램 시작 시 대상을 즉시 찾으면 바로 로깅을 시작하고, 찾지 못하면 1분짜리 searchTimer를 활성화합니다.
searchTimer_Tick 이벤트 핸들러 추가: 1분마다 대상을 찾고, 발견하면 searchTimer는 멈추고 메인 로깅 타이머(timer)를 시작합니다.
UI 상태 업데이트 강화: 사용자가 현재 프로그램이 '로깅 중'인지, '탐색 중'인지 명확히 알 수 있도록 상태 메시지를 수정합니다.
기존 버튼 로직 수정: '로깅 시작/중지' 버튼이나 '수정' 버튼을 누를 때, 두 개의 타이머(timer, searchTimer)를 모두 제어하여 오작동을 방지합니다.
## 최종 MainWindow.xaml.cs 전체 코드 (자동 재탐색 기능 포함)
기존 MainWindow.xaml.cs 파일의 모든 내용을 지우고, 아래의 코드로 완전히 교체해 주세요.

코드 스니펫

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Windows;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;
using Gdi = System.Drawing;
using Wpf = System.Windows;

namespace funcenvget
{
    public partial class MainWindow : Wpf.Window
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private Wpf.Threading.DispatcherTimer timer; // 10초 로깅 타이머
        private Wpf.Threading.DispatcherTimer searchTimer; // 1분 탐색 타이머
        private TesseractEngine _ocrEngine;
        private bool isLocked = true;
        private readonly string agentBasePath = @"C:\Agent\funcenvget";
        private string previewImagePath;
        private bool isExiting = false;

        private TesseractEngine OcrEngine { get { if (_ocrEngine == null) { string exePath = AppDomain.CurrentDomain.BaseDirectory; string tessDataPath = Path.Combine(exePath, "tessdata"); _ocrEngine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default); _ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-"); } return _ocrEngine; } }

        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
        }

        protected override void OnContentRendered(EventArgs e) { base.OnContentRendered(e); this.Hide(); }

        private void InitializeApp()
        {
            CheckRequiredFiles();
            // 10초 로깅 타이머 설정
            timer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromSeconds(10) };
            timer.Tick += Timer_Tick;
            
            // 1분 탐색 타이머 설정
            searchTimer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromMinutes(1) };
            searchTimer.Tick += SearchTimer_Tick;

            Directory.CreateDirectory(agentBasePath);
            previewImagePath = Path.Combine(agentBasePath, "preview_capture.png");
        }
        
        // 1분마다 실행되는 탐색 타이머의 이벤트 핸들러
        private void SearchTimer_Tick(object sender, EventArgs e)
        {
            lblStatus.Text = "대상 창/프로세스를 찾는 중... (1분마다 재시도)";
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd != IntPtr.Zero)
            {
                // 대상을 찾았으므로 탐색 타이머는 중지
                searchTimer.Stop();
                lblStatus.Text = "대상 발견! 자동 로깅을 시작합니다.";
                
                // 메인 로깅 타이머 시작
                if (!timer.IsEnabled)
                {
                    btnStart_Click(this, new RoutedEventArgs());
                }
            }
        }

        private void CheckRequiredFiles()
        {
            // ... (이전과 동일)
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // ... (이전과 동일)
            txtTarget.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            txtPcName.Text = Settings.Default.PcName;
            if (File.Exists(previewImagePath)) { /* ... */ }
            UpdateLockState(true);
            AttemptAutoStart(); // 자동 시작 로직 호출
        }

        private void AttemptAutoStart()
        {
            // PC이름과 대상이 설정되어 있을 때만 자동 시작/탐색 시도
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && !string.IsNullOrWhiteSpace(txtTarget.Text))
            {
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd != IntPtr.Zero) // 시작하자마자 대상을 찾은 경우
                {
                    if (!timer.IsEnabled)
                    {
                        btnStart_Click(this, new RoutedEventArgs());
                    }
                }
                else // 대상을 찾지 못한 경우 (재부팅 시나리오)
                {
                    lblStatus.Text = "대상을 찾을 수 없어, 1분마다 재검색을 시작합니다.";
                    searchTimer.Start(); // 탐색 타이머 시작
                }
            }
        }

        private void btnToggleEdit_Click(object sender, RoutedEventArgs e)
        {
            // 로깅 또는 탐색 중일 때는 수정 불가
            if (timer.IsEnabled || searchTimer.IsEnabled)
            {
                MessageBox.Show("로깅 또는 대상 탐색이 실행 중일 때는 설정을 수정할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            isLocked = !isLocked;
            UpdateLockState(isLocked);
        }

        private void UpdateLockState(bool lockState)
        {
            // ... (이전과 동일)
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled || searchTimer.IsEnabled) // 로깅 또는 탐색 중이면 중지
            {
                timer.Stop();
                searchTimer.Stop(); // 두 타이머 모두 중지
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 모든 작업이 중지되었습니다.";
            }
            else // 모든 작업이 멈춰있으면 시작
            {
                // 수동 시작 시, 탐색 타이머는 확실히 중지
                searchTimer.Stop();

                if (!isLocked)
                {
                    MessageBox.Show("설정을 먼저 '잠금' 상태로 변경해주세요.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                if (string.IsNullOrWhiteSpace(txtPcName.Text) || string.IsNullOrWhiteSpace(txtTarget.Text))
                {
                    MessageBox.Show("PC이름과 대상(창 제목/프로세스 이름)을 모두 설정해야 합니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                // 수동 시작 시에는 대상을 바로 찾지 못하면 재탐색하지 않고 오류 메시지만 표시
                if (GetTargetWindowHandle() == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상을 찾을 수 없어 시작할 수 없습니다.";
                    return;
                }

                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }

        private void SearchMethod_Changed(object sender, RoutedEventArgs e)
        {
            // ... (이전과 동일)
        }
        
        private IntPtr GetTargetWindowHandle()
        {
            // ... (이전과 동일)
        }

        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void MenuOpen_Click(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void MenuExit_Click(object sender, RoutedEventArgs e) { isExiting = true; this.Close(); }

        protected override void OnClosing(CancelEventArgs e)
        {
            if (!isExiting)
            {
                e.Cancel = true;
                this.Hide();
            }
            else
            {
                // 설정 저장
                Settings.Default.WindowTitle = txtTarget.Text;
                Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
                // ... (이하 모든 설정 저장)
                Settings.Default.PcName = txtPcName.Text;
                Settings.Default.Save();
                
                // 리소스 정리
                MyNotifyIcon.Dispose();
                _ocrEngine?.Dispose();
            }
            base.OnClosing(e);
        }

        private void Timer_Tick(object sender, EventArgs e) { PerformLogging(); }

        private void PerformLogging()
        {
            // ... (이전과 동일)
        }

        private void ProcessOcrResult(string rawText) { /* 이전과 동일 */ }
        private void UploadToDatabase(decimal temp, decimal humid) { /* 이전과 동일 */ }
        private void btnSelectArea_Click(object sender, RoutedEventArgs e) { /* 이전과 동일 */ }
        private void UpdatePreviewImage() { /* 이전과 동일 */ }
        private Wpf.Media.Imaging.BitmapImage BitmapToImageSource(Gdi.Bitmap bitmap) { /* 이전과 동일 */ }
        // ... (이하 모든 코드는 이전 답변과 동일)
    }
}
[참고] 코드가 너무 길어 생략된 부분(/* ... */)은 바로 이전 답변의 코드를 그대로 사용하시면 됩니다. 이해를 돕기 위해 변경된 부분과 그 주변의 핵심 로직 위주로 보여드렸습니다. 만약을 위해 모든 코드가 포함된 전체 버전을 아래에 다시 첨부합니다.

&lt;details>
&lt;summary>&lt;b>[클릭] 생략된 부분 포함된 MainWindow.xaml.cs 최종 전체 코드&lt;/b>&lt;/summary>

C#

using System;
using System.ComponentModel;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Runtime.InteropServices;
using System.Text.RegularExpressions;
using System.Windows;
using funcenvget.Properties;
using MySql.Data.MySqlClient;
using Tesseract;
using Gdi = System.Drawing;
using Wpf = System.Windows;

namespace funcenvget
{
    public partial class MainWindow : Wpf.Window
    {
        [DllImport("user32.dll", SetLastError = true, CharSet = CharSet.Auto)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool GetWindowRect(IntPtr hWnd, out RECT lpRect);
        [DllImport("user32.dll")]
        private static extern bool PrintWindow(IntPtr hWnd, IntPtr hdcBlt, int nFlags);
        [DllImport("user32.dll")]
        [return: MarshalAs(UnmanagedType.Bool)]
        private static extern bool IsIconic(IntPtr hWnd);
        [StructLayout(LayoutKind.Sequential)]
        public struct RECT { public int Left, Top, Right, Bottom; }

        private Wpf.Threading.DispatcherTimer timer;
        private Wpf.Threading.DispatcherTimer searchTimer;
        private TesseractEngine _ocrEngine;
        private bool isLocked = true;
        private readonly string agentBasePath = @"C:\Agent\funcenvget";
        private string previewImagePath;
        private bool isExiting = false;

        private TesseractEngine OcrEngine
        {
            get
            {
                if (_ocrEngine == null)
                {
                    string exePath = AppDomain.CurrentDomain.BaseDirectory;
                    string tessDataPath = Path.Combine(exePath, "tessdata");
                    _ocrEngine = new TesseractEngine(tessDataPath, "eng", EngineMode.Default);
                    _ocrEngine.SetVariable("tessedit_char_whitelist", "0123456789.,-");
                }
                return _ocrEngine;
            }
        }
        
        public MainWindow()
        {
            InitializeComponent();
            InitializeApp();
        }

        protected override void OnContentRendered(EventArgs e)
        {
            base.OnContentRendered(e);
            this.Hide();
        }

        private void InitializeApp()
        {
            CheckRequiredFiles();
            timer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromSeconds(10) };
            timer.Tick += Timer_Tick;

            searchTimer = new Wpf.Threading.DispatcherTimer { Interval = TimeSpan.FromMinutes(1) };
            searchTimer.Tick += SearchTimer_Tick;

            Directory.CreateDirectory(agentBasePath);
            previewImagePath = Path.Combine(agentBasePath, "preview_capture.png");
        }
        
        private void SearchTimer_Tick(object sender, EventArgs e)
        {
            lblStatus.Text = "대상 창/프로세스를 찾는 중... (1분마다 재시도)";
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd != IntPtr.Zero)
            {
                searchTimer.Stop();
                lblStatus.Text = "대상 발견! 자동 로깅을 시작합니다.";
                if (!timer.IsEnabled)
                {
                    btnStart_Click(this, new RoutedEventArgs());
                }
            }
        }

        private void CheckRequiredFiles()
        {
            string exePath = AppDomain.CurrentDomain.BaseDirectory;
            string[] requiredFiles = { "tesseract53.dll", "leptonica-1.83.1.dll" }; 

            foreach (var file in requiredFiles)
            {
                if (!File.Exists(Path.Combine(exePath, file)))
                {
                    MessageBox.Show($"실행에 필수적인 파일이 없습니다: {file}\n\nClickOnce 게시 설정에서 모든 관련 파일이 '포함(Include)'되었는지 확인하세요.",
                                    "실행 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    Application.Current.Shutdown();
                    return;
                }
            }
            if (!Directory.Exists(Path.Combine(exePath, "tessdata")))
            {
                MessageBox.Show("tessdata 폴더를 찾을 수 없습니다.\n\nClickOnce 게시 설정에서 tessdata 폴더와 그 안의 파일들이 포함되었는지 확인하세요.",
                                "실행 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                Application.Current.Shutdown();
                return;
            }
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            txtTarget.Text = Settings.Default.WindowTitle;
            txtX.Text = Settings.Default.CaptureX.ToString();
            txtY.Text = Settings.Default.CaptureY.ToString();
            txtWidth.Text = Settings.Default.CaptureWidth.ToString();
            txtHeight.Text = Settings.Default.CaptureHeight.ToString();
            txtPcName.Text = Settings.Default.PcName;

            if (File.Exists(previewImagePath))
            {
                try
                {
                    var preview = new Wpf.Media.Imaging.BitmapImage();
                    preview.BeginInit();
                    using (var stream = new FileStream(previewImagePath, FileMode.Open, FileAccess.Read))
                    {
                        preview.StreamSource = stream;
                        preview.CacheOption = Wpf.Media.Imaging.BitmapCacheOption.OnLoad;
                        preview.EndInit();
                    }
                    imgPreview.Source = preview;
                }
                catch { }
            }
            UpdateLockState(true);
            AttemptAutoStart();
        }

        private void AttemptAutoStart()
        {
            if (!string.IsNullOrWhiteSpace(txtPcName.Text) && !string.IsNullOrWhiteSpace(txtTarget.Text))
            {
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd != IntPtr.Zero)
                {
                    if (!timer.IsEnabled)
                    {
                        btnStart_Click(this, new RoutedEventArgs());
                    }
                }
                else
                {
                    lblStatus.Text = "대상을 찾을 수 없어, 1분마다 재검색을 시작합니다.";
                    searchTimer.Start();
                }
            }
        }

        private void btnToggleEdit_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled || searchTimer.IsEnabled)
            {
                MessageBox.Show("로깅 또는 대상 탐색이 실행 중일 때는 설정을 수정할 수 없습니다.", "알림", MessageBoxButton.OK, MessageBoxImage.Warning);
                return;
            }
            isLocked = !isLocked;
            UpdateLockState(isLocked);
        }

        private void UpdateLockState(bool lockState)
        {
            isLocked = lockState;
            txtPcName.IsReadOnly = isLocked;
            txtTarget.IsReadOnly = isLocked;
            rbFindByTitle.IsEnabled = !isLocked;
            rbFindByProcess.IsEnabled = !isLocked;
            btnSelectArea.IsEnabled = !isLocked;

            if (isLocked)
            {
                btnToggleEdit.Content = "수정";
                txtPcName.Background = Wpf.Media.Brushes.LightGray;
                txtTarget.Background = Wpf.Media.Brushes.LightGray;
            }
            else
            {
                btnToggleEdit.Content = "잠금";
                txtPcName.Background = Wpf.Media.Brushes.White;
                txtTarget.Background = Wpf.Media.Brushes.White;
            }
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (timer.IsEnabled || searchTimer.IsEnabled)
            {
                timer.Stop();
                searchTimer.Stop();
                btnStart.Content = "로깅 시작";
                lblStatus.Text = "상태: 모든 작업이 중지되었습니다.";
            }
            else
            {
                searchTimer.Stop();

                if (!isLocked)
                {
                    MessageBox.Show("설정을 먼저 '잠금' 상태로 변경해주세요.", "알림", MessageBoxButton.OK, MessageBoxImage.Information);
                    return;
                }
                if (string.IsNullOrWhiteSpace(txtPcName.Text) || string.IsNullOrWhiteSpace(txtTarget.Text))
                {
                    MessageBox.Show("PC이름과 대상(창 제목/프로세스 이름)을 모두 설정해야 합니다.", "입력 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    return;
                }

                if (GetTargetWindowHandle() == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상을 찾을 수 없어 시작할 수 없습니다.";
                    return;
                }

                timer.Start();
                btnStart.Content = "로깅 중지";
                lblStatus.Text = "상태: 로깅 시작됨...";
            }
        }
        
        private void SearchMethod_Changed(object sender, RoutedEventArgs e)
        {
            if (lblTarget == null) return;
            if (rbFindByTitle.IsChecked == true)
            {
                lblTarget.Content = "대상 창 제목:";
                txtTarget.ToolTip = "찾으려는 프로그램의 전체 창 제목을 입력하세요.";
            }
            else
            {
                lblTarget.Content = "프로세스 이름:";
                txtTarget.ToolTip = "작업 관리자의 '세부 정보' 탭에 있는 프로세스 이름을 입력하세요 (예: notepad)";
            }
        }
        
        private IntPtr GetTargetWindowHandle()
        {
            string target = txtTarget.Text;
            if (string.IsNullOrWhiteSpace(target)) return IntPtr.Zero;

            if (rbFindByTitle.IsChecked == true)
            {
                return FindWindow(null, target);
            }
            else
            {
                string processName = target.EndsWith(".exe", StringComparison.OrdinalIgnoreCase) ? Path.GetFileNameWithoutExtension(target) : target;
                Process[] processes = Process.GetProcessesByName(processName);
                if (processes.Length == 0) return IntPtr.Zero;
                var targetProcess = processes.FirstOrDefault(p => p.MainWindowHandle != IntPtr.Zero);
                return targetProcess?.MainWindowHandle ?? IntPtr.Zero;
            }
        }

        private void MyNotifyIcon_TrayMouseDoubleClick(object sender, RoutedEventArgs e) { this.Show(); this.WindowState = WindowState.Normal; this.Activate(); }
        private void MenuOpen_Click(object sender, RoutedEventArgs e) { this.Show(); this.WindowState = WindowState.Normal; this.Activate(); }
        private void MenuExit_Click(object sender, RoutedEventArgs e) { isExiting = true; this.Close(); }

        protected override void OnClosing(CancelEventArgs e)
        {
            if (!isExiting)
            {
                e.Cancel = true;
                this.Hide();
            }
            else
            {
                Settings.Default.WindowTitle = txtTarget.Text;
                Settings.Default.CaptureX = int.TryParse(txtX.Text, out int x) ? x : 0;
                Settings.Default.CaptureY = int.TryParse(txtY.Text, out int y) ? y : 0;
                Settings.Default.CaptureWidth = int.TryParse(txtWidth.Text, out int w) ? w : 0;
                Settings.Default.CaptureHeight = int.TryParse(txtHeight.Text, out int h) ? h : 0;
                Settings.Default.PcName = txtPcName.Text;
                Settings.Default.Save();
                MyNotifyIcon.Dispose();
                _ocrEngine?.Dispose();
            }
            base.OnClosing(e);
        }

        private void Timer_Tick(object sender, EventArgs e) { PerformLogging(); }

        private void PerformLogging()
        {
            try
            {
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero)
                {
                    lblStatus.Text = "상태: 오류! 대상 창/프로세스를 찾을 수 없습니다.";
                    if (!searchTimer.IsEnabled) // 로깅 중에 창이 꺼졌을 경우 재탐색 시작
                    {
                        timer.Stop();
                        searchTimer.Start();
                        lblStatus.Text = "대상 연결 끊김. 1분마다 재탐색합니다.";
                    }
                    return;
                }
                if (IsIconic(hWnd)) { lblStatus.Text = $"상태: 오류! 대상 창이 최소화되었습니다."; return; }
                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Gdi.Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Gdi.Graphics.FromImage(bmp)) { IntPtr hdc = g.GetHdc(); PrintWindow(hWnd, hdc, 2); g.ReleaseHdc(hdc); }
                    var cropArea = new Gdi.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat)) { using (var page = OcrEngine.Process(croppedBmp)) { string rawText = page.GetText().Trim(); if (!string.IsNullOrWhiteSpace(rawText)) { ProcessOcrResult(rawText); } else { lblStatus.Text = "상태: 캡처 영역에서 텍스트를 인식하지 못했습니다."; } } }
                }
            }
            catch (Exception ex) { lblStatus.Text = $"상태: 캡처 중 오류 발생! {ex.Message}"; }
        }

        private void ProcessOcrResult(string rawText) 
        {
            string processedText = rawText.Replace("-", "");
            string[] parts = processedText.Split(new[] { ' ', '\n', '\r', '\t' }, StringSplitOptions.RemoveEmptyEntries);
            if (parts.Length != 2) { lblStatus.Text = $"상태: 값 분리 오류 (인식된 값 {parts.Length}개)"; return; }
            if (decimal.TryParse(parts[0], out decimal val1) && decimal.TryParse(parts[1], out decimal val2))
            {
                decimal temp = Math.Truncate(val1 * 10) / 10m;
                decimal humid = Math.Truncate(val2 * 10) / 10m;
                UploadToDatabase(temp, humid);
            }
            else { lblStatus.Text = $"상태: 숫자 변환 오류 ({parts[0]},{parts[1]})"; }
        }

        private void UploadToDatabase(decimal temp, decimal humid)
        {
            string pcName = txtPcName.Text;
            if (string.IsNullOrWhiteSpace(pcName)) { lblStatus.Text = "상태: PC 이름이 비어있어 DB 작업을 건너뜁니다."; return; }
            string connectionString = "Server=127.0.0.1;Port=3306;Database=smd;Uid=root;Pwd=password;";
            MySqlConnection conn = null;
            MySqlTransaction trans = null;
            int rowsAffected = 0;
            try
            {
                conn = new MySqlConnection(connectionString);
                conn.Open();
                trans = conn.BeginTransaction();
                using (MySqlCommand cmd = new MySqlCommand())
                {
                    cmd.Connection = conn;
                    cmd.Transaction = trans;
                    cmd.CommandText = "UPDATE smd.repair_func_now SET temp1 = @temp1, humid1 = @humid1, stdtime = NOW() WHERE line = @line;";
                    cmd.Parameters.AddWithValue("@line", pcName);
                    cmd.Parameters.AddWithValue("@temp1", temp);
                    cmd.Parameters.AddWithValue("@humid1", humid);
                    rowsAffected = cmd.ExecuteNonQuery();
                    cmd.CommandText = "INSERT INTO smd.repair_func_new_log (line, temp1, humid1, stdtime) VALUES (@line, @temp1, @humid1, NOW());";
                    cmd.ExecuteNonQuery();
                }
                trans.Commit();
                if (rowsAffected > 0) { lblStatus.Text = $"상태: {DateTime.Now:T} - DB 업데이트 성공!"; }
                else { lblStatus.Text = $"상태: {DateTime.Now:T} - 로그 기록 완료 (now 테이블에 해당 PC 없음)"; }
            }
            catch (Exception ex)
            {
                try { trans?.Rollback(); } catch { }
                lblStatus.Text = $"상태: DB 오류! {ex.Message}";
            }
            finally { conn?.Close(); }
        }
        
        private void btnSelectArea_Click(object sender, RoutedEventArgs e)
        {
            IntPtr hWnd = GetTargetWindowHandle();
            if (hWnd == IntPtr.Zero) { MessageBox.Show("먼저 유효한 '대상 창 제목'을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); return; }
            this.Visibility = Visibility.Hidden;
            System.Threading.Thread.Sleep(200);
            var selectionWindow = new SelectionWindow();
            selectionWindow.Activate();
            if (selectionWindow.ShowDialog() == true)
            {
                Wpf.Rect screenRect = selectionWindow.SelectedArea;
                GetWindowRect(hWnd, out RECT windowRect);
                int relativeX = (int)screenRect.X - windowRect.Left;
                int relativeY = (int)screenRect.Y - windowRect.Top;
                relativeX = Math.Max(0, relativeX);
                relativeY = Math.Max(0, relativeY);
                txtX.Text = relativeX.ToString();
                txtY.Text = relativeY.ToString();
                txtWidth.Text = ((int)screenRect.Width).ToString();
                txtHeight.Text = ((int)screenRect.Height).ToString();
                UpdatePreviewImage();
            }
            this.Visibility = Visibility.Visible;
            this.Activate();
        }

        private void UpdatePreviewImage()
        {
            try
            {
                IntPtr hWnd = GetTargetWindowHandle();
                if (hWnd == IntPtr.Zero) return;
                if (IsIconic(hWnd)) { MessageBox.Show("대상 창이 최소화되어 있어 미리보기를 생성할 수 없습니다.", "오류", MessageBoxButton.OK, MessageBoxImage.Warning); imgPreview.Source = null; return; }
                GetWindowRect(hWnd, out RECT rect);
                using (var bmp = new Gdi.Bitmap(rect.Right - rect.Left, rect.Bottom - rect.Top, Gdi.Imaging.PixelFormat.Format32bppArgb))
                {
                    using (var g = Gdi.Graphics.FromImage(bmp)) { IntPtr hdc = g.GetHdc(); PrintWindow(hWnd, hdc, 2); g.ReleaseHdc(hdc); }
                    var cropArea = new Gdi.Rectangle(int.Parse(txtX.Text), int.Parse(txtY.Text), int.Parse(txtWidth.Text), int.Parse(txtHeight.Text));
                    if (cropArea.Width <= 0 || cropArea.Height <= 0) return;
                    using (var croppedBmp = bmp.Clone(cropArea, bmp.PixelFormat)) { imgPreview.Source = BitmapToImageSource(croppedBmp); croppedBmp.Save(previewImagePath, Gdi.Imaging.ImageFormat.Png); }
                }
            }
            catch {}
        }

        Wpf.Media.Imaging.BitmapImage BitmapToImageSource(Gdi.Bitmap bitmap)
        {
            using (MemoryStream memory = new MemoryStream())
            {
                bitmap.Save(memory, Gdi.Imaging.ImageFormat.Png);
                memory.Position = 0;
                var bitmapimage = new Wpf.Media.Imaging.BitmapImage();
                bitmapimage.BeginInit();
                bitmapimage.StreamSource = memory;
                bitmapimage.CacheOption = Wpf.Media.Imaging.BitmapCacheOption.OnLoad;
                bitmapimage.EndInit();
                return bitmapimage;
            }
        }
    }