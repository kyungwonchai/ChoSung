, 잘 동작한다니 다행입니다! 이제 자동으로 모니터 관련 설정(디스플레이 타임아웃)을 변경하는 스케줄링 기능이 언제 실행되고, 어떤 기준으로 가동일/비가동일을 판단하는지 관련된 파일과 코드를 알려드리겠습니다.

이 자동화 로직은 주로 다음 두 파일에 구현되어 있습니다:

app/scheduler_tasks.py:

이 파일에는 특정 날짜가 가동일인지 비가동일인지 판단하는 로직 (is_operational_day 함수)이 들어있습니다. 이 함수는 주말, 대한민국 공휴일 (holidays 라이브러리 사용), 그리고 관리자가 웹 UI를 통해 설정한 work_calendar_exceptions 데이터베이스 테이블의 예외 날짜를 모두 고려합니다.
또한, 실제 "모니터 켜기 설정"(타임아웃 해제) 또는 "모니터 끄기 설정"(1분 후 타임아웃) 명령을 모든 등록된 PC에 전송하는 함수들 (scheduled_task_monitor_on, scheduled_task_monitor_off, 그리고 내부 헬퍼 함수 _send_display_timeout_to_all_pcs)이 정의되어 있습니다.
app/__init__.py:

이 파일에서는 Flask 애플리케이션이 시작될 때 APScheduler (또는 Flask-APScheduler)를 초기화하고 스케줄러를 시작합니다.
가장 중요한 부분은 scheduler.add_job() 함수를 사용하여 app/scheduler_tasks.py에 정의된 위 작업 함수들이 매일 어떤 시간에 실행될지 (예: 아침 6시, 아침 7시) 설정하는 부분입니다. 즉, **"시간 설정"**은 이 파일에서 이루어집니다.
아래에 해당 파일들의 전체 코드를 다시 제공해 드리겠습니다. 코드 내에서 관련 부분을 찾아보시면 됩니다.

1. app/scheduler_tasks.py (가동/비가동일 판단 및 작업 실행 로직)
(이 파일은 이전 답변 #38에서 제공된 내용과 동일합니다. 주석은 최소화했습니다.)

Python

# scontrol_flask_web/app/scheduler_tasks.py
from datetime import date, time
import holidays
from flask import current_app
from .db_utils import get_db_connection
from .socket_client import send_command_to_agent
import json
import uuid
from datetime import datetime as dt, timezone

def is_operational_day(target_date):
    conn = None
    try:
        conn = get_db_connection()
        if not conn:
            current_app.logger.error("is_operational_day: DB 연결 실패. 기본 가동일 처리.")
            return True 

        with conn.cursor() as cursor:
            sql = "SELECT is_operational FROM dbo.work_calendar_exceptions WHERE exception_date = %s"
            cursor.execute(sql, (target_date.strftime('%Y-%m-%d'),))
            exception_day = cursor.fetchone()
            if exception_day:
                is_op = bool(exception_day['is_operational'])
                current_app.logger.info(f"{target_date}는 사용자 지정 예외일: {'가동일' if is_op else '비가동일'}")
                return is_op

        if target_date.weekday() >= 5: # 토(5), 일(6)
            current_app.logger.info(f"{target_date}는 주말(비가동일).")
            return False

        kr_holidays = holidays.KR(years=target_date.year) 
        if target_date in kr_holidays:
            current_app.logger.info(f"{target_date}는 공휴일('{kr_holidays.get(target_date)}'). (비가동일)")
            return False
            
        current_app.logger.info(f"{target_date}는 평일(가동일).")
        return True
    except Exception as e:
        current_app.logger.error(f"is_operational_day 함수 오류: {e}", exc_info=True)
        return True 

def _send_display_timeout_to_all_pcs(timeout_minutes, action_description):
    conn = None
    pcs_to_control = []
    try:
        conn = get_db_connection()
        if not conn:
            current_app.logger.error(f"_send_display_timeout_to_all_pcs: DB 연결 실패.")
            return
        with conn.cursor() as cursor:
            cursor.execute("SELECT id, pc_name, address1, address2 FROM dbo.target_pcs")
            pcs_to_control = cursor.fetchall()
    except Exception as e:
        current_app.logger.error(f"스케줄 작업 PC 목록 조회 오류: {e}", exc_info=True)
        return 

    if not pcs_to_control:
        current_app.logger.info("스케줄 작업: 제어할 PC 없음.")
        return

    current_app.logger.info(f"스케줄 작업 시작: '{action_description}'을(를) {len(pcs_to_control)}대 PC에 전송.")
    payload_obj = {'TimeoutMinutes': timeout_minutes}
    common_command_name = "SET_DISPLAY_TIMEOUT" 

    for pc_data in pcs_to_control:
        command_packet = {
            'PacketId': str(uuid.uuid4()),
            'TimestampUtc': dt.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z'),
            'CommandName': common_command_name,
            'PayloadJson': json.dumps(payload_obj),
            'ResponseAddress': None, 'ResponsePort': None
        }
        target_ip_for_command = ""; is_relay = bool(pc_data.get('address2') and pc_data['address2'].strip())
        if is_relay:
            command_packet['Instruction'] = "RelayToTarget"
            command_packet['FinalTargetIpForRelayedCommand'] = pc_data['address2']
            command_packet['FinalTargetPortForRelayedCommand'] = 4026
            target_ip_for_command = pc_data['address1']
        else:
            command_packet['Instruction'] = "DirectExecute"
            target_ip_for_command = pc_data['address1']

        log_prefix = f"[Scheduler][PC: {pc_data.get('pc_name','N/A')}({target_ip_for_command})]"
        current_app.logger.info(f"{log_prefix} - '{action_description}' 명령 전송 시도. PktID: {command_packet['PacketId']}")
        try:
            agent_response = send_command_to_agent(target_ip_for_command, command_packet)
            if agent_response.get('success'):
                raw_resp_packet = agent_response.get('raw_response')
                if raw_resp_packet and isinstance(raw_resp_packet, dict) and raw_resp_packet.get('PayloadJson'):
                    resp_payload = json.loads(raw_resp_packet['PayloadJson'])
                    if resp_payload.get('Success'): current_app.logger.info(f"{log_prefix} - 명령 성공: {resp_payload.get('Message', 'OK')}")
                    else: current_app.logger.error(f"{log_prefix} - 명령 실패 (에이전트): {resp_payload.get('Message', 'Agent error')}")
                else: current_app.logger.warning(f"{log_prefix} - 전송 성공, 상세 응답 확인 불가. Raw: {raw_resp_packet}")
            else: current_app.logger.error(f"{log_prefix} - 전송 실패: {agent_response.get('message', 'Socket error')}")
        except Exception as e_send:
            current_app.logger.error(f"{log_prefix} - 명령 전송 중 예외: {e_send}", exc_info=True)

def scheduled_task_monitor_on():
    with current_app.app_context(): 
        today = date.today()
        current_app.logger.info(f"[Scheduler] 모니터 켜기 작업 (06:00 예정), 오늘: {today}")
        if is_operational_day(today):
            current_app.logger.info(f"[Scheduler] 가동일: '모니터 켜기(타임아웃 해제)' 명령 전송.")
            _send_display_timeout_to_all_pcs(0, "디스플레이 항상 켜기 설정 (타임아웃 0분)")
        else:
            current_app.logger.info(f"[Scheduler] 비가동일: '모니터 켜기' 명령 미실행.")

def scheduled_task_monitor_off():
    with current_app.app_context():
        today = date.today()
        current_app.logger.info(f"[Scheduler] 모니터 끄기 작업 (07:00 예정), 오늘: {today}")
        if not is_operational_day(today): 
            current_app.logger.info(f"[Scheduler] 비가동일: '모니터 끄기(1분 후 타임아웃)' 명령 전송.")
            _send_display_timeout_to_all_pcs(1, "디스플레이 1분 후 자동 꺼짐 설정")
        else:
            current_app.logger.info(f"[Scheduler] 가동일: '모니터 끄기' 명령 미실행.")
2. app/__init__.py (APScheduler 설정 및 작업 스케줄링)
이 파일에서 APScheduler가 scheduler_tasks.py의 함수들을 언제 (몇 시에) 실행할지 설정합니다. (이전 답변 #47에서 Flask-APScheduler 관련 오류 수정 버전입니다.)

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app
from config import config
import datetime
import os
from flask_apscheduler import APScheduler 

scheduler = APScheduler()

def create_app(config_name='default'):
    app = Flask(__name__)
    app.config.from_object(config[config_name])
    config[config_name].init_app(app)

    from . import db_utils 
    app.teardown_appcontext(db_utils.close_db)

    # --- Jinja2 필터 및 컨텍스트 프로세서 ---
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: app.logger.warning(f"날짜 파싱 실패 (format_datetime): '{original_value_for_log}'"); return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: app.logger.error(f"날짜 파싱 중 예외 (format_datetime) '{original_value_for_log}': {e_parse}"); return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}
    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)

    # --- 블루프린트 등록 ---
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 

    # --- APScheduler 초기화 및 작업 등록 ---
    if not scheduler.running:
        scheduler.init_app(app)
        from . import scheduler_tasks # 스케줄 작업 함수들이 있는 모듈 임포트

        # 개발 중 재시작 시 작업 중복 방지를 위해 기존 작업 제거 (ID 기반)
        if app.debug:
            if scheduler.get_job('scheduled_task_monitor_on_daily'): scheduler.remove_job('scheduled_task_monitor_on_daily')
            if scheduler.get_job('scheduled_task_monitor_off_daily'): scheduler.remove_job('scheduled_task_monitor_off_daily')
            app.logger.info("기존 스케줄러 작업들 (ID 기준) 제거 시도됨 (디버그 모드).")

        # ▼▼▼ 여기가 실제 작업 실행 시간 설정 부분입니다 ▼▼▼
        # 매일 아침 6시에 모니터 켜기 작업 스케줄링
        scheduler.add_job(id='scheduled_task_monitor_on_daily', 
                          func=scheduler_tasks.scheduled_task_monitor_on, # 실행할 함수
                          trigger='cron', 
                          hour=6,       # 실행 시간: 6시
                          minute=0,     # 실행 시간: 0분
                          misfire_grace_time=3600) # 1시간(3600초) 내에는 지연 실행 허용
        app.logger.info("스케줄 작업 '모니터 켜기' 매일 06:00 등록됨.")

        # 매일 아침 7시에 모니터 끄기 작업 스케줄링
        scheduler.add_job(id='scheduled_task_monitor_off_daily', 
                          func=scheduler_tasks.scheduled_task_monitor_off, # 실행할 함수
                          trigger='cron', 
                          hour=7,       # 실행 시간: 7시
                          minute=0,     # 실행 시간: 0분
                          misfire_grace_time=3600)
        app.logger.info("스케줄 작업 '모니터 끄기' 매일 07:00 등록됨.")
        # ▲▲▲ 여기가 실제 작업 실행 시간 설정 부분입니다 ▲▲▲
        
        try:
            scheduler.start() # 스케줄러 시작
            app.logger.info("APScheduler 시작됨.")
        except Exception as e:
            app.logger.error(f"APScheduler 시작 실패: {e}", exc_info=True)

    app.logger.info("Flask application (with APScheduler) 생성 및 설정 완료.")
    if app.debug:
        app.logger.debug(f"DB 연결 (pymssql): Server={app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}, DB={app.config.get('DB_DATABASE')}")

    return app
핵심 확인 부분:

app/scheduler_tasks.py 파일 내의 is_operational_day 함수 로직을 보시면, 주말/공휴일/사용자 지정 예외를 어떻게 판단하는지 알 수 있습니다. scheduled_task_monitor_on과 scheduled_task_monitor_off 함수는 이 판단 결과에 따라 _send_display_timeout_to_all_pcs 함수를 호출하여 실제 명령을 전송합니다.
app/__init__.py 파일 내의 scheduler.add_job(...) 부분을 보시면, trigger='cron'과 함께 hour=6, minute=0 (모니터 켜기 설정) 및 hour=7, minute=0 (모니터 끄기 설정)으로 실행 시간이 설정되어 있는 것을 확인할 수 있습니다.