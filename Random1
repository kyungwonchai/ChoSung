문서 목적: 이 문서는 AI 기반 코드 처리 엔진(이하 'AI')에게 C# 프로젝트의 전면적인 리팩토링 및 안정화 작업을 지시하기 위한 공식 명령 명세서입니다. AI는 이 문서에 기술된 절차, 규칙, 철학을 단 하나의 예외 없이 준수해야 합니다.

작업 핵심 철학: "선(先) 전면 개선, 후(後) 안정화". 코드의 품질을 산발적으로 개선하는 것이 아니라, 전문가가 프로젝트 전체를 한 번에 재설계하듯, 가능한 모든 개선 사항을 코드베이스 전체에 먼저 적용합니다. 그 후, 오직 그 결과물이 완벽하게 컴파일되도록 만드는 '안정화' 단계에 집중합니다.

Phase 0: 사전 준비 및 환경 설정 (Pre-computation & Environment Setup)
이유: 본격적인 코드 수정에 앞서, 작업의 안정성을 보장하고 필요한 모든 정보를 사전에 확보하기 위함입니다.

0.1: 작업 대상 식별 (Identifying the Target)

명령: 현재 AI의 작업 세션 또는 활성 환경에 로드된 Visual Studio 솔루션(.sln)을 이번 작업의 유일한 대상으로 확정하십시오.
세부 설명: 사용자가 별도의 경로를 지정하지 않았으므로, 현재 컨텍스트에 존재하는 프로젝트가 무엇인지 스스로 인지해야 합니다.
0.2: 메타데이터 추출 및 저장 (Extracting and Storing Metadata)

명령: 대상 솔루션으로부터 다음의 핵심 데이터들을 추출하여 내부 변수에 저장하고, 작업이 끝날 때까지 이 데이터를 일관되게 사용하십시오.
SolutionName: 솔루션 파일의 이름 (예: MyProject.sln)
SolutionRootPath: 솔루션 파일이 위치한 최상위 디렉토리의 절대 경로
DotNetVersion: 프로젝트 파일들(.csproj)을 분석하여 확인한 원본 .NET Framework 버전
BuildConfig: 솔루션에 정의된 기본 빌드 구성 (예: Debug|Any CPU)
이유: 이 변수들은 이후 빌드 커맨드 구성, 로그 파일 경로 지정 등 모든 과정에서 동적으로 사용되므로, 작업의 정확성과 일관성을 보장하는 필수 요소입니다.
0.3: 백업 건너뛰기 확인 (Confirmation of Backup Skip)

경고: 사용자의 명시적인 지시에 따라, 원본 소스 코드 백업 단계를 건너뜁니다. 이 작업은 안전망 없이 원본 코드를 직접 수정하므로, 모든 변경 사항은 되돌릴 수 없습니다. 각별한 주의가 필요합니다.
Phase 1: 전역 코드 리팩토링 (Global Code Refactoring)
이유: 이 단계의 목표는 코드베이스를 '최상의 상태'로 한 번에 변환하는 것입니다. 개별적인 수정이 아닌, 전체적인 관점에서 코드의 구조와 품질을 재설계합니다.

1.1: 작업 철학의 이해 (Understanding the Operational Philosophy)

설명: 이 단계는 여러 번 반복되는 루프가 아닙니다. 단 한 번의 원자적(Atomic)인 작업으로, 프로젝트 전체를 분석하고 가능한 모든 개선점을 적용하는 과정입니다.
1.2: 종합 분석 지시 (Comprehensive Analysis Command)

명령: 솔루션에 포함된 모든 C# 소스 코드 파일(.cs)에 대해 심층 분석을 시작하십시오. 각 파일의 추상 구문 트리(AST)와 프로젝트 전체의 의미론적 모델(Semantic Model)을 구축하여, 코드 간의 모든 상호 의존성을 파악해야 합니다.
이유: 단편적인 분석은 클래스나 파일 간의 연관 관계를 놓쳐 더 큰 문제를 유발할 수 있습니다. 전역적인 시야는 지능적이고 안전한 대규모 리팩토링의 전제 조건입니다.
1.3: 다중 개선 항목 동시 적용 (Simultaneous Application of Multiple Improvement Categories)

명령: 1.2에서 구축한 전역 모델을 바탕으로, 아래 체크리스트의 모든 항목에 해당하는 개선 사항을 코드베이스 전체에 걸쳐 적용하십시오. 이는 당신의 지능을 통해 '알아서' 최적의 코드로 수정하는 과정입니다.
[리팩토링 체크리스트]
안정성 확보 (Ensuring Stability): IDisposable 객체의 미해제, GDI 핸들 누수 등 잠재적인 모든 리소스 누수 지점을 찾아 using 구문 등으로 감싸거나 명시적으로 해제하도록 수정하십시오.
이유: 애플리케이션의 비정상 종료를 유발하는 가장 치명적인 버그 유형이기 때문입니다.
구조적 개선 (Structural Improvement): 과도하게 비대한 클래스나 메서드를 단일 책임 원칙에 입각하여 더 작고 논리적인 단위로 분할하십시오.
이유: 코드의 가독성, 유지보수성, 테스트 용이성을 극적으로 향상시키기 위함입니다.
설계 품질 향상 (Enhancing Design Quality): 전역적으로 사용되는 자원 관리 클래스에 싱글톤 패턴을 적용하거나, 객체 생성이 복잡한 부분에 팩토리 패턴을 도입하는 등, SOLID 원칙과 디자인 패턴을 코드의 맥락에 맞게 적용하십시오.
이유: 코드의 복잡도를 낮추고 재사용성을 높여 장기적인 프로젝트 관리 비용을 절감하기 위함입니다.
코드 현대화 (Code Modernization): 낡은 구문이나 비동기 처리 방식 등을 최신 C# 문법과 async/await 패턴으로 개선하십시오.
이유: 코드의 성능을 개선하고 현재의 개발 표준에 맞추기 위함입니다.
Phase 2: 빌드 안정화 루프 (Build Stabilization Loop)
이유: 1단계의 대규모 변경으로 인해 발생했을 가능성이 높은 수많은 컴파일 오류를 체계적으로 해결하기 위함입니다. 이 단계의 유일한 목표는 '컴파일 성공'이며, 어떠한 추가적인 리팩토링도 허용되지 않습니다.

2.1: 루프의 목적 명확화 (Clarifying the Purpose of the Loop)

설명: 당신은 이제부터 '리팩터'가 아닌 '버그 픽서'의 역할을 수행합니다. 당신의 임무는 1단계의 결과물을 빌드 가능한 상태로 만드는 것이며, 코드의 의미나 구조를 바꾸려 해서는 안 됩니다.
2.2: 실행 프로토콜 (Execution Protocol)

명령: 최대 50회 또는 빌드가 성공할 때까지 아래의 'A-B-C' 단계를 반복하십시오.

A. 빌드 시도 및 로그 생성:

필수 행동: SolutionName과 BuildConfig 변수를 사용하여 MSBuild 커맨드를 실행합니다. 이때, 모든 표준 출력(stdout)과 표준 에러(stderr)를 1.log라는 파일에 덮어쓰기 형태로 리디렉션해야 합니다.
정확한 커맨드 예시: msbuild MyProject.sln /p:Configuration=Debug /p:Platform="Any CPU" /nologo > 1.log 2>&1
이유: 1.log 파일은 빌드 결과에 대한 유일하고 완전한 '진실의 원천(Source of Truth)'입니다.
B. 결과 분석:

명령: 1.log 파일의 전체 내용을 읽어들인 후, "Build Succeeded" 또는 이에 준하는 성공 메시지가 있는지 확인합니다. 없다면, "Error" 또는 "오류" 문자열이 있는지 확인합니다.
C. 오류 수정 (빌드 실패 시):

명령 1 (최우선 순위 오류 처리): 에러 로그를 분석하여, 원인이 smdDBConntction 관련 참조 누락인지 가장 먼저 확인하십시오. 만약 그렇다면, 다른 모든 오류에 앞서 D:\sDatabaseServer.dll 파일을 프로젝트에 참조 추가하는 조치를 수행한 뒤, 즉시 A단계로 돌아갑니다.
이유: 이는 코드 자체의 문제가 아닌, 외부 환경 의존성 문제일 가능성이 높으므로 가장 먼저 해결해야 다른 코드 오류를 정확히 진단할 수 있습니다.
명령 2 (일반 오류 처리): 위 경우가 아니라면, 로그에 기록된 가장 첫 번째 에러에만 집중하십시오. 해당 에러의 파일 위치, 라인 번호, 에러 메시지를 정확히 파싱한 후, 그 문제를 해결하기 위한 가장 국소적이고 최소한의 코드 수정(예: 누락된 세미콜론 추가, 타입 캐스팅, using 지시문 추가 등)만을 적용하십시오.
이유: 한 번에 여러 오류를 수정하려는 시도는 예측 불가능한 새로운 오류를 낳을 수 있습니다. 순차적인 단일 오류 해결이 가장 안정적인 접근법입니다.
명령 3 (루프 계속): 수정 조치를 적용한 후, 즉시 A단계로 돌아가 빌드를 다시 시도합니다.
Phase 3: 최종 보고 및 완료 (Final Reporting & Completion)
이유: 자동화된 모든 과정의 결과를 사용자가 명확히 확인하고 추적할 수 있도록, 영구적인 기록을 남기기 위함입니다.

3.1: 보고서 생성: D:\refactoringhistory\{SolutionFolderName} 디렉토리를 확인 및 생성하고, 그 안에 {SolutionName}_{yyyyMMddHHmmss}.txt 이름의 최종 보고 파일을 생성하십시오.
3.2: 보고서 내용 명세: 생성된 파일에 다음 내용을 상세히 기록하십시오.
작업 요약: "전역 리팩토링 후 빌드 안정화 작업 완료. 총 빌드 시도 횟수: [실제 시도 횟수]회."
주요 변경 사항: 1단계의 전면 리팩토링으로 인해 발생한 핵심적인 구조 변경(예: "5개의 거대 클래스가 23개의 작은 클래스로 분리됨", "프로젝트 전반에 걸쳐 157개의 리소스 누수 의심 코드 수정 완료")을 요약하여 보고하십시오.
전역 불변 규칙 (Global Immutable Rules)
경고: 아래 규칙들은 이 명세서의 다른 어떤 지시보다도 우선하며, 모든 단계에서 항상 유효합니다.

실행 절대 금지: 컴파일된 .exe 파일은 어떤 이유로도 실행되어서는 안 됩니다.
password 문자열 취급: 이 단어는 일반 텍스트로 간주하며, 수정 대상에서 제외하지 않습니다.
실제 자격 증명 보호: 명백한 데이터베이스 연결 문자열 등은 절대 수정해서는 안 됩니다.