엔트리를 감지하고, 현재 **작업 큐(TaskQueue)**가 실행 중일 때 작업을 추가하거나 스타트하려는 흐름을 관리하려면, _taskQueue.IsRunning 상태를 잘 활용해야 합니다.

이를 위해서는 TaskQueue 클래스에 IsRunning 플래그를 추가하여 작업이 실행 중인지 아닌지를 확인할 수 있도록 하고, 작업이 실행 중일 때 새로운 작업을 추가하거나, 대기 중이라면 바로 시작할 수 있게 처리해야 합니다.

해결책:
**TaskQueue**에 IsRunning 속성을 추가하여 작업 상태를 확인.
**OnLogEntryDetected**에서 새로운 작업이 감지되면, 작업이 진행 중인 경우에는 작업을 큐에 넣고, 작업이 실행 중이지 않은 경우에는 작업을 즉시 실행.
1. TaskQueue 수정 (IsRunning 플래그 추가)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하는 역할을 담당합니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;

    // IsRunning 속성: 현재 작업이 실행 중인지 여부를 반환
    public bool IsRunning => _isRunning;

    /// <summary>
    /// 작업을 큐에 추가하고 순차적으로 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);

        // 현재 작업이 실행 중이 아니면, 작업 실행 시작
        if (!_isRunning)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 큐의 다음 작업을 실행하는 메서드
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0)
        {
            _isRunning = false;
            return;
        }

        _isRunning = true; // 작업이 실행 중
        var task = _tasks.Dequeue(); // 큐에서 작업을 가져와 실행
        await task(); // 작업 실행

        _isRunning = false; // 작업 완료
        if (_tasks.Count > 0)
        {
            RunNextTask(); // 다음 작업 실행
        }
    }

    /// <summary>
    /// 현재 작업 큐를 비웁니다. (모든 작업을 삭제)
    /// </summary>
    public void ClearQueue()
    {
        _tasks.Clear();
    }
}
설명:
IsRunning 속성을 통해 현재 작업이 진행 중인지 아닌지 확인할 수 있습니다.
RunNextTask가 완료되면 **_isRunning**이 false로 설정되어 작업이 완료된 상태임을 나타냅니다.
2. MainViewModel에서 OnLogEntryDetected 로직 추가
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;

public class MainViewModel : ViewModelBase
{
    // 작업 목록 (TaskModel 리스트)
    public ObservableCollection<TaskModel> TaskList { get; set; }

    private TaskQueue _taskQueue;

    public MainViewModel()
    {
        _taskQueue = new TaskQueue();  // TaskQueue 인스턴스 생성

        // 작업 목록 초기화
        TaskList = new ObservableCollection<TaskModel>();
    }

    /// <summary>
    /// 새로운 로그 엔트리가 감지되었을 때 호출되는 함수
    /// </summary>
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        // 새로운 TaskModel 생성
        var task = new TaskModel(logEntry, _taskQueue);
        TaskList.Add(task);  // 작업 목록에 추가

        // 작업이 실행 중이면 작업을 큐에 추가만 함
        if (_taskQueue.IsRunning)
        {
            // 이미 다른 작업이 실행 중이면 큐에만 추가
            task.ResumeTask(); // 대기열에 추가
        }
        else
        {
            // 실행 중이지 않으면 즉시 실행
            task.ResumeTask(); // 바로 실행
        }
    }
}
설명:
OnLogEntryDetected 함수는 로그 엔트리를 감지할 때 호출되며, TaskModel을 생성하고, 이를 **작업 목록(TaskList)**에 추가합니다.
작업 큐가 이미 실행 중인 경우, 새로운 작업은 큐에 추가됩니다.
작업 큐가 비어있다면, 즉시 해당 작업을 실행합니다.
3. TaskModel (변경 없음, 기존대로 사용)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;
using System.Windows;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스 플래그에 따라 함수들을 순차적으로 실행합니다.
/// 작업이 완료되면 자동으로 다음 작업을 실행합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    // 로그 엔트리 정보
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 비동기 함수 리스트
    public List<Func<Task>> FunctionTasks { get; set; }

    // 각 함수 상태를 도형으로 표현 (도형 상태)
    public ObservableCollection<Brush> FunctionStatusColors { get; set; }

    // 현재 작업이 대기, 실행, 완료 상태인지 나타냄
    public string Status { get; set; }

    // Resume 명령어 (행마다 존재)
    public ICommand ResumeCommand { get; }

    // 작업 큐와 연결
    private TaskQueue _taskQueue;

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;

        _taskQueue = taskQueue;  // TaskQueue를 받아옴

        // 비동기 함수 리스트 초기화 및 함수 추가
        FunctionTasks = new List<Func<Task>>
        {
            ExecuteTaskA,
            ExecuteTaskB,
            ExecuteTaskC
        };

        // FunctionStatusColors 리스트 초기화 (각 함수의 상태를 색상으로 표현)
        FunctionStatusColors = new ObservableCollection<Brush>
        {
            Brushes.Gray,  // Task A 초기 상태
            Brushes.Gray,  // Task B 초기 상태
            Brushes.Gray   // Task C 초기 상태
        };

        // 상태 초기화
        Status = "Pending";

        // Resume 버튼 명령어 설정
        ResumeCommand = new RelayCommand(ResumeTask);
    }

    /// <summary>
    /// 특정 행부터 작업을 재개하는 함수 (Resume 버튼 클릭 시 호출)
    /// </summary>
    public async void ResumeTask()
    {
        Status = "Running";  // 상태를 Running으로 변경
        _taskQueue.EnqueueTask(async () => await ExecuteTaskSequence());  // 작업을 큐에 등록
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행 (스킵 없이 모든 작업 재실행)
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        for (int i = 0; i < FunctionTasks.Count; i++)
        {
            // 도형 색상을 다시 회색으로 변경 (재실행이므로 초기화)
            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[i] = Brushes.Gray;
            });

            await FunctionTasks[i]();  // 비동기 작업 실행

            // 함수 실행 후 색상 변경
            Application.Current.Dispatcher.Invoke(() =>
            {
                FunctionStatusColors[i] = Brushes.Green;
            });
        }
        Status = "Completed";  // 완료 상태로 변경
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}
요약:
**TaskQueue**는 IsRunning 속성을 추가하여 현재 작업 실행 상태를 관리합니다.
**MainViewModel**의 **OnLogEntryDetected**에서 작업 실행 중인지 확인하고, 대기열에 추가하거나 바로 실행합니다.
**TaskModel**은 그대로 사용하여, 로그 엔트리가 감지되었을 때 작업을 실행하는 로직을 유지합니다.
이 코드 구조에서는 작업이 실행 중일 때 