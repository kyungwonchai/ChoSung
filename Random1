아래는 RouterMiddleACR 프로젝트의 기존 기능을 유지하면서, 코드를 최적화하고, 서비스 구동 및 소켓 통신을 제거하여 단일 애플리케이션으로 통합한 예제입니다. 모든 코드를 하나의 MainWindow.xaml과 MainWindow.xaml.cs 파일로 통합하였으며, 함수형 패턴을 최대한 활용하여 가독성을 높였습니다.

MainWindow.xaml
이 파일은 사용자 인터페이스(UI)를 정의합니다. 여기에는 로그를 표시하는 ListBox와 여러 버튼이 포함되어 있습니다.

xml
코드 복사
<Window x:Class="RouterMiddleACR.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="RouterMiddleACR" Height="450" Width="800"
        Closing="Window_Closing">
    <Grid>
        <!-- 로그를 출력하는 ListBox -->
        <ListBox x:Name="LogListBox" HorizontalAlignment="Stretch" VerticalAlignment="Top" Height="300" Margin="10"/>

        <!-- 버튼과 텍스트박스를 배치하기 위한 StackPanel -->
        <StackPanel Orientation="Horizontal" HorizontalAlignment="Center" VerticalAlignment="Bottom" Margin="10">
            <!-- 임의의 테스트 버튼 예시 -->
            <Button Content="Start Test" Width="100" Height="30" Margin="5" Click="StartTest_Click"/>
            <Button Content="Stop Test" Width="100" Height="30" Margin="5" Click="StopTest_Click"/>
            <!-- PLC 데이터를 전송하는 버튼 예시 -->
            <Button Content="Send PLC Data" Width="100" Height="30" Margin="5" Click="SendPLCData_Click"/>
            <!-- 텍스트 박스 예시 -->
            <TextBox x:Name="InputTextBox" Width="200" Height="30" Margin="5"/>
        </StackPanel>
    </Grid>
</Window>
MainWindow.xaml.cs
이 파일은 애플리케이션의 모든 로직을 포함합니다. 모든 기능이 하나의 클래스에 통합되어 있어, 코드의 가독성을 높이고 관리하기 쉽게 하였습니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private SerialPort _serialPort; // 시리얼 포트 객체
        private Dictionary<string, int> _memory; // PLC의 메모리 시뮬레이션
        private Dictionary<string, string> _stringMemory; // 문자열을 저장하는 메모리 시뮬레이션

        public MainWindow()
        {
            InitializeComponent();

            // PLC 메모리 초기화
            _memory = new Dictionary<string, int>
            {
                { "D2300", 0 },
                { "D2330", 0 },
                { "R520", 0 },
                { "R521", 0 }
            };

            // 문자열 메모리 초기화
            _stringMemory = new Dictionary<string, string>
            {
                { "D2310", string.Empty }
            };

            // 시리얼 포트 초기화
            InitializeSerialPort("COM3"); // COM3 포트를 사용 예시
        }

        // 시리얼 포트를 초기화하는 메서드
        private void InitializeSerialPort(string portName)
        {
            _serialPort = new SerialPort(portName, 9600, Parity.None, 8, StopBits.One);
            _serialPort.DataReceived += SerialPort_DataReceived; // 데이터 수신 이벤트 핸들러 등록
            _serialPort.Open(); // 시리얼 포트 열기
        }

        // 시리얼 포트로 수신된 데이터를 처리하는 메서드
        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            string data = _serialPort.ReadExisting(); // 수신된 데이터를 ASCII로 읽기
            ProcessReceivedData(data);
        }

        // 수신된 데이터를 처리하는 메서드
        private void ProcessReceivedData(string data)
        {
            LogMessage($"Received: {data}");

            // ASCII 형식의 명령 처리 로직
            if (data.Contains("WDD"))
            {
                if (data.Contains("D2300"))
                {
                    var value = ExtractValueFromCommand(data);
                    WriteDataToPLC("D2300", value);
                    WriteDataToPLC("D2330", value);
                }
            }

            if (data.Contains("WDS"))
            {
                if (data.Contains("D2310"))
                {
                    var value = ExtractStringFromCommand(data);
                    WriteStringToPLC("D2310", value);
                }
            }
        }

        // PLC 메모리에 데이터를 쓰는 메서드
        private void WriteDataToPLC(string address, int value)
        {
            if (_memory.ContainsKey(address))
            {
                _memory[address] = value;
                LogMessage($"Data written to {address}: {value}");
            }
        }

        // PLC 메모리에 문자열 데이터를 쓰는 메서드
        private void WriteStringToPLC(string address, string value)
        {
            if (_stringMemory.ContainsKey(address))
            {
                _stringMemory[address] = value.Length > 20 ? value.Substring(0, 20) : value;
                LogMessage($"String written to {address}: {_stringMemory[address]}");
            }
        }

        // PLC 메모리 값을 주기적으로 체크하는 메서드
        private async void StartCheckingMemory()
        {
            while (true)
            {
                if (_memory.ContainsKey("D2330"))
                {
                    int currentValue = _memory["D2330"];

                    if (currentValue != 0)
                    {
                        LogMessage($"Checking D2330, value: {currentValue}");
                        WriteDataToPLC("D2330", 0);
                    }
                }

                await Task.Delay(1000); // 1초마다 체크
            }
        }

        // 명령에서 값을 추출하는 메서드
        private int ExtractValueFromCommand(string command)
        {
            string valueString = command.Substring(command.Length - 4);
            return int.TryParse(valueString, out int value) ? value : 0;
        }

        // 명령에서 문자열을 추출하는 메서드
        private string ExtractStringFromCommand(string command)
        {
            string valueString = command.Substring(8); // 시작 위치 조정 필요
            return valueString;
        }

        // 로그 메시지를 UI에 출력하는 메서드
        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() =>
            {
                LogListBox.Items.Add(message); // ListBox에 로그 메시지 추가
                LogListBox.ScrollIntoView(LogListBox.Items[LogListBox.Items.Count - 1]); // 항상 마지막 항목으로 스크롤
            });
        }

        // "Start Test" 버튼 클릭 이벤트 핸들러
        private void StartTest_Click(object sender, RoutedEventArgs e)
        {
            LogMessage("테스트 시작");
        }

        // "Stop Test" 버튼 클릭 이벤트 핸들러
        private void StopTest_Click(object sender, RoutedEventArgs e)
        {
            LogMessage("테스트 중지");
        }

        // "Send PLC Data" 버튼 클릭 이벤트 핸들러
        private void SendPLCData_Click(object sender, RoutedEventArgs e)
        {
            string dataToSend = InputTextBox.Text;
            _serialPort.WriteLine(dataToSend); // 입력된 데이터를 시리얼 포트를 통해 전송
            LogMessage($"Sent data: {dataToSend}");
        }

        // 윈도우 닫기 시 포트 닫기
        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _serialPort.Close(); // 시리얼 포트 닫기
        }
    }
}
주요 변경 사항과 설명
파일 구조 단순화:

모든 기능을 MainWindow.xaml.cs 파일 하나에 통합하였습니다. 서비스로 구동하는 부분과 소켓 통신은 제거했습니다.
PLC 메모리 및 문자열 처리:

PLC 메모리를 시뮬레이션하기 위해 딕셔너리를 사용하였으며, 문자열 데이터를 처리할 수 있도록 추가했습니다.
시리얼 포트 통신:

시리얼 포트를 통해 PLC와 통신하며, 데이터를 수신하고 처리합니다.
로그 메시지 출력:

LogMessage 메서드를 사용하여 모든 로그 메시지를 UI의 ListBox에 출력합니다.
명령 처리 로직:

ProcessReceivedData 메서드를 통해 ASCII 형식의 명령을 처리하고, 메모리에 데이터를 쓰거나 문자열을 저장합니다.
이 코드 구조는 프로젝트의 복잡성을 줄이고, 필수 기능을 하나의 파일에 집중시켜 관리하기 쉽게 만들었습니다. 이를 통해 유지보수와 확장이 더 쉬워졌습니