네, 10개의 공유 폴더 정보(IP, 계정, 경로 등)가 모두 다른 상황에서 가장 효율적이고 안전한 방법을 알려드릴게요.

결론부터 말하자면, 10개를 전부 /mnt에 항상 마운트해두는 것보다, 필요할 때마다 스크립트로 자동 마운트 -> 작업 -> 마운트 해제하는 방식이 훨씬 효율적이고 안정적입니다.

전부 마운트해두면 관리가 번거롭고, 부팅 시 특정 서버에 문제가 생기면 시스템 전체가 느려질 수 있습니다.

## 🚀 가장 효율적인 방법: 설정 파일 + 자동화 스크립트
이 방식은 각 공유 폴더의 정보를 별도의 설정 파일에 정리해두고, 하나의 스크립트가 이 파일을 읽어 모든 작업을 자동으로 처리하게 만드는 것입니다. 관리가 매우 쉬워지고 나중에 공유 폴더가 추가/변경되어도 스크립트를 수정할 필요가 없습니다.

### 1단계: 자격 증명 파일 만들기 (보안 강화)
먼저, 각 공유 폴더의 아이디와 비밀번호를 안전하게 보관할 파일을 만듭니다. 이렇게 하면 스크립트에 비밀번호가 직접 노출되지 않습니다. 각 계정마다 하나씩 만듭니다.

vim ~/.smb-credentials-server1 명령어로 파일을 열고 아래 내용을 입력합니다.

Ini, TOML

username=사용자명
password=비밀번호
파일 권한을 변경하여 소유자만 읽고 쓸 수 있게 합니다. (필수!)

Bash

chmod 600 ~/.smb-credentials-server1
10개의 계정이 모두 다르다면 ~/.smb-credentials-server2, ~/.smb-credentials-server3 ... 와 같이 여러 개를 만듭니다.

### 2단계: 설정 파일 만들기
이제 10개 공유 폴더의 모든 정보를 담은 설정 파일을 하나 만듭니다. 스크립트가 이 파일을 읽어서 작업하게 됩니다. 파일 이름은 servers.conf로 하겠습니다.

vim ~/servers.conf 명령어로 파일을 열고 한 줄에 하나의 서버 정보를 아래 형식으로 입력합니다. (띄어쓰기 대신 ; 문자로 구분하면 좋습니다.)

# IP주소;공유폴더이름;자격증명파일경로;가져올폴더경로;저장할로컬폴더
192.168.1.10;Data;~/.smb-credentials-server1;/path/on/server;/home/user/dest1
192.168.1.20;Backup;~/.smb-credentials-server2;/another/path;/home/user/dest2
192.168.1.30;Share;~/.smb-credentials-server3;/source/files;/home/user/dest3
... (나머지 7개 서버 정보 추가) ...
### 3단계: 자동화 셸 스크립트 작성
이제 위 설정 파일을 읽어서 모든 작업을 처리하는 똑똑한 스크립트를 만듭니다.

vim ~/copy_latest.sh 명령어로 스크립트 파일을 엽니다.

아래 코드를 복사하여 붙여넣으세요.

Bash

#!/bin/bash

# 2단계에서 만든 설정 파일 경로
CONFIG_FILE="$HOME/servers.conf"

# 설정 파일이 없으면 종료
if [ ! -f "$CONFIG_FILE" ]; then
    echo "설정 파일($CONFIG_FILE)을 찾을 수 없습니다."
    exit 1
fi

# 설정 파일을 한 줄씩 읽어서 반복 처리
while IFS=';' read -r SERVER_IP SHARE_NAME CRED_FILE SRC_DIR DEST_DIR || [[ -n "$line" ]]; do
    # 주석(#)으로 시작하는 줄은 건너뛰기
    [[ "$SERVER_IP" =~ ^#.* ]] && continue

    # 임시 마운트 포인트 생성 (프로세스 ID를 붙여서 중복 방지)
    TEMP_MOUNT_POINT="/mnt/smb_temp_$$"
    mkdir -p "$TEMP_MOUNT_POINT"

    echo "--- [${SERVER_IP}] 작업 시작 ---"

    # 공유 폴더 마운트
    sudo mount -t cifs "//$SERVER_IP/$SHARE_NAME" "$TEMP_MOUNT_POINT" -o credentials="$CRED_FILE",iocharset=utf8

    # 마운트 성공 여부 확인
    if [ $? -eq 0 ]; then
        echo "-> 마운트 성공: $TEMP_MOUNT_POINT"

        # 원본 경로 (마운트 포인트 + 가져올 폴더 경로)
        FULL_SRC_PATH="$TEMP_MOUNT_POINT/$SRC_DIR"

        # 원본 경로에서 최신 파일 찾기
        # find: 파일을 찾고, -printf: 수정시간(유닉스타임)과 파일명을 출력, sort: 시간으로 역순 정렬, head: 첫번째 줄 선택, cut: 파일명만 잘라내기
        LATEST_FILE=$(find "$FULL_SRC_PATH" -maxdepth 1 -type f -printf '%T@ %p\n' | sort -nr | head -n 1 | cut -d' ' -f2-)

        if [ -n "$LATEST_FILE" ]; then
            echo "-> 최신 파일 찾음: $LATEST_FILE"
            # 최신 파일을 목적지 폴더로 복사
            cp -v "$LATEST_FILE" "$DEST_DIR"
        else
            echo "-> 경고: 복사할 파일을 찾지 못했습니다."
        fi

        # 작업 완료 후 마운트 해제
        sudo umount "$TEMP_MOUNT_POINT"
        echo "-> 마운트 해제 완료"
    else
        echo "-> 에러: 마운트에 실패했습니다. IP나 자격 증명을 확인하세요."
    fi

    # 임시 마운트 포인트 폴더 삭제
    rmdir "$TEMP_MOUNT_POINT"
    echo "--------------------------"
    echo ""

done < "$CONFIG_FILE"

echo "모든 작업이 완료되었습니다."
### 4. 스크립트 실행
스크립트에 실행 권한 부여:

Bash

chmod +x ~/copy_latest.sh
스크립트 실행:

Bash
