네, 요청하신 내용을 바탕으로 MainViewModel과 LogService를 최적화하고 ComPortManager를 효과적으로 활용하는 방안을 정리하겠습니다.

목표
MainViewModel: PLC로 데이터를 전송하는 기능을 추가하며, 버튼을 통해 명령을 전달할 수 있도록 합니다.
LogService: 기존 TCP 서버 및 클라이언트 기능을 유지하면서, PLC와의 통신 기능을 ComPortManager를 활용하여 분리합니다.
ComPortManager: PLC 통신 관련 기능을 전담하여, 메인 서비스가 독립적으로 관리할 수 있도록 합니다.
설계 개요
MainViewModel:

버튼 명령을 통해 서비스에 데이터를 전송하는 기능을 추가합니다.
소켓을 통해 서비스를 호출하여 데이터를 전송하도록 합니다.
LogService:

ComPortManager를 활용하여 PLC와의 시리얼 통신을 담당합니다.
소켓 통신을 통해 UI에서 받은 명령을 PLC로 전달합니다.
ComPortManager:

PLC와의 시리얼 통신을 처리하고, 필요한 경우 데이터를 전송합니다.
최적화된 코드 구현
1. MainViewModel.cs 수정
MainViewModel에 새로운 명령을 추가하여, UI에서 입력된 데이터를 서비스에 전송하는 기능을 구현합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Net.Sockets;
using System.Text;
using System.Windows.Input;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        // PLC에 전송할 데이터의 매핑
        public ObservableCollection<ButtonMapping> ButtonMappings { get; } = new ObservableCollection<ButtonMapping>
        {
            new ButtonMapping { Number = 0, DisplayName = "Zero" },
            new ButtonMapping { Number = 1, DisplayName = "One" },
            new ButtonMapping { Number = 2, DisplayName = "Two" },
            new ButtonMapping { Number = 3, DisplayName = "Three" },
            new ButtonMapping { Number = 4, DisplayName = "Four" }
        };

        private TcpClient _tcpClient;
        private NetworkStream _networkStream;

        public ICommand SendToPLCCommand { get; }

        public MainViewModel()
        {
            SendToPLCCommand = new RelayCommand<int>(SendToPLC);
            ConnectToService();
        }

        private void ConnectToService()
        {
            try
            {
                _tcpClient = new TcpClient("127.0.0.1", 9000);
                _networkStream = _tcpClient.GetStream();
            }
            catch (Exception ex)
            {
                // 에러 처리 로직
            }
        }

        private async void SendToPLC(int number)
        {
            if (_networkStream != null)
            {
                string message = $"%01#WDD0230002300{number:D2}00**\r"; // Mewtocol 메시지 형식
                byte[] data = Encoding.ASCII.GetBytes(message);
                await _networkStream.WriteAsync(data, 0, data.Length);
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ButtonMapping
    {
        public int Number { get; set; }
        public string DisplayName { get; set; }
    }
}
2. LogService.cs 수정
LogService에서 PLC 통신을 ComPortManager로 위임하고, 서버와 클라이언트 기능을 유지합니다.

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        private static LogService _instance;
        private readonly string _logDirectory;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private TcpListener _tcpListener;
        private string _serverIp = "127.0.0.1"; // 메인 UI 서버 IP
        private int _serverPort = 9000; // 메인 UI 서버 포트
        private CancellationTokenSource _cancellationTokenSource;
        private bool _isConnected = false;
        private Queue<string> _logQueue = new Queue<string>(); // 로그 메시지 큐
        private ComPortManager _comPortManager; // ComPortManager 인스턴스

        // 싱글톤 패턴을 위한 인스턴스 접근자
        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        // 생성자
        private LogService()
        {
            // 로그 파일이 저장될 디렉터리 설정
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory);

            // ComPortManager 인스턴스 초기화
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1"); // 기본 포트 설정
        }

        // 서비스 시작 메서드
        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ConnectToMainUIServer(_cancellationTokenSource.Token)); // 메인 UI 서버 연결을 시작
            Task.Run(() => StartTcpListener(_cancellationTokenSource.Token)); // TCP 서버 시작
        }

        // 서비스 중지 메서드
        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _networkStream?.Close();
            _tcpClient?.Close();
            _tcpListener?.Stop();
        }

        // 메인 UI 서버에 연결하는 메서드
        private async Task ConnectToMainUIServer(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                if (!_isConnected)
                {
                    try
                    {
                        _tcpClient = new TcpClient();
                        await _tcpClient.ConnectAsync(_serverIp, _serverPort); // 서버에 연결
                        _networkStream = _tcpClient.GetStream();
                        _isConnected = true;
                        Console.WriteLine("Connected to main UI server.");
                        
                        // 재연결 후 로그 큐에 저장된 메시지 전송
                        await SendQueuedLogs();
                    }
                    catch (Exception ex)
                    {
                        Console.WriteLine($"Error connecting to server: {ex.Message}");
                        _isConnected = false;
                        await Task.Delay(5000); // 5초 후 재연결 시도
                    }
                }
                else
                {
                    await Task.Delay(1000); // 연결이 되어 있을 때 1초마다 상태 체크
                }
            }
        }

        // TCP 서버를 시작하는 메서드
        private async Task StartTcpListener(CancellationToken cancellationToken)
        {
            _tcpListener = new TcpListener(IPAddress.Any, 9000); // 모든 IP 주소에서 포트 9000으로 대기
            _tcpListener.Start();
            Console.WriteLine("TCP server started, listening for connections...");

            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    TcpClient client = await _tcpListener.AcceptTcpClientAsync();
                    Console.WriteLine("Client connected.");
                    _ = Task.Run(() => HandleClient(client, cancellationToken));
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error accepting client: {ex.Message}");
                }
            }

            _tcpListener.Stop();
        }

        // 클라이언트 연결을 처리하는 메서드
        private async Task HandleClient(TcpClient client, CancellationToken cancellationToken)
        {
            using (client)
            using (NetworkStream stream = client.GetStream())
            {
                byte[] buffer = new byte[1024];
                int bytesRead;

                while ((bytesRead = await stream.ReadAsync(buffer, 0, buffer.Length, cancellationToken)) != 0)
                {
                    string message = Encoding.ASCII.GetString(buffer, 0, bytesRead);
                    Console.WriteLine($"Received message: {message}");
                    _comPortManager.SendDataToPLC(message); // ComPortManager를 통해 메시지를 PLC로 전송
                }
            }
        }

        // 로그 메시지를 기록하고 메인 UI 서버로 전송하는 메서드
        public async Task LogMessage(string message)
        {
            try
            {
                string logEntry = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}";
                string logFilePath = Path.Combine(_logDirectory, $"{DateTime.Now:yyyyMMdd}_ServiceLog.txt");

                File.AppendAllText(logFilePath, logEntry + Environment.NewLine);

                if (_isConnected && _tcpClient != null && _tcpClient.Connected)
                {
                    await SendLogMessage(logEntry); // 연결된 경우 바로 전송
                }
                else
                {
                    _logQueue.Enqueue(logEntry); // 연결되지 않은 경우 로그 큐에 저장
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error logging message: {ex.Message}");
            }
        }

        // 메인 UI 서버로 로그 메시지를 전송하는 메서드
        private async Task SendLogMessage(string message)
        {
            try
            {
                // 네트워크 스트림과 TCP 클라이언트가 유효한지 확인
                if (_networkStream != null && _tcpClient != null && _tcpClient.Connected)
                {
                    string messageWithDelimiter = message + "\n";
                    byte[] data = Encoding.UTF8.GetBytes(messageWithDelimiter);
                    await _networkStream.WriteAsync(data, 0, data.Length); // 메시지 전송
                    Console.WriteLine("Log message sent to main UI server.");
                }
                else
                {
                    throw new InvalidOperationException("Network stream or TCP client is not connected.");
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending log message: {ex.Message}");
                _isConnected = false; // 전송 실패 시 연결 끊김으로 처리
            }
        }

        // 큐에 저장된 로그 메시지를 전송하는 메서드
        private async Task SendQueuedLogs()
        {
            while (_logQueue.Count > 0 && _isConnected)
            {
                var logMessage = _logQueue.Dequeue();
                await SendLogMessage(logMessage); // 큐에 저장된 로그 메시지 전송
            }
        }
    }
}
3. ComPortManager.cs 구현
ComPortManager는 PLC와의 통신을 전담하며, LogService에서 호출됩니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class ComPortManager
    {
        private SerialPort _port; // 시리얼 포트 객체
        private string _currentPortName; // 현재 사용 중인 포트 이름

        // 포트를 설정하는 메서드
        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _currentPortName = portName; // 현재 포트 이름 저장

            if (_port != null && _port.IsOpen) // 이미 포트가 열려 있는 경우
            {
                _port.Close(); // 포트 닫기
            }

            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits); // 새 포트 설정
        }

        // 데이터를 비동기적으로 전송하는 메서드
        public async Task<bool> SendDataToPLC(string data)
        {
            try
            {
                if (_port == null || !_port.IsOpen) // 포트가 설정되지 않았거나 열려 있지 않은 경우
                {
                    _port.Open(); // 포트 열기
                }

                _port.WriteLine(data); // 데이터 전송
                await Task.Delay(100); // 통신 대기 시간

                string response = _port.ReadLine(); // 응답 수신
                Console.WriteLine($"전송 데이터: {data}, 응답: {response}"); // 로그 기록

                return response.Contains("OK"); // 응답 확인
            }
            catch (Exception ex)
            {
                Console.WriteLine($"COM 포트 전송 중 오류 발생: {ex.Message}"); // 오류 로그 기록
                return false; // 실패 반환
            }
            finally
            {
                if (_port != null && _port.IsOpen)
                {
                    _port.Close(); // 포트 닫기
                }
            }
        }

        // 포트 설정을 저장하는 메서드
        public void SavePortSettings(string key, string portName)
        {
            // 설정 저장 로직 구현 필요
        }

        // 포트 설정을 불러오는 메서드
        public string LoadPortSettings(string key)
        {
            // 설정 불러오기 로직 구현 필요
            return string.Empty;
        }
    }
}
최적화된 설계 요약
MainViewModel: PLC로 데이터를 전송하는 명령을 정의하고, 소켓을 통해 서비스를 호출합니다.
LogService: 기존 TCP 서버 및 클라이언트 기능을 유지하면서, PLC와의 통신 기능을 ComPortManager로 분리하여 관리합니다.
ComPortManager: PLC와의 시리얼 통신을 전담하여, LogService가 독립적으로 관리할 수 있도록 합니다.
이 구조는 각 기능이 명확히 분리되어 있으며, 유지보수와 확장이 용이한 설계를 제공합