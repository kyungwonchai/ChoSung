래는 보낸값이 20자 이하인 경우 고유값으로 간주하여, 시간의 흐름에서 변경이 발생할 때마다 기록하는 방식으로 수정된 코드입니다. 이 수정된 코드는 DetailCMD 파일의 고유값별 변경된 응답과 다른 파일의 로그를 포함해, 시간 순서대로 정렬된 데이터를 시트2에 저장합니다.

코드는 다음과 같이 구성됩니다:

Sheet1에는 기존과 동일하게 DetailCMD와 다른 파일들의 전체 로그를 시간순으로 정렬하여 저장합니다.
Sheet2에는 DetailCMD의 보낸값이 20자 이하인 경우 최초 응답을 포함해 변경된 응답만 기록하고, 다른 파일의 모든 로그를 함께 시간순으로 정렬하여 기록합니다.
코드
python
코드 복사
import os
import csv
import re
from datetime import datetime, timedelta

# 디렉토리 경로 설정
directory_path = 'c:/prod_file_logs/'
output_directory = 'c:/Agent/'

# 3일 전 날짜 계산
three_days_ago = datetime.now() - timedelta(days=3)

# 정규 표현식 패턴 설정
time_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'  # 날짜와 시간 추출 패턴
key_pattern = r'고유키:[^\s]+'  # 고유키 추출 패턴 (공백 전까지)
send_value_pattern = r'보낸값:[^\s]+'  # 보낸값 추출 패턴 (공백 전까지)
recv_value_pattern = r'받은값:[^\s]+'  # 받은값 추출 패턴 (공백 전까지)

# 데이터 저장 리스트
data_for_csv = []   # Sheet1용 전체 데이터
filtered_data = []  # Sheet2용 필터링된 데이터

# 보낸값이 20자 이하인 경우, 변경된 응답을 기록하기 위해 응답 상태 추적
response_tracker = {}

# 디렉토리 및 하위 폴더 내 모든 파일을 재귀적으로 탐색
for root, dirs, files in os.walk(directory_path):
    for filename in files:
        # 3일 전 이후 생성된 파일만 처리
        file_path = os.path.join(root, filename)
        file_creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
        
        if file_creation_time >= three_days_ago:
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()  # 파일의 모든 줄을 읽음
                i = 0
                
                # DetailCMD 파일 처리
                if 'DetailCMD' in filename:
                    while i < len(lines):
                        # "보낸값" 줄을 찾음
                        send_match = re.search(send_value_pattern, lines[i])
                        
                        if send_match:
                            # "보낸값" 줄에서 시간, 고유키, 보낸값 추출
                            time_match = re.search(time_pattern, lines[i])
                            key_match = re.search(key_pattern, lines[i])
                            
                            if time_match and key_match:
                                # 시간과 고유키 추출
                                time_str = time_match.group()
                                unique_key = key_match.group().split(':')[1]
                                send_value = send_match.group().split(':')[1]

                                # 시간 형식을 "yyMMdd HHmmss"로 변환
                                original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                                formatted_time = original_time.strftime('%y%m%d %H%M%S')

                                # 다음 줄에서 "받은값" 추출
                                if i + 1 < len(lines):
                                    recv_match = re.search(recv_value_pattern, lines[i + 1])

                                if recv_match:
                                    recv_value = recv_match.group().split(':')[1]
                                    recv_length = len(recv_value)

                                    # Sheet1에 모든 데이터를 추가
                                    data_for_csv.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                                    # 보낸값이 20자 이하인 경우, 최초 및 변경된 응답만 추가
                                    if len(send_value) <= 20:
                                        # 고유키별 응답 상태 추적
                                        if send_value not in response_tracker:
                                            # 최초 응답을 기록
                                            response_tracker[send_value] = recv_value
                                            filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])
                                        elif response_tracker[send_value] != recv_value:
                                            # 응답이 변경되었을 경우에만 기록
                                            response_tracker[send_value] = recv_value
                                            filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                            # "보낸값" 다음 줄로 이동
                            i += 2
                        else:
                            # "보낸값"이 없는 경우 다음 줄로 이동
                            i += 1
                
                # 기타 파일 처리
                else:
                    for line in lines:
                        # 각 행에서 시간 추출
                        time_match = re.search(time_pattern, line)
                        if time_match:
                            time_str = time_match.group()
                            remaining_data = line[len(time_str):].strip()  # 시간 이후의 모든 데이터를 추출
                            
                            # 시간 형식을 "yyMMdd HHmmss"로 변환
                            original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                            formatted_time = original_time.strftime('%y%m%d %H%M%S')
                            
                            # Sheet1과 Sheet2에 기타 로그 추가 (시간순으로 섞임)
                            data_for_csv.append([filename, formatted_time, "", "", "", remaining_data])
                            filtered_data.append([filename, formatted_time, "", "", "", remaining_data])

# 수집된 모든 데이터를 Time 컬럼 기준으로 오름차순 정렬
data_for_csv.sort(key=lambda x: x[1])
filtered_data.sort(key=lambda x: x[1])

# CSV 파일 저장
timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')

with open(output_csv_path, 'w', newline='', encoding='utf-8-sig') as csvfile:
    csv_writer = csv.writer(csvfile)
    csv_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    csv_writer.writerows(data_for_csv)

# 별도 시트2에 해당하는 필터링된 응답을 저장
filtered_output_path = os.path.join(output_directory, f'filtered_output_{timestamp}.csv')

with open(filtered_output_path, 'w', newline='', encoding='utf-8-sig') as filtered_csvfile:
    filtered_writer = csv.writer(filtered_csvfile)
    filtered_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    filtered_writer.writerows(filtered_data)

print(f'\n모든 데이터를 Sheet1에 저장 완료: {output_csv_path}')
print(f'필터링된 데이터를 Sheet2에 저장 완료: {filtered_output_path}')
코드 설명
파일 구분 처리:

DetailCMD 파일은 기존 방식대로 처리하되, 보낸값이 20자 이하일 경우 고유키로 간주하여 최초 응답과 변경된 응답만 filtered_data에 추가합니다.
기타 파일들은 remaining_data를 포함해 data_for_csv와 filtered_data에 모두 기록합니다.
응답 필터링:

response_tracker 딕셔너리를 사용하여 고유 보낸값별 응답을 추적하며, 변경이 발생할 때마다 기록해 filtered_data에 추가합니다.
정렬 및 CSV 저장:
