겠습니다. MainViewModel에서 SensorViewModel을 이미 생성하고 할당한 상황이고, 이제 다른 클래스에서 이 SensorViewModel 인스턴스를 사용하는 방법을 설명하겠습니다. 명확하고 직접적인 예시를 통해 설명드리겠습니다.

상황
MainViewModel 내부에 SensorViewModel이 이미 생성되었으며, 이제 다른 클래스에서 이 SensorViewModel을 접근하여 사용해야 한다고 가정하겠습니다.

1. MainViewModel 준비
먼저, MainViewModel에서 SensorViewModel을 공개적으로 접근할 수 있도록 프로퍼티를 설정합니다.

csharp
코드 복사
public class MainViewModel
{
    // 공개적으로 접근 가능한 SensorViewModel 프로퍼티
    public SensorViewModel SensorVM { get; private set; }

    public MainViewModel()
    {
        // SensorViewModel 인스턴스 생성
        SensorVM = new SensorViewModel();
    }
}
2. 다른 클래스에서 SensorViewModel 사용
다른 클래스에서 MainViewModel 인스턴스를 통해 SensorViewModel을 사용하기 위해서는, 해당 클래스에 MainViewModel의 인스턴스가 전달되어야 합니다. 이를 위해 의존성 주입, 생성자 주입 또는 프로퍼티 주입 등의 방법을 사용할 수 있습니다.

예시: OtherClass가 MainViewModel을 통해 SensorViewModel 사용
csharp
코드 복사
public class OtherClass
{
    private MainViewModel _mainViewModel;

    public OtherClass(MainViewModel mainViewModel)
    {
        _mainViewModel = mainViewModel;
    }

    public void UseSensorData()
    {
        var sensors = _mainViewModel.SensorVM.Sensors;
        foreach(var sensor in sensors)
        {
            Console.WriteLine($"Sensor Name: {sensor.SensorName}, Detected: {sensor.IsDetected}");
        }
    }
}
3. OtherClass 인스턴스 생성 및 사용
OtherClass를 사용하는 코드 예는 다음과 같습니다. 이는 MainViewModel 인스턴스가 생성된 후, 이 인스턴스를 사용하여 OtherClass를 초기화하고, 센서 데이터를 사용하는 과정을 보여줍니다.

App.xaml.cs에서 OtherClass 사용 예시
csharp
코드 복사
public partial class App : Application
{
    protected override void OnStartup(StartupEventArgs e)
    {
        base.OnStartup(e);

        // MainViewModel 인스턴스 생성
        var mainViewModel = new MainViewModel();

        // OtherClass 인스턴스 생성, MainViewModel 주입
        var otherClass = new OtherClass(mainViewModel);

        // OtherClass에서 센서 데이터 사용
        otherClass.UseSensorData();
    }
}
결론
이 방법을 통해 MainViewModel 내에서 생성된 SensorViewModel 인스턴스를 다른 클래스에서도 접근하여 사용할 수 있습니다. MainViewModel의 인스턴스를 필요로 하는 클래스에 주입함으로써, 그 내부의 SensorViewModel 및 관련 데이터에 접근할 수 있습니다. 이 구조는 모듈화와 의존성 관리를 효율적으로 수행할 수 있게 하며, 클래스 간의 결합도를 낮추고, 코드의 유연성과 유지보수성을 높이는 데 도움을 줍니다.