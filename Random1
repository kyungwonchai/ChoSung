지우개 기능을 추가하려면, 그리는 대신 특정 영역을 투명하게 만드는 로직이 필요합니다. 현재 drawLine 대신 지우개 모드에서는 해당 영역을 투명하게 만들도록 수정하겠습니다.

수정할 부분
drawMode와 함께 eraseMode를 추가하여 지우개 기능을 활성화합니다. 그리고 지우개 모드일 때는 그리는 대신 투명하게 만듭니다.

kotlin
코드 복사
@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var eraseMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val view = LocalView.current
    val window = (context as? ComponentActivity)?.window
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode && !eraseMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        Canvas(modifier = Modifier
            .fillMaxSize()
            .pointerInput(Unit) {
                detectDragGestures(
                    onDragStart = { offset -> currentPathPoints = listOf(offset) },
                    onDragEnd = {
                        if (drawMode) {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                        } else if (eraseMode) {
                            // 지우개 모드에서는 색을 투명으로 설정하여 경로 추가
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, Color.Transparent)
                        }
                        currentPathPoints = listOf()
                    },
                    onDrag = { change, _ ->
                        currentPathPoints = currentPathPoints + change.position
                        change.consume()
                    }
                )
            }
        ) {
            for (path in drawingPaths) {
                val paintColor = if (path.color == Color.Transparent) Color.White else path.color
                for (i in 1 until path.points.size) {
                    drawLine(
                        color = paintColor,
                        start = path.points[i - 1],
                        end = path.points[i],
                        strokeWidth = if (path.color == Color.Transparent) 10f else 3f // 지우개 모드에서는 더 두껍게
                    )
                }
            }
            for (i in 1 until currentPathPoints.size) {
                drawLine(
                    color = if (eraseMode) Color.White else color,
                    start = currentPathPoints[i - 1],
                    end = currentPathPoints[i],
                    strokeWidth = if (eraseMode) 10f else 3f // 지우개 모드에서는 더 두껍게
                )
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(horizontal = 20.dp, vertical = 0.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                    eraseMode = false // Draw 모드 활성화 시 지우개 모드는 비활성화
                }) {
                    Text("Draw")
                }
                Button(onClick = {
                    eraseMode = !eraseMode
                    drawMode = false // Erase 모드 활성화 시 Draw 모드는 비활성화
                }) {
                    Text("Erase")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    window?.let { captureAndUploadBitmap(it, view, scope) }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}
이제 Erase 버튼을 추가하여 지우개 모드를 활성화할 수 있습니다. 지우개 모드가 활성화되면 드로잉 대신 해당 영역을 투명하게 만들어 이미지에서 지울 수 있습니다. drawLine에서 지우개 모드일 때 더 두껍게 설정하여 지울 수 있는 범위를 넓혔습니다.