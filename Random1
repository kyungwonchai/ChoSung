using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.ComponentModel;
using System.Collections.Generic;

public class CommandQueueViewModel : INotifyPropertyChanged
{
    // 명령 큐
    private Queue<Func<Task<CommandResult>>> commandQueue = new Queue<Func<Task<CommandResult>>>();
    
    // UI에 표시할 명령 리스트
    public ObservableCollection<CommandItem> RemainingCommands { get; set; } = new ObservableCollection<CommandItem>();

    // INotifyPropertyChanged 인터페이스 구현
    public event PropertyChangedEventHandler PropertyChanged;

    // 처리 중 여부 플래그
    private bool _isProcessing; 
    
    // DB 헬퍼 클래스
    private readonly DatabaseHelper _dbHelper;

    // 기본 재시도 횟수와 재시도 간격
    public int RetryLimit { get; set; } = 3; // 기본 재시도 횟수 3회
    public int RetryInterval { get; set; } = 2000; // 기본 재시도 간격 2초 (2000ms)

    // Progress 속성 추가 (ProgressBar를 위한 속성)
    private int _progress;
    public int Progress
    {
        get => _progress;
        set
        {
            if (_progress != value)
            {
                _progress = value;
                OnPropertyChanged(nameof(Progress)); // Progress 변경 시 UI 업데이트
            }
        }
    }

    public CommandQueueViewModel()
    {
        _dbHelper = new DatabaseHelper();
        _isProcessing = false; // 처리 중 상태 플래그 초기화
        Progress = 0; // 초기값 0
    }

    // 비동기 작업을 큐에 추가하는 함수 (보낸 명령, 응답 검사 포함)
    public void AddAsyncTaskCommand(Func<Task<string>> asyncTask, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        EnqueueTask(asyncTask, commandText, sentCommand, responseValidator);
    }

    // 명령을 큐에 추가하고 처리하는 함수
    private async void EnqueueTask(Func<Task<string>> taskFunc, string commandText, string sentCommand, Func<string, bool> responseValidator)
    {
        var newCommand = new CommandItem { CommandText = commandText, Status = "Pending" };
        RemainingCommands.Add(newCommand);

        commandQueue.Enqueue(async () =>
        {
            newCommand.Status = "Processing";
            int retryCount = 0;
            Stopwatch stopwatch = new Stopwatch(); // 응답 시간 측정용 스톱워치

            while (retryCount < RetryLimit) // 재시도 횟수가 최대 재시도 횟수보다 적을 때까지 반복
            {
                try
                {
                    stopwatch.Restart(); // 응답 시간 측정 시작
                    string result = await taskFunc(); // 비동기 작업 실행
                    stopwatch.Stop(); // 응답 시간 측정 완료

                    int responseTime = (int)stopwatch.ElapsedMilliseconds; // 응답 시간 계산
                    newCommand.Output = result; // 받은 응답 저장

                    if (responseValidator(result)) // 정상 응답 검증
                    {
                        newCommand.Status = "Completed"; // 성공 처리
                        newCommand.Result = 1; // 성공 플래그
                        await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Completed", newCommand.Result, retryCount, responseTime, newCommand.Output);
                        UpdateProgress(); // 작업 완료 시 Progress 업데이트
                        return new CommandResult { Success = true, Message = result };
                    }
                    else
                    {
                        retryCount++;
                        if (retryCount >= RetryLimit)
                        {
                            newCommand.Status = "Failed";
                            newCommand.Result = 0; // 실패 플래그
                            await _dbHelper.LogCommandToDatabase(commandText, sentCommand, result, "Failed", newCommand.Result, retryCount, responseTime, result);
                            ShowAlarm("Failed after maximum retries: " + result);
                            StopProcessing(); // 큐 처리 중단
                            UpdateProgress(); // 작업 실패 시에도 Progress 업데이트
                            return new CommandResult { Success = false, Message = result };
                        }
                        await Task.Delay(RetryInterval); // 재시도 간격 대기
                    }
                }
                catch (Exception ex)
                {
                    newCommand.Status = "Failed";
                    newCommand.Result = 0; // 실패 플래그
                    stopwatch.Stop(); // 예외 시에도 응답 시간 측정 종료
                    int responseTime = (int)stopwatch.ElapsedMilliseconds;

                    await _dbHelper.LogCommandToDatabase(commandText, sentCommand, ex.Message, "Failed", newCommand.Result, retryCount, responseTime, ex.Message);
                    ShowAlarm("Error occurred: " + ex.Message); // 오류 알람
                    UpdateProgress(); // 예외 시에도 Progress 업데이트
                    return new CommandResult { Success = false, Message = ex.Message };
                }
            }
            UpdateProgress(); // 최종적으로 Progress 업데이트
            return new CommandResult { Success = false };
        });

        // 작업이 처리 중이 아닌 경우 즉시 처리 시작
        if (!_isProcessing)
        {
            _isProcessing = true;
            await ProcessCommandQueue();
        }

        UpdateProgress(); // 프로그레스바 상태 업데이트
    }

    // 명령 큐를 순차적으로 처리하는 함수
    private async Task ProcessCommandQueue()
    {
        while (commandQueue.Count > 0)
        {
            var command = commandQueue.Dequeue(); // 큐에서 작업을 꺼냄
            await command(); // 큐에 있는 작업 실행
            UpdateProgress(); // 프로그레스바 상태 업데이트
        }

        _isProcessing = false; // 모든 작업 완료 후 처리 중 상태 해제
    }

    // 큐 처리 중단 함수
    private void StopProcessing()
    {
        commandQueue.Clear(); // 큐를 비우고 처리 중단
        _isProcessing = false; // 처리 중 상태 해제
    }

    // 알람 표시 (실제 구현은 UI 관련 코드로 연결)
    private void ShowAlarm(string message)
    {
        Console.WriteLine("ALARM: " + message); // 콘솔에 알람 출력 (UI에서 알람 처리 필요)
    }

    // 프로그레스바 상태 업데이트
    private void UpdateProgress()
    {
        Progress = commandQueue.Count; // 남은 명령의 수에 따라 Progress 값 업데이트
    }

    // INotifyPropertyChanged 인터페이스 구현
    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
