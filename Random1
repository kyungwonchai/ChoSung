제 ProcessOut과 ProcessStack 함수도 함께 제공하고, 작업이 완료되면 ProductOrderModel 속성 값을 갱신해서 UI가 최신 상태로 업데이트되도록 하겠습니다. 또한, 속성 값의 변경이 **ProductOrderModel**에서 제대로 반영될 수 있도록 관련 코드를 업데이트하겠습니다.

ProcessOutAsync() 및 ProcessStackAsync() 함수 수정
두 함수는 큐에서 배출 또는 적재 작업을 처리하는 비동기 함수로, 작업이 완료되면 **ProductOrderModel**의 POStatus 속성을 업데이트하여 상태가 변경되었음을 UI에 반영합니다.

최종 수정된 코드
csharp
코드 복사
// 큐에서 작업을 처리하는 비동기 메소드
private async Task ProcessQueueAsync()
{
    _isProcessingTask = true; // 작업이 진행 중임을 나타냄

    // 큐에서 작업이 남아 있을 때까지 반복
    while (_taskQueue.TryDequeue(out (string taskType, ProductOrderModel order)))
    {
        _taskList.Add($"처리 중: {taskType}: {order.ProductOrder}");

        // 작업의 종류에 따라 분기 처리 (적재 또는 배출)
        if (taskType == "적재")
        {
            await ProcessStackAsync(order); // 적재 작업 처리
        }
        else if (taskType == "배출")
        {
            await ProcessOutAsync(order); // 배출 작업 처리
        }

        // 완료된 작업을 리스트에서 삭제
        _taskList.Remove($"처리 중: {taskType}: {order.ProductOrder}");

        // 작업 완료 후 주문 상태 갱신 (out 또는 stack)
        order.POStatus = taskType == "적재" ? "stack" : "out";
    }

    _isProcessingTask = false; // 작업이 끝나면 플래그 초기화
}

// 적재 작업을 처리하는 비동기 함수
private async Task ProcessStackAsync(ProductOrderModel order)
{
    _taskList.Add($"적재 신호 전송: {order.ProductOrder}");

    // PLC로 적재 명령 전송 (실제 PLC 통신 로직 구현 필요)
    bool isCommandSent = SendStackCommandToPLC();

    if (isCommandSent)
    {
        _taskList.Add($"WD13 응답 대기: {order.ProductOrder}");

        // WD13 응답 대기 (비동기적으로 대기)
        bool isWD13Response = await WaitForWD13ResponseAsync();
        if (isWD13Response)
        {
            _taskList.Add($"WD13 응답 완료: {order.ProductOrder}");

            // R520 및 R521 센서 감지 대기 (비동기적으로 감시)
            bool isSensorSuccess = await MonitorSensorsAsync();
            if (isSensorSuccess)
            {
                _taskList.Add($"적재 완료: {order.ProductOrder}");
                order.POStatus = "stack"; // 적재 완료 후 상태 업데이트
            }
            else
            {
                _taskList.Add($"적재 실패(3분 초과): {order.ProductOrder}");
                ShowError($"적재 실패: {order.ProductOrder} (3분 내 감지되지 않음)");
            }
        }
        else
        {
            _taskList.Add($"WD13 응답 실패: {order.ProductOrder}");
            ShowError($"WD13 응답 실패: {order.ProductOrder}");
        }
    }

    _taskList.Remove($"적재 신호 전송: {order.ProductOrder}");
}

// 배출 작업을 처리하는 비동기 함수
private async Task ProcessOutAsync(ProductOrderModel order)
{
    _taskList.Add($"배출 신호 전송: {order.ProductOrder}");

    // PLC로 배출 명령 전송 (실제 PLC 통신 로직 구현 필요)
    await Task.Delay(1000); // 예시로 1초 대기

    _taskList.Add($"배출 완료: {order.ProductOrder}");
    order.POStatus = "out"; // 배출 완료 후 상태 업데이트

    _taskList.Remove($"배출 신호 전송: {order.ProductOrder}");
}

// PLC에 적재 신호 전송 함수 (가정된 구현)
private bool SendStackCommandToPLC()
{
    return true; // 실제 PLC로 적재 명령 전송 로직 구현
}

// WD13 응답 대기 함수 (비동기)
private async Task<bool> WaitForWD13ResponseAsync()
{
    await Task.Delay(2000); // 예시로 2초 대기 (실제 응답 대기 로직 구현)
    return true;
}

// 센서 감시 함수 (R520, R521 센서 감시)
private async Task<bool> MonitorSensorsAsync()
{
    var startTime = DateTime.Now;

    while ((DateTime.Now - startTime).TotalMilliseconds < 180000) // 3분 감시
    {
        bool isR520Detected = ReadSensor("R520");
        bool isR521Detected = ReadSensor("R521");

        if (isR520Detected)
        {
            _taskList.Add("R520 감지됨");

            // R520 꺼질 때까지 대기
            while (!ReadSensor("R520"))
            {
                await Task.Delay(100);
            }

            _taskList.Add("R520 꺼짐 확인");

            if (isR521Detected)
            {
                _taskList.Add("R521 감지됨");
                return true; // 적재 성공
            }
        }

        await Task.Delay(100); // 감시 주기
    }

    return false; // 적재 실패 (3분 초과)
}

// 에러 처리 함수
private void ShowError(string message)
{
    msgvs.Instance.LogT2(message); // 에러 메시지 기록
}

// 큐에 작업 추가
private void EnqueueTask(string taskType, ProductOrderModel order)
{
    _taskQueue.Enqueue((taskType, order)); // 작업을 큐에 추가

    // 큐에 추가한 후 바로 작업 처리 시작
    if (!_isProcessingTask) // 이미 다른 작업을 처리 중이지 않을 때만 실행
    {
        _ = ProcessQueueAsync(); // 큐 처리 시작
    }
}
설명:
작업 처리 로직 (적재와 배출):

ProcessStackAsync: 적재 작업 처리 함수로, PLC로 명령을 보내고 센서 감시를 통해 적재 작업을 완료합니다.
ProcessOutAsync: 배출 작업 처리 함수로, PLC로 배출 명령을 보냅니다.
작업이 완료되면 해당 작업의 **POStatus**를 업데이트하여 UI에 상태 변경을 반영합니다.
센서 감시 및 PLC 응답 처리:

MonitorSensorsAsync: R520 및 R521 센서를 3분 동안 감시합니다. 이 센서가 감지되면 작업이 성공한 것으로 처리됩니다.
WaitForWD13ResponseAsync: PLC의 WD13 응답을 기다리는 비동기 함수입니다. 응답이 오면 작업을 진행하고, 응답이 없으면 에러 처리합니다.
EnqueueTask 및 작업 처리:

작업을 큐에 추가할 때, **작업이 진행 중이지 않으면 바로 ProcessQueueAsync()**를 호출하여 큐에 있는 작업을 처리합니다.
ProductOrderModel 클래스
ProductOrderModel 클래스는 작업의 상태를 UI에 반영할 수 있도록 INotifyPropertyChanged를 구현하여 속성 값이 변경되면 UI가 자동으로 업데이트되도록 되어 있습니다.

csharp
코드 복사
// ProductOrderModel: 제품 주문 정보를 담고 있으며 UI와 데이터 바인딩을 지원
public class ProductOrderModel : INotifyPropertyChanged
{
    private string _productOrder;
    private string _basicModel;
    private int _poRemain;
    private int _mgCount;
    private int _pCount;
    private string _poStatus;
    private string _pDate;

    public string ProductOrder
    {
        get => _productOrder;
        set
        {
            _productOrder = value;
            OnPropertyChanged(nameof(ProductOrder));
        }
    }

    public string BasicModel
    {
        get => _basicModel;
        set
        {
            _basicModel = value;
            OnPropertyChanged(nameof(BasicModel));
        }
    }

    public int PORemain
    {
        get => _poRemain;
        set
        {
            _poRemain = value;
            OnPropertyChanged(nameof(PORemain));
        }
    }

    public int MGCount
    {
        get => _mgCount;
        set
        {
            _mgCount = value;
            OnPropertyChanged(nameof(MGCount));
        }
    }

    public int PCount
    {
        get => _pCount;
        set
        {
            _pCount = value;
            OnPropertyChanged(nameof(PCount));
        }
    }

    public string POStatus
    {
        get => _poStatus;
        set
        {
            _poStatus = value;
            OnPropertyChanged(nameof(POStatus));
        }
    }

    public string PDate
    {
        get => _pDate;
        set
        {
            _pDate = value;
            OnPropertyChanged(nameof(PDate));
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
이제 적재 또는 배출 작업이 센서 감시와 PLC 응답 확인 후 완료되며, 완료된 후에 ProductOrderModel의 상태가 갱신되고, UI에 반영되도록 수정되었습니다.