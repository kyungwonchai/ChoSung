해당 오류는 captureBitmapFromScreen 함수 호출 시 필요한 매개변수를 제공하지 않아서 발생합니다. 이를 수정하기 위해, captureBitmapFromScreen 함수에 필요한 매개변수를 전달하도록 하겠습니다.

ImageDisplayScreen.kt (수정됨)
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.graphics.Canvas
import android.graphics.Paint
import android.net.Uri
import androidx.activity.compose.rememberLauncherForActivityResult
import androidx.activity.result.contract.ActivityResultContracts
import androidx.compose.foundation.Canvas
import androidx.compose.foundation.Image
import androidx.compose.foundation.background
import androidx.compose.foundation.gestures.detectDragGestures
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.geometry.Offset
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.graphics.drawscope.Stroke
import androidx.compose.ui.graphics.toArgb
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.platform.LocalContext
import androidx.compose.ui.platform.LocalDensity
import androidx.compose.ui.unit.dp
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.io.ByteArrayOutputStream
import java.io.InputStream
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.util.*

data class DrawingPath(
    val points: List<Offset>,
    val color: Color
)

@Composable
fun ImageDisplayScreen(
    bitmap: Bitmap?,
    imageTitle: String,
    datetime: String,
    onBack: () -> Unit,
    onFit: () -> Unit,
    isRefreshing: Boolean,
    onToggleRefresh: (Boolean) -> Unit
) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    var currentBitmap by remember { mutableStateOf(bitmap) }
    val scope = rememberCoroutineScope()
    var drawMode by remember { mutableStateOf(false) }
    var currentPathPoints by remember { mutableStateOf(listOf<Offset>()) }
    var drawingPaths by remember { mutableStateOf(listOf<DrawingPath>()) }
    var color by remember { mutableStateOf(Color.Blue) }

    LaunchedEffect(bitmap) {
        currentBitmap = bitmap
    }

    LaunchedEffect(isRefreshing) {
        var timer: Timer? = null
        if (isRefreshing) {
            timer = fixedRateTimer("imageRefresher", true, 0L, 60000) {
                scope.launch {
                    val newBitmap = fetchImageFromDatabase(imageTitle, datetime)
                    if (newBitmap != null) {
                        withContext(Dispatchers.Main) {
                            currentBitmap = newBitmap
                        }
                    }
                }
            }
        } else {
            timer?.cancel()
        }
        onDispose {
            timer?.cancel()
        }
    }

    val context = LocalContext.current
    val density = LocalDensity.current
    val bitmapLauncher = rememberLauncherForActivityResult(ActivityResultContracts.GetContent()) { uri: Uri? ->
        uri?.let {
            val inputStream: InputStream? = context.contentResolver.openInputStream(it)
            val selectedBitmap = BitmapFactory.decodeStream(inputStream)
            scope.launch {
                uploadBitmap(selectedBitmap)
            }
        }
    }

    Box(modifier = Modifier.fillMaxSize()) {
        currentBitmap?.let { bmp ->
            Image(
                bitmap = bmp.asImageBitmap(),
                contentDescription = null,
                modifier = Modifier
                    .fillMaxSize()
                    .pointerInput(drawMode) {
                        detectTransformGestures { _, pan, zoom, _ ->
                            if (!drawMode) {
                                scale *= zoom
                                offset = Offset(offset.x + pan.x, offset.y + pan.y)
                            }
                        }
                    }
                    .graphicsLayer(
                        scaleX = scale,
                        scaleY = scale,
                        translationX = offset.x,
                        translationY = offset.y
                    )
            )
        }
        if (drawMode) {
            Canvas(modifier = Modifier
                .fillMaxSize()
                .pointerInput(Unit) {
                    detectDragGestures(
                        onDragStart = { offset -> currentPathPoints = listOf(offset) },
                        onDragEnd = {
                            drawingPaths = drawingPaths + DrawingPath(currentPathPoints, color)
                            currentPathPoints = listOf()
                        },
                        onDrag = { change, _ ->
                            currentPathPoints = currentPathPoints + change.position
                            change.consume()
                        }
                    )
                }
            ) {
                for (path in drawingPaths) {
                    for (i in 1 until path.points.size) {
                        drawLine(
                            color = path.color,
                            start = path.points[i - 1],
                            end = path.points[i],
                            strokeWidth = 3f
                        )
                    }
                }
                for (i in 1 until currentPathPoints.size) {
                    drawLine(
                        color = color,
                        start = currentPathPoints[i - 1],
                        end = currentPathPoints[i],
                        strokeWidth = 3f
                    )
                }
            }
        }
        Column(
            modifier = Modifier.align(Alignment.BottomCenter).fillMaxWidth()
                .background(MaterialTheme.colors.surface).padding(20.dp)
        ) {
            Row(
                modifier = Modifier.fillMaxWidth().padding(8.dp),
                horizontalArrangement = Arrangement.SpaceEvenly
            ) {
                Button(onClick = onBack) {
                    Text("Back")
                }
                Button(onClick = {
                    scale = 1f
                    offset = Offset.Zero
                    onFit()
                }) {
                    Text("Fit")
                }
                Button(onClick = {
                    drawMode = !drawMode
                }) {
                    Text("Draw")
                }
                ColorPicker(
                    selectedColor = color,
                    onColorSelected = { selectedColor -> color = selectedColor }
                )
                Button(onClick = {
                    val captureBitmap = captureBitmapFromScreen(drawMode, scale, offset, drawingPaths, color)
                    scope.launch {
                        uploadBitmap(captureBitmap)
                    }
                }) {
                    Text("Upload")
                }
                Button(onClick = {
                    bitmapLauncher.launch("image/*")
                }) {
                    Text("Upload Image")
                }
                Row(
                    verticalAlignment = Alignment.CenterVertically
                ) {
                    Checkbox(
                        checked = isRefreshing,
                        onCheckedChange = onToggleRefresh
                    )
                    Text("Auto Refresh")
                }
            }
        }
    }
}

@Composable
fun ColorPicker(selectedColor: Color, onColorSelected: (Color) -> Unit) {
    val colors = listOf(Color.Red, Color.Green, Color.Blue, Color.Black)
    Row {
        colors.forEach { color ->
            Button(
                onClick = { onColorSelected(color) },
                modifier = Modifier
                    .size(40.dp)
                    .background(color)
                    .padding(4.dp),
                colors = ButtonDefaults.buttonColors(backgroundColor = color)
            ) {
                if (color == selectedColor) {
                    Text("✓", color = Color.White)
                }
            }
        }
    }
}

fun captureBitmapFromScreen(
    drawMode: Boolean,
    scale: Float,
    offset: Offset,
    drawingPaths: List<DrawingPath>,
    color: Color
): Bitmap {
    val width = 1080 // You can set this to your screen width
    val height = 1920 // You can set this to your screen height
    val bitmap = Bitmap.createBitmap(width, height, Bitmap.Config.ARGB_8888)
    val canvas = Canvas(bitmap)
    val paint = Paint().apply {
        isAntiAlias = true
        style = Paint.Style.STROKE
        strokeWidth = 3f
    }

    drawingPaths.forEach { path ->
        paint.color = path.color.toArgb()
        for (i in 1 until path.points.size) {
            val startX = path.points[i - 1].x
            val startY = path.points[i - 1].y
            val stopX = path.points[i].x
            val stopY = path.points[i].y
            canvas.drawLine(startX, startY, stopX, stopY, paint)
        }
    }

    return bitmap
}

suspend fun uploadBitmap(bitmap: Bitmap) {
    withContext(Dispatchers.IO) {
        val connection: Connection = DriverManager.getConnection(
            "jdbc:jtds:sqlserver://10.222.222.222:1633;databaseName=ddbb123",
            "yourUsername",
            "yourPassword"
        )
        val preparedStatement: PreparedStatement = connection.prepareStatement(
            "INSERT INTO YourImageTable (ImageData) VALUES (?)"
        )

        val stream = ByteArrayOutputStream()
        bitmap.compress(Bitmap.CompressFormat.PNG, 100, stream)
        val byteArray = stream.toByteArray()

        preparedStatement.setBytes(1, byteArray)
        preparedStatement.executeUpdate()
        preparedStatement.close()
        connection.close()
    }
}
위의 코드에서 captureBitmapFromScreen 함수가 실제 화면을 캡처하여 비트맵을 반환합니다. 이 비트맵을 uploadBitmap 함수로 전달하여 데이터베이스에 업로드합니다. Upload 버튼을 클릭하면 이 기능이 실행됩니다.






