SQL Server에서 자동으로 실행되는 작업 중 가장 부하가 큰 작업을 찾고, 그 안에서 평균 실행 시간과 문제를 일으키는 쿼리를 파악하려면, SQL Agent 작업, Stored Procedure, 트리거 또는 다른 주기적 작업에서 실행된 쿼리를 모니터링해야 합니다. 아래는 이를 확인하는 방법입니다.

1. 최근 실행된 작업(Job) 분석
SQL Agent 작업(Job) 중 가장 오래 실행되거나 부하가 큰 작업을 확인하려면 아래 쿼리를 실행합니다.

sql
코드 복사
-- SQL Agent 작업 실행 기록 분석
SELECT 
    j.name AS JobName, -- 작업 이름
    h.run_date AS RunDate, -- 실행 날짜
    h.run_time AS RunTime, -- 실행 시작 시간
    msdb.dbo.agent_datetime(h.run_date, h.run_time) AS StartDateTime, -- 실행 시작 시각
    h.run_duration AS RunDuration, -- 실행 소요 시간 (HHMMSS 형식)
    CASE h.run_status
        WHEN 0 THEN 'Failed'
        WHEN 1 THEN 'Succeeded'
        WHEN 2 THEN 'Retry'
        WHEN 3 THEN 'Canceled'
        ELSE 'Unknown'
    END AS RunStatus, -- 작업 상태
    s.step_name AS StepName, -- 작업 단계 이름
    s.command AS CommandText -- 실행된 T-SQL 또는 명령어
FROM msdb.dbo.sysjobs j
JOIN msdb.dbo.sysjobhistory h
    ON j.job_id = h.job_id
JOIN msdb.dbo.sysjobsteps s
    ON j.job_id = s.job_id
WHERE h.run_date = CONVERT(VARCHAR(8), GETDATE(), 112) -- 오늘 실행된 작업
ORDER BY h.run_duration DESC; -- 실행 시간 기준 정렬
쿼리 설명
JobName: 작업 이름.
RunDuration: 실행된 작업의 소요 시간(HHMMSS).
CommandText: 작업 단계에서 실행된 실제 T-SQL 쿼리 또는 명령.
2. 가장 부하가 큰 쿼리 찾기
자동 실행되는 작업(Job) 또는 주기적으로 실행되는 쿼리 중 평균 실행 시간이 높은 쿼리를 찾으려면 다음 쿼리를 실행합니다.

sql
코드 복사
-- 평균 실행 시간 기준으로 상위 10개 쿼리 찾기
WITH QueryStats AS (
    SELECT 
        qs.sql_handle,
        qs.plan_handle,
        qs.creation_time,
        qs.last_execution_time,
        qs.execution_count, -- 실행 횟수
        qs.total_worker_time / 1000 AS TotalCPUTime_ms, -- 총 CPU 시간 (ms)
        qs.total_elapsed_time / 1000 AS TotalElapsedTime_ms, -- 총 실행 시간 (ms)
        qs.total_elapsed_time / NULLIF(qs.execution_count, 0) / 1000 AS AvgElapsedTime_ms, -- 평균 실행 시간 (ms)
        qs.total_logical_reads AS TotalLogicalReads, -- 논리적 읽기 수
        qs.total_logical_reads / NULLIF(qs.execution_count, 0) AS AvgLogicalReads, -- 평균 논리적 읽기
        qs.total_physical_reads AS TotalPhysicalReads, -- 물리적 읽기 수
        qs.total_logical_writes AS TotalLogicalWrites -- 논리적 쓰기 수
    FROM sys.dm_exec_query_stats qs
    WHERE qs.execution_count > 0 -- 실행된 적이 있는 쿼리만 포함
)
SELECT TOP 10
    DB_NAME(DB_ID()) AS DatabaseName, -- 데이터베이스 이름
    qs.execution_count AS ExecutionCount, -- 실행 횟수
    qs.AvgElapsedTime_ms AS AvgExecutionTime_ms, -- 평균 실행 시간 (ms)
    qs.TotalCPUTime_ms AS TotalCPUTime_ms, -- 총 CPU 시간 (ms)
    qs.AvgLogicalReads AS AvgLogicalReads, -- 평균 논리적 읽기
    qs.TotalLogicalWrites AS TotalLogicalWrites, -- 총 논리적 쓰기
    SUBSTRING(st.text, (qs.statement_start_offset / 2) + 1, 
              ((CASE qs.statement_end_offset 
                  WHEN -1 THEN DATALENGTH(st.text)
                  ELSE qs.statement_end_offset
              END - qs.statement_start_offset) / 2) + 1) AS QueryText -- 실행된 쿼리
FROM QueryStats qs
CROSS APPLY sys.dm_exec_sql_text(qs.sql_handle) AS st
ORDER BY qs.AvgElapsedTime_ms DESC; -- 평균 실행 시간 기준 정렬
쿼리 설명
AvgElapsedTime_ms: 쿼리의 평균 실행 시간(밀리초).
ExecutionCount: 쿼리 실행 횟수.
QueryText: 실제로 실행된 쿼리 텍스트.
TotalCPUTime_ms: 쿼리가 사용한 총 CPU 시간.
AvgLogicalReads: 쿼리 실행당 평균 논리적 읽기.
3. 문제가 되는 쿼리의 실행 계획 확인
위에서 확인된 문제가 되는 쿼리를 실행 계획으로 분석하여 최적화합니다.

실행 계획 확인
sql
코드 복사
-- 실행 계획 확인
SET SHOWPLAN_XML ON; -- 실행 계획을 XML 형식으로 출력
-- 문제가 되는 쿼리 실행
<여기에 문제 쿼리를 입력하세요>
SET SHOWPLAN_XML OFF;
4. 쿼리 최적화
문제가 되는 쿼리를 확인한 후 아래 방법으로 최적화합니다:

인덱스 추가:
쿼리에서 자주 검색되는 열에 적절한 인덱스를 추가.
실행 계획 분석:
실행 계획에서 테이블 스캔(Table Scan)이나 인덱스 스캔(Index Scan)을 줄이고 인덱스 탐색(Index Seek)을 유도.
쿼리 리팩토링:
불필요한 JOIN 제거, 서브쿼리 최적화 등.
요약
위의 두 가지 쿼리로 다음을 확인할 수 있습니다:

SQL Agent 작업 중 실행 시간이 긴 작업 (RunDuration 기준).