해했습니다. 요구 사항을 다시 명확히 정리하겠습니다.

요구 사항:
처음 실행 시:

로그 파일을 처음부터 끝까지 읽어서 PLAN Selected가 마지막으로 나오는 위치를 찾아야 합니다.
PLAN Selected가 마지막으로 등장한 지점 이후부터 로그 파일을 실시간으로 감시하여 변경 사항을 처리해야 합니다.
실시간 감시:

이후 로그 파일이 변경될 때 새로 쓰여진 부분을 감지하여 그 시점부터 처리해야 합니다.
최종 구현 코드
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileChecker
    {
        // 로그 파일이 위치한 디렉토리 경로
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 정규식 패턴: 파일 이름 규칙을 정의 (IP 주소 형식 + "_M4OI"로 시작)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 타이머: 주기적으로 파일 변경을 확인하기 위한 타이머
        private DispatcherTimer _timer;

        // 현재 감시 중인 파일 경로 (가장 최근 파일)
        private string _currentMonitoredFile;

        // 마지막 감지된 PLAN Selected 시간
        private DateTime _lastPlanSelectedDate;

        // 마지막으로 감시 중인 파일의 수정 시간
        private DateTime _lastWriteTime;

        // 현재 처리 중인 ProductOrder 객체
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (주문 목록을 실시간으로 갱신)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // 파일에서 마지막으로 `PLAN Selected`가 나온 위치
        private long _lastPlanSelectedPosition;

        // 첫 실행 여부 체크
        private bool _isFirstExecution;

        // 생성자: 타이머를 초기화하고 설정하는 작업
        public FileChecker(ObservableCollection<ProductOrderModel> productOrders)
        {
            _productOrders = productOrders;
            _isFirstExecution = true;

            // 타이머 초기화 및 설정 (1초마다 파일 상태를 확인)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 주기적으로 디렉토리 내 파일들을 확인
            _timer.Start(); // 타이머 시작

            // 처음 실행할 때 가장 최근 파일을 감시 대상으로 설정
            _currentMonitoredFile = GetLatestLogFile(); // 최근 파일을 가져옴
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 초기값 설정

            // 마지막 PLAN Selected 감지 시간을 현재 시간으로 초기화
            _lastPlanSelectedDate = DateTime.Now;

            // PLAN Selected 위치 초기화
            _lastPlanSelectedPosition = 0;
        }

        // 주기적으로 디렉토리 내 파일을 확인하는 메소드 (타이머에 의해 1초마다 호출)
        private void CheckFiles(object sender, EventArgs e)
        {
            // 현재 디렉토리에서 가장 최신 파일을 확인
            string latestFile = GetLatestLogFile();

            // 새로운 파일이 감지되었거나 현재 감시 중인 파일이 변경된 경우
            if (_currentMonitoredFile == null || latestFile != _currentMonitoredFile)
            {
                // 새로운 파일로 감시 대상을 변경
                _currentMonitoredFile = latestFile;
                _lastWriteTime = File.GetLastWriteTime(_currentMonitoredFile); // 마지막 수정 시간 업데이트
            }

            // 처음 실행일 때는 로그 파일에서 `PLAN Selected`가 마지막으로 등장한 부분을 찾음
            if (_isFirstExecution)
            {
                FindLastPlanSelected(_currentMonitoredFile);  // PLAN Selected가 마지막으로 나온 위치를 찾음
                _isFirstExecution = false; // 첫 실행 이후에는 실시간 감시로 전환
            }

            // 현재 감시 중인 파일의 마지막 수정 시간을 확인
            DateTime latestWriteTime = File.GetLastWriteTime(_currentMonitoredFile);

            // 파일이 수정된 경우에만 파일을 읽고 처리
            if (latestWriteTime > _lastWriteTime)
            {
                _lastWriteTime = latestWriteTime; // 마지막 수정 시간 업데이트
                ReadLogFileFromPosition(_currentMonitoredFile); // PLAN Selected 이후부터 읽고 처리
            }
        }

        // 지정된 경로에서 가장 최근에 수정된 파일을 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 로그 파일 디렉토리에서 파일 목록을 가져와 패턴에 맞는 파일만 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일 필터링
                .OrderByDescending(f => f.LastWriteTime) // 수정 시간을 기준으로 내림차순 정렬
                .ToList();

            // 가장 최근에 수정된 파일의 경로 반환 (없을 경우 null 반환)
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일을 처음부터 읽고 마지막으로 나오는 `PLAN Selected`를 찾음
        private void FindLastPlanSelected(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 처리하지 않음

            try
            {
                // 파일을 읽기-쓰기 공유 모드로 열기
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    string line;
                    long currentPosition = 0; // 현재 파일의 위치
                    _lastPlanSelectedPosition = 0; // 마지막 PLAN Selected 위치 초기화

                    while ((line = streamReader.ReadLine()) != null)
                    {
                        currentPosition = fileStream.Position; // 현재 파일의 포인터 위치 저장

                        if (line.Contains("PLAN Selected"))
                        {
                            // PLAN Selected가 나온 위치를 저장 (마지막으로 나온 위치)
                            _lastPlanSelectedPosition = currentPosition;
                        }

                        ProcessLogLine(line, filePath); // 로그 줄 처리
                    }
                }
            }
            catch (IOException ex)
            {
                Console.WriteLine($"파일을 읽는 중 오류 발생: {ex.Message}");
            }
        }

        // PLAN Selected 이후부터 파일을 읽고 처리
        private void ReadLogFileFromPosition(string filePath)
        {
            if (filePath == null) return;

            try
            {
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    fileStream.Seek(_lastPlanSelectedPosition, SeekOrigin.Begin); // 마지막 PLAN Selected 위치로 이동
                    string line;
                    
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        ProcessLogLine(line, filePath); // 로그 줄 처리
                    }

                    // 최신 로그 위치를 업데이트
                    _lastPlanSelectedPosition = fileStream.Position;
                }
            }
            catch (IOException ex)
            {
                Console.WriteLine($"파일을 읽는 중 오류 발생: {ex.Message}");
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 날짜를 추출하여 yyyyMMdd 형식으로 변환
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 파일 이름의 마지막 두 글자를 날짜로 사용
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도와 월을 yyyyMM 형식으로 가져옴
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 날짜 조합

            // "PLAN Selected" 라인을 감지했을 때 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 분리하여 제품 주문 번호를 가져옴
                string productOrder = splitLine[1]; // 두 번째 값이 제품 주문 번호

                // 새로운 주문이거나 다른 주문일 경우 처리
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    // 최근 2일 이내에 PLAN Selected가 감지되지 않은 경우 처리
                    if (DateTime.Now.Subtract(_lastPlanSelectedDate).TotalDays > 2)
                    {
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder,
                            PDate = fullDate, // yyyyMMdd 형식으로 날짜 설정
                            POStatus = "wait" // 주문 상태를 "대기(wait)"로 설정
                        };
                        _productOrders.Add(_currentProductOrder); // 새로운 주문을 목록에 추가
                    }

                    // 마지막 PLAN Selected 감지 시간을 현재 시간으로 업데이트
                    _lastPlanSelectedDate = DateTime.Now;
                }
            }
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                var modelData = line.Split(':')[1].Trim(); // BasicModel 데이터를 추출
                _currentProductOrder.BasicModel = modelData; // 모델 데이터 저장
            }
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                var mbData = line.Split('^'); // MB^ 데이터를 처리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 설정
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 수량 설정
            }
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가
            }
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "stack"; // 상태를 "적재(stack)"로 변경
            }
            else if (line.Contains("JD^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "out"; // 상태를 "배출(out)"로 변경
                ExecuteOutFunction(); // 배출 처리 호출
            }
        }

        // 배출 처리를 위한 메소드
        private void ExecuteOutFunction()
        {
            // 배출 처리 로직 구현
        }
    }

    // ProductOrderModel 클래스: 제품 주문 정보를 저장하는 모델 클래스
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; } // 제품 주문 번호
        public string BasicModel { get; set; } // 제품 모델 정보
        public int PORemain { get; set; } // 잔여 수량
        public int MGCount { get; set; } // 매거진 당 제품 수량
        public int PCount { get; set; } // 생산된 제품 개수
        public string POStatus { get; set; } // 주문 상태 (대기, 적재, 배출 등)
        public string PDate { get; set; } // 제품 주문 날짜 (yyyyMMdd 형식)
    }
}
핵심 설명:
처음 실행 시:

FindLastPlanSelected 메소드에서 파일을 처음부터 끝까지 읽으면서 PLAN Selected가 마지막으로 등장하는 지점을 찾습니다.
이때, 마지막 PLAN Selected가 등장하는 **파일의 위치(_lastPlanSelectedPosition)**를 저장합니다.
이후, 그 위치부터 파일의 나머지 부분을 실시간으로 감시합니다.
실시간 감시:

ReadLogFileFromPosition 메소드를 통해, 마지막 PLAN Selected 이후부터 새로운 로그가 추가되면 그때부터 실시간으로 변경 사항을 감시합니다.
새로운 로그가 감지되면 ProcessLogLine 메소드에서 각 줄을 처리합니다.
파일 읽기 모드:

읽기-쓰기 공유 모드로 파일을 열어서 다른 프로세스가 파일을 쓰고 있을 때도 읽을 수 있도록 처리했습니다.
이제 로그 파일에서 PLAN Selected가 마지막으로 등장하는 지점을 기준으로 이후 로그 파일을 실시간으로 감시하고 처리하는 구조로 구현되었습니다.