아래는 수정된 전체 코드입니다. 데이터 결합에서 문제가 발생했던 부분을 수정했으며, np.concatenate를 통해 데이터를 **가로 방향(열)**으로 결합하도록 변경했습니다. 또한, 데이터 형태와 구조를 확인할 수 있도록 디버깅 출력을 추가했습니다.

수정된 전체 코드
python
코드 복사
import numpy as np
import pandas as pd
import pymssql
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from tqdm import tqdm


# 1. 데이터베이스에서 데이터 가져오기 함수
def fetch_data_from_procedure_with_cursor(proc_name, connection_details):
    """
    MSSQL 저장 프로시저를 호출하여 데이터를 가져오는 함수.
    커서를 사용하여 결과를 Pandas DataFrame으로 반환.
    
    :param proc_name: 저장 프로시저 이름 (str).
    :param connection_details: 데이터베이스 연결 정보 (dict).
    :return: Pandas DataFrame.
    """
    print(f"Calling stored procedure: {proc_name}")
    try:
        # 데이터베이스 연결
        conn = pymssql.connect(
            server=connection_details['server'],
            user=connection_details['user'],
            password=connection_details['password'],
            database=connection_details['database']
        )
        cursor = conn.cursor()

        # 저장 프로시저 실행
        cursor.execute(f"EXEC {proc_name}")

        # 결과를 DataFrame으로 변환
        columns = [desc[0] for desc in cursor.description]
        data = cursor.fetchall()
        df = pd.DataFrame(data, columns=columns)

        print(f"Data successfully fetched from procedure: {proc_name}")
        return df

    except Exception as e:
        print(f"Error while calling procedure {proc_name}: {e}")
        return pd.DataFrame()

    finally:
        conn.close()


# 2. DB 연결 정보
connection_details = {
    "server": "localhost",
    "user": "your_username",
    "password": "your_password",
    "database": "your_database"
}

# 3. 데이터 가져오기
print("Fetching data from stored procedures...")
df_test_a = fetch_data_from_procedure_with_cursor("PTestA", connection_details)
df_test_b = fetch_data_from_procedure_with_cursor("PTestB", connection_details)
df_real_a = fetch_data_from_procedure_with_cursor("PRealA", connection_details)
df_real_b = fetch_data_from_procedure_with_cursor("PRealB", connection_details)

# 4. 데이터 준비
if df_test_a.empty or df_test_b.empty or df_real_a.empty or df_real_b.empty:
    print("Error: One or more datasets are empty. Check the stored procedures.")
    exit()

# 데이터에서 첫 열(날짜/시간)을 제외한 나머지 값만 추출
data_a = df_test_a.iloc[:, 1:].values
data_b = df_test_b.iloc[:, 1:].values

# 데이터를 가로 방향(열)으로 결합
data = np.concatenate([data_a, data_b], axis=1)
print(f"Data shape after concatenation: {data.shape}")

# Real 데이터도 동일하게 준비
real_a = df_real_a.iloc[:, 1:].values
real_b = df_real_b.iloc[:, 1:].values
real_data = np.concatenate([real_a, real_b], axis=1)

# 5. 모델 리스트 정의
models = {
    "RandomForest": RandomForestRegressor(),
    "LinearRegression": LinearRegression(),
    "SVR": SVR(kernel="linear")
}

# 6. 최적 모델 찾기
print("Starting model training and evaluation...")
best_models = []
errors = []

for i in tqdm(range(data.shape[1]), desc="Training models for each data point"):
    try:
        # i번째 값을 제외한 나머지 데이터로 학습 데이터 구성
        X = np.delete(data, i, axis=1)  # i번째 열을 제외
        y = data[:, i]  # 예측 대상

        print(f"Training model for data point {i + 1}/{data.shape[1]}...")

        # 데이터 분리 및 학습
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

        # 각 모델로 학습 및 평가
        best_model = None
        best_error = float("inf")
        for model_name, model in models.items():
            model.fit(X_train, y_train)
            predictions = model.predict(X_test)
            error = mean_squared_error(y_test, predictions)

            print(f"Model: {model_name}, MSE: {error:.5f}")
            if error < best_error:
                best_error = error
                best_model = model_name

        print(f"Best model for data point {i + 1}: {best_model} with MSE: {best_error:.5f}")
        best_models.append(best_model)
        errors.append(best_error)

    except Exception as e:
        print(f"Error during training for data point {i}: {e}")
        raise

print("Model training and evaluation completed.")

# 7. 실시간 모니터링
print("Starting real-time monitoring...")
avg_errors = []

for sample_idx, sample in enumerate(tqdm(real_data, desc="Monitoring real-time data")):
    try:
        print(f"Processing real-time sample {sample_idx + 1}/{real_data.shape[0]}...")
        sample_errors = []

        for i, model_name in enumerate(best_models):
            model = models[model_name]
            X_sample = np.delete(sample, i).reshape(1, -1)  # i번째 값을 제외
            y_sample = sample[i]

            prediction = model.predict(X_sample)
            error = abs(prediction - y_sample)
            sample_errors.append(error)

            print(f"Data point {i + 1}: Predicted={prediction[0]:.5f}, Actual={y_sample:.5f}, Error={error[0]:.5f}")

        avg_error = np.mean(sample_errors)
        avg_errors.append(avg_error)

        print(f"Average error for sample {sample_idx + 1}: {avg_error:.5f}")

    except Exception as e:
        print(f"Error during monitoring for sample {sample_idx}: {e}")
        raise

print("Real-time monitoring completed.")

# 8. 평균 오차의 변화 시각화
plt.plot(avg_errors, label="Average Prediction Error")
plt.xlabel("Sample Index")
plt.ylabel("Average Error")
plt.legend()
plt.title("Real-time Monitoring of Prediction Errors")
plt.show()
변경 및 수정된 주요 내용
데이터 결합 방식 변경

데이터를 **가로 방향(열)**으로 결합하도록 np.concatenate에서 axis=1 설정.
np.delete 수정

np.delete(data, i, axis=1)로 열 삭제 처리.
axis=1을 명시하여 열 방향으로 데이터를 처리.
디버깅 출력 추가

데이터의 형태(.shape)와 구조를 중간중간 출력하여 디버깅이 용이하도록 추가.
실시간 모니터링

np.delete(sample, i)를 사용해 실시간 데이터에서 예측 대상 제외.
예상 출력
모델 학습 시:
plaintext
코드 복사
Data shape after concatenation: (4, 8)
Training models for each data point: 100%|██████████| 8/8 [00:10<00:00,  1.25s/it]
Best model for data point 1: RandomForest with MSE: 0.01234
...
실시간 모니터링:
plaintext
코드 복사
Monitoring real-time data: 100%|██████████| 10/10 [00:05<00:00,  2.00s/it]
Processing real-time sample 1/10...
Data point 1: Predicted=0.23456, Actual=0.23000, Error=0.00456
...
추가 검토