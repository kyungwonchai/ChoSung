 구조를 요약하면:

기본 루트 폴더는 예: C:\abc

그 하위 폴더들 중 하나에 SM-으로 시작하는 폴더가 존재
→ 즉, C:\abc\*\SM-xxxx 형식

SM- 폴더의 바로 하위 폴더 중 " - GH-"가 포함된 이름을 찾음

" - GH-" 앞 문자열을 중복 없이 출력

개선된 전체 코드 (성능 최적화 & 상세 주석 포함)
python
코드 복사
import os

def find_unique_prefixes(base_path):
    result_set = set()  # 중복 제거용 set

    # base_path의 바로 아래 폴더들만 검색 (1단계 깊이)
    try:
        first_level_folders = os.listdir(base_path)
    except Exception as e:
        print(f"기본 경로 접근 실패: {base_path}, 오류: {e}")
        return

    for folder_name in first_level_folders:
        folder_path = os.path.join(base_path, folder_name)

        # 해당 경로가 폴더인지 확인
        if not os.path.isdir(folder_path):
            continue

        # 이 폴더 안에 SM-으로 시작하는 폴더가 있는지 확인
        try:
            sub_folders = os.listdir(folder_path)
        except Exception as e:
            print(f"하위 폴더 접근 실패: {folder_path}, 오류: {e}")
            continue

        for sub_name in sub_folders:
            # SM-으로 시작하는 폴더만 대상
            if sub_name.startswith("SM-"):
                sm_folder_path = os.path.join(folder_path, sub_name)

                # SM-폴더 내부 확인
                try:
                    sm_inner_folders = os.listdir(sm_folder_path)
                except Exception as e:
                    print(f"SM-폴더 접근 실패: {sm_folder_path}, 오류: {e}")
                    continue

                for inner_name in sm_inner_folders:
                    inner_path = os.path.join(sm_folder_path, inner_name)

                    if os.path.isdir(inner_path) and " - GH-" in inner_name:
                        # " - GH-" 앞의 문자열 추출
                        prefix = inner_name.split(" - GH-")[0].strip()
                        result_set.add(prefix)

    # 결과 출력
    print("=== 결과 (중복 제거됨) ===")
    for item in sorted(result_set):
        print(item)

# 실제 사용 경로 입력
find_unique_prefixes(r"C:\abc")
요약 흐름
makefile
코드 복사
C:\abc
  ├─ A
  │   └─ SM-xxxx
  │       └─ A123 - GH-ZZ99
  ├─ B
  │   └─ SM-yyyy
  │       └─ B987 - GH-ABCD
→ 위 구조에서 A123, B987을 중복 없이 추출