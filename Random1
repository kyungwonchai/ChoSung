using LockerManagementApp.Data; // DbContext 네임스페이스
using LockerManagementApp.Models; // Model 네임스페이스
using LockerManagementApp.Infrastructure; // ViewModelBase, RelayCommand 네임스페이스
using System;
using System.Collections.ObjectModel; // ObservableCollection 사용
using System.ComponentModel; // INotifyPropertyChanged (ViewModelBase에 구현됨)
using System.Data.Entity; // EntityState, ToListAsync 등 EF6 네임스페이스
using System.Data.Entity.Infrastructure; // DbEntityEntry 사용
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // MessageBox 사용
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터(층, 구역, 소파트, 관리자, 사물함 종류)를 관리하는 ViewModel 클래스입니다.
    /// CRUD 작업 및 이름 변경 시 연쇄 업데이트 기능을 포함합니다.
    /// </summary>
    public class MasterDataViewModel : ViewModelBase
    {
        private readonly LockerDbContext _context; // 데이터베이스 컨텍스트

        #region Observable Collections (UI 바인딩용)
        // 각 마스터 데이터 목록을 담는 ObservableCollection
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        #endregion

        #region Selected Item Properties
        // 사용자가 각 그리드/리스트에서 선택한 항목을 저장하는 속성
        // 여러 그리드를 관리하므로 object 타입으로 하거나, 각 타입별 속성을 만들 수 있습니다.
        // 여기서는 간단히 object 타입으로 하고, CommandParameter를 사용하여 구분합니다.
        private object _selectedItem;
        public object SelectedItem
        {
            get => _selectedItem;
            set => SetProperty(ref _selectedItem, value);
        }
        #endregion

        #region Status Message Property
        // 작업 상태를 표시하기 위한 메시지 속성
        private string _statusMessage;
        public string StatusMessage
        {
            get => _statusMessage;
            set => SetProperty(ref _statusMessage, value);
        }
        #endregion

        #region Commands
        // UI와 바인딩될 Command 속성들
        public ICommand LoadAllMasterDataCommand { get; } // 모든 마스터 데이터 새로고침
        public ICommand AddItemCommand { get; }          // 새 항목 추가
        public ICommand DeleteItemCommand { get; }       // 선택 항목 삭제
        public ICommand SaveChangesCommand { get; }     // 변경 사항 저장 (연쇄 업데이트 포함)
        #endregion

        /// <summary>
        /// MasterDataViewModel 생성자
        /// </summary>
        /// <param name="context">주입받거나 생성된 LockerDbContext 인스턴스</param>
        public MasterDataViewModel(LockerDbContext context)
        {
            _context = context ?? throw new ArgumentNullException(nameof(context));

            // ObservableCollection 초기화
            LockerTypes = new ObservableCollection<LockerType>();
            Floors = new ObservableCollection<Floor>();
            Zones = new ObservableCollection<Zone>();
            SubParts = new ObservableCollection<SubPart>();
            Administrators = new ObservableCollection<Administrator>();

            // Command 초기화
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItem); // CanExecute 조건 추가 가능
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItem); // CanExecute 조건 추가
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync());

            // 생성 시 데이터 로드
            _ = LoadAllMasterDataAsync();
        }

        /// <summary>
        /// 모든 마스터 데이터를 데이터베이스에서 비동기적으로 로드합니다.
        /// </summary>
        public async Task LoadAllMasterDataAsync()
        {
            StatusMessage = "마스터 데이터 로딩 중...";
            try
            {
                // 각 마스터 데이터 목록을 DB에서 가져와 ObservableCollection에 채웁니다.
                // Clear 후 AddRange 방식 또는 새 인스턴스 할당 방식 사용 가능
                var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).ToListAsync();
                LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add);

                var floors = await _context.Floors.OrderBy(x => x.Name).ToListAsync();
                Floors.Clear(); floors.ForEach(Floors.Add);

                var zones = await _context.Zones.OrderBy(x => x.Name).ToListAsync();
                Zones.Clear(); zones.ForEach(Zones.Add);

                var subParts = await _context.SubParts.OrderBy(x => x.Name).ToListAsync();
                SubParts.Clear(); subParts.ForEach(SubParts.Add);

                var administrators = await _context.Administrators.OrderBy(x => x.Name).ToListAsync();
                Administrators.Clear(); administrators.ForEach(Administrators.Add);

                StatusMessage = "마스터 데이터 로드 완료.";
            }
            catch (Exception ex)
            {
                StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}";
                MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        #region Add/Delete Logic

        /// <summary>
        /// 새 항목 추가 가능 여부 (CommandParameter로 카테고리 문자열을 받는다고 가정)
        /// </summary>
        private bool CanAddItem(object parameter) => parameter is string category && !string.IsNullOrEmpty(category);

        /// <summary>
        /// 지정된 카테고리에 새 항목을 추가합니다 (UI 및 DbContext에).
        /// </summary>
        private void AddItem(object parameter)
        {
            if (parameter is string category)
            {
                try
                {
                    // 새 엔티티를 생성하고 DbContext와 ObservableCollection 양쪽에 추가합니다.
                    switch (category.ToLower())
                    {
                        case "lockertype":
                            var newType = _context.LockerTypes.Add(new LockerType { Name = "새 종류" });
                            LockerTypes.Add(newType);
                            SelectedItem = newType; // 새로 추가된 항목 선택
                            break;
                        case "floor":
                            var newFloor = _context.Floors.Add(new Floor { Name = "새 층" });
                            Floors.Add(newFloor);
                            SelectedItem = newFloor;
                            break;
                        case "zone":
                            var newZone = _context.Zones.Add(new Zone { Name = "새 구역" });
                            Zones.Add(newZone);
                            SelectedItem = newZone;
                            break;
                        case "subpart":
                            var newSubPart = _context.SubParts.Add(new SubPart { Name = "새 소파트" });
                            SubParts.Add(newSubPart);
                            SelectedItem = newSubPart;
                            break;
                        case "administrator":
                            var newAdmin = _context.Administrators.Add(new Administrator { Name = "새 관리자" });
                            Administrators.Add(newAdmin);
                            SelectedItem = newAdmin;
                            break;
                        default:
                            MessageBox.Show("알 수 없는 카테고리입니다.", "오류");
                            return;
                    }
                    StatusMessage = "새 항목이 추가되었습니다. 이름 수정 후 저장하세요.";
                }
                catch (Exception ex)
                {
                    StatusMessage = $"항목 추가 중 오류: {ex.Message}";
                    MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                }
            }
        }

        /// <summary>
        /// 선택된 항목 삭제 가능 여부
        /// </summary>
        private bool CanDeleteItem(object parameter) => SelectedItem != null;

        /// <summary>
        /// 선택된 항목을 삭제합니다 (UI 및 DbContext에서).
        /// </summary>
        private void DeleteItem(object parameter)
        {
            if (SelectedItem == null) return;

            // 중요: 삭제하기 전에 이 마스터 데이터를 사용하는 LockerAssignment가 있는지 확인하는 로직 추가 권장
            // 예: if (SelectedItem is SubPart sp) { var assignments = _context.LockerAssignments.FirstOrDefault(a => a.SubPart == sp.Name); if (assignments != null) { /* 삭제 불가 메시지 */ return; } }

            if (MessageBox.Show("선택된 항목을 삭제하시겠습니까?\n(이 항목을 사용하는 사물함 정보가 있다면 문제가 발생할 수 있습니다.)", "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                try
                {
                    // DbContext에서 엔티티를 제거 대상으로 표시하고, ObservableCollection에서도 제거합니다.
                    if (SelectedItem is LockerType lt) { _context.LockerTypes.Remove(lt); LockerTypes.Remove(lt); }
                    else if (SelectedItem is Floor f) { _context.Floors.Remove(f); Floors.Remove(f); }
                    else if (SelectedItem is Zone z) { _context.Zones.Remove(z); Zones.Remove(z); }
                    else if (SelectedItem is SubPart sp) { _context.SubParts.Remove(sp); SubParts.Remove(sp); }
                    else if (SelectedItem is Administrator ad) { _context.Administrators.Remove(ad); Administrators.Remove(ad); }
                    else { return; } // 알 수 없는 타입

                    SelectedItem = null; // 선택 해제
                    StatusMessage = "항목이 삭제 대기 상태입니다. '마스터 데이터 저장' 시 최종 반영됩니다.";
                }
                catch (Exception ex)
                {
                    StatusMessage = $"항목 삭제 중 오류: {ex.Message}";
                    MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    // 오류 발생 시 UI와 DB 상태 동기화를 위해 목록을 다시 로드하는 것이 좋을 수 있음
                    _ = LoadAllMasterDataAsync();
                }
            }
        }

        #endregion

        #region Save Changes Logic (Including Cascade Update)

        /// <summary>
        /// 마스터 데이터의 변경 사항(추가, 수정, 삭제)을 데이터베이스에 저장합니다.
        /// 이름(Name)이 변경된 경우, 관련된 LockerAssignment 레코드도 연쇄적으로 업데이트합니다.
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            StatusMessage = "마스터 데이터 저장 중...";

            // 트랜잭션을 사용하여 마스터 데이터 변경과 연쇄 업데이트를 원자적으로 처리합니다.
            using (var transaction = _context.Database.BeginTransaction())
            {
                try
                {
                    // 1. 이름이 변경된 마스터 데이터 항목들을 찾습니다.
                    var modifiedNameEntries = _context.ChangeTracker.Entries()
                        .Where(e => e.State == EntityState.Modified &&
                                    (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator))
                        .Select(e => new // 필요한 정보만 추출
                        {
                            Entry = e,
                            OriginalName = e.OriginalValues["Name"]?.ToString(), // 원본 이름
                            CurrentName = e.CurrentValues["Name"]?.ToString()   // 현재(수정된) 이름
                        })
                        .Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName) // 이름이 실제로 변경된 항목만 필터링
                        .ToList(); // 즉시 실행하여 리스트로 만듭니다.

                    // 2. 각 이름 변경 건에 대해 연쇄 업데이트 SQL을 실행합니다.
                    foreach (var modified in modifiedNameEntries)
                    {
                        StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중...";
                        int updatedCount = 0;
                        string updateSql = "";
                        string targetColumn = "";

                        // 엔티티 타입에 따라 업데이트할 컬럼과 SQL 결정
                        if (modified.Entry.Entity is LockerType) targetColumn = "LockerType";
                        else if (modified.Entry.Entity is Floor) targetColumn = "Floor";
                        else if (modified.Entry.Entity is Zone) targetColumn = "Zone";
                        else if (modified.Entry.Entity is SubPart) targetColumn = "SubPart";
                        else if (modified.Entry.Entity is Administrator) targetColumn = "Administrator";

                        if (!string.IsNullOrEmpty(targetColumn))
                        {
                            // SQL Injection 방지를 위해 파라미터화된 쿼리 사용
                            updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}";
                            updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName);
                            StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 사물함 정보 업데이트 완료).";
                            System.Diagnostics.Debug.WriteLine($"Executed: {updateSql} with params '{modified.CurrentName}', '{modified.OriginalName}'. Rows affected: {updatedCount}");
                        }
                    }

                    // 3. 모든 변경 사항(마스터 데이터 추가/수정/삭제 및 연쇄 업데이트)을 DB에 저장합니다.
                    //    로그 기록은 DbContext의 SaveChanges 오버라이드에서 처리됩니다.
                    int masterDataChanges = await _context.SaveChangesAsync();

                    // 4. 트랜잭션을 커밋합니다.
                    transaction.Commit();
                    StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다.";

                    // 5. 메인 ViewModel의 콤보박스용 마스터 데이터 목록도 갱신해야 함
                    //    (가장 간단한 방법은 MainViewModel의 LoadMasterDataAsync를 다시 호출하는 것)
                    //    이벤트 기반 방식(메신저 패턴 등)이 더 좋음
                    //    예: WeakReferenceMessenger.Default.Send(new MasterDataChangedMessage());
                }
                catch (Exception ex)
                {
                    // 6. 오류 발생 시 트랜잭션을 롤백합니다.
                    transaction.Rollback();
                    StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}";
                    MessageBox.Show($"{StatusMessage}\n\n{ex.ToString()}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);

                    // 오류 발생 시 컨텍스트의 변경 내용을 되돌리는 것이 좋습니다.
                    // (간단한 방법: 모든 변경된 엔트리 상태를 Unchanged로 설정하거나 Detached)
                    var errorEntries = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged && e.State != EntityState.Detached);
                    foreach (var entry in errorEntries.ToList())
                    {
                        entry.Reload(); // DB 값으로 다시 로드 (주의: UI 변경과 충돌 가능성)
                        // 또는 entry.State = EntityState.Unchanged;
                    }
                }
            }

            // 7. 작업 완료 후 (성공/실패 무관) 마스터 데이터 목록을 다시 로드하여 UI를 최신 상태로 유지합니다.
            await LoadAllMasterDataAsync();
        }

        #endregion
    }
}
```

**주요 구현 내용:**

* **생성자:** `LockerDbContext`를 받고 각 마스터 데이터 목록(`ObservableCollection`)을 초기화합니다. Command들을 설정하고 초기 데이터를 로드합니다.
* **`LoadAllMasterDataAsync`:** 각 마스터 테이블에서 데이터를 비동기적으로 로드하여 해당 `ObservableCollection`을 업데이트합니다.
* **`AddItem` / `DeleteItem`:** 사용자가 UI에서 선택한 카테고리 또는 항목에 대해 추가/삭제 작업을 수행합니다. 실제 DB 반영은 `SaveChangesCommand` 실행 시 이루어집니다. (삭제 전 연관 데이터 확인 로직 추가 권장)
* **`SaveMasterDataChangesAsync`:**
    * `DbContext.Database.BeginTransaction()`을 사용하여 트랜잭션을 시작합니다.
    * `ChangeTracker`를 사용하여 이름(`Name` 속성)이 변경된 마스터 데이터 엔티티를 찾습니다.
    * 변경된 각 항목에 대해, 해당 마스터 데이터를 사용하는 `LockerAssignments` 테이블의 레코드를 업데이트하는 SQL(`UPDATE ... SET ... WHERE ...`)을 `ExecuteSqlCommandAsync`를 사용하여 실행합니다. (SQL Injection 방지를 위해 파라미터화)
    * 모든 연쇄 업데이트 SQL 실행 후, `_context.SaveChangesAsync()`를 호출하여 마스터 데이터 자체의 변경(추가/수정/삭제)과 로그 기록을 수행합니다.
    * 성공 시 `transaction.Commit()`, 실패 시 `transaction.Rollback()`을 호출합니다.
    * 작업 완료 후 목록을 다시 로드합니다.