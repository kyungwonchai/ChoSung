import os
import esprima  # 자바스크립트/리액트 코드 분석용 라이브러리

# --- 설정 (이 부분만 수정하세요) ---

# 1. 분석할 리액트 프로젝트 폴더 경로
PROJECT_PATH = r"C:\path\to\your\react\project"

# 2. 결과가 저장될 파일 이름
OUTPUT_FILENAME = "_summary_preprocessed.txt"

# --- 메인 코드 (수정할 필요 없음) ---

def extract_meaningful_info(file_path: str, file_content: str) -> str:
    """
    AST(Abstract Syntax Tree)를 사용해 코드에서 의미 있는 정보만 추출합니다.
    """
    meaningful_parts = []
    
    try:
        # 코드를 AST로 파싱, 주석(comment)도 함께 추출하도록 설정
        ast = esprima.parseScript(file_content, {
            'jsx': True, 
            'comment': True, 
            'tolerant': True # 사소한 문법 오류는 무시
        })

        # 1. 주석 추출
        if ast.comments:
            meaningful_parts.append("### 주석 ###")
            for comment in ast.comments:
                meaningful_parts.append(comment.value.strip())
            meaningful_parts.append("-" * 20)

        # 2. 함수/클래스 정의 및 UI 텍스트 추출을 위한 재귀 함수
        def traverse(node):
            if not node or not hasattr(node, 'type'):
                return

            # 함수 선언문 추출 (예: function MyComponent() { ... })
            if node.type == 'FunctionDeclaration' and node.id:
                meaningful_parts.append(f"### 함수: {node.id.name} ###")
            
            # 변수에 할당된 화살표 함수 컴포넌트 추출 (예: const MyComponent = () => { ... })
            if node.type == 'VariableDeclarator' and node.init and node.init.type == 'ArrowFunctionExpression':
                if hasattr(node.id, 'name'):
                    meaningful_parts.append(f"### 컴포넌트: {node.id.name} ###")

            # 클래스 컴포넌트 추출 (예: class MyComponent extends React.Component { ... })
            if node.type == 'ClassDeclaration' and node.id:
                 meaningful_parts.append(f"### 클래스: {node.id.name} ###")

            # JSX 내부의 텍스트 추출 (사용자가 보는 UI 텍스트)
            if node.type == 'JSXText':
                text = node.value.strip()
                if text:
                    meaningful_parts.append(f"UI 텍스트: \"{text}\"")
            
            # 하위 노드들을 계속 탐색
            for key, value in node.to_dict().items():
                if isinstance(value, dict):
                    traverse(esprima.nodes.Node(value))
                elif isinstance(value, list):
                    for item in value:
                        if isinstance(item, dict):
                            traverse(esprima.nodes.Node(item))
        
        traverse(ast)

    except Exception as e:
        # AST 파싱 실패 시 (예: 문법 오류가 심한 파일), 원본 내용을 그대로 사용하되 경고 표시
        print(f"    - 경고: '{file_path}' 파싱 실패. 원본 내용을 사용합니다. (오류: {e})")
        return file_content

    return "\n".join(meaningful_parts)


def preprocess_react_project(project_path: str, output_filename: str):
    """
    프로젝트 폴더에서 의미 있는 정보만 추출하여 하나의 텍스트 파일로 합칩니다.
    """
    if not os.path.isdir(project_path):
        print(f"오류: '{project_path}'는 유효한 폴더가 아닙니다.")
        return

    print(f"'{project_path}' 폴더에서 지능형 전처리를 시작합니다...")
    
    all_meaningful_content = []
    
    target_code_extensions = ['.js', '.jsx', 'ts', '.tsx']
    target_text_extensions = ['.md', '.txt']
    ignore_items = ['node_modules', '.git', 'build', 'dist', 'public', 'package-lock.json']

    for root, dirs, files in os.walk(project_path):
        dirs[:] = [d for d in dirs if d not in ignore_items]
        
        for file in files:
            if file in ignore_items:
                continue
            
            file_path = os.path.join(root, file)
            relative_path = os.path.relpath(file_path, project_path)
            header = f"\n\n--- 파일: {relative_path} ---\n"
            
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    
                    # 코드 파일인 경우, 의미 있는 정보 추출
                    if any(file.endswith(ext) for ext in target_code_extensions):
                        meaningful_content = extract_meaningful_info(file_path, content)
                        if meaningful_content: # 추출된 내용이 있을 때만 추가
                             all_meaningful_content.append(header + meaningful_content)
                    
                    # 텍스트 파일인 경우, 내용 전체를 추가
                    elif any(file.endswith(ext) for ext in target_text_extensions):
                        all_meaningful_content.append(header + content)

            except Exception as e:
                print(f"    - 경고: {file_path} 파일을 처리하는 중 오류 발생 - {e}")

    # 최종 결과를 파일에 저장
    output_path = os.path.join(project_path, output_filename)
    with open(output_path, 'w', encoding='utf-8') as f:
        f.write("\n".join(all_meaningful_content))
        
    print("\n" + "="*50)
    print("? 지능형 전처리 완료!")
    print(f"의미 있는 정보만 추출하여 아래 파일에 저장했습니다:")
    print(f"-> {output_path}")
    print("="*50)

# --- 스크립트 실행 ---
if __name__ == "__main__":
    preprocess_react_project(PROJECT_PATH, OUTPUT_FILENAME)