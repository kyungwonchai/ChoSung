하거나 버튼을 눌렀을 때 각각 다른 타이머로 창이 다시 열리도록 설정하겠습니다:

창을 클릭하여 닫을 때: 2초 후에 메시지가 남아 있으면 다시 열립니다.
버튼을 눌러서 닫을 때: 10초 후에 메시지가 남아 있으면 다시 열립니다.
각 타이머를 독립적으로 설정하여 이 요구 사항을 충족하도록 수정하겠습니다.

수정된 MainViewModelPop1 코드
두 개의 타이머 (_reopenTimerPop1ForClick와 _reopenTimerPop1ForButton)를 추가하고, 각 상황에 맞게 설정하겠습니다.

csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media;
using System.Timers;

namespace YourNamespace
{
    public class MainViewModelPop1 : INotifyPropertyChanged
    {
        public event Action<string, bool> ErrorTriggeredPop1;

        private WarningWindowPop1 _warningWindowPop1;
        private ObservableCollection<ErrorMessagePop1> _errorMessagesPop1;
        private bool _isWarningWindowOpen;

        // 두 가지 상황을 위한 타이머
        private System.Timers.Timer _reopenTimerPop1ForClick; // 창 클릭 시 2초 타이머
        private System.Timers.Timer _reopenTimerPop1ForButton; // 버튼 클릭 시 10초 타이머

        public MainViewModelPop1()
        {
            _errorMessagesPop1 = new ObservableCollection<ErrorMessagePop1>();
            ErrorTriggeredPop1 += HandleErrorEventPop1;

            // 창 클릭 후 2초 타이머 설정
            _reopenTimerPop1ForClick = new System.Timers.Timer(2000);
            _reopenTimerPop1ForClick.Elapsed += ReopenTimerElapsedPop1ForClick;
            _reopenTimerPop1ForClick.AutoReset = false;

            // 버튼 클릭 후 10초 타이머 설정
            _reopenTimerPop1ForButton = new System.Timers.Timer(10000);
            _reopenTimerPop1ForButton.Elapsed += ReopenTimerElapsedPop1ForButton;
            _reopenTimerPop1ForButton.AutoReset = false;
        }

        private void HandleErrorEventPop1(string message, bool isAdd)
        {
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                if (isAdd)
                {
                    AddErrorMessagePop1(message);
                }
                else
                {
                    RemoveErrorMessagePop1(message);
                }
            });
        }

        private void AddErrorMessagePop1(string message)
        {
            Debug.WriteLine($"[DEBUG] Attempting to add message: {message}");

            if (_errorMessagesPop1.Any(m => m.ContentPop1 == message))
            {
                Debug.WriteLine($"[DEBUG] Duplicate message found. Skipping addition: {message}");
                return;
            }

            Color color = _errorMessagesPop1.Count % 2 == 0 ? Colors.Yellow : Colors.Aqua;
            _errorMessagesPop1.Add(new ErrorMessagePop1(message, new SolidColorBrush(color)));

            if (!_isWarningWindowOpen)
            {
                ShowWarningWindowPop1();
            }
        }

        private void RemoveErrorMessagePop1(string message)
        {
            var errorMessage = _errorMessagesPop1.FirstOrDefault(m => m.ContentPop1 == message);
            if (errorMessage != null)
            {
                _errorMessagesPop1.Remove(errorMessage);
                Debug.WriteLine($"[DEBUG] Error removed: {message}");

                if (_errorMessagesPop1.Count == 0)
                {
                    CloseWarningWindowPop1();
                }
            }
        }

        private void ShowWarningWindowPop1()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                _warningWindowPop1 = new WarningWindowPop1(_errorMessagesPop1, this);
                _warningWindowPop1.Topmost = true;
                _warningWindowPop1.Show();

                _warningWindowPop1.Closed += (sender, e) =>
                {
                    _isWarningWindowOpen = false;
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed");
                };

                _isWarningWindowOpen = true;
                Debug.WriteLine("[DEBUG] Warning window shown");
            });
        }

        // 창을 클릭하여 닫을 때 2초 후 다시 열림
        public void HideWarningWindowForClick()
        {
            CloseWarningWindowPop1();
            _reopenTimerPop1ForClick.Start(); // 창 클릭 시 2초 타이머 시작
        }

        // 버튼을 눌러서 닫을 때 10초 후 다시 열림
        public void HideWarningWindowForButton()
        {
            CloseWarningWindowPop1();
            _reopenTimerPop1ForButton.Start(); // 버튼 클릭 시 10초 타이머 시작
        }

        private void ReopenTimerElapsedPop1ForClick(object sender, ElapsedEventArgs e)
        {
            // 2초 후 메시지가 남아 있는지 확인하여 창 다시 열기
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessagesPop1.Count > 0 && !_isWarningWindowOpen)
                {
                    Debug.WriteLine("[DEBUG] Reopening warning window after 2 seconds.");
                    ShowWarningWindowPop1();
                }
            });
        }

        private void ReopenTimerElapsedPop1ForButton(object sender, ElapsedEventArgs e)
        {
            // 10초 후 메시지가 남아 있는지 확인하여 창 다시 열기
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessagesPop1.Count > 0 && !_isWarningWindowOpen)
                {
                    Debug.WriteLine("[DEBUG] Reopening warning window after 10 seconds.");
                    ShowWarningWindowPop1();
                }
            });
        }

        private void CloseWarningWindowPop1()
        {
            System.Windows.Application.Current.Dispatcher.Invoke(() =>
            {
                if (_warningWindowPop1 != null)
                {
                    _warningWindowPop1.Close();
                    _warningWindowPop1 = null;
                    _isWarningWindowOpen = false;
                    Debug.WriteLine("[DEBUG] Warning window closed and messages cleared");
                }
            });
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ErrorMessagePop1
    {
        public string ContentPop1 { get; }
        public SolidColorBrush ColorPop1 { get; }

        public ErrorMessagePop1(string content, SolidColorBrush color)
        {
            ContentPop1 = content;
            ColorPop1 = color;
        }
    }
}
2. WarningWindowPop1.xaml에 버튼과 창 클릭 이벤트 추가
버튼과 창의 MouseDown 이벤트를 설정하여 각각 HideWarningWindowForButton와 HideWarningWindowForClick을 호출합니다.

WarningWindowPop1.xaml
xml
코드 복사
<Window x:Class="YourNamespace.WarningWindowPop1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WarningPop1" Height="500" Width="500"
        WindowStyle="None" AllowsTransparency="True" Background="#AAFF0000"
        ShowInTaskbar="False" Topmost="True" ResizeMode="NoResize"
        WindowStartupLocation="Manual"
        MouseDown="Window_MouseDownPop1">
    
    <Grid>
        <ScrollViewer VerticalScrollBarVisibility="Auto">
            <ItemsControl ItemsSource="{Binding ErrorMessagesPop1}">
                <ItemsControl.ItemTemplate>
                    <DataTemplate>
                        <TextBlock Text="{Binding ContentPop1}"
                                   FontSize="15"
                                   Foreground="{Binding ColorPop1}"
                                   TextAlignment="Center"
                                   VerticalAlignment="Center"
                                   HorizontalAlignment="Center"/>
                    </DataTemplate>
                </ItemsControl.ItemTemplate>
            </ItemsControl>
        </ScrollViewer>
        
        <!-- 10초 동안 경고 안 보이기 버튼 -->
        <Button Content="10초간 경고 안 보이기" 
                HorizontalAlignment="Right" 
                VerticalAlignment="Bottom" 
                Margin="10"
                Click="HideFor10SecondsButton_Click"/>
    </Grid>
</Window>
WarningWindowPop1.xaml.cs
창을 클릭하면 HideWarningWindowForClick 메서드를 호출하여 창을 2초 동안 숨기고, 버튼을 클릭하면 HideWarningWindowForButton 메서드를 호출하여 창을 10초 동안 숨깁니다.
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;

namespace YourNamespace
{
    public partial class WarningWindowPop1 : Window
    {
        private readonly MainViewModelPop1 _viewModel;

        public ObservableCollection<ErrorMessagePop1> ErrorMessagesPop1 { get; }

        public WarningWindowPop1(ObservableCollection<ErrorMessagePop1> errorMessagesPop1, MainViewModelPop1 viewModel)
        {
            InitializeComponent();
            ErrorMessagesPop1 = errorMessagesPop1;
            _viewModel = viewModel;
            DataContext = this;

            Loaded += OnWindowLoaded;
        }

        private void OnWindowLoaded(object sender, RoutedEventArgs e)
        {
            var screenWidth = SystemParameters.PrimaryScreenWidth;
            this.Left = (screenWidth - this.Width) / 2;
            this.Top = 10;
        }

        private void Window_MouseDownPop1(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            _viewModel.HideWarningWindowForClick(); // 창 클릭 시 2초 타이머 시작
            this.Close();
        }

        private void HideFor10SecondsButton_Click(object sender, RoutedEventArgs e)
        {
            _viewModel.HideWarningWindowForButton(); // 버튼 클릭 시 10초 타이머 시작
            this.Close();
        }
    }
}
설명
창 클릭 시: 창이 닫히며, 2초 후 _errorMessagesPop1에 메시지가 남아 있으면 창이 다시 열립니다.
버튼 클릭 시: 창이 닫히며, 10초 후 _errorMessagesPop1에 메시지가 남아 있으면 창이 다시 열립니다.
이제 창을 닫는 방식에 따라 지정한 시간 뒤에 창이 다시 열리도록 설정되었습니