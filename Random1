러 발생 시 WarningWindow에 메시지를 추가하고, 에러가 해결되면 메시지를 제거하며, 모든 메시지가 제거되면 창이 자동으로 닫히도록 구조를 수정하겠습니다.

구현 사항:

이벤트에 의해 에러 메시지를 추가하거나 제거합니다.
WarningWindow는 쌓인 메시지가 없으면 자동으로 닫힙니다.
메시지가 추가되면 팝업이 열리고, 메시지가 제거될 때 업데이트됩니다.
1. MainViewModel 코드 (이벤트에 따라 에러 메시지 추가 및 제거)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Timers;
using System.Windows;
using System.Windows.Media;

namespace YourNamespace
{
    public class MainViewModel : INotifyPropertyChanged
    {
        public event Action<string, bool> ErrorTriggered; // 에러 발생/해결 이벤트 (메시지, 추가 여부)

        private Timer _delayTimer; // 3초 지연 타이머
        private WarningWindow _warningWindow; // 경고창 인스턴스 저장
        private ObservableCollection<ErrorMessage> _errorMessages; // 에러 메시지 목록

        public MainViewModel()
        {
            _delayTimer = new Timer(3000);
            _delayTimer.Elapsed += DelayTimerElapsed;
            _delayTimer.AutoReset = false;

            _errorMessages = new ObservableCollection<ErrorMessage>();

            // 에러 발생/해결 이벤트 구독
            ErrorTriggered += HandleErrorEvent;
        }

        // 에러 이벤트 처리 (추가 또는 제거)
        private void HandleErrorEvent(string message, bool isAdd)
        {
            if (isAdd)
            {
                AddErrorMessage(message);
            }
            else
            {
                RemoveErrorMessage(message);
            }
        }

        private void AddErrorMessage(string message)
        {
            if (_errorMessages.Any(m => m.Content == message)) return;

            Color color = _errorMessages.Count % 2 == 0 ? Colors.Yellow : Colors.Aqua;
            _errorMessages.Add(new ErrorMessage(message, new SolidColorBrush(color)));

            if (_errorMessages.Count == 1)
            {
                ShowWarningWindow(); // 첫 메시지 추가 시 창 표시
            }
            else
            {
                UpdateWarningWindow(); // 메시지 추가 시 창 업데이트
            }

            Debug.WriteLine($"[DEBUG] Error added: {message}");
        }

        private void RemoveErrorMessage(string message)
        {
            var errorMessage = _errorMessages.FirstOrDefault(m => m.Content == message);
            if (errorMessage != null)
            {
                _errorMessages.Remove(errorMessage);
                Debug.WriteLine($"[DEBUG] Error removed: {message}");

                if (_errorMessages.Count == 0)
                {
                    CloseWarningWindow(); // 메시지가 없으면 창 닫기
                }
                else
                {
                    UpdateWarningWindow(); // 메시지 제거 시 창 업데이트
                }
            }
        }

        private void ShowWarningWindow()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _warningWindow = new WarningWindow(_errorMessages);
                _warningWindow.Topmost = true;
                _warningWindow.Show();

                _warningWindow.Closed += (sender, e) =>
                {
                    _warningWindow = null;
                    Debug.WriteLine("[DEBUG] Warning window closed");
                };

                Debug.WriteLine("[DEBUG] Warning window shown");
            });
        }

        private void UpdateWarningWindow()
        {
            if (_warningWindow != null)
            {
                _warningWindow.UpdateMessages(_errorMessages);
                Debug.WriteLine("[DEBUG] Warning window updated");
            }
        }

        private void CloseWarningWindow()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_warningWindow != null)
                {
                    _warningWindow.Close();
                    _warningWindow = null;
                    Debug.WriteLine("[DEBUG] Warning window closed and messages cleared");
                }
            });
        }

        private void DelayTimerElapsed(object sender, ElapsedEventArgs e)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessages.Count > 0)
                {
                    ShowWarningWindow();
                }
            });
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ErrorMessage
    {
        public string Content { get; }
        public SolidColorBrush Color { get; }

        public ErrorMessage(string content, SolidColorBrush color)
        {
            Content = content;
            Color = color;
        }
    }
}
ErrorTriggered 이벤트는 에러가 발생할 때 isAdd = true로 메시지를 추가하고, isAdd = false로 메시지를 제거합니다.
AddErrorMessage: 메시지를 추가하고, 처음 메시지가 들어올 경우 창을 열고, 이후 메시지는 UpdateWarningWindow를 통해 업데이트합니다.
RemoveErrorMessage: 해당 메시지를 제거하며, 마지막 메시지가 제거되면 창을 닫습니다.
ShowWarningWindow 및 CloseWarningWindow: 경고창을 열고 닫으며 로그를 남깁니다.
2. WarningWindow.xaml
여러 메시지를 표시하기 위해 ItemsControl을 사용하여 템플릿을 구성합니다.

xml
코드 복사
<Window x:Class="YourNamespace.WarningWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Warning" Height="500" Width="500"
        WindowStyle="None" AllowsTransparency="True" Background="#AAFF0000"
        ShowInTaskbar="False" Topmost="True" ResizeMode="NoResize"
        WindowStartupLocation="CenterScreen" 
        MouseDown="Window_MouseDown">
    <Grid>
        <ItemsControl ItemsSource="{Binding ErrorMessages}">
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding Content}"
                               FontSize="15"
                               Foreground="{Binding Color}"
                               TextAlignment="Center"
                               VerticalAlignment="Center"
                               HorizontalAlignment="Center"/>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>
    </Grid>
</Window>
WarningWindow.xaml.cs
경고창에서 전달된 메시지를 실시간으로 업데이트할 수 있도록 ObservableCollection을 사용합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;

namespace YourNamespace
{
    public partial class WarningWindow : Window
    {
        public ObservableCollection<ErrorMessage> ErrorMessages { get; set; } = new ObservableCollection<ErrorMessage>();

        public WarningWindow(ObservableCollection<ErrorMessage> errorMessages)
        {
            InitializeComponent();
            ErrorMessages = errorMessages;
            DataContext = this;
        }

        public void UpdateMessages(ObservableCollection<ErrorMessage> errorMessages)
        {
            ErrorMessages.Clear();
            foreach (var message in errorMessages)
            {
                ErrorMessages.Add(message);
            }
        }

        private void Window_MouseDown(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            this.Close(); // 클릭하면 창 닫기
        }
    }
}
3. 외부 클래스에서 이벤트를 통한 에러 발생 및 해제
외부 클래스에서 MainViewModel의 이벤트를 통해 에러를 발생시키고, 해제합니다.

csharp
코드 복사
namespace YourNamespace
{
    public class SampleErrorTrigger
    {
        public event Action<string, bool> OnError; // 에러 메시지 이벤트 (메시지, 추가 여부)

        public void TriggerError(string message)
        {
            OnError?.Invoke(message, true); // 에러 발생
        }

        public void ResolveError(string message)
        {
            OnError?.Invoke(message, false); // 에러 해결
        }
    }
}
MainWindow에서 이벤트 연결
SampleErrorTrigger의 OnError 이벤트를 MainViewModel의 ErrorTriggered에 연결하여 에러 메시지가 추가되거나 제거될 때마다 창을 자동으로 제어합니다.

csharp
코드 복사
using System.Windows;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private MainViewModel _viewModel;
        private SampleErrorTrigger _errorTrigger;

        public MainWindow()
        {
            InitializeComponent();
            _viewModel = new MainViewModel();
            DataContext = _viewModel;

            _errorTrigger = new SampleErrorTrigger();
            _errorTrigger.OnError += _viewModel.ErrorTriggered; // 이벤트 연결
        }

        private void OnAddErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTrigger.TriggerError("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
            _errorTrigger.TriggerError("Warning!\nNetwork connection lost.\nAttempting to reconnect...");
        }

        private void OnResolveErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTrigger.ResolveError("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
        }
    }
}
이제 OnAddErrorMessageClicked 버튼을 눌러 에러를 발생시키고, OnResolveErrorMessageClicked 버튼을 눌러 특정 에러 메시지를 제거할 수 있습니다.






나의 말:
모든 변수명이나 클라스에 pop1을 덧대서 써줘 햇갈리니까 timer는 네임스페이스까지 명시해서 붙이고 해서 싹다시줘바
ChatGPT의 말:
ChatGPT
변수명과 클래스명에 pop1을 붙여 혼동을 줄이도록 하겠습니다. System.Timers.Timer를 명시적으로 사용하고, 변수와 클래스명을 구분하기 쉽게 일관되게 수정한 코드를 제공합니다.

1. MainViewModelPop1 코드 (이벤트에 따라 에러 메시지 추가 및 제거)
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Diagnostics;
using System.Linq;
using System.Runtime.CompilerServices;
using System.Windows;
using System.Windows.Media;
using System.Timers;

namespace YourNamespace
{
    public class MainViewModelPop1 : INotifyPropertyChanged
    {
        public event Action<string, bool> ErrorTriggeredPop1; // 에러 발생/해결 이벤트 (메시지, 추가 여부)

        private System.Timers.Timer _delayTimerPop1; // 3초 지연 타이머
        private WarningWindowPop1 _warningWindowPop1; // 경고창 인스턴스 저장
        private ObservableCollection<ErrorMessagePop1> _errorMessagesPop1; // 에러 메시지 목록

        public MainViewModelPop1()
        {
            _delayTimerPop1 = new System.Timers.Timer(3000);
            _delayTimerPop1.Elapsed += DelayTimerElapsedPop1;
            _delayTimerPop1.AutoReset = false;

            _errorMessagesPop1 = new ObservableCollection<ErrorMessagePop1>();

            // 에러 발생/해결 이벤트 구독
            ErrorTriggeredPop1 += HandleErrorEventPop1;
        }

        // 에러 이벤트 처리 (추가 또는 제거)
        private void HandleErrorEventPop1(string message, bool isAdd)
        {
            if (isAdd)
            {
                AddErrorMessagePop1(message);
            }
            else
            {
                RemoveErrorMessagePop1(message);
            }
        }

        private void AddErrorMessagePop1(string message)
        {
            if (_errorMessagesPop1.Any(m => m.ContentPop1 == message)) return;

            Color color = _errorMessagesPop1.Count % 2 == 0 ? Colors.Yellow : Colors.Aqua;
            _errorMessagesPop1.Add(new ErrorMessagePop1(message, new SolidColorBrush(color)));

            if (_errorMessagesPop1.Count == 1)
            {
                ShowWarningWindowPop1(); // 첫 메시지 추가 시 창 표시
            }
            else
            {
                UpdateWarningWindowPop1(); // 메시지 추가 시 창 업데이트
            }

            Debug.WriteLine($"[DEBUG] Error added: {message}");
        }

        private void RemoveErrorMessagePop1(string message)
        {
            var errorMessagePop1 = _errorMessagesPop1.FirstOrDefault(m => m.ContentPop1 == message);
            if (errorMessagePop1 != null)
            {
                _errorMessagesPop1.Remove(errorMessagePop1);
                Debug.WriteLine($"[DEBUG] Error removed: {message}");

                if (_errorMessagesPop1.Count == 0)
                {
                    CloseWarningWindowPop1(); // 메시지가 없으면 창 닫기
                }
                else
                {
                    UpdateWarningWindowPop1(); // 메시지 제거 시 창 업데이트
                }
            }
        }

        private void ShowWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                _warningWindowPop1 = new WarningWindowPop1(_errorMessagesPop1);
                _warningWindowPop1.Topmost = true;
                _warningWindowPop1.Show();

                _warningWindowPop1.Closed += (sender, e) =>
                {
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed");
                };

                Debug.WriteLine("[DEBUG] Warning window shown");
            });
        }

        private void UpdateWarningWindowPop1()
        {
            if (_warningWindowPop1 != null)
            {
                _warningWindowPop1.UpdateMessagesPop1(_errorMessagesPop1);
                Debug.WriteLine("[DEBUG] Warning window updated");
            }
        }

        private void CloseWarningWindowPop1()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_warningWindowPop1 != null)
                {
                    _warningWindowPop1.Close();
                    _warningWindowPop1 = null;
                    Debug.WriteLine("[DEBUG] Warning window closed and messages cleared");
                }
            });
        }

        private void DelayTimerElapsedPop1(object sender, ElapsedEventArgs e)
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                if (_errorMessagesPop1.Count > 0)
                {
                    ShowWarningWindowPop1();
                }
            });
        }

        public event PropertyChangedEventHandler PropertyChanged;
        protected void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }

    public class ErrorMessagePop1
    {
        public string ContentPop1 { get; }
        public SolidColorBrush ColorPop1 { get; }

        public ErrorMessagePop1(string content, SolidColorBrush color)
        {
            ContentPop1 = content;
            ColorPop1 = color;
        }
    }
}
모든 변수, 메서드, 이벤트에 Pop1을 추가하여 명확하게 구분했습니다.
System.Timers.Timer을 명시적으로 사용하여, 네임스페이스로 모호함을 방지했습니다.
2. WarningWindowPop1.xaml
여러 메시지를 표시하기 위해 ItemsControl을 사용하여 템플릿을 구성합니다.

xml
코드 복사
<Window x:Class="YourNamespace.WarningWindowPop1"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="WarningPop1" Height="500" Width="500"
        WindowStyle="None" AllowsTransparency="True" Background="#AAFF0000"
        ShowInTaskbar="False" Topmost="True" ResizeMode="NoResize"
        WindowStartupLocation="CenterScreen" 
        MouseDown="Window_MouseDownPop1">
    <Grid>
        <ItemsControl ItemsSource="{Binding ErrorMessagesPop1}">
            <ItemsControl.ItemTemplate>
                <DataTemplate>
                    <TextBlock Text="{Binding ContentPop1}"
                               FontSize="15"
                               Foreground="{Binding ColorPop1}"
                               TextAlignment="Center"
                               VerticalAlignment="Center"
                               HorizontalAlignment="Center"/>
                </DataTemplate>
            </ItemsControl.ItemTemplate>
        </ItemsControl>
    </Grid>
</Window>
WarningWindowPop1.xaml.cs
경고창에서 전달된 메시지를 실시간으로 업데이트할 수 있도록 ObservableCollection을 사용합니다.

csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows;

namespace YourNamespace
{
    public partial class WarningWindowPop1 : Window
    {
        public ObservableCollection<ErrorMessagePop1> ErrorMessagesPop1 { get; set; } = new ObservableCollection<ErrorMessagePop1>();

        public WarningWindowPop1(ObservableCollection<ErrorMessagePop1> errorMessagesPop1)
        {
            InitializeComponent();
            ErrorMessagesPop1 = errorMessagesPop1;
            DataContext = this;
        }

        public void UpdateMessagesPop1(ObservableCollection<ErrorMessagePop1> errorMessagesPop1)
        {
            ErrorMessagesPop1.Clear();
            foreach (var message in errorMessagesPop1)
            {
                ErrorMessagesPop1.Add(message);
            }
        }

        private void Window_MouseDownPop1(object sender, System.Windows.Input.MouseButtonEventArgs e)
        {
            this.Close(); // 클릭하면 창 닫기
        }
    }
}
3. 외부 클래스에서 이벤트를 통한 에러 발생 및 해제
외부 클래스에서 MainViewModelPop1의 이벤트를 통해 에러를 발생시키고, 해제합니다.

csharp
코드 복사
namespace YourNamespace
{
    public class SampleErrorTriggerPop1
    {
        public event Action<string, bool> OnErrorPop1; // 에러 메시지 이벤트 (메시지, 추가 여부)

        public void TriggerErrorPop1(string message)
        {
            OnErrorPop1?.Invoke(message, true); // 에러 발생
        }

        public void ResolveErrorPop1(string message)
        {
            OnErrorPop1?.Invoke(message, false); // 에러 해결
        }
    }
}
MainWindow에서 이벤트 연결
SampleErrorTriggerPop1의 OnErrorPop1 이벤트를 MainViewModelPop1의 ErrorTriggeredPop1에 연결하여 에러 메시지가 추가되거나 제거될 때마다 창을 자동으로 제어합니다.

csharp
코드 복사
using System.Windows;

namespace YourNamespace
{
    public partial class MainWindow : Window
    {
        private MainViewModelPop1 _viewModelPop1;
        private SampleErrorTriggerPop1 _errorTriggerPop1;

        public MainWindow()
        {
            InitializeComponent();
            _viewModelPop1 = new MainViewModelPop1();
            DataContext = _viewModelPop1;

            _errorTriggerPop1 = new SampleErrorTriggerPop1();
            _errorTriggerPop1.OnErrorPop1 += _viewModelPop1.ErrorTriggeredPop1; // 이벤트 연결
        }

        private void OnAddErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTriggerPop1.TriggerErrorPop1("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
            _errorTriggerPop1.TriggerErrorPop1("Warning!\nNetwork connection lost.\nAttempting to reconnect...");
        }

        private void OnResolveErrorMessageClicked(object sender, RoutedEventArgs e)
        {
            _errorTriggerPop1.ResolveErrorPop1("Critical Error!\nSystem temperature too high.\nImmediate cooling required.");
        }
    }
}
이제 OnAddErrorMessageClicked 버튼을 눌러 에러를 발생시키고, OnResolveErrorMessageClicked 버튼을 눌러 특정 에러 메시지를 제거할 수 있습니다.