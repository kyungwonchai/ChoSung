말씀하신 것처럼 파일이 실시간으로 쓰이고 있을 때, 특정 줄이 완전히 기록된 상태에서만 읽어야 하는 경우가 있습니다. 만약 파일이 계속해서 쓰이는 도중에 해당 줄이 아직 완성되지 않은 상태라면, 그 줄을 읽지 않고 나중에 완성된 후에 읽어야 합니다.

이를 처리하기 위한 방법은:

파일이 닫히거나 더 이상 변경되지 않는 시점에 읽기: FileSystemWatcher의 Changed 이벤트로 파일 변경을 감지하고, 변경이 완료되었을 때(더 이상 쓰이지 않을 때) 줄을 읽는 방식입니다.
줄이 완성되었는지 확인: 파일에서 줄이 완성되었는지 확인할 수 있는 여러 방법이 있습니다. 일반적으로 줄이 개행 문자로 끝나는지 확인하는 방식이 있습니다. 만약 줄이 개행 문자 없이 끝난다면, 해당 줄은 아직 쓰는 중일 가능성이 있습니다.
해결 방안:
개행 문자로 줄이 완성되었는지 확인합니다. 만약 줄이 개행 문자로 끝나지 않는다면, 아직 그 줄은 완성되지 않았다고 간주하고 다음에 다시 읽습니다.
FileSystemWatcher가 파일이 변경될 때 즉시 읽지 않고, 일정 시간 지연 후에 파일을 다시 확인하여 더 이상 파일이 쓰이지 않는 상태에서 줄을 읽도록 구현합니다.
코드 수정 (줄 완성 확인 및 처리)
csharp
코드 복사
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.ComponentModel;
using System.Security.Cryptography;
using System.Text;
using System.Threading.Tasks;
using System.Windows;

namespace LogFileWatcher.ViewModels
{
    public class FileWatcherViewModel : INotifyPropertyChanged
    {
        private FileSystemWatcher _watcher;
        private readonly string _folderPath = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 있는 폴더 경로
        private readonly string _positionFolderPath = @"C:\G-MES2.0\GUMI_WEB\log_positions"; // 마지막 줄 위치를 저장할 폴더
        private readonly string[] _keywords = { "FST", "FNL", "PLAN" };  // 감지할 키워드 목록
        private Dictionary<string, int> _fileLinePositions = new Dictionary<string, int>();  // 파일별 마지막 읽은 줄 저장
        private HashSet<string> _processedLineHashes = new HashSet<string>(); // 중복 방지용 해시값 저장

        public event PropertyChangedEventHandler PropertyChanged;

        public FileWatcherViewModel()
        {
            LoadLastPositions();  // 프로그램 시작 시 마지막 읽은 위치 로드
            SetupWatcher();
            Application.Current.Exit += OnExit;  // 프로그램 종료 시 이벤트 처리
        }

        // 마지막으로 읽은 줄 번호를 파일로부터 로드하는 메서드
        private void LoadLastPositions()
        {
            if (!Directory.Exists(_positionFolderPath))
            {
                Directory.CreateDirectory(_positionFolderPath);
            }

            var positionFiles = Directory.GetFiles(_positionFolderPath, "*.txt");
            foreach (var positionFile in positionFiles)
            {
                string fileName = Path.GetFileNameWithoutExtension(positionFile);
                if (int.TryParse(File.ReadAllText(positionFile), out int lastLine))
                {
                    _fileLinePositions[fileName] = lastLine;
                }
            }
        }

        // 마지막으로 읽은 줄 번호를 저장하는 메서드
        private void SaveLastPosition(string fileName, int lastLine)
        {
            string positionFilePath = Path.Combine(_positionFolderPath, fileName + ".txt");
            File.WriteAllText(positionFilePath, lastLine.ToString());
        }

        // FileSystemWatcher 설정
        private void SetupWatcher()
        {
            _watcher = new FileSystemWatcher
            {
                Path = _folderPath,  // 감시할 폴더 경로 설정
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,  // 파일 이름과 파일 변경 시 감지
                Filter = "*.log",  // .log 확장자 파일만 감지
                EnableRaisingEvents = true,  // 이벤트 활성화
                IncludeSubdirectories = false  // 하위 폴더는 감지하지 않음
            };

            _watcher.Created += OnChanged;
            _watcher.Changed += OnChanged;
        }

        // 파일이 생성되거나 변경되었을 때 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            string fileName = Path.GetFileName(e.FullPath);
            string pattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_\d{2}\.log$";

            if (Regex.IsMatch(fileName, pattern))
            {
                if (!_fileLinePositions.ContainsKey(fileName))
                {
                    _fileLinePositions[fileName] = 0;
                }

                // 일정 시간 지연 후 파일 읽기 (쓰기 작업이 완료될 시간을 기다림)
                Task.Delay(500).ContinueWith(t => CheckFileForKeywords(e.FullPath, fileName));
            }
        }

        // 변경된 파일의 내용을 읽고 특정 키워드(FST, FNL, PLAN)가 있는지 확인하는 메서드
        private void CheckFileForKeywords(string filePath, string fileName)
        {
            try
            {
                int lastReadLine = _fileLinePositions[fileName];  // 마지막 읽은 줄 번호
                int currentLineNumber = 0;

                // 파일을 읽기/쓰기 공유 모드로 열기
                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (StreamReader reader = new StreamReader(fs))
                {
                    string line;
                    while ((line = reader.ReadLine()) != null)
                    {
                        currentLineNumber++;

                        // 줄이 개행 문자로 끝나는지 확인하여 완성된 줄인지 확인
                        if (!line.EndsWith(Environment.NewLine) && reader.Peek() == -1)
                        {
                            // 아직 쓰기 작업이 완료되지 않은 줄일 수 있으므로 스킵
                            break;
                        }

                        if (currentLineNumber > lastReadLine)
                        {
                            // 줄을 해시화하여 중복 감지
                            string lineHash = ComputeHash(line);
                            if (!_processedLineHashes.Contains(lineHash))
                            {
                                foreach (var keyword in _keywords)
                                {
                                    if (line.Contains(keyword))
                                    {
                                        Console.WriteLine($"[{fileName}] 특정 문구 발견: {line}");
                                    }
                                }

                                // 해시값 저장 (중복 방지)
                                _processedLineHashes.Add(lineHash);
                            }

                            _fileLinePositions[fileName] = currentLineNumber;
                        }
                    }
                }

                SaveLastPosition(fileName, _fileLinePositions[fileName]);
            }
            catch (IOException ex)
            {
                Console.WriteLine("파일을 읽는 도중 오류가 발생했습니다: " + ex.Message);
            }
        }

        // 줄을 해시로 변환하여 중복을 감지하는 메서드
        private string ComputeHash(string input)
        {
            using (SHA256 sha256 = SHA256.Create())
            {
                byte[] inputBytes = Encoding.UTF8.GetBytes(input);
                byte[] hashBytes = sha256.ComputeHash(inputBytes);
                return Convert.ToBase64String(hashBytes);
            }
        }

        // 프로그램 종료 시 마지막 상태를 저장하는 메서드
        private void OnExit(object sender, ExitEventArgs e)
        {
            foreach (var kvp in _fileLinePositions)
            {
                SaveLastPosition(kvp.Key, kvp.Value);
            }
        }

        // INotifyPropertyChanged 구현
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항:
줄이 완성되었는지 확인:

CheckFileForKeywords 메서드에서 line.EndsWith(Environment.NewLine)로 줄이 개행 문자로 끝나는지 확인합니다. 개행 문자로 끝나지 않으면 줄이 아직 완성되지 않은 상태로 간주하고, 해당 줄을 읽지 않고 다음 번에 다시 확인합니다.

reader.Peek() == -1로 파일의 끝을 확인하여 더 이상 읽을 수 없는 상태인지도 체크합니다.

일정 시간 지연 후 파일 읽기:

파일이 변경된 후 즉시 읽지 않고, Task.Delay(500)를 사용하여 500ms 정도 기다린 후 파일을 읽도록 했습니다. 이 시간 동안 파일 쓰기가 완료될 수 있습니다.
동작 방식:
파일 변경 감지: FileSystemWatcher가 파일이 변경될 때마다 이벤트가 발생합니다.
줄이 완성되었는지 확인: 줄이 완전히 기록되었는지(개행 문자로 끝나는지) 확인하고, 완성된 줄만 처리합니다.
중복 방지: 각 줄의 해시값을 계산하여 중복된 줄을 처리하지 않습니다.
이 코드를 사용하면 실시간으로 파일이 쓰이는 도중에도 줄이 완성된 상태에서만 읽어들일 수 있습니다. 추가적인 요청이 있으면 언제든지 알려주세