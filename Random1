이제 XAML 오류를 해결하고 함수 상태를 시각적으로 가로로 나열하며, 작업이 시작될 때 함수들의 상태가 **회색(대기)**에서 스카이블루(진행 중), 그리고 **녹색(완료)**로 바뀌도록 수정하겠습니다. 또한, 진행 중인 함수의 상태는 진행 상태라고 표시하는 별도의 컬럼에 실시간으로 업데이트되도록 구현하겠습니다.

요약 요구사항:
모든 함수는 작업 대기 상태로 시작하며, 도형은 회색으로 표시됩니다.
작업이 진행되면 진행 중인 함수는 스카이블루, 완료된 함수는 녹색으로 표시됩니다.
함수 상태는 진행 상태라는 별도의 컬럼에 실시간으로 업데이트됩니다.
함수 상태 도형을 가로로 배치하여 표시합니다.
TaskModel.cs (함수 상태 및 실시간 상태 표시)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;
using System.Windows.Input;

public class TaskModel : ViewModelBase
{
    public string PONumber { get; set; }
    public string MAG_NO { get; set; }
    public string BASIC_MODEL { get; set; }
    public string MODEL_CODE { get; set; }
    public int PO_PLAN_QTY { get; set; }
    public int PO_PROD_QTY { get; set; }
    public int MAG_QTY { get; set; }
    public int SequenceFlag { get; set; }

    private string _status;
    public string Status
    {
        get => _status;
        set
        {
            _status = value;
            OnPropertyChanged(nameof(Status));
        }
    }

    public List<string> Functions { get; set; }  // 각 작업에서 실행할 함수 이름 리스트
    public List<string> FunctionStatuses { get; set; } // 각 함수의 상태 (대기 중, 실행 중, 완료 등)

    public string CurrentFunctionStatus { get; set; } // 현재 함수의 상태를 실시간으로 보여주는 컬럼

    public bool IsCompleted { get; set; }
    public bool IsError { get; set; }
    public bool IsPaused { get; set; }
    public bool IsRunning { get; set; }

    private TaskQueue _taskQueue;
    public ICommand StartCommand { get; }

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, bool isExecutable)
    {
        PONumber = logEntry.PO_NO;
        MAG_NO = logEntry.MAG_NO;
        BASIC_MODEL = logEntry.BASIC_MODEL;
        MODEL_CODE = logEntry.MODEL_CODE;
        PO_PLAN_QTY = logEntry.PO_PLAN_QTY;
        PO_PROD_QTY = logEntry.PO_PROD_QTY;
        MAG_QTY = logEntry.MAG_QTY;
        SequenceFlag = logEntry.SequenceFlag;

        _taskQueue = taskQueue;

        // 작업마다 3개의 함수를 실행하는 예시
        Functions = new List<string> { "FunctionA", "FunctionB", "FunctionC" };
        FunctionStatuses = new List<string> { "Waiting", "Waiting", "Waiting" };

        CurrentFunctionStatus = "Pending"; // 시작 시에는 모든 함수가 대기 중
        StartCommand = new RelayCommand(StartTask);

        Status = "Pending";
        if (isExecutable) StartTask();
    }

    private async void StartTask()
    {
        Status = "Running";
        IsRunning = true;
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsRunning));

        // 각 함수를 순차적으로 실행하며 상태를 업데이트
        for (int i = 0; i < Functions.Count; i++)
        {
            // 진행 중 함수의 상태를 실시간 업데이트
            CurrentFunctionStatus = $"Running {Functions[i]}";
            OnPropertyChanged(nameof(CurrentFunctionStatus));

            FunctionStatuses[i] = "Running";
            OnPropertyChanged(nameof(FunctionStatuses)); // 함수 상태를 업데이트
            var success = await _taskQueue.ExecuteSpecificTask(UpdateTaskStatus, i); // 함수 실행

            FunctionStatuses[i] = success ? "Completed" : "Error";
            OnPropertyChanged(nameof(FunctionStatuses));

            if (!success)
            {
                Status = "Error";
                IsError = true;
                break;
            }
        }

        CurrentFunctionStatus = "Completed";
        Status = IsError ? "Error" : "Completed";
        IsCompleted = !IsError;
        IsRunning = false;

        OnPropertyChanged(nameof(CurrentFunctionStatus));
        OnPropertyChanged(nameof(Status));
        OnPropertyChanged(nameof(IsCompleted));
        OnPropertyChanged(nameof(IsError));
        OnPropertyChanged(nameof(IsRunning));
    }

    /// <summary>
    /// TaskQueue의 상태를 실시간으로 업데이트하는 메서드
    /// </summary>
    private async Task UpdateTaskStatus(string message)
    {
        CurrentFunctionStatus = message;
        OnPropertyChanged(nameof(CurrentFunctionStatus));
        await Task.CompletedTask;
    }
}
주요 변경 사항:
CurrentFunctionStatus: 현재 실행 중인 함수의 상태를 실시간으로 보여주기 위한 속성을 추가했습니다.
FunctionStatuses: 각 함수의 상태가 **대기 중(회색)**에서 실행 중(스카이블루), **완료(녹색)**로 바뀝니다.
실시간 상태 업데이트: 함수가 실행되면 상태가 실시간으로 변경되며, 완료 시 현재 함수 상태가 업데이트됩니다.
TaskQueue.cs (각 함수가 순차적으로 실행되도록 처리)
Models/TaskQueue.cs

csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading;
using System.Threading.Tasks;

public class TaskQueue
{
    private List<Func<Func<string, Task>, Task<bool>>> _tasks; // 작업 리스트 (상태 업데이트)
    private PlcCommunication _plcCommunication; // PLC 통신 인스턴스

    public TaskQueue(PlcCommunication plcCommunication)
    {
        _tasks = new List<Func<Func<string, Task>, Task<bool>>>(); // 작업 초기화
        _plcCommunication = plcCommunication;
        AddDefaultTasks(); // 기본 작업 추가
    }

    // 기본 작업을 추가하는 메서드 (여러 작업을 큐에 추가)
    private void AddDefaultTasks()
    {
        _tasks.Add(TaskA);
        _tasks.Add(TaskB);
        _tasks.Add(TaskC);
    }

    // 특정 함수만 실행하는 메서드
    public async Task<bool> ExecuteSpecificTask(Func<string, Task> updateStatus, int taskIndex)
    {
        if (taskIndex < 0 || taskIndex >= _tasks.Count)
        {
            return false; // 잘못된 작업 인덱스일 경우
        }

        var success = await _tasks[taskIndex](updateStatus);
        return success;
    }

    // COM 포트 1과 2를 통해 데이터를 전송하며 순차적으로 처리
    private async Task<bool> TaskA(Func<string, Task> updateStatus)
    {
        await updateStatus("Task A: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task A");
        
        await updateStatus("Task A: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task A");

        await updateStatus("Task A completed.");
        return true;  // 작업 성공
    }

    private async Task<bool> TaskB(Func<string, Task> updateStatus)
    {
        await updateStatus("Task B: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task B");
        
        await updateStatus("Task B: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task B");

        await updateStatus("Task B completed.");
        return true;
    }

    private async Task<bool> TaskC(Func<string, Task> updateStatus)
    {
        await updateStatus("Task C: COM 포트 1로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort1("Data for Task C");
        
        await updateStatus("Task C: COM 포트 2로 데이터 전송 중...");
        await _plcCommunication.SendDataToComPort2("Data for Task C");

        await updateStatus("Task C completed.");
        return true;
    }
}
MainWindow.xaml (도형을 가로로 배치하고 상태 컬럼 추가)
xml
코드 복사
<Window x:Class="LogisticsApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Logistics Task Manager" Height="400" Width="1000">
    <Grid>
        <!-- DataGrid: 작업 목록과 상태를 표시 -->
        <DataGrid Name="TaskDataGrid" ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" IsReadOnly="True" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="PO Number" Binding="{Binding PONumber}" Width="*" />
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*" />
                <DataGridTextColumn Header="BASIC_MODEL" Binding="{Binding BASIC_MODEL}" Width="*" />
                <DataGridTextColumn Header="MODEL_CODE" Binding="{Binding MODEL_CODE}" Width="*" />
                <DataGridTextColumn Header="PO_PLAN_QTY" Binding="{Binding PO_PLAN_QTY}" Width="*" />
                <DataGridTextColumn Header="PO_PROD_QTY" Binding="{Binding PO_PROD_QTY}" Width="*" />
                <DataGridTextColumn Header="MAG_QTY" Binding="{Binding MAG_QTY}" Width="*" />
                <DataGridTextColumn Header="SequenceFlag" Binding="{Binding SequenceFlag}" Width="*" />
                
                <!-- 함수 상태를 도형으로 가로로 표시하는 열 -->
                <DataGridTemplateColumn Header="Functions Status" Width="*">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <StackPanel Orientation="Horizontal">
                                <ItemsControl ItemsSource="{Binding FunctionStatuses}">
                                    <ItemsControl.ItemsPanel>
                                        <ItemsPanelTemplate>
                                            <StackPanel Orientation="Horizontal" />
                                        </ItemsPanelTemplate>
                                    </ItemsControl.ItemsPanel>
                                    <ItemsControl.ItemTemplate>
                                        <DataTemplate>
                                            <Ellipse Width="20" Height="20" Stroke="Black" StrokeThickness="1">
                                                <Ellipse.Style>
                                                    <Style TargetType="Ellipse">
                                                        <Style.Triggers>
                                                            <!-- 대기 중인 함수는 회색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Waiting">
                                                                <Setter Property="Fill" Value="Gray"/>
                                                            </DataTrigger>
                                                            <!-- 실행 중인 함수는 스카이블루 -->
                                                            <DataTrigger Binding="{Binding}" Value="Running">
                                                                <Setter Property="Fill" Value="SkyBlue"/>
                                                            </DataTrigger>
                                                            <!-- 완료된 함수는 녹색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Completed">
                                                                <Setter Property="Fill" Value="LightGreen"/>
                                                            </DataTrigger>
                                                            <!-- 에러가 발생한 함수는 빨간색 -->
                                                            <DataTrigger Binding="{Binding}" Value="Error">
                                                                <Setter Property="Fill" Value="Red"/>
                                                            </DataTrigger>
                                                        </Style.Triggers>
                                                    </Style>
                                                </Ellipse.Style>
                                            </Ellipse>
                                        </DataTemplate>
                                    </ItemsControl.ItemTemplate>
                                </ItemsControl>
                            </StackPanel>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <!-- 진행 상태를 표시하는 컬럼 -->
                <DataGridTextColumn Header="진행 상태" Binding="{Binding CurrentFunctionStatus}" Width="2*" />
            </DataGrid.Columns>
        </DataGrid>

        <!-- 일시정지 및 다시 시작 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="120,0,0,10"/>
    </Grid>
</Window>
주요 변경 사항:
StackPanel로 도형 가로 배치: 각 함수의 상태 도형을 가로로 나열하기 위해 StackPanel을 사용했습니다.
상태 컬럼 추가: CurrentFunctionStatus 속성을 바인딩하여 진행 상태를 실시간으로 글자로 표시하는 별도의 컬럼을 추가했습니다.
함수 상태 도형: 회색(대기 중), 스카이블루(진행 중), 녹색(완료), **빨간색(에러)**로 도형 색상을 변경합니다.
이제 각 함수 상태가 가로로 나열되며, 작업의 진행 상태가 별도의 컬럼에 실시간으로 업데이