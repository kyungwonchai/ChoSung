++ 힙(Heap) 구현 - 삼성 Certi Expert 대비
힙(Heap)은 우선순위 큐(Priority Queue)를 구현할 때 사용되며, 일반적으로 최대 힙(Max Heap)과 최소 힙(Min Heap)으로 나뉩니다.

최대 힙(Max Heap): 부모 노드의 값이 자식 노드보다 크거나 같은 완전 이진 트리
최소 힙(Min Heap): 부모 노드의 값이 자식 노드보다 작거나 같은 완전 이진 트리
📌 힙의 기본 연산
삽입 (Insert)
새로운 요소를 힙의 끝에 추가한 후, 부모와 비교하여 위치 조정(Up-Heap 또는 Bubble-Up)
삭제 (Delete)
루트(최댓값 또는 최솟값)를 제거한 후, 마지막 요소를 루트로 이동하고 자식과 비교하여 위치 조정(Down-Heap 또는 Heapify)
📌 코드 구현 (Max Heap)
삼성 Certi Expert 시험을 대비하여, 배열을 사용한 최대 힙을 구현합니다.
주석을 아주 상세하게 추가하여 이해하기 쉽게 설명하겠습니다.

cpp
코드 복사
#include <iostream>
#include <vector>

using namespace std;

class MaxHeap {
private:
    vector<int> heap; // 내부 배열을 사용하여 힙을 저장

public:
    // 생성자: 힙의 첫 번째 요소는 사용하지 않기 위해 0을 추가
    MaxHeap() { heap.push_back(0); }

    // 부모 노드의 인덱스를 반환
    int parent(int index) { return index / 2; }

    // 왼쪽 자식 노드의 인덱스를 반환
    int leftChild(int index) { return index * 2; }

    // 오른쪽 자식 노드의 인덱스를 반환
    int rightChild(int index) { return index * 2 + 1; }

    // 힙에 값 추가 (삽입 연산)
    void insert(int value) {
        heap.push_back(value); // 배열 끝에 새 값 추가
        int index = heap.size() - 1; // 현재 삽입된 노드의 인덱스

        // 부모와 비교하며 위로 이동 (Up-Heap / Bubble-Up)
        while (index > 1 && heap[parent(index)] < heap[index]) {
            swap(heap[parent(index)], heap[index]); // 부모와 자리 변경
            index = parent(index); // 인덱스를 부모로 이동
        }
    }

    // 힙에서 최대값(루트) 삭제 (삭제 연산)
    int deleteMax() {
        if (heap.size() <= 1) {
            cout << "Heap is empty!\n";
            return -1;
        }

        int maxValue = heap[1]; // 최대값 (루트 노드 저장)
        heap[1] = heap.back(); // 마지막 노드를 루트로 이동
        heap.pop_back(); // 마지막 요소 삭제

        int index = 1; // 현재 루트 위치
        int size = heap.size(); // 힙 크기

        // 자식 노드와 비교하며 아래로 이동 (Down-Heap / Heapify)
        while (leftChild(index) < size) {
            int largest = leftChild(index); // 왼쪽 자식을 기준으로 비교
            if (rightChild(index) < size && heap[rightChild(index)] > heap[largest]) {
                largest = rightChild(index); // 오른쪽 자식이 더 크다면 업데이트
            }

            if (heap[index] >= heap[largest]) break; // 부모가 더 크면 종료

            swap(heap[index], heap[largest]); // 자리 변경
            index = largest; // 인덱스 이동
        }

        return maxValue; // 삭제된 최대값 반환
    }

    // 힙 출력 (디버깅용)
    void printHeap() {
        cout << "Heap: ";
        for (int i = 1; i < heap.size(); i++) {
            cout << heap[i] << " ";
        }
        cout << endl;
    }
};

int main() {
    MaxHeap maxHeap; // 최대 힙 객체 생성

    // 예제 데이터 삽입
    maxHeap.insert(10);
    maxHeap.insert(20);
    maxHeap.insert(30);
    maxHeap.insert(5);
    maxHeap.insert(50);
    maxHeap.insert(40);

    maxHeap.printHeap(); // 현재 힙 상태 출력

    // 최대값 삭제 후 출력
    cout << "Deleted Max: " << maxHeap.deleteMax() << endl;
    maxHeap.printHeap();

    return 0;
}
📌 상세 주석 설명
1️⃣ insert(int value)
새 값을 벡터의 끝에 추가
부모와 비교하여 위치를 조정 (Bubble-Up)
부모보다 크다면 부모와 자리 변경을 반복
2️⃣ deleteMax()
루트 노드를 삭제하고, 마지막 노드를 루트로 이동
자식과 비교하여 위치를 조정 (Heapify / Down-Heap)
왼쪽과 오른쪽 자식 중 더 큰 값과 비교 후, 자리 변경
3️⃣ 출력 예시
cpp
코드 복사
Heap: 50 30 40 5 10 20
Deleted Max: 50
Heap: 40 30 20 5 10
📌 시간 복잡도 분석
연산	시간 복잡도
삽입 (Insert)	O(log N)
삭제 (Delete Max)	O(log N)
📌 시험 대비 정리
✔ 배열을 이용한 완전 이진 트리 형태로 힙 구현
✔ Bubble-Up (삽입)과 Heapify (삭제)를 구현
✔ 배열을 사용하여 부모/자식 접근을 효율적으로 처리
✔ 힙을 유지하면서 우선순위 큐 기능 제공
✔ 시간 복잡도를 고려하여 효율적인 코드 작성
