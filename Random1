import csv
import re
from datetime import datetime, timedelta
from collections import Counter
import matplotlib.pyplot as plt
from matplotlib.ticker import MaxNLocator
import pandas as pd

# 예제 데이터로 작업을 대체합니다.
# 아래 예제 데이터는 11월 4일부터 11월 8일까지의 데이터를 포함하는 가상 데이터입니다.
example_data = [
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd1234", "abcd1234", "2024-11-04", "day", "2024-11-04 08:00:00", 1],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd5678", "abcd5678", "2024-11-04", "night", "2024-11-04 20:00:00", 1],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd5678", "abcd5678", "2024-11-05", "day", "2024-11-05 10:00:00", 1],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd1234", "abcd1234", "2024-11-05", "night", "2024-11-05 22:00:00", 2],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd9876", "abcd9876", "2024-11-06", "day", "2024-11-06 09:00:00", 1],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd5432", "abcd5432", "2024-11-07", "night", "2024-11-07 21:00:00", 1],
    ["line1", "machine1", "lane1", "splicing", "Reel ID=abcd9876", "abcd9876", "2024-11-08", "day", "2024-11-08 07:30:00", 1]
]

# 예제 데이터로부터 필요한 집계를 생성합니다.
filtered_rows = [row for row in example_data if row[6] >= '2024-11-04' and row[6] <= '2024-11-08' and row[9] == 1]
date_shift_counts = Counter((row[6], row[7]) for row in filtered_rows)

# 날짜와 조별로 개수 집계 결과 정리
dates = sorted(set(row[6] for row in filtered_rows))
shifts = ['day', 'night']
count_data = {date: [date_shift_counts.get((date, shift), 0) for shift in shifts] for date in dates}

# CSV 파일로 저장할 로우 데이터 준비
csv_file = 'c:\\agent\\splicing_logs.csv'
with open(csv_file, mode='w', newline='', encoding='utf-8-sig') as file:
    writer = csv.writer(file)
    writer.writerow(['line1', 'machine1', 'lane1', 'log1', 'log2', 'partid', 'date1', 'shift1', 'datatime1', 'dup'])
    writer.writerows(example_data)

# 막대차트 시각화
fig, ax = plt.subplots(figsize=(10, 6))
bars = []
labels = []

for i, (date, counts) in enumerate(count_data.items()):
    for j, count in enumerate(counts):
        label = f"{date} ({shifts[j]})"
        bars.append(count)
        labels.append(label)

# 그래디언트 색상 적용
bars_plot = ax.bar(labels, bars, color=plt.cm.viridis([i / len(bars) for i in range(len(bars))]))

# 막대 위에 숫자 표시
for bar in bars_plot:
    height = bar.get_height()
    ax.text(bar.get_x() + bar.get_width() / 2, height, f'{int(height)}', ha='center', va='bottom')

# 차트 설정
ax.set_xlabel("날짜와 조")
ax.set_ylabel("중복이 1인 항목 개수")
ax.set_title("날짜별, 조별 중복이 1인 항목 개수")
ax.yaxis.set_major_locator(MaxNLocator(integer=True))
plt.xticks(rotation=45, ha='right')
plt.tight_layout()

# 차트를 이미지 파일로 저장
chart_image_path = 'c:\\agent\\splicing_chart.png'
plt.savefig(chart_image_path)

# 엑셀 파일로 저장
excel_path = 'c:\\agent\\splicing_report.xlsx'
with pd.ExcelWriter(excel_path, engine='xlsxwriter') as writer:
    # 시트1에 차트 이미지 추가
    workbook = writer.book
    worksheet_chart = workbook.add_worksheet('Chart')
    worksheet_chart.insert_image('A1', chart_image_path)

    # 시트2에 로우 데이터 추가
    df = pd.DataFrame(example_data, columns=['line1', 'machine1', 'lane1', 'log1', 'log2', 'partid', 'date1', 'shift1', 'datatime1', 'dup'])
    df.to_excel(writer, sheet_name='Data', index=False)
