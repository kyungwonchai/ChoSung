이 요구 사항에 맞게 PLC 시뮬레이터 프로그램을 수정하려면, WPF UI에 버튼을 추가하여 마우스로 누를 때와 뗄 때의 상태를 감지하고, 특정 센서 주소(예: R520)의 값을 0 또는 1로 기록할 수 있어야 합니다.

기능 변경 및 추가:
센서 감지 기능: 버튼이 눌린 상태에서는 R520 주소에 1을 기록하고, 버튼에서 손을 떼면 R520 주소에 0을 기록합니다.
UI 수정: WPF에 센서 감지 버튼을 추가하고, 마우스 클릭 및 해제 이벤트를 처리합니다.
PLC 시뮬레이터: R520 값을 읽을 때 그 버튼의 상태를 반영하도록 구현합니다.
수정된 전체 코드
MainWindow.xaml
xml
코드 복사
<Window x:Class="PlcSimulation.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Simulator" Height="400" Width="525">
    <Grid>
        <TextBox Name="CommandInput" Width="400" Height="30" Margin="10"/>
        <Button Content="Send Command" Width="100" Height="30" Margin="420,10,0,0" VerticalAlignment="Top" Click="SendCommand_Click"/>
        <TextBlock Name="ResponseText" Width="500" Height="200" Margin="10,50,0,0" TextWrapping="Wrap"/>
        <TextBox Name="ReadAddressInput" Width="200" Height="30" Margin="10,260,0,0"/>
        <Button Content="Read Address" Width="100" Height="30" Margin="220,260,0,0" VerticalAlignment="Bottom" Click="ReadAddress_Click"/>

        <!-- 센서 감지 버튼 -->
        <Button Name="SensorButton" Content="Sensor (R520)" Width="100" Height="30" Margin="10,300,0,0"
                MouseDown="SensorButton_MouseDown" MouseUp="SensorButton_MouseUp"/>
    </Grid>
</Window>
MainWindow.xaml.cs
csharp
코드 복사
using System.Windows;

namespace PlcSimulation
{
    public partial class MainWindow : Window
    {
        private PlcSimulator _plcSimulator;

        public MainWindow()
        {
            InitializeComponent();
            _plcSimulator = new PlcSimulator();  // PLC 시뮬레이터 인스턴스 생성
        }

        // 명령 전송 버튼 클릭 시
        private void SendCommand_Click(object sender, RoutedEventArgs e)
        {
            string command = CommandInput.Text;
            string response = _plcSimulator.ProcessCommand(command);
            ResponseText.Text = "Response: " + response;
        }

        // 주소 읽기 버튼 클릭 시
        private void ReadAddress_Click(object sender, RoutedEventArgs e)
        {
            string address = ReadAddressInput.Text;
            string value = _plcSimulator.ReadAddress(address);
            ResponseText.Text = $"Value at {address}: " + value;
        }

        // 센서 버튼을 눌렀을 때 (마우스 다운)
        private void SensorButton_MouseDown(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 1);  // 센서 감지 (1)
            ResponseText.Text = "Sensor R520: Detected (1)";
        }

        // 센서 버튼에서 마우스를 뗐을 때 (마우스 업)
        private void SensorButton_MouseUp(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 0);  // 센서 감지 안됨 (0)
            ResponseText.Text = "Sensor R520: Not Detected (0)";
        }
    }
}
PlcSimulator.cs
csharp
코드 복사
using System;
using System.Collections.Generic;

namespace PlcSimulation
{
    public class PlcSimulator
    {
        // PLC 메모리 시뮬레이션 (주소, 값 저장)
        private Dictionary<string, int> _plcMemory;

        public PlcSimulator()
        {
            _plcMemory = new Dictionary<string, int>();
        }

        // 명령어 처리
        public string ProcessCommand(string command)
        {
            // 쓰기 명령어 처리
            if (command.StartsWith("%01#WDD"))
            {
                return HandleWriteCommand(command);
            }
            // 읽기 명령어 처리
            else if (command.StartsWith("%01#RD"))
            {
                return HandleReadCommand(command);
            }

            return "Invalid Command";
        }

        // 쓰기 명령어 처리 함수
        private string HandleWriteCommand(string command)
        {
            // 예: %01#WDD02300023000100** 에서 주소 2300과 값 0100을 추출
            string addressStr = command.Substring(7, 4); // 2300 주소
            string valueStr = command.Substring(15, 4);  // 0100 값

            if (int.TryParse(addressStr, out int address) && int.TryParse(valueStr, out int value))
            {
                // 2300번지에 쓰기
                _plcMemory[addressStr] = value;

                // 특별히 2300번지가 쓰여졌을 때 2330에 값을 복사
                if (addressStr == "2300")
                {
                    _plcMemory["2330"] = value;
                }

                // 기본 응답
                return "$01SWD13";
            }

            return "Write Command Error";
        }

        // 읽기 명령어 처리 함수
        private string HandleReadCommand(string command)
        {
            // 예: %01#RD0230** 에서 주소 0230을 추출
            string addressStr = command.Substring(7, 4); // 읽을 주소

            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Value Not Found";
        }

        // PLC 메모리에서 주소 읽기
        public string ReadAddress(string addressStr)
        {
            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Invalid Address or Value Not Found";
        }

        // 센서 값 설정 (R520)
        public void SetSensorValue(string address, int value)
        {
            if (address == "R520")
            {
                _plcMemory[address] = value;
            }
        }
    }
}
코드 설명
UI 수정:

센서 감지 버튼을 추가하였습니다. 버튼을 마우스로 클릭하면 MouseDown 이벤트가 발생하여 R520 주소에 1 값을 기록하고, MouseUp 이벤트가 발생하면 R520에 0 값을 기록합니다.
센서 감지 상태 기록:

PlcSimulator 클래스에 SetSensorValue 메서드를 추가하여 특정 주소(R520)에 대한 값을 기록합니다.
버튼이 눌리면 R520에 1이 기록되고, 버튼에서 손을 떼면 0이 기록됩니다.
명령 처리:

기존의 쓰기 및 읽기 명령어 처리 로직은 그대로 유지하면서, 센서 감지 버튼의 상태를 반영합니다.
PLC 메모리 시뮬레이션:

Dictionary<string, int> 구조로 PLC 메모리를 시뮬레이션하여, PLC의 주소와 값을 관리합니다.
R520 같은 센서 주소의 값을 동적으로 변경할 수 있습니다.
요약
이제 이 WPF 기반의 PLC 시뮬레이터는 다음 기능을 지원합니다:

PLC로부터 쓰기/읽기 명령어 처리 (%01#WDD, %01#RD).
센서(R520) 버튼의 마우스 클릭 상태에 따라 감지 여부를 기록하고, PLC가 그 상태를 읽을 수 있도록 처