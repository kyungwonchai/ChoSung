, 앱이 잘 동작한다니 정말 다행입니다! 이제 실시간으로 측정된 조도 값을 MSSQL 데이터베이스에 1초마다 저장하는 기능을 추가해 보겠습니다.

여기서 매우 중요한 점이 있습니다. 보안상의 이유로 안드로이드 앱에서 데이터베이스(MSSQL)로 직접 연결하는 것은 절대 안 됩니다. 앱 코드에 데이터베이스 접속 정보(ID, 비밀번호)가 그대로 노출되어 해킹의 직접적인 원인이 되기 때문입니다.

따라서, 아래와 같이 '웹 API 서버' 라는 중간 다리를 반드시 만들어야 합니다.

전체 구조
안드로이드 앱: 1초마다 조도 값을 웹 API 서버로 전송합니다. (데이터 전송 요청)

웹 API 서버: 앱으로부터 데이터를 받아서, 안전하게 MSSQL 데이터베이스에 저장합니다. (데이터 저장 담당)

MSSQL 데이터베이스: 웹 API 서버를 통해서만 데이터가 저장됩니다.

이제 사용자님께서 하실 일과 제가 수정해 드릴 안드로이드 코드를 나누어 상세히 안내해 드리겠습니다.

## 1. 사용자님이 준비하실 것 (DB & API 서버)
이 부분은 사용자님의 서버 환경에서 직접 구축하셔야 합니다.

1-1. MSSQL 2014에 테이블 생성하기
먼저 조도 값을 저장할 테이블을 만드셔야 합니다. SQL Server Management Studio에서 아래 쿼리를 실행하여 LightLog라는 이름의 테이블을 생성하세요.

SQL

-- LightLog 라는 이름의 테이블을 생성합니다.
CREATE TABLE LightLog (
    LogID INT PRIMARY KEY IDENTITY(1,1), -- 데이터 고유 ID (자동 증가)
    LuxValue FLOAT NOT NULL,             -- 조도 값 (소수점 가능)
    Timestamp DATETIME DEFAULT GETDATE() -- 데이터 저장 시간 (자동 기록)
);
1-2. 웹 API 서버 만들기 (C# ASP.NET 예시)
가장 일반적인 방법인 C# ASP.NET Web API로 간단한 예시를 만들어 드립니다. Visual Studio에서 새 프로젝트를 만들어 아래와 같이 코드를 작성하시면 됩니다.

Controllers/LightController.cs 파일 생성

C#

using Microsoft.AspNetCore.Mvc;
using System.Data.SqlClient;

namespace LightApi.Controllers
{
    [ApiController]
    [Route("[controller]")]
    public class LightController : ControllerBase
    {
        // 데이터베이스 연결 문자열 (실제 환경에 맞게 수정 필요)
        private readonly string _connectionString = "Server=내서버IP;Database=데이터베이스이름;User Id=사용자ID;Password=비밀번호;";

        // 안드로이드 앱에서 호출할 주소: http://내서버IP/Light/Log
        [HttpPost("Log")]
        public IActionResult LogLightValue([FromBody] LightData data)
        {
            try
            {
                using (SqlConnection connection = new SqlConnection(_connectionString))
                {
                    connection.Open();
                    string sql = "INSERT INTO LightLog (LuxValue) VALUES (@LuxValue)";
                    using (SqlCommand command = new SqlCommand(sql, connection))
                    {
                        command.Parameters.AddWithValue("@LuxValue", data.Lux);
                        command.ExecuteNonQuery();
                    }
                }
                return Ok("데이터 저장 성공"); // 성공 시 응답
            }
            catch (Exception ex)
            {
                // 실패 시 서버에 에러 로그를 남기고, 앱에는 간단한 실패 응답을 보냄
                return StatusCode(500, "서버 오류 발생: " + ex.Message);
            }
        }
    }

    // 앱에서 보낼 데이터 형식
    public class LightData
    {
        public float Lux { get; set; }
    }
}
## 2. 안드로이드 앱 코드 수정
이제 1초마다 서버로 데이터를 보내도록 MainActivity.kt와 설정 파일들을 수정하겠습니다.

2-1. build.gradle.kts (Module :app) 파일 수정
네트워크 통신을 쉽게 하도록 도와주는 라이브러리(Retrofit, OkHttp)를 추가해야 합니다. dependencies { ... } 블록 안에 아래 코드를 추가해 주세요.

Kotlin

// ... 기존 dependencies ...

// 네트워크 통신 라이브러리 (Retrofit)
implementation("com.squareup.retrofit2:retrofit:2.9.0")
implementation("com.squareup.retrofit2:converter-gson:2.9.0")
// 네트워크 통신 로깅 라이브러리 (OkHttp) - 개발 중 확인용
implementation("com.squareup.okhttp3:logging-interceptor:4.10.0")
수정 후 화면 상단의 **Sync Now**를 꼭 눌러주세요.

2-2. AndroidManifest.xml 파일 수정
앱이 인터넷을 사용할 수 있도록 권한을 추가해야 합니다. <manifest ...> 태그 안에 아래 코드를 추가하세요. 또한, API 서버가 http를 사용할 경우를 대비해 usesCleartextTraffic 속성을 추가합니다.

파일 위치: app > src > main > AndroidManifest.xml

XML

<?xml version="1.0" encoding="utf-8"?>
<manifest xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools">

    <!-- 인터넷 사용 권한 추가 -->
    <uses-permission android:name="android.permission.INTERNET" />

    <application
        android:allowBackup="true"
        android:dataExtractionRules="@xml/data_extraction_rules"
        android:fullBackupContent="@xml/backup_rules"
        android:icon="@mipmap/ic_launcher"
        android:label="@string/app_name"
        android:roundIcon="@mipmap/ic_launcher_round"
        android:supportsRtl="true"
        android:theme="@style/Theme.LightMeter"
        tools:targetApi="31"
        android:usesCleartextTraffic="true"> <!-- HTTP 통신 허용 (개발용) -->
        
        <!-- ... 기존 Activity 설정 ... -->

    </application>

</manifest>
2-3. MainActivity.kt 파일 교체 (최종)
기존 MainActivity.kt 파일의 내용을 모두 지우고 아래의 최종 코드로 덮어쓰기 하세요. 1초 타이머, 네트워크 전송 로직이 모두 포함되어 있습니다.

파일 위치: app > src > main > java > com.sec.lightmeter > MainActivity.kt

Kotlin

package com.sec.lightmeter

import android.content.Context
import android.hardware.Sensor
import android.hardware.SensorEvent
import android.hardware.SensorEventListener
import android.hardware.SensorManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.ContextCompat
import com.sec.lightmeter.databinding.ActivityMainBinding
import retrofit2.Call
import retrofit2.Callback
import retrofit2.Response
import retrofit2.Retrofit
import retrofit2.converter.gson.GsonConverterFactory
import retrofit2.http.Body
import retrofit2.http.POST

// --- 1. 네트워크 통신을 위한 데이터 클래스 및 인터페이스 정의 ---

// 서버로 보낼 데이터의 형식을 정의 (JSON)
data class LightData(val lux: Float)

// Retrofit이 사용할 API 명세
interface ApiService {
    // HTTP POST 방식으로 "Log" 경로에 데이터를 보냄
    @POST("Light/Log")
    fun postLightValue(@Body data: LightData): Call<String>
}


class MainActivity : AppCompatActivity(), SensorEventListener {

    private lateinit var binding: ActivityMainBinding
    private lateinit var sensorManager: SensorManager
    private var lightSensor: Sensor? = null

    // --- 2. 서버 통신 및 타이머를 위한 변수 추가 ---
    private var latestLuxValue: Float = 0.0f
    private val handler = Handler(Looper.getMainLooper())
    private lateinit var apiService: ApiService

    // 1초마다 실행될 작업 정의
    private val runnable = object : Runnable {
        override fun run() {
            sendDataToServer(latestLuxValue)
            // 1초(1000ms) 후에 자기 자신을 다시 실행하도록 예약
            handler.postDelayed(this, 1000)
        }
    }

    // --- 조도 스펙 정의 (이 값을 변경하여 스펙을 조절할 수 있습니다) ---
    private val SPEC_MIN_LUX = 100.0f
    private val SPEC_MAX_LUX = 500.0f
    // ---------------------------------------------------------

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.tvSpecInfo.text = getString(R.string.spec_info_format, SPEC_MIN_LUX, SPEC_MAX_LUX)

        setupSensor()
        setupNetwork() // --- 3. 네트워크 설정 함수 호출 ---
    }

    private fun setupSensor() {
        sensorManager = getSystemService(Context.SENSOR_SERVICE) as SensorManager
        lightSensor = sensorManager.getDefaultSensor(Sensor.TYPE_LIGHT)
        if (lightSensor == null) {
            binding.tvLuxValue.text = "조도 센서 없음"
            binding.tvUnit.text = ""
        }
    }

    // --- 4. 네트워크 클라이언트(Retrofit)를 설정하는 함수 ---
    private fun setupNetwork() {
        val retrofit = Retrofit.Builder()
            .baseUrl("http://여기에-사용자-API-서버-IP주소/") // ★★반드시 사용자님의 API 서버 주소로 변경하세요!★★
            .addConverterFactory(GsonConverterFactory.create())
            .build()

        apiService = retrofit.create(ApiService::class.java)
    }

    // --- 5. 실제 서버로 데이터를 전송하는 함수 ---
    private fun sendDataToServer(lux: Float) {
        val lightData = LightData(lux = lux)
        apiService.postLightValue(lightData).enqueue(object : Callback<String> {
            override fun onResponse(call: Call<String>, response: Response<String>) {
                if (response.isSuccessful) {
                    Log.d("NetworkSuccess", "데이터 전송 성공: ${response.body()}")
                } else {
                    Log.e("NetworkError", "데이터 전송 실패: ${response.code()}")
                }
            }

            override fun onFailure(call: Call<String>, t: Throwable) {
                Log.e("NetworkFailure", "네트워크 오류: ${t.message}")
            }
        })
    }

    override fun onResume() {
        super.onResume()
        lightSensor?.let {
            sensorManager.registerListener(this, it, SensorManager.SENSOR_DELAY_UI)
        }
        // --- 6. 앱이 화면에 보일 때 1초 타이머 시작 ---
        handler.post(runnable)
    }

    override fun onPause() {
        super.onPause()
        sensorManager.unregisterListener(this)
        // --- 7. 앱이 화면에서 사라질 때 1초 타이머 중지 (배터리 절약) ---
        handler.removeCallbacks(runnable)
    }

    override fun onSensorChanged(event: SensorEvent?) {
        if (event?.sensor?.type == Sensor.TYPE_LIGHT) {
            val luxValue = event.values[0]
            binding.tvLuxValue.text = "%.1f".format(luxValue)

            // --- 8. 센서 값이 바뀔 때마다 최신 값을 변수에 저장 ---
            latestLuxValue = luxValue

            val colorResId = when {
                luxValue < SPEC_MIN_LUX -> R.color.spec_out_dark_blue
                luxValue > SPEC_MAX_LUX -> R.color.spec_out_bright_red
                else -> R.color.spec_in_black
            }
            binding.tvLuxValue.setTextColor(ContextCompat.getColor(this, colorResId))
        }
    }

    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {
        // Do nothing
    }
}
이제 모든 준비가 끝났습니다. MainActivity.kt 코드에서 http://여기에-사용자-API-서버-IP주소/ 부분만 실제 운영하실 서버의 IP 주소로 변경하신 후 앱을 실행하면, 1초마다 조도 값이 MSSQL DB에 저장되는 것을 확인하실 수 있습니다.


그럼 웹api 서버를 우분투로 해도되나요 그게 더쉬울듯




생각하는 과정 표시
네, 그럼요! 오히려 훨씬 더 좋은 선택입니다.

우분투(Ubuntu)는 웹 서버로 가장 많이 사용되는 운영체제 중 하나이며, C# ASP.NET보다 훨씬 더 쉽고 빠르게 API 서버를 만들 수 있는 방법이 많습니다. Node.js나 Python을 사용하는 것이 일반적이고 자료도 훨씬 많습니다.

여기서는 가장 대중적이고 배우기 쉬운 **Node.js (Express 프레임워크)**를 사용하여 우분투에 API 서버를 구축하는 방법을 상세히 안내해 드리겠습니다.

## 1. 우분투(Ubuntu) 서버 준비
먼저 우분투 서버에 접속해서, API 서버를 실행하는 데 필요한 Node.js를 설치해야 합니다.

우분투 터미널에서 아래 명령어를 순서대로 입력하세요.

Bash

# 1. 패키지 목록 업데이트
sudo apt update

# 2. Node.js 및 npm(노드 패키지 관리자) 설치
sudo apt install nodejs npm -y

# 3. 설치 확인 (버전 정보가 나오면 성공)
node -v
npm -v
## 2. API 서버 프로젝트 생성 및 코드 작성
이제 조도 값을 받아서 MSSQL에 저장하는 API 코드를 작성합니다.

우분투 터미널에서 아래 작업을 순서대로 진행하세요.

1. 프로젝트 폴더 생성 및 이동

Bash

# 'light-api' 라는 이름의 폴더를 만들고 그 안으로 들어갑니다.
mkdir light-api
cd light-api
2. Node.js 프로젝트 시작 및 라이브러리 설치

Bash

# package.json 파일을 생성합니다. (모든 질문에 그냥 Enter를 누르세요)
npm init -y

# API 서버(Express)와 MSSQL 연결에 필요한 라이브러리를 설치합니다.
npm install express mssql
3. API 서버 코드 작성 (server.js)

nano 편집기를 사용해 server.js 파일을 만들고 아래 코드를 그대로 붙여넣으세요.

Bash

# server.js 파일 생성 및 편집기 열기
nano server.js
[아래 코드를 복사해서 터미널에 붙여넣기]

JavaScript

const express = require('express');
const sql = require('mssql');

const app = express();
app.use(express.json()); // 앱이 JSON 형태의 데이터를 받을 수 있게 설정

// --- ★★★ MSSQL 데이터베이스 연결 정보 (사용자 환경에 맞게 수정하세요!) ★★★ ---
const dbConfig = {
    user: '사용자ID',
    password: '비밀번호',
    server: '내서버IP', // MSSQL 서버 IP 주소
    database: '데이터베이스이름',
    options: {
        encrypt: false, // Azure SQL이 아닌 경우 false로 설정
        trustServerCertificate: true // 로컬 또는 사설망의 경우 true로 설정
    }
};
// -------------------------------------------------------------------------

// 안드로이드 앱에서 호출할 주소: http://우분투서버IP:3000/log
app.post('/log', async (req, res) => {
    const { lux } = req.body; // 앱에서 보낸 lux 값을 받음

    if (lux === undefined) {
        return res.status(400).send('lux 값이 없습니다.');
    }

    try {
        // DB 연결
        await sql.connect(dbConfig);
        
        // SQL 쿼리 실행
        const request = new sql.Request();
        request.input('LuxValue', sql.Float, lux);
        await request.query('INSERT INTO LightLog (LuxValue) VALUES (@LuxValue)');
        
        console.log(`데이터 저장 성공: ${lux} lux`);
        res.status(200).send('데이터 저장 성공');

    } catch (err) {
        console.error('DB 오류:', err);
        res.status(500).send('서버 오류 발생');
    } finally {
        // 연결 종료
        sql.close();
    }
});

const PORT = 3000;
app.listen(PORT, () => {
    console.log(`API 서버가 ${PORT}번 포트에서 실행 중입니다.`);
});
[붙여넣기 후 저장 및 종료]

Ctrl + X 키를 누릅니다.

Y 키를 누릅니다.

Enter 키를 누릅니다.

## 3. API 서버 실행
이제 만든 API 서버를 실행할 차례입니다.

우분투 터미널에서 아래 명령어를 입력하세요.

Bash

node server.js
"API 서버가 3000번 포트에서 실행 중입니다." 라는 메시지가 나오면 성공입니다.

## 4. 안드로이드 앱 최종 수정
마지막으로, 안드로이드 앱이 C# 서버가 아닌 새로 만든 우분투 서버를 바라보도록 MainActivity.kt 파일의 주소만 수정하면 됩니다.

파일 위치: app > src > main > java > com.sec.lightmeter > MainActivity.kt

수정할 부분: setupNetwork() 함수 안의 .baseUrl()

Kotlin

// ... 기존 코드 ...
private fun setupNetwork() {
    val retrofit = Retrofit.Builder()
        // ★★반드시 사용자님의 '우분투 서버 IP' 주소와 포트번호 '3000'으로 변경하세요!★★
        .baseUrl("http://여기에-사용자-우분투-서버-IP주소:3000/") 
        .addConverterFactory(GsonConverterFactory.create())
        .build()

    apiService = retrofit.create(ApiService::class.java)
}

// ... 기존 코드 ...
// ApiService 인터페이스의 @POST 주소도 수정해야 합니다.
interface ApiService {
    // HTTP POST 방식으로 "log" 경로에 데이터를 보냄
    @POST("log")
    fun postLightValue(@Body data: LightData): Call<String>
}