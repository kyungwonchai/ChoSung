이제 요구 사항을 명확하게 반영하여, 통신 로그를 리스트박스에 표시하고, 센서 3개로 확장하며, 각 로그 항목에는 연월일시분초가 기록되도록 수정하겠습니다. 또한, 최대 50개의 로그 항목만 유지되도록 하고, 최근 로그가 맨 위로 추가되도록 구현할 것입니다.

수정된 전체 코드
MainWindow.xaml (UI)
xml
코드 복사
<Window x:Class="PlcSimulation.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Simulator" Height="500" Width="600">
    <Grid>
        <!-- 통신 로그를 표시하는 리스트 박스 -->
        <ListBox Name="LogListBox" Width="550" Height="300" Margin="10,10,0,0"/>

        <!-- 첫 번째 센서 (R520) 버튼 -->
        <Button Name="SensorButton1" Content="Sensor 1 (R520)" Width="150" Height="30" Margin="10,320,0,0"
                MouseDown="SensorButton1_MouseDown" MouseUp="SensorButton1_MouseUp"/>

        <!-- 두 번째 센서 (R521) 버튼 -->
        <Button Name="SensorButton2" Content="Sensor 2 (R521)" Width="150" Height="30" Margin="170,320,0,0"
                MouseDown="SensorButton2_MouseDown" MouseUp="SensorButton2_MouseUp"/>

        <!-- 세 번째 센서 (R522) 버튼 -->
        <Button Name="SensorButton3" Content="Sensor 3 (R522)" Width="150" Height="30" Margin="330,320,0,0"
                MouseDown="SensorButton3_MouseDown" MouseUp="SensorButton3_MouseUp"/>
    </Grid>
</Window>
MainWindow.xaml.cs (PLC 시뮬레이터 동작 처리)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Windows;
using System.Windows.Threading;
using System.Collections.Generic;

namespace PlcSimulation
{
    public partial class MainWindow : Window
    {
        private PlcSimulator _plcSimulator;  // PLC 시뮬레이터 객체
        private SerialPort _serialPort;      // 시리얼 통신 객체
        private DispatcherTimer _timer;      // 상태 업데이트 타이머
        private List<string> _logList;       // 로그 리스트 (최대 50개)

        public MainWindow()
        {
            InitializeComponent();

            // PLC 시뮬레이터 초기화
            _plcSimulator = new PlcSimulator();

            // 로그 리스트 초기화 (최대 50개 유지)
            _logList = new List<string>();

            // 시리얼 포트 설정 (COM19, 9600 Baudrate, 기본 통신 설정)
            _serialPort = new SerialPort("COM19", 9600)
            {
                DataBits = 8,
                Parity = Parity.None,
                StopBits = StopBits.One,
                Handshake = Handshake.None
            };

            // 시리얼 포트 데이터 수신 이벤트 핸들러 등록
            _serialPort.DataReceived += SerialPort_DataReceived;

            // 시리얼 포트 열기
            OpenSerialPort();

            // 타이머 설정 (1초마다 상태 업데이트)
            _timer = new DispatcherTimer();
            _timer.Interval = TimeSpan.FromSeconds(1);
            _timer.Tick += Timer_Tick;
            _timer.Start();
        }

        // 시리얼 포트 열기 메서드
        private void OpenSerialPort()
        {
            try
            {
                if (!_serialPort.IsOpen)
                {
                    _serialPort.Open();
                    AddLog("PLC Simulator connected to COM19.");
                }
            }
            catch (Exception ex)
            {
                AddLog("Error opening COM port: " + ex.Message);
            }
        }

        // 시리얼 포트 데이터 수신 처리
        private void SerialPort_DataReceived(object sender, SerialDataReceivedEventArgs e)
        {
            try
            {
                string receivedData = _serialPort.ReadLine();  // 데이터 수신
                Dispatcher.Invoke(() => ProcessCommand(receivedData));  // UI 스레드에서 명령 처리
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => AddLog("Error reading from serial port: " + ex.Message));
            }
        }

        // 명령을 처리하고 응답하는 메서드
        private void ProcessCommand(string command)
        {
            string response = _plcSimulator.ProcessCommand(command);

            // 응답을 시리얼 포트로 전송
            if (_serialPort.IsOpen)
            {
                _serialPort.WriteLine(response);
            }

            // 로그에 기록
            AddLog($"Received: {command}, Response: {response}");
        }

        // 주기적으로 실행되는 타이머 이벤트 (UI 업데이트)
        private void Timer_Tick(object sender, EventArgs e)
        {
            // 각 센서의 값을 읽어 로그에 표시
            int sensorValue1 = _plcSimulator.ReadSensorValue("R520");
            int sensorValue2 = _plcSimulator.ReadSensorValue("R521");
            int sensorValue3 = _plcSimulator.ReadSensorValue("R522");

            AddLog($"Sensor R520: {(sensorValue1 == 1 ? "Detected" : "Not Detected")}, " +
                   $"R521: {(sensorValue2 == 1 ? "Detected" : "Not Detected")}, " +
                   $"R522: {(sensorValue3 == 1 ? "Detected" : "Not Detected")}");
        }

        // 센서 1 버튼을 눌렀을 때 (R520 감지)
        private void SensorButton1_MouseDown(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 1);  // 감지됨
            AddLog("Sensor R520: Detected (1)");
        }

        // 센서 1 버튼에서 마우스를 뗐을 때 (R520 감지 안 됨)
        private void SensorButton1_MouseUp(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R520", 0);  // 감지 안 됨
            AddLog("Sensor R520: Not Detected (0)");
        }

        // 센서 2 버튼을 눌렀을 때 (R521 감지)
        private void SensorButton2_MouseDown(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R521", 1);  // 감지됨
            AddLog("Sensor R521: Detected (1)");
        }

        // 센서 2 버튼에서 마우스를 뗐을 때 (R521 감지 안 됨)
        private void SensorButton2_MouseUp(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R521", 0);  // 감지 안 됨
            AddLog("Sensor R521: Not Detected (0)");
        }

        // 센서 3 버튼을 눌렀을 때 (R522 감지)
        private void SensorButton3_MouseDown(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R522", 1);  // 감지됨
            AddLog("Sensor R522: Detected (1)");
        }

        // 센서 3 버튼에서 마우스를 뗐을 때 (R522 감지 안 됨)
        private void SensorButton3_MouseUp(object sender, RoutedEventArgs e)
        {
            _plcSimulator.SetSensorValue("R522", 0);  // 감지 안 됨
            AddLog("Sensor R522: Not Detected (0)");
        }

        // 로그 추가 메서드 (최대 50개 유지, 시간 정보 포함)
        private void AddLog(string message)
        {
            string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
            string logEntry = $"{timestamp} - {message}";

            // 로그가 50개를 초과하면 가장 오래된 로그를 삭제
            if (_logList.Count >= 50)
            {
                _logList.RemoveAt(0);
            }

            // 로그 리스트에 추가하고 UI에 업데이트
            _logList.Insert(0, logEntry);  // 최근 로그가 맨 위에 위치
            LogListBox.ItemsSource = null; // UI 업데이트를 위해 먼저 null로 설정
            LogListBox.ItemsSource = _logList;
        }
    }
}
PlcSimulator.cs (PLC 동작 처리)
csharp
코드 복사
using System.Collections.Generic;

namespace PlcSimulation
{
    // PLC 시뮬레이터 클래스
    public class PlcSimulator
    {
        // PLC 메모리 시뮬레이션 (주소와 값 저장)
        private Dictionary<string, int> _plcMemory;

        // 생성자에서 메모리 초기화
        public PlcSimulator()
        {
            _plcMemory = new Dictionary<string, int>();

            // 초기 센서 값 설정 (0 = 감지 안 됨)
            _plcMemory["R520"] = 0;
            _plcMemory["R521"] = 0;
            _plcMemory["R522"] = 0;
        }

        // 명령어 처리
        public string ProcessCommand(string command)
        {
            // 쓰기 명령어 처리
            if (command.StartsWith("%01#WDD"))
            {
                return HandleWriteCommand(command);
            }
            // 읽기 명령어 처리
            else if (command.StartsWith("%01#RD"))
            {
                return HandleReadCommand(command);
            }

            return "Invalid Command";
        }

        // 쓰기 명령어 처리 메서드
        private string HandleWriteCommand(string command)
        {
            // 예: %01#WDD02300023000100** 에서 주소 2300과 값 0100을 추출
            string addressStr = command.Substring(7, 4); // 2300 주소
            string valueStr = command.Substring(15, 4);  // 0100 값

            // 주소와 값을 정수로 변환
            if (int.TryParse(addressStr, out int address) && int.TryParse(valueStr, out int value))
            {
                // 주소에 값을 저장
                _plcMemory[addressStr] = value;

                // 기본 응답 메시지
                return "$01SWD13";
            }

            return "Write Command Error";
        }

        // 읽기 명령어 처리 메서드
        private string HandleReadCommand(string command)
        {
            // 예: %01#RD0230** 에서 주소를 추출
            string addressStr = command.Substring(7, 4); // 읽을 주소

            // 주소에 해당하는 값을 반환
            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Value Not Found";
        }

        // PLC 메모리에서 주소 읽기
        public string ReadAddress(string addressStr)
        {
            if (_plcMemory.TryGetValue(addressStr, out int value))
            {
                return value.ToString();
            }

            return "Invalid Address or Value Not Found";
        }

        // 센서 값을 설정하는 메서드 (예: R520, R521, R522 주소)
        public void SetSensorValue(string address, int value)
        {
            if (_plcMemory.ContainsKey(address))
            {
                _plcMemory[address] = value;
            }
        }

        // 센서 값을 읽는 메서드
        public int ReadSensorValue(string address)
        {
            if (_plcMemory.TryGetValue(address, out int value))
            {
                return value;
            }

            return 0;  // 기본값은 감지 안 됨
        }
    }
}
기능 설명
로그 기능:

ListBox를 사용해 최대 50개의 로그를 기록합니다. 각 로그는 연월일시분초 형식으로 시간과 함께 표시됩니다.
최근 로그는 리스트의 맨 위에 추가되며, 50개를 초과하면 가장 오래된 로그가 삭제됩니다.
센서 3개:

R520, R521, R522라는 3개의 센서를 시뮬레이션하며, 각각 버튼으로 감지 상태를 처리합니다.
버튼을 눌렀을 때는 감지됨(1) 상태로, 버튼에서 손을 떼면 감지 안 됨(0) 상태로 설정됩니다.
PLC 명령어 처리:

**읽기(%01#RD)**와 쓰기(%01#WDD) 명령어를 처리합니다. 쓰기 명령어로 특정 주소에 값을 저장하고, 읽기 명령어로 그 값을 반환합니다.
요약
이 PLC 시뮬레이터는 센서 3개를 지원하며, 각 센서는 실시간으로 상태를 변경할 수 있습니다. 로그 기능은 주고받은 명령과 센서 상태 변화를 기록하며, 최근 로그가 리스트의 맨 위로 추가