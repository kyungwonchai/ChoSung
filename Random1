// SControl.Common/LocalDeviceControl.cs
using System;
using System.Runtime.InteropServices;
using System.ComponentModel; // Win32Exception 클래스 사용
using System.Threading;     // Thread.Sleep 사용

namespace SControl.Common
{
    public static class LocalDeviceControl
    {
        private const int HWND_BROADCAST = 0xFFFF;   
        private const uint WM_SYSCOMMAND = 0x0112;   
        private const uint SC_MONITORPOWER = 0xF170; 

        // user32.dll의 SendMessageTimeout 함수 원형 선언 (P/Invoke)
        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,                     // 첫 번째 파라미터: 대상 윈도우 핸들
            uint Msg,                        // <<--- 두 번째 파라미터: 메시지 ID (반드시 uint 여야 함!)
            UIntPtr wParam,                  // 세 번째 파라미터: 메시지의 첫 번째 추가 정보
            IntPtr lParam,                   // 네 번째 파라미터: 메시지의 두 번째 추가 정보
            SendMessageTimeoutFlags fuFlags, // 다섯 번째 파라미터: 메시지 전송 방법 플래그
            uint uTimeout,                   // 여섯 번째 파라미터: 타임아웃 시간 (밀리초)
            out UIntPtr lpdwResult);         // 일곱 번째 파라미터: 메시지 처리 결과 (out)

        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,
            SMTO_BLOCK = 0x1,
            SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8,
            SMTO_ERRORONEXIT = 0x20
        }

        public static void SetMonitorState(MonitorAction action)
        {
            if (!Enum.IsDefined(typeof(MonitorAction), action))
            {
                throw new ArgumentOutOfRangeException(nameof(action), "유효하지 않은 MonitorAction 값입니다.");
            }
            IntPtr lParam = (IntPtr)action;
            UIntPtr commandResultPlaceholder;

            IntPtr apiCallResult = SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,
                WM_SYSCOMMAND, // WM_SYSCOMMAND는 이미 uint 타입이므로 (uint) 캐스팅 불필요 (해도 무방)
                (UIntPtr)SC_MONITORPOWER,
                lParam,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG | SendMessageTimeoutFlags.SMTO_ERRORONEXIT,
                1000, 
                out commandResultPlaceholder);

            if (apiCallResult == IntPtr.Zero) 
            {
                int errorCode = Marshal.GetLastWin32Error();
                if (errorCode != 0) 
                {
                    throw new Win32Exception(errorCode, $"모니터 상태 변경 실패 (요청 동작: {action}). Win32 오류 코드: {errorCode}");
                }
            }
        }

        // --- SendInput 관련 P/Invoke 선언 및 구조체 ---
        [StructLayout(LayoutKind.Sequential)]
        private struct MOUSEINPUT { public int dx; public int dy; public uint mouseData; public uint dwFlags; public uint time; public IntPtr dwExtraInfo; }
        [StructLayout(LayoutKind.Sequential)]
        private struct KEYBDINPUT { public ushort wVk; public ushort wScan; public uint dwFlags; public uint time; public IntPtr dwExtraInfo; }
        [StructLayout(LayoutKind.Sequential)]
        private struct HARDWAREINPUT { public uint uMsg; public ushort wParamL; public ushort wParamH; }
        [StructLayout(LayoutKind.Explicit)]
        private struct MOUSEKEYBDHARDWAREINPUT { [FieldOffset(0)] public MOUSEINPUT mi; [FieldOffset(0)] public KEYBDINPUT ki; [FieldOffset(0)] public HARDWAREINPUT hi; }
        [StructLayout(LayoutKind.Sequential)]
        private struct INPUT { public uint type; public MOUSEKEYBDHARDWAREINPUT mkhi; }
        [DllImport("user32.dll", SetLastError = true)]
        private static extern uint SendInput(uint nInputs, INPUT[] pInputs, int cbSize);
        private const uint INPUT_MOUSE = 0;
        private const uint MOUSEEVENTF_MOVE = 0x0001;
        // --- SendInput 관련 끝 ---

        public static void SimulateSmallMouseMovement()
        {
            INPUT[] inputs = new INPUT[2];
            inputs[0] = new INPUT { type = INPUT_MOUSE, mkhi = new MOUSEKEYBDHARDWAREINPUT { mi = new MOUSEINPUT { dx = 1, dy = 0, dwFlags = MOUSEEVENTF_MOVE } } };
            inputs[1] = new INPUT { type = INPUT_MOUSE, mkhi = new MOUSEKEYBDHARDWAREINPUT { mi = new MOUSEINPUT { dx = -1, dy = 0, dwFlags = MOUSEEVENTF_MOVE } } };
            uint inputsSent = SendInput((uint)inputs.Length, inputs, Marshal.SizeOf(typeof(INPUT)));
            if (inputsSent < inputs.Length)
            {
                Console.WriteLine($"SimulateSmallMouseMovement: SendInput sent {inputsSent} of {inputs.Length} inputs. LastError: {Marshal.GetLastWin32Error()}");
            }
            Thread.Sleep(50); 
        }
    }
}