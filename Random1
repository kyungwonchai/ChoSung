아래는 요구 사항에 맞추어 20글자 이하의 보낸값을 고유키로 처리하여, 해당 보낸값의 응답 중 최초 응답과 이후 변경된 응답만 기록하도록 한 코드입니다.

이 코드는 다음과 같은 기능을 포함합니다:

DetailCMD 파일을 기존 방식대로 처리하되, 보낸값이 20자 이하인 경우 최초 응답과 변경된 응답만 수집합니다.
다른 파일들은 기존 처리 방식대로 시간과 남은 데이터를 하나의 열에 저장합니다.
Sheet1에는 모든 데이터가 시간 순서로 정렬되어 있으며, Sheet2에는 필터링된 응답 기록이 정렬되어 추가됩니다.
최종적으로 두 시트를 하나의 CSV 파일로 내보내며, Sheet1과 Sheet2로 구분된 데이터를 제공합니다.

최종 코드
python
코드 복사
import os
import csv
import re
from datetime import datetime, timedelta

# 디렉토리 경로 설정
directory_path = 'c:/prod_file_logs/'
output_directory = 'c:/Agent/'

# 3일 전 날짜 계산
three_days_ago = datetime.now() - timedelta(days=3)

# 정규 표현식 패턴 설정
time_pattern = r'\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}\.\d{3}'  # 날짜와 시간 추출 패턴
key_pattern = r'고유키:[^\s]+'  # 고유키 추출 패턴 (공백 전까지)
send_value_pattern = r'보낸값:[^\s]+'  # 보낸값 추출 패턴 (공백 전까지)
recv_value_pattern = r'받은값:[^\s]+'  # 받은값 추출 패턴 (공백 전까지)

# 데이터 저장 리스트
data_for_csv = []   # Sheet1용 전체 데이터
filtered_data = []  # Sheet2용 필터링된 데이터

# 보낸값이 20자 이하인 경우, 변경된 응답을 기록하기 위해 응답 상태 추적
response_tracker = {}

# 디렉토리 및 하위 폴더 내 모든 파일을 재귀적으로 탐색
for root, dirs, files in os.walk(directory_path):
    for filename in files:
        # 3일 전 이후 생성된 파일만 처리
        file_path = os.path.join(root, filename)
        file_creation_time = datetime.fromtimestamp(os.path.getctime(file_path))
        
        if file_creation_time >= three_days_ago:
            with open(file_path, 'r', encoding='utf-8') as file:
                lines = file.readlines()  # 파일의 모든 줄을 읽음
                i = 0
                
                # DetailCMD 파일 처리
                if 'DetailCMD' in filename:
                    while i < len(lines):
                        # "보낸값" 줄을 찾음
                        send_match = re.search(send_value_pattern, lines[i])
                        
                        if send_match:
                            # "보낸값" 줄에서 시간, 고유키, 보낸값 추출
                            time_match = re.search(time_pattern, lines[i])
                            key_match = re.search(key_pattern, lines[i])
                            
                            if time_match and key_match:
                                # 시간과 고유키 추출
                                time_str = time_match.group()
                                unique_key = key_match.group().split(':')[1]
                                send_value = send_match.group().split(':')[1]

                                # 시간 형식을 "yyMMdd HHmmss"로 변환
                                original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                                formatted_time = original_time.strftime('%y%m%d %H%M%S')

                                # 다음 줄에서 "받은값" 추출
                                if i + 1 < len(lines):
                                    recv_match = re.search(recv_value_pattern, lines[i + 1])

                                if recv_match:
                                    recv_value = recv_match.group().split(':')[1]
                                    recv_length = len(recv_value)

                                    # Sheet1에 모든 데이터를 추가
                                    data_for_csv.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                                    # 보낸값이 20자 이하인 경우, 최초 및 변경된 응답만 추가
                                    if len(send_value) <= 20:
                                        # 고유키별 응답 상태 추적
                                        if send_value not in response_tracker:
                                            # 최초 응답을 기록
                                            response_tracker[send_value] = recv_value
                                            filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])
                                        elif response_tracker[send_value] != recv_value:
                                            # 응답이 변경되었을 경우에만 기록
                                            response_tracker[send_value] = recv_value
                                            filtered_data.append([filename, formatted_time, unique_key, send_value, recv_value, recv_length])

                            # "보낸값" 다음 줄로 이동
                            i += 2
                        else:
                            # "보낸값"이 없는 경우 다음 줄로 이동
                            i += 1
                
                # 기타 파일 처리
                else:
                    for line in lines:
                        # 각 행에서 시간 추출
                        time_match = re.search(time_pattern, line)
                        if time_match:
                            time_str = time_match.group()
                            remaining_data = line[len(time_str):].strip()  # 시간 이후의 모든 데이터를 추출
                            
                            # 시간 형식을 "yyMMdd HHmmss"로 변환
                            original_time = datetime.strptime(time_str, '%Y-%m-%d %H:%M:%S.%f')
                            formatted_time = original_time.strftime('%y%m%d %H%M%S')
                            
                            # 데이터 리스트에 추가 (파일명, 시간, 남은 데이터)
                            data_for_csv.append([filename, formatted_time, remaining_data])

# 수집된 모든 데이터를 Time 컬럼 기준으로 오름차순 정렬
data_for_csv.sort(key=lambda x: x[1])
filtered_data.sort(key=lambda x: x[1])

# CSV 파일 저장
timestamp = datetime.now().strftime('%Y%m%d%H%M%S')
output_csv_path = os.path.join(output_directory, f'output_{timestamp}.csv')

with open(output_csv_path, 'w', newline='', encoding='utf-8-sig') as csvfile:
    csv_writer = csv.writer(csvfile)
    csv_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    csv_writer.writerows(data_for_csv)

# 별도 시트2에 해당하는 필터링된 응답을 저장
filtered_output_path = os.path.join(output_directory, f'filtered_output_{timestamp}.csv')

with open(filtered_output_path, 'w', newline='', encoding='utf-8-sig') as filtered_csvfile:
    filtered_writer = csv.writer(filtered_csvfile)
    filtered_writer.writerow(['Filename', 'Time', 'Unique Key', 'Sent Value', 'Received Value', 'Length / Remaining Data'])
    filtered_writer.writerows(filtered_data)

print(f'\n모든 데이터를 Sheet1에 저장 완료: {output_csv_path}')
print(f'필터링된 데이터를 Sheet2에 저장 완료: {filtered_output_path}')
코드 설명
하위 폴더 탐색:

os.walk(directory_path)로 c:/prod_file_logs/의 모든 하위 폴더와 파일을 탐색합니다.
파일 구분 처리:

DetailCMD 파일은 기존 방식대로 처리하여 데이터를 Sheet1로 저장하며, 보낸값이 20자 이하인 경우 최초 및 변경된 응답만 filtered_data에 추가하여 Sheet2로 저장합니다.
기타 파일들은 시간 컬럼과 남은 모든 데이터를 data_for_csv에 하나의 열로 저장합니다.
응답 필터링:

response_tracker 딕셔너리를 사용하여 보낸값이 20자 이하인 경우 최초 응답을 기록하고 이후 변경된 응답만 추가하여 Sheet2에 저장합니다.
정렬 및 CSV 파일 저장:
