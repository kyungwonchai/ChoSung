네, 네임드 파이프(named pipe)를 통해 서비스와 클라이언트(프로세스) 간의 지속적인 통신을 유지하고, 연결이 끊어지거나 문제가 발생했을 때 자동으로 재연결하는 로직을 구현하려면 몇 가지 추가적인 제어와 예외 처리가 필요합니다.

이 목표를 달성하기 위해 필요한 작업은 다음과 같습니다:

연결이 끊어졌을 때 재연결 시도: 서비스와 클라이언트 간의 연결이 끊어졌을 때 이를 감지하고, 자동으로 재연결을 시도해야 합니다.

타임아웃 처리: 클라이언트가 연결되지 않거나 연결 중 타임아웃이 발생할 경우 UI에 알리고, 다시 연결을 시도하도록 합니다.

로그 메시지 처리: 연결 상태와 관련된 모든 메시지를 클라이언트의 UI에 실시간으로 표시합니다.

서비스 측 LogService 구현
서비스에서는 네임드 파이프 서버를 설정하고, 클라이언트의 연결을 기다리며 로그를 지속적으로 전송합니다. 클라이언트와의 연결이 끊어지거나 문제가 발생했을 때 다시 연결을 시도해야 합니다.

csharp
코드 복사
using System;
using System.IO;
using System.IO.Pipes;
using System.Threading;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class LogService
    {
        private static LogService _instance; // 싱글톤 인스턴스
        private readonly string _logDirectory; // 로그 파일이 저장될 디렉터리 경로
        private readonly string _pipeName = "RouterMiddleACRLogPipe"; // 네임드 파이프 이름
        private NamedPipeServerStream _pipeServer;
        private StreamWriter _pipeWriter;
        private CancellationTokenSource _cancellationTokenSource;

        // 싱글톤 인스턴스 접근자
        public static LogService Instance
        {
            get
            {
                if (_instance == null)
                {
                    _instance = new LogService();
                }
                return _instance;
            }
        }

        // 생성자
        private LogService()
        {
            // 로그 디렉터리 경로 설정
            _logDirectory = Path.Combine("C:\\Logs", "RouterMiddleACRService", DateTime.Now.ToString("yyyyMM"));
            Directory.CreateDirectory(_logDirectory); // 디렉터리가 없으면 생성
        }

        // 로그 서비스를 시작하는 메서드
        public void Start()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ManagePipeServer(_cancellationTokenSource.Token));
        }

        // 로그 서비스를 중지하는 메서드
        public void Stop()
        {
            _cancellationTokenSource.Cancel();
            _pipeWriter?.Dispose();
            _pipeServer?.Dispose();
        }

        // 파이프 서버를 관리하고, 클라이언트와의 지속적인 연결을 유지하는 메서드
        private async Task ManagePipeServer(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await StartPipeServer(cancellationToken);
                }
                catch (Exception ex)
                {
                    Console.WriteLine($"Error in pipe server: {ex.Message}");
                }

                // 클라이언트 연결이 끊어진 경우 5초 후 재시도
                await Task.Delay(5000, cancellationToken);
            }
        }

        // 네임드 파이프 서버를 시작하고 클라이언트와 통신하는 메서드
        private async Task StartPipeServer(CancellationToken cancellationToken)
        {
            try
            {
                _pipeServer = new NamedPipeServerStream(_pipeName, PipeDirection.Out, 1, PipeTransmissionMode.Message, PipeOptions.Asynchronous);
                Console.WriteLine("Waiting for client connection...");
                
                await _pipeServer.WaitForConnectionAsync(cancellationToken);
                Console.WriteLine("Client connected to pipe.");
                
                _pipeWriter = new StreamWriter(_pipeServer) { AutoFlush = true };

                while (!cancellationToken.IsCancellationRequested && _pipeServer.IsConnected)
                {
                    string logMessage = $"Log message at {DateTime.Now}";
                    _pipeWriter.WriteLine(logMessage);
                    await Task.Delay(1000, cancellationToken); // 1초 대기
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Pipe server error: {ex.Message}");
            }
            finally
            {
                _pipeWriter?.Dispose();
                _pipeServer?.Dispose();
            }
        }
    }
}
서비스 코드 설명
ManagePipeServer 메서드:

이 메서드는 파이프 서버를 관리하며, 클라이언트와의 연결이 끊어졌을 때 재연결을 시도합니다. 무한 루프 내에서 StartPipeServer를 호출하고, 예외가 발생하거나 클라이언트 연결이 끊어질 경우 5초 후에 재시도합니다.
StartPipeServer 메서드:

네임드 파이프 서버를 시작하고, 클라이언트와 연결된 상태에서 로그 메시지를 지속적으로 전송합니다.
클라이언트 연결이 끊어지거나 예외가 발생하면 finally 블록에서 리소스를 정리하고 종료됩니다.
클라이언트 측 네임드 파이프 클라이언트 구현
클라이언트(프로세스) 측에서는 네임드 파이프 클라이언트를 설정하고, 서비스가 보내는 로그 메시지를 수신합니다. 연결이 끊어졌거나 문제가 발생하면 재연결을 시도합니다.

csharp
코드 복사
using System;
using System.IO;
using System.IO.Pipes;
using System.Threading;
using System.Threading.Tasks;
using System.Windows;

namespace RouterMiddleACR
{
    public partial class MainWindow : Window
    {
        private NamedPipeClientStream _pipeClient;
        private StreamReader _pipeReader;
        private CancellationTokenSource _cancellationTokenSource;
        private readonly string _pipeName = "RouterMiddleACRLogPipe";

        public MainWindow()
        {
            InitializeComponent();
            StartListeningToLogs();
        }

        // 로그 수신을 시작하는 메서드
        private void StartListeningToLogs()
        {
            _cancellationTokenSource = new CancellationTokenSource();
            Task.Run(() => ListenForLogs(_cancellationTokenSource.Token));
        }

        // 로그 수신 및 연결 관리 메서드
        private async Task ListenForLogs(CancellationToken cancellationToken)
        {
            while (!cancellationToken.IsCancellationRequested)
            {
                try
                {
                    await ConnectToPipeServer(cancellationToken);
                }
                catch (Exception ex)
                {
                    Dispatcher.Invoke(() => LogMessage($"ERROR: {ex.Message}"));
                }

                // 연결이 끊어진 경우 5초 후 재시도
                await Task.Delay(5000, cancellationToken);
            }
        }

        // 파이프 서버에 연결하고 로그 메시지를 수신하는 메서드
        private async Task ConnectToPipeServer(CancellationToken cancellationToken)
        {
            try
            {
                _pipeClient = new NamedPipeClientStream(".", _pipeName, PipeDirection.In);
                await _pipeClient.ConnectAsync(10000, cancellationToken); // 10초 타임아웃 설정

                Dispatcher.Invoke(() => LogMessage("Named pipe connected successfully."));

                _pipeReader = new StreamReader(_pipeClient);
                while (_pipeClient.IsConnected && !cancellationToken.IsCancellationRequested)
                {
                    var message = await _pipeReader.ReadLineAsync();
                    if (message != null)
                    {
                        Dispatcher.Invoke(() => LogMessage(message));
                    }
                }
            }
            catch (Exception ex)
            {
                Dispatcher.Invoke(() => LogMessage($"ERROR: {ex.Message}"));
            }
            finally
            {
                _pipeReader?.Dispose();
                _pipeClient?.Dispose();
            }
        }

        // UI에 로그 메시지를 출력하는 메서드
        private void LogMessage(string message)
        {
            // 여기에 로그 메시지를 ListBox나 다른 UI 요소에 추가하는 로직을 작성합니다.
            // 예: LogListBox.Items.Add(message);
        }

        private void Window_Closing(object sender, System.ComponentModel.CancelEventArgs e)
        {
            _cancellationTokenSource.Cancel();
        }
    }
}
클라이언트 코드 설명
ListenForLogs 메서드:

클라이언트가 서비스와의 연결을 관리하는 메서드입니다. 무한 루프 내에서 ConnectToPipeServer를 호출하여 서버와의 연결을 시도합니다. 연결이 끊어지면 예외를 처리하고, 5초 후에 재연결을 시도합니다.
ConnectToPipeServer 메서드:

네임드 파이프 서버에 연결하고, 로그 메시지를 수신하는 메서드입니다. 연결이 끊어지거나 예외가 발생하면 리소스를 정리하고 재연결을 준비합니다.
LogMessage 메서드:

UI에 로그 메시지를 표시하는 메서드입니다. 로그 메시지를 ListBox 또는 다른 UI 요소에 추가하는 로직을 작성할 수 있습니다.
요약
자동 재연결: 서비스와 클라이언트는 연결이 끊어지면 일정 시간 후에 자동으로










