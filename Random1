함수를 주기적으로 실행하는 10분 타이머 코드를 System.Timers.Timer와 System.Threading.Timer 두 가지 방법으로 작성해 줄게.

✅ System.Timers.Timer을 이용한 비동기 async 함수 실행 (C# 콘솔)
csharp
코드 복사
using System;
using System.Timers;
using System.Threading.Tasks;

class Program
{
    private Timer _timer;

    public Program()
    {
        // 10분(600,000ms)마다 실행
        _timer = new Timer(600000);
        _timer.Elapsed += async (sender, e) => await OnTimedEvent(); // 비동기 핸들러
        _timer.AutoReset = true; // 반복 실행
        _timer.Enabled = true; // 타이머 시작
    }

    private async Task OnTimedEvent()
    {
        Console.WriteLine($"비동기 함수 실행됨: {DateTime.Now}");
        await ExecuteFunction();
    }

    private async Task ExecuteFunction()
    {
        Console.WriteLine("10분마다 실행되는 async 함수 시작...");
        await Task.Delay(2000); // 비동기 작업 (예: API 호출)
        Console.WriteLine("비동기 작업 완료!");
    }

    static void Main()
    {
        Program program = new Program(); // 인스턴스 생성

        Console.WriteLine("타이머가 시작되었습니다. 종료하려면 Enter 키를 누르세요.");
        Console.ReadLine();
    }
}
Elapsed 이벤트에서 직접 async void를 사용하면 예외가 제대로 전파되지 않으므로 **람다식 (async (sender, e) => await OnTimedEvent())**을 사용!

✅ System.Threading.Timer을 이용한 비동기 async 함수 실행 (C# 콘솔)
csharp
코드 복사
using System;
using System.Threading;
using System.Threading.Tasks;

class Program
{
    private Timer _timer;

    public Program()
    {
        _timer = new Timer(async state => await OnTimedEvent(), null, TimeSpan.Zero, TimeSpan.FromMinutes(10));
    }

    private async Task OnTimedEvent()
    {
        Console.WriteLine($"비동기 함수 실행됨: {DateTime.Now}");
        await ExecuteFunction();
    }

    private async Task ExecuteFunction()
    {
        Console.WriteLine("10분마다 실행되는 async 함수 시작...");
        await Task.Delay(2000); // 비동기 작업 (예: API 호출)
        Console.WriteLine("비동기 작업 완료!");
    }

    static void Main()
    {
        Program program = new Program(); // 인스턴스 생성

        Console.WriteLine("타이머가 시작되었습니다. 종료하려면 Enter 키를 누르세요.");
        Console.ReadLine();
    }
}
Timer가 생성될 때 async 람다 (async state => await OnTimedEvent())를 사용하여 비동기 작업을 안전하게 처리!

✅ DispatcherTimer를 이용한 비동기 async 함수 실행 (WPF)
csharp
코드 복사
using System;
using System.Threading.Tasks;
using System.Windows.Threading;

public class TimerExample
{
    private DispatcherTimer _timer;

    public TimerExample()
    {
        _timer = new DispatcherTimer();
        _timer.Interval = TimeSpan.FromMinutes(10);
        _timer.Tick += async (sender, e) => await OnTimedEvent();
        _timer.Start();
    }

    private async Task OnTimedEvent()
    {
        Console.WriteLine($"비동기 함수 실행됨: {DateTime.Now}");
        await ExecuteFunction();
    }

    private async Task ExecuteFunction()
    {
        Console.WriteLine("10분마다 실행되는 async 함수 시작...");
        await Task.Delay(2000); // 비동기 작업 (예: API 호출)
        Console.WriteLine("비동기 작업 완료!");
    }
}
DispatcherTimer는 UI 스레드에서 실행되므로 UI를 갱신하는 비동기 작업을 할 때 적합!

⚡ 어떤 방식이 좋을까?
방식	장점	단점	추천 사용 환경
System.Timers.Timer	정확한 주기로 실행	UI 스레드 접근 어려움	콘솔, 서비스
System.Threading.Timer	정확한 주기, 백그라운드 실행	UI 직접 접근 불가능	콘솔, 서비스