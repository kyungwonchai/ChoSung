검정 화면이 뜨는 문제는 FindWindow 함수가 올바른 창 핸들을 찾지 못하거나, SetForegroundWindow와 ShowWindow 호출이 잘못되었을 때 발생할 수 있습니다. 이를 해결하기 위해 WPF의 창 핸들을 정확하게 찾아 기존 인스턴스를 활성화하는 방법을 조금 수정하겠습니다.

WPF 애플리케이션에서는 FindWindow로 정확한 핸들을 찾기 어려울 수 있으므로, WPF의 MainWindow를 직접 검색하는 방식으로 수정해보겠습니다.

수정된 코드: App.xaml.cs
csharp
코드 복사
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows;

namespace YourNamespace
{
    public partial class App : Application
    {
        private static Mutex _mutex;
        private const string MutexName = "YourUniqueMutexName"; // 고유한 이름으로 변경하세요

        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool ShowWindow(IntPtr hWnd, int nCmdShow);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr FindWindow(string lpClassName, string lpWindowName);

        private const int SW_RESTORE = 9;

        protected override void OnStartup(StartupEventArgs e)
        {
            bool isNewInstance;
            _mutex = new Mutex(true, MutexName, out isNewInstance);

            if (!isNewInstance)
            {
                // 이미 실행 중인 프로그램이 있는 경우, 기존 인스턴스를 활성화
                ActivateExistingInstance();
                Shutdown(); // 새 인스턴스를 종료
                return;
            }

            base.OnStartup(e);
        }

        private void ActivateExistingInstance()
        {
            Application.Current.Dispatcher.Invoke(() =>
            {
                // WPF 애플리케이션의 활성 창을 찾기 위해 LINQ와 Win32 API를 결합하여 정확한 핸들을 찾습니다.
                var existingWindow = Application.Current.Windows.OfType<MainWindow>().FirstOrDefault();

                if (existingWindow != null)
                {
                    // WPF 창 핸들을 가져옵니다.
                    var wih = new System.Windows.Interop.WindowInteropHelper(existingWindow);
                    IntPtr hWnd = wih.Handle;

                    if (hWnd != IntPtr.Zero)
                    {
                        // 트레이에 내려간 상태라면 윈도우를 복원
                        ShowWindow(hWnd, SW_RESTORE);
                        // 윈도우를 활성화
                        SetForegroundWindow(hWnd);
                    }
                }
            });
        }

        protected override void OnExit(ExitEventArgs e)
        {
            _mutex?.ReleaseMutex();
            _mutex?.Dispose();
            base.OnExit(e);
        }
    }
}
코드 수정 설명
WPF 윈도우 직접 검색:

Application.Current.Windows.OfType<MainWindow>().FirstOrDefault()를 사용하여 현재 실행 중인 WPF 애플리케이션의 MainWindow를 찾습니다. WPF에서는 창 클래스를 직접 사용하는 것이 FindWindow 함수보다 더 안정적입니다.
찾은 MainWindow를 WindowInteropHelper를 통해 핸들(hWnd)을 얻어냅니다.
Dispatcher 사용:

Application.Current.Dispatcher.Invoke를 사용하여 UI 스레드에서 안전하게 실행되도록 합니다.
ShowWindow와 SetForegroundWindow:

ShowWindow는 트레이로 내려간 창을 다시 복원하며, SetForegroundWindow는 창을 최상위로 가져옵니다.
주의사항
MainWindow는 WPF 애플리케이션의 기본 창 클래스 이름입니다. 만약 다른 이름을 사용하고 있다면 코드에서 클래스 이름을 수정해야 합니다.