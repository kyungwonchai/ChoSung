USB 바코드 스캐너가 COM 포트로 잡히는 경우도 있지만, 그렇지 않은 경우도 있습니다. 일반적으로 USB 바코드 스캐너는 HID(Human Interface Device)로 인식되어 키보드 입력처럼 동작합니다. 이를 확인하기 위해 먼저 바코드 스캐너가 COM 포트로 인식되는지 확인하는 절차를 알려드리겠습니다.

USB 바코드 스캐너가 COM 포트로 인식되는지 확인하는 방법
장치 관리자 열기:

Windows + X를 누르고 "장치 관리자"를 선택합니다.
포트 (COM 및 LPT) 확인:

"포트 (COM 및 LPT)" 항목을 확장합니다.
여기서 USB 바코드 스캐너가 COM 포트로 인식되는지 확인합니다. 예를 들어, "USB Serial Port (COMxx)"로 표시됩니다.
USB 바코드 스캐너가 COM 포트로 인식되지 않는 경우
USB 바코드 스캐너가 COM 포트로 인식되지 않고 HID 장치로 인식되는 경우, HID 입력을 읽어야 합니다. 이를 위해 Windows의 Raw Input API를 사용할 수 있습니다.

Raw Input을 사용하여 HID 바코드 스캐너 데이터 읽기
다음은 C#에서 Raw Input을 사용하여 USB 바코드 스캐너의 데이터를 읽는 방법입니다.

1. 프로젝트 설정
새 C# 콘솔 애플리케이션 프로젝트 생성:

Visual Studio에서 새 C# 콘솔 애플리케이션 프로젝트를 생성합니다.
Raw Input 관련 참조 추가:

프로젝트에 System.Runtime.InteropServices 네임스페이스를 사용합니다.
2. 코드 작성
RawInput 클래스 작성
먼저, RawInput 클래스와 관련된 코드를 작성합니다.

csharp
코드 복사
using System;
using System.Runtime.InteropServices;
using System.Text;

namespace RawInput
{
    class Program
    {
        const int RID_INPUT = 0x10000003;
        const int RIM_TYPEKEYBOARD = 1;
        const int RIM_TYPEHID = 2;

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTDEVICE
        {
            public ushort UsagePage;
            public ushort Usage;
            public uint Flags;
            public IntPtr Target;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTDEVICELIST
        {
            public IntPtr hDevice;
            public uint dwType;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTHEADER
        {
            public uint dwType;
            public uint dwSize;
            public IntPtr hDevice;
            public IntPtr wParam;
        }

        [StructLayout(LayoutKind.Explicit)]
        struct RAWINPUT
        {
            [FieldOffset(0)]
            public RAWINPUTHEADER header;
            [FieldOffset(16)]
            public RAWKEYBOARD keyboard;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWKEYBOARD
        {
            public ushort MakeCode;
            public ushort Flags;
            public ushort Reserved;
            public ushort VKey;
            public uint Message;
            public uint ExtraInformation;
        }

        [DllImport("User32.dll")]
        static extern uint GetRawInputDeviceList(IntPtr pRawInputDeviceList, ref uint uiNumDevices, uint cbSize);

        [DllImport("User32.dll")]
        static extern uint GetRawInputData(IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);

        [DllImport("User32.dll")]
        static extern bool RegisterRawInputDevices(RAWINPUTDEVICE[] pRawInputDevice, uint uiNumDevices, uint cbSize);

        static void Main(string[] args)
        {
            // RAWINPUTDEVICE 구조체 배열 생성
            RAWINPUTDEVICE[] rid = new RAWINPUTDEVICE[1];
            rid[0].UsagePage = 0x01; // Generic Desktop Controls
            rid[0].Usage = 0x06; // Keyboard
            rid[0].Flags = 0;
            rid[0].Target = IntPtr.Zero;

            // Raw Input 등록
            if (!RegisterRawInputDevices(rid, (uint)rid.Length, (uint)Marshal.SizeOf(typeof(RAWINPUTDEVICE))))
            {
                Console.WriteLine("Failed to register raw input device(s).");
                return;
            }

            Console.WriteLine("Press any key to exit...");
            Console.ReadKey();
        }
    }
}
이 코드는 USB 바코드 스캐너가 키보드로 인식되는 경우 Raw Input을 통해 데이터를 읽을 수 있도록 설정합니다. 여기서 RegisterRawInputDevices를 사용하여 Raw Input을 등록하고, 입력 데이터를 읽을 준비를 합니다.

3. 데이터 읽기
실제 입력 데이터를 읽어오는 부분을 추가해야 합니다. 이를 위해 메시지 루프를 만들어 Raw Input 데이터를 처리합니다.

csharp
코드 복사
using System;
using System.Runtime.InteropServices;
using System.Text;
using System.Windows.Forms;

namespace RawInput
{
    class Program : Form
    {
        const int WM_INPUT = 0x00FF;
        const int RID_INPUT = 0x10000003;

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTDEVICE
        {
            public ushort UsagePage;
            public ushort Usage;
            public uint Flags;
            public IntPtr Target;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTHEADER
        {
            public uint dwType;
            public uint dwSize;
            public IntPtr hDevice;
            public IntPtr wParam;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWKEYBOARD
        {
            public ushort MakeCode;
            public ushort Flags;
            public ushort Reserved;
            public ushort VKey;
            public uint Message;
            public uint ExtraInformation;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUT
        {
            public RAWINPUTHEADER header;
            public RAWKEYBOARD keyboard;
        }

        [DllImport("User32.dll")]
        static extern uint GetRawInputData(IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);

        [DllImport("User32.dll")]
        static extern bool RegisterRawInputDevices(RAWINPUTDEVICE[] pRawInputDevice, uint uiNumDevices, uint cbSize);

        protected override void WndProc(ref Message m)
        {
            if (m.Msg == WM_INPUT)
            {
                uint dwSize = 0;
                GetRawInputData(m.LParam, RID_INPUT, IntPtr.Zero, ref dwSize, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER)));

                IntPtr buffer = Marshal.AllocHGlobal((int)dwSize);
                try
                {
                    if (GetRawInputData(m.LParam, RID_INPUT, buffer, ref dwSize, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER))) == dwSize)
                    {
                        RAWINPUT raw = (RAWINPUT)Marshal.PtrToStructure(buffer, typeof(RAWINPUT));

                        if (raw.header.dwType == 1) // Keyboard input
                        {
                            Console.WriteLine("VKey: " + raw.keyboard.VKey);
                        }
                    }
                }
                finally
                {
                    Marshal.FreeHGlobal(buffer);
                }
            }

            base.WndProc(ref m);
        }

        static void Main()
        {
            Application.Run(new Program());
        }
    }
}
4. 코드 설명
RegisterRawInputDevices: Raw Input을 등록하여 키보드(바코드 스캐너) 입력을 받을 수 있도록 설정합니다.
WndProc: 메시지 루프에서 WM_INPUT 메시지를 처리하여 Raw Input 데이터를 읽습니다.
GetRawInputData: Raw Input 데이터를 가져와 키보드 입력을 처리합니다.
이 코드를 사용하면 USB 바코드 스캐너로부터 키보드 입력 데이터를 읽을 수 있습니다. 그런 다음, 이 데이터를 프로그램 A와 B가 열어 놓은 가상 COM 포트로 전달할 수 있습니다.

다음 단계
바코드 스캐너가 키보드로 인식되는지 확인합니다.
키보드 입력 데이터를 읽어 가상 COM 포트로 전달하는 코드를 작성합니다.
이렇게 하면 바코드 스캐너로부터 입력된 데이터를 프로그램 A와 B가 사용할 수 있도록 할 수 있습니다.





자,, 봐바,, 나는 지금 프로그램A에 실제 있는 포트만을 잡을수가 있는데 장치관리자에  Ports(COM & LPT)에 보면, USB Serial Port(COM6)처럼 이런 가상의 포트가 없다는거야
ChatGPT
이해했습니다. USB 바코드 스캐너가 COM 포트로 인식되지 않는 상황에서, 실제 포트로 데이터를 전달할 수 있도록 가상 COM 포트를 설정하고, 이를 통해 프로그램 A와 B에 데이터를 전달하는 방법을 설명드리겠습니다.

여기서는 com0com을 사용하여 가상 COM 포트를 생성하고, com2tcp와 같은 툴을 사용하여 USB 바코드 스캐너 데이터를 가상 COM 포트로 전달하는 방법을 다룹니다.

1. com0com 설치 및 가상 COM 포트 설정
com0com 다운로드 및 설치
com0com 다운로드:

SourceForge의 com0com 프로젝트 페이지에서 설치 파일을 다운로드합니다.
설치 파일 실행:

다운로드한 설치 파일 (com0com-3.0.0.0-i386-and-x64-signed.exe)을 실행합니다.
설치 도중에 Windows 보안 경고가 나타나면 "이 드라이버 소프트웨어를 설치합니다"를 선택합니다.
드라이버 서명 비활성화 (필요한 경우)
고급 시작 옵션:

설정 > 업데이트 및 보안 > 복구로 이동합니다.
고급 시작 옵션에서 "지금 다시 시작"을 클릭합니다.
드라이버 서명 비활성화:

재부팅 후 나타나는 옵션 화면에서 "문제 해결"을 선택합니다.
고급 옵션 > 시작 설정 > 다시 시작을 선택합니다.
다시 시작 후 나타나는 메뉴에서 7번 "드라이버 서명 적용 안 함"을 선택합니다.
가상 포트 페어 생성
com0com Setup Command Prompt 실행:

시작 메뉴에서 com0com 폴더를 찾아 Setup Command Prompt를 관리자 권한으로 실행합니다.
가상 포트 페어 생성:

다음 명령어를 입력하여 가상 포트를 생성합니다:
sh
코드 복사
install PortName=COM20 PortName=COM21
이렇게 하면 COM20과 COM21이라는 가상 포트 페어가 생성됩니다.
가상 포트 페어 확인:

생성된 가상 포트 페어를 확인하려면 다음 명령어를 입력합니다:
sh
코드 복사
list
2. USB 바코드 스캐너 데이터를 COM 포트로 전달
USB 바코드 스캐너가 키보드로 인식되므로, 이를 읽어 COM 포트로 전달하는 프로그램을 작성합니다.

C# 프로그램 작성
C# 프로그램을 작성하여 USB 바코드 스캐너로부터 데이터를 읽고, 이를 가상 포트 페어(COM20, COM21)로 전달합니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Windows.Forms;

namespace BarcodeScannerProxy
{
    public class Program : Form
    {
        static SerialPort _outputPort1;
        static SerialPort _outputPort2;
        private StringBuilder _barcode = new StringBuilder();

        const int WM_INPUT = 0x00FF;

        [STAThread]
        public static void Main()
        {
            _outputPort1 = new SerialPort("COM20", 9600);
            _outputPort2 = new SerialPort("COM21", 9600);

            _outputPort1.Open();
            _outputPort2.Open();

            Application.Run(new Program());

            _outputPort1.Close();
            _outputPort2.Close();
        }

        protected override void WndProc(ref Message m)
        {
            if (m.Msg == WM_INPUT)
            {
                ProcessInput(m.LParam);
            }
            base.WndProc(ref m);
        }

        private void ProcessInput(IntPtr lParam)
        {
            uint dwSize = 0;
            GetRawInputData(lParam, RID_INPUT, IntPtr.Zero, ref dwSize, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER)));

            IntPtr buffer = Marshal.AllocHGlobal((int)dwSize);
            try
            {
                if (GetRawInputData(lParam, RID_INPUT, buffer, ref dwSize, (uint)Marshal.SizeOf(typeof(RAWINPUTHEADER))) == dwSize)
                {
                    RAWINPUT raw = (RAWINPUT)Marshal.PtrToStructure(buffer, typeof(RAWINPUT));

                    if (raw.header.dwType == RIM_TYPEKEYBOARD)
                    {
                        ProcessRawKeyboard(raw.keyboard);
                    }
                }
            }
            finally
            {
                Marshal.FreeHGlobal(buffer);
            }
        }

        private void ProcessRawKeyboard(RAWKEYBOARD keyboard)
        {
            // 키보드 이벤트 처리 로직 추가
            // 예시: 스캔 데이터를 문자열로 변환
            char keyChar = ConvertVKeyToChar(keyboard.VKey);
            if (keyChar != '\0')
            {
                _barcode.Append(keyChar);
                if (keyChar == '\n')
                {
                    // 바코드 데이터 전송
                    SendBarcodeData(_barcode.ToString());
                    _barcode.Clear();
                }
            }
        }

        private char ConvertVKeyToChar(ushort vKey)
        {
            // 가상 키 코드를 문자로 변환하는 로직 추가
            // 예시: 기본적인 ASCII 값 변환
            if (vKey >= 0x30 && vKey <= 0x39) // 숫자 키
            {
                return (char)vKey;
            }
            if (vKey >= 0x41 && vKey <= 0x5A) // 알파벳 키
            {
                return (char)vKey;
            }
            if (vKey == 0x0D) // 엔터 키
            {
                return '\n';
            }
            return '\0';
        }

        private void SendBarcodeData(string data)
        {
            if (_outputPort1.IsOpen)
            {
                _outputPort1.Write(data);
            }
            if (_outputPort2.IsOpen)
            {
                _outputPort2.Write(data);
            }
        }

        [DllImport("User32.dll")]
        static extern uint GetRawInputData(IntPtr hRawInput, uint uiCommand, IntPtr pData, ref uint pcbSize, uint cbSizeHeader);

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTHEADER
        {
            public uint dwType;
            public uint dwSize;
            public IntPtr hDevice;
            public IntPtr wParam;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWKEYBOARD
        {
            public ushort MakeCode;
            public ushort Flags;
            public ushort Reserved;
            public ushort VKey;
            public uint Message;
            public uint ExtraInformation;
        }

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUT
        {
            public RAWINPUTHEADER header;
            public RAWKEYBOARD keyboard;
        }

        const int RID_INPUT = 0x10000003;
        const int RIM_TYPEKEYBOARD = 1;

        protected override void OnLoad(EventArgs e)
        {
            base.OnLoad(e);

            RAWINPUTDEVICE[] rid = new RAWINPUTDEVICE[1];
            rid[0].UsagePage = 0x01; // Generic Desktop Controls
            rid[0].Usage = 0x06; // Keyboard
            rid[0].Flags = 0;
            rid[0].Target = Handle;

            if (!RegisterRawInputDevices(rid, (uint)rid.Length, (uint)Marshal.SizeOf(typeof(RAWINPUTDEVICE))))
            {
                throw new ApplicationException("Failed to register raw input devices.");
            }
        }

        [DllImport("User32.dll", SetLastError = true)]
        static extern bool RegisterRawInputDevices(RAWINPUTDEVICE[] pRawInputDevice, uint uiNumDevices, uint cbSize);

        [StructLayout(LayoutKind.Sequential)]
        struct RAWINPUTDEVICE
        {
            public ushort UsagePage;
            public ushort Usage;
            public uint Flags;
            public IntPtr Target;
        }
    }
}
3. 사용 방법
프로그램 A와 B가 사용하는 포트 설정:

프로그램 A는 COM20을 사용하도록 설정합니다.
프로그램 B는 COM21을 사용하도록 설정합니다.
C# 프로그램 실행:

이 프로그램은 USB 바코드 스캐너로부터 키보드 입력 데이터를 읽고, 가상 COM 포트 페어(COM20, COM21)로 전달합니다.
이렇게 설정하면 프로그램 A와 B는 자신들이 지정한 COM 포트에서 데이터를 받을 수 있고, 실제 바코드 스캐너는 USB로 연결되어 있습니다. C# 프로그램이 중간에 데이터 브릿지 역할을 수행하여, 가상 COM 포트를 통해 데이터를 전달하게 됩니다.