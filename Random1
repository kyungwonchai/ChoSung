겠습니다! MVVM 패턴에 맞춰서 뷰모델을 통해 PLC 데이터 쓰기를 처리하는 방식으로 코드를 수정하겠습니다. 사용자가 주소와 값을 입력하고, 뷰모델을 통해 데이터 처리가 이루어지며, 결과가 UI에 표시되도록 할 것입니다.

1. MainWindow.xaml (UI)
xml
코드 복사
<Window x:Class="WpfApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="PLC Data Writer" Height="350" Width="400">
    <Grid>
        <StackPanel Margin="20">
            <TextBlock Text="주소 입력 (단일: 4자리, 멀티: 8자리)" />
            <TextBox Text="{Binding AddressInput}" Width="200" Height="30" MaxLength="8" />

            <TextBlock Text="값 입력 (숫자만 허용)" Margin="0,10,0,0" />
            <TextBox Text="{Binding ValueInput}" Width="200" Height="30" />

            <Button Content="값 기록" Width="200" Height="40" Margin="0,20,0,0" Command="{Binding WriteCommand}" />

            <TextBlock Text="{Binding ResultMessage}" Margin="0,20,0,0" Foreground="Green" />
        </StackPanel>
    </Grid>
</Window>
2. MainViewModel.cs (뷰모델)
뷰모델을 통해 값 쓰기 처리를 구현합니다. 사용자 입력 검증 및 명령 실행을 MVVM 패턴에 맞게 처리합니다.

csharp
코드 복사
using System;
using System.Linq;
using System.ComponentModel;
using System.Windows.Input;

namespace WpfApp
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private ComportManager comportManager;

        private string addressInput;
        private string valueInput;
        private string resultMessage;

        public string AddressInput
        {
            get { return addressInput; }
            set
            {
                addressInput = value;
                OnPropertyChanged(nameof(AddressInput));
            }
        }

        public string ValueInput
        {
            get { return valueInput; }
            set
            {
                valueInput = value;
                OnPropertyChanged(nameof(ValueInput));
            }
        }

        public string ResultMessage
        {
            get { return resultMessage; }
            set
            {
                resultMessage = value;
                OnPropertyChanged(nameof(ResultMessage));
            }
        }

        public ICommand WriteCommand { get; }

        public MainViewModel()
        {
            comportManager = ComportManager.GetInstance();
            WriteCommand = new RelayCommand(ExecuteWriteCommand, CanExecuteWriteCommand);
        }

        private bool CanExecuteWriteCommand(object parameter)
        {
            // 주소는 4자리 또는 8자리, 값은 숫자만 허용
            return IsValidAddress(AddressInput) && IsValidValue(ValueInput);
        }

        private void ExecuteWriteCommand(object parameter)
        {
            try
            {
                if (AddressInput.Length == 4) // 단일 주소 처리
                {
                    int value = int.Parse(ValueInput);
                    string response = comportManager.WriteSingleData(AddressInput, value);
                    ResultMessage = $"단일 주소 {AddressInput}에 값 {ValueInput} 기록 성공!";
                }
                else if (AddressInput.Length == 8) // 멀티 주소 처리
                {
                    string startAddress = AddressInput.Substring(0, 4);
                    string endAddress = AddressInput.Substring(4, 4);

                    int[] values = ValueInput.Split(',').Select(int.Parse).ToArray();

                    string response = comportManager.WriteMultipleData(startAddress, endAddress, values);
                    ResultMessage = $"멀티 주소 {startAddress}~{endAddress}에 값 {ValueInput} 기록 성공!";
                }
            }
            catch (Exception ex)
            {
                ResultMessage = $"오류 발생: {ex.Message}";
            }
        }

        // 주소 유효성 검사 (4자리 또는 8자리 숫자)
        private bool IsValidAddress(string address)
        {
            return (address.Length == 4 || address.Length == 8) && address.All(char.IsDigit);
        }

        // 값 유효성 검사 (숫자만 허용)
        private bool IsValidValue(string value)
        {
            return value.All(c => char.IsDigit(c) || c == ',');
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
3. RelayCommand.cs (명령 패턴)
MVVM 패턴에서 명령을 사용하여 버튼 클릭 시 동작을 처리하기 위한 RelayCommand 클래스입니다.

csharp
코드 복사
using System;
using System.Windows.Input;

public class RelayCommand : ICommand
{
    private readonly Action<object> execute;
    private readonly Func<object, bool> canExecute;

    public RelayCommand(Action<object> execute, Func<object, bool> canExecute = null)
    {
        this.execute = execute;
        this.canExecute = canExecute;
    }

    public bool CanExecute(object parameter)
    {
        return canExecute == null || canExecute(parameter);
    }

    public void Execute(object parameter)
    {
        execute(parameter);
    }

    public event EventHandler CanExecuteChanged;

    public void RaiseCanExecuteChanged()
    {
        CanExecuteChanged?.Invoke(this, EventArgs.Empty);
    }
}
4. ComportManager.cs (PLC와 통신 처리)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;

public class ComportManager
{
    private static ComportManager _instance;
    private SerialPort _serialPort;

    private ComportManager() 
    {
        _serialPort = new SerialPort("COM1", 9600, Parity.None, 8, StopBits.One);
        _serialPort.Open();
    }

    public static ComportManager GetInstance()
    {
        if (_instance == null)
            _instance = new ComportManager();
        return _instance;
    }

    public string WriteSingleData(string startAddress, int value)
    {
        string valueString = value.ToString("D4");
        string command = $"%01#WDD{startAddress}{startAddress}{valueString}";

        string bcc = CalculateBCC(command);
        command += bcc + "\n";

        byte[] buffer = Encoding.ASCII.GetBytes(command);
        _serialPort.Write(buffer, 0, buffer.Length);

        return GetResponse();
    }

    public string WriteMultipleData(string startAddress, string endAddress, int[] values)
    {
        string valueData = string.Join("", Array.ConvertAll(values, v => v.ToString("D4")));  
        string command = $"%01#WDD{startAddress}{endAddress}{valueData}";

        string bcc = CalculateBCC(command);
        command += bcc + "\n";

        byte[] buffer = Encoding.ASCII.GetBytes(command);
        _serialPort.Write(buffer, 0, buffer.Length);

        return GetResponse();
    }

    private string CalculateBCC(string command)
    {
        int bcc = 0;
        foreach (char c in command)
        {
            bcc ^= c;
        }
        return bcc.ToString("X2");
    }

    private string GetResponse()
    {
        byte[] readBuffer = new byte[256];
        int bytesRead = _serialPort.Read(readBuffer, 0, readBuffer.Length);
        return Encoding.ASCII.GetString(readBuffer, 0, bytesRead);
    }
}
MVVM 패턴 전체 설명:
MainWindow.xaml:

UI에서 주소와 값을 입력받고, 명령 버튼을 클릭하면 입력 값이 뷰모델을 통해 처리됩니다.
MainViewModel:

AddressInput과 ValueInput은 사용자가 입력한 값을 바인딩합니다.
WriteCommand 명령이 실행되면, 입력값이 검증된 후 단일/멀티 주소로 처리됩니다.
처리 결과는 **ResultMessage**에 바인딩되어 UI에 표시됩니다.
RelayCommand:

버튼을 클릭했을 때 명령 실행을 처리하는 RelayCommand 클래스입니다.
ComportManager:

PLC와의 통신을 처리하는 부분으로, 입력된 주소와 값을 기반으로 명령을 PLC에 전송합니다.
단일/멀티 주소로 값을 기록하며, 결과는 BCC 검증 후 처리됩니다.
실행 예시:
단일 주소 입력: 주소 02300과 값 1을 입력하면 D2300에 값 0100이 기록됩니다.
멀티 주소 입력: 주소 023002304과 값 1,2,3,4,5를 입력하면 D2300부터 D2304까지 각각 0100, 0200, 0300, 0400, 0500이 기록됩니다.
이제 MVVM 패턴을 통해 주소와 값을 입력받고, PLC에 값을 쓰는 작업이 제대로 이루어집니다.