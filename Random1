수정된 전체 코드 (FileCheckerMES20.cs)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;
using System.Collections.Concurrent;
using System.Threading.Tasks;

namespace GumiChecker
{
    public class FileCheckerMES20
    {
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 위치한 디렉토리 경로
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$"; // 파일명 패턴 정의
        private DispatcherTimer _timer; // 주기적으로 파일을 체크하기 위한 타이머
        private string _currentMonitoredFile; // 현재 감시 중인 파일 경로
        private DateTime _lastPlanSelectedDate; // 마지막으로 PLAN Selected가 감지된 시간
        private DateTime _lastWriteTime; // 마지막으로 파일이 수정된 시간
        private ProductOrderModel _currentProductOrder; // 현재 처리 중인 주문 정보
        private ProductOrderModel _previousProductOrder; // 배출할 주문 정보 (이전 주문)
        private ObservableCollection<ProductOrderModel> _productOrders; // 주문 목록을 저장하는 컬렉션
        private long _lastPlanSelectedPosition; // 파일에서 마지막 PLAN Selected 위치
        private bool _isFirstExecution; // 프로그램의 첫 실행 여부를 나타내는 플래그
        private ComportManager _comPortPLC; // ComportManager 객체
        private DateTime _programStartTime; // 프로그램이 시작된 시간

        // 추가: FNL^ 이후의 처리 순서를 위한 플래그
        private bool _isFNLDetected; // FNL^이 감지되었는지 여부
        private bool _pendingAction; // FNL^ 이후 PLAN Selected나 JD^을 기다리는 플래그

        // 새로운 추가: 작업 큐 및 작업 상태를 실시간으로 리스트박스에 표시하기 위한 데이터
        private ConcurrentQueue<string> _taskQueue = new ConcurrentQueue<string>(); // 큐에 들어갈 작업 목록
        private ObservableCollection<string> _taskList; // 리스트박스에 표시할 큐 상태
        private bool _isProcessingTask = false; // 현재 작업이 진행 중인지 여부
        private int _R520SensorTimeout = 180000; // 3분 타임아웃 (3 * 60 * 1000ms)

        // 생성자: FileCheckerMES20 객체를 생성하고 초기화
        public FileCheckerMES20(ObservableCollection<ProductOrderModel> productOrders, ComportManager comPortManager, ObservableCollection<string> taskList)
        {
            _productOrders = productOrders; // 주문 목록 컬렉션을 받아 초기화
            _comPortPLC = comPortManager; // ComportManager 인스턴스를 초기화
            _taskList = taskList; // 작업 리스트 초기화
            _isFirstExecution = true; // 첫 실행 여부를 true로 설정
            _programStartTime = DateTime.Now; // 프로그램 시작 시간을 현재 시간으로 설정
            _isFNLDetected = false; // FNL^ 감지 여부 초기화
            _pendingAction = false; // PLAN Selected 또는 JD^ 대기 상태로 설정

            // 타이머를 1초마다 실행되도록 설정
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 타이머가 작동할 때마다 CheckFiles 실행
            _timer.Start(); // 타이머 시작

            // 로그 출력: 타이머가 시작되었음을 알림
            msgvs.Instance.LogT2("FileCheckerMES20: 타이머가 시작되었습니다.");

            // 현재 감시할 가장 최신 로그 파일을 설정
            _currentMonitoredFile = GetLatestLogFile();
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 시간을 MinValue로 설정

            // 로그 출력: 파일 감시 시작 알림
            msgvs.Instance.LogT2($"FileCheckerMES20: {_currentMonitoredFile} 파일 감시를 시작합니다.");
            _lastPlanSelectedDate = DateTime.Now; // 마지막 PLAN Selected 시간을 현재 시간으로 설정
            _lastPlanSelectedPosition = 0; // 파일의 위치를 0으로 초기화
        }

        // 적재 함수
        public async Task ExecuteStackFunctionAsync(ProductOrderModel order)
        {
            // 작업을 큐에 추가
            _taskQueue.Enqueue($"적재: {order.ProductOrder}");
            _taskList.Add($"적재 대기: {order.ProductOrder}");

            if (!_isProcessingTask)
            {
                await ProcessQueueAsync(); // 작업 처리 시작
            }
        }

        // 배출 함수
        public async Task ExecuteOutFunctionAsync(ProductOrderModel order)
        {
            // 작업을 큐에 추가
            _taskQueue.Enqueue($"배출: {order.ProductOrder}");
            _taskList.Add($"배출 대기: {order.ProductOrder}");

            if (!_isProcessingTask)
            {
                await ProcessQueueAsync(); // 작업 처리 시작
            }
        }

        // 큐에서 작업을 처리하는 함수
        private async Task ProcessQueueAsync()
        {
            _isProcessingTask = true;

            while (_taskQueue.TryDequeue(out string task))
            {
                _taskList.Remove(task); // 큐에서 작업을 제거하고 리스트에서 표시 제거
                string[] taskParts = task.Split(':');
                string taskType = taskParts[0].Trim();
                string productOrder = taskParts[1].Trim();

                if (taskType == "적재")
                {
                    msgvs.Instance.LogT2($"적재 작업 시작: {productOrder}");
                    await ProcessStackAsync(productOrder); // 적재 작업 처리
                }
                else if (taskType == "배출")
                {
                    msgvs.Instance.LogT2($"배출 작업 시작: {productOrder}");
                    await ProcessOutAsync(productOrder); // 배출 작업 처리
                }
            }

            _isProcessingTask = false;
        }

        // 적재 작업 처리
        private async Task ProcessStackAsync(string productOrder)
        {
            // 적재 신호를 뮤토콜로 PLC에 전송
            bool isCommandSent = SendStackCommandToPLC();

            if (isCommandSent)
            {
                msgvs.Instance.LogT2($"PLC 적재 신호 전송 완료: {productOrder}");

                // 뮤토콜 응답 대기 (WD13)
                bool isWD13Response = await WaitForWD13ResponseAsync();
                if (isWD13Response)
                {
                    msgvs.Instance.LogT2($"WD13 응답 완료: {productOrder}");

                    // R520/R521 센서 감지 대기
                    bool isSensorSuccess = await MonitorSensorsAsync();

                    if (isSensorSuccess)
                    {
                        msgvs.Instance.LogT2($"적재 완료: {productOrder}");
                    }
                    else
                    {
                        msgvs.Instance.LogT2($"적재 실패: {productOrder}");
                        // 에러 발생: 적재가 완료되지 않음
                        ShowError($"적재 실패: {productOrder} (3분 내 감지되지 않음)");
                    }
                }
                else
                {
                    msgvs.Instance.LogT2($"WD13 응답 실패: {productOrder}");
                    ShowError($"WD13 응답 실패: {productOrder}");
                }
            }
        }

        // 배출 작업 처리
        private async Task ProcessOutAsync(string productOrder)
        {
            // 뮤토콜을 사용해 PLC에 배출 신호 전송
            bool isCommandSent = SendOutCommandToPLC();

            if (isCommandSent)
            {
                msgvs.Instance.LogT2($"PLC 배출 신호 전송 완료: {productOrder}");
            }
        }

        // PLC에 적재 신호 전송 함수 (구현되어 있다고 가정)
        private bool SendStackCommandToPLC()
        {
            // PLC에 적재 신호를 전송하는 로직
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // WD13 응답을 기다리는 함수 (뮤토콜 응답 대기)
        private async Task<bool> WaitForWD13ResponseAsync()
        {
            // 뮤토콜로 WD13 응답 대기 로직 (비동기 처리)
            await Task.Delay(2000); // 2초 대기 (예시)
            return true; // WD13 응답 성공했다고 가정
        }

        // PLC에 배출 신호 전송 함수 (구현되어 있다고 가정)
        private bool SendOutCommandToPLC()
        {
            // PLC에 배출 신호를 전송하는 로직
            return true; // 신호가 정상적으로 전송되었다고 가정
        }

        // 센서 감시 함수 (3분 동안 R520, R521 감시)
        private async Task<bool> MonitorSensorsAsync()
        {
            var startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalMilliseconds < _R520SensorTimeout)
            {
                // PLC에서 센서 상태를 읽어옴 (R520 감지 -> 꺼짐 -> R521 감지 순서)
                bool isR520Detected = ReadSensor("R520");
                bool isR521Detected = ReadSensor("R521");

                if (isR520Detected)
                {
                    msgvs.Instance.LogT2("R520 감지됨");
                    // R520이 감지되고 꺼졌는지 확인
                    while (!ReadSensor("R520"))
                    {
                        await Task.Delay(100); // 0.1초 대기
                    }

                    msgvs.Instance.LogT2("R520 꺼짐 확인");

                    // R521 감지 확인
                    if (isR521Detected)
                    {
                        msgvs.Instance.LogT2("R521 감지됨");
                        return true; // 적재 완료
                    }
                }

                await Task.Delay(100); // 0.1초 대기
            }

            return false; // 3분 내에 적재 완료되지 않음
        }

        // 센서 값을 읽는 함수 (구현되어 있다고 가정)
        private bool ReadSensor(string sensorId)
        {
            // PLC에서 센서 값을 읽어오는 로직
            return false; // 센서 감지 여부를 반환 (가정)
        }

        // 에러 창을 표시하는 함수
        private void ShowError(string message)
        {
            // 에러 메시지 창을 띄움
            msgvs.Instance.LogT2(message);
        }

        // 로그 파일 디렉토리에서 가장 최신 로그 파일을 반환 (이전 코드 그대로 유지)
        private string GetLatestLogFile()
        {
            // 로그 출력: 최신 로그 파일 검색 중
            msgvs.Instance.LogT2("FileCheckerMES20: 최신 로그 파일 검색 중...");

            // 디렉토리 내의 로그 파일 목록을 필터링하고 최신 파일을 선택
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 파일 패턴과 일치하는 파일만 선택
                .OrderByDescending(f => f.LastWriteTime) // 최근 수정된 파일을 기준으로 정렬
                .ToList();

            return logFiles.FirstOrDefault()?.FullName; // 가장 최신 파일 경로 반환
        }

        // ... 기존 나머지 코드 유지
    }

    // 제품 주문 정보를 저장하는 모델 클래스 (INotifyPropertyChanged 구현, 기존 코드 유지)
    public class ProductOrderModel : INotifyPropertyChanged
    {
        private string _productOrder;
        private string _basicModel;
        private int _poRemain;
        private int _mgCount;
        private int _pCount;
        private string _poStatus;
        private string _pDate;

        public string ProductOrder
        {
            get => _productOrder;
            set
            {
                _productOrder = value;
                OnPropertyChanged(nameof(ProductOrder));
            }
        }

        public string BasicModel
        {
            get => _basicModel;
            set
            {
                _basicModel = value;
                OnPropertyChanged(nameof(BasicModel));
            }
        }

        public int PORemain
        {
            get => _poRemain;
            set
            {
                _poRemain = value;
                OnPropertyChanged(nameof(PORemain));
            }
        }

        public int MGCount
        {
            get => _mgCount;
            set
            {
                _mgCount = value;
                OnPropertyChanged(nameof(MGCount));
            }
        }

        public int PCount
        {
            get => _pCount;
            set
            {
                _pCount = value;
                OnPropertyChanged(nameof(PCount));
            }
        }

        public string POStatus
        {
            get => _poStatus;
            set
            {
                _poStatus = value;
                OnPropertyChanged(nameof(POStatus));
            }
        }

        public string PDate
        {
            get => _pDate;
            set
            {
                _pDate = value;
                OnPropertyChanged(nameof(PDate));
            }
        }

        public event PropertyChangedEventHandler PropertyChanged;

        // 프로퍼티가 변경될 때마다 UI에 알림을 보냄
        protected void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
주요 변경 사항 요약:
적재와 배출 작업 처리:

적재 작업은 뮤토콜로 PLC에 명령을 보내고, WD13 응답을 기다린 후, R520/R521 센서를 감시하여 적재 완료 여부를 확인합니다.
3분 내에 완료되지 않으면 에러 창이 발생합니다.
작업 큐 및 리스트 박스 표시:

적재 및 배출 작업이 큐에 추가되며, 리스트 박스에 실시간으로 작업 상태가 표시됩니다.
기존 코드를 유지하면서 새로운 기능을 추가했습니다.