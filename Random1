네, 알겠습니다. SAgentM.App (WPF 에이전트)을 실행하면 바로 메인 창이 뜨는 대신, 시스템 트레이(알림 영역)로 최소화되어 시작하고, 트레이 아이콘을 통해 제어할 수 있도록 수정하겠습니다.

이 기능을 구현하려면 다음 파일들을 수정해야 합니다:

SAgentM.App.csproj (수정): System.Windows.Forms 어셈블리 참조를 추가합니다. (NotifyIcon 사용을 위해)
아이콘 파일 (신규 필요): 트레이에 표시될 .ico 아이콘 파일이 필요합니다. (예: agent_icon.ico)
App.xaml (수정): StartupUri를 제거하여 MainWindow가 자동으로 시작되지 않도록 합니다.
App.xaml.cs (수정): 애플리케이션 시작 시 NotifyIcon을 생성하고, MainWindow는 숨겨진 상태로 로드하며, AgentCoreService를 시작합니다. 트레이 아이콘의 메뉴 및 이벤트 처리 로직을 포함합니다.
MainWindow.xaml.cs (수정): 창을 닫을 때 실제 종료 대신 숨겨지도록 하고, 트레이 메뉴를 통해 보이거나 완전히 종료될 수 있도록 수정합니다.
ViewModels/MainViewModel.cs (수정 - 필요시): 에이전트 서비스 시작/중지 로직 호출 부분을 조정할 수 있습니다. (여기서는 App.xaml.cs에서 직접 서비스 시작/중지를 관리하는 것으로 변경합니다.)
1. SAgentM.App.csproj 파일 수정
이 파일은 직접 텍스트 편집기로 열거나, Visual Studio의 솔루션 탐색기에서 SAgentM.App 프로젝트의 "참조"를 마우스 우클릭하여 System.Windows.Forms 어셈블리 참조를 추가합니다.

.csproj 파일에 직접 추가하는 예시:

XML

  <ItemGroup>
    <Reference Include="System.Windows.Forms" />
    </ItemGroup>
2. 아이콘 파일 준비
agent_icon.ico 라는 이름의 아이콘 파일을 준비하여 SAgentM.App 프로젝트 루트에 추가합니다.
추가한 아이콘 파일의 속성에서 "빌드 작업(Build Action)"을 "Resource" 로 설정하고, "출력 디렉터리로 복사(Copy to Output Directory)"는 "복사 안 함(Do not copy)" 또는 **"변경된 내용만 복사(Copy if newer)"**로 설정합니다. (Resource로 포함하면 실행 파일 내에 포함됩니다.)
3. 수정: App.xaml (전체 파일)
StartupUri="MainWindow.xaml" 속성을 제거합니다.

XML

<Application x:Class="SAgentM.App.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:SAgentM.App">
    <Application.Resources>
         
    </Application.Resources>
</Application>
4. 수정: App.xaml.cs (전체 파일)
애플리케이션 시작/종료 로직, NotifyIcon 생성 및 관리를 담당합니다.

C#

// SAgentM.App/App.xaml.cs
using SAgentM.App.Services;
using SAgentM.App.ViewModels; // MainViewModel은 MainWindow에서 사용
using System;
using System.Configuration;
using System.IO;
using System.Windows;
using System.Windows.Forms; // NotifyIcon, ContextMenuStrip 등 사용
using Serilog; // 파일 로깅을 위해 Serilog 사용 (이전 설정 유지)

namespace SAgentM.App
{
    public partial class App : Application
    {
        private NotifyIcon _notifyIcon;
        private MainWindow _mainWindow; // MainWindow 인스턴스 유지

        // 서비스 인스턴스
        private ILoggingService _loggingService;
        private IAgentCoreService _agentCoreService;
        private MainViewModel _mainViewModel; // MainWindow의 ViewModel

        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);

            // Serilog 전역 파일 로거 설정 (이전과 동일)
            var logFilePath = ConfigurationManager.AppSettings["LogFilePath"] ?? "Logs_SAgentM\\SAgentM_App_.log";
            var baseDir = AppDomain.CurrentDomain.BaseDirectory;
            var fullLogPath = Path.Combine(baseDir, logFilePath);
            if (!Directory.Exists(Path.GetDirectoryName(fullLogPath)))
            {
                Directory.CreateDirectory(Path.GetDirectoryName(fullLogPath));
            }
            Log.Logger = new LoggerConfiguration()
                .MinimumLevel.Debug()
                .MinimumLevel.Override("Microsoft", Serilog.Events.LogEventLevel.Warning)
                .Enrich.FromLogContext()
                .Enrich.WithThreadId().Enrich.WithProcessId()
                .WriteTo.File(fullLogPath, rollingInterval: RollingInterval.Day, retainedFileCountLimit: 7, shared: true, flushToDiskInterval: TimeSpan.FromSeconds(5))
                .CreateLogger();
            Log.Information("SAgentM.App Application_Startup: Logging initialized. Path: {LogPath}", fullLogPath);


            // 서비스 및 ViewModel 초기화
            _loggingService = new LoggingService(); // LoggingService는 UI 로그와 파일 로그 모두 처리
            _agentCoreService = new AgentCoreService(_loggingService);
            _mainViewModel = new MainViewModel(_loggingService, _agentCoreService); // ViewModel 생성

            // MainWindow 인스턴스 생성 및 ViewModel 연결
            // StartupUri가 없으므로 여기서 MainWindow를 생성해야 함
            _mainWindow = new MainWindow();
            _mainWindow.DataContext = _mainViewModel; // ViewModel 설정

            // NotifyIcon 설정
            _notifyIcon = new NotifyIcon();
            try
            {
                // 아이콘 리소스 경로 주의: 
                // 1. 아이콘 파일이 프로젝트 루트에 있고 'Resource'로 설정된 경우:
                //    "pack://application:,,,/AssemblyName;component/agent_icon.ico"
                // 2. 아이콘 파일이 실행 파일과 같은 폴더에 '내용(Content)' 및 '항상 복사'로 설정된 경우:
                //    "agent_icon.ico" (상대 경로) 또는 Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "agent_icon.ico")
                // 여기서는 Resource로 가정합니다. AssemblyName을 실제 어셈블리 이름으로 변경해야 합니다.
                // 예: "pack://application:,,,/SAgentM.App;component/agent_icon.ico"
                // 더 간단하게는 실행 폴더에 아이콘을 두고 직접 경로 지정
                string iconPath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, "agent_icon.ico");
                if (File.Exists(iconPath)) {
                    _notifyIcon.Icon = new System.Drawing.Icon(iconPath);
                } else {
                     _notifyIcon.Icon = System.Drawing.SystemIcons.Application; // 임시 아이콘
                    _loggingService.UiWarn("agent_icon.ico 파일을 찾을 수 없어 기본 아이콘을 사용합니다.");
                }
            }
            catch (Exception ex)
            {
                _notifyIcon.Icon = System.Drawing.SystemIcons.Error; // 오류 시 아이콘
                _loggingService.UiError("트레이 아이콘 로드 실패.", ex);
            }
            
            _notifyIcon.Text = "SAgentM - 에이전트 실행 중";
            _notifyIcon.Visible = true;

            // NotifyIcon 컨텍스트 메뉴 설정
            var contextMenu = new ContextMenuStrip();
            var showMenuItem = new ToolStripMenuItem("상태 보기/숨기기");
            showMenuItem.Click += ShowMainWindow_Click;
            contextMenu.Items.Add(showMenuItem);

            var exitMenuItem = new ToolStripMenuItem("종료");
            exitMenuItem.Click += ExitApplication_Click;
            contextMenu.Items.Add(exitMenuItem);

            _notifyIcon.ContextMenuStrip = contextMenu;

            // NotifyIcon 더블 클릭 시 창 보이기/숨기기
            _notifyIcon.DoubleClick += ShowMainWindow_Click;

            // MainWindow를 처음에는 숨김 (Show() 호출 안 함 또는 Hide())
            // _mainWindow.Hide(); // 생성 후 바로 숨기거나, ShowInTaskbar=false, WindowState=Minimized 후 Show()
            // 또는 MainWindow 자체의 Loaded 이벤트에서 숨김 처리 가능
            // 여기서는 MainWindow의 Loaded에서 숨기도록 하고, AgentCoreService는 여기서 시작
            
            // AgentCoreService 시작 (ViewModel의 LoadedCommand 대신 여기서 직접 호출)
            if (!_agentCoreService.IsRunning)
            {
                _loggingService.UiInfo("App.xaml.cs: AgentCoreService 시작 시도...");
                try
                {
                    _agentCoreService.Start(); // 동기적으로 시작될 수 있으므로 주의
                                               // MainViewModel의 ExecuteStartAgentAsync처럼 Task.Run으로 감쌀 수 있음
                    _mainViewModel.IsAgentServiceRunning = true; // 상태 강제 업데이트
                    _mainViewModel.AgentStatus = $"에이전트 실행 중 (포트: {ConfigurationManager.AppSettings["ListenPort"]})";
                }
                catch (Exception ex)
                {
                     _loggingService.UiError("App.xaml.cs: AgentCoreService 시작 중 오류.", ex);
                     _mainViewModel.AgentStatus = "에이전트 시작 오류";
                }
            }
        }

        private void ShowMainWindow_Click(object sender, EventArgs e)
        {
            if (_mainWindow == null) return;

            if (_mainWindow.IsVisible)
            {
                _mainWindow.Hide();
                _loggingService.UiDebug("MainWindow 숨김.");
            }
            else
            {
                _mainWindow.Show();
                _mainWindow.WindowState = WindowState.Normal;
                _mainWindow.Activate();
                _loggingService.UiDebug("MainWindow 표시.");
            }
        }

        private void ExitApplication_Click(object sender, EventArgs e)
        {
            _loggingService.UiInfo("애플리케이션 종료 요청 (트레이 메뉴).");
            // ViewModel 및 서비스 정리 작업 호출
            _mainViewModel?.CleanupAsync().ContinueWith(t => { /* 로깅 또는 추가 작업 */ }); // 비동기 호출 후 처리
            _agentCoreService?.Stop(); // 확실히 중지

            _notifyIcon?.Dispose(); // 트레이 아이콘 정리
            Current.Shutdown();     // 애플리케이션 완전히 종료
        }

        protected override void OnExit(ExitEventArgs e)
        {
            _loggingService?.UiInfo("SAgentM.App Application_Exit: 트레이 아이콘 정리 및 로거 닫기.");
            _notifyIcon?.Dispose(); // 만약을 위해 한번 더
            Log.CloseAndFlush();    // Serilog 파일 로거 닫기
            base.OnExit(e);
        }
    }
}
5. 수정: MainWindow.xaml.cs (창 동작 변경)
MainWindow가 로드될 때 자신을 숨기고, 닫기 버튼을 눌렀을 때 실제 종료 대신 트레이로 숨겨지도록 수정합니다.

C#

// SAgentM.App/MainWindow.xaml.cs
using SAgentM.App.ViewModels;
using System;
using System.ComponentModel;
using System.Windows;

namespace SAgentM.App
{
    public partial class MainWindow : Window
    {
        // ViewModel은 App.xaml.cs에서 생성되어 DataContext로 주입됨
        private MainViewModel _viewModel => DataContext as MainViewModel;

        public MainWindow()
        {
            InitializeComponent();
            // 디자인 타임에는 DataContext가 null일 수 있음
            // if (System.ComponentModel.DesignerProperties.GetIsInDesignMode(this))
            // {
            //     DataContext = new MainViewModel(); // 디자인 타임용 ViewModel (매개변수 없는 생성자 필요)
            // }
        }

        private void Window_Loaded(object sender, RoutedEventArgs e)
        {
            // 창이 로드된 후 바로 숨깁니다.
            // App.xaml.cs에서 AgentCoreService는 이미 시작되었을 것입니다.
            // ViewModel의 LoadedCommand는 여기서 호출하지 않습니다 (App.xaml.cs에서 서비스 시작 관리)
            Hide();
            if (_viewModel != null)
            {
                 _viewModel.UiLogEntries.CollectionChanged += UiLogEntries_CollectionChanged;
            }
        }
        
        // 로그 목록이 변경될 때 자동으로 스크롤 (선택적 UI 개선)
        private void UiLogEntries_CollectionChanged(object sender, System.Collections.Specialized.NotifyCollectionChangedEventArgs e)
        {
            // ListView 이름이 "LogListView"라고 가정 (XAML에서 ListView에 x:Name="LogListView" 추가 필요)
            // if (LogListView.Items.Count > 0)
            // {
            //    var lastItem = LogListView.Items[LogListView.Items.Count - 1];
            //    LogListView.ScrollIntoView(lastItem);
            // }
        }


        protected override void OnClosing(CancelEventArgs e)
        {
            // 창의 닫기 버튼(X)을 눌렀을 때 애플리케이션을 종료하는 대신 창을 숨김
            e.Cancel = true; // 실제 종료 방지
            Hide();          // 창 숨기기
            _viewModel?.UiInfo("MainWindow 창 숨김 (트레이 아이콘으로 최소화).");
            base.OnClosing(e);
        }

        // 이 메서드는 App.xaml.cs의 ExitApplication_Click에서 호출될 수 있습니다.
        // 또는 ViewModel의 CleanupAsync가 AgentCoreService.Stop()을 이미 호출합니다.
        public async Task PerformCleanupAndShutdown()
        {
            if (_viewModel != null)
            {
                await _viewModel.CleanupAsync();
            }
             // _notifyIcon?.Dispose(); App.xaml.cs에서 처리
            Application.Current.Shutdown();
        }
    }
}
MainWindow.xaml 에 ListView 이름 추가 (선택 사항 - 자동 스크롤용):
로그 자동 스크롤 기능을 사용하려면 MainWindow.xaml의 ListView에 x:Name을 추가합니다.

XML

<ListView Grid.Row="1" ItemsSource="{Binding UiLogEntries}" x:Name="LogListView" ... >
    </ListView>
6. ViewModels/MainViewModel.cs (약간의 조정)
App.xaml.cs에서 AgentCoreService의 시작을 담당하므로, MainViewModel의 LoadedCommand는 이제 필수가 아니거나 다른 용도로 사용될 수 있습니다. CleanupAsync는 여전히 유효합니다. IsAgentServiceRunning과 AgentStatus는 App.xaml.cs에서 서비스 시작/중지 시 직접 업데이트하거나, AgentCoreService의 상태를 주기적으로 반영하도록 할 수 있습니다.

여기서는 MainViewModel에서 AgentCoreService를 직접 시작/중지하는 명령은 유지하되, 초기 자동 시작은 App.xaml.cs에서 담당하는 것으로 간주합니다.

C#

// SAgentM.App/ViewModels/MainViewModel.cs
// ... (using문은 이전과 동일) ...
namespace SAgentM.App.ViewModels
{
    public class MainViewModel : ObservableObject
    {
        private readonly ILoggingService _loggingService;
        private readonly IAgentCoreService _agentCoreService;

        private string _agentStatus = "에이전트 중지됨";
        public string AgentStatus { get => _agentStatus; private set => SetProperty(ref _agentStatus, value); }

        private bool _isAgentServiceRunning;
        public bool IsAgentServiceRunning { get => _isAgentServiceRunning; 
            set { if (SetProperty(ref _isAgentServiceRunning, value)) { UpdateCommandStates(); } } 
        }

        private string _listenPortInfo;
        public string ListenPortInfo { get => _listenPortInfo; private set => SetProperty(ref _listenPortInfo, value); }

        public ObservableCollection<LogEntry> UiLogEntries { get; }

        public ICommand StartAgentCommand { get; }
        public ICommand StopAgentCommand { get; }
        // public ICommand LoadedCommand { get; } // App.xaml.cs에서 시작하므로 제거 또는 다른 용도

        public MainViewModel() { /* 디자인 타임용 생성자 (이전과 동일) */ 
            if (System.ComponentModel.DesignerProperties.GetIsInDesignMode(new System.Windows.DependencyObject()))
            {
                UiLogEntries = new ObservableCollection<LogEntry> { /* ... */ }; AgentStatus = "디자인 타임 모드"; ListenPortInfo = "포트: 12345 (디자인)";
                StartAgentCommand = new AsyncRelayCommand(async () => await Task.CompletedTask, () => false); StopAgentCommand = new AsyncRelayCommand(async () => await Task.CompletedTask, () => false);
            } else { throw new InvalidOperationException("런타임에는 매개변수 있는 생성자 사용 필요."); }
        }

        public MainViewModel(ILoggingService loggingService, IAgentCoreService agentCoreService)
        {
            _loggingService = loggingService ?? throw new ArgumentNullException(nameof(loggingService));
            _agentCoreService = agentCoreService ?? throw new ArgumentNullException(nameof(agentCoreService));
            UiLogEntries = _loggingService.UiLogEntries;

            if (int.TryParse(ConfigurationManager.AppSettings["ListenPort"], out int port)) { ListenPortInfo = $"수신 대기 포트: {port}"; }
            else { ListenPortInfo = "수신 대기 포트: 설정 오류 (기본 4026)"; }

            StartAgentCommand = new AsyncRelayCommand(ExecuteStartAgentAsync, CanExecuteStartAgent);
            StopAgentCommand = new AsyncRelayCommand(ExecuteStopAgentAsync, CanExecuteStopAgent);
            // LoadedCommand는 App.xaml.cs에서 처리하므로 여기서 꼭 필요하지 않음.
            // 필요하다면 ViewModel 초기화 로직을 여기에 둘 수 있음.
            // LoadedCommand = new AsyncRelayCommand(async () => { _loggingService.UiInfo("ViewModel LoadedCommand 실행됨 (App에서 서비스 시작)."); UpdateAgentStatus(); await Task.CompletedTask; });


            UpdateAgentStatus(); // 초기 상태 설정
            _loggingService.UiInfo("MainViewModel 초기화 완료.");
        }

        private void UpdateCommandStates()
        {
            (StartAgentCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
            (StopAgentCommand as AsyncRelayCommand)?.RaiseCanExecuteChanged();
        }

        private bool CanExecuteStartAgent() => !_agentCoreService.IsRunning;
        private async Task ExecuteStartAgentAsync()
        {
            _loggingService.UiInfo("UI에서 에이전트 서비스 시작 명령 수신...");
            AgentStatus = "에이전트 시작 중...";
            try { await Task.Run(() => _agentCoreService.Start()); }
            catch (Exception ex) { _loggingService.UiError("UI 에이전트 시작 중 오류.", ex); }
            finally { UpdateAgentStatus(); }
        }

        private bool CanExecuteStopAgent() => _agentCoreService.IsRunning;
        private async Task ExecuteStopAgentAsync()
        {
            _loggingService.UiInfo("UI에서 에이전트 서비스 중지 명령 수신...");
            AgentStatus = "에이전트 중지 중...";
            try { await Task.Run(() => _agentCoreService.Stop()); }
            catch (Exception ex) { _loggingService.UiError("UI 에이전트 중지 중 오류.", ex); }
            finally { UpdateAgentStatus(); }
        }

        // AgentCoreService의 실제 상태를 주기적으로 확인하거나, 
        // App.xaml.cs에서 상태 변경 시 이 메서드를 호출하도록 할 수 있음.
        public void UpdateAgentStatus() 
        {
            IsAgentServiceRunning = _agentCoreService.IsRunning;
            if (IsAgentServiceRunning) { AgentStatus = $"에이전트 실행 중 (포트: {ConfigurationManager.AppSettings["ListenPort"]})"; }
            else { AgentStatus = "에이전트 중지됨"; }
             _loggingService.UiDebug($"ViewModel 상태 업데이트: {AgentStatus}"); // 디버그 레벨로 변경
        }

        public async Task CleanupAsync()
        {
            _loggingService.UiInfo("ViewModel 정리 시작. 에이전트 중지 시도.");
            if (CanExecuteStopAgent()) { await ExecuteStopAgentAsync(); }
            _loggingService.UiInfo("ViewModel 정리 완료.");
        }
    }
}
주요 변경 사항 요약:

App.xaml.cs:
OnStartup에서 NotifyIcon (트레이 아이콘)을 생성하고 컨텍스트 메뉴(상태 보기/숨기기, 종료)를 설정합니다.
MainWindow 인스턴스를 생성하지만 바로 Show() 하지 않습니다 (또는 MainWindow 자체 Loaded 이벤트에서 Hide() 하도록 유도).
AgentCoreService를 직접 시작합니다. MainViewModel의 LoadedCommand는 이제 주된 시작점이 아닙니다.
트레이 아이콘 더블 클릭 또는 메뉴 "상태 보기/숨기기" 클릭 시 MainWindow를 보이거나 숨깁니다.
트레이 메뉴 "종료" 클릭 시 CleanupAsync 및 Shutdown()을 호출하여 애플리케이션을 완전히 종료합니다.
OnExit에서 NotifyIcon을 확실히 정리합니다.
MainWindow.xaml.cs:
Window_Loaded 이벤트에서 창을 바로 숨깁니다 (Hide()).
OnClosing 이벤트(창의 X 버튼 클릭)를 가로채서 실제 종료 대신 창을 숨기도록 합니다.
실제 애플리케이션 종료는 App.xaml.cs의 트레이 메뉴를 통해 이루어집니다.
MainViewModel.cs:
LoadedCommand의 역할이 축소되거나 제거될 수 있습니다 (서비스 시작은 App.xaml.cs에서).
IsAgentServiceRunning과 AgentStatus는 App.xaml.cs에서 서비스 상태 변경 시 MainViewModel의 UpdateAgentStatus()를 호출해주거나, AgentCoreService에 상태 변경 이벤트를 만들어 ViewModel이 구독하는 방식으로 더 동적으로 업데이트할 수 있습니다. (현재는 시작/중지 명령 후 업데이트)
실행 방법:

agent_icon.ico 파일을 프로젝트에 추가하고 속성을 설정합니다.
위 코드들을 각 파일에 적용하고 프로젝트를 빌드합니다.
SAgentM.App.exe를 실행하면 (관리자 권한으로) 메인 창이 바로 뜨지 않고 시스템 트레이에 아이콘이 나타나야 합니다.
트레이 아이콘을 더블 클릭하거나 마우스 우클릭 후 "상태 보기"를 선택하면 MainWindow가 나타납니다.
창의 X 버튼을 누르면 창이 숨겨지고 트레이 아이콘만 남습니다.
트레이 아이콘 메뉴에서 "종료"를 선택하면 애플리케이션이 완전히 종료됩니다.
이 수정으로 SAgentM.App은 트레이 아이콘 기반으로 동작하게 됩니다. 테스트 해보시고 잘 동작하는지 알려주세요!

