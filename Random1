고, 지정된 RGB 색상(146, 202, 173)을 가진 영역을 찾아 클릭하는 코드를 제공하겠습니다. 흰색 격자로 칸이 나눠져 있음을 고려하여 작성하겠습니다.

전체 코드
csharp
코드 복사
using System;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Windows.Forms;
using AForge.Imaging;
using AForge.Imaging.Filters;

namespace CalendarClicker
{
    public partial class Form1 : Form
    {
        [DllImport("user32.dll")]
        static extern bool SetCursorPos(int X, int Y);

        [DllImport("user32.dll")]
        static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, int dwExtraInfo);

        const uint MOUSEEVENTF_LEFTDOWN = 0x02;
        const uint MOUSEEVENTF_LEFTUP = 0x04;

        private Button clickButton;
        private PictureBox pictureBox;

        public Form1()
        {
            InitializeComponent();

            // 버튼 추가
            clickButton = new Button();
            clickButton.Text = "Detect and Highlight Areas";
            clickButton.Location = new Point(10, 10);
            clickButton.Click += new EventHandler(OnButtonClick);
            this.Controls.Add(clickButton);

            // PictureBox 추가
            pictureBox = new PictureBox();
            pictureBox.Location = new Point(10, 50);
            pictureBox.Size = new Size(800, 600);
            this.Controls.Add(pictureBox);
        }

        private void OnButtonClick(object sender, EventArgs e)
        {
            // 스크린샷 캡처
            Bitmap screenshot = CaptureScreen(200, 200, 400, 400);

            // 필터 적용 (특정 색상 필터링)
            EuclideanColorFiltering filter = new EuclideanColorFiltering();
            filter.CenterColor = new RGB(Color.FromArgb(146, 202, 173)); // 지정된 색상 중심
            filter.Radius = 30; // 색상 반경
            filter.ApplyInPlace(screenshot);

            // 윤곽선 찾기
            BlobCounter blobCounter = new BlobCounter();
            blobCounter.FilterBlobs = true;
            blobCounter.MinHeight = 15;
            blobCounter.MinWidth = 15;
            blobCounter.ProcessImage(screenshot);
            Blob[] blobs = blobCounter.GetObjectsInformation();

            using (Graphics g = Graphics.FromImage(screenshot))
            {
                foreach (Blob blob in blobs)
                {
                    // 흰색 격자를 무시하고 윤곽선을 찾음
                    if (IsInsideGrid(blob.Rectangle))
                    {
                        // 클릭 위치 계산
                        int centerX = 200 + blob.Rectangle.X + blob.Rectangle.Width / 2;
                        int centerY = 200 + blob.Rectangle.Y + blob.Rectangle.Height / 2;

                        // 클릭 위치에 빨간 원 그리기
                        g.DrawEllipse(Pens.Red, blob.Rectangle.X, blob.Rectangle.Y, blob.Rectangle.Width, blob.Rectangle.Height);

                        // 클릭 이벤트 시뮬레이션 (주석 처리 해제 시 실제 클릭)
                        // SetCursorPos(centerX, centerY);
                        // mouse_event(MOUSEEVENTF_LEFTDOWN, centerX, centerY, 0, 0);
                        // mouse_event(MOUSEEVENTF_LEFTUP, centerX, centerY, 0, 0);
                    }
                }
            }

            // PictureBox에 이미지 표시
            pictureBox.Image = screenshot;
        }

        private bool IsInsideGrid(Rectangle rect)
        {
            // 흰색 격자선을 기준으로 윤곽선이 겹치는지 확인
            // 격자선 두께와 간격을 설정
            int gridThickness = 2; // 격자선 두께
            int gridSpacing = 50; // 격자 간격

            // 윤곽선이 격자선을 포함하지 않으면 true 반환
            return (rect.X % gridSpacing > gridThickness && rect.Y % gridSpacing > gridThickness &&
                    (rect.X + rect.Width) % gridSpacing > gridThickness && (rect.Y + rect.Height) % gridSpacing > gridThickness);
        }

        private Bitmap CaptureScreen(int x, int y, int width, int height)
        {
            Rectangle bounds = new Rectangle(x, y, width, height);
            Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);

            using (Graphics g = Graphics.FromImage(bitmap))
            {
                g.CopyFromScreen(new Point(x, y), Point.Empty, bounds.Size);
            }

            return bitmap;
        }
    }
}
주요 기능
버튼 추가: 버튼을 추가하여 클릭 시 지정된 색상을 감지하고 빨간 원으로 표시합니다.
PictureBox 추가: PictureBox를 추가하여 처리된 이미지를 표시합니다.
특정 영역 캡처: CaptureScreen 메서드를 사용하여 화면의 특정 영역을 캡처하고 Bitmap으로 반환합니다.
특정 색상 필터 적용: EuclideanColorFiltering을 사용하여 지정된 RGB 색상을 필터링합니다.
윤곽선 찾기: BlobCounter를 사용하여 윤곽선을 찾고, 각 윤곽선의 중심에 빨간 원을 그립니다.
흰색 격자 무시: IsInsideGrid 메서드를 사용하여 흰색 격자선을 무시하고 윤곽선이 겹치지 않는지 확인합니다.
이미지 표시: PictureBox에 처리된 이미지를 표시합니다.
이 코드를 실행하면 버튼 클릭 시 특정 영역에서 지정된 색상을 감지하여 빨간 원으로 표시하고, 처리된 이미지를 PictureBox에 표시