제가 여전히 발생하고 있는 것 같아 죄송합니다. CameraX 및 Camera2Interop과 관련된 문제를 해결하기 위해 더 정확한 접근 방식을 설명드리겠습니다.

문제 해결을 위한 정확한 접근 방식
hasCamera는 잘못된 접근:

CameraInfo 객체에 hasCamera 메서드는 없습니다. 카메라를 선택할 때 CameraSelector를 사용하여 카메라를 선택해야 합니다.
sensorInfo 접근 문제:

sensorInfo는 CameraX API에서 제공되지 않으며, 대신 Camera2 API를 직접 사용해야 합니다.
수정된 코드 (올바른 접근 방법)
아래는 CameraX와 Camera2Interop을 사용하여 카메라를 설정하고, CaptureRequest 옵션을 적용하는 방법입니다.

kotlin
코드 복사
package com.example.myapp

import android.Manifest
import android.content.pm.PackageManager
import android.graphics.Rect
import android.hardware.camera2.CameraCharacteristics
import android.hardware.camera2.CaptureRequest
import android.hardware.camera2.params.MeteringRectangle
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.camera.camera2.interop.Camera2CameraInfo
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.core.Camera
import androidx.camera.core.CameraSelector
import androidx.camera.core.Preview
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors

class MainActivity : ComponentActivity() {

    private lateinit var previewView: PreviewView
    private lateinit var cameraExecutor: ExecutorService
    private var camera: Camera? = null // Camera 객체 선언

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        previewView = findViewById(R.id.previewView)
        cameraExecutor = Executors.newSingleThreadExecutor()

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }
    }

    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)
        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            // 프리뷰 빌더 초기화 및 Camera2Interop 설정
            val previewBuilder = Preview.Builder()
            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            // Camera2Interop을 사용해 Camera2 API와 통합
            val camera2Interop = Camera2Interop.Extender(previewBuilder)

            val cameraInfo = cameraProvider.availableCameraInfos.firstOrNull {
                Camera2CameraInfo.from(it).getCameraCharacteristic(CameraCharacteristics.LENS_FACING) ==
                        CameraCharacteristics.LENS_FACING_BACK
            }

            cameraInfo?.let { info ->
                val characteristics = Camera2CameraInfo.from(info).cameraCharacteristics
                val sensorArraySize = characteristics.get(CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE)

                if (sensorArraySize != null) {
                    val focusArea = Rect(
                        (sensorArraySize.width() * 0.4).toInt(),
                        (sensorArraySize.height() * 0.4).toInt(),
                        (sensorArraySize.width() * 0.6).toInt(),
                        (sensorArraySize.height() * 0.6).toInt()
                    )

                    val meteringRectangle = MeteringRectangle(focusArea, MeteringRectangle.METERING_WEIGHT_MAX)

                    camera2Interop.setCaptureRequestOption(
                        CaptureRequest.CONTROL_AF_MODE,
                        CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
                    )

                    camera2Interop.setCaptureRequestOption(
                        CaptureRequest.CONTROL_AF_REGIONS,
                        arrayOf(meteringRectangle)
                    )

                    camera2Interop.setCaptureRequestOption(
                        CaptureRequest.CONTROL_AE_REGIONS,
                        arrayOf(meteringRectangle)
                    )
                }
            }

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(previewView.surfaceProvider)
            }

            try {
                cameraProvider.unbindAll()
                camera = cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview
                ) // Camera 객체 초기화

                // 카메라 제어를 위한 cameraControl 사용
                val cameraControl = camera?.cameraControl

                // 예: 줌 설정 (1.0f ~ 최대 줌 비율)
                cameraControl?.setZoomRatio(2.0f)

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }
        }, ContextCompat.getMainExecutor(this))
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onRequestPermissionsResult(
        requestCode: Int, permissions: Array<String>, grantResults: IntArray
    ) {
        super.onRequestPermissionsResult(requestCode, permissions, grantResults)
        if (requestCode == REQUEST_CODE_PERMISSIONS) {
            if (allPermissionsGranted()) {
                startCamera()
            } else {
                // 권한이 거부된 경우 처리
            }
        }
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(
            Manifest.permission.CAMERA
        )
    }
}
핵심 수정 사항:
올바른 카메라 정보 접근:

Camera2CameraInfo.from(cameraInfo).getCameraCharacteristic(CameraCharacteristics.LENS_FACING)을 사용하여 카메라 특성을 확인하고, 원하는 카메라를 선택합니다.
sensorInfo 대체:

sensorInfo는 CameraX에서 직접 접근할 수 없습니다. 대신 CameraCharacteristics.SENSOR_INFO_ACTIVE_ARRAY_SIZE를 사용하여 센서의 활성 영역 크기를 가져옵니다.
포커스 영역 설정:

센서의 활성 배열 크기를 기반으로 초점 영역을 설정합니다.
결론:
이 코드를 통해 CameraX와 Camera2 API를 올바르게 사용하여 카메라 설정을 구성할 수 있습니다. 문제가 해결되지 않거나 추가적인 질문이 있다면 언제든지 말씀해 주세