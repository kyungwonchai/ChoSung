. 수정: app/db_utils.py (요청별 pymssql 연결 관리)
이 파일은 pymssql 연결을 생성하고, Flask의 요청(request) 컨텍스트(g 객체)를 사용하여 요청당 하나의 연결을 유지하며, 요청이 끝나면 자동으로 연결을 닫는 기능을 제공합니다.

Python

# scontrol_flask_web/app/db_utils.py
import pymssql
from flask import current_app, g # g는 요청 컨텍스트별 DB 연결 관리에 사용

def get_db():
    """
    현재 요청 컨텍스트(g)에 DB 연결이 없으면 새로 생성하여 저장하고 반환합니다.
    이미 연결이 있다면 기존 연결을 반환합니다.
    config.py에 정의된 설정을 사용합니다.
    """
    if 'db_conn' not in g or g.db_conn is None or getattr(g.db_conn, '_closed', True):
        # g.db_conn이 없거나, None이거나, 또는 _closed 속성이 True (연결이 닫힌 상태)이면 새 연결
        try:
            current_app.logger.debug(
                f"Attempting to connect to DB: Server={current_app.config['DB_SERVER']}:{current_app.config['DB_PORT']}, "
                f"DB={current_app.config['DB_DATABASE']}, User={current_app.config['DB_USER']}"
            )
            g.db_conn = pymssql.connect(
                server=current_app.config['DB_SERVER'],
                port=str(current_app.config['DB_PORT']), # port는 문자열이 더 안전할 수 있음
                user=current_app.config['DB_USER'],
                password=current_app.config['DB_PASSWORD'],
                database=current_app.config['DB_DATABASE'],
                as_dict=True, # 결과를 딕셔너리 형태로 받으면 사용하기 편리합니다. (선택 사항)
                timeout=5,    # 연결 시도 타임아웃 (초)
                login_timeout=5 # 로그인 타임아웃 (초)
            )
            current_app.logger.debug("New DB connection created and stored in g for this request.")
        except Exception as e:
            current_app.logger.error(f"Failed to connect to database using pymssql: {e}", exc_info=True)
            g.db_conn = None # 오류 발생 시 None으로 설정
            raise # 오류를 다시 발생시켜 상위 호출자가 처리하도록 함 (또는 None 반환 후 처리)
    else:
        current_app.logger.debug("Reusing existing DB connection from g for this request.")
    return g.db_conn

def close_db(e=None):
    """
    요청 컨텍스트(g)에 저장된 DB 연결을 닫습니다.
    Flask의 @app.teardown_appcontext 데코레이터와 함께 사용되어 요청이 끝나면 자동으로 호출됩니다.
    """
    db_conn = g.pop('db_conn', None) # g에서 연결을 가져오면서 제거
    if db_conn is not None and not getattr(db_conn, '_closed', True):
        try:
            db_conn.close()
            current_app.logger.debug("DB connection closed for this request.")
        except Exception as e:
            current_app.logger.error(f"Error closing DB connection: {e}", exc_info=True)

# 이 함수는 app/__init__.py의 create_app 내부에서 @app.teardown_appcontext로 등록됩니다.
db_utils.py 설명:

get_db():
현재 Flask 요청 컨텍스트(g)에 db_conn이라는 이름으로 저장된 pymssql 연결이 있는지 확인합니다.
없거나 닫혀있으면, config.py의 정보를 사용하여 새 연결을 만들고 g.db_conn에 저장합니다.
as_dict=True로 설정하면 DB 조회 결과가 튜플 대신 컬럼명을 키로 하는 딕셔너리로 반환되어 편리합니다. (기본값은 False - 튜플 반환)
연결 오류 발생 시 로그를 남기고 예외를 다시 발생시킵니다.
close_db():
요청 처리가 끝나면(teardown_appcontext), g에 저장된 DB 연결을 가져와 닫습니다.
2. 수정: app/__init__.py (SQLAlchemy 완전 제거, pymssql 연결 관리 통합)
이 파일에서는 SQLAlchemy 관련 코드를 모두 제거하고, 위에서 정의한 db_utils.py의 함수들을 사용하여 요청별 DB 연결을 관리하도록 설정합니다.

Python

# scontrol_flask_web/app/__init__.py
from flask import Flask, current_app # current_app은 로깅 및 컨텍스트 프로세서 등에서 사용
from config import config # 프로젝트 루트의 config.py 임포트
import datetime
import os

# SQLAlchemy db 객체 정의는 완전히 제거합니다.
# db = SQLAlchemy() 

def create_app(config_name='default'):
    """
    Flask 애플리케이션 인스턴스를 생성하고 초기화하는 팩토리 함수입니다.
    이제 SQLAlchemy 대신 pymssql 직접 사용을 위한 설정을 포함합니다.
    """
    app = Flask(__name__)
    
    # 1. 설정 로드
    app.config.from_object(config[config_name])
    config[config_name].init_app(app) # Config 클래스의 init_app (현재는 비어있음)

    # SQLAlchemy 초기화 코드 제거
    # db.init_app(app) 

    # 2. 요청 종료 시 DB 연결 자동 해제를 위한 teardown 함수 등록
    from . import db_utils # db_utils.py 임포트
    app.teardown_appcontext(db_utils.close_db) # 모든 요청이 끝나면 close_db 함수 자동 호출

    # 3. Jinja2 커스텀 필터 및 컨텍스트 프로세서 등록 (이전과 동일)
    def format_datetime(value, fmt='%Y-%m-%d %H:%M'):
        if not value: 
            return ""
        if isinstance(value, str): 
            original_value_for_log = value 
            try: 
                processed_value = value.upper().replace('Z', '')
                if '.' in processed_value: processed_value = processed_value.split('.')[0]
                processed_value = processed_value.replace('T', ' ')
                formats_to_try = ["%Y-%m-%d %H:%M:%S", "%Y-%m-%d"]
                parsed_dt = None
                for dt_format in formats_to_try:
                    try: parsed_dt = datetime.datetime.strptime(processed_value, dt_format); break
                    except ValueError: continue
                if parsed_dt is None: 
                    app.logger.warning(f"날짜 문자열 파싱 실패 (format_datetime filter): '{original_value_for_log}'")
                    return original_value_for_log 
                value = parsed_dt
            except Exception as e_parse: 
                app.logger.error(f"날짜 문자열 파싱 중 예외 발생 (format_datetime filter) '{original_value_for_log}': {e_parse}")
                return original_value_for_log 
        if not isinstance(value, (datetime.datetime, datetime.date)): return value 
        return value.strftime(fmt)
    app.jinja_env.filters['datetimeformat'] = format_datetime
    
    @app.context_processor
    def inject_now(): return {'now': datetime.datetime.utcnow()}

    from .auth import inject_user_info_to_templates
    app.context_processor(inject_user_info_to_templates)

    # 4. 블루프린트(Blueprint) 등록 (이전과 동일)
    from .routes_main import main_bp
    app.register_blueprint(main_bp) 
    from .routes_admin import admin_bp
    app.register_blueprint(admin_bp, url_prefix='/admin') 
    from .routes_user import user_bp
    app.register_blueprint(user_bp, url_prefix='/user') 
    
    app.logger.info("Flask application (using direct pymssql with request-scoped connections) created and configured.")
    if app.debug:
        app.logger.debug(f"DB Server (for pymssql): {app.config.get('DB_SERVER')}:{app.config.get('DB_PORT')}")
        app.logger.debug(f"DB Name (for pymssql): {app.config.get('DB_DATABASE')}")

    return app
app/__init__.py 주요 변경 사항:

SQLAlchemy 완전 제거: from flask_sqlalchemy import SQLAlchemy, db = SQLAlchemy(), db.init_app(app) 라인을 모두 삭제했습니다.
teardown_appcontext 등록: app.teardown_appcontext(db_utils.close_db) 라인을 추가했습니다. 이 설정은 Flask가 각 HTTP 요청 처리를 완료한 후 (성공이든 오류든) db_utils.close_db 함수를 자동으로 호출하여 해당 요청에서 사용된 DB 연결(g.db_conn)이 있다면 닫도록 합니다.
로그 메시지 변경: 애플리케이션 생성 로그 메시지를 "using direct pymssql with request-scoped connections"로 변경하여 현재 설정을 명확히 했습니다.
4. app/models.py 파일의 역할 (재정의)
이제 SQLAlchemy ORM을 사용하지 않으므로, app/models.py 파일은 데이터베이스 테이블 구조를 정의하는 SQLAlchemy 모델 클래스를 포함하지 않습니다.

이 파일은 다음과 같은 용도로 사용할 수 있습니다 (선택 사항):

데이터 전송 객체 (DTO) 또는 간단한 데이터 클래스: 라우트 함수에서 DB 조회 결과를 받아 템플릿으로 전달하기 전에 데이터를 담는 간단한 Python 클래스들을 정의할 수 있습니다. (또는 그냥 딕셔너리 형태로 계속 사용)
Pydantic과 같은 데이터 유효성 검사 라이브러리 모델: API 요청/응답 데이터의 유효성을 검사하기 위한 모델을 정의할 수 있습니다 (현재 프로젝트 범위에서는 약간 과할 수 있음).
지금 당장은 app/models.py 파일이 비어 있거나, 또는 SQLAlchemy 모델 정의가 남아있더라도 실제 코드에서 사용되지 않으므로 기능에 영향을 주지 않습니다. 깔끔하게 하려면 SQLAlchemy 모델 정의 부분을 삭제하거나, 파일을 비워두셔도 됩니다.

다음 단계:

이제 config.py, app/__init__.py, app/db_utils.py 파일이 pymssql 직접 사용 방식으로 변경되었습니다.

다음으로는 이 변경된 DB 연결 방식을 사용하여 라우트 파일들 (app/routes_admin.py, app/routes_user.py, app/routes_main.py) 내부의 모든 데이터베이스 관련 코드를 수정해야 합니다. SQLAlchemy ORM 쿼리(AdminIP.query.filter_by(...), db.session.add(), db.session.commit() 등) 대신, db_utils.get_db()를 통해 pymssql 연결을 얻고, SQL 쿼리 문자열을 직접 작성하여 실행한 후, 그 결과를 처리하는 코드로 변경됩니다.