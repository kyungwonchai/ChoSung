겠습니다. 말씀하신 대로 일시정지를 누르면 전체 작업이 정지되어야 합니다. 그 이후 **Resume(재개)**를 누르면 다시 전체 작업을 재개하는 방식으로 수정하겠습니다.

다음은 전체 일시정지를 위한 기능과 **Resume(재개)**를 행별로 구현한 코드입니다.

전체 수정된 코드
1. TaskQueue.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Threading.Tasks;

/// <summary>
/// TaskQueue는 작업을 순차적으로 실행하며, 작업이 완료되면 다음 작업을 실행합니다.
/// 일시정지 기능도 포함하여 모든 작업을 정지할 수 있습니다.
/// </summary>
public class TaskQueue
{
    private Queue<Func<Task>> _tasks = new Queue<Func<Task>>();
    private bool _isRunning = false;  // 현재 작업이 실행 중인지 여부
    private bool _isPaused = false;   // 작업 일시정지 상태

    /// <summary>
    /// 작업 큐에 새로운 작업을 추가하고, 현재 작업이 실행 중이 아니면 즉시 실행합니다.
    /// </summary>
    public void EnqueueTask(Func<Task> task)
    {
        _tasks.Enqueue(task);  // 작업을 큐에 추가

        // 현재 작업이 실행 중이 아니고 일시정지 상태가 아니면 즉시 실행
        if (!_isRunning && !_isPaused)
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐의 다음 작업을 실행하는 메서드.
    /// </summary>
    private async void RunNextTask()
    {
        if (_tasks.Count == 0 || _isPaused)  // 작업이 없거나 일시정지 상태면 리턴
        {
            _isRunning = false;
            return;
        }

        _isRunning = true;  // 현재 작업 실행 중

        var task = _tasks.Dequeue();  // 큐에서 작업을 가져와 실행
        await task();  // 비동기 작업 실행

        _isRunning = false;  // 작업 완료 후 실행 중 상태 해제
        RunNextTask();  // 다음 작업 실행
    }

    /// <summary>
    /// 작업을 일시정지합니다.
    /// </summary>
    public void Pause()
    {
        _isPaused = true;  // 전체 작업 일시정지
    }

    /// <summary>
    /// 일시정지된 작업을 재개합니다.
    /// </summary>
    public void Resume()
    {
        _isPaused = false;  // 일시정지 상태 해제

        if (!_isRunning)  // 작업이 실행 중이지 않으면 작업을 재개
        {
            RunNextTask();
        }
    }

    /// <summary>
    /// 작업 큐를 초기화하고 비웁니다.
    /// </summary>
    public void ClearQueue()
    {
        _tasks.Clear();  // 작업 큐 비우기
        _isRunning = false;  // 실행 상태 해제
    }
}
2. TaskModel.cs
csharp
코드 복사
using System;
using System.Collections.ObjectModel;
using System.Threading.Tasks;
using System.Windows.Input;
using System.Windows.Media;

/// <summary>
/// TaskModel은 각 작업의 상태를 관리하며, 시퀀스에 따라 함수들을 실행합니다.
/// 작업이 완료되면 상태를 변경하고, 도형 색상을 업데이트합니다.
/// </summary>
public class TaskModel : ViewModelBase
{
    public string MAG_NO { get; set; }
    public string PO_NO { get; set; }

    // 함수와 도형 상태를 한 곳에서 관리
    public ObservableCollection<FunctionStatus> FunctionStatusList { get; set; }

    public string Status { get; set; }
    public ICommand ResumeCommand { get; }  // 리쥼 커맨드 (특정 행에서 시작)

    private TaskQueue _taskQueue;
    private Action<TaskModel> _resumeFromHere;  // 특정 행부터 재개할 델리게이트

    public TaskModel(LogEntry logEntry, TaskQueue taskQueue, Action<TaskModel> resumeFromHere)
    {
        MAG_NO = logEntry.MAG_NO;
        PO_NO = logEntry.PO_NO;
        _taskQueue = taskQueue;
        _resumeFromHere = resumeFromHere;  // 해당 행부터 재개하기 위한 델리게이트 전달

        // 함수 상태 초기화
        FunctionStatusList = new ObservableCollection<FunctionStatus>();

        Status = "Pending";  // 처음엔 대기 상태
        ResumeCommand = new RelayCommand(() => _resumeFromHere(this));  // 리쥼 버튼 클릭 시 실행

        // 함수 추가 (예시로 3개의 함수)
        AddFunction("Task A", ExecuteTaskA, Brushes.Gray);
        AddFunction("Task B", ExecuteTaskB, Brushes.Gray);
        AddFunction("Task C", ExecuteTaskC, Brushes.Gray);
    }

    /// <summary>
    /// 함수 이름, 작업, 도형 색상을 함께 관리
    /// </summary>
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);  // 도형과 상태를 함께 관리
    }

    /// <summary>
    /// 전체 작업 시퀀스를 실행
    /// </summary>
    public async Task ExecuteTaskSequence()
    {
        foreach (var functionStatus in FunctionStatusList)
        {
            functionStatus.UpdateStatus(Brushes.SkyBlue);  // 실행 중
            await functionStatus.Task();  // 비동기 작업 실행
            functionStatus.UpdateStatus(Brushes.Green);  // 완료됨
        }
        Status = "Completed";  // 전체 작업 완료
    }

    // Task A 실행
    private async Task ExecuteTaskA()
    {
        await Task.Delay(1000);  // 1초 대기 (작업 시뮬레이션)
    }

    // Task B 실행
    private async Task ExecuteTaskB()
    {
        await Task.Delay(1000);
    }

    // Task C 실행
    private async Task ExecuteTaskC()
    {
        await Task.Delay(1000);
    }
}

/// <summary>
/// FunctionStatus는 각 함수의 상태와 이름을 관리하는 클래스입니다.
/// </summary>
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush statusColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = statusColor;
    }

    /// <summary>
    /// 도형의 색상을 업데이트하여 상태를 나타냅니다.
    /// </summary>
    public void UpdateStatus(Brush newColor)
    {
        StatusColor = newColor;
        OnPropertyChanged(nameof(StatusColor));  // UI 업데이트
    }
}
3. MainViewModel.cs
csharp
코드 복사
using System.Collections.ObjectModel;
using System.Windows.Input;
using System.Windows;
using System.Linq;

public class MainViewModel : ViewModelBase
{
    // 작업 목록을 저장하는 ObservableCollection
    public ObservableCollection<TaskModel> TaskList { get; set; }

    // 작업을 순차적으로 실행하는 TaskQueue
    private TaskQueue _taskQueue;

    public ICommand PauseAllCommand { get; }
    public ICommand ResumeAllCommand { get; }

    public MainViewModel()
    {
        TaskList = new ObservableCollection<TaskModel>();

        // 작업 큐 초기화
        _taskQueue = new TaskQueue();

        // 전체 작업 정지와 재개 명령 설정
        PauseAllCommand = new RelayCommand(PauseAllTasks);
        ResumeAllCommand = new RelayCommand(ResumeAllTasks);
    }

    /// <summary>
    /// 특정 행의 리쥼 버튼을 눌렀을 때 그 행부터 시작하여 남은 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeTasksFrom(TaskModel startTask)
    {
        _taskQueue.ClearQueue();  // 기존 큐를 비워서 모든 작업을 리셋
        bool startAdding = false;

        // TaskList에서 선택한 행부터 끝까지 다시 큐에 작업 추가
        foreach (var task in TaskList)
        {
            if (task == startTask)
            {
                startAdding = true;
            }

            if (startAdding)
            {
                _taskQueue.EnqueueTask(async () => await task.ExecuteTaskSequence());
            }
        }
    }

    /// <summary>
    /// 모든 작업을 일시정지합니다.
    /// </summary>
    private void PauseAllTasks()
    {
        _taskQueue.Pause();  // 모든 작업을 일시정지
    }

    /// <summary>
    /// 모든 작업을 재개합니다.
    /// </summary>
    private void ResumeAllTasks()
    {
        _taskQueue.Resume();  // 모든 작업 재개
    }

    /// <summary>
    /// 새로운 로그 파일이 감지되었을 때 호출됩니다.
    /// LogEntry 데이터를 기반으로 TaskModel을 생성하고 작업 큐에 추가합니다.
    /// </summary>
    public void OnLogEntryDetected(LogEntry logEntry)
    {
        Application.Current.Dispatcher.Invoke(() =>
        {
            var task = new TaskModel(logEntry, _taskQueue, ResumeTasksFrom);
            TaskList.Add(task);  // UI 스레드에서 작업 목록에 추가
        });
    }
}
4. XAML 코드
xml
코드 복사
<Window x:Class="YourApp.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="MainWindow" Height="450" Width="800">
    <Grid>
        <!-- 작업 목록을 표시하는 DataGrid -->
        <DataGrid ItemsSource="{Binding TaskList}" AutoGenerateColumns="False" Margin="10">
            <DataGrid.Columns>
                <DataGridTextColumn Header="MAG_NO" Binding="{Binding MAG_NO}" Width="*"/>
                <DataGridTextColumn Header="PO_NO" Binding="{Binding PO_NO}" Width="*"/>
                <DataGridTemplateColumn Header="Function Status">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <!-- 도형과 상태를 표시하는 ItemsControl -->
                            <ItemsControl ItemsSource="{Binding FunctionStatusList}">
                                <ItemsControl.ItemTemplate>
                                    <DataTemplate>
                                        <StackPanel Orientation="Horizontal">
                                            <!-- 함수 이름 표시 -->
                                            <Ellipse Width="30" Height="30" Fill="{Binding StatusColor}">
                                                <Ellipse.ToolTip>
                                                    <TextBlock Text="{Binding FunctionName}" />
                                                </Ellipse.ToolTip>
                                            </Ellipse>
                                        </StackPanel>
                                    </DataTemplate>
                                </ItemsControl.ItemTemplate>
                            </ItemsControl>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>

                <!-- 리쥼 버튼 -->
                <DataGridTemplateColumn Header="Resume">
                    <DataGridTemplateColumn.CellTemplate>
                        <DataTemplate>
                            <Button Content="Resume" Command="{Binding ResumeCommand}"/>
                        </DataTemplate>
                    </DataGridTemplateColumn.CellTemplate>
                </DataGridTemplateColumn>
            </DataGrid.Columns>
        </DataGrid>

        <!-- 전체 작업 일시정지 버튼 -->
        <Button Content="Pause All" Command="{Binding PauseAllCommand}" HorizontalAlignment="Left" VerticalAlignment="Bottom" Width="100" Margin="10"/>
        
        <!-- 전체 작업 재개 버튼 -->
        <Button Content="Resume All" Command="{Binding ResumeAllCommand}" HorizontalAlignment="Right" VerticalAlignment="Bottom" Width="100" Margin="10"/>
    </Grid>
</Window>
주요 기능
전체 작업 일시정지:

Pause All 버튼을 누르면 전체 작업이 일시정지됩니다.
모든 작업은 멈추고, 실행 중이던 작업도 멈춘 상태가 됩니다.
전체 작업 재개:

Resume All 버튼을 누르면 작업이 다시 재개됩니다.
멈췄던 작업부터 다시 실행됩니다.
리쥼 버튼:

각 행에 리쥼 버튼을 눌러 해당 작업부터 다시 실행하도록 구성되었습니다.
적용 방식
전체 작업 정지/재개를 위한 Pause/Resume 버튼은 전체적으로 작동하며, 리쥼 버튼은 개별적으로 행에서 재개가 가능하도록 구현되어 있습니다.