삭제된 개체에 대한 액세스" 오류는 TcpListener 객체가 중지되었거나 사용이 중단된 후에 다시 액세스하려고 할 때 발생할 수 있습니다. 이 문제는 TcpListener가 중지되거나 CancellationToken이 요청된 후에도 클라이언트 연결을 처리하려고 할 때 주로 발생합니다.

원인 분석
TcpListener가 중지됨: TcpListener가 중지된 후에도 클라이언트를 수락하려고 할 때, 해당 객체는 더 이상 유효하지 않으므로 "삭제된 개체" 오류가 발생할 수 있습니다.
다른 스레드에서 TcpListener.Stop() 호출: 한 스레드에서 TcpListener.Stop()이 호출되었는데, 동시에 다른 스레드에서 클라이언트 연결을 수락하려고 하면 이 문제가 발생할 수 있습니다.
해결 방법
TcpListener의 수명을 관리하고, 객체가 유효하지 않을 때 접근하려는 시도를 방지해야 합니다. 이를 위해 몇 가지 방법을 제안합니다:

1. TcpListener 객체의 상태를 확인하고 에러 처리
TcpListener가 중지된 경우 예외를 처리하고 반복 루프를 빠져나오는 방법입니다.

csharp
코드 복사
private async Task StartTcpListener(CancellationToken cancellationToken)
{
    try
    {
        _tcpListener = new TcpListener(IPAddress.Any, _serverPort);
        _tcpListener.Start();
        Console.WriteLine("TCP server started, listening for connections...");

        while (!cancellationToken.IsCancellationRequested)
        {
            try
            {
                // 클라이언트 연결 수락을 비동기적으로 대기
                TcpClient client = await _tcpListener.AcceptTcpClientAsync();

                // 클라이언트가 연결되면 처리 작업 시작
                Console.WriteLine("Client connected.");
                _ = Task.Run(() => HandleClient(client, cancellationToken));
            }
            catch (ObjectDisposedException ex)
            {
                // TcpListener가 중지된 경우, 루프 종료
                Console.WriteLine("TcpListener has been stopped: " + ex.Message);
                break; // 루프를 빠져나가 서버 종료
            }
            catch (Exception ex)
            {
                // 그 외 예외 처리
                Console.WriteLine($"Error accepting client: {ex.Message}");
            }
        }
    }
    catch (Exception ex)
    {
        // 서버 시작 실패 시 예외 처리
        Console.WriteLine($"Error starting TCP server: {ex.Message}");
    }
    finally
    {
        _tcpListener?.Stop();
        Console.WriteLine("TCP server stopped.");
    }
}
2. CancellationToken과 TcpListener의 수명 관리
CancellationToken을 사용하여 TCP 서버를 중단할 때, 토큰의 상태와 TcpListener의 상태를 철저히 관리해야 합니다.

TcpListener의 유효성 확인: TcpListener가 중지되었거나 중단된 상태에서 사용되지 않도록 유효성을 철저히 확인해야 합니다.
비동기 작업 취소: AcceptTcpClientAsync와 같은 비동기 작업에서 CancellationToken을 올바르게 사용하여 작업이 안전하게 중단될 수 있도록 합니다.
3. 코드를 통한 개선
아래 코드는 TcpListener의 수명을 좀 더 철저히 관리하고, CancellationToken을 사용하여 TCP 서버가 중지될 때 안전하게 종료할 수 있도록 합니다.

csharp
코드 복사
private async Task StartTcpListener(CancellationToken cancellationToken)
{
    _tcpListener = new TcpListener(IPAddress.Any, _serverPort);
    _tcpListener.Start();
    Console.WriteLine("TCP server started, listening for connections...");

    try
    {
        while (!cancellationToken.IsCancellationRequested)
        {
            // 비동기 작업이 취소되지 않은 경우에만 클라이언트를 수락
            if (_tcpListener.Pending())
            {
                try
                {
                    TcpClient client = await _tcpListener.AcceptTcpClientAsync().ConfigureAwait(false);
                    Console.WriteLine("Client connected.");
                    _ = Task.Run(() => HandleClient(client, cancellationToken));
                }
                catch (ObjectDisposedException)
                {
                    // TcpListener가 중지되었을 때 예외 처리
                    Console.WriteLine("TcpListener has been stopped.");
                    break;
                }
                catch (Exception ex)
                {
                    // 기타 예외 처리
                    Console.WriteLine($"Error accepting client: {ex.Message}");
                }
            }
            await Task.Delay(100); // 적절한 대기 시간을 두어 CPU 사용량을 줄임
        }
    }
    finally
    {
        _tcpListener?.Stop();
        Console.WriteLine("TCP server stopped.");
    }
}
설명
Pending() 메서드 사용: TcpListener.Pending() 메서드를 사용하여 들어오는 클라이언트 연결이 있는지 확인하고, 없으면 짧은 지연을 두고 루프를 반복합니다. 이는 CPU 사용량을 줄이고 불필요한 예외를 방지하는 데 도움이 됩니다.
ConfigureAwait(false): AcceptTcpClientAsync 호출에서 ConfigureAwait(false)를 사용하여 현재 컨텍스트를 무시하고 비동기 작업이 완료될 때 기본 스레드에서 작업을 계속하도록 합니다.
CancellationToken 확인: 루프 내부에서 cancellationToken.IsCancellationRequested를 계속 확인하여, 취소 요청이 있으면 안전하게 종료할 수 있도록 합니다.
이 수정된 코드로 TcpListener가 더 안전하게 동작하고, 종료 시 발생할 수 있는 예외를 방지할 수 있습니다.







