
import React, { useState, useEffect, useCallback } from 'react';
import { nanoid } from 'https://esm.sh/nanoid';
import ElementToolbox from './components/ElementToolbox';
import EditorCanvas from './components/EditorCanvas';
import PrintPreview from './components/PrintPreview';
import SettingsPanel from './components/SettingsPanel';
import LayoutList from './components/LayoutList';
import BackendInstructionsModal from './components/BackendInstructionsModal';


// --- TYPE DEFINITIONS ---
export type ElementType = 'label' | 'textbox' | 'line' | 'rectangle' | 'relative-time';

export interface LabelElement {
  id: string;
  type: ElementType;
  x: number; // position from left in px
  y: number; // position from top in px
  width: number; // in px
  height: number; // in px
  content: string; // for text or data
  fontSize: number; // in px, for text-based elements
  color: string; // text color
  backgroundColor: string; // fill color
  borderWidth: number; // in px
  borderColor: string;
  hoursAgo?: number; // for relative-time
}

export interface Layout {
  id: string;
  name: string;
  elements: LabelElement[];
}

const CANVAS_WIDTH = 400;
const CANVAS_HEIGHT = 300;
const LOCAL_STORAGE_KEY = 'canvasEditorLayouts_v1';
const API_BASE_URL = 'http://localhost:3001'; // Backend server address

const App: React.FC = () => {
  const [layouts, setLayouts] = useState<Layout[]>([]);
  const [selectedLayoutId, setSelectedLayoutId] = useState<string | null>(null);
  const [selectedElementId, setSelectedElementId] = useState<string | null>(null);
  const [isInstructionsModalOpen, setIsInstructionsModalOpen] = useState(false);
  const [printSettings, setPrintSettings] = useState({
    width: 300,
    height: 200,
  });
  
  const [isEditMode, setIsEditMode] = useState(false);
  const [passwordInput, setPasswordInput] = useState('');

  // Load from local storage or initialize on mount
  useEffect(() => {
    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    let loadedSuccessfully = false;
    if (savedData) {
        try {
            const { layouts: savedLayouts, printSettings: savedPrintSettings } = JSON.parse(savedData);
            if (Array.isArray(savedLayouts) && savedLayouts.length > 0) {
              setLayouts(savedLayouts);
              setSelectedLayoutId(savedLayouts[0].id);
              if (savedPrintSettings) setPrintSettings(savedPrintSettings);
              loadedSuccessfully = true;
            }
        } catch (e) {
            console.error("Failed to parse layouts from local storage.", e);
        }
    }

    if (!loadedSuccessfully) {
        // Initialize with 20 empty layouts
        const initialLayouts = Array.from({ length: 20 }, (_, i) => ({
            id: nanoid(),
            name: `Label ${i + 1}`,
            elements: [],
        }));
        setLayouts(initialLayouts);
        setSelectedLayoutId(initialLayouts[0].id);
    }
  }, []);
  
  const handleEnableEditMode = (e: React.FormEvent) => {
    e.preventDefault();
    if (passwordInput === '시스템2@') {
      setIsEditMode(true);
    } else {
      alert('암호가 올바르지 않습니다.');
      setPasswordInput('');
    }
  };

  const handleDisableEditMode = () => {
    setIsEditMode(false);
    setPasswordInput('');
    setSelectedElementId(null);
  };

  const handlePrint = () => {
    window.print();
  };
  
  const addElement = (type: ElementType) => {
    if (!isEditMode || !selectedLayoutId) return;

    const baseElement = {
      id: nanoid(),
      type,
      x: CANVAS_WIDTH / 2 - 50,
      y: CANVAS_HEIGHT / 2 - 25,
      width: 100,
      height: 50,
      fontSize: 16,
      color: '#1e293b', // slate-800
      backgroundColor: 'transparent',
      borderWidth: 0,
      borderColor: 'transparent',
    };

    let newElement: LabelElement;

    switch (type) {
        case 'label':
            newElement = { ...baseElement, content: 'Label' };
            break;
        case 'textbox':
            newElement = { ...baseElement, content: 'Editable Text', borderWidth: 1, borderColor: '#64748b', backgroundColor: '#f8fafc' }; // slate-500 border, slate-50 bg
            break;
        case 'line':
            newElement = { ...baseElement, content: '', height: 2, backgroundColor: '#1e293b' };
            break;
        case 'rectangle':
            newElement = { ...baseElement, content: '', width: 100, height: 80, y: CANVAS_HEIGHT / 2 - 40, backgroundColor: 'transparent', borderWidth: 1, borderColor: '#64748b' }; // slate-200 bg, slate-500 border
            break;
        case 'relative-time':
            newElement = { ...baseElement, content: '', hoursAgo: 1 };
            break;
        default:
            return;
    }
    
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: [...layout.elements, newElement] }
            : layout
    ));
    setSelectedElementId(newElement.id);
  };
  
  const updateElement = useCallback((id: string, newProps: Partial<LabelElement>) => {
    if (!isEditMode) return;
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: layout.elements.map(el => el.id === id ? { ...el, ...newProps } : el) }
            : layout
    ));
  }, [selectedLayoutId, isEditMode]);

  const updatePrintSettings = useCallback((newSettings: Partial<typeof printSettings>) => {
    setPrintSettings(prev => ({
        ...prev,
        ...newSettings
    }));
  }, []);
  
  const deleteElement = useCallback((id: string) => {
    if (!isEditMode) return;
    setLayouts(prev => prev.map(layout => 
        layout.id === selectedLayoutId
            ? { ...layout, elements: layout.elements.filter(el => el.id !== id) }
            : layout
    ));

    if (selectedElementId === id) {
      setSelectedElementId(null);
    }
  }, [selectedLayoutId, selectedElementId, isEditMode]);

  useEffect(() => {
    const handleKeyDown = (e: KeyboardEvent) => {
      if (!isEditMode) return;
      if ((e.key === 'Delete' || e.key === 'Backspace') && selectedElementId) {
        const target = e.target as HTMLElement;
        if(target.tagName !== 'INPUT' && target.tagName !== 'TEXTAREA'){
          e.preventDefault();
          deleteElement(selectedElementId);
        }
      }
    };
    window.addEventListener('keydown', handleKeyDown);
    return () => window.removeEventListener('keydown', handleKeyDown);
  }, [selectedElementId, deleteElement, isEditMode]);
  
  const handleSaveLayout = useCallback(() => {
    const layoutData = { layouts, printSettings };
    const layoutJson = JSON.stringify(layoutData, null, 2);
    localStorage.setItem(LOCAL_STORAGE_KEY, layoutJson);
    alert('All layouts have been saved to your browser\'s local storage.');
  }, [layouts, printSettings]);

  const handleLoadLayout = useCallback(() => {
    const savedData = localStorage.getItem(LOCAL_STORAGE_KEY);
    if (savedData) {
        try {
            const { layouts: savedLayouts, printSettings: savedPrintSettings } = JSON.parse(savedData);
            if (Array.isArray(savedLayouts)) {
                setLayouts(savedLayouts);
                setSelectedLayoutId(savedLayouts.length > 0 ? savedLayouts[0].id : null);
                setSelectedElementId(null);
                if (savedPrintSettings) setPrintSettings(savedPrintSettings);
                alert('All layouts loaded from local storage.');
            } else {
                throw new Error("Saved data is not in the correct format.");
            }
        } catch (e) {
            alert('Could not parse layouts from local storage.');
            console.error(e);
        }
    } else {
        alert('No saved layouts found in local storage.');
    }
  }, []);

  const handleSaveToDb = async () => {
    if (!confirm('This will save all layouts to the database via the backend API. Are you sure?')) return;
    try {
        const response = await fetch(`${API_BASE_URL}/api/layouts`, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify({ layouts }),
        });
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server error: ${response.status} ${response.statusText}. ${errorText}`);
        }
        alert('All layouts were successfully saved to the database.');
    } catch (err: any) {
        console.error('Database save error:', err);
        alert(`Failed to save layouts to the database. Is the backend server running? Error: ${err.message}`);
    }
  };

  const handleLoadFromDb = async () => {
    if (!confirm('This will replace your current layouts with data from the database. Are you sure?')) return;
    try {
        const response = await fetch(`${API_BASE_URL}/api/layouts`);
        if (!response.ok) {
            const errorText = await response.text();
            throw new Error(`Server error: ${response.status} ${response.statusText}. ${errorText}`);
        }
        const dbLayouts: Layout[] = await response.json();

        if (dbLayouts && Array.isArray(dbLayouts)) {
            if (dbLayouts.length > 0) {
              setLayouts(dbLayouts);
              setSelectedLayoutId(dbLayouts[0].id);
              setSelectedElementId(null);
              alert(`Successfully loaded ${dbLayouts.length} layouts from the database.`);
            } else {
              alert('No layouts found in the database.');
            }
        } else {
             throw new Error("Received invalid data from server.");
        }
    } catch (err: any) {
        console.error('Database load error:', err);
        alert(`Failed to load layouts from the database. Is the backend server running? Error: ${err.message}`);
    }
  };


  const handleSelectLayout = (id: string) => {
    setSelectedLayoutId(id);
    setSelectedElementId(null); // Deselect element when switching layouts
  };

  const selectedLayout = layouts.find(l => l.id === selectedLayoutId);
  const elements = selectedLayout ? selectedLayout.elements : [];
  const selectedElement = elements.find(el => el.id === selectedElementId) || null;

  return (
    <div className="flex flex-col h-screen bg-slate-100 font-sans text-slate-800">
      <header className="bg-white shadow-md p-3 print:hidden z-20">
        <div className="container mx-auto flex justify-between items-center">
            <h1 className="text-xl font-bold text-slate-700 flex-shrink-0">Multi-Label Canvas Editor</h1>

            <div className="flex-1 flex justify-center px-8">
                {!isEditMode ? (
                    <form onSubmit={handleEnableEditMode} className="flex items-center gap-2">
                        <input
                            type="password"
                            value={passwordInput}
                            onChange={(e) => setPasswordInput(e.target.value)}
                            placeholder="암호"
                            className="w-40 px-3 py-2 text-sm border border-slate-300 rounded-md shadow-sm focus:outline-none focus:ring-1 focus:ring-indigo-500"
                            aria-label="Password for edit mode"
                        />
                        <button type="submit" className="px-5 py-2 text-sm font-semibold bg-slate-600 text-white rounded-lg shadow-sm hover:bg-slate-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-500">
                            편집
                        </button>
                    </form>
                ) : (
                    <button onClick={handleDisableEditMode} className="px-5 py-2 text-sm font-semibold bg-red-600 text-white rounded-lg shadow-sm hover:bg-red-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-red-500">
                        편집 종료
                    </button>
                )}
            </div>
            
            <div className="flex items-center gap-3">
                <button
                    onClick={() => setIsInstructionsModalOpen(true)}
                    className="px-5 py-2 text-sm font-semibold bg-slate-200 text-slate-800 rounded-lg shadow-sm hover:bg-slate-300 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-slate-400 transition-colors"
                >
                    설명
                </button>
                <button
                    onClick={handlePrint}
                    className="px-5 py-2 text-sm font-semibold bg-indigo-600 text-white rounded-lg shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 transition-colors"
                >
                    Print
                </button>
            </div>
        </div>
      </header>

      <main className="flex flex-1 overflow-hidden">
        <LayoutList
            layouts={layouts}
            selectedLayoutId={selectedLayoutId}
            onSelectLayout={handleSelectLayout}
        />
        {isEditMode && <ElementToolbox onAddElement={addElement} />}
        <div id="editor-wrapper" className="flex-1 p-4 sm:p-6 lg:p-8 overflow-auto bg-slate-200">
          <EditorCanvas
            elements={elements}
            selectedElementId={selectedElementId}
            onSelectElement={setSelectedElementId}
            onUpdateElement={updateElement}
            canvasWidth={CANVAS_WIDTH}
            canvasHeight={CANVAS_HEIGHT}
            printSettings={printSettings}
            isEditMode={isEditMode}
          />
        </div>
        {isEditMode && <SettingsPanel
            selectedElement={selectedElement}
            onUpdateElement={updateElement}
            onDeleteElement={deleteElement}
            printSettings={printSettings}
            onUpdatePrintSettings={updatePrintSettings}
            onSaveLayout={handleSaveLayout}
            onLoadLayout={handleLoadLayout}
            onSaveToDb={handleSaveToDb}
            onLoadFromDb={handleLoadFromDb}
        />}
      </main>
      <PrintPreview elements={elements} canvasWidth={CANVAS_WIDTH} canvasHeight={CANVAS_HEIGHT} printSettings={printSettings} />
      <BackendInstructionsModal
        isOpen={isInstructionsModalOpen}
        onClose={() => setIsInstructionsModalOpen(false)}
      />
    </div>
  );
};
