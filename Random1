xaml.cs의 내용을 지우면 전역 예외 처리기가 동작하지 않아 오류가 더 직접적으로 나타날 수 있습니다.

"DbContext has been disposed" 오류가 CanSaveChangesExecute 함수에서 발생한다는 것은, MasterDataWindow가 닫히면서 해당 창의 ViewModel(MasterDataViewModel)이 가진 DbContext가 Dispose 메서드 호출로 인해 이미 해제되었는데, 그 이후에 WPF 프레임워크가 (아직 가비지 컬렉션되지 않은 ViewModel의) SaveChangesCommand의 상태를 확인하기 위해 CanSaveChangesExecute를 호출하면서 이미 해제된 DbContext에 접근하려고 하기 때문에 발생하는 문제입니다.

해결 방법:

MasterDataViewModel 내부에 자신이 Dispose되었는지 여부를 나타내는 플래그(_disposed)를 추가하고, CanExecute 메서드들(CanSaveChangesExecute, CanAddItemExecute, CanDeleteItemExecute)이 실행될 때 이 플래그를 먼저 확인하여, 이미 Dispose된 상태라면 DbContext에 접근하지 않도록 수정합니다.

수정해야 할 파일:

ViewModels/MasterDataViewModel.cs
아래는 수정된 MasterDataViewModel.cs 파일의 전체 코드입니다.

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Data.Entity;
using System.Data.Entity.Infrastructure;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Input;
using System.Collections.Generic;
using System.Diagnostics;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 마스터 데이터 관리 ViewModel (Dispose 후 접근 오류 수정)
    /// </summary>
    public class MasterDataViewModel : ViewModelBase, IDisposable
    {
        private readonly LockerDbContext _context;
        private bool _disposed = false; // *** 수정: Dispose 되었는지 확인하는 플래그 ***

        #region Observable Collections & Properties
        public ObservableCollection<LockerType> LockerTypes { get; set; }
        public ObservableCollection<Floor> Floors { get; set; }
        public ObservableCollection<Zone> Zones { get; set; }
        public ObservableCollection<SubPart> SubParts { get; set; }
        public ObservableCollection<Administrator> Administrators { get; set; }
        private object _selectedItem;
        public object SelectedItem { get => _selectedItem; set { if (SetProperty(ref _selectedItem, value)) RaiseCanExecuteChanged(); } }
        private string _statusMessage;
        public string StatusMessage { get => _statusMessage; set => SetProperty(ref _statusMessage, value); }
        #endregion

        #region Commands
        public ICommand LoadAllMasterDataCommand { get; }
        public ICommand AddItemCommand { get; }
        public ICommand DeleteItemCommand { get; }
        public ICommand SaveChangesCommand { get; }
        #endregion

        public MasterDataViewModel()
        {
            try { _context = new LockerDbContext(); }
            catch (Exception ex) { MessageBox.Show($"[MasterData] DB 컨텍스트 생성 오류:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error); StatusMessage = "[MasterData] DB 연결 오류!"; LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>(); LoadAllMasterDataCommand = new RelayCommand(_ => { }, _ => false); AddItemCommand = new RelayCommand(_ => { }, _ => false); DeleteItemCommand = new RelayCommand(_ => { }, _ => false); SaveChangesCommand = new RelayCommand(_ => { }, _ => false); return; }

            LockerTypes = new ObservableCollection<LockerType>(); Floors = new ObservableCollection<Floor>(); Zones = new ObservableCollection<Zone>(); SubParts = new ObservableCollection<SubPart>(); Administrators = new ObservableCollection<Administrator>();
            LoadAllMasterDataCommand = new RelayCommand(async _ => await LoadAllMasterDataAsync());
            AddItemCommand = new RelayCommand(AddItem, CanAddItemExecute);
            DeleteItemCommand = new RelayCommand(DeleteItem, CanDeleteItemExecute);
            SaveChangesCommand = new RelayCommand(async _ => await SaveMasterDataChangesAsync(), CanSaveChangesExecute);
            if (_context != null) { _ = LoadAllMasterDataAsync(); }
        }

        #region Data Loading and CRUD Methods
        public async Task LoadAllMasterDataAsync() { if (_context == null || _disposed) return; StatusMessage = "마스터 데이터 로딩 중..."; try { var lockerTypes = await _context.LockerTypes.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); LockerTypes.Clear(); lockerTypes.ForEach(LockerTypes.Add); var floors = await _context.Floors.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Floors.Clear(); floors.ForEach(Floors.Add); var zones = await _context.Zones.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Zones.Clear(); zones.ForEach(Zones.Add); var subParts = await _context.SubParts.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); SubParts.Clear(); subParts.ForEach(SubParts.Add); var administrators = await _context.Administrators.OrderBy(x => x.Name).AsNoTracking().ToListAsync(); Administrators.Clear(); administrators.ForEach(Administrators.Add); StatusMessage = "마스터 데이터 로드 완료."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"마스터 데이터 로딩 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } }

        // *** 수정: CanExecute 메서드들에서 _disposed 플래그 확인 추가 ***
        private bool CanAddItemExecute(object parameter) => !_disposed && _context != null && parameter is string category && !string.IsNullOrEmpty(category);
        private bool CanDeleteItemExecute(object parameter) => !_disposed && _context != null && SelectedItem != null;
        private bool CanSaveChangesExecute(object parameter)
        {
            // Dispose 되었거나 Context가 null이면 false
            if (_disposed || _context == null) return false;
            try
            {
                // DbContext가 유효할 때만 변경 사항 확인
                return _context.ChangeTracker.HasChanges();
            }
            catch (ObjectDisposedException)
            {
                // 만약 확인 중 Dispose 되었다면 false 반환
                return false;
            }
            catch (Exception ex)
            {
                // 기타 예외 발생 시 로그 남기고 false 반환 (안전 조치)
                Debug.WriteLine($"CanSaveChangesExecute 확인 중 오류: {ex.Message}");
                return false;
            }
        }


        private void AddItem(object parameter) { if (!CanAddItemExecute(parameter)) return; if (parameter is string category) { try { object newItem = null; switch (category.ToLower()) { case "lockertype": newItem = _context.LockerTypes.Add(new LockerType { Name = "새 종류" }); LockerTypes.Add((LockerType)newItem); break; case "floor": newItem = _context.Floors.Add(new Floor { Name = "새 층" }); Floors.Add((Floor)newItem); break; case "zone": newItem = _context.Zones.Add(new Zone { Name = "새 구역" }); Zones.Add((Zone)newItem); break; case "subpart": newItem = _context.SubParts.Add(new SubPart { Name = "새 소파트" }); SubParts.Add((SubPart)newItem); break; case "administrator": newItem = _context.Administrators.Add(new Administrator { Name = "새 관리자" }); Administrators.Add((Administrator)newItem); break; default: MessageBox.Show("알 수 없는 카테고리.", "오류"); return; } SelectedItem = newItem; StatusMessage = "새 항목 추가됨. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 추가 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); } } }
        private void DeleteItem(object parameter) { if (!CanDeleteItemExecute(parameter)) return; string itemName = GetItemName(SelectedItem); if (itemName == null) return; string confirmMessage = $"'{itemName}' 삭제?"; if (HasAssociatedAssignments(SelectedItem, itemName)) { confirmMessage += "\n\n경고: 사용 중인 사물함 정보가 있습니다!"; } if (MessageBox.Show(confirmMessage, "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes) { try { object entityToDelete = SelectedItem; var entry = _context.Entry(entityToDelete); if (entry.State == EntityState.Detached) _context.Set(entityToDelete.GetType()).Attach(entityToDelete); entry.State = EntityState.Deleted; if (SelectedItem is LockerType lt1) LockerTypes.Remove(lt1); else if (SelectedItem is Floor f1) Floors.Remove(f1); else if (SelectedItem is Zone z1) Zones.Remove(z1); else if (SelectedItem is SubPart sp1) SubParts.Remove(sp1); else if (SelectedItem is Administrator ad1) Administrators.Remove(ad1); SelectedItem = null; StatusMessage = "항목 삭제 대기 중. 저장 필요."; RaiseCanExecuteChanged(); } catch (Exception ex) { StatusMessage = $"항목 삭제 오류: {ex.Message}"; MessageBox.Show(StatusMessage, "오류", MessageBoxButton.OK, MessageBoxImage.Error); _ = LoadAllMasterDataAsync(); } } }
        private string GetItemName(object item) { return item?.GetType().GetProperty("Name")?.GetValue(item)?.ToString(); }
        private bool HasAssociatedAssignments(object item, string itemName) { if (_context == null || _disposed || item == null || string.IsNullOrEmpty(itemName)) return false; try { if (item is LockerType) return _context.LockerAssignments.Any(a => a.LockerType == itemName); if (item is Floor) return _context.LockerAssignments.Any(a => a.Floor == itemName); if (item is Zone) return _context.LockerAssignments.Any(a => a.Zone == itemName); if (item is SubPart) return _context.LockerAssignments.Any(a => a.SubPart == itemName); if (item is Administrator) return _context.LockerAssignments.Any(a => a.Administrator == itemName); } catch (Exception ex) { Debug.WriteLine($"연관 데이터 확인 오류: {ex.Message}"); return true; } return false; }

        /// <summary>
        /// 마스터 데이터 변경 사항 저장 (연쇄 업데이트 포함)
        /// </summary>
        private async Task SaveMasterDataChangesAsync()
        {
            if (!CanSaveChangesExecute(null)) { StatusMessage = "저장할 변경 사항이 없습니다."; return; }
            StatusMessage = "마스터 데이터 저장 중...";
            List<DbEntityEntry> changesForRollback = _context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged).ToList();

            using (var transaction = _context.Database.BeginTransaction())
            {
                try
                {
                    Debug.WriteLine("마스터 데이터 저장 시작 - 트랜잭션 시작됨.");
                    var modifiedNameEntries = _context.ChangeTracker.Entries().Where(e => e.State == EntityState.Modified && (e.Entity is LockerType || e.Entity is Floor || e.Entity is Zone || e.Entity is SubPart || e.Entity is Administrator)).Select(e => new { Entry = e, EntityType = e.Entity.GetType(), OriginalName = e.OriginalValues["Name"]?.ToString(), CurrentName = e.CurrentValues["Name"]?.ToString() }).Where(x => x.OriginalName != null && x.CurrentName != null && x.OriginalName != x.CurrentName).ToList();
                    Debug.WriteLine($"이름 변경 감지된 마스터 데이터 수: {modifiedNameEntries.Count}");

                    foreach (var modified in modifiedNameEntries)
                    {
                        StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' 연쇄 업데이트 중..."; Debug.WriteLine($"연쇄 업데이트 시도: Type={modified.EntityType.Name}, Original='{modified.OriginalName}', New='{modified.CurrentName}'"); int updatedCount = 0; string updateSql = ""; string targetColumn = ""; if (modified.EntityType == typeof(LockerType)) targetColumn = "LockerType"; else if (modified.EntityType == typeof(Floor)) targetColumn = "Floor"; else if (modified.EntityType == typeof(Zone)) targetColumn = "Zone"; else if (modified.EntityType == typeof(SubPart)) targetColumn = "SubPart"; else if (modified.EntityType == typeof(Administrator)) targetColumn = "Administrator";
                        if (!string.IsNullOrEmpty(targetColumn))
                        {
                            updateSql = $"UPDATE LockerAssignments SET [{targetColumn}] = {{0}} WHERE [{targetColumn}] = {{1}}";
                            try { updatedCount = await _context.Database.ExecuteSqlCommandAsync(updateSql, modified.CurrentName, modified.OriginalName); StatusMessage = $"'{modified.OriginalName}' -> '{modified.CurrentName}' ({updatedCount}개 업데이트 완료)."; Debug.WriteLine($"  SQL 실행 성공: {updateSql} | Params: '{modified.CurrentName}', '{modified.OriginalName}' | Rows Affected: {updatedCount}"); }
                            catch (Exception sqlEx) { Debug.WriteLine($"*** 연쇄 업데이트 SQL 실행 오류! SQL: {updateSql}, Params: '{modified.CurrentName}', '{modified.OriginalName}'\n*** 오류: {sqlEx.ToString()}"); StatusMessage = $"'{modified.OriginalName}' 연쇄 업데이트 중 오류 발생!"; throw new Exception($"연쇄 업데이트 SQL 실행 실패 ({modified.OriginalName} -> {modified.CurrentName}): {sqlEx.Message}", sqlEx); } // 예외 다시 던지기
                        } else { Debug.WriteLine($"  경고: 엔티티 타입 '{modified.EntityType.Name}'에 대한 대상 컬럼을 찾을 수 없습니다."); }
                    }

                    Debug.WriteLine("마스터 데이터 변경 사항 저장 시도 (SaveChangesAsync)...");
                    int masterDataChanges = await _context.SaveChangesAsync(); // 로그는 DbContext에서 자동 기록
                    Debug.WriteLine($"마스터 데이터 SaveChanges 완료. 변경 건수: {masterDataChanges}");

                    transaction.Commit(); Debug.WriteLine("트랜잭션 커밋 완료.");
                    StatusMessage = $"마스터 데이터 변경 사항 ({masterDataChanges}건) 및 연쇄 업데이트가 성공적으로 저장되었습니다.";
                }
                catch (DbUpdateException dbEx) { Debug.WriteLine($"*** 마스터 데이터 SaveChanges 중 DbUpdateException 발생! 트랜잭션 롤백 시도...\n*** 오류: {dbEx.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } HandleDbUpdateExceptionForMasterData(dbEx); RollbackMasterDataChanges(changesForRollback); }
                catch (Exception ex) { Debug.WriteLine($"*** 마스터 데이터 저장/연쇄 업데이트 중 오류 발생! 트랜잭션 롤백 시도...\n*** 오류: {ex.ToString()}"); try { transaction.Rollback(); Debug.WriteLine("트랜잭션 롤백 완료."); } catch (Exception rbEx) { Debug.WriteLine($"*** 트랜잭션 롤백 중 오류 발생!\n*** 오류: {rbEx.ToString()}"); } StatusMessage = $"마스터 데이터 저장 중 오류 발생: {ex.Message}"; MessageBox.Show($"{StatusMessage}\n\n자세한 내용은 출력 창을 확인하세요.", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error); RollbackMasterDataChanges(changesForRollback); }
            }
            await LoadAllMasterDataAsync(); // 작업 완료 후 목록 새로고침
            RaiseCanExecuteChanged(); // 저장 후 CanExecute 상태 갱신
        }
        private void RollbackMasterDataChanges(List<DbEntityEntry> changedEntries) { if (_context == null || _disposed || changedEntries == null) return; foreach (var entry in changedEntries) { switch (entry.State) { case EntityState.Modified: try { entry.Reload(); } catch { entry.State = EntityState.Unchanged; } break; case EntityState.Added: entry.State = EntityState.Detached; break; case EntityState.Deleted: entry.State = EntityState.Unchanged; break; } } StatusMessage = "마스터 데이터 변경 롤백됨."; _ = LoadAllMasterDataAsync(); }
        private void HandleDbUpdateExceptionForMasterData(DbUpdateException dbEx) { var innerExMsg = dbEx.InnerException?.InnerException?.Message ?? dbEx.InnerException?.Message ?? dbEx.Message; StatusMessage = $"DB 업데이트 오류: {innerExMsg}"; MessageBox.Show($"DB 작업 오류:\n{innerExMsg}\n\n{dbEx.ToString()}", "DB 오류", MessageBoxButton.OK, MessageBoxImage.Error); }
        #endregion

        /// <summary>
        /// 모든 Command의 CanExecute 상태를 갱신합니다.
        /// </summary>
        private void RaiseCanExecuteChanged()
        {
            (LoadAllMasterDataCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (AddItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (DeleteItemCommand as RelayCommand)?.RaiseCanExecuteChanged();
            (SaveChangesCommand as RelayCommand)?.RaiseCanExecuteChanged();
        }

        #region IDisposable 구현
        // private bool disposed = false; // 클래스 멤버 변수로 이동

        /// <summary>
        /// 관리되는 리소스 및 관리되지 않는 리소스를 해제합니다.
        /// </summary>
        /// <param name="disposing">true이면 관리되는 리소스를 해제하고, false이면 관리되지 않는 리소스만 해제합니다.</param>
        protected virtual void Dispose(bool disposing)
        {
            if (!_disposed) // _disposed 필드 사용
            {
                if (disposing)
                {
                    // 관리되는 리소스 해제 (DbContext)
                    _context?.Dispose();
                }
                // 관리되지 않는 리소스 해제 (필요 시)

                _disposed = true; // *** 수정: Dispose 되었음을 플래그로 표시 ***
            }
        }

        /// <summary>
        /// 이 인스턴스에서 사용하는 모든 리소스를 해제합니다.
        /// </summary>
        public void Dispose()
        {
            Dispose(true); // 관리/비관리 리소스 모두 해제
            GC.SuppressFinalize(this); // GC가 Finalize를 호출하지 않도록 함
        }
        #endregion
    }
}
주요 수정 사항:

_disposed 플래그 추가: MasterDataViewModel 클래스에 private bool _disposed = false; 멤버 변수를 추가했습니다.
Dispose 메서드 수정: Dispose(bool disposing) 메서드 내에서 리소스를 해제한 후 _disposed = true; 코드를 추가하여 객체가 해제되었음을 표시합니다.
CanExecute 메서드 수정: CanAddItemExecute, CanDeleteItemExecute, CanSaveChangesExecute 메서드 시작 부분에 !_disposed && _context != null 조건을 추가하여, ViewModel이 이미 Dispose되었거나 Context가 없는 경우에는 false를 반환하도록 수정했습니다. 특히 CanSaveChangesExecute는 _context.ChangeTracker 접근 전에 ObjectDisposedException을 방지하기 위해 try-catch를 추가하여 안정성을 높였습니다.