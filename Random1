using System;
using System.Collections.Generic;
using System.Drawing;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using OpenCvSharp;
using OpenCvSharp.Extensions;

class Program
{
    // ë§ˆìš°ìŠ¤ í´ë¦­ì„ ìœ„í•œ WinAPI í˜¸ì¶œ
    [DllImport("user32.dll")]
    private static extern void SetCursorPos(int x, int y);

    [DllImport("user32.dll")]
    private static extern void mouse_event(int dwFlags, int dx, int dy, int dwData, int dwExtraInfo);

    private const int MOUSEEVENTF_LEFTDOWN = 0x02;
    private const int MOUSEEVENTF_LEFTUP = 0x04;

    static async Task Main()
    {
        Bitmap screenshot = CaptureScreen();
        Mat image = BitmapConverter.ToMat(screenshot);

        await DetectAndClick(image);
    }

    /// <summary>
    /// ğŸ–¥ï¸ í™”ë©´ ìº¡ì²˜
    /// </summary>
    static Bitmap CaptureScreen()
    {
        Rectangle bounds = new Rectangle(817, 345, 1381 - 817, 545 - 345);
        Bitmap bitmap = new Bitmap(bounds.Width, bounds.Height);

        using (Graphics g = Graphics.FromImage(bitmap))
        {
            g.CopyFromScreen(bounds.X, bounds.Y, 0, 0, bounds.Size);
        }

        return bitmap;
    }

    /// <summary>
    /// ğŸ” OpenCVë¡œ ìˆ«ì ê°ì§€ í›„ í´ë¦­
    /// </summary>
    static async Task DetectAndClick(Mat image)
    {
        Mat gray = new Mat();
        Cv2.CvtColor(image, gray, ColorConversionCodes.BGR2GRAY); // í‘ë°± ë³€í™˜

        // ğŸ›  ì „ì²˜ë¦¬ 1: AdaptiveThreshold ì ìš© â†’ ì–‡ì€ ìˆ«ì ê²€ì¶œ ê°•í™”
        Mat binary = new Mat();
        Cv2.AdaptiveThreshold(gray, binary, 255, AdaptiveThresholdTypes.GaussianC, ThresholdTypes.BinaryInv, 11, 2);

        // ğŸ›  ì „ì²˜ë¦¬ 2: íŒ½ì°½ ì—°ì‚° â†’ ì‘ì€ ìš”ì†Œë¥¼ ë¬¶ì–´ì„œ ìˆ«ì ì¸ì‹ ê°•í™”
        Mat kernel = Cv2.GetStructuringElement(MorphShapes.Rect, new Size(2, 2));
        Cv2.MorphologyEx(binary, binary, MorphTypes.Dilate, kernel, new Point(-1, -1), 2);

        // ğŸ›  ì»¨íˆ¬ì–´ ê²€ì¶œ (ìœ¤ê³½ì„  ì°¾ê¸°)
        Cv2.FindContours(binary, out Point[][] contours, out _, RetrievalModes.External, ContourApproximationModes.ApproxSimple);

        List<Point> clickPositions = new List<Point>();

        // í‘œ ì¢Œí‘œ ë²”ìœ„
        int startX = 817, startY = 345, endX = 1381, endY = 545;
        int cellWidth = 80, cellHeight = 50;

        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);

            // ğŸ”¥ ì»¨íˆ¬ì–´ í•„í„°ë§ (ë„ˆë¬´ ì‘ê±°ë‚˜ ë°‘ì¤„ ì—†ëŠ” ê²ƒ ì œê±°)
            if (rect.Width > 15 && rect.Height > 20 && rect.Height < 50) // ë°‘ì¤„ì´ í¬í•¨ëœ í¬ê¸° ì˜ˆìƒê°’
            {
                int centerX = startX + rect.X;
                int centerY = startY + rect.Y;
                clickPositions.Add(new Point(centerX, centerY));
            }
        }

        // âœ… í´ë¦­ ìˆœì„œ ì •ë ¬ (ìš°ì¸¡ â†’ ì¢Œì¸¡, ìœ„ì—ì„œ ì•„ë˜ë¡œ ì´ë™)
        clickPositions.Sort((a, b) =>
        {
            if (a.X == b.X) return a.Y.CompareTo(b.Y); // ê°™ì€ ì—´ì´ë©´ ìœ„ì—ì„œ ì•„ë˜ë¡œ ì •ë ¬
            return b.X.CompareTo(a.X); // ìš°ì¸¡ë¶€í„° í´ë¦­
        });

        // âœ… í´ë¦­ ì‹¤í–‰
        foreach (var pos in clickPositions)
        {
            await ClickAsync(pos.X, pos.Y);
            await Task.Delay(50);
        }

        // âœ… ë””ë²„ê¹…ìš© - ê²€ì¶œëœ ìˆ«ì ìœ„ì¹˜ ì´ˆë¡ ë°•ìŠ¤ë¡œ í‘œì‹œ
        foreach (var contour in contours)
        {
            Rect rect = Cv2.BoundingRect(contour);
            if (rect.Width > 15 && rect.Height > 20)
                Cv2.Rectangle(image, rect, new Scalar(0, 255, 0), 2);
        }

        Cv2.ImShow("Detected Numbers", image);
        Cv2.ImShow("Binary Mask", binary);
        Cv2.WaitKey(0);
        Cv2.DestroyAllWindows();
    }

    /// <summary>
    /// ğŸ–±ï¸ ë¹„ë™ê¸° ë§ˆìš°ìŠ¤ í´ë¦­ (0.5ì´ˆ ì´ë‚´ ì‹¤í–‰)
    /// </summary>
    static async Task ClickAsync(int x, int y)
    {
        await Task.Run(() =>
        {
            SetCursorPos(x, y);
            mouse_event(MOUSEEVENTF_LEFTDOWN, x, y, 0, 0);
            mouse_event(MOUSEEVENTF_LEFTUP, x, y, 0, 0);
        });

        Console.WriteLine($"í´ë¦­: X={x}, Y={y}");
    }