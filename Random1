영 로그를 남길 때 어떤 함수에서 왜 남겼는지에 대한 원인을 명확하게 기록하도록 MainWindow.xaml.cs 파일을 수정하겠습니다. 각 로그 메시지에 함수명과 이유를 포함시키겠습니다.

수정된 MainWindow.xaml.cs
csharp
코드 복사
private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
{
    while (true)
    {
        try
        {
            long freeSpace = await Task.Run(() => _fileCleaner.GetDriveFreeSpace(driveName));
            List<FileInfo> filesToDelete;

            if (freeSpace <= MinimumFreeSpace)
            {
                filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension, forceDelete: true));
                LogRecentActivity("MonitorAndDisplayFilesToDelete", $"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 강제 삭제를 진행합니다.");
            }
            else
            {
                filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension));
                if (filesToDelete.Count > 0)
                {
                    LogRecentActivity("MonitorAndDisplayFilesToDelete", "삭제를 진행합니다.");
                }
            }

            Dispatcher.Invoke(() => DisplayFilesToDelete(filesToDelete));
            await _fileCleaner.DeleteFilesAsync(filesToDelete, folderPath, forceDelete: freeSpace <= MinimumFreeSpace);

            long totalSize = await Task.Run(() => _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension));
            if (totalSize > 0 && totalSize != _fileCleaner.lastLoggedSize) // 총 크기가 0인 경우와 중복 크기 로그 생성을 피함
            {
                _fileCleaner.lastLoggedSize = totalSize;
                LogRecentActivity("UpdateFolderStatistics", $"폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB");
            }
            await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
        }
        catch (Exception ex)
        {
            _logger.LogError("MonitorAndDisplayFilesToDelete", "모니터링 중 오류 발생: " + ex.Message);
        }
    }
}

private void LogRecentActivity(string functionName, string message)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: [{functionName}] {message}";
        lstRecentLogs.Items.Add(logMessage);
        if (lstRecentLogs.Items.Count > 200)
        {
            lstRecentLogs.Items.RemoveAt(0);
        }
    });
}

private void LogDeletionActivity(string functionName, string message)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: [{functionName}] {message}";
        lstDeletionLogs.Items.Add(logMessage);
        if (lstDeletionLogs.Items.Count > 200)
        {
            lstDeletionLogs.Items.RemoveAt(0);
        }
    });
}

private void LogError(string functionName, string message)
{
    Dispatcher.Invoke(() =>
    {
        string logMessage = $"{DateTime.Now}: [ERROR] [{functionName}] {message}";
        lstRecentLogs.Items.Add(logMessage);
        if (lstRecentLogs.Items.Count > 200)
        {
            lstRecentLogs.Items.RemoveAt(0);
        }
    });
}
이제 로그를 남길 때 함수명과 이유를 포함하도록 수정되었습니다. LogRecentActivity, LogDeletionActivity, LogError 함수를 통해 각각의 로그에 어떤 함수에서 왜 로그를 남겼는지 명확히 기록됩니