, 가져온 파일을 이어서 판다스(Pandas)로 처리해야 한다면 처음부터 파이썬으로 전체 과정을 자동화하는 것이 훨씬 효율적입니다.

이전의 셸 스크립트와 동일한 servers.conf 및 자격 증명 파일을 그대로 사용하면서, 모든 로직을 파이썬으로 구현한 스크립트입니다.

## 사전 준비: 파이썬 라이브러리 설치
이 스크립트를 실행하려면 파일 공유(SMB) 프로토콜을 다루는 라이브러리와 판다스를 설치해야 합니다. 터미널에서 아래 명령어를 실행하세요.

Bash

pip install smbprotocol pandas
## 파이썬 자동화 스크립트
이전 단계에서 만들었던 servers.conf 파일과 자격 증명 파일들은 그대로 사용합니다. 아래 내용을 copy_latest.py 라는 이름으로 저장하세요.

Python

import os
import shutil
import pandas as pd
from smbprotocol.exceptions import SMBException
from smbprotocol.smb_client import SmbClient, SMB_DIALECT_SMB2_1, SMB_DIALECT_SMB3_1_1

# 셸 스크립트에서 사용했던 설정 파일 경로
CONFIG_FILE = os.path.expanduser("~/servers.conf")

def get_credentials(file_path):
    """자격 증명 파일에서 username과 password를 읽어오는 함수"""
    creds = {}
    try:
        with open(os.path.expanduser(file_path), 'r') as f:
            for line in f:
                key, value = line.strip().split('=', 1)
                creds[key] = value
    except FileNotFoundError:
        print(f"-> 에러: 자격 증명 파일을 찾을 수 없습니다: {file_path}")
        return None, None
    return creds.get("username"), creds.get("password")

def process_with_pandas(file_path):
    """다운로드한 파일을 판다스로 처리하는 함수 (예시)"""
    print(f"-> 판다스로 파일 처리 시작: {file_path}")
    try:
        # 파일 확장자에 따라 다르게 읽기 (예: .csv)
        if file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
            # 여기에서 판다스를 이용한 2차 처리를 수행합니다.
            # 예: 데이터프레임의 첫 5줄 출력
            print("파일 내용 (상위 5줄):")
            print(df.head())
        else:
            print("-> 지원하지 않는 파일 형식이므로 판다스 처리를 건너뜁니다.")
        
        print("-> 판다스 처리 완료.")
        
    except Exception as e:
        print(f"-> 판다스 처리 중 에러 발생: {e}")


def main():
    """메인 실행 함수"""
    if not os.path.exists(CONFIG_FILE):
        print(f"설정 파일({CONFIG_FILE})을 찾을 수 없습니다.")
        return

    with open(CONFIG_FILE, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            server_ip, share_name, cred_file, src_dir, dest_dir = line.split(';')
            
            print(f"--- [{server_ip}] 작업 시작 ---")
            
            username, password = get_credentials(cred_file)
            if not username or not password:
                continue

            latest_file_info = {'name': None, 'mtime': 0}
            
            client = SmbClient(server_ip, username=username, password=password)
            try:
                # SMB 3.1.1 또는 2.1 프로토콜로 연결 시도
                client.connect(dialects=[SMB_DIALECT_SMB3_1_1, SMB_DIALECT_SMB2_1])
                
                # 원본 디렉토리의 파일 목록 스캔
                full_src_path = f"\\\\{server_ip}\\{share_name}\\{src_dir}"
                for file_info in client.scandir(full_src_path):
                    if file_info.is_file():
                        mod_time = file_info.stat().st_mtime
                        if mod_time > latest_file_info['mtime']:
                            latest_file_info['name'] = file_info.name
                            latest_file_info['mtime'] = mod_time

                if latest_file_info['name']:
                    remote_file_name = latest_file_info['name']
                    remote_file_path = os.path.join(full_src_path, remote_file_name).replace(os.path.sep, '\\')
                    local_file_path = os.path.join(os.path.expanduser(dest_dir), remote_file_name)
                    
                    print(f"-> 최신 파일 찾음: {remote_file_name}")
                    
                    # 파일 다운로드
                    with client.open_file(remote_file_path, mode='rb') as remote_f:
                        with open(local_file_path, 'wb') as local_f:
                            shutil.copyfileobj(remote_f, local_f)
                    
                    print(f"-> 파일 복사 완료: {local_file_path}")
                    
                    # **다운로드 완료 후 판다스 처리 함수 호출**
                    process_with_pandas(local_file_path)

                else:
                    print("-> 경고: 복사할 파일을 찾지 못했습니다.")

            except SMBException as e:
                print(f"-> SMB 에러: {e}")
            except Exception as e:
                print(f"-> 알 수 없는 에러: {e}")
            finally:
                if client.is_connected:
                    client.close()
            
            print("--------------------------\n")

    print("모든 작업이 완료되었습니다.")


if __name__ == "__main__":
    main()
## 스크립트 실행 방법
위 코드를 copy_latest.py로 저장합니다.

터미널에서 아래 명령어로 실행합니다.

Bash

python3 copy_latest.py
## 셸 스크립트 대비 파이썬 스크립트의 장점
통합된 워크플로우: 파일을 가져오는 작업과 판다스로 데이터를 처리하는 작업이 하나의 스크립트 안에서 자연스럽게 이어집니다.

안정적인 에러 처리: try...except 구문을 통해 네트워크 연결 실패, 인증 오류, 파일 없음 등 다양한 예외 상황을 훨씬 더 체계적으로 관리할 수 있습니다.

플랫폼 독립성: 이 파이썬 스크립트는 리눅스뿐만 아니라 윈도우, macOS에서도 라이브러리만 설치하면 동일하게 작동합니다.

뛰어난 확장성: 나중에 처리 로직이 복잡해지거나, 결과를 다른 DB에 저장하는 등의 기능을 추가하기 훨씬 용이합니다.


공유폴더 계정이 guest일수도있는데




생각하는 과정 표시
네, 아주 좋은 지적입니다. 공유 폴더가 guest 계정(익명)으로 열려있는 경우를 처리할 수 있도록 이전 파이썬 스크립트를 수정해 드릴게요.

guest 계정은 자격 증명 파일 경로에 guest 라고 명시하는 간단한 규칙을 추가하여 처리하겠습니다.

## 1단계: servers.conf 파일 수정
먼저, guest 계정으로 접근해야 하는 서버의 정보를 servers.conf 파일에서 수정합니다. 세 번째 항목인 자격 증명 파일 경로에 guest 라고 적어주세요.

~/servers.conf 파일 예시:

# IP주소;공유폴더이름;자격증명파일경로;가져올폴더경로;저장할로컬폴더
192.168.1.10;Data;~/.smb-credentials-server1;/path/on/server;/home/user/dest1
192.168.1.20;Backup;~/.smb-credentials-server2;/another/path;/home/user/dest2
192.168.1.30;Public;guest;/public/files;/home/user/dest3  # <-- 이 라인처럼 guest로 지정
## 2단계: Guest 계정을 처리하는 파이썬 스크립트
아래는 guest 설정을 인식하여 아이디/비밀번호 없이 접속을 시도하는 수정된 파이썬 스크립트입니다.

copy_latest_with_guest.py

Python

import os
import shutil
import pandas as pd
from smbprotocol.exceptions import SMBException
from smbprotocol.smb_client import SmbClient, SMB_DIALECT_SMB2_1, SMB_DIALECT_SMB3_1_1

# 설정 파일 경로
CONFIG_FILE = os.path.expanduser("~/servers.conf")

def get_credentials(file_path):
    """자격 증명 파일에서 username과 password를 읽어오는 함수"""
    creds = {}
    try:
        with open(os.path.expanduser(file_path), 'r') as f:
            for line in f:
                key, value = line.strip().split('=', 1)
                creds[key] = value
    except FileNotFoundError:
        print(f"-> 에러: 자격 증명 파일을 찾을 수 없습니다: {file_path}")
        return None, None
    return creds.get("username"), creds.get("password")

def process_with_pandas(file_path):
    """다운로드한 파일을 판다스로 처리하는 함수 (예시)"""
    print(f"-> 판다스로 파일 처리 시작: {file_path}")
    try:
        if file_path.endswith('.csv'):
            df = pd.read_csv(file_path)
            print("파일 내용 (상위 5줄):")
            print(df.head())
        else:
            print("-> 지원하지 않는 파일 형식이므로 판다스 처리를 건너뜁니다.")
        print("-> 판다스 처리 완료.")
    except Exception as e:
        print(f"-> 판다스 처리 중 에러 발생: {e}")

def main():
    """메인 실행 함수"""
    if not os.path.exists(CONFIG_FILE):
        print(f"설정 파일({CONFIG_FILE})을 찾을 수 없습니다.")
        return

    with open(CONFIG_FILE, 'r') as f:
        for line in f:
            line = line.strip()
            if not line or line.startswith('#'):
                continue

            server_ip, share_name, cred_file, src_dir, dest_dir = line.split(';')

            print(f"--- [{server_ip}] 작업 시작 ---")

            # **'guest'인 경우와 아닌 경우를 분기하여 처리**
            if cred_file.lower() == 'guest':
                username = None
                password = None
                print("-> Guest 계정으로 접속을 시도합니다.")
            else:
                username, password = get_credentials(cred_file)
                if not username or not password:
                    continue

            latest_file_info = {'name': None, 'mtime': 0}

            # SmbClient는 username, password가 None이면 익명 접속을 시도함
            client = SmbClient(server_ip, username=username, password=password)
            try:
                client.connect(dialects=[SMB_DIALECT_SMB3_1_1, SMB_DIALECT_SMB2_1])

                full_src_path = f"\\\\{server_ip}\\{share_name}\\{src_dir}"
                for file_info in client.scandir(full_src_path):
                    if file_info.is_file():
                        mod_time = file_info.stat().st_mtime
                        if mod_time > latest_file_info['mtime']:
                            latest_file_info['name'] = file_info.name
                            latest_file_info['mtime'] = mod_time

                if latest_file_info['name']:
                    remote_file_name = latest_file_info['name']
                    remote_file_path = os.path.join(full_src_path, remote_file_name).replace(os.path.sep, '\\')
                    local_file_path = os.path.join(os.path.expanduser(dest_dir), remote_file_name)

                    print(f"-> 최신 파일 찾음: {remote_file_name}")

                    with client.open_file(remote_file_path, mode='rb') as remote_f:
                        with open(local_file_path, 'wb') as local_f:
                            shutil.copyfileobj(remote_f, local_f)

                    print(f"-> 파일 복사 완료: {local_file_path}")

                    process_with_pandas(local_file_path)
                else:
                    print("-> 경고: 복사할 파일을 찾지 못했습니다.")

            except SMBException as e:
                print(f"-> SMB 에러: {e}")
            except Exception as e:
                print(f"-> 알 수 없는 에러: {e}")
            finally:
                if client.is_connected:
                    client.close()

            print("--------------------------\n")

    print("모든 작업이 완료되었습니다.")

if __name__ == "__main__":
    main()

## 변경된 점
main() 함수 내부에 cred_file의 값이 문자열 'guest'인지 확인하는 로직을 추가했습니다.

만약 'guest'라면, username과 password를 None으로 설정합니다. smbprotocol 라이브러리는 이 값들이 None일 때 자동으로 익명(guest) 로그인을 시도합니다.

'guest'가 아니라면, 이전과 동일하게 get_credentials 함수를 통해 파일에서 계정 정보를 읽어옵니다.