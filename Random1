private async Task<CommandPacket> RelayCommandAsync(CommandPacket originalRelayRequest, string clientIp, CancellationToken token)
{
    _loggingService.UiInfo($"[{clientIp}] 릴레이: {originalRelayRequest.CommandName} -> {originalRelayRequest.FinalTargetIpForRelayedCommand}:{originalRelayRequest.FinalTargetPortForRelayedCommand}");
    if (string.IsNullOrEmpty(originalRelayRequest.FinalTargetIpForRelayedCommand) || !originalRelayRequest.FinalTargetPortForRelayedCommand.HasValue)
    { return CreateErrorResponse(originalRelayRequest, "Relay failed: Final target IP/Port missing."); }

    // 릴레이 대상이 여러 IP일 경우 (세미콜론 구분) 파싱 및 순차 전송
    string[] finalTargetIps = originalRelayRequest.FinalTargetIpForRelayedCommand.Split(new[] { ';' }, StringSplitOptions.RemoveEmptyEntries)
                                  .Select(ip => ip.Trim())
                                  .Distinct() // 중복 제거
                                  .ToArray();

    if (!finalTargetIps.Any())
    {
        return CreateErrorResponse(originalRelayRequest, "Relay failed: No valid final target IPs after parsing.");
    }

    _loggingService.UiInfo($"[{clientIp}] Parsed {finalTargetIps.Length} unique final relay targets: {string.Join(", ", finalTargetIps)}");

    // 각 최종 타겟에 대한 응답을 수집하거나, 첫 번째 성공/실패만 보고할 수 있음.
    // 여기서는 각 타겟에 명령을 보내고, 전체적인 성공/실패를 요약하여 응답.
    int successCount = 0;
    List<string> individualResults = new List<string>();

    foreach (var finalIp in finalTargetIps)
    {
        if (token.IsCancellationRequested) { _loggingService.UiInfo($"[{clientIp}] Relay loop canceled before processing {finalIp}."); token.ThrowIfCancellationRequested(); }

        var packetForFinalTarget = new CommandPacket {
            Instruction = CommandInstruction.DirectExecute,
            CommandName = originalRelayRequest.CommandName,
            PayloadJson = originalRelayRequest.PayloadJson,
            // 최종 목적지는 이 릴레이 에이전트나 원 요청자에게 직접 응답하지 않음 (단순화)
            // 필요하다면 ResponseAddress/Port를 설정하여 다단계 응답 체인 구성 가능
            ResponseAddress = null,
            ResponsePort = null,
            PacketId = Guid.NewGuid()
        };
        string currentRelayTargetDesc = $"{finalIp}:{originalRelayRequest.FinalTargetPortForRelayedCommand.Value}";
        _loggingService.UiDebug($"[{clientIp}] Relaying to {currentRelayTargetDesc}...");

        CommandPacket responseFromThisFinalTarget = null;
        string thisTargetMessage = $"Relay to {currentRelayTargetDesc}: ";

        try
        {
            using (var targetClient = new TcpClient())
            {
                var connectTask = targetClient.ConnectAsync(finalIp, originalRelayRequest.FinalTargetPortForRelayedCommand.Value);
                
                // ### 변경 지점 1: 연결 타임아웃을 5초에서 200ms로 변경 ###
                if (await Task.WhenAny(connectTask, Task.Delay(200, token)) != connectTask || token.IsCancellationRequested)
                { 
                    token.ThrowIfCancellationRequested(); 
                    targetClient.Close(); 
                    throw new TimeoutException($"Connection to final relay target {currentRelayTargetDesc} timed out (200ms)."); 
                }
                
                await connectTask;
                _loggingService.UiDebug($"[{clientIp}] 릴레이 대상 {currentRelayTargetDesc} 연결 성공.");

                using (NetworkStream relayStream = targetClient.GetStream())
                using (StreamWriter relayWriter = new StreamWriter(relayStream, Encoding.UTF8){AutoFlush=true})
                using (StreamReader relayReader = new StreamReader(relayStream, Encoding.UTF8))
                {
                    string jsonToRelay = JsonConvert.SerializeObject(packetForFinalTarget);
                    if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                    await relayWriter.WriteLineAsync(jsonToRelay);
                    _loggingService.UiDebug($"[{clientIp}] 릴레이 데이터 전송 to {currentRelayTargetDesc}: {jsonToRelay}");
                    
                    var targetResponseTask = relayReader.ReadLineAsync();
                    
                    // ### 변경 지점 2: 응답 대기 타임아웃을 10초에서 200ms로 변경 ###
                    if (await Task.WhenAny(targetResponseTask, Task.Delay(200, token)) == targetResponseTask && !token.IsCancellationRequested)
                    {
                        string targetJson = await targetResponseTask;
                        if(token.IsCancellationRequested) token.ThrowIfCancellationRequested();
                        if (!string.IsNullOrEmpty(targetJson))
                        {
                            _loggingService.UiInfo($"[{clientIp}] 릴레이 대상 {currentRelayTargetDesc} 응답: {targetJson}");
                            responseFromThisFinalTarget = JsonConvert.DeserializeObject<CommandPacket>(targetJson);
                            // 최종 타겟의 응답 페이로드에서 실제 성공 여부 확인
                            if (responseFromThisFinalTarget?.PayloadJson != null) {
                                var finalPayload = JsonConvert.DeserializeObject<GenericResponsePayload>(responseFromThisFinalTarget.PayloadJson);
                                if (finalPayload != null && finalPayload.Success) {
                                    successCount++;
                                    thisTargetMessage += $"Success - {finalPayload.Message}";
                                } else {
                                    thisTargetMessage += $"Failed - {finalPayload?.Message ?? "Unknown error from target."}";
                                }
                            } else { thisTargetMessage += "Sent, but no detailed payload from target.";}
                        } else { _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 {currentRelayTargetDesc} 빈 응답."); thisTargetMessage += "Sent, but empty response from final target."; }
                    } else { 
                        _loggingService.UiWarn($"[{clientIp}] 릴레이 대상 {currentRelayTargetDesc} 응답 시간 초과(200ms)/취소."); 
                        thisTargetMessage += "Sent, but no response/timeout/canceled from final target (200ms).";
                    }
                }
            }
        }
        catch (OperationCanceledException) { thisTargetMessage += "Operation Canceled."; _loggingService.UiInfo($"[{clientIp}] Relay to {currentRelayTargetDesc} canceled."); }
        catch (TimeoutException tex) { thisTargetMessage += $"Timeout - {tex.Message}"; _loggingService.UiWarn($"[{clientIp}] Relay to {currentRelayTargetDesc}: {thisTargetMessage}"); }
        catch (SocketException se) { thisTargetMessage += $"Socket error - {se.Message}"; _loggingService.UiError($"[{clientIp}] Relay to {currentRelayTargetDesc}: {thisTargetMessage}", se); }
        catch (Exception ex) { thisTargetMessage += $"Unexpected error - {ex.Message}"; _loggingService.UiError($"[{clientIp}] Relay to {currentRelayTargetDesc}: {thisTargetMessage}", ex); }
        individualResults.Add(thisTargetMessage);
    } // end foreach finalIp

    // 릴레이 작업 전체에 대한 요약 응답 생성
    bool overallSuccess = successCount == finalTargetIps.Length && finalTargetIps.Length > 0;
    string finalMessage = $"Relay to {finalTargetIps.Length} targets. Success: {successCount}/{finalTargetIps.Length}. Details: {string.Join(" | ", individualResults)}";
    
    return CreateExecutionResponse(originalRelayRequest, overallSuccess, finalMessage.Length > 1000 ? finalMessage.Substring(0,1000) + "..." : finalMessage); // 메시지 길이 제한
}