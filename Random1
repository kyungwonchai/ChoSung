, 알겠습니다. git add 이후에 추가될 파일들의 총용량을 계산해서, 90MB가 넘으면 해당 프로젝트의 커밋과 푸시를 건너뛰도록 스크립트를 수정하겠습니다.

용량 제한은 스크립트 상단에서 쉽게 조절할 수 있도록 변수로 만들었습니다.

## 최종 업데이트된 Python 스크립트
아래는 파일 용량 제한 기능이 추가된 최종 코드입니다.

Python

import os
import subprocess
import glob
import sys
import re # 정규표현식 모듈

# --------------------------------------------------
# 설정: 아래 변수들을 자신의 환경에 맞게 수정하세요.
# --------------------------------------------------
# ✨ 1. 본인의 GitHub 유저네임을 정확히 입력하세요.
GITHUB_USER = "<YOUR_GITHUB_USERNAME>"

# ✨ 2. 검색을 시작할 절대 경로를 지정하세요. (비워두면 현재 폴더에서 검색)
TARGET_DIRECTORY = ""  # 예: "/home/user/projects"

# ✨ 3. 생성될 저장소의 기본 공개 상태를 '비공개'로 설정합니다.
VISIBILITY = "--private"

# ✨ 4. 푸시할 파일의 최대 용량(MB)을 설정합니다. 이 용량을 초과하면 해당 프로젝트는 건너뜁니다.
SIZE_LIMIT_MB = 90

# --------------------------------------------------
# 아래 코드는 수정할 필요 없습니다.
# --------------------------------------------------

def sanitize_path(path_string):
    """경로 문자열에서 안전하지 않은 문자를 언더스코어로 변경하는 함수"""
    return re.sub(r'[^a-zA-Z0-9_./-]', '_', path_string)

def run_command(command):
    """주어진 명령어를 실행하고 결과를 출력하는 함수"""
    print(f"🚀 실행: {' '.join(command)}")
    try:
        result = subprocess.run(command, check=True, text=True, capture_output=True)
        if result.stdout: print(result.stdout)
        if result.stderr: print(result.stderr, file=sys.stderr)
    except FileNotFoundError:
        print(f"❌ 오류: '{command[0]}' 명령어를 찾을 수 없습니다. PATH를 확인해주세요.", file=sys.stderr)
        sys.exit(1)
    except subprocess.CalledProcessError as e:
        print(f"❌ 명령어 실행 실패: {' '.join(e.cmd)}", file=sys.stderr)
        print(f"--- STDOUT ---\n{e.stdout}", file=sys.stderr)
        print(f"--- STDERR ---\n{e.stderr}", file=sys.stderr)
        sys.exit(1)

def detect_project_type(directory):
    """디렉토리 내용을 분석하여 프로젝트 타입을 반환하는 함수."""
    package_json_path = os.path.join(directory, 'package.json')
    if os.path.isfile(package_json_path):
        try:
            with open(package_json_path, 'r', encoding='utf-8') as f:
                if '"react":' in f.read(): return "react"
        except Exception: pass

    py_files = glob.glob(os.path.join(directory, '*.py'))
    if not py_files: return None

    contains_flask, contains_streamlit = False, False
    for file_path in py_files:
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read().lower()
                if 'flask' in content: contains_flask = True
                if 'streamlit' in content: contains_streamlit = True
        except Exception: continue
            
    if contains_flask: return "flask"
    if contains_streamlit: return "streamlit"
    return None

def main():
    if GITHUB_USER == "<YOUR_GITHUB_USERNAME>":
        print("❌ 오류: 스크립트 상단의 GITHUB_USER 변수를 실제 GitHub 유저네임으로 수정해주세요.")
        return

    print(f"스크립트를 시작합니다. GitHub 사용자: {GITHUB_USER}")
    base_path = TARGET_DIRECTORY if TARGET_DIRECTORY else os.getcwd()
    print(f"검색을 시작할 폴더: {base_path}")
    print("--------------------------------------------------")

    all_subdirs = glob.glob(os.path.join(base_path, '*/'))
    
    projects_to_upload = []
    print(">>> 프로젝트 폴더를 검색하고 타입을 분석합니다...")
    for subdir_path in all_subdirs:
        dir_name = os.path.basename(os.path.normpath(subdir_path))
        if not (dir_name and dir_name[0].isalpha()):
            print(f"-[SKIP] '{dir_name}': 알파벳으로 시작하지 않음")
            continue
        project_type = detect_project_type(subdir_path)
        if project_type:
            print(f"+[OK] '{dir_name}': {project_type.capitalize()} 프로젝트로 감지됨")
            projects_to_upload.append({'path': subdir_path, 'type': project_type, 'name': dir_name})
        else:
            print(f"-[SKIP] '{dir_name}': 지원하는 프로젝트 타입이 아님")

    if not projects_to_upload:
        print("\n🤔 조건에 맞는 프로젝트 디렉토리를 찾을 수 없습니다.")
        return

    original_directory = os.getcwd()
    print("\n>>> GitHub 업로드 작업을 시작합니다...")
    print("--------------------------------------------------")

    PREFIXES = {"react": "react-", "flask": "flask-", "streamlit": "streamlit-"}
    size_limit_bytes = SIZE_LIMIT_MB * 1024 * 1024

    for project in projects_to_upload:
        project_dir = project['path']
        project_name = project['name']
        project_type = project['type']
        
        prefix = PREFIXES.get(project_type, "unknown-")
        repo_name = f"{prefix}{project_name}"

        print(f">>> [시작] 프로젝트: {project_name} (타입: {project_type})")

        try:
            os.chdir(project_dir)

            if os.path.isdir(".git"):
                print("--- 💡 이미 Git 저장소입니다. 건너뜁니다.")
                print("--------------------------------------------------")
                continue
            
            print("--- Git safe.directory에 현재 폴더를 추가하여 소유권 문제를 방지합니다...")
            safe_dir_path = os.path.normpath(project_dir)
            run_command(['git', 'config', '--global', '--add', 'safe.directory', safe_dir_path])

            print(f"--- GitHub에 '{repo_name}' 비공개 저장소를 생성합니다...")
            gh_command = ["gh", "repo", "create", repo_name, VISIBILITY, "--description", f"Automated initial push for {project_name}"]
            run_command(gh_command)

            print("--- 로컬 Git 저장소를 초기화합니다...")
            run_command(["git", "init", "-b", "main"])

            remote_url = f"https://github.com/{GITHUB_USER}/{repo_name}.git"
            run_command(["git", "remote", "add", "origin", remote_url])
            
            print("--- 모든 파일을 추가합니다...")
            run_command(["git", "add", "."])
            
            # ✨ --- 추가될 파일 총 용량 확인 로직 ---
            print("--- 스테이징된 파일의 총 용량을 확인합니다...")
            staged_files_process = subprocess.run(['git', 'diff', '--cached', '--name-status'], capture_output=True, text=True)
            total_size = 0
            if staged_files_process.stdout:
                for line in staged_files_process.stdout.strip().split('\n'):
                    try:
                        status, file_path = line.split('\t')
                        if status.strip() in ['A', 'M'] and os.path.exists(file_path):
                            total_size += os.path.getsize(file_path)
                    except (ValueError, FileNotFoundError):
                        continue # 파일 이름에 탭이 있거나, race condition으로 파일이 사라진 경우 무시
            
            total_size_mb = total_size / (1024 * 1024)
            print(f"--- 총 용량: {total_size_mb:.2f} MB / {SIZE_LIMIT_MB} MB")
            
            if total_size > size_limit_bytes:
                print(f"--- ❌ 용량 초과: 이 프로젝트를 건너뛰고 스테이징된 파일들을 원상 복구합니다.")
                run_command(['git', 'reset'])
                print("--------------------------------------------------")
                continue
            # ------------------------------------

            sanitized_original_path = sanitize_path(project_dir)
            commit_message = f"feat: Initial commit from {sanitized_original_path}"
            
            print("--- 첫 커밋을 생성합니다...")
            status_result = subprocess.run(["git", "status", "--porcelain"], capture_output=True, text=True)
            if status_result.stdout:
                run_command(["git", "commit", "-m", commit_message])
            else:
                print("--- 😮 커밋할 변경사항이 없습니다. 빈 커밋을 생성합니다.")
                run_command(["git", "commit", "--allow-empty", "-m", commit_message])

            print("--- GitHub 저장소로 푸시합니다...")
            run_command(["git", "push", "-u", "origin", "main"])
            print(f"<<< [완료] 프로젝트: {project_name}")

        finally:
            os.chdir(original_directory)
            print("--------------------------------------------------")

    print("🎉 모든 작업이 성공적으로 완료되었습니다!")

if __name__ == "__main__":
    main()
## ✨ 주요 변경 사항
SIZE_LIMIT_MB 설정 추가: 스크립트 상단에 SIZE_LIMIT_MB = 90 변수를 추가했습니다. 이제 이 숫자만 바꾸면 용량 제한을 쉽게 조절할 수 있습니다.

용량 확인 로직 추가: git add . 명령이 실행된 직후, 커밋하기 전에 다음 로직이 실행됩니다.

git diff --cached --name-status 명령으로 스테이징(staging) 영역에 추가된 모든 파일 목록을 가져옵니다.

Python의 os.path.getsize를 이용해 각 파일의 용량을 더하여 총합을 계산합니다.

계산된 총용량이 SIZE_LIMIT_MB를 초과하면, 경고 메시지를 출력하고 git reset 명령으로 스테이징을 취소한 뒤, 해당 프로젝트의 나머지 과정을 건너뛰고 다음 프로젝트로 넘어갑니다.