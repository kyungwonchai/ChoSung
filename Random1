<script>
    const sensorNames = {{ sensor_names | tojson }}; // 서버에서 전달된 센서 이름 매핑

    let sensorActivationTimes = {}; // 각 IP별 센서 활성화 시작 시간을 저장
    let timerIntervals = {}; // 각 IP별 타이머 간격을 저장

    function fetchData() {
        fetch('/logsensors-data')
            .then(response => response.json())
            .then(data => {
                updateTable(data);
            })
            .catch(error => console.error('Error fetching data:', error));
    }

    function updateTable(data) {
        const tbody = document.querySelector('tbody');
        tbody.innerHTML = ''; // 기존 테이블 내용 초기화

        data.forEach(item => {
            const row = document.createElement('tr');
            row.setAttribute('data-ip', item.ip);

            row.innerHTML = `
                <td>${item.ip}</td>
                <td>
                    <div class="circle-container">
                        ${item.sensor1.split('').map((value, index) => {
                            return `<span class="circle ${value === '1' ? 'red' : 'green'}" data-ip="${item.ip}" data-index="${index}"></span>`;
                        }).join('')}
                    </div>
                </td>
                <td>${item.time1}</td>
                <td>${item.line}</td>
                <td class="duration-cell" data-ip="${item.ip}">Not active</td>
            `;

            tbody.appendChild(row);

            // 두 번째 센서에 대한 상태 추적 설정
            const secondSensor = row.querySelector('.circle-container .circle[data-index="1"]');
            if (secondSensor) {
                if (secondSensor.classList.contains('red')) {
                    if (!sensorActivationTimes[item.ip]) {
                        // 빨간색이지만 아직 기록이 시작되지 않은 경우
                        sensorActivationTimes[item.ip] = new Date();
                    }
                    // 빨간색 상태를 유지하면서 시간을 업데이트합니다.
                    startOrUpdateTimer(item.ip);
                } else {
                    // 녹색으로 돌아오면 시간 초기화
                    if (sensorActivationTimes[item.ip]) {
                        clearInterval(timerIntervals[item.ip]);
                        sensorActivationTimes[item.ip] = null;
                        const durationCell = row.querySelector(`.duration-cell[data-ip="${item.ip}"]`);
                        durationCell.textContent = 'Not active';
                    }
                }
            }
        });

        attachClickHandlers(); // 도형 클릭 이벤트 핸들러 추가
    }

    function attachClickHandlers() {
        const circles = document.querySelectorAll('.circle');
        circles.forEach(circle => {
            circle.addEventListener('click', event => {
                // 모든 도형의 크기 효과 제거
                circles.forEach(c => c.classList.remove('active'));

                // 클릭된 도형에 크기 효과 추가
                event.target.classList.add('active');

                // 텍스트 박스에 센서 정보 표시
                const ip = event.target.getAttribute('data-ip');
                const index = event.target.getAttribute('data-index');
                const sensorName = sensorNames[index] || 'Unknown Sensor';
                document.getElementById('sensorInfo').value = `IP: ${ip}, ${sensorName} (Position: ${index})`;
            });
        });
    }

    function startOrUpdateTimer(ip) {
        const durationCell = document.querySelector(`.duration-cell[data-ip="${ip}"]`);
        if (durationCell) {
            if (!timerIntervals[ip]) {
                // 타이머가 없을 때만 설정
                timerIntervals[ip] = setInterval(() => {
                    const startTime = sensorActivationTimes[ip];
                    if (startTime) {
                        const currentTime = new Date();
                        const duration = Math.floor((currentTime - startTime) / 1000);
                        durationCell.textContent = `${duration} seconds`;
                    }
                }, 1000);
            }
        }
    }

    document.addEventListener('DOMContentLoaded', () => {
        fetchData(); // 페이지 로드 시 데이터 가져오기
        setInterval(fetchData, 3000); // 3초마다 데이터 갱신
    });
</script>
