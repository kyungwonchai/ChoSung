죄송합니다. processfiles.txt 파일에 전체 경로가 포함되어 있고, 파일 이름이 프로세스 이름과 일치하는 경우, 해당 파일을 실행하거나 강제 종료하는 작업을 수행하도록 코드를 수정하겠습니다.

수정된 코드
아래는 WPF 애플리케이션에서 DispatcherTimer를 사용하여 processfiles.txt 파일에 명시된 각 파일의 프로세스 이름을 기반으로 실행 여부를 확인하고, 필요 시 실행 및 강제 종료를 처리하는 전체 코드입니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Linq;
using System.Windows;
using System.Windows.Threading;

namespace WpfProcessMonitor
{
    public partial class MainWindow : Window
    {
        private DispatcherTimer checkTimer;
        private DispatcherTimer forceRestartTimer;
        private string processListPath = @"c:\processfiles.txt";
        private const int MaxLogCount = 100;
        private List<string> logMessages = new List<string>();

        public MainWindow()
        {
            InitializeComponent();

            // 1분마다 프로세스 상태를 확인하기 위한 타이머 설정
            checkTimer = new DispatcherTimer();
            checkTimer.Interval = TimeSpan.FromMinutes(1);
            checkTimer.Tick += CheckProcesses;
            checkTimer.Start();

            // 1시간마다 프로세스를 강제 종료하고 재시작하기 위한 타이머 설정
            forceRestartTimer = new DispatcherTimer();
            forceRestartTimer.Interval = TimeSpan.FromHours(1);
            forceRestartTimer.Tick += ForceRestartProcesses;
            forceRestartTimer.Start();

            // 시작시 상태 확인
            CheckProcesses(null, null);
        }

        private void CheckProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processPaths = File.ReadAllLines(processListPath);

                    foreach (string processPath in processPaths)
                    {
                        string trimmedProcessPath = processPath.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessPath))
                            continue;

                        string processName = Path.GetFileNameWithoutExtension(trimmedProcessPath);
                        Process[] processes = Process.GetProcessesByName(processName);

                        if (processes.Length == 0)
                        {
                            // 프로세스가 실행 중이지 않으면 해당 경로의 파일을 실행
                            Process.Start(trimmedProcessPath);
                            LogMessage($"{processName}가 실행되지 않아 {trimmedProcessPath}를 실행했습니다.");
                        }
                        else
                        {
                            LogMessage($"{processName}가 이미 실행 중입니다.");
                        }
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void ForceRestartProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processPaths = File.ReadAllLines(processListPath);

                    foreach (string processPath in processPaths)
                    {
                        string trimmedProcessPath = processPath.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessPath))
                            continue;

                        string processName = Path.GetFileNameWithoutExtension(trimmedProcessPath);
                        Process[] processes = Process.GetProcessesByName(processName);

                        if (processes.Length > 0)
                        {
                            // 프로세스 강제 종료
                            foreach (Process proc in processes)
                            {
                                proc.Kill();
                                proc.WaitForExit();
                            }
                            LogMessage($"{processName}를 강제 종료했습니다.");
                        }

                        // 프로세스가 종료된 것을 확인한 후 다시 실행
                        Process.Start(trimmedProcessPath);
                        LogMessage($"{processName}를 {trimmedProcessPath} 경로에서 재실행했습니다.");
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() =>
            {
                // 로그 메시지를 추가하고, 최대 100개까지만 유지
                logMessages.Add($"{DateTime.Now}: {message}");

                if (logMessages.Count > MaxLogCount)
                {
                    logMessages.RemoveAt(0); // 가장 오래된 로그 삭제
                }

                // ListBox에 로그를 표시
                LogListBox.ItemsSource = null;
                LogListBox.ItemsSource = logMessages;
                LogListBox.ScrollIntoView(logMessages[logMessages.Count - 1]);
            });
        }
    }
}
MainWindow.xaml
xml
코드 복사
<Window x:Class="WpfProcessMonitor.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Process Monitor" Height="350" Width="525">
    <Grid>
        <ListBox Name="LogListBox"
                 VerticalScrollBarVisibility="Auto" 
                 HorizontalScrollBarVisibility="Auto"
                 Margin="10"/>
    </Grid>
</Window>
코드 설명:
프로세스 경로에서 이름 추출: processfiles.txt 파일에서 각 줄을 읽어, 해당 경로의 파일 이름에서 확장자를 제거한 것을 프로세스 이름으로 사용합니다. 예를 들어 C:\Program Files\Example\example.exe가 주어지면, 프로세스 이름은 example이 됩니다.

프로세스 상태 확인 및 실행: 프로세스가 실행 중이지 않은 경우 해당 경로에서 프로그램을 실행합니다.

강제 종료 및 재실행: 1시간마다 지정된 프로세스를 강제 종료한 후, 동일한 경로에서 다시 실행합니다.

로그 관리: 로그는 ListBox에 표시되며, 최대 100개의 로그만 유지되도록 관리합니다.

이 수정된 코드는 지정된 경로의 각 파일에 대해 프로세스 이름을 기반으로 모니터링 및 관리 작업을 수행합니다. 이를 통해, 사용자의 요구사항에 맞게 정확하게 프로세스를 제어할 수 있습