드래그 앤 드롭 구현 (커스텀 방식)
이 방식에서는 MouseDown으로 드래그를 시작하고, MouseMove 중에 드래그 상태를 유지하다가 MouseUp에서 항목을 최종 위치로 이동하는 방식을 사용합니다.

1. MainWindow.xaml - GridControl 설정
xml
코드 복사
<dxg:GridControl Name="taskGrid" ItemsSource="{Binding TaskManager.Tasks}" MouseDown="GridControl_MouseDown" MouseMove="GridControl_MouseMove" MouseUp="GridControl_MouseUp">
    <dxg:GridControl.View>
        <dxg:TableView AllowPerPixelScrolling="True" />
    </dxg:GridControl.View>
    <dxg:GridControl.Columns>
        <dxg:GridColumn FieldName="Priority" Header="순위" />
        <dxg:GridColumn FieldName="CreatedTime" Header="생성시간" />
        <dxg:GridColumn FieldName="UpdateCount" Header="수정횟수" />
        <dxg:GridColumn FieldName="LastUpdateTime" Header="수정시간" />
        <dxg:GridColumn FieldName="FolderPath" Header="폴더 경로" />
        <dxg:GridColumn FieldName="CellColor" Header="셀 색상">
            <dxg:GridColumn.CellTemplate>
                <DataTemplate>
                    <Border Background="{Binding CellColor}" />
                </DataTemplate>
            </dxg:GridColumn.CellTemplate>
        </dxg:GridColumn>
        <dxg:GridColumn FieldName="Assignee" Header="담당자" />
        <dxg:GridColumn FieldName="IsCompleted" Header="완료 여부" />
    </dxg:GridControl.Columns>
</dxg:GridControl>
2. MainWindow.xaml.cs - 드래그 앤 드롭 이벤트 핸들러
드래그 앤 드롭을 수동으로 구현하기 위해 MouseDown, MouseMove, MouseUp 이벤트를 활용합니다.

csharp
코드 복사
using System.Windows;
using System.Windows.Input;
using DevExpress.Xpf.Grid;
using SwiftAIMaster.ViewModels;
using SwiftAIMaster.Models;

namespace SwiftAIMaster.Views
{
    public partial class MainWindow : Window
    {
        private MainViewModel ViewModel => (MainViewModel)DataContext;
        
        private bool isDragging = false;      // 드래그 상태 플래그
        private int sourceIndex = -1;         // 드래그 시작 인덱스

        public MainWindow()
        {
            InitializeComponent();
        }

        // 드래그 시작: 항목을 클릭할 때 시작 인덱스를 저장
        private void GridControl_MouseDown(object sender, MouseButtonEventArgs e)
        {
            var rowHandle = taskGrid.View.GetRowHandleByMouseEventArgs(e);
            if (rowHandle >= 0)
            {
                isDragging = true;
                sourceIndex = rowHandle;
            }
        }

        // 드래그 중: 마우스를 이동하면 드래그 상태 유지
        private void GridControl_MouseMove(object sender, MouseEventArgs e)
        {
            if (isDragging && e.LeftButton == MouseButtonState.Pressed)
            {
                // 드래그 상태 유지
            }
        }

        // 드래그 완료: 항목을 놓을 위치로 이동하고 순위 업데이트
        private void GridControl_MouseUp(object sender, MouseButtonEventArgs e)
        {
            if (isDragging)
            {
                var targetIndex = taskGrid.View.GetRowHandleByMouseEventArgs(e);

                if (targetIndex >= 0 && targetIndex != sourceIndex)
                {
                    // 드래그한 항목을 새로운 위치로 이동
                    var task = ViewModel.TaskManager.Tasks[sourceIndex];
                    ViewModel.TaskManager.Tasks.RemoveAt(sourceIndex);
                    ViewModel.TaskManager.Tasks.Insert(targetIndex, task);

                    // 순위 업데이트
                    ViewModel.TaskManager.UpdateTaskPriorities();
                }

                // 드래그 상태 초기화
                isDragging = false;
                sourceIndex = -1;
            }
        }
    }
}
3. TaskManager.cs - 순위 업데이트 메서드 수정
드래그 앤 드롭 이후에 작업 순위를 데이터베이스에 반영하기 위해 UpdateTaskPriorities 메서드를 수정합니다.

csharp
코드 복사
public void UpdateTaskPriorities()
{
    for (int i = 0; i < Tasks.Count; i++)
    {
        var task = Tasks[i];
        task.Priority = i + 1;
        _databaseService.UpdateTaskPriority(task.Id, task.Priority); // 데이터베이스에 새로운 순위 저장
    }
}
설명
MouseDown 이벤트: MouseDown 이벤트에서 드래그가 시작될 때 sourceIndex를 설정하여 드래그 시작 인덱스를 저장합니다.
MouseMove 이벤트: MouseMove에서는 드래그 상태를 유지하고, 실시간 이동을 감지할 수 있습니다.
MouseUp 이벤트: 마우스 버튼을 놓을 때(MouseUp) 드래그가 끝난 위치로 항목을 이동시키고 UpdateTaskPriorities를 호출하