현재 작업이 끝나면 다음 작업이 자동으로 시작되는 로직은 ProcessQueueAsync() 함수 내에서 처리되고 있습니다. 이 함수는 큐에서 작업을 하나씩 순차적으로 꺼내서 처리하며, 현재 작업이 끝나면 큐에 남아 있는 다음 작업을 바로 처리합니다.

아래에서 설명하겠습니다.

ProcessQueueAsync() 함수의 동작 원리
csharp
코드 복사
private async Task ProcessQueueAsync()
{
    _isProcessingTask = true; // 현재 작업을 처리 중임을 나타내는 플래그

    // 큐에 남아있는 작업이 있을 때까지 계속 처리
    while (_taskQueue.TryDequeue(out (string taskType, ProductOrderModel order) task))
    {
        _taskList.Add($"처리 중: {task.taskType}: {task.order.ProductOrder}"); // 작업 시작 로그

        // 작업의 종류에 따라 처리 (적재 또는 배출)
        if (task.taskType == "적재")
        {
            await ProcessStackAsync(task.order); // 적재 작업 처리
        }
        else if (task.taskType == "배출")
        {
            await ProcessOutAsync(task.order); // 배출 작업 처리
        }

        // 완료된 작업을 리스트에서 삭제
        _taskList.Remove($"처리 중: {task.taskType}: {task.order.ProductOrder}");

        // 작업이 끝나면 주문의 상태를 업데이트 (out 또는 stack)
        task.order.POStatus = task.taskType == "적재" ? "stack" : "out";
    }

    _isProcessingTask = false; // 모든 작업 처리가 끝나면 플래그 초기화
}
동작 설명:
while (_taskQueue.TryDequeue(...)):

이 부분이 큐에 남아 있는 작업을 하나씩 꺼내서 처리하는 부분입니다.
**_taskQueue.TryDequeue()**는 큐에 있는 작업을 하나씩 꺼내오며, 작업이 있을 때는 **true**를 반환합니다.
작업이 없으면 false를 반환하여 루프가 종료됩니다.
비동기 작업 처리:

await ProcessStackAsync(task.order) 및 **await ProcessOutAsync(task.order)**를 통해 작업을 비동기적으로 처리합니다. 이 부분이 끝나면 그다음 큐에 남아 있는 작업을 계속해서 처리합니다.
즉, 하나의 작업이 끝나면 다음 작업을 큐에서 꺼내 바로 처리합니다.
작업 완료 후 상태 업데이트:

작업이 완료되면, POStatus를 "stack" 또는 "out"으로 변경하고, UI를 갱신합니다.
이 작업이 끝난 후 다시 큐에서 다음 작업을 꺼내 처리합니다.
큐에서 작업이 순차적으로 처리되는 구조 요약:
EnqueueTask()에서 작업을 큐에 추가: 작업이 추가되면 자동으로 ProcessQueueAsync()가 실행됩니다.

큐에 추가된 작업은 _taskQueue.Enqueue()를 통해 순서대로 들어갑니다.
ProcessQueueAsync()에서 큐의 작업을 처리:

큐에서 작업을 하나씩 순차적으로 꺼내 적재 또는 배출 작업을 처리합니다.
작업이 비동기적으로 완료되면, 다음 작업을 자동으로 처리합니다.
모든 작업이 완료되면 루프 종료:

큐가 비어 있을 경우 더 이상 처리할 작업이 없으면 루프가 종료되고, 작업이 완료되었음을 표시합니다.
_isProcessingTask = false;를 통해 더 이상 작업이 진행 중이 아님을 나타냅니다.
예시 흐름:
적재 작업이 들어오면:

EnqueueTask("적재", productOrder)로 큐에 작업이 추가됨.
ProcessQueueAsync()가 실행되어 적재 작업을 처리함.
적재 작업이 끝나면 큐에서 다음 작업을 처리함.
배출 작업이 들어오면:

EnqueueTask("배출", productOrder)로 큐에 작업이 추가됨.
배출 작업이 적재 작업 후에 큐에 쌓여 있으면, 적재 작업이 끝난 후 배출 작업이 바로 처리됨.
다시 말해:
작업을 큐에 넣으면 자동으로 작업 처리 루프가 시작됩니다.
현재 작업이 끝나면 다음 작업이 바로 실행되며, 큐가 비어있지 않는 한 계속해서 순차적으로 작업을 처리합니다.
이제 작업이 완료되면 자동으로 큐에서 다음 작업을 처리하는 구조가 작동 원리와 함께 명확히 설명되었