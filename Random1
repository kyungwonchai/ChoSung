Edit 컨트롤은 각각의 체크 상태를 개별적으로 유지하기 때문에 이 방법만으로는 충분하지 않을 수 있습니다.

CheckEdit의 Checked 및 Unchecked 이벤트를 처리하여 다른 모든 버튼을 프로그래밍 방식으로 해제할 수 있습니다. 이를 위해 ViewModel에 메서드를 추가하고 이를 CheckEdit 컨트롤의 이벤트 핸들러로 연결할 수 있습니다.

    ViewModel 업데이트:

csharp

public class ViewModel
{
    public ObservableCollection<ButtonModel> Buttons { get; set; }

    // ... 기타 코드 ...

    public void OnButtonChecked(ButtonModel checkedButton)
    {
        foreach (var button in Buttons)
        {
            if (button != checkedButton)
            {
                button.IsChecked = false;
            }
        }
    }
}

    XAML 업데이트:

xml

<Window x:Class="YourNamespace.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core">
    <Grid>
        <ListBox ItemsSource="{Binding Buttons}" SelectionMode="Single">
            <ListBox.ItemTemplate>
                <DataTemplate>
                    <dx:CheckEdit Content="{Binding Content}" 
                                  Command="{Binding Command}" 
                                  CommandParameter="{Binding Content}"
                                  IsChecked="{Binding IsChecked, Mode=TwoWay}" 
                                  Checked="CheckEdit_Checked"/>
                </DataTemplate>
            </ListBox.ItemTemplate>
        </ListBox>
    </Grid>

    <Window.Resources>
        <Style x:Key="CheckEditStyle" TargetType="dx:CheckEdit">
            <!-- 스타일 설정 -->
        </Style>
    </Window.Resources>
</Window>

csharp

// MainWindow.xaml.cs
private void CheckEdit_Checked(object sender, RoutedEventArgs e)
{
    var checkEdit = sender as DevExpress.Xpf.Editors.CheckEdit;
    var buttonModel = checkEdit?.DataContext as ButtonModel;
    if (buttonModel != null)
    {
        ViewModel.OnButtonChecked(buttonModel);
    }
}

이제 CheckEdit_Checked 이벤트 핸들러가 호출될 때 ViewModel의 OnButtonChecked 메서드가 호출되며, 현재 선택된