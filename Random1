말 죄송합니다. 문제가 해결되지 않아 많이 답답하실 것 같습니다. 이제부터는 문제를 해결하는 데 필요한 정확한 디버깅 방법과 코드를 제공합니다. 발생한 JSONException 문제를 해결하기 위해 더욱 구체적인 단계를 살펴보겠습니다.

1. 디버깅 중 문제 파악
우선, JSONException이 발생한 위치를 정확히 파악하고 문제의 원인을 알아보겠습니다. 디버깅 메시지를 사용해 responseData가 정확히 어떻게 생겼는지 확인합니다.

2. 코틀린 앱에서 디버깅
다음은 Android 앱에서 네트워크 응답을 처리하는 부분을 수정하여 더 나은 디버깅을 제공하는 예시 코드입니다. 이 코드는 서버에서 받은 응답 데이터를 정확히 확인하고, JSON 파싱을 시도하기 전에 데이터의 상태를 확인합니다.

kotlin
코드 복사
import android.content.Context
import android.content.Intent
import android.net.Uri
import android.os.Bundle
import android.util.Log
import androidx.appcompat.app.AppCompatActivity
import androidx.core.content.FileProvider
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import okhttp3.OkHttpClient
import okhttp3.Request
import org.json.JSONObject
import java.io.File
import java.io.FileOutputStream
import java.io.IOException

class MainActivity : AppCompatActivity() {

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // 네트워크 작업을 비동기로 실행
        CoroutineScope(Dispatchers.IO).launch {
            checkForUpdates(this@MainActivity, "apk1")
        }
    }

    private suspend fun checkForUpdates(context: Context, apkName: String) {
        Log.d("TTTTT", "Starting checkForUpdates for $apkName")

        val client = OkHttpClient()
        val request = Request.Builder()
            .url("http://10.244.122.222:8116/api/$apkName/version")
            .build()

        try {
            val response = client.newCall(request).execute()

            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code: ${response.code}")
                return
            }

            val responseData = response.body?.string()
            Log.d("TTTTT", "Received response: $responseData")

            // JSON 파싱 전 응답 데이터가 정확한지 확인
            if (responseData != null && responseData.startsWith("{") && responseData.endsWith("}")) {
                try {
                    val jsonObject = JSONObject(responseData)
                    val latestVersion = jsonObject.getString("version")
                    val apkUrl = jsonObject.getString("apk_url")
                    Log.d("TTTTT", "Parsed version: $latestVersion, apk_url: $apkUrl")

                    // APK 다운로드 및 설치 로직
                    downloadAndInstallApk(context, apkUrl, apkName)
                } catch (e: JSONException) {
                    Log.e("TTTTT", "Failed to parse JSON: $responseData", e)
                }
            } else {
                Log.e("TTTTT", "Response is not a valid JSON: $responseData")
            }
        } catch (e: Exception) {
            Log.e("TTTTT", "Error during checkForUpdates: ${e.message}", e)
        }
    }

    private suspend fun downloadAndInstallApk(context: Context, apkUrl: String, apkName: String) {
        Log.d("TTTTT", "Starting download for $apkName from $apkUrl")

        val client = OkHttpClient()
        val request = Request.Builder().url("http://10.244.122.222:8116$apkUrl").build()

        try {
            val response = client.newCall(request).execute()
            if (!response.isSuccessful) {
                Log.e("TTTTT", "Unexpected response code during download: ${response.code}")
                return
            }

            val apkFile = File(context.getExternalFilesDir(null), "$apkName.apk")
            FileOutputStream(apkFile).use { fos ->
                fos.write(response.body?.bytes())
                Log.d("TTTTT", "APK file downloaded successfully to ${apkFile.absolutePath}")
            }

            val apkUri: Uri = FileProvider.getUriForFile(
                context,
                context.applicationContext.packageName + ".provider",
                apkFile
            )

            withContext(Dispatchers.Main) {
                val intent = Intent(Intent.ACTION_VIEW).apply {
                    flags = Intent.FLAG_ACTIVITY_NEW_TASK or Intent.FLAG_GRANT_READ_URI_PERMISSION
                    setDataAndType(apkUri, "application/vnd.android.package-archive")
                }
                context.startActivity(intent)
                Log.d("TTTTT", "APK installation initiated for $apkName")
            }

        } catch (e: Exception) {
            Log.e("TTTTT", "Error during downloadAndInstallApk: ${e.message}", e)
        }
    }
}
주요 디버깅 지점
responseData 확인:

responseData를 로그로 출력하여 서버에서 전달된 데이터가 실제로 어떤 상태인지 확인합니다. 이 데이터가 JSON 형식인지 확인하세요.
JSON 파싱 전 확인:

JSON 파싱을 시도하기 전에 데이터가 JSON 형식인지 확인하는 검사를 추가했습니다. startsWith("{")와 endsWith("}") 조건을 통해 데이터가 JSON 객체일 가능성이 높은지 검사합니다.
예외 처리:

JSONException이 발생할 때, 그 이유를 로그에 명확히 기록합니다. 이 정보를 통해 어떤 부분에서 문제가 발생했는지 파악할 수 있습니다.
응답 상태 코드 확인:

서버가 200번대의 정상적인 상태 코드를 반환하는지 확인합니다. 그렇지 않으면, 그 이유를 로그에 기록합니다.
결론
이제 responseData와 JSON 파싱 과정에서 발생할 수 있는 문제를 보다 정확하게 진단할 수 있습니다. 이 코드를 실행하고 로그에서 TTTTT 태그로 필터링하여 문제의 원인을 파악한 후, 추가적인 조치가 필요하다면 그에 따라 대응할 수 있습니다.

다시 한번 불편을 끼쳐드려 죄송합니다. 이제 이 문제를 해결하는 데 있어 더 큰 도움이 되길 바랍니다. 문제가 계속된다면, 다시 자세히 알려주시면 추가적으로 도와드리겠습니다