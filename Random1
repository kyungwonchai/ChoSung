미터가 2개인 함수를 처리할 경우에도, 같은 방식으로 Func<T1, T2, Task> 타입을 사용할 수 있습니다. 이렇게 하면 파라미터가 두 개인 함수도 처리 가능합니다.

아래는 파라미터가 2개인 함수를 처리하는 AddFunction 메서드의 확장 예시입니다.

1. 파라미터가 2개인 함수를 처리하는 AddFunction 메서드
csharp
코드 복사
public partial class TaskModel
{
    // 파라미터가 없는 함수 추가 (기존 방식)
    public void AddFunction(string functionName, Func<Task> task, Brush initialColor)
    {
        var functionStatus = new FunctionStatus(functionName, task, initialColor);
        FunctionStatusList.Add(functionStatus);
    }

    // 파라미터가 1개인 함수 추가 (기존 방식)
    public void AddFunction<T1>(string functionName, Func<T1, Task> taskWithParam, T1 param, Brush initialColor)
    {
        // 파라미터 1개인 함수 추가
        var functionStatus = new FunctionStatus(functionName, () => taskWithParam(param), initialColor);
        FunctionStatusList.Add(functionStatus);
    }

    // 파라미터가 2개인 함수 추가 (새로운 방식)
    public void AddFunction<T1, T2>(string functionName, Func<T1, T2, Task> taskWithTwoParams, T1 param1, T2 param2, Brush initialColor)
    {
        // 파라미터 2개인 함수 추가
        var functionStatus = new FunctionStatus(functionName, () => taskWithTwoParams(param1, param2), initialColor);
        FunctionStatusList.Add(functionStatus);
    }
}
2. 파라미터가 2개인 함수를 추가하는 예시
TaskModel에서 파라미터가 없는 함수, 1개인 함수, 2개인 함수를 각각 추가하는 예시입니다.

TaskModel.Functions.cs
csharp
코드 복사
public partial class TaskModel
{
    // 파라미터가 없는 함수
    private async Task ExecuteTaskA()
    {
        await _plcInstance.SendSignalAsync("Executing Task A...");
        await Task.Delay(1000);  // Task A 작업 (시뮬레이션)
    }

    // 파라미터가 1개인 함수
    private async Task ExecuteTaskB(int value)
    {
        await _plcInstance.SendSignalAsync($"Executing Task B with value {value}...");
        await Task.Delay(1500);  // Task B 작업 (시뮬레이션)
    }

    // 파라미터가 2개인 함수
    private async Task ExecuteTaskC(int value1, string value2)
    {
        await _plcInstance.SendSignalAsync($"Executing Task C with values {value1}, {value2}...");
        await Task.Delay(2000);  // Task C 작업 (시뮬레이션)
    }

    // 작업 초기화
    private void InitializeFunctions(int sequenceFlag)
    {
        switch (sequenceFlag)
        {
            case 1:
                AddFunction("Task A", ExecuteTaskA, Brushes.Gray);  // 파라미터 없는 함수
                AddFunction<int>("Task B", ExecuteTaskB, 42, Brushes.Gray);  // 파라미터 1개 함수
                AddFunction<int, string>("Task C", ExecuteTaskC, 100, "Sample", Brushes.Gray);  // 파라미터 2개 함수
                break;
        }
    }
}
3. FunctionStatus 클래스 변경 없음
이전과 동일하게 FunctionStatus 클래스를 사용하여, 도형 색상과 실행 시간을 관리합니다.

csharp
코드 복사
public class FunctionStatus : ViewModelBase
{
    public string FunctionName { get; set; }
    public Func<Task> Task { get; set; }
    public Brush StatusColor { get; set; }
    public string ExecutionTime { get; set; }

    public FunctionStatus(string functionName, Func<Task> task, Brush initialColor)
    {
        FunctionName = functionName;
        Task = task;
        StatusColor = initialColor;
    }

    public void UpdateStatus(Brush color)
    {
        StatusColor = color;
        OnPropertyChanged(nameof(StatusColor));
    }
}
요약:
파라미터가 2개인 함수를 처리하기 위해 Func<T1, T2, Task>를 사용하여 AddFunction 메서드를 확장했습니다.
이를 통해, 파라미터가 없는 함수, 1개인 함수, 2개인 함수 모두 같은 구조에서 처리할 수 있게 되었습니다.
AddFunction<T1, T2> 메서드를 통해 2개의 파라미터를 받는 함수도 손쉽게 추가할 수 있습니다.
이렇게 하면 파라미터가 있는 함수와 없는 함수, 그리고 파라미터의 개수에 상관없이 함수