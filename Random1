네, websockets 라이브러리의 최신 버전(현재 기준 12.0) 스타일에 맞게 코드를 더 간결하고 현대적으로 수정해 드릴게요.

가장 큰 차이점은 async with websockets.connect(URI) as websocket: 구문이 async with websockets.unix_connect(), websockets.client.connect() 와 같이 명시적인 함수로 변경된 점이지만, 기존의 websockets.connect()도 호환성을 위해 계속 사용 가능합니다.

최신 스타일과 모범 사례를 반영하여 코드를 더 깔끔하게 다듬었습니다. 이전 코드와 기능은 100% 동일합니다.

최신 버전 스타일 반영 코드 (websocket_test_modern.py)
아래 코드를 파일 하나로 저장하고 이전과 동일하게 실행하시면 됩니다.

Python

import asyncio
import websockets
import json
import logging
import sys
from websockets.client import connect as websocket_connect
from websockets.exceptions import WebSocketException

# --- 설정 부분 ---

# 1. 여기에 실제 서버 주소를 입력하세요.
# TARGET_WEBSITE_URL = "ws://10.55.111.111:8888/ABCC"
TARGET_WEBSOCKET_URL = "ws://echo.websocket.events/" # 공개 테스트 서버

# 2. 대괄호 안에 보낼 메시지 사양을 JSON 형식으로 입력하세요.
MESSAGE_SPEC = {
    "command": "REGISTER",
    "transactionId": f"CLIENT-001-{int(asyncio.get_event_loop().time())}", # 매번 다른 ID 생성
    "payload": {
        "deviceName": "ModernTestDevice",
        "deviceType": "SENSOR_V2"
    }
}
# --- 설정 끝 ---


# 더 보기 좋은 형식의 로거 설정
logging.basicConfig(
    level=logging.INFO,
    format='[%(asctime)s] [%(levelname)s] %(message)s',
    datefmt='%Y-%m-%d %H:%M:%S'
)

async def run_websocket_test():
    """웹소켓 서버에 연결하고 메시지를 보내고 응답을 받는 최신 스타일의 테스트 함수"""
    
    # 서버에서 요구한 최종 메시지 형식: [{ ... }]
    message_to_send = [MESSAGE_SPEC]
    
    logging.info(f"지정한 서버에 연결을 시도합니다: {TARGET_WEBSOCKET_URL}")

    try:
        # 최신 스타일에서는 connect 함수를 명시적으로 임포트하여 사용합니다.
        async with websocket_connect(TARGET_WEBSOCKET_URL) as websocket:
            logging.info("✅ 서버에 성공적으로 연결되었습니다.")
            
            json_message = json.dumps(message_to_send, indent=2)
            logging.info(f"📤 서버로 다음 메시지를 전송합니다:\n{json_message}")
            await websocket.send(json_message)
            
            logging.info("👂 서버로부터 응답을 기다리는 중...")
            response = await websocket.recv()
            
            try:
                parsed_response = json.loads(response)
                logging.info(f"📥 서버로부터 JSON 응답을 수신했습니다:\n{json.dumps(parsed_response, indent=2)}")
            except json.JSONDecodeError:
                logging.info(f"📥 서버로부터 텍스트 응답을 수신했습니다: {response}")

    # 최신 버전에 맞춰 예외 처리 방식을 더 명확하게 수정
    except WebSocketException as e:
        logging.error(f"❌ 웹소켓 통신 중 오류가 발생했습니다: {type(e).__name__} - {e}")
    except ConnectionRefusedError:
        logging.error("❌ 서버가 연결을 거부했습니다. 서버가 실행 중인지, 주소와 포트를 확인하세요.")
    except Exception as e:
        logging.error(f"💥 예상치 못한 오류가 발생했습니다: {type(e).__name__} - {e}")
    finally:
        logging.info("👋 테스트 스크립트를 종료합니다.")


async def main():
    """스크립트의 메인 진입점"""
    # 라이브러리 설치 여부 확인
    try:
        import websockets
    except ImportError:
        print("="*60)
        print("🛑 'websockets' 라이브러리가 설치되지 않았습니다.")
        print("터미널에 아래 명령어를 입력하여 설치해주세요:")
        print(f"{sys.executable} -m pip install websockets")
        print("="*60)
        return

    await run_websocket_test()

if __name__ == "__main__":
    asyncio.run(main())
이전 코드와 달라진 점
명시적인 connect 함수 사용:

from websockets.client import connect as websocket_connect 처럼 클라이언트용 connect 함수를 명확하게 가져와서 사용했습니다. 이는 코드를 읽을 때 "이것이 클라이언트 연결 부분이구나"라고 더 쉽게 이해하게 도와줍니다.

구체적인 예외 처리:

websockets.exceptions.ConnectionClosedError 같은 개별적인 예외 대신, websockets 라이브러리에서 발생하는 대부분의 예외를 포괄하는 WebSocketException 을 사용하여 예외 처리 블록을 더 간결하게 만들었습니다.

진입점 함수(main) 분리:

if __name__ == "__main__": 부분에 있던 로직을 main 함수로 분리하여 코드 구조를 더 깔끔하게 정리했습니다.

pip 설치 명령어 개선:

사용자의 파이썬 환경이 여러 개일 경우를 대비하여, 현재 스크립트를 실행하는 파이썬 환경에 정확히 라이브러리를 설치하도록 sys.executable -m pip ... 방식으로 안내 문구를 수정했습니다.