, "허용 아이피가 아니어서 접근 거부 (403 에러)" 메시지가 표시되고, 사용자님의 PC IP가 10.22.22.22인데도 접속이 안 되는 상황이군요. 이 문제는 Flask 애플리케이션의 app/auth.py 파일에 있는 IP 기반 접근 제어 로직이 현재 접속하신 IP(10.22.22.22)를 관리자 또는 허용된 사용자로 인식하지 못했기 때문에 발생합니다.

이전에 제공해 드린 app/auth.py의 get_current_user_role() 함수는 데이터베이스의 admin_ips 테이블과 allowed_user_ips 테이블을 조회하여 역할을 결정합니다. 만약 이 테이블들에 해당 IP가 등록되어 있지 않다면 'guest'로 처리되어 접근이 거부될 수 있습니다.

가장 가능성이 높은 원인:

데이터베이스 admin_ips 테이블에 10.22.22.22 IP가 등록되지 않음: 웹 UI를 통해 관리자 IP를 추가하기 전이라면, 데이터베이스에 직접 첫 관리자 IP를 등록해야 합니다.
Flask가 인식하는 IP 주소 불일치: 매우 드물지만, 네트워크 구성(예: 프록시 서버)으로 인해 Flask 애플리케이션이 인식하는 클라이언트 IP 주소가 사용자님이 생각하는 10.22.22.22와 다를 수 있습니다.
해결 방안:

1단계: Flask가 실제로 어떤 IP를 감지하는지 확인하고, config.py의 ADMIN_IPS 목록을 우선적으로 사용하도록 auth.py 수정

config.py에 있는 ADMIN_IPS 리스트를 초기 관리자 IP 목록으로 사용하고, 그 이후에 DB를 확인하도록 get_current_user_role() 함수를 수정하면 초기 설정에 도움이 될 수 있습니다. 또한, Flask가 감지하는 IP를 로그로 남겨 확인합니다.

수정: app/auth.py (전체 코드)

Python

# scontrol_flask_web/app/auth.py
from functools import wraps
from flask import request, current_app, abort, g
from .db_utils import get_db_connection # pymssql 연결을 위한 함수 임포트

def get_current_user_role():
    if hasattr(g, 'current_user_role'):
        return g.current_user_role

    user_ip = None
    if request.headers.getlist("X-Forwarded-For"):
        user_ip = request.headers.getlist("X-Forwarded-For")[0].split(',')[0].strip()
    else:
        user_ip = request.remote_addr
    
    # Flask가 감지한 IP 로깅 (중요!)
    current_app.logger.info(f"AUTH: 현재 접속 시도 IP 주소: {user_ip}")
    g.user_ip = user_ip
    
    # 1. config.py의 ADMIN_IPS 목록에서 먼저 확인 (초기 부트스트랩 또는 고정 관리자용)
    # config.py에 ADMIN_IPS = ['10.22.22.22', '127.0.0.1'] 와 같이 정의되어 있어야 함
    if user_ip in current_app.config.get('ADMIN_IPS', []):
        g.current_user_role = 'admin'
        current_app.logger.info(f"AUTH: IP {user_ip}는 config.py의 ADMIN_IPS 목록에 포함되어 'admin' 역할을 부여받았습니다.")
        return 'admin'

    # 2. 데이터베이스의 admin_ips 테이블에서 확인
    conn = None
    try:
        conn = get_db_connection()
        if conn: # DB 연결 성공 시에만 조회
            with conn.cursor() as cursor:
                sql_admin_check = "SELECT ip_address FROM dbo.admin_ips WHERE ip_address = %s"
                cursor.execute(sql_admin_check, (user_ip,))
                admin_entry = cursor.fetchone()
                if admin_entry:
                    g.current_user_role = 'admin'
                    current_app.logger.info(f"AUTH: IP {user_ip}는 DB의 admin_ips 테이블에 포함되어 'admin' 역할을 부여받았습니다.")
                    return 'admin'

                # 3. 데이터베이스의 allowed_user_ips 테이블에서 확인
                sql_user_check = "SELECT ip_address FROM dbo.allowed_user_ips WHERE ip_address = %s"
                cursor.execute(sql_user_check, (user_ip,))
                allowed_user_entry = cursor.fetchone()
                if allowed_user_entry:
                    g.current_user_role = 'user'
                    current_app.logger.info(f"AUTH: IP {user_ip}는 DB의 allowed_user_ips 테이블에 포함되어 'user' 역할을 부여받았습니다.")
                    return 'user'
        else: # DB 연결 실패 시
             current_app.logger.error(f"AUTH: DB 연결 실패. IP {user_ip}에 대한 DB 기반 역할 확인 불가.")
             # DB 연결 실패 시 어떻게 처리할지 정책 결정 필요 (예: 'guest' 또는 접근 완전 차단)
             # 여기서는 config.py의 ADMIN_IPS 확인 후 DB가 안되면 guest로 처리
    except Exception as e:
        current_app.logger.error(f"AUTH: IP 역할 확인 중 DB 오류 발생: {e}", exc_info=True)
    
    current_app.logger.info(f"AUTH: IP {user_ip}는 허용 목록에 없어 'guest' 역할이 부여됩니다.")
    g.current_user_role = 'guest' # 최종적으로 guest
    return 'guest'


def ip_auth_required(role_required=None):
    def decorator(f):
        @wraps(f)
        def decorated_function(*args, **kwargs):
            user_role = get_current_user_role() # 이 함수는 이제 g.user_ip를 설정함
            
            # g.user_ip가 설정되었으므로 로깅에 사용 가능
            client_ip_for_log = getattr(g, 'user_ip', 'IP 확인 불가')

            if role_required == 'admin' and user_role != 'admin':
                current_app.logger.warning(f"접근 거부 (관리자 필요): IP {client_ip_for_log} -> {request.path}")
                abort(403)
            elif role_required == 'user' and user_role not in ['admin', 'user']:
                current_app.logger.warning(f"접근 거부 (사용자 필요): IP {client_ip_for_log} -> {request.path}")
                abort(403)
            elif role_required is None and user_role not in ['admin', 'user']: # 단순 접속 가능 여부 ('guest' 제외)
                current_app.logger.warning(f"접근 거부 (허용 IP 아님): IP {client_ip_for_log} -> {request.path}")
                abort(403)
            
            return f(*args, **kwargs)
        return decorated_function
    return decorator


def inject_user_info_to_templates():
    current_role = get_current_user_role() 
    return dict(
        current_user_ip=getattr(g, 'user_ip', 'IP 확인 불가'), 
        current_user_role=current_role
    )
app/auth.py 주요 변경 사항:

Flask가 감지하는 IP 로깅: get_current_user_role() 함수 시작 부분에 current_app.logger.info(f"AUTH: 현재 접속 시도 IP 주소: {user_ip}") 라인을 추가했습니다. Flask 개발 서버를 실행하고 페이지에 접속하려고 할 때, 터미널 로그에 어떤 IP가 기록되는지 확인해주세요. 이 IP가 10.22.22.22가 맞는지, 아니면 (예를 들어 프록시나 Docker 환경 등으로 인해) 다른 IP로 표시되는지 확인하는 것이 매우 중요합니다.
config.py의 ADMIN_IPS 우선 확인: 데이터베이스를 조회하기 전에, config.py 파일의 ADMIN_IPS 리스트에 현재 접속한 user_ip가 있는지 먼저 확인합니다. 여기에 IP가 있다면 바로 'admin' 역할을 부여합니다. 이렇게 하면 데이터베이스에 관리자 IP를 수동으로 넣기 전에도 초기 관리자 접속이 가능해집니다.
2단계: config.py 파일의 ADMIN_IPS 목록 확인 및 수정

scontrol_flask_web/config.py 파일을 열고, ADMIN_IPS 리스트에 사용자님의 PC IP 주소 (10.22.22.22)가 정확히 포함되어 있는지 확인하고, 없다면 추가해주세요.

Python

# scontrol_flask_web/config.py
# ... (다른 설정은 동일) ...

class Config:
    # ... (SECRET_KEY, DB 설정 등은 동일) ...

    ADMIN_IPS = [
        '127.0.0.1',    # 로컬호스트 IPv4 (개발/테스트용)
        '::1',          # 로컬호스트 IPv6 (개발/테스트용)
        '10.22.22.22',  # <<--- 사용자님의 PC IP 주소를 여기에 추가 (또는 기존 값 확인)
        # '다른 관리자 IP가 있다면 여기에 추가',
    ]
    # ...
3. 데이터베이스 admin_ips 테이블 확인 및 데이터 추가 (필요시)

만약 config.py의 ADMIN_IPS 목록을 사용하지 않고 전적으로 DB로만 관리하고 싶다면 (또는 config.py에 추가했음에도 문제가 지속된다면), MSSQL 데이터베이스의 dbo.admin_ips 테이블에 10.22.22.22 IP가 직접 등록되어 있는지 확인해야 합니다.

SQL Server Management Studio (SSMS)에서 다음 쿼리를 실행하여 확인하고, 없다면 추가합니다:

SQL

USE SControlFlaskDB; -- 실제 데이터베이스 이름으로 변경

-- 1. 현재 admin_ips 테이블 내용 확인
SELECT * FROM dbo.admin_ips;

-- 2. 만약 10.22.22.22 IP가 없다면 추가 (이미 있다면 실행 안 함)
IF NOT EXISTS (SELECT 1 FROM dbo.admin_ips WHERE ip_address = '10.22.22.22')
BEGIN
    INSERT INTO dbo.admin_ips (ip_address, description)
    VALUES ('10.22.22.22', '주 관리자 PC (수동 추가)');
    PRINT '관리자 IP 10.22.22.22 추가 완료.';
END
ELSE
BEGIN
    PRINT '관리자 IP 10.22.22.22 이미 존재함.';
END
조치 순서:

먼저 위 app/auth.py와 config.py 코드를 프로젝트에 적용합니다.
Flask 개발 서버를 재시작합니다.
웹 브라우저로 접속을 시도합니다.
Flask 개발 서버의 터미널 로그를 확인하여 AUTH: 현재 접속 시도 IP 주소: ... 로그에 어떤 IP가 찍히는지 확인합니다. 이 IP가 10.22.22.22가 맞는지, 그리고 config.py의 ADMIN_IPS 목록과 비교하여 역할이 어떻게 부여되는지 확인합니다.
만약 config.py의 ADMIN_IPS 목록에 IP를 올바르게 넣었는데도 계속 접근 거부가 발생하고, 터미널 로그에 찍힌 IP가 예상과 다르다면, 사용자님의 네트워크 환경(프록시 등)을 점검해야 할 수 있습니다.
터미널 로그에 찍힌 IP가 10.22.22.22가 맞고, config.py에도 이 IP가 있는데 여전히 guest로 처리된다면, auth.py의 get_current_user_role 함수 로직에 다른 문제가 있을 수 있습니다 (이 경우 로그를 더 자세히 봐야 합니다).
만약 DB로만 관리하고 싶다면, 3번 단계의 SQL 쿼리를 실행하여 DB에 직접 IP를 등록합니다.
위 방법으로 수정하고 테스트해보신 후, Flask 터미널 로그에 찍히는 AUTH: 현재 접속 시도 IP 주소: 메시지와 함께 결과를 알려주시면 다음 단계 진행에 도움이 됩니다.

