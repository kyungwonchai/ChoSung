겠습니다. ISensorDataService 인터페이스를 사용하는 것이 좋은 프랙티스입니다. 이 인터페이스를 사용하면 센서 데이터에 대한 접근과 관리를 추상화하여, 애플리케이션의 유연성과 유지보수성을 높일 수 있습니다. 이제 이 인터페이스를 구현하는 SensorViewModel과 이를 사용하는 커스텀 클래스 두 개의 예를 포함한 전체 코드와 상세한 주석을 제공하겠습니다.

1. ISensorDataService 인터페이스 정의
ISensorDataService는 센서 데이터를 가져오고, 특정 인덱스의 센서 데이터를 조회하는 메서드를 정의합니다.

csharp
코드 복사
// ISensorDataService.cs
public interface ISensorDataService
{
    IEnumerable<SensorModel> GetAllSensors();
    SensorModel GetSensorByIndex(int index);
}
2. SensorViewModel 클래스
SensorViewModel은 ISensorDataService를 구현합니다. 이 클래스는 센서 데이터를 관리하고, 필요에 따라 외부에 센서 데이터를 제공합니다.

csharp
코드 복사
// SensorViewModel.cs
using System.Collections.ObjectModel;
using System.ComponentModel;

public class SensorViewModel : INotifyPropertyChanged, ISensorDataService
{
    public ObservableCollection<SensorModel> Sensors { get; private set; }

    public SensorViewModel()
    {
        Sensors = new ObservableCollection<SensorModel>();
        LoadSensors(); // 센서 데이터 로드
    }

    private void LoadSensors()
    {
        // 초기 센서 데이터 로드 (예시 데이터)
        for (int i = 0; i < 20; i++)
        {
            Sensors.Add(new SensorModel { SensorName = $"Sensor {i+1}", IsDetected = false });
        }
    }

    public IEnumerable<SensorModel> GetAllSensors()
    {
        return Sensors;
    }

    public SensorModel GetSensorByIndex(int index)
    {
        return Sensors[index];
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected virtual void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
3. SensorModel 클래스
SensorModel은 각 센서의 데이터를 표현합니다. INotifyPropertyChanged 인터페이스를 구현하여 속성 변경을 UI에 알립니다.

csharp
코드 복사
// SensorModel.cs
public class SensorModel : INotifyPropertyChanged
{
    private string _sensorName;
    private bool _isDetected;

    public string SensorName
    {
        get => _sensorName;
        set
        {
            if (_sensorName != value)
            {
                _sensorName = value;
                OnPropertyChanged(nameof(SensorName));
            }
        }
    }

    public bool IsDetected
    {
        get => _isDetected;
        set
        {
            if (_isDetected != value)
            {
                _isDetected = value;
                OnPropertyChanged(nameof(IsDetected));
            }
        }
    }

    public event PropertyChangedEventHandler PropertyChanged;

    protected void OnPropertyChanged(string propertyName)
    {
        PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
    }
}
4. 사용자 정의 클래스
예를 들어, SensorDataHandler 클래스는 SensorViewModel을 사용하여 센서 데이터를 처리합니다.

csharp
코드 복사
// SensorDataHandler.cs
public class SensorDataHandler
{
    private ISensorDataService _sensorService;

    public SensorDataHandler(ISensorDataService sensorService)
    {
        _sensorService = sensorService;
    }

    public void DisplaySensorStatus()
    {
        var sensors = _sensorService.GetAllSensors();
        foreach (var sensor in sensors)
        {
            Console.WriteLine($"Sensor: {sensor.SensorName}, Status: {(sensor.IsDetected ? "Active" : "Inactive")}");
        }
    }
}
사용 예
SensorViewModel 인스턴스를 생성하고, 이를 사용하여 SensorDataHandler를 초기화한 후 센서 데이터를 처리합니다.

csharp
코드 복사
// Program.cs
class Program
{
    static void Main()
    {
        var sensorViewModel = new SensorViewModel();
        var sensorHandler = new SensorDataHandler(sensorViewModel);
        sensorHandler.DisplaySensorStatus();
    }
}
이 코드 구성은 ISensorDataService 인터페이스를 통해 SensorViewModel의 기능을 외부 클래스에 제공하는 좋은 예입니다. 이 방식으로 코드의 의존성을 관리하고 테스트 및 유지보수를 용이하게 할 수 있습