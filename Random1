해결하기 위해, 로그를 남기는 부분을 수정하여 중복된 로그가 남지 않도록 하겠습니다.

문제 분석
중복된 로그: 같은 폴더 경로와 총 크기가 여러 번 출력되는 것은 코드에서 로그를 남기는 부분이 반복적으로 실행되기 때문입니다.
필요 없는 로그 제거: 총 크기가 0인 로그는 유용하지 않을 수 있으므로 제거하는 것이 좋습니다.
코드 수정
운영 로그에서 중복된 줄을 제거하고, 필요 없는 로그가 출력되지 않도록 수정하겠습니다.

FileCleaner.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Windows.Threading;

public class FileCleaner
{
    private readonly string _logFolderPath;
    private readonly MLModelBuilder _mlModelBuilder;
    private readonly Dispatcher _dispatcher;
    private readonly Logger _logger;
    private readonly Action<long, string> _updateFolderStatistics;

    public FileCleaner(string logFolderPath, MLModelBuilder mlModelBuilder, Dispatcher dispatcher, Logger logger, Action<long, string> updateFolderStatistics)
    {
        _logFolderPath = logFolderPath;
        _mlModelBuilder = mlModelBuilder;
        _dispatcher = dispatcher;
        _logger = logger;
        _updateFolderStatistics = updateFolderStatistics;
    }

    public async Task DeleteFilesAsync(List<FileInfo> filesToDelete, string folderPath, bool forceDelete = false)
    {
        foreach (var file in filesToDelete)
        {
            try
            {
                file.Delete();
                _logger.LogDeletionActivity($"Deleted: {file.FullName}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to delete file: {file.FullName} - {ex.Message}");
            }

            // 삭제 후 남은 용량 확인 및 업데이트
            if (!forceDelete)
            {
                long remainingSize = await Task.Run(() => CalculateFolderSize(new DirectoryInfo(folderPath)));
                _updateFolderStatistics(remainingSize, folderPath);
            }
        }
    }

    public List<FileInfo> GetFilesToDelete(string folderPath, string fileExtension, bool forceDelete = false)
    {
        var filesToDelete = new List<FileInfo>();
        try
        {
            var directory = new DirectoryInfo(folderPath);
            var files = directory.GetFiles($"*{fileExtension}", SearchOption.AllDirectories)
                                 .Where(f => _mlModelBuilder.Predict(f)).ToList();

            // 오래된 순으로 정렬
            files.Sort((f1, f2) => f1.CreationTime.CompareTo(f2.CreationTime));

            long folderSize = files.Sum(f => f.Length);
            if (forceDelete || folderSize > 0)
            {
                filesToDelete = files;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Failed to get files to delete: {ex.Message}");
        }

        return filesToDelete;
    }

    public long GetDriveFreeSpace(string driveName)
    {
        foreach (var drive in DriveInfo.GetDrives())
        {
            if (drive.Name.Equals(driveName, StringComparison.OrdinalIgnoreCase))
            {
                return drive.AvailableFreeSpace;
            }
        }
        return 0;
    }

    public async Task UpdateFolderStatistics(string folderPath, string fileExtension)
    {
        long totalSize = await Task.Run(() => CalculateFolderSize(new DirectoryInfo(folderPath)));
        _updateFolderStatistics(totalSize, folderPath);

        // 로그에서 중복 제거 및 필요 없는 로그 제거
        if (totalSize > 0)
        {
            _logger.LogRecentActivity($"폴더: {folderPath}, 총 크기: {totalSize / (1024 * 1024)} MB");
        }
    }

    private long CalculateFolderSize(DirectoryInfo directoryInfo)
    {
        long totalSize = 0;
        try
        {
            foreach (var file in directoryInfo.GetFiles("*", SearchOption.AllDirectories))
            {
                totalSize += file.Length;
            }
        }
        catch (Exception ex)
        {
            _logger.LogError($"Failed to calculate folder size: {ex.Message}");
        }

        return totalSize;
    }
}
MainWindow.xaml.cs
UpdateFolderStatistics 메서드를 호출하는 부분을 수정합니다.

csharp
코드 복사
private async Task MonitorAndDisplayFilesToDelete(string folderPath, string fileExtension, string driveName)
{
    while (true)
    {
        try
        {
            long freeSpace = await Task.Run(() => _fileCleaner.GetDriveFreeSpace(driveName));
            List<FileInfo> filesToDelete;

            if (freeSpace <= MinimumFreeSpace)
            {
                filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension, forceDelete: true));
                _logger.LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 강제 삭제를 진행합니다.");
            }
            else
            {
                filesToDelete = await Task.Run(() => _fileCleaner.GetFilesToDelete(folderPath, fileExtension));
                if (filesToDelete.Count > 0)
                {
                    _logger.LogRecentActivity("삭제를 진행합니다.");
                }
            }

            Dispatcher.Invoke(() => DisplayFilesToDelete(filesToDelete));
            await _fileCleaner.DeleteFilesAsync(filesToDelete, folderPath, forceDelete: freeSpace <= MinimumFreeSpace);

            await _fileCleaner.UpdateFolderStatistics(folderPath, fileExtension);
            await Task.Delay(TimeSpan.FromMinutes(10)); // 10분마다 체크
        }
        catch (Exception ex)
        {
            _logger.LogError("모니터링 중 오류 발생: " + ex.Message);
        }
    }
}
이제, UpdateFolderStatistics 메서드가 불필요한 로그를 생성하지 않도록 수정되었습니다. 폴더 크기가 0인 경우 로그를 생성하지 않으며