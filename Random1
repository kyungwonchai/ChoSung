알겠습니다. 여러 개의 블록으로 나누지 않고, 전체 코드를 여기에 바로 작성해 드리겠습니다. 복사해서 사용하시면 됩니다.

주의: 코드가 매우 길어질 수 있습니다.

1. 데이터베이스 설정 (MS SQL Server)

(이전과 동일)

SQL

-- 데이터베이스가 존재하지 않으면 새로 생성합니다.
IF NOT EXISTS (SELECT * FROM sys.databases WHERE name = 'LockerManagementDB')
BEGIN
    CREATE DATABASE LockerManagementDB;
END
GO

-- 생성된 데이터베이스를 사용합니다.
USE LockerManagementDB;
GO

-- 테이블이 이미 존재하면 삭제합니다 (스크립트 재실행 용이성을 위해).
IF OBJECT_ID('dbo.LockerAssignments', 'U') IS NOT NULL
    DROP TABLE dbo.LockerAssignments;
GO

-- 기본 사물함 배정 정보를 저장할 테이블을 생성합니다.
CREATE TABLE LockerAssignments (
    Id INT PRIMARY KEY IDENTITY(1,1),             -- 각 레코드의 고유 식별자 (자동 증가)
    LockerType NVARCHAR(50) NOT NULL,            -- 사물함 종류 ('개인사물함', '락커', '신발장')
    Floor NVARCHAR(10) NOT NULL,                 -- 층 ('B1', '1', '2', '3', '4')
    Zone NVARCHAR(50) NOT NULL,                  -- 구역 ('A'~'H', 'B1'~'B4', '기타' 등)
    SpecificLocation NVARCHAR(100) NOT NULL,     -- 세부 위치 (수기입력 - 물리적 사물함을 식별하는 고유값)
    UserName NVARCHAR(100) NULL,                -- 사용자 이름 (수기입력 - 비어있으면 NULL)
    KnoxId NVARCHAR(100) NULL,                   -- Knox ID (수기입력 - 비어있으면 NULL)
    SubPart NVARCHAR(50) NULL,                   -- 소속 파트 ('Main(시생산)', 'MainA'~'Z' - 비어있으면 NULL)
    Administrator NVARCHAR(100) NULL,           -- 관리자 ('홍길동A'~'X' - 이 레코드/배정을 관리하는 사람)
    LastUpdated DATETIME2 NOT NULL DEFAULT GETDATE() -- 마지막 수정일시 (변경 추적용)
);
GO

-- 옵션: 초기 데이터로 빈 사물함 몇 개를 추가합니다.
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'A', 'A-01', 'System', GETDATE()),
('개인사물함', '1', 'A', 'A-02', 'System', GETDATE()),
('락커', 'B1', 'B1', 'R-B1-01', 'System', GETDATE()),
('신발장', '2', '2F', 'S-2F-01', 'System', GETDATE());

-- 옵션: 사용자 배정 예시 데이터를 추가합니다.
INSERT INTO LockerAssignments (LockerType, Floor, Zone, SpecificLocation, UserName, KnoxId, SubPart, Administrator, LastUpdated)
VALUES
('개인사물함', '1', 'B', 'B-15', '김철수', 'kimcs', 'MainA', '홍길동A', GETDATE());
GO

-- 옵션: 검색 성능 향상을 위해 인덱스를 추가합니다. (특히 사물함 개수가 많을 경우 유용)
CREATE INDEX IX_LockerAssignments_Location ON dbo.LockerAssignments (Floor, Zone, SpecificLocation);
CREATE INDEX IX_LockerAssignments_User ON dbo.LockerAssignments (UserName);
GO

PRINT '데이터베이스 및 테이블 생성이 완료되었습니다.';
2. App.config 파일

XML

<?xml version="1.0" encoding="utf-8"?>
<configuration>
  <configSections>
    <section name="entityFramework" type="System.Data.Entity.Internal.ConfigFile.EntityFrameworkSection, EntityFramework, Version=6.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089" requirePermission="false" />
  </configSections>

  <connectionStrings>
    <add name="LockerDbConnection"
         connectionString="Server=YOUR_SERVER_NAME;Database=LockerManagementDB;Trusted_Connection=True;"
         providerName="System.Data.SqlClient"/>
  </connectionStrings>

  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.8" /> </startup>

  <entityFramework>
    <defaultConnectionFactory type="System.Data.Entity.Infrastructure.LocalDbConnectionFactory, EntityFramework">
      <parameters>
        <parameter value="mssqllocaldb" />
      </parameters>
    </defaultConnectionFactory>
    <providers>
      <provider invariantName="System.Data.SqlClient" type="System.Data.Entity.SqlServer.SqlProviderServices, EntityFramework.SqlServer" />
    </providers>
  </entityFramework>
</configuration>
3. 모델 (Models/LockerAssignment.cs)   

C#

using System;
using System.Collections.Generic; // EqualityComparer 사용
using System.ComponentModel;
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;
using System.Runtime.CompilerServices;

namespace LockerManagementApp.Models
{
    /// <summary>
    /// 사물함 배정 정보를 나타내는 데이터 모델 클래스입니다.
    /// INotifyPropertyChanged를 구현하여 속성 변경 시 UI가 업데이트되도록 합니다.
    /// </summary>
    [Table("LockerAssignments")] // 데이터베이스 테이블과 매핑
    public class LockerAssignment : INotifyPropertyChanged
    {
        // Private backing fields
        private int _id;
        private string _lockerType = string.Empty;
        private string _floor = string.Empty;
        private string _zone = string.Empty;
        private string _specificLocation = string.Empty;
        private string _userName; // Nullable string 사용 가능 (.NET Framework 4.8)
        private string _knoxId;
        private string _subPart;
        private string _administrator;
        private DateTime _lastUpdated = DateTime.Now;

        [Key]
        [DatabaseGenerated(DatabaseGeneratedOption.Identity)]
        public int Id
        {
            get => _id;
            set => SetProperty(ref _id, value);
        }

        [Required(ErrorMessage = "사물함 종류는 필수 항목입니다.")]
        [StringLength(50)]
        public string LockerType
        {
            get => _lockerType;
            set => SetProperty(ref _lockerType, value);
        }

        [Required(ErrorMessage = "층 정보는 필수 항목입니다.")]
        [StringLength(10)]
        public string Floor
        {
            get => _floor;
            set => SetProperty(ref _floor, value);
        }

        [Required(ErrorMessage = "구역 정보는 필수 항목입니다.")]
        [StringLength(50)]
        public string Zone
        {
            get => _zone;
            set => SetProperty(ref _zone, value);
        }

        [Required(ErrorMessage = "세부 위치는 필수 항목입니다.")]
        [StringLength(100)]
        public string SpecificLocation
        {
            get => _specificLocation;
            set => SetProperty(ref _specificLocation, value);
        }

        [StringLength(100)]
        public string UserName // Nullable string은 C# 8.0 기능이므로 ? 제거 (또는 프로젝트 언어 버전 확인)
        {
            get => _userName;
            set
            {
                if (SetProperty(ref _userName, value))
                {
                    OnPropertyChanged(nameof(IsAssigned));
                }
            }
        }

        [StringLength(100)]
        public string KnoxId
        {
            get => _knoxId;
            set => SetProperty(ref _knoxId, value);
        }

        [StringLength(50)]
        public string SubPart
        {
            get => _subPart;
            set => SetProperty(ref _subPart, value);
        }

        [StringLength(100)]
        public string Administrator
        {
            get => _administrator;
            set => SetProperty(ref _administrator, value);
        }

        public DateTime LastUpdated
        {
            get => _lastUpdated;
            set => SetProperty(ref _lastUpdated, value);
        }

        [NotMapped]
        public bool IsAssigned => !string.IsNullOrWhiteSpace(UserName);

        public override string ToString()
        {
            return $"{Floor}-{Zone}-{SpecificLocation}: {(IsAssigned ? UserName : "(비어 있음)")}";
        }

        // --- INotifyPropertyChanged 구현 ---
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
        // --- INotifyPropertyChanged 구현 끝 ---
    }
}
4. 데이터 컨텍스트 (Data/LockerDbContext.cs)

C#

using LockerManagementApp.Models;
using System; // DateTime 사용
using System.Data.Entity; // EF6 DbContext 사용
using System.Data.Entity.Infrastructure; // DbEntityEntry 사용
using System.Linq;
using System.Threading.Tasks; // Task 사용 (EF6는 비동기 지원)

namespace LockerManagementApp.Data
{
    /// <summary>
    /// Entity Framework 6 DbContext 클래스입니다.
    /// App.config의 연결 문자열을 사용하여 데이터베이스와 상호작용합니다.
    /// </summary>
    public class LockerDbContext : DbContext
    {
        /// <summary>
        /// LockerAssignments 테이블에 접근하기 위한 DbSet입니다.
        /// </summary>
        public DbSet<LockerAssignment> LockerAssignments { get; set; }

        /// <summary>
        /// 기본 생성자. App.config의 "LockerDbConnection" 연결 문자열을 사용합니다.
        /// </summary>
        public LockerDbContext() : base("name=LockerDbConnection")
        {
            // EF6에서는 OnConfiguring 메서드가 없습니다.
            // 연결 문자열은 App.config 또는 생성자를 통해 설정됩니다.
        }

        /// <summary>
        /// 모델(테이블) 생성 시 추가 구성을 위한 메서드입니다 (Fluent API).
        /// </summary>
        protected override void OnModelCreating(DbModelBuilder modelBuilder)
        {
            // 필요한 경우 Fluent API 또는 Data Annotation을 사용하여 모델 구성
            base.OnModelCreating(modelBuilder);
        }

        /// <summary>
        /// 변경 사항을 저장하기 전에 LastUpdated 타임스탬프를 업데이트합니다.
        /// </summary>
        public override int SaveChanges()
        {
            UpdateTimestamps();
            return base.SaveChanges();
        }

        /// <summary>
        /// 비동기 방식으로 변경 사항을 저장하기 전에 LastUpdated 타임스탬프를 업데이트합니다.
        /// </summary>
        public override Task<int> SaveChangesAsync()
        {
            UpdateTimestamps();
            return base.SaveChangesAsync();
        }

        /// <summary>
        /// 추가(Added)되거나 수정(Modified)된 LockerAssignment 엔티티의 LastUpdated 속성을 현재 시간으로 설정합니다.
        /// </summary>
        private void UpdateTimestamps()
        {
            var entries = ChangeTracker.Entries<LockerAssignment>()
                .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

            foreach (var entry in entries)
            {
                entry.Entity.LastUpdated = DateTime.Now;
            }
        }
    }
}
5. ViewModel 베이스 (Infrastructure/ViewModelBase.cs)

C#

using System.Collections.Generic; // EqualityComparer 사용
using System.ComponentModel;
using System.Runtime.CompilerServices;

namespace LockerManagementApp.Infrastructure
{
    public abstract class ViewModelBase : INotifyPropertyChanged
    {
        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged([CallerMemberName] string propertyName = null)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }

        protected bool SetProperty<T>(ref T storage, T value, [CallerMemberName] string propertyName = null)
        {
            if (EqualityComparer<T>.Default.Equals(storage, value)) return false;
            storage = value;
            OnPropertyChanged(propertyName);
            return true;
        }
    }
}
6. RelayCommand (Infrastructure/RelayCommand.cs)

C#

using System;
using System.Windows.Input;

namespace LockerManagementApp.Infrastructure
{
    public class RelayCommand : ICommand
    {
        private readonly Action<object> _execute; // object? 대신 object 사용
        private readonly Predicate<object> _canExecute; // object? 대신 object 사용

        public event EventHandler CanExecuteChanged
        {
            add { CommandManager.RequerySuggested += value; }
            remove { CommandManager.RequerySuggested -= value; }
        }

        public RelayCommand(Action<object> execute, Predicate<object> canExecute = null)
        {
            _execute = execute ?? throw new ArgumentNullException(nameof(execute));
            _canExecute = canExecute;
        }

        public bool CanExecute(object parameter)
        {
            return _canExecute == null || _canExecute(parameter);
        }

        public void Execute(object parameter)
        {
            _execute(parameter);
        }

        public void RaiseCanExecuteChanged()
        {
            CommandManager.InvalidateRequerySuggested();
        }
    }
}
7. 메인 ViewModel (ViewModels/MainViewModel.cs)   

C#

using LockerManagementApp.Data;
using LockerManagementApp.Models;
using LockerManagementApp.Infrastructure;
using System; // IDisposable 사용
using System.Collections.Generic; // List 사용
using System.Collections.ObjectModel;
using System.Data.Entity; // EF6 네임스페이스 (ToListAsync 등)
using System.Data.Entity.Infrastructure; // DbUpdateException (EF6)
using System.Linq;
using System.Threading.Tasks;
using System.Windows; // MessageBox 사용
using System.Windows.Input;

namespace LockerManagementApp.ViewModels
{
    /// <summary>
    /// 메인 ViewModel 클래스 (.NET Framework 4.8 버전)
    /// DbContext를 직접 생성하고 관리합니다.
    /// </summary>
    public class MainViewModel : ViewModelBase, IDisposable // IDisposable 구현
    {
        private LockerDbContext _context; // DbContext 인스턴스
        private ObservableCollection<LockerAssignment> _lockerAssignments;
        private LockerAssignment _selectedAssignment; // Nullable ? 제거
        private string _statusBarText = "준비 완료";
        private string _currentAdmin = "홍길동A"; // 예시 관리자

        public ObservableCollection<LockerAssignment> LockerAssignments
        {
            get => _lockerAssignments;
            set => SetProperty(ref _lockerAssignments, value);
        }

        public LockerAssignment SelectedAssignment
        {
            get => _selectedAssignment;
            set
            {
                if (SetProperty(ref _selectedAssignment, value))
                {
                    ((RelayCommand)DeleteCommand).RaiseCanExecuteChanged();
                    ((RelayCommand)ClearAssignmentCommand).RaiseCanExecuteChanged();
                }
            }
        }

        public string StatusBarText
        {
            get => _statusBarText;
            set => SetProperty(ref _statusBarText, value);
        }

        // --- Commands ---
        public ICommand LoadDataCommand { get; }
        public ICommand SaveChangesCommand { get; }
        public ICommand AddNewCommand { get; }
        public ICommand DeleteCommand { get; }
        public ICommand ClearAssignmentCommand { get; }

        // --- Predefined Lists ---
        public List<string> LockerTypes { get; } = new List<string> { "개인사물함", "락커", "신발장" };
        public List<string> Floors { get; } = new List<string> { "B1", "1", "2", "3", "4" };
        public List<string> Zones { get; } = new List<string> { "A", "B", "C", "D", "E", "F", "G", "H", "B1", "B2", "B3", "B4", "1F", "2F", "3F", "4F", "기타" };
        public List<string> SubParts { get; } = new List<string> { "Main(시생산)", "MainA", "MainB", "MainC", "MainD", "MainE", "MainF", "MainG", "MainH", "MainI", "MainJ", "MainK", "MainL", "MainM", "MainN", "MainO", "MainP", "MainQ", "MainR", "MainS", "MainT", "MainU", "MainV", "MainW", "MainX", "MainY", "MainZ" };
        public List<string> Administrators { get; } = new List<string> { "홍길동A", "홍길동B", "홍길동C", "홍길동D", "홍길동E", "홍길동F", "홍길동G", "홍길동H", "홍길동I", "홍길동J", "홍길동K", "홍길동L", "홍길동M", "홍길동N", "홍길동O", "홍길동P", "홍길동Q", "홍길동R", "홍길동S", "홍길동T", "홍길동U", "홍길동V", "홍길동W", "홍길동X" };

        /// <summary>
        /// MainViewModel 생성자. DbContext를 직접 생성합니다.
        /// </summary>
        public MainViewModel()
        {
            try
            {
                _context = new LockerDbContext(); // DbContext 직접 생성
            }
            catch (Exception ex)
            {
                 // DbContext 생성 실패 시 (예: App.config 오류)
                 MessageBox.Show($"데이터베이스 컨텍스트 생성 중 오류 발생:\n{ex.ToString()}", "초기화 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                 // 앱 종료 또는 오류 상태 처리 필요
                 StatusBarText = "데이터베이스 연결 오류!";
                 // 생성자에서 예외를 던지면 앱이 불안정해질 수 있으므로 상태 표시 및 기능 제한 고려
                 return; // 이후 로직 실행 중단
            }

            _lockerAssignments = new ObservableCollection<LockerAssignment>();

            // Command 초기화
            LoadDataCommand = new RelayCommand(async _ => await LoadDataAsync());
            SaveChangesCommand = new RelayCommand(async _ => await SaveChangesAsync());
            AddNewCommand = new RelayCommand(AddNewLocker);
            DeleteCommand = new RelayCommand(async _ => await DeleteSelectedAsync(), _ => SelectedAssignment != null);
            ClearAssignmentCommand = new RelayCommand(ClearSelectedAssignment, _ => SelectedAssignment != null && SelectedAssignment.IsAssigned);

            // 생성 시 데이터 로드 (DbContext 생성 성공 시)
            if (_context != null)
            {
                 _ = LoadDataAsync();
            }
        }

        private async Task LoadDataAsync()
        {
            if (_context == null) return; // DbContext 생성 실패 시 실행 방지

            StatusBarText = "데이터 로딩 중...";
            try
            {
                var assignments = await _context.LockerAssignments
                                               .OrderBy(l => l.Floor)
                                               .ThenBy(l => l.Zone)
                                               .ThenBy(l => l.SpecificLocation)
                                               .ToListAsync();
                LockerAssignments = new ObservableCollection<LockerAssignment>(assignments);
                StatusBarText = $"총 {LockerAssignments.Count}개의 레코드를 로드했습니다.";
            }
            catch (Exception ex)
            {
                StatusBarText = $"데이터 로딩 오류: {ex.Message}";
                MessageBox.Show($"데이터베이스 연결 또는 쿼리 실행 중 오류가 발생했습니다:\n{ex.Message}\n\nApp.config의 연결 문자열을 확인하고 데이터베이스 서버가 실행 중인지 확인하세요.", "로드 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private async Task SaveChangesAsync()
        {
             if (_context == null) return;

            StatusBarText = "변경 사항 저장 중...";
            try
            {
                 var changedEntries = _context.ChangeTracker.Entries<LockerAssignment>()
                    .Where(e => e.State == EntityState.Added || e.State == EntityState.Modified);

                 var addedOrModifiedEntities = changedEntries.Select(e => e.Entity).ToList();

                 // 현재 컬렉션(UI) 상태 기준으로 중복 검사 (DB 저장 전)
                 var allItemsToCheck = LockerAssignments.ToList(); // 현재 UI 목록 복사
                 var duplicates = allItemsToCheck
                    .GroupBy(l => new { l.Floor, l.Zone, l.SpecificLocation })
                    .Where(g => g.Count() > 1)
                    .Select(g => g.Key);


                 if (duplicates.Any())
                 {
                     MessageBox.Show($"저장할 수 없습니다. 중복된 물리적 사물함 위치가 발견되었습니다: {string.Join(", ", duplicates.Select(d => $"{d.Floor}-{d.Zone}-{d.SpecificLocation}"))}", "유효성 검사 오류", MessageBoxButton.OK, MessageBoxImage.Warning);
                     StatusBarText = "중복 위치로 인해 저장 실패.";
                     // 변경 사항 롤백 (EF6)
                     RollbackChanges(changedEntries);
                     return;
                 }


                foreach(var entry in changedEntries) // changedEntries는 DB 컨텍스트 기준
                {
                    entry.Entity.Administrator = _currentAdmin;
                }

                int changedCount = await _context.SaveChangesAsync();
                StatusBarText = $"성공적으로 {changedCount}개의 변경 사항을 저장했습니다.";
            }
            catch (DbUpdateException dbEx)
            {
                var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                StatusBarText = $"데이터 저장 오류: {innerExceptionMessage}";
                MessageBox.Show($"데이터베이스에 변경 사항을 저장하는 중 오류가 발생했습니다:\n{innerExceptionMessage}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                // 변경 사항 롤백 (EF6)
                RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged));
            }
            catch (Exception ex)
            {
                StatusBarText = $"데이터 저장 오류: {ex.Message}";
                MessageBox.Show($"저장 중 예기치 않은 오류가 발생했습니다:\n{ex.Message}", "저장 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                RollbackChanges(_context.ChangeTracker.Entries().Where(e => e.State != EntityState.Unchanged));
            }
        }

        /// <summary>
        /// EF6에서 변경 사항 롤백 (간단 버전)
        /// </summary>
        private void RollbackChanges(IEnumerable<DbEntityEntry> changedEntries)
        {
            if (_context == null) return;

            foreach (var entry in changedEntries.ToList()) // ToList()로 복사본 사용
            {
                switch (entry.State)
                {
                    case EntityState.Modified:
                        entry.CurrentValues.SetValues(entry.OriginalValues);
                        entry.State = EntityState.Unchanged;
                        break;
                    case EntityState.Added:
                        entry.State = EntityState.Detached;
                        // UI 컬렉션에서도 제거해야 할 수 있음
                        if (entry.Entity is LockerAssignment addedEntity)
                        {
                            LockerAssignments.Remove(addedEntity);
                        }
                        break;
                    case EntityState.Deleted:
                        entry.State = EntityState.Unchanged; // 또는 OriginalValues로 복원
                        break;
                }
            }
             StatusBarText = "변경 사항이 롤백되었습니다.";
        }


        private void AddNewLocker(object parameter)
        {
            if (_context == null) return;

            var newAssignment = new LockerAssignment
            {
                LockerType = LockerTypes.FirstOrDefault() ?? "개인사물함",
                Floor = Floors.FirstOrDefault() ?? "1",
                Zone = Zones.FirstOrDefault() ?? "A",
                SpecificLocation = "새 위치-" + Guid.NewGuid().ToString().Substring(0, 4),
                Administrator = _currentAdmin,
                LastUpdated = DateTime.Now
            };
            LockerAssignments.Add(newAssignment);
            _context.LockerAssignments.Add(newAssignment);
            SelectedAssignment = newAssignment;
            StatusBarText = "새 사물함이 추가되었습니다. 세부 정보를 입력하고 '변경 사항 저장'을 클릭하세요.";
        }

        private async Task DeleteSelectedAsync()
        {
             if (_context == null || SelectedAssignment == null) return;


            if (MessageBox.Show($"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함 정보를 정말 삭제하시겠습니까?",
                                "삭제 확인", MessageBoxButton.YesNo, MessageBoxImage.Warning) == MessageBoxResult.Yes)
            {
                StatusBarText = "레코드 삭제 중...";
                try
                {
                    var assignmentToDelete = SelectedAssignment;
                    // 컨텍스트에서 엔티티를 찾아 삭제 상태로 변경
                    var entry = _context.Entry(assignmentToDelete);
                    if (entry.State == EntityState.Detached) // 컨텍스트에 없는 경우 Attach 후 삭제
                    {
                         _context.LockerAssignments.Attach(assignmentToDelete);
                    }
                     _context.LockerAssignments.Remove(assignmentToDelete);

                    int changedCount = await _context.SaveChangesAsync();

                    LockerAssignments.Remove(assignmentToDelete);
                    SelectedAssignment = null;
                    StatusBarText = $"성공적으로 {changedCount}개의 레코드를 삭제했습니다.";
                }
                 catch (DbUpdateException dbEx)
                {
                    var innerExceptionMessage = dbEx.InnerException?.Message ?? dbEx.Message;
                    StatusBarText = $"데이터 삭제 오류: {innerExceptionMessage}";
                    MessageBox.Show($"데이터베이스에서 레코드를 삭제하는 중 오류가 발생했습니다:\n{innerExceptionMessage}", "삭제 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                    // 오류 시 상태 복원 (필요 시)
                    _context.Entry(dbEx.Entries.First().Entity).State = EntityState.Unchanged; // 간단 복원 예시
                    await LoadDataAsync(); // 데이터 다시 로드
                }
                catch (Exception ex)
                {
                    StatusBarText = $"데이터 삭제 오류: {ex.Message}";
                     MessageBox.Show($"삭제 중 예기치 않은 오류가 발생했습니다:\n{ex.Message}", "삭제 오류", MessageBoxButton.OK, MessageBoxImage.Error);
                     await LoadDataAsync(); // 데이터 다시 로드
                }
            }
        }

        private void ClearSelectedAssignment(object parameter)
        {
             if (_context == null || SelectedAssignment == null) return;

            SelectedAssignment.UserName = null;
            SelectedAssignment.KnoxId = null;
            SelectedAssignment.SubPart = null;

            _context.Entry(SelectedAssignment).State = EntityState.Modified;
            SelectedAssignment.Administrator = _currentAdmin;

            StatusBarText = $"'{SelectedAssignment.Floor}-{SelectedAssignment.Zone}-{SelectedAssignment.SpecificLocation}' 사물함의 배정을 해제했습니다. 변경 사항을 저장하세요.";
        }


        #region IDisposable 구현
        private bool disposed = false;

        protected virtual void Dispose(bool disposing)
        {
            if (!disposed)
            {
                if (disposing)
                {
                    // 관리되는 리소스 해제 (DbContext 등)
                    _context?.Dispose();
                }
                disposed = true;
            }
        }

        public void Dispose()
        {
            Dispose(true);
            GC.SuppressFinalize(this);
        }
        #endregion
    }
}
8. 메인 View (Views/MainWindow.xaml)

XML

<dx:ThemedWindow
    x:Class="LockerManagementApp.Views.MainWindow"
    xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
    xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
    xmlns:dx="http://schemas.devexpress.com/winfx/2008/xaml/core"
    xmlns:dxg="http://schemas.devexpress.com/winfx/2008/xaml/grid"
    xmlns:dxe="http://schemas.devexpress.com/winfx/2008/xaml/editors"
    xmlns:dxgt="http://schemas.devexpress.com/winfx/2008/xaml/grid/themekeys"
    xmlns:dxb="http://schemas.devexpress.com/winfx/2008/xaml/bars"
    xmlns:local="clr-namespace:LockerManagementApp.Views"
    xmlns:viewmodels="clr-namespace:LockerManagementApp.ViewModels" xmlns:models="clr-namespace:LockerManagementApp.Models"
    Title="사물함 관리 프로그램 (DevExpress MVVM - .NET Framework 4.8)" Height="700" Width="1200"
    Loaded="MainWindow_Loaded" Closing="MainWindow_Closing" >

    <dx:ThemedWindow.DataContext>
        <viewmodels:MainViewModel/>
    </dx:ThemedWindow.DataContext>

    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/> <RowDefinition Height="*"/>    <RowDefinition Height="Auto"/> </Grid.RowDefinitions>

        <Border Grid.Row="0" Background="LightGray" Padding="5"> <StackPanel Orientation="Horizontal">
                <Button Content="🔄 로드/새로고침" Margin="3" Command="{Binding LoadDataCommand}" ToolTip="데이터베이스에서 최신 정보를 불러옵니다."/>
                <Button Content="💾 변경 사항 저장" Margin="3" Command="{Binding SaveChangesCommand}" ToolTip="그리드에서 변경된 내용을 데이터베이스에 저장합니다."/>
                <Button Content="➕ 새 사물함 추가" Margin="3" Command="{Binding AddNewCommand}" ToolTip="새로운 사물함 정보를 추가합니다 (새 행이 추가되며 직접 편집)."/>
                <Button Content="❌ 선택 항목 삭제" Margin="3" Command="{Binding DeleteCommand}" ToolTip="선택된 사물함 정보를 데이터베이스에서 삭제합니다."/>
                <Button Content="🧹 배정 해제" Margin="3,3,15,3" Command="{Binding ClearAssignmentCommand}" ToolTip="선택된 사물함의 사용자 배정 정보(이름, ID 등)를 제거합니다."/>
            </StackPanel>
        </Border>

        <dxg:GridControl Grid.Row="1"
                         ItemsSource="{Binding LockerAssignments}"
                         SelectedItem="{Binding SelectedAssignment, Mode=TwoWay}"
                         AutoGenerateColumns="None"
                         EnableSmartColumnsGeneration="False"
                         SelectionMode="Row"
                         >
            <dxg:GridControl.View>
                <dxg:TableView AllowPerPixelScrolling="True"
                               ShowTotalSummary="False"
                               ShowGroupPanel="True"
                               AllowEditing="True"
                               NavigationStyle="Cell"
                               ShowAutoFilterRow="True"
                               NewItemRowPosition="None"
                               ShowIndicator="True"
                               ShowSearchPanelMode="Always"
                               ShowSearchPanelFindButton="True"
                               ShowSearchPanelCloseButton="True"
                               SearchPanelHighlightResults="True"
                               >
                     <dxg:TableView.RowCellMenuCustomizations>
                         <dxb:BarButtonItem Content="선택 항목 배정 해제"
                                            Command="{Binding View.DataContext.ClearAssignmentCommand}"
                                            Glyph="{dx:DXImage Svg/Actions/DeleteList.svg}"/>
                         <dxb:BarItemSeparator/>
                         <dxb:BarButtonItem Content="선택 행 삭제"
                                            Command="{Binding View.DataContext.DeleteCommand}"
                                            Glyph="{dx:DXImage Svg/Actions/Delete.svg}"/>
                     </dxg:TableView.RowCellMenuCustomizations>
                </dxg:TableView>
            </dxg:GridControl.View>

            <dxg:GridControl.Columns>
                <dxg:GridColumn FieldName="LockerType" Header="종류" Width="100" Fixed="Left">
                    <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding LockerTypes}" IsTextEditable="False"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>
                 <dxg:GridColumn FieldName="Floor" Header="층" Width="60">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding Floors}" IsTextEditable="False"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>
                <dxg:GridColumn FieldName="Zone" Header="구역" Width="80">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding Zones}" IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>
                <dxg:GridColumn FieldName="SpecificLocation" Header="세부 위치" Width="120"/>
                <dxg:GridColumn FieldName="UserName" Header="성명" Width="100"/>
                <dxg:GridColumn FieldName="KnoxId" Header="Knox ID" Width="100"/>
                <dxg:GridColumn FieldName="SubPart" Header="소파트" Width="120">
                     <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding SubParts}" IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>
                 <dxg:GridColumn FieldName="Administrator" Header="관리 담당자" Width="120">
                      <dxg:GridColumn.EditSettings>
                        <dxe:ComboBoxEditSettings ItemsSource="{Binding Administrators}" IsTextEditable="True"/>
                    </dxg:GridColumn.EditSettings>
                 </dxg:GridColumn>
                <dxg:GridColumn FieldName="LastUpdated" Header="최종 수정일시" Width="150" AllowEditing="False" ReadOnly="True">
                     <dxg:GridColumn.EditSettings>
                        <dxe:DateEditSettings MaskType="DateTime" Mask="yyyy-MM-dd HH:mm:ss" MaskUseAsDisplayFormat="True"/>
                    </dxg:GridColumn.EditSettings>
                </dxg:GridColumn>
                <dxg:GridColumn FieldName="Id" Header="ID" Visible="False" ReadOnly="True"/>
            </dxg:GridControl.Columns>

        </dxg:GridControl>

        <StatusBar Grid.Row="2" Background="LightGray"> <StatusBarItem>
                <TextBlock Text="{Binding StatusBarText}" Margin="5,0"/>
            </StatusBarItem>
        </StatusBar>
    </Grid>

</dx:ThemedWindow>
9. 메인 View 코드 비하인드 (Views/MainWindow.xaml.cs)

C#

using DevExpress.Xpf.Core; // ThemedWindow, ApplicationThemeHelper 사용
using LockerManagementApp.ViewModels; // MainViewModel 참조
using System; // IDisposable 사용
using System.ComponentModel; // CancelEventArgs 사용
using System.Windows;

namespace LockerManagementApp.Views
{
    /// <summary>
    /// MainWindow.xaml에 대한 상호 작용 논리 (.NET Framework 4.8)
    /// </summary>
    public partial class MainWindow : ThemedWindow
    {
        public MainWindow()
        {
            InitializeComponent();

            // 옵션: DevExpress 테마 설정
            // ApplicationThemeHelper.ApplicationThemeName = Theme.Office2019ColorfulName;
        }

        // 편의를 위해 DataContext를 ViewModel 타입으로 캐스팅하는 속성
        private MainViewModel ViewModel => DataContext as MainViewModel;

        // 창이 로드되었을 때 호출될 이벤트 핸들러
        private void MainWindow_Loaded(object sender, RoutedEventArgs e)
        {
            // 필요 시 ViewModel의 초기화 로직 호출 (예: 데이터 로드)
            // ViewModel?.LoadDataCommand.Execute(null); // ViewModel 생성자에서 이미 호출됨
        }

        // 창이 닫히기 전에 호출될 이벤트 핸들러
        private void MainWindow_Closing(object sender, CancelEventArgs e)
        {
            // ViewModel이 IDisposable을 구현했으므로, Dispose 호출하여 리소스 정리
            if (ViewModel is IDisposable disposableViewModel)
            {
                disposableViewModel.Dispose();
            }
        }
    }
}
10. 애플리케이션 진입점 (App.xaml)

XML

<Application x:Class="LockerManagementApp.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:LockerManagementApp"
             StartupUri="Views/MainWindow.xaml"> <Application.Resources>
        </Application.Resources>
</Application>
11. 애플리케이션 진입점 (App.xaml.cs)

C#

using System;
using System.Diagnostics; // Debug 사용
using System.Threading.Tasks; // TaskScheduler 사용
using System.Windows;
using System.Windows.Threading; // DispatcherUnhandledException 사용

namespace LockerManagementApp
{
    /// <summary>
    /// App.xaml에 대한 상호 작용 논리 (.NET Framework 4.8)
    /// </summary>
    public partial class App : Application
    {
        protected override void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // 전역 예외 처리 설정
            SetupGlobalExceptionHandling();
        }

        #region 전역 예외 처리 (Global Exception Handling)

        private void SetupGlobalExceptionHandling()
        {
            DispatcherUnhandledException += (s, e) =>
            {
                LogAndShowException(e.Exception, "UI Thread Exception");
                e.Handled = true;
            };
            TaskScheduler.UnobservedTaskException += (s, e) =>
            {
                LogAndShowException(e.Exception, "Background Task Exception");
                e.SetObserved();
            };
            AppDomain.CurrentDomain.UnhandledException += (s, e) =>
            {
                LogAndShowException((Exception)e.ExceptionObject, "AppDomain Exception");
            };
        }

        private void LogAndShowException(Exception exception, string source)
        {
            string errorMessage = $"예기치 않은 오류가 발생했습니다 ({source}):\n\n{exception.ToString()}";
            Debug.WriteLine($"*** 예외 발생 ({source}) ***\n{errorMessage}");
            try
            {
                 MessageBox.Show(errorMessage, "애플리케이션 오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
            catch (Exception msgEx)
            {
                 Debug.WriteLine($"*** 메시지 박스 표시 실패 ({source}) ***\n{msgEx.ToString()}");
            }
        }

        #endregion
    }