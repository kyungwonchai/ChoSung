사항을 잘못 이해했습니다. lotname이 변경될 때마다 새로운 그룹으로 간주하고, 각 그룹별로 datetime1 기준 상위 20개 로우만을 유지하고 싶으신 것이군요. 이를 위해서는 lotname이 변경될 때마다 그룹을 새로 시작하는 로직이 필요합니다.

이를 위해, lotname이 변경될 때마다 그룹 번호를 증가시키는 방법을 사용할 수 있습니다. 이를 위해 LAG 함수를 사용하여 이전 행의 lotname과 현재 행의 lotname을 비교하고, 이 값이 변경될 때마다 그룹 번호를 증가시키는 방법을 사용할 수 있습니다. 그런 다음, 각 그룹 내에서 datetime1 기준으로 상위 20개 로우를 식별하여 xxx 컬럼을 업데이트합니다.

sql
Copy code
WITH LotGroups AS (
    SELECT *,
           SUM(CASE WHEN LAG(lotname) OVER (ORDER BY datetime1) = lotname THEN 0 ELSE 1 END) 
           OVER (ORDER BY datetime1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS GroupID
    FROM LOG_MEV_Backup
),
RankedLots AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY GroupID ORDER BY datetime1) AS rn
    FROM LotGroups
)
UPDATE LOG_MEV_Backup
SET xxx = CASE 
            WHEN RankedLots.rn <= 20 THEN 1
            ELSE 0
          END
FROM LOG_MEV_Backup
INNER JOIN RankedLots
ON LOG_MEV_Backup.line1 = RankedLots.line1
   AND LOG_MEV_Backup.machine1 = RankedLots.machine1
   AND LOG_MEV_Backup.lane1 = RankedLots.lane1
   AND LOG_MEV_Backup.lotname = RankedLots.lotname
   AND LOG_MEV_Backup.tb = RankedLots.tb
   AND LOG_MEV_Backup.datetime1 = RankedLots.datetime1;
이 쿼리는 lotname이 변경될 때마다 새로운 그룹을 시작하고, 각 그룹 내에서 datetime1을 기준으로 상위 20개 로우를 식별하여 xxx 컬럼을 업데이트합니다. 이 쿼리 역시 테스트 환경에서 먼저 실행하여 예상대로 동작하는지 확인하는 것이 중요합니다