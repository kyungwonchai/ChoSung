# app.py (new_post 라우트 부분만 수정)

# ... (다른 import 구문 및 Flask 앱 초기화, 다른 라우트들은 이전 최종본과 동일하게 유지) ...

@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    cats = []
    if Category:
        try:
            cats = Category.query.order_by(Category.name).all()
        except Exception as e:
            app.logger.error(f"Error fetching categories for new_post: {e}")
            flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")

    if request.method == 'POST':
        title = request.form.get('title')
        # onsubmit="tinymce.triggerSave();"를 통해 이 content_from_form은 TinyMCE의 최신 내용을 담고 있어야 합니다.
        content_from_form = request.form.get('content', '') 
        category_id_str = request.form.get('category_id')
        
        is_protected_from_form = request.form.get('is_password_protected_checkbox') == 'y'
        password_from_form = request.form.get('post_password_input', '').strip()

        if not title:
            flash('제목을 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, post=None, selected_category_id=category_id_str)

        app.logger.debug(f"--- RAW CONTENT RECEIVED IN NEW_POST (from form): [{content_from_form}]")

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        
        new_post_obj = None
        try:
            if not Post:
                 raise Exception("Post model is not available.")

            # 1단계: Post 객체를 먼저 생성하고 최소한의 정보로 DB에 추가하여 ID를 받습니다.
            # content는 이 단계에서는 임시값이나 빈 값으로 설정합니다.
            new_post_obj = Post(title=title, content="[TEMP_CONTENT_PLACEHOLDER]", category_id=processed_category_id)
            
            # 비밀번호는 객체 생성 후 바로 설정 가능 (해시값만 가짐)
            if is_protected_from_form:
                if password_from_form:
                    new_post_obj.set_password(password_from_form)
                else: 
                    flash('비밀번호로 보호를 선택했지만, 비밀번호를 입력하지 않았습니다. 보호되지 않은 글로 저장됩니다.', 'warning')
                    new_post_obj.is_password_protected = False
                    new_post_obj.password_hash = None
            else: 
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None

            db.session.add(new_post_obj)
            db.session.commit() # 첫 번째 커밋: Post 객체가 ID를 할당받음

            app.logger.debug(f"--- Post object created with ID: {new_post_obj.id}, Current content: [{new_post_obj.content}]")

            # 2단계: 이제 ID가 있는 new_post_obj 객체에 실제 content를 업데이트합니다.
            # 이 시점에서 new_post_obj는 DB 세션에 의해 관리되는 객체입니다.
            post_to_update_content = Post.query.get(new_post_obj.id) # DB에서 다시 가져와도 되고, new_post_obj를 그대로 써도 됩니다.
            if post_to_update_content:
                post_to_update_content.content = content_from_form # TinyMCE에서 받은 실제 내용으로 업데이트
                app.logger.debug(f"--- Content for Post ID {post_to_update_content.id} updated to: [{post_to_update_content.content}]")
                db.session.commit() # 두 번째 커밋: content 업데이트 저장
            else:
                # 이 경우는 거의 발생하지 않아야 함
                raise Exception(f"Failed to retrieve post with ID {new_post_obj.id} after first commit.")

            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        
        except Exception as e:
            if db and db.session.is_active:
                 db.session.rollback()
            app.logger.error(f"Error creating post (potentially after partial commit): {e}")
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            # 오류 발생 시, 폼 값을 유지하며 다시 렌더링
            return render_template('edit_post.html', title=title, content=content_from_form, categories=cats, post=None, selected_category_id=category_id_str)

    # GET 요청 시
    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None)

# ... (edit_post 및 나머지 app.py 코드는 이전 최종본과 동일하게 유지) ...