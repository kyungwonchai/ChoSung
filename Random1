아닙니다, 그 부분이 가장 헷갈리기 쉬운 부분입니다. Qdrant 컴포넌트는 자동 임베딩 기능이 없습니다.

Embedding 입력점에 무언가를 연결한다고 해서 Qdrant 컴포넌트가 알아서 벡터로 만들어주지 않습니다. 오히려 그 반대입니다.

## 역할 분담: 번역가와 창고 관리인 💡
쉽게 생각해서, 컴포넌트는 각자 역할이 정해진 전문가입니다.

허깅페이스 임베딩 컴포넌트: 번역가입니다. 한국어(텍스트)를 받아서 벡터어(Vector)로 번역하는 역할만 합니다.

Qdrant 컴포넌트: 창고 관리인입니다. 번역가가 번역해준 '벡터어'와 '원본 서류(데이터)'를 받아서 창고에 잘 보관(Ingest)하거나, 손님이 '벡터어'로 물어보면 가장 비슷한 서류를 찾아주는(Search) 역할만 합니다.

즉, 창고 관리인은 번역을 할 줄 모릅니다. 반드시 번역가가 번역한 결과물을 전달해 줘야 합니다.

## 각 입력점(Pin)의 정확한 역할
Qdrant 컴포넌트의 각 입력점은 다음과 같은 데이터를 받기 위해 존재합니다.

Ingest Data: 창고에 보관할 '원본 서류' (딕셔너리 데이터 자체)를 연결하는 곳입니다.

Search Query: 손님의 **'질문(벡터)'**을 연결하는 곳입니다.

Embedding: 창고에 보관할 서류에 붙일 **'번역된 라벨(벡터)'**을 연결하는 곳입니다.

## 올바른 연결 방법 (두 가지 흐름)
임베딩 카드의 출력이 하나뿐이라 헷갈리실 수 있는데, '데이터 주입'을 할 때의 흐름과 '데이터 검색'을 할 때의 흐름을 따로 만들어서 사용해야 합니다.

1. 데이터를 주입(Ingest)할 때의 연결 흐름
이 흐름은 데이터를 Qdrant에 저장할 때 사용합니다.

[데이터 소스 (딕셔너리)] 에서 선이 두 갈래로 나옵니다.

한 갈래는 → [허깅페이스 임베딩] 컴포넌트로 들어가 **벡터**가 됩니다.

이 **벡터**는 → [Qdrant] 컴포넌트의 Embedding 입력점에 연결합니다.

다른 한 갈래는 → [Qdrant] 컴포넌트의 Ingest Data 입력점에 바로 연결합니다. (원본 데이터)

2. 데이터를 검색(Search)할 때의 연결 흐름
이 흐름이 실제 사용자가 질문했을 때 작동하는 에이전트입니다.

[사용자 질문 (텍스트)] 에서 나온 선은 → [허깅페이스 임베딩] 컴포넌트로 들어갑니다.

여기서 나온 **벡터**는 → [Qdrant] 컴포넌트의 Search Query 입력점에 연결합니다.