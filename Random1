LotChanges CTE에서 log1 컬럼이 'END1'인 행만 선택하도록 조건을 추가하겠습니다.

수정된 쿼리는 다음과 같습니다:

sql
Copy code
WITH LotChanges AS (
    SELECT *,
           CASE 
               WHEN LAG(lotname) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1) = lotname THEN 0 
               ELSE 1 
           END AS IsNewLot
    FROM LOG_MEV_Backup
    WHERE log1 = 'END1'
),
LotGroups AS (
    SELECT *,
           SUM(IsNewLot) OVER (PARTITION BY line1, machine1, lane1, tb ORDER BY datetime1 ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS SubGroupID
    FROM LotChanges
),
RankedLots AS (
    SELECT *,
           ROW_NUMBER() OVER (PARTITION BY line1, machine1, lane1, tb, SubGroupID ORDER BY datetime1) AS rn,
           ROW_NUMBER() OVER (PARTITION BY line1, machine1, lane1, tb, SubGroupID ORDER BY datetime1 DESC) AS rn_desc
    FROM LotGroups
)
UPDATE LOG_MEV_Backup
SET xxx = CASE 
            WHEN RankedLots.rn <= 20 THEN 1
            WHEN RankedLots.rn_desc <= 5 THEN 2
            ELSE 0
          END
FROM LOG_MEV_Backup
INNER JOIN RankedLots
ON LOG_MEV_Backup.line1 = RankedLots.line1
   AND LOG_MEV_Backup.machine1 = RankedLots.machine1
   AND LOG_MEV_Backup.lane1 = RankedLots.lane1
   AND LOG_MEV_Backup.lotname = RankedLots.lotname
   AND LOG_MEV_Backup.tb = RankedLots.tb
   AND LOG_MEV_Backup.datetime1 = RankedLots.datetime1
WHERE LOG_MEV_Backup.log1 = 'END1';
이 쿼리는 log1 컬럼이 'END1'인 행에 대해서만 작동합니다. 각 서브그룹 내에서 datetime1을 기준으로 상위 20개 로우에 대해 xxx를 1로 