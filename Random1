using UnityEngine;
using UnityEngine.UI;
using System.Collections;
using System.Collections.Generic;
using System.Text;

public class RackSystemManager : MonoBehaviour
{
    [Header("핵심 연결 대상")]
    [Tooltip("모든 랙들의 최상위 부모 오브젝트 (Rack_Installations)")]
    public Transform rackContainer;

    [Header("머티리얼")]
    [Tooltip("꺼져 있을 때의 기본 램프 머티리얼")]
    public Material defaultLampMaterial;
    [Tooltip("켜졌을 때의 발광 램프 머티리얼")]
    public Material litLampMaterial;

    [Header("애니메이션")]
    [Tooltip("마스크 슬라이드 시간")]
    public float animationDuration = 0.5f;
    [Tooltip("마스크가 앞으로 나오는 거리")]
    public float slideOutDistance = 0.4f;

    // 내부 데이터 저장소: Key는 "A_01_Mask_C05"와 같은 고유 주소, Value는 해당 게임 오브젝트
    private Dictionary<string, GameObject> maskObjects = new Dictionary<string, GameObject>();
    private Dictionary<string, Renderer> lampRenderers = new Dictionary<string, Renderer>();
    
    // 마지막으로 활성화된 오브젝트의 상태를 기억하기 위한 변수들
    private Coroutine lastAnimationCoroutine;
    private GameObject lastMovedMask;
    private Renderer lastLitLamp;
    private Vector3 lastMaskOriginalLocalPosition;

    // 게임이 시작될 때 한 번만 호출되는 함수
    void Start()
    {
        InitializeAllRacks(); // 모든 랙 정보를 수집하고 정리하는 함수를 실행
    }

    // 씬에 배치된 모든 램프와 마스크를 찾아 데이터 저장소(Dictionary)에 등록하는 함수
    void InitializeAllRacks()
    {
        Debug.Log("랙 시스템 초기화를 시작합니다...");
        if (rackContainer == null) { Debug.LogError("Rack Container가 연결되지 않았습니다! Inspector 창을 확인해주세요."); return; }

        int rackCounterA = 1; // A열 랙의 순번을 세는 카운터
        int rackCounterB = 1; // B열 랙의 순번을 세는 카운터

        // rackContainer의 모든 자식 랙(A열, B열)을 순서대로 순회
        foreach (Transform rackParent in rackContainer)
        {
            string standardizedRackID; // "A_01", "B_12" 와 같이 새로 부여할 표준 ID

            // Hierarchy 상의 실제 랙 이름이 'A'로 시작하면 A열로 간주하고 순번 부여
            if (rackParent.name.StartsWith("A"))
            {
                standardizedRackID = $"A_{rackCounterA:02d}";
                rackCounterA++;
            }
            // Hierarchy 상의 실제 랙 이름이 'B'로 시작하면 B열로 간주하고 순번 부여
            else if (rackParent.name.StartsWith("B"))
            {
                standardizedRackID = $"B_{rackCounterB:02d}";
                rackCounterB++;
            }
            else
            {
                continue; // A나 B로 시작하지 않는 오브젝트는 건너뜀
            }

            // 해당 랙 하위의 모든 렌더러(보이는 모든 부품)를 찾음
            Renderer[] childRenderers = rackParent.GetComponentsInChildren<Renderer>(true);
            foreach(Renderer rend in childRenderers)
            {
                string localName = rend.name; // 프리팹 내부의 이름 (예: "Lamp_C05")
                string globalKey = $"{standardizedRackID}_{localName}"; // 최종 고유 주소 생성 (예: "A_01_Lamp_C05")

                // 이름에 따라 램프와 마스크를 구분하여 각각의 저장소에 등록
                if (localName.StartsWith("Lamp_"))
                {
                    if (!lampRenderers.ContainsKey(globalKey))
                    {
                        lampRenderers.Add(globalKey, rend);
                    }
                }
                else if (localName.StartsWith("Mask_"))
                {
                     if (!maskObjects.ContainsKey(globalKey))
                    {
                        maskObjects.Add(globalKey, rend.gameObject);
                    }
                }
            }
        }
        
        Debug.Log($"초기화 완료: {lampRenderers.Count}개의 램프, {maskObjects.Count}개의 마스크가 등록되었습니다.");
    }

    // InputField에 입력된 바코드를 받아 처리하는 메인 함수
    public void ProcessBarcode(string barcode)
    {
        ResetPreviousSlot(); // 이전에 선택됐던 슬롯을 먼저 초기화

        // 입력된 바코드의 유효성을 검사 (11자리가 아니거나, MMF10으로 시작하지 않으면 오류 처리)
        if (string.IsNullOrEmpty(barcode) || barcode.Length != 11 || !barcode.StartsWith("MMF10"))
        {
            Debug.LogError($"잘못된 바코드 형식입니다: {barcode}. (11자리, 예: MMF10A12C05)");
            return;
        }

        // 바코드를 규칙에 따라 분해 (예: MMF10A01C05)
        string row = barcode.Substring(5, 1);      // "A"
        string rackNum = barcode.Substring(6, 2);  // "01"
        string floor = barcode.Substring(8, 1);    // "C"
        string slotNum = barcode.Substring(9, 2);  // "05"

        // 분해된 정보로 데이터 저장소에서 검색할 키(고유 주소)를 조합
        string rackID = $"{row}_{rackNum}"; // "A_01"
        string lampKey = $"{rackID}_Lamp_{floor}{slotNum}"; // "A_01_Lamp_C05"
        string maskKey = $"{rackID}_Mask_{floor}{slotNum}"; // "A_01_Mask_C05"
        
        // 조합된 키로 램프를 찾아 불을 켬
        if (lampRenderers.TryGetValue(lampKey, out Renderer targetLampRenderer))
        {
            if (litLampMaterial != null) targetLampRenderer.material = litLampMaterial;
            lastLitLamp = targetLampRenderer;
        }
        else { Debug.LogWarning($"경고: {lampKey} 이름의 램프를 찾지 못했습니다."); }

        // 조합된 키로 마스크를 찾아 애니메이션 실행
        if (maskObjects.TryGetValue(maskKey, out GameObject targetMask))
        {
            lastMovedMask = targetMask;
            lastMaskOriginalLocalPosition = targetMask.transform.localPosition;
            lastAnimationCoroutine = StartCoroutine(AnimateMask(targetMask, true));
        }
        else { Debug.LogWarning($"경고: {maskKey} 이름의 마스크를 찾지 못했습니다."); }
    }

    // 이전에 활성화된 슬롯을 원래 상태로 되돌리는 함수
    void ResetPreviousSlot()
    {
        if (lastAnimationCoroutine != null) StopCoroutine(lastAnimationCoroutine);
        if (lastLitLamp != null && defaultLampMaterial != null)
        {
            lastLitLamp.material = defaultLampMaterial;
            lastLitLamp = null;
        }
        if (lastMovedMask != null)
        {
            StartCoroutine(AnimateMask(lastMovedMask, false)); // 다시 들어가는 애니메이션 실행
            lastMovedMask = null;
        }
    }

    // 마스크를 부드럽게 움직이는 애니메이션 함수 (코루틴)
    IEnumerator AnimateMask(GameObject mask, bool isSlidingOut)
    {
        // 애니메이션 동안 물리 효과를 잠시 꺼서 충돌을 방지
        Rigidbody rb = mask.GetComponent<Rigidbody>();
        if (rb != null) rb.isKinematic = true;

        Vector3 startPosition = mask.transform.localPosition;
        Vector3 endPosition;
        Vector3 slideDirection = Vector3.up; // 랙이 세워지면서 로컬 Y축(up)이 앞뒤 방향이 됨

        if (isSlidingOut) { endPosition = startPosition + slideDirection * slideOutDistance; }
        else { endPosition = lastMaskOriginalLocalPosition; }

        float timeElapsed = 0;
        // 설정된 시간(animationDuration) 동안 매 프레임마다 조금씩 위치를 변경하여 부드러운 움직임 구현
        while (timeElapsed < animationDuration)
        {
            mask.transform.localPosition = Vector3.Lerp(startPosition, endPosition, timeElapsed / animationDuration);
            timeElapsed += Time.deltaTime;
            yield return null; // 다음 프레임까지 대기
        }
        mask.transform.localPosition = endPosition; // 정확한 위치로 보정

        // 애니메이션이 끝나면 물리 효과를 다시 켬
        if (rb != null) rb.isKinematic = false;
    }
    
    // UI의 InputField의 OnEndEdit 이벤트와 연결되어, 엔터 입력 시 호출될 함수
    public void OnInputSubmit(string text)
    {
        if (!string.IsNullOrEmpty(text))
        {
            ProcessBarcode(text.ToUpper()); // 입력된 텍스트로 바코드 처리 함수 실행
        }
    }
}