 ì´ì œ ReceiveLoopAsync()ì—ì„œ ë°›ì€ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ ë©”ì‹œì§€ì™€ ì •í™•íˆ ë§¤ì¹­í•˜ë„ë¡ ìˆ˜ì •í•´ì¤„ê²Œ.

âœ… ëª©í‘œ
ìˆ˜ì‹ ëœ ë©”ì‹œì§€ (received)ë¥¼ ë³´ë‚¸ ë©”ì‹œì§€ì™€ ì •í™•íˆ ë§¤ì¹­í•´ì•¼ í•œë‹¤.

ReceiveLoopAsync() ë‚´ë¶€ì—ì„œ ì²˜ë¦¬í•  ë•Œ ë³´ë‚¸ ë©”ì‹œì§€ë¥¼ í™•ì¸í•  ìˆ˜ ìˆê²Œ í•´ì•¼ í•œë‹¤.

ë³´ë‚¸ ë©”ì‹œì§€ì™€ ë°›ì€ ë©”ì‹œì§€ë¥¼ ëª¨ë‘ ë¡œê·¸ë¡œ ë‚¨ê¸¸ ìˆ˜ ìˆê²Œ í•œë‹¤.

ğŸ”¥ ì½”ë“œ ìˆ˜ì • (ReceiveLoopAsyncì—ì„œ ë³´ë‚¸ ë©”ì‹œì§€ ë§¤ì¹­)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;

public class ExpertSocketClient
{
    private TcpClient _client; // ì„œë²„ì™€ ì—°ê²°í•˜ëŠ” TcpClient ê°ì²´
    private NetworkStream _stream; // ë°ì´í„°ë¥¼ ì£¼ê³ ë°›ê¸° ìœ„í•œ ë„¤íŠ¸ì›Œí¬ ìŠ¤íŠ¸ë¦¼
    private byte[] _buffer = new byte[1024]; // ìˆ˜ì‹  ë°ì´í„°ë¥¼ ì €ì¥í•˜ëŠ” ë²„í¼ (1KB í¬ê¸°)
    private bool _isConnected = false; // ì„œë²„ì™€ì˜ ì—°ê²° ìƒíƒœë¥¼ í™•ì¸í•˜ëŠ” í”Œë˜ê·¸

    // ìš”ì²­ IDì™€ ì‘ë‹µ TaskCompletionSourceë¥¼ ë§¤í•‘í•˜ê¸° ìœ„í•œ ë”•ì…”ë„ˆë¦¬
    private ConcurrentDictionary<string, TaskCompletionSource<string>> _responseTasks 
        = new ConcurrentDictionary<string, TaskCompletionSource<string>>();

    // ë³´ë‚¸ ë©”ì‹œì§€ë¥¼ ê¸°ë¡í•˜ê¸° ìœ„í•œ ë”•ì…”ë„ˆë¦¬ (ë§¤ì¹­ì„ ìœ„í•´ ì‚¬ìš©)
    private ConcurrentDictionary<string, string> _sentMessages = new ConcurrentDictionary<string, string>();

    /// <summary>
    /// ì„œë²„ì— ì—°ê²°í•˜ê³  ìˆ˜ì‹  ë£¨í”„ë¥¼ ì‹œì‘í•œë‹¤.
    /// </summary>
    public async Task ConnectAsync(string ip, int port)
    {
        _client = new TcpClient();
        await _client.ConnectAsync(ip, port);
        _stream = _client.GetStream();
        _isConnected = true;

        Console.WriteLine($"[INFO] Connected to {ip}:{port}");

        // í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„ë¥¼ ë¹„ë™ê¸°ë¡œ ì‹¤í–‰
        _ = Task.Run(ReceiveLoopAsync); 
    }

    /// <summary>
    /// ì„œë²„ë¡œ ë©”ì‹œì§€ë¥¼ ë³´ë‚´ê³  ì‘ë‹µì„ ê¸°ë‹¤ë¦°ë‹¤.
    /// </summary>
    public async Task<string> SendAndReceiveAsync(string message)
    {
        if (!_isConnected)
            return "[ERROR] Not connected.";

        string wrappedMessage = '\x02' + message + '\x03';
        byte[] data = Encoding.ASCII.GetBytes(wrappedMessage);

        var tcs = new TaskCompletionSource<string>();

        // ê³ ìœ í•œ ìš”ì²­ ID ìƒì„±
        string requestId = Guid.NewGuid().ToString("N");

        // ë³´ë‚¸ ë©”ì‹œì§€ì™€ ìš”ì²­ IDë¥¼ ë§¤ì¹­í•˜ì—¬ ì €ì¥
        _responseTasks.TryAdd(requestId, tcs);
        _sentMessages.TryAdd(requestId, message); 

        // ì„œë²„ë¡œ ë©”ì‹œì§€ ì „ì†¡
        await _stream.WriteAsync(data, 0, data.Length);
        LogMessage($"[SEND] [{requestId}] {message}");

        // ì‘ë‹µì„ ê¸°ë‹¤ë¦¼
        string response = await tcs.Task;
        _responseTasks.TryRemove(requestId, out _);
        _sentMessages.TryRemove(requestId, out _);

        return response;
    }

    /// <summary>
    /// í•­ìƒ ëŒì•„ê°€ëŠ” ìˆ˜ì‹  ë£¨í”„. ëª¨ë“  ë©”ì‹œì§€ë¥¼ ê°ì§€í•˜ê³  ì²˜ë¦¬í•œë‹¤.
    /// </summary>
    private async Task ReceiveLoopAsync()
    {
        while (_isConnected)
        {
            try
            {
                int bytesRead = await _stream.ReadAsync(_buffer, 0, _buffer.Length);

                if (bytesRead == 0)
                {
                    Console.WriteLine("[INFO] Server disconnected.");
                    _isConnected = false;
                    break;
                }

                // ë°›ì€ ë©”ì‹œì§€ ë³€í™˜
                string received = Encoding.ASCII.GetString(_buffer, 0, bytesRead).Trim('\x02', '\x03');
                LogMessage($"[RECV] {received}");

                // ë©”ì‹œì§€ë¥¼ ë°›ì€ í›„, ë³´ë‚¸ ë©”ì‹œì§€ì™€ ë§¤ì¹­í•˜ì—¬ ë¡œê·¸ë¡œ ë‚¨ê¸°ê¸°
                foreach (var key in _responseTasks.Keys)
                {
                    if (_responseTasks.TryRemove(key, out var tcs))
                    {
                        if (_sentMessages.TryGetValue(key, out var sentMessage))
                        {
                            LogMessage($"[MATCHED] Sent: {sentMessage} | Received: {received}");
                        }
                        tcs.SetResult(received); // ì‘ë‹µ ì„¤ì •
                        break;
                    }
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[ERROR] ReceiveLoop exception: {ex.Message}");
                _isConnected = false;
            }
        }
    }

    /// <summary>
    /// ë©”ì‹œì§€ë¥¼ ê¸°ë¡í•˜ëŠ” í•¨ìˆ˜. (ì½˜ì†” ë˜ëŠ” íŒŒì¼ë¡œ ë¡œê·¸ë¥¼ ë‚¨ê¸¸ ìˆ˜ ìˆìŒ)
    /// </summary>
    private void LogMessage(string message)
    {
        Console.WriteLine(message);
    }

    /// <summary>
    /// ì„œë²„ ì—°ê²°ì„ í•´ì œí•œë‹¤.
    /// </summary>
    public void Disconnect()
    {
        _isConnected = false;
        _stream?.Close();
        _client?.Close();
        Console.WriteLine("[INFO] Disconnected.");
    }
}
ğŸ“Œ ì½”ë“œ ì„¤ëª… (ìˆ˜ì • ì‚¬í•­)
ìš”ì²­ê³¼ ì‘ë‹µ ë§¤ì¹­ì„ ìœ„í•œ ì¶”ê°€ ì €ì¥ì†Œ (_sentMessages)

SendAndReceiveAsync()ì—ì„œ ë³´ë‚¸ ë©”ì‹œì§€ë¥¼ _sentMessages ë”•ì…”ë„ˆë¦¬ì— ì €ì¥.

ìš”ì²­ ID (requestId)ë¡œ ë§¤ì¹­ ê°€ëŠ¥í•˜ë„ë¡ ê´€ë¦¬.

ReceiveLoopAsync()ì—ì„œ ì‘ë‹µì„ ë³´ë‚¸ ë©”ì‹œì§€ì™€ ë§¤ì¹­

foreach (var key in _responseTasks.Keys)ë¡œ ëª¨ë“  í‚¤ë¥¼ í™•ì¸í•˜ë©´ì„œ ë§¤ì¹­.

ë§¤ì¹­ë˜ë©´ LogMessage() í•¨ìˆ˜ë¡œ [MATCHED] Sent: ... | Received: ... í˜•íƒœë¡œ ê¸°ë¡.

ë¡œê·¸ ì˜ˆì‹œ:

css
ì½”ë“œ ë³µì‚¬
[SEND] [b91bfa24e5b54abf924fa56e0d4d9463] STATUS_CHECK
[RECV] OK_STATUS
[MATCHED] Sent: STATUS_CHECK | Received: OK_STATUS
ë¡œê·¸ í•¨ìˆ˜ (LogMessage())

ì½˜ì†”ë¡œ ì¶œë ¥í•˜ì§€ë§Œ, íŒŒì¼ë¡œë„ ì €ì¥í•  ìˆ˜ ìˆê²Œ ì‰½ê²Œ ìˆ˜ì • ê°€ëŠ¥.

ğŸ’¯ ê²°ë¡ 
âœ… ì´ì œ ReceiveLoopAsync()ì—ì„œ ë°›ì€ ë©”ì‹œì§€ë¥¼ ë³´ë‚¸ ë©”ì‹œì§€ì™€ ì •í™•íˆ ë§¤ì¹­í•  ìˆ˜ ìˆë‹¤.

âœ… ìš”ì²­ ID (requestId)ë¡œ ë”•ì…”ë„ˆë¦¬ë¥¼ ì‚¬ìš©í•´ì„œ ì•ˆì „í•˜ê²Œ ê´€ë¦¬í•œë‹¤.

âœ… ë³´ë‚¸ ë©”ì‹œì§€ì™€ ë°›ì€ ë©”ì‹œì§€ë¥¼ ëª¨ë‘ ê¸°ë¡í•  ìˆ˜ ìˆë‹¤.
