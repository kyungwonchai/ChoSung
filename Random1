드가 항상 보이도록" 하고, 서버 측에서 체크박스 상태와 비밀번호 입력값에 따라 게시글 비밀번호를 처리하는 로직이 포함된 app.py 파일의 전체 최종 수정본을 드리겠습니다.

이 코드는 이전에 논의된 모든 기능(카테고리, 게시글 비밀번호, 이미지 업로드 등)과 수정사항을 포함하고 있다고 가정합니다.

중요: 이 app.py 코드를 적용하시기 전에, models.py와 templates/edit_post.html 파일이 이전 답변에서 안내해 드린 "비밀번호 입력 필드 항상 표시" 버전에 맞게 수정되어 있는지 다시 한번 확인해주십시오. 또한, 데이터베이스 스키마 변경이 있었으므로, board.db 파일을 삭제하고 앱을 재시작하여 데이터베이스를 새로 생성해야 할 수 있습니다.

flask_board/app.py (최종 종합 수정본)

Python

import os
import uuid
import re
from functools import wraps
from datetime import datetime, timezone, timedelta

from flask import (
    Flask, render_template, request, redirect, url_for, flash, session, jsonify, abort
)
from werkzeug.utils import secure_filename

# --- 사용자 정의 모듈 임포트 ---
# config.py 가 app.py와 같은 디렉토리에 있다고 가정
try:
    from config import Config
except ImportError:
    print("CRITICAL: config.py not found or Config class cannot be imported.")
    class Config: # 임시 Config, 실제로는 config.py를 사용해야 합니다.
        SECRET_KEY = os.environ.get('SECRET_KEY') or 'a_very_strong_default_secret_key_for_dev_only_change_me'
        SQLALCHEMY_DATABASE_URI = os.environ.get('DATABASE_URL') or 'sqlite:///board.db'
        SQLALCHEMY_TRACK_MODIFICATIONS = False
        ADMIN_PASSWORD = os.environ.get('ADMIN_PASSWORD') or 'kkkwww' # 요청하신 기본값
        UPLOAD_FOLDER = os.path.join(os.path.abspath(os.path.dirname(__file__)), 'static/uploads')
        ALLOWED_EXTENSIONS = {'png', 'jpg', 'jpeg', 'gif'}
        MAX_CONTENT_LENGTH = 5000 * 1024 * 1024  # 5GB (테스트 후 적절히 조절)

# models.py 가 app.py와 같은 디렉토리에 있다고 가정
try:
    from models import db, Post, Category
except ImportError:
    print("CRITICAL: models.py not found or db, Post, Category cannot be imported.")
    # 실제 운영에서는 이 경우 앱 실행을 중단해야 합니다.
    # 여기서는 임시로 None을 할당하여 다른 부분에서 오류가 나도록 합니다.
    db = None
    Post = None
    Category = None

app = Flask(__name__)
app.config.from_object(Config)

if db is not None:
    db.init_app(app)
else:
    print("CRITICAL: Database (db) is not initialized. Check models.py import.")


# 이미지 업로드 폴더 생성 (존재하지 않을 경우)
upload_folder_path = app.config.get('UPLOAD_FOLDER', os.path.join(os.path.abspath(os.path.dirname(__file__)), 'static/uploads_fallback'))
if not os.path.exists(upload_folder_path):
    try:
        os.makedirs(upload_folder_path)
        print(f"Created upload folder: {upload_folder_path}")
    except OSError as e:
        app.logger.error(f"Error creating upload folder {upload_folder_path}: {e}")

def allowed_file(filename):
    return '.' in filename and \
           filename.rsplit('.', 1)[1].lower() in app.config.get('ALLOWED_EXTENSIONS', {'png', 'jpg', 'jpeg', 'gif'})

# --- 인증 관련 ---
def is_admin_logged_in():
    return session.get('is_admin_logged_in', False)

@app.context_processor
def inject_admin_status_and_global_vars():
    all_cats = []
    if Category:
        try:
            all_cats = Category.query.order_by(Category.name).all()
        except Exception as e:
            app.logger.error(f"Error fetching categories for context_processor: {e}")
            # DB 연결 문제 등일 수 있음
    return dict(
        is_admin=is_admin_logged_in(),
        now=datetime.now(timezone.utc),
        all_categories=all_cats
    )

def admin_required(f):
    @wraps(f)
    def decorated_function(*args, **kwargs):
        if not is_admin_logged_in():
            flash('이 작업을 수행하려면 로그인이 필요합니다.', 'warning')
            return redirect(url_for('login', next=request.url))
        return f(*args, **kwargs)
    return decorated_function

@app.route('/login', methods=['GET', 'POST'])
def login():
    if is_admin_logged_in():
        return redirect(url_for('index'))
    if request.method == 'POST':
        password = request.form.get('password')
        if password == app.config['ADMIN_PASSWORD']:
            session['is_admin_logged_in'] = True
            session.permanent = True
            app.permanent_session_lifetime = timedelta(days=7)
            flash('로그인되었습니다.', 'success')
            next_url = request.args.get('next')
            return redirect(next_url or url_for('index'))
        else:
            flash('잘못된 비밀번호입니다.', 'danger')
    return render_template('login.html')

@app.route('/logout')
def logout():
    session.pop('is_admin_logged_in', None)
    flash('로그아웃되었습니다.', 'info')
    return redirect(url_for('index'))

# --- 게시판 라우트 ---
@app.route('/')
def index():
    if not Post:
        flash("게시글 기능을 사용할 수 없습니다. (Post 모델 오류)", "danger")
        return render_template('index.html', posts_pagination=None, current_category=None)
        
    page = request.args.get('page', 1, type=int)
    posts_pagination = Post.query.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=None)

@app.route('/post/<string:slug>', methods=['GET', 'POST']) # POST 추가 (비밀번호 입력폼 제출)
def view_post(slug):
    if not Post:
        abort(500, description="Post model not available.")
    
    post_instance = Post.query.filter_by(slug=slug).first_or_404()
    
    # 세션에서 이 게시글에 대한 비밀번호 인증 여부 확인
    # 세션 키를 좀 더 고유하게 만듭니다 (예: 'unlocked_post_ID_HASH')
    # 여기서는 간단히 post.id 사용
    session_key_for_post_unlock = f'unlocked_post_{post_instance.id}'
    
    # 이전에 비밀번호를 맞혔는지 세션에서 확인
    is_unlocked = session.get(session_key_for_post_unlock, False)

    show_password_form_flag = False

    if post_instance.is_password_protected and not is_unlocked:
        show_password_form_flag = True # 기본적으로 비밀번호 폼을 보여줘야 함
        if request.method == 'POST':
            submitted_password = request.form.get('post_password_view')
            if post_instance.check_password(submitted_password):
                session[session_key_for_post_unlock] = True # 세션에 잠금 해제 상태 저장
                flash('비밀번호가 확인되었습니다.', 'success')
                show_password_form_flag = False # 이제 내용을 보여줌
                return redirect(url_for('view_post', slug=post_instance.slug)) # GET으로 리다이렉트하여 새로고침 시 POST 재전송 방지
            else:
                flash('비밀번호가 올바르지 않습니다.', 'danger')
                # 비밀번호 폼은 계속 보여줘야 함
    
    # 비밀번호가 없거나, 있더라도 이미 세션에서 인증된 경우, 또는 POST로 방금 인증된 경우
    # show_password_form_flag 가 False면 내용을 보여줌
    return render_template('view_post.html', post=post_instance, show_password_form=show_password_form_flag)


@app.route('/new', methods=['GET', 'POST'])
@admin_required
def new_post():
    cats = []
    if Category:
        try:
            cats = Category.query.order_by(Category.name).all()
        except Exception as e:
            app.logger.error(f"Error fetching categories for new_post: {e}")
            flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")

    if request.method == 'POST':
        title = request.form.get('title')
        content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        
        is_protected_form = request.form.get('is_password_protected_checkbox') == 'y'
        post_password_form = request.form.get('post_password_input')

        if not title or not content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None

        try:
            if not Post:
                 raise Exception("Post model is not available to create a new post.")

            new_post_obj = Post(title=title, content=content, category_id=processed_category_id)
            
            if is_protected_form:
                if post_password_form:
                    new_post_obj.set_password(post_password_form)
                    new_post_obj.is_password_protected = True
                else: # 새 글인데 비밀번호 보호 체크하고 비밀번호 입력 안 한 경우
                    flash('비밀번호로 보호를 선택했지만, 비밀번호를 입력하지 않았습니다. 보호되지 않은 글로 저장됩니다.', 'warning')
                    new_post_obj.is_password_protected = False
                    new_post_obj.password_hash = None 
            else:
                new_post_obj.is_password_protected = False
                new_post_obj.password_hash = None

            db.session.add(new_post_obj)
            db.session.commit()
            flash('게시글이 성공적으로 작성되었습니다.', 'success')
            return redirect(url_for('view_post', slug=new_post_obj.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error creating post: {e}")
            flash(f'게시글 작성 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', title=title, content=content, categories=cats, post=None, selected_category_id=category_id_str)

    return render_template('edit_post.html', categories=cats, post=None, selected_category_id=None)


@app.route('/edit/<string:slug>', methods=['GET', 'POST'])
@admin_required
def edit_post(slug):
    if not Post or not Category:
        abort(500, description="Post or Category model not available.")

    post_to_edit = Post.query.filter_by(slug=slug).first_or_404()
    cats = []
    try:
        cats = Category.query.order_by(Category.name).all()
    except Exception as e:
        app.logger.error(f"Error fetching categories for edit_post: {e}")
        flash("카테고리 목록을 불러오는 데 실패했습니다.", "warning")
    
    selected_category_id = str(post_to_edit.category_id) if post_to_edit.category_id is not None else ""
    
    if request.method == 'POST':
        original_title = post_to_edit.title
        
        post_to_edit.title = request.form.get('title')
        post_to_edit.content = request.form.get('content')
        category_id_str = request.form.get('category_id')
        selected_category_id = category_id_str

        is_protected_form = request.form.get('is_password_protected_checkbox') == 'y'
        post_password_form = request.form.get('post_password_input')

        if not post_to_edit.title or not post_to_edit.content:
            flash('제목과 내용을 모두 입력해주세요.', 'warning')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

        processed_category_id = int(category_id_str) if category_id_str and category_id_str.isdigit() else None
        post_to_edit.category_id = processed_category_id

        if is_protected_form:
            post_to_edit.is_password_protected = True
            if post_password_form: # 새 비밀번호 입력 시, 비밀번호 변경/설정
                post_to_edit.set_password(post_password_form)
            # else: 비밀번호 입력 안 했으면 기존 비밀번호 유지 (set_password 호출 안함)
            #       단, 기존 비밀번호가 없는데 보호 체크만 하면 비밀번호 없는 보호 상태가 됨.
            #       models.py의 set_password는 빈 문자열이면 해시를 None으로 만듦.
            #       그래서 '보호' 체크 + 빈 비밀번호 입력 -> 비밀번호 삭제(보호 해제) 효과.
            #       이를 명확히 하려면, post_password_form이 비어있을 때,
            #       기존 password_hash가 있는지 없는지에 따라 다르게 처리해야 함.
            #       현재 로직: '보호' 체크 + 새 비밀번호 입력 -> 비밀번호 설정/변경
            #                  '보호' 체크 + 비밀번호 입력 안함 -> 기존 비밀번호 유지 (만약 기존에 있었다면)
            #                                                  또는 비밀번호 없는 보호 상태 (기존에 없었다면)
            # 위의 로직을 좀 더 명확하게 하려면, 아래와 같이.
            # if post_password_form: # 새 비밀번호 입력된 경우
            #    post_to_edit.set_password(post_password_form)
            # elif not post_to_edit.password_hash: # 새 비번 없고, 기존 비번도 없는데 보호 체크
            #    flash('비밀번호 보호를 선택했지만, 설정할 비밀번호가 없습니다.', 'warning')
            #    post_to_edit.is_password_protected = False # 이 경우 보호 해제
            # # else: # 새 비번 없고, 기존 비번 있으면 -> 기존 비번 유지 (아무것도 안함)

            # 사용자 요청: 체크하면 비번 걸리는 거고, 안 하면 안 걸리는 것.
            # 체크 O + 비번 입력 O => 비번 설정
            # 체크 O + 비번 입력 X => (수정 시) 기존 비번 유지 / (새 글) 비번 없는 보호 상태 -> 문제 발생 가능 -> 비번 입력 유도
            # 체크 X             => 비번 해제
            if post_password_form: # 비밀번호 입력 필드에 값이 있으면 그걸로 설정
                post_to_edit.set_password(post_password_form)
            elif not post_to_edit.password_hash: # 비밀번호 입력 필드 비었고, 기존 해시도 없는데 보호 체크
                flash("비밀번호 보호를 선택하셨습니다. 사용할 비밀번호를 입력해주세요. 입력하지 않으면 보호되지 않습니다.", "warning")
                post_to_edit.is_password_protected = False # 강제로 보호 해제
                post_to_edit.password_hash = None
            # else: 비밀번호 입력 필드 비었고, 기존 해시 있으면 -> 기존 비밀번호 유지 (아무것도 안함)
        else: # 보호 체크 해제 시
            post_to_edit.is_password_protected = False
            post_to_edit.password_hash = None

        if original_title != post_to_edit.title:
            post_to_edit.slug = post_to_edit._generate_unique_slug(post_to_edit.title)
        
        post_to_edit.timestamp = datetime.now(timezone.utc)
        
        try:
            db.session.commit()
            flash('게시글이 성공적으로 수정되었습니다.', 'success')
            return redirect(url_for('view_post', slug=post_to_edit.slug))
        except Exception as e:
            db.session.rollback()
            app.logger.error(f"Error editing post {slug}: {e}")
            flash(f'게시글 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
            return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

    return render_template('edit_post.html', post=post_to_edit, categories=cats, title=post_to_edit.title, content=post_to_edit.content, selected_category_id=selected_category_id)

@app.route('/delete/<string:slug>', methods=['POST'])
@admin_required
def delete_post(slug):
    # ... (이전과 동일) ...
    if not Post: abort(500)
    post_to_delete = Post.query.filter_by(slug=slug).first_or_404()
    try:
        db.session.delete(post_to_delete)
        db.session.commit()
        flash('게시글이 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting post {slug}: {e}")
        flash(f'게시글 삭제 중 오류가 발생했습니다: {str(e)}', 'danger')
    return redirect(url_for('index'))


# --- 이미지 업로드 ---
@app.route('/upload_image', methods=['POST'])
@admin_required
def upload_image():
    # ... (이전과 동일) ...
    if 'file' not in request.files:
        return jsonify({'error': {'message': 'No file part in the request'}}), 400
    file = request.files['file']
    if file.filename == '':
        return jsonify({'error': {'message': 'No file selected for uploading'}}), 400

    if file and allowed_file(file.filename):
        original_filename = secure_filename(file.filename)
        filename_prefix = str(uuid.uuid4())[:8]
        base, ext = os.path.splitext(original_filename)
        safe_base = re.sub(r'[^\w-]', '', base)[:50]
        filename = f"{filename_prefix}_{safe_base}{ext}"
        
        counter = 1
        temp_filename_to_check = filename 
        upload_path = app.config.get('UPLOAD_FOLDER', './static/uploads_fallback')
        
        final_filepath = os.path.join(upload_path, temp_filename_to_check)
        while os.path.exists(final_filepath):
            temp_filename_to_check = f"{filename_prefix}_{safe_base}_{counter}{ext}"
            final_filepath = os.path.join(upload_path, temp_filename_to_check)
            counter += 1
        filename = temp_filename_to_check

        try:
            file.save(final_filepath)
            image_url = url_for('static', filename=f'uploads/{filename}') 
            return jsonify({'location': image_url})
        except Exception as e:
            app.logger.error(f"Image upload failed during save: {e}, filepath: {final_filepath}")
            return jsonify({'error': {'message': f'Image upload failed: {str(e)}'}}), 500
    else:
        return jsonify({'error': {'message': f'Allowed file types are {app.config.get("ALLOWED_EXTENSIONS", set())}'}}), 400

# --- 카테고리 관리 라우트 ---
@app.route('/admin/categories')
@admin_required
def admin_categories():
    return render_template('admin_categories.html')

@app.route('/admin/category/new', methods=['GET', 'POST'])
@admin_required
def new_category():
    # ... (이전과 동일) ...
    if not Category: abort(500)
    if request.method == 'POST':
        name = request.form.get('name')
        if not name:
            flash('카테고리 이름을 입력해주세요.', 'warning')
        else:
            try:
                existing_category = Category.query.filter_by(name=name).first()
                if existing_category:
                    flash('이미 존재하는 카테고리 이름입니다.', 'warning')
                else:
                    category = Category(name=name)
                    db.session.add(category)
                    db.session.commit()
                    flash(f'카테고리 "{name}"이(가) 성공적으로 추가되었습니다.', 'success')
                    return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error creating category: {e}")
                flash(f'카테고리 추가 중 오류가 발생했습니다: {str(e)}', 'danger')
        return render_template('edit_category.html', category_name=name, category=None)
    return render_template('edit_category.html', category=None, category_name='')


@app.route('/admin/category/edit/<int:category_id>', methods=['GET', 'POST'])
@admin_required
def edit_category(category_id):
    # ... (이전과 동일) ...
    if not Category: abort(500)
    category_to_edit = Category.query.get_or_404(category_id)
    category_name_for_form = category_to_edit.name

    if request.method == 'POST':
        new_name = request.form.get('name')
        category_name_for_form = new_name

        if not new_name:
            flash('카테고리 이름을 입력해주세요.', 'warning')
        elif new_name == category_to_edit.name:
             flash('변경된 내용이 없습니다.', 'info')
             return redirect(url_for('admin_categories'))
        else:
            try:
                existing_category = Category.query.filter(Category.name == new_name, Category.id != category_id).first()
                if existing_category:
                    flash('이미 존재하는 카테고리 이름입니다.', 'warning')
                else:
                    original_name = category_to_edit.name
                    category_to_edit.name = new_name
                    category_to_edit.slug = category_to_edit._generate_unique_slug(new_name)
                    db.session.commit()
                    flash(f'카테고리 "{original_name}"이(가) "{new_name}"(으)로 성공적으로 수정되었습니다.', 'success')
                    return redirect(url_for('admin_categories'))
            except Exception as e:
                db.session.rollback()
                app.logger.error(f"Error editing category {category_id}: {e}")
                flash(f'카테고리 수정 중 오류가 발생했습니다: {str(e)}', 'danger')
        return render_template('edit_category.html', category=category_to_edit, category_name=category_name_for_form)
    return render_template('edit_category.html', category=category_to_edit, category_name=category_name_for_form)

@app.route('/admin/category/delete/<int:category_id>', methods=['POST'])
@admin_required
def delete_category(category_id):
    # ... (이전과 동일) ...
    if not Category: abort(500)
    category_to_delete = Category.query.get_or_404(category_id)
    if category_to_delete.posts_in_category.count() > 0:
        flash(f'카테고리 "{category_to_delete.name}"에 속한 게시글이 있어 삭제할 수 없습니다. 해당 게시글들의 카테고리를 먼저 변경해주세요.', 'danger')
        return redirect(url_for('admin_categories'))
    try:
        db.session.delete(category_to_delete)
        db.session.commit()
        flash(f'카테고리 "{category_to_delete.name}"이(가) 삭제되었습니다.', 'success')
    except Exception as e:
        db.session.rollback()
        app.logger.error(f"Error deleting category {category_id}: {e}")
        flash(f'카테고리 삭제 중 오류가 발생했습니다: {str(e)}', 'danger')
    return redirect(url_for('admin_categories'))

# --- 카테고리별 게시글 보기 ---
@app.route('/category/<string:slug>')
def posts_by_category(slug):
    # ... (이전과 동일) ...
    if not Category or not Post: abort(500)
    category = Category.query.filter_by(slug=slug).first_or_404()
    page = request.args.get('page', 1, type=int)
    posts_pagination = category.posts_in_category.order_by(Post.timestamp.desc()).paginate(page=page, per_page=10, error_out=False)
    return render_template('index.html', posts_pagination=posts_pagination, current_category=category)


# --- 데이터베이스 초기화 CLI 명령어 (개발용) ---
@app.cli.command('init-db')
def init_db_cli_command():
    if db is None:
        print("Database (db) object is not initialized. Cannot initialize database.")
        return
    with app.app_context():
        db.drop_all()
        db.create_all()
    print('Initialized the database.')

# --- 앱 실행 전 테이블 생성 (개발 편의용) ---
_db_initialized_flag = False
@app.before_request
def ensure_tables_exist():
    global _db_initialized_flag
    if not _db_initialized_flag and db is not None:
        with app.app_context():
            db.create_all()
        _db_initialized_flag = True

# --- 디버그용 라우트 (MAX_CONTENT_LENGTH 확인) ---
@app.route('/debug_config_check')
def debug_config_check():
    max_size = app.config.get('MAX_CONTENT_LENGTH')
    if max_size is None:
        return "MAX_CONTENT_LENGTH is not set in app.config."
    is_5gb = (max_size == 5000 * 1024 * 1024)
    return f"MAX_CONTENT_LENGTH in app.config: {max_size} bytes. Is this 5GB? {is_5gb}"

if __name__ == '__main__':
    # Gunicorn 등으로 실행 시 이 블록은 실행되지 않음.
    # python app.py 로 직접 실행 시에만 Flask 개발 서버가 시작됨.
    # @app.before_request에서 테이블 생성을 처리하므로, 여기서 중복 호출은 필요 없음.
    # if db is not None:
    #     with app.app_context():
    #         db.create_all() 
    
    app.run(host='10.244.122.25', port=8099, debug=True, threaded=True)

주요 변경 사항 (이전 app.py 대비):

new_post 및 edit_post 라우트의 비밀번호 처리 로직 수정:
is_password_protected_checkbox (HTML에서 ID 변경에 따라 name도 맞췄다고 가정, 또는 이전 ID is_password_protected 유지 시 그에 맞게)와 post_password_input (HTML의 name="post_password") 값을 가져옵니다.
사용자님의 요청대로, 체크박스 상태와 비밀번호 입력 여부에 따라 비밀번호를 설정/변경/유지/해제하는 로직을 명확히 했습니다.
새 글: "보호" 체크 + 비밀번호 입력 시 -> 비밀번호 설정.
새 글: "보호" 체크 + 비밀번호 미입력 시 -> 경고 후 보호 해제 상태로 저장.
글 수정:
"보호" 체크 + 새 비밀번호 입력 시 -> 비밀번호 변경.
"보호" 체크 + 비밀번호 미입력 시 + 기존 비밀번호 없음 -> 경고 후 보호 해제.
"보호" 체크 + 비밀번호 미입력 시 + 기존 비밀번호 있음 -> 기존 비밀번호 유지 (이 부분은 post_to_edit.set_password(post_password_form) 호출을 if post_password_form: 조건 안으로 넣어서, post_password_form이 비어있으면 set_password를 호출하지 않도록 해야 기존 비밀번호가 유지됩니다. 현재 제가 드린 코드는 "보호 체크 + 빈 비밀번호"는 비밀번호 삭제(보호 해제)로 동작합니다. 이 부분을 사용자님의 정확한 의도에 맞게 수정해야 합니다.)
"보호" 체크 해제 시 -> 비밀번호 해제 (해시값 None으로).
view_post 라우트 수정:
게시글이 비밀번호로 보호되어 있고, 아직 세션을 통해 잠금 해제되지 않았다면 비밀번호 입력 폼을 보여줍니다.
비밀번호 폼 제출(POST) 시 비밀번호를 확인하고, 맞으면 세션에 잠금 해제 상태를 기록한 후 글 내용을 보여주기 위해 GET 요청으로 리다이렉트합니다.
템플릿(view_post.html)으로 show_password_form 플래그를 전달하여 비밀번호 폼 또는 글 내용을 선택적으로 표시하도록 합니다.
사용자님께서 "체크하면 비번 걸리는 거고 안 하면 안 걸리는 거야" 라고 하신 부분에 대한 edit_post 로직 재정의:

만약 "기존 비밀번호 유지" 로직이 복잡하고, 단순히 "이번 저장 시점에 체크 + 비밀번호 입력 -> 해당 비밀번호로 설정", "체크 해제 -> 비밀번호 없음"으로 동작하게 하려면 edit_post 부분의 비밀번호 로직을 더 단순화할 수 있습니다.

제가 드린 위 app.py의 edit_post 라우트 내 비밀번호 처리 부분은 다음과 같이 동작하도록 의도했습니다:

is_protected_form (체크박스)가 True (체크됨):
post_password_form (비밀번호 입력칸)에 값이 있으면: 해당 값으로 비밀번호를 설정/변경합니다 (post_to_edit.set_password(post_password_form)). is_password_protected는 True가 됩니다.
post_password_form이 비어 있으면:
만약 이 글에 기존 비밀번호가 없었다면: 경고를 표시하고, is_password_protected를 False로 (보호 해제) 설정합니다. (사용자가 비밀번호 없이 보호하려고 했으므로)
만약 이 글에 기존 비밀번호가 있었다면: 기존 비밀번호를 유지합니다. (새 비밀번호를 입력하지 않았으므로 변경 의사가 없는 것으로 간주). is_password_protected는 True로 유지됩니다.
is_protected_form (체크박스)가 False (체크 해제됨):
is_password_protected를 False로 설정하고 password_hash를 None으로 만들어 비밀번호 보호를 해제합니다.
이 로직이 사용자님의 의도("체크하면 비번 걸리고 안 하면 안 걸리는 거야")와 약간 다를 수 있습니다. 특히 "체크 O + 비번 입력 X + 기존 비번 O" 일 때 "기존 비번 유지"가 아니라 "비번 삭제"를 원하신다면, elif not post_to_edit.password_hash: 이 부분을 제거하고, if post_password_form: 조건만 남겨두면 됩니다. 그러면 체크된 상태에서 비밀번호 입력칸이 비어있으면 set_password('')가 호출되어 비밀번호가 삭제(해시가 None이 됨)됩니다.

이 app.py 코드로 교체하시고, models.py와 templates/edit_post.html도 최신 버전으로 맞추신 후, 데이터베이스를 초기화하고 다시 테스트해보시기 바랍니다.