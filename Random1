단순히 포커스를 빼앗는 것만으로는 Windows 11 알림과 동일한 동작을 재현하기 어려울 수 있습니다.
Windows 11 알림은 일시적으로 포커스를 가져갔다가 원래 창으로 돌려주는 동작을 수행합니다.
따라서, 포커스를 가져갔다가 다시 돌려주는 프로그램을 만들어야 합니다.

Windows 11 알림 효과 재현하기
목표:

일정 간격으로 다른 창으로 포커스를 이동 (알림이 뜬 것처럼 동작)
잠시 후 원래 창으로 포커스를 되돌림 (Windows가 원래 창을 다시 활성화한 것처럼 동작)
TextBox에 미치는 영향을 확인 (전체 선택 발생 여부)
1. XAML (MainWindow.xaml)
xml
코드 복사
<Window x:Class="FocusTest.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="포커스 테스트" Height="250" Width="400">
    <StackPanel HorizontalAlignment="Center" VerticalAlignment="Center">
        <TextBox Name="TestTextBox" Width="300" Height="30" Text="여기에 입력하세요"/>
        <Button Name="StartButton" Click="StartButton_Click" Width="200" Height="40" Margin="10">
            포커스 강제 이동 시작
        </Button>
        <Button Name="StopButton" Click="StopButton_Click" Width="200" Height="40" Margin="10">
            포커스 강제 이동 중지
        </Button>
    </StackPanel>
</Window>
2. C# 코드 (MainWindow.xaml.cs)
csharp
코드 복사
using System;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace FocusTest
{
    public partial class MainWindow : Window
    {
        private DispatcherTimer _focusTimer;
        private IntPtr _originalWindowHandle;
        private IntPtr _notepadHandle; // 테스트용으로 메모장을 사용

        [DllImport("user32.dll")]
        private static extern IntPtr GetForegroundWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern bool SetForegroundWindow(IntPtr hWnd);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern void SwitchToThisWindow(IntPtr hWnd, bool fAltTab);

        public MainWindow()
        {
            InitializeComponent();
            _focusTimer = new DispatcherTimer();
            _focusTimer.Interval = TimeSpan.FromSeconds(3);
            _focusTimer.Tick += FocusTimer_Tick;
        }

        private void StartButton_Click(object sender, RoutedEventArgs e)
        {
            _originalWindowHandle = new System.Windows.Interop.WindowInteropHelper(this).Handle;
            _focusTimer.Start();

            // 테스트를 위해 메모장을 실행하여 타겟 창으로 사용
            _notepadHandle = StartNotepad();
        }

        private void StopButton_Click(object sender, RoutedEventArgs e)
        {
            _focusTimer.Stop();
        }

        private async void FocusTimer_Tick(object sender, EventArgs e)
        {
            if (_notepadHandle == IntPtr.Zero) return;

            // 1. 포커스를 메모장으로 이동 (Windows 알림처럼 동작)
            SetForegroundWindow(_notepadHandle);
            await Task.Delay(1000); // 1초 대기 (실제 알림이 잠깐 포커스를 가져가는 것처럼)

            // 2. 원래 WPF 창으로 다시 포커스 복구
            SetForegroundWindow(_originalWindowHandle);
            SwitchToThisWindow(_originalWindowHandle, true);

            // 3. TextBox의 전체 선택 방지 (포커스가 돌아왔을 때 테스트)
            TestTextBox.SelectionLength = 0;
            TestTextBox.SelectionStart = TestTextBox.Text.Length;
        }

        private IntPtr StartNotepad()
        {
            var process = System.Diagnostics.Process.Start("notepad.exe");
            process.WaitForInputIdle(); // 창이 뜰 때까지 대기
            return process.MainWindowHandle;
        }
    }
}
3. 테스트 방법
WPF 프로그램을 실행한 후 TextBox에 텍스트 입력.
"포커스 강제 이동 시작" 버튼 클릭 → 3초 후 메모장이 실행되며 포커스 이동됨.