프로젝트는 많은 기능과 요구 사항을 포함하고 있습니다. WPF 또는 WinForms를 사용하여 만들 수 있지만, WPF가 더 현대적이고 UI가 유연하기 때문에 WPF를 추천드립니다. 아래에 WPF를 사용한 솔루션의 기본적인 구조를 제공하겠습니다. 모든 코드를 한 번에 제공하는 것은 매우 길어질 수 있으므로, 각 부분을 단계별로 설명하고 필요한 코드를 포함하겠습니다.

1. 기본 구조 설정
프로젝트를 생성한 후, 필요한 전역 변수를 설정합니다.

csharp
코드 복사
public partial class MainWindow : Window
{
    private const string LogDirectory = @"C:\Agent\SMDFileAgent";
    private const long MinimumFreeSpaceInBytes = 20L * 1024 * 1024 * 1024; // 20GB
    private List<string> MonitoredFolders = new List<string> { @"D:\YourFolder1", @"D:\YourFolder2" };

    public MainWindow()
    {
        InitializeComponent();
        StartMonitoring();
    }
}
2. 폴더 용량 계산
폴더의 용량을 계산하는 메서드를 추가합니다.

csharp
코드 복사
private long GetDirectorySize(string folderPath)
{
    long size = 0;
    try
    {
        DirectoryInfo dirInfo = new DirectoryInfo(folderPath);
        foreach (FileInfo fileInfo in dirInfo.GetFiles("*", SearchOption.AllDirectories))
        {
            size += fileInfo.Length;
        }
    }
    catch (Exception ex)
    {
        LogError($"Error calculating directory size: {ex.Message}");
    }
    return size;
}
3. 여유 공간 확인 및 파일 삭제
하드 디스크의 여유 공간을 확인하고 파일을 삭제하는 메서드를 추가합니다.

csharp
코드 복사
private void CheckAndFreeSpace()
{
    DriveInfo driveInfo = new DriveInfo(@"D:\");
    long availableFreeSpace = driveInfo.AvailableFreeSpace;

    if (availableFreeSpace < MinimumFreeSpaceInBytes)
    {
        foreach (var folder in MonitoredFolders)
        {
            DeleteOldFiles(folder);
        }
    }
}

private void DeleteOldFiles(string folderPath)
{
    try
    {
        DirectoryInfo dirInfo = new DirectoryInfo(folderPath);
        var files = dirInfo.GetFiles("*.jpg", SearchOption.AllDirectories)
                           .OrderBy(f => f.CreationTime)
                           .ToList();

        foreach (var file in files)
        {
            if (new DriveInfo(@"D:\").AvailableFreeSpace >= MinimumFreeSpaceInBytes)
            {
                break;
            }
            file.Delete();
            LogInfo($"Deleted file: {file.FullName}");
        }
    }
    catch (Exception ex)
    {
        LogError($"Error deleting files: {ex.Message}");
    }
}
4. 용량 및 로그 표시
용량과 로그를 표시하는 메서드를 추가합니다.

csharp
코드 복사
private void DisplayDiskUsage()
{
    long totalUsedSize = MonitoredFolders.Sum(folder => GetDirectorySize(folder));
    long availableFreeSpace = new DriveInfo(@"D:\").AvailableFreeSpace;

    // Update your UI with the values
    // Example:
    // lblTotalUsedSize.Content = FormatBytes(totalUsedSize);
    // lblAvailableFreeSpace.Content = FormatBytes(availableFreeSpace);
}

private string FormatBytes(long bytes)
{
    if (bytes >= 1024 * 1024 * 1024)
        return $"{bytes / (1024 * 1024 * 1024)} GB";
    else if (bytes >= 1024 * 1024)
        return $"{bytes / (1024 * 1024)} MB";
    else if (bytes >= 1024)
        return $"{bytes / 1024} KB";
    else
        return $"{bytes} B";
}
5. 로그 파일 작성
로그 파일을 작성하는 메서드를 추가합니다.

csharp
코드 복사
private void LogInfo(string message)
{
    Log(message, "INFO");
}

private void LogError(string message)
{
    Log(message, "ERROR");
}

private void Log(string message, string level)
{
    try
    {
        if (!Directory.Exists(LogDirectory))
        {
            Directory.CreateDirectory(LogDirectory);
        }

        string logFilePath = Path.Combine(LogDirectory, $"{DateTime.Now:yyMMdd}.txt");
        string logMessage = $"{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff} [{level}] {message}";

        File.AppendAllText(logFilePath, logMessage + Environment.NewLine);

        // Clean up old log files
        DeleteOldLogFiles();
    }
    catch
    {
        // Handle logging failure if needed
    }
}

private void DeleteOldLogFiles()
{
    try
    {
        var logFiles = new DirectoryInfo(LogDirectory).GetFiles("*.txt")
                          .OrderByDescending(f => f.CreationTime)
                          .Skip(30)
                          .ToList();

        foreach (var file in logFiles)
        {
            file.Delete();
        }
    }
    catch (Exception ex)
    {
        // Handle cleanup failure if needed
    }
}
6. 주기적으로 실행
작업을 주기적으로 실행하는 타이머를 설정합니다.

csharp
코드 복사
private void StartMonitoring()
{
    DispatcherTimer timer = new DispatcherTimer();
    timer.Interval = TimeSpan.FromMinutes(1);
    timer.Tick += (sender, args) =>
    {
        CheckAndFreeSpace();
        DisplayDiskUsage();
    };
    timer.Start();
}
이 코드는 기본적인 요구 사항을 충족시키기 위한 구조를 제공합니다. 실제 구현에서는 UI 요소와 에러 처리 등을 추가적으로 고려해야 합니다. 이 코드를 기본으로 하여 더 구체적인 기능을 추가하거나 수정할 수 있습니다.






