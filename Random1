이해했습니다. 파일이 실시간으로 한 줄씩 쓰여지고 있으며, 중복 없이 마지막으로 읽은 줄 이후에만 새로 추가된 내용을 읽고 처리해야 한다는 요구사항입니다. 또한, 파일의 내용이 변경될 때마다 마지막으로 읽은 줄 이후의 내용만 확인하고 특정 키워드가 있는 줄을 출력해야 합니다.

이를 위해 다음과 같은 기능을 추가해야 합니다:

파일의 마지막 읽은 위치를 기록: 각 파일에 대해 마지막으로 읽은 위치를 기억해야 합니다.
파일이 변경될 때 마지막 읽은 위치 이후의 내용을 읽기: 파일이 변경될 때, 이전에 읽은 줄 이후에 추가된 내용만 읽어야 합니다.
**특정 키워드(FST, FNL, PLAN)**가 포함된 줄을 확인하고 출력.
이를 구현하기 위해 파일의 변경 내용만 읽는 코드를 아래에 작성했습니다.

수정된 C# 코드 (중복 없는 파일 읽기)
csharp
코드 복사
using System;
using System.IO;
using System.Text.RegularExpressions;
using System.Collections.Generic;
using System.Windows;

namespace LogFileWatcher
{
    public partial class MainWindow : Window
    {
        private FileSystemWatcher _watcher;
        private readonly string _folderPath = @"C:\G-MES2.0\GUMI_WEB\log"; // 로그 파일이 있는 폴더 경로
        private readonly string[] _keywords = { "FST", "FNL", "PLAN" };  // 감지할 키워드 목록
        private Dictionary<string, long> _fileReadPositions = new Dictionary<string, long>();  // 각 파일의 마지막 읽은 위치 저장

        public MainWindow()
        {
            InitializeComponent();
            SetupWatcher();
        }

        private void SetupWatcher()
        {
            // FileSystemWatcher 설정
            _watcher = new FileSystemWatcher
            {
                Path = _folderPath,  // 감시할 폴더 경로 설정
                NotifyFilter = NotifyFilters.LastWrite | NotifyFilters.FileName,  // 파일 이름과 파일 변경 시 감지
                Filter = "*.log",  // .log 확장자 파일만 감지
                EnableRaisingEvents = true,  // 이벤트 활성화
                IncludeSubdirectories = false  // 하위 폴더는 감지하지 않음
            };

            // 파일 생성 및 변경 시 이벤트 등록
            _watcher.Created += OnChanged;
            _watcher.Changed += OnChanged;

            Console.WriteLine("파일 감시 시작: " + _folderPath);
        }

        // 파일이 생성되거나 변경되었을 때 호출되는 이벤트 핸들러
        private void OnChanged(object sender, FileSystemEventArgs e)
        {
            // 변경된 파일의 전체 경로에서 파일 이름만 추출
            string fileName = Path.GetFileName(e.FullPath);

            // IP는 가변적이며, M4OI 뒤의 문자열과 gumi 뒤의 문자열은 가변적이므로 패턴을 설정
            string pattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_\d{2}\.log$";

            // 파일 이름이 정규식 패턴과 일치하는지 확인
            if (Regex.IsMatch(fileName, pattern))
            {
                // 파일의 변화 감지 및 마지막 읽은 위치 이후에만 내용을 확인
                CheckFileForNewLines(e.FullPath);
            }
        }

        // 변경된 파일의 마지막 읽은 위치 이후 내용을 확인하는 메서드
        private void CheckFileForNewLines(string filePath)
        {
            try
            {
                // 파일의 마지막 읽은 위치를 가져옴 (처음 읽을 경우 0으로 초기화)
                long lastPosition = _fileReadPositions.ContainsKey(filePath) ? _fileReadPositions[filePath] : 0;

                using (FileStream fs = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    // 파일 스트림을 마지막 읽은 위치로 설정
                    fs.Seek(lastPosition, SeekOrigin.Begin);

                    using (StreamReader reader = new StreamReader(fs))
                    {
                        string line;
                        while ((line = reader.ReadLine()) != null)
                        {
                            // 키워드가 포함된 줄을 찾으면 출력
                            foreach (var keyword in _keywords)
                            {
                                if (line.Contains(keyword))
                                {
                                    Console.WriteLine($"특정 문구 발견: {line}");
                                    // TODO: 추가 작업 필요시 여기서 처리 가능
                                }
                            }
                        }

                        // 현재 파일 스트림의 위치를 기록 (다음에 읽을 위치)
                        _fileReadPositions[filePath] = fs.Position;
                    }
                }
            }
            catch (IOException ex)
            {
                Console.WriteLine("파일을 읽는 도중 오류가 발생했습니다: " + ex.Message);
            }
        }

        // 윈도우가 닫힐 때 감시자 해제
        protected override void OnClosed(EventArgs e)
        {
            _watcher.Dispose();
            base.OnClosed(e);
        }
    }
}
주요 수정 사항:
마지막 읽은 위치 기록:

Dictionary<string, long> _fileReadPositions를 사용하여 각 파일의 마지막 읽은 위치를 기록합니다. 파일 경로를 키(key)로 사용하여, 파일별로 마지막 읽은 위치를 관리합니다.
마지막 읽은 위치 이후의 내용만 읽기:

파일이 변경될 때마다 FileStream.Seek(lastPosition, SeekOrigin.Begin)을 사용하여 마지막으로 읽은 위치에서부터 파일을 다시 읽습니다.
StreamReader로 파일을 한 줄씩 읽어내고, 키워드가 포함된 줄을 찾습니다.
키워드 포함 줄 확인:

특정 키워드(FST, FNL, PLAN)가 포함된 줄이 있으면 이를 출력합니다. 필요시 TODO 부분에 추가 작업을 넣을 수 있습니다.
파일 읽기 중 오류 처리:

파일을 읽는 도중에 IOException 발생 가능성을 대비해 예외 처리 코드를 추가했습니다.
동작 방식:
파일 변경 감지: FileSystemWatcher는 지정된 폴더에서 .log 파일이 생성되거나 변경될 때 OnChanged 이벤트를 발생시킵니다.

변경된 파일 확인: 파일 이름이 정규식 패턴에 맞는지 확인한 후, 해당 파일에서 마지막 읽은 위치 이후의 내용만 읽습니다.

마지막 읽은 위치 기록: 각 파일에 대해 마지막으로 읽은 위치를 기록하고, 그 이후에만 추가된 내용을 읽습니다.

특정 키워드 포함 줄 출력: 읽어낸 내용 중 특정 키워드(FST, FNL, PLAN)가 포함된 줄이 있으면 이를 콘솔에 출력합니다.

이 코드로 해결할 수 있는 문제:
파일이 실시간으로 추가되거나 변경될 때, 중복되지 않게 마지막으로 읽은 위치 이후에만 변경된 내용을 확인합니다.
키워드가 포함된 줄만 출력합니다.
모든 파일에 대해 동시로 관리할 수 있으며, 각각의 파일에 대해 마지막 읽은 위치를 따로 기록합니다.
필요한 기능을 모두 처리할 수 있도록 수정했습니다. 추가로 질문이 있으시면 언제든지 알려주세요