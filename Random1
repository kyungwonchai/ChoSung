COM 포트를 여는/닫는 작업도 비동기로 수행할 경우에는 Task.WhenAny를 사용해 타임아웃을 적용해야 안정적으로 처리됩니다. Task.WhenAny를 사용하면 지정된 시간이 지나기 전에 작업이 완료되었는지 확인할 수 있어, 포트가 제대로 열리고 닫히지 않았을 때 시스템이 무한 대기에 빠지지 않도록 방지할 수 있습니다.

아래는 COM 포트를 여닫는 작업에도 Task.WhenAny를 적용한 코드입니다. 이 방식으로 타임아웃을 설정하면 열기 및 닫기 작업이 지정된 시간 내에 수행되지 않았을 때 에러로 처리합니다.

코드 구현 (Task.WhenAny 적용)
csharp
코드 복사
private const int TimeoutDuration = 1000; // 명령 타임아웃 시간 1초
private const int RetryCount = 3; // 명령 재시도 횟수
private const int ComPortOperationTimeout = 2000; // COM 포트 열기/닫기 타임아웃 시간 2초

public async Task<string> SendCommandWithRetryAndReconnectAsync(string command)
{
    int attempt = 0;
    string response = string.Empty;

    while (attempt < RetryCount)
    {
        attempt++;

        // 응답 수신 시도
        var responseTask = SendCommandAsync(command);
        if (await Task.WhenAny(responseTask, Task.Delay(TimeoutDuration)) == responseTask)
        {
            response = responseTask.Result;
            if (!string.IsNullOrEmpty(response))
            {
                LogT5($"응답 수신 성공: {response} (시도 횟수: {attempt})");
                return response;
            }
        }

        // 응답 미수신 시 재시도
        LogT5($"응답 미수신, 재시도 중... (시도 횟수: {attempt})");
        await Task.Delay(500); // 재시도 전 짧은 대기 시간 추가
    }

    // 재시도 실패 시 COM 포트 재설정 시도
    LogT5($"응답 수신 실패: {command}, 최종 시도 횟수: {RetryCount}. COM 포트 재설정 시도 중...");
    bool reconnectSuccess = await CloseAndReopenComPortWithTimeoutAsync();
    if (!reconnectSuccess)
    {
        LogT5("COM 포트 재설정 실패. 오류 발생.");
        return "COM 포트 재설정 실패";
    }

    // 재연결 후 명령 재시도
    LogT5("COM 포트 재설정 성공. 명령 재시도 중...");
    return await SendCommandWithRetryAndReconnectAsync(command);
}

private async Task<bool> CloseAndReopenComPortWithTimeoutAsync()
{
    // 포트 닫기 시도
    bool closeSuccess = await PerformOperationWithTimeoutAsync(() =>
    {
        LogT5("COM 포트 닫는 중...");
        comPort.Close();
        LogT5("COM 포트 닫힘 성공.");
    }, "COM 포트 닫기 실패");

    if (!closeSuccess) return false;

    // 포트 열기 시도
    bool openSuccess = await PerformOperationWithTimeoutAsync(() =>
    {
        LogT5("COM 포트 여는 중...");
        comPort.Open();
        LogT5("COM 포트 열림 성공.");
    }, "COM 포트 열기 실패");

    return openSuccess;
}

private async Task<bool> PerformOperationWithTimeoutAsync(Action operation, string errorMessage)
{
    try
    {
        var task = Task.Run(operation);
        if (await Task.WhenAny(task, Task.Delay(ComPortOperationTimeout)) == task)
        {
            // 작업이 성공적으로 완료된 경우
            return true;
        }
        else
        {
            // 작업이 타임아웃된 경우
            LogT5($"{errorMessage} (타임아웃 {ComPortOperationTimeout}ms 초과)");
            return false;
        }
    }
    catch (Exception ex)
    {
        LogT5($"{errorMessage}: {ex.Message}");
        return false;
    }
}

private async Task<string> SendCommandAsync(string command)
{
    try
    {
        LogT5($"명령 전송: {command}");
        await networkStream.WriteAsync(Encoding.ASCII.GetBytes(command)); // 명령 전송

        byte[] buffer = new byte[1024];
        int bytesRead = await networkStream.ReadAsync(buffer, 0, buffer.Length); // 응답 수신
        string response = Encoding.ASCII.GetString(buffer, 0, bytesRead);

        LogT5($"응답 수신: {response}");
        return response;
    }
    catch (Exception ex)
    {
        LogT5($"통신 오류: {ex.Message}");
        return string.Empty;
    }
}

private void LogT5(string message)
{
    msgvs.Instance.LogT5($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}");
}
설명
PerformOperationWithTimeoutAsync 메서드: 포트를 여는/닫는 작업이 타임아웃에 걸리지 않도록 Task.WhenAny를 사용해 타임아웃을 적용했습니다.

작업이 ComPortOperationTimeout 내에 완료되면 true를 반환합니다.
타임아웃이 초과되면 에러 메시지를 로그에 기록하고 false를 반환하여 작업이 완료되지 않았음을 알립니다.
닫기 및 열기 작업에 타임아웃 적용: CloseAndReopenComPortWithTimeoutAsync에서 PerformOperationWithTimeoutAsync를 사용해 포트를 닫고 여는 작업 각각에 대해 시간 제한을 설정했습니다. 특정 시간 내에 작업이 완료되지 않으면 작업을 중지하고 에러를 반환합니다.