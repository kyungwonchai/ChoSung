소켓 통신에서 메시지가 한 줄로 여러 개 겹쳐서 수신되는 문제는 메시지 구분이 명확하게 이루어지지 않았기 때문입니다. 소켓 통신은 기본적으로 스트림 기반이기 때문에, 데이터가 전송될 때 메시지의 경계를 자동으로 구분해 주지 않습니다. 따라서, 데이터 송수신 시 메시지를 명확하게 구분하기 위해 구분자를 사용해야 합니다.

문제 원인
스트림 기반 전송: TCP 소켓 통신은 스트림 기반이므로, 여러 개의 메시지가 하나의 전송 단위로 합쳐질 수 있습니다.
수신 시 버퍼 처리 문제: 수신 측에서 데이터가 여러 번 읽히거나 메시지 경계가 맞지 않을 수 있습니다.
해결 방안
구분자 추가: 송신 측에서 각 메시지의 끝에 구분자(예: \n)를 추가하여, 수신 측에서 메시지를 구분할 수 있도록 합니다.
수신 시 메시지 분할 처리: 수신 측에서 구분자를 기준으로 메시지를 분할하여 처리합니다.
수정된 코드
1. LogService.cs 수정
메시지 송신 시 명확한 구분자를 추가합니다.

csharp
코드 복사
private async Task SendLogMessage(string message)
{
    try
    {
        // 네트워크 스트림과 TCP 클라이언트가 유효한지 확인
        if (_networkStream != null && _tcpClient != null && _tcpClient.Connected)
        {
            // 메시지 끝에 줄바꿈 문자를 추가하여 메시지 구분
            string messageWithDelimiter = message + "\n";
            byte[] data = Encoding.UTF8.GetBytes(messageWithDelimiter);
            await _networkStream.WriteAsync(data, 0, data.Length); // 메시지 전송
            Console.WriteLine("Log message sent to main UI server.");
        }
        else
        {
            throw new InvalidOperationException("Network stream or TCP client is not connected.");
        }
    }
    catch (Exception ex)
    {
        Console.WriteLine($"Error sending log message: {ex.Message}");
        _isConnected = false; // 전송 실패 시 연결 끊김으로 처리
        // 재시도 로직을 추가할 수 있음
    }
}
2. MainWindow.xaml.cs 수정
수신 시 구분자를 기준으로 메시지를 분할하여 처리합니다.

csharp
코드 복사
private void StartListeningToLogs()
{
    Task.Run(async () =>
    {
        try
        {
            _tcpClient = new TcpClient("127.0.0.1", 9000); // 로컬호스트의 포트 9000에 연결
            _networkStream = _tcpClient.GetStream();

            byte[] buffer = new byte[1024];
            int bytesRead;
            StringBuilder messageBuilder = new StringBuilder();

            // 로그 메시지를 지속적으로 수신하여 UI에 표시
            while ((bytesRead = await _networkStream.ReadAsync(buffer, 0, buffer.Length)) != 0)
            {
                string receivedData = Encoding.UTF8.GetString(buffer, 0, bytesRead);
                messageBuilder.Append(receivedData);

                // 메시지 구분자로 분할하여 개별 메시지로 처리
                string[] messages = messageBuilder.ToString().Split(new[] { '\n' }, StringSplitOptions.RemoveEmptyEntries);

                for (int i = 0; i < messages.Length; i++)
                {
                    if (i == messages.Length - 1 && !receivedData.EndsWith("\n"))
                    {
                        // 마지막 메시지는 완성되지 않았을 수 있으므로 다음 읽기 때까지 보류
                        messageBuilder.Clear();
                        messageBuilder.Append(messages[i]);
                    }
                    else
                    {
                        Dispatcher.Invoke(() => _viewModel.LogMessages.Add(messages[i])); // UI에 로그 메시지 추가
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Dispatcher.Invoke(() => _viewModel.LogMessages.Add($"ERROR: {ex.Message}"));
        }
        finally
        {
            _networkStream?.Close();
            _tcpClient?.Close();
        }
    });
}
주요 변경점 설명
송신 시 구분자 추가:

SendLogMessage 메서드에서 메시지 끝에 줄바꿈 문자(\n)를 추가하여 메시지 구분을 명확히 합니다.
수신 시 메시지 분할 처리:

수신 측에서는 messageBuilder를 사용하여 받은 데이터를 계속 추가하고, 줄바꿈 문자(\n)를 기준으로 메시지를 분할합니다.
Split 메서드를 사용하여 구분자로 메시지를 분할하고, RemoveEmptyEntries 옵션을 사용하여 빈 문자열을 제거합니다.
마지막 메시지가 완성되지 않았을 수 있으므로 이를 확인하고, 다음 읽기 때까지 보류합니다.
이렇게 하면 메시지의 구분이 명확해져서 한 줄에 여러 개의 이벤트가 동시에 수신되는 문제를 해결할 수 있습니다