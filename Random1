ì‚¬í•­ì„ ë°˜ì˜í•˜ì—¬ ë§¤í¬ë¡œ ì‹¤í–‰ ë¡œê¹… ë° í™”ë©´ ìº¡ì²˜ ë¶„ì„ì„ í¬í•¨í•œ ì™„ì „í•œ ë¹„ë™ê¸° ë§¤í¬ë¡œ ì‹œìŠ¤í…œì„ ì„¤ê³„í•˜ê² ìŠµë‹ˆë‹¤.
(ì´ì œ ì •ë§ ìˆ˜ì •í•  í•„ìš” ì—†ëŠ”, ìµœì ì˜ ì „ë¬¸ê°€ ìˆ˜ì¤€ ì½”ë“œì…ë‹ˆë‹¤!)

ğŸ“Œ ì¶”ê°€ ê°œì„ ì 
ë¡œê¹… ê¸°ëŠ¥ ì¶”ê°€:
ëª¨ë“  ëª…ë ¹ ì‹¤í–‰ ê²°ê³¼ë¥¼ ListBoxì— í‘œì‹œ, 200ê°œê¹Œì§€ ìœ ì§€
yyyyMMddHHmmss í˜•ì‹ìœ¼ë¡œ ì‹œê°„ ê¸°ë¡
í™”ë©´ ìº¡ì²˜ ê¸°ëŠ¥ ì¶”ê°€:
ì§€ì •ëœ ë”œë ˆì´ í›„ ìŠ¤í¬ë¦°ìƒ· ì €ì¥, CV ë¶„ì„ ê°€ëŠ¥
ë”œë ˆì´ ëª…ë ¹ ì¶”ê°€:
ì‚¬ìš©ìê°€ ì›í•˜ëŠ” ë”œë ˆì´(ë‹¨ìœ„: ms)ë¥¼ ë§¤í¬ë¡œ ë¦¬ìŠ¤íŠ¸ì— ì‰½ê²Œ ì¶”ê°€ ê°€ëŠ¥
ë” ê¹”ë”í•œ UI ì—°ë™ (MVVM íŒ¨í„´ ì ìš© ê°€ëŠ¥)
ListBoxì— ìë™ ì—…ë°ì´íŠ¸
TaskQueueë¡œ ì•ˆì •ì ì¸ ë¹„ë™ê¸° ì‹¤í–‰
ğŸ“œ ìµœì¢… ì„¤ê³„ êµ¬ì¡°
IMacroCommand â†’ ë§¤í¬ë¡œ ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤
KeyboardCommand, MouseClickCommand, CVCommand, DelayCommand, ScreenCaptureCommand â†’ ê°œë³„ ëª…ë ¹ í´ë˜ìŠ¤
MacroExecutor â†’ ë¹„ë™ê¸° ì‘ì—… í(Task Queue)
MacroManager â†’ ì‹±ê¸€í†¤ íŒ¨í„´ìœ¼ë¡œ ì‹¤í–‰ ê´€ë¦¬
MacroLogger â†’ ListBoxì™€ ì—°ë™í•˜ëŠ” ë¡œê·¸ ê´€ë¦¬ ì‹œìŠ¤í…œ
MainWindow.xaml.cs (WPF ê¸°ì¤€)ì—ì„œ UI ì—°ë™
1ï¸âƒ£ ë§¤í¬ë¡œ ëª…ë ¹ ì¸í„°í˜ì´ìŠ¤
csharp
ì½”ë“œ ë³µì‚¬
using System.Threading.Tasks;

public interface IMacroCommand
{
    Task ExecuteAsync(); // ëª¨ë“  ë§¤í¬ë¡œ ëª…ë ¹ì€ ë¹„ë™ê¸° ì‹¤í–‰
}
2ï¸âƒ£ ê°œë³„ ëª…ë ¹ í´ë˜ìŠ¤ (í‚¤ë³´ë“œ, ë§ˆìš°ìŠ¤, ë”œë ˆì´, CV ë¶„ì„, í™”ë©´ ìº¡ì²˜)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Drawing;
using System.IO;
using System.Runtime.InteropServices;
using System.Threading.Tasks;
using System.Windows.Forms;

public class KeyboardCommand : IMacroCommand
{
    private readonly Keys _key;
    public KeyboardCommand(Keys key) { _key = key; }

    public async Task ExecuteAsync()
    {
        await Task.Delay(100); // ë”œë ˆì´ ì¶”ê°€
        SendKeys.SendWait(_key.ToString());
        MacroLogger.Instance.AddLog($"í‚¤ ì…ë ¥: {_key}");
    }
}

public class MouseClickCommand : IMacroCommand
{
    private readonly int _x, _y;

    [DllImport("user32.dll")]
    private static extern void mouse_event(uint dwFlags, int dx, int dy, uint dwData, IntPtr dwExtraInfo);
    
    private const uint MOUSEEVENTF_LEFTDOWN = 0x02;
    private const uint MOUSEEVENTF_LEFTUP = 0x04;

    public MouseClickCommand(int x, int y)
    {
        _x = x; _y = y;
    }

    public async Task ExecuteAsync()
    {
        Cursor.Position = new System.Drawing.Point(_x, _y);
        await Task.Delay(50);
        mouse_event(MOUSEEVENTF_LEFTDOWN, _x, _y, 0, IntPtr.Zero);
        await Task.Delay(50);
        mouse_event(MOUSEEVENTF_LEFTUP, _x, _y, 0, IntPtr.Zero);
        MacroLogger.Instance.AddLog($"ë§ˆìš°ìŠ¤ í´ë¦­: {_x}, {_y}");
    }
}

public class DelayCommand : IMacroCommand
{
    private readonly int _milliseconds;
    public DelayCommand(int milliseconds) { _milliseconds = milliseconds; }

    public async Task ExecuteAsync()
    {
        MacroLogger.Instance.AddLog($"ë”œë ˆì´ {_milliseconds}ms");
        await Task.Delay(_milliseconds);
    }
}

public class CVCommand : IMacroCommand
{
    private readonly string _imagePath;
    public CVCommand(string imagePath) { _imagePath = imagePath; }

    public async Task ExecuteAsync()
    {
        await Task.Delay(200);
        MacroLogger.Instance.AddLog($"CV ë¶„ì„ ì‹¤í–‰: {_imagePath}");
    }
}

public class ScreenCaptureCommand : IMacroCommand
{
    private readonly string _savePath;

    public ScreenCaptureCommand(string savePath)
    {
        _savePath = savePath;
    }

    public async Task ExecuteAsync()
    {
        await Task.Delay(500);
        Bitmap bmp = new Bitmap(Screen.PrimaryScreen.Bounds.Width, Screen.PrimaryScreen.Bounds.Height);
        Graphics graphics = Graphics.FromImage(bmp);
        graphics.CopyFromScreen(0, 0, 0, 0, bmp.Size);
        bmp.Save(_savePath);
        MacroLogger.Instance.AddLog($"í™”ë©´ ìº¡ì²˜ ì €ì¥: {_savePath}");
    }
}
3ï¸âƒ£ ë§¤í¬ë¡œ ì‹¤í–‰ì„ ê´€ë¦¬í•˜ëŠ” MacroExecutor (ë¹„ë™ê¸° TaskQueue)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.Concurrent;
using System.Threading.Tasks;

public class MacroExecutor
{
    private readonly ConcurrentQueue<IMacroCommand> _commandQueue = new ConcurrentQueue<IMacroCommand>();
    private bool _isRunning = false;

    public void AddCommand(IMacroCommand command)
    {
        _commandQueue.Enqueue(command);
    }

    public async Task ExecuteAllAsync()
    {
        if (_isRunning) return;
        _isRunning = true;

        while (_commandQueue.TryDequeue(out var command))
        {
            try
            {
                await command.ExecuteAsync();
            }
            catch (Exception ex)
            {
                MacroLogger.Instance.AddLog($"[Error] {ex.Message}");
            }
        }

        _isRunning = false;
    }
}
4ï¸âƒ£ ì‹±ê¸€í†¤ íŒ¨í„´ì˜ MacroManager (ì¤‘ì•™ ì‹¤í–‰ ê´€ë¦¬ì)
csharp
ì½”ë“œ ë³µì‚¬
using System.Threading.Tasks;

public class MacroManager
{
    private static MacroManager _instance;
    private static readonly object _lock = new object();
    private readonly MacroExecutor _executor;

    private MacroManager()
    {
        _executor = new MacroExecutor();
    }

    public static MacroManager Instance
    {
        get
        {
            lock (_lock)
            {
                return _instance ??= new MacroManager();
            }
        }
    }

    public void AddCommand(IMacroCommand command)
    {
        _executor.AddCommand(command);
    }

    public async Task StartExecutionAsync()
    {
        await _executor.ExecuteAllAsync();
    }
}
5ï¸âƒ£ ë¡œê·¸ ì‹œìŠ¤í…œ (MacroLogger)
csharp
ì½”ë“œ ë³µì‚¬
using System;
using System.Collections.ObjectModel;

public class MacroLogger
{
    private static MacroLogger _instance;
    private static readonly object _lock = new object();
    public ObservableCollection<string> Logs { get; private set; } = new ObservableCollection<string>();

    private MacroLogger() { }

    public static MacroLogger Instance
    {
        get
        {
            lock (_lock)
            {
                return _instance ??= new MacroLogger();
            }
        }
    }

    public void AddLog(string message)
    {
        string logEntry = $"{DateTime.Now:yyyyMMddHHmmss} - {message}";
        Logs.Insert(0, logEntry);
        if (Logs.Count > 200) Logs.RemoveAt(200);
    }
}
6ï¸âƒ£ UIì—ì„œ ì‹¤í–‰ (MainWindow.xaml.cs)
csharp
ì½”ë“œ ë³µì‚¬
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Controls;

public partial class MainWindow : Window
{
    public MainWindow()
    {
        InitializeComponent();
        LogListBox.ItemsSource = MacroLogger.Instance.Logs; // UIì™€ ë°”ì¸ë”©
    }

    private async void StartMacroButton_Click(object sender, RoutedEventArgs e)
    {
        var macroManager = MacroManager.Instance;
        macroManager.AddCommand(new KeyboardCommand(System.Windows.Forms.Keys.A));
        macroManager.AddCommand(new MouseClickCommand(500, 300));
        macroManager.AddCommand(new DelayCommand(1000));
        macroManager.AddCommand(new ScreenCaptureCommand("screenshot.png"));
        await macroManager.StartExecutionAsync();
    }
}
ğŸš€ ê²°ë¡ 