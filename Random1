습니다! 오류 메시지:

python
코드 복사
list indices must be integers or slices, not str
은 row가 리스트일 때 row["BCT1_1"]처럼 문자열 인덱스로 접근했기 때문에 발생하는 것입니다.

✅ 문제 원인
python
코드 복사
row = get_latest_data_by_line(selected_line)
이 함수에서 cursor.fetchone()이 리스트처럼 반환된 경우 (또는 as_dict=True가 누락되었거나, 잘못 적용됨)
→ row["BCT1_1"] → ❌ 리스트에서는 문자열 인덱스를 사용할 수 없습니다.

✅ 해결 방법
1. cursor = conn.cursor(as_dict=True) 이걸 꼭 써야 합니다!
딕셔너리로 받아야 row["컬럼명"] 형식으로 접근 가능

2. 이 부분 다시 확인해보세요:
python
코드 복사
cursor = conn.cursor(as_dict=True)  ' ✅ 필수!
✅ 안전하게 고친 전체 함수
python
코드 복사
def get_latest_data_by_line(line1):
    conn = pymssql.connect(**DB_CONFIG)
    cursor = conn.cursor(as_dict=True)  # ✅ 꼭 딕셔너리 모드

    cursor.execute("""
        SELECT TOP 1 * FROM ExcelData
        WHERE line1 = %s
        ORDER BY time1 DESC
    """, (line1,))
    
    row = cursor.fetchone()  # ✅ row["컬럼명"] 가능
    conn.close()
    return row
✅ 추가 안전 코드 (row가 None일 때 방지)
python
코드 복사
if selected_line:
    row = get_latest_data_by_line(selected_line)

    if row is not None and isinstance(row, dict):  # ✅ 추가 확인
        # 그대로 make_ct_table 호출
    else:
        st.warning("선택한 라인의 데이터가 없습니다.")
✅ 요약
문제	해결
list indices must be strings	as_dict=True로 커서 설정
row["BCT1_1"] 접근 불가	리스트면 숫자 인덱스만 가능하므로 딕셔너리로 받아야 됨