[BEGIN SCRIPT]

# 목표 (Primary Objective)
현재 활성화된 C# 솔루션을 대상으로 코드 리팩토링 및 빌드 자동화를 수행한다. 최종 목표는 모든 요구사항이 반영된, 빌드 에러가 없는 안정적인 소스 코드 상태를 만드는 것이다.

# 1. 초기 설정 (Initialization)

현재 프로젝트 식별 (Identify Current Project):

현재 작업 환경에 로드된 C# 솔루션을 대상으로 작업을 시작한다.
솔루션의 이름과 루트 디렉토리 경로를 자동으로 파악하여 이후 백업 및 로깅 작업에 사용한다.
프로젝트 분석 (Analyze Project):

로드된 솔루션 파일(.sln)과 포함된 모든 프로젝트 파일(.csproj)을 분석한다.
원본 .NET Framework 버전을 감지하고, 모든 리팩토링 및 빌드 과정에서 해당 버전을 엄격히 준수한다.
솔루션에 설정된 기존 빌드 구성(Debug/Release)을 파악한다.
안전 백업 (Safety Backup):

작업 시작 전, 현재 솔루션의 루트 디렉토리 전체를 압축하여 원본 상태의 백업 파일을 생성한다.
백업 파일명: {SolutionName}_backup_{yyyyMMddHHmmss}.zip
# 2. 핵심 리팩토링 지시사항 (Core Refactoring Directives)

다음 지침에 따라 코드를 수정한다. 모든 수정은 상호 의존성을 고려하여 진행한다.

안정성 및 최적화 (Stability & Optimization):

메모리 누수 방지: IDisposable 인터페이스를 구현한 객체가 using 문이나 try-finally 블록 내에서 Dispose()가 호출되도록 보장한다. 이벤트 핸들러의 구독 해제가 누락된 부분을 찾아 수정한다.
CPU 부하 감소: 불필요한 루프, 비효율적인 알고리즘, 과도한 동기 처리 로직을 찾아 최적화한다. UI 스레드를 차단하는 긴 작업을 async/await를 사용하여 비동기 처리로 전환한다.
GDI/핸들 누수 방지: WinForms/WPF에서 System.Drawing 객체(Brush, Pen, Font 등)나 기타 핸들 객체 사용 후 명시적으로 해제하도록 코드를 수정한다.
네트워크 부하 예방: 불필요한 네트워크 호출을 최소화하고, 적절한 캐싱 전략을 적용할 수 있는 부분을 찾아 수정한다.
코드 구조 개선 (Code Structure Improvement):

파일 분리: 단일 파일에 과도하게 많은 클래스나 코드가 집중된 경우(Monolithic file), 논리적 단위(클래스, 기능)에 따라 파일을 분리한다.
SOLID 원칙 적용: 코드 전체에 단일 책임 원칙(SRP), 개방-폐쇄 원칙(OCP) 등을 적용하여 재사용성과 유지보수성을 향상시킨다.
디자인 패턴 도입: 코드의 맥락을 분석하여 싱글톤, 팩토리, 옵저버 등 적절하다고 판단되는 디자인 패턴을 적용한다.
절차적 코드 리팩토링: 하나의 메서드에 모든 기능이 나열된 절차적 코드를 더 작은 비공개 메서드(private method)와 명확한 역할을 가진 클래스로 분리한다.
# 3. 중요 제약 조건 (Critical Constraint)

민감 정보 처리 규칙:
소스 코드 내에서 실제 데이터베이스 연결 정보, API 키와 같이 명백한 자격 증명(Credential) 패턴이 발견될 경우, 해당 부분은 수정하지 않는다.
예외 규칙: password 라는 문자열 리터럴 자체는 이 프로젝트에서 실제 비밀번호가 아니므로, 일반 텍스트로 간주한다. 따라서 이 문자열이 포함된 코드는 다른 리팩토링 규칙에 따라 자유롭게 수정할 수 있다. 이로 인해 발생하는 빌드 에러는 무시하지 말고 수정해야 한다.
# 4. 반복 빌드 및 검증 루프 (Iterative Build & Verification Loop)

루프 조건: 최대 50회 시도하거나, 빌드가 성공할 때까지 아래 과정을 반복한다.
프로세스: a. 리팩토링 지시사항(#2)에 따라 코드 수정을 1회 적용한다. b. 빌드 실행: 분석된(#1.2) 빌드 구성을 사용하여 솔루션 전체 빌드를 명령줄(command line)에서 실행한다. c. 로그 리디렉션: 빌드 과정에서 발생하는 모든 출력(표준 출력, 표준 에러)을 임시 텍스트 파일(예: build_output.txt)로 리디렉션한다. d. 로그 분석: build_output.txt 파일의 내용을 분석하여 'Error' 또는 '오류' 키워드를 찾는다. e. 분기 처리: * 빌드 실패 시: i. 로그에 기록된 에러의 원인을 정밀하게 파악한다. ii. 특수 오류 처리: 만약 에러 내용이 smdDBConntction 타입 또는 네임스페이스를 찾을 수 없다는 참조 오류(Reference Error)일 경우, 다음을 즉시 수행한다: - D:\sDatabaseServer.dll 파일을 해당 프로젝트의 참조 추가에 사용될 수 있는 위치로 복사한다. - 오류가 발생한 프로젝트에 복사된 sDatabaseServer.dll 파일에 대한 참조를 추가한다. - 이후 루프의 처음(a)으로 돌아가 다시 시도한다. iii. 일반 오류 처리: 그 외 다른 빌드 에러의 경우, 로그를 기반으로 에러를 해결하기 위한 일반적인 코드 수정을 적용하고 루프의 처음(a)으로 돌아간다. * 빌드 성공 시: 루프를 즉시 종료하고 #5 단계로 넘어간다.
절대 실행 금지 (Execution Prohibition):
중요: 빌드가 성공적으로 완료되면 모든 작업은 즉시 종료된다. 어떠한 경우에도 컴파일된 실행 파일(.exe)을 직접 실행해서는 안 된다.
# 5. 최종 변경 이력 로깅 (Final Change Logging)

로그 디렉토리: D:\refactoringhistory\ 경로를 확인하고, 없으면 생성한다. 그 안에 현재 솔루션 이름과 동일한 폴더({SolutionFolderName})를 확인하고, 없으면 생성한다.
로그 파일 생성: 위 경로에 다음 형식으로 로그 파일을 생성한다.
{SolutionName}_{yyyyMMddHHmmss}.txt
로그 내용 기록:
해당 파일에 지금까지의 모든 코드 수정 내역을 기록한다.
각 수정 사항은 어떤 파일의 어느 부분이 어떻게 변경되었는지 명확하게 알 수 있도록 'Before'와 'After' 형식으로 기재해야 한다.
[END SCRIPT]