Services/MonitorControlService.cs

C#

// MonitorAgent/Services/MonitorControlService.cs
using System;
using System.Runtime.InteropServices;

namespace MonitorAgent.Services
{
    public interface IMonitorControlService
    {
        bool TurnMonitorOn();
        bool TurnMonitorOff();
        // string GetMonitorStatus(); // 상태 확인은 복잡하므로 우선 제외
    }

    public class MonitorControlService : IMonitorControlService
    {
        private readonly ILoggingService _logger;

        // Windows API 상수
        private const int WM_SYSCOMMAND = 0x0112;
        private const int SC_MONITORPOWER = 0xF170;
        private const int MONITOR_ON = -1;    // 모니터 켜기
        private const int MONITOR_OFF = 2;    // 모니터 끄기
        // private const int MONITOR_STANDBY = 1; // 모니터 대기 (필요시 사용)

        // HWND_BROADCAST 사용하여 모든 최상위 창에 메시지 전송
        private static readonly IntPtr HWND_BROADCAST = new IntPtr(0xFFFF);
        // 특정 창 핸들을 사용하려면 FindWindow 등을 사용해야 하나, 일반적으로 Broadcast로 충분
        // private static readonly IntPtr HWND_DESKTOP = IntPtr.Zero; // 또는 GetDesktopWindow()

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        public MonitorControlService(ILoggingService logger)
        {
            _logger = logger;
        }

        public bool TurnMonitorOn()
        {
            _logger.LogInfo("Attempting to turn monitor ON.");
            try
            {
                // SendMessage의 반환값은 메시지 처리 결과에 따라 다르며, 0이 성공을 의미하지 않을 수 있음.
                // 여기서는 명령 전송 자체에 집중. 실제 상태 확인은 별도 API 필요.
                SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
                _logger.LogInfo("Monitor ON command sent successfully.");
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to send Monitor ON command.", ex);
                return false;
            }
        }

        public bool TurnMonitorOff()
        {
            _logger.LogInfo("Attempting to turn monitor OFF.");
            try
            {
                SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
                _logger.LogInfo("Monitor OFF command sent successfully.");
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to send Monitor OFF command.", ex);
                return false;
            }
        }
    }
}
다음은 통신에 사용될 Models 폴더의 클래스들과, Agent의 핵심 로직이 담길 Core 폴더, 그리고 네트워크 통신을 담당할 Network 폴더의 코드들을 순차적으로 제공하겠습니다.

먼저 Models 폴더의 클래스들입니다.

2.7. Models/AgentRegistrationInfo.cs (서버 등록 시 전송할 정보)

C#

// MonitorAgent/Models/AgentRegistrationInfo.cs
using System.Collections.Generic;

namespace MonitorAgent.Models
{
    public class AgentRegistrationInfo
    {
        public string AgentId { get; set; }
        public string MachineName { get; set; }
        public List<string> IpAddresses { get; set; }
        public string AgentVersion { get; set; } // Agent 프로그램 버전
        public string CurrentMonitorStatus { get; set; } // 초기 모니터 상태
        // 필요시 OS 버전, .NET 버전 등 추가 정보 포함 가능
    }
}
2.8. Models/ServerCommand.cs (서버에서 Agent로 내려오는 명령)

C#

// MonitorAgent/Models/ServerCommand.cs
using MonitorAgent.Config; // RuntimeConfig 사용

namespace MonitorAgent.Models
{
    public enum CommandAction
    {
        TurnMonitorOn,
        TurnMonitorOff,
        RequestStatusUpdate,
        UpdateConfiguration, // 서버가 Agent의 설정을 변경하라고 보낼 때
        Ping                 // Agent 생존 확인
    }

    public class ServerCommand
    {
        public CommandAction Action { get; set; }
        public string CommandId { get; set; } // 요청 추적을 위한 ID (서버에서 생성)
        public string TargetAgentId { get; set; } // 이 명령이 최종적으로 도달해야 할 Agent의 ID (중계 시 사용)
        public string Payload { get; set; } // JSON 직렬화된 추가 데이터
                                            // 예: UpdateConfiguration 시 RuntimeConfig 객체를 JSON으로 전달
    }

    // ServerCommand의 Payload로 사용될 UpdateConfiguration 명령의 상세 내용
    public class UpdateConfigurationPayload
    {
        public RuntimeConfig NewConfig { get; set; }
    }
}

2.9. Models/InternalTcpMessage.cs (Gateway와 Proxied Agent 간 TCP 통신 메시지)

C#

// MonitorAgent/Models/InternalTcpMessage.cs
using Newtonsoft.Json; // Newtonsoft.Json NuGet 패키지 필요

namespace MonitorAgent.Models
{
    public enum InternalMessageType
    {
        // Proxied -> Gateway
        ProxiedAgentHello,      // Proxied Agent가 Gateway에 처음 연결 시 자신의 ID 알림
        CommandResult,          // Proxied Agent가 명령 실행 결과를 Gateway로 보고
        ProxiedHeartbeat,       // Proxied Agent가 Gateway로 보내는 하트비트

        // Gateway -> Proxied
        ExecuteRelayedCommand,  // Gateway가 Proxied Agent에게 중앙 서버로부터 받은 명령을 중계
        GatewayPing             // Gateway가 Proxied Agent 생존 확인
    }

    public class InternalTcpMessage
    {
        public InternalMessageType MessageType { get; set; }
        public string SourceAgentId { get; set; }   // 메시지를 보낸 Agent의 ID (Proxied 또는 Gateway)
        public string TargetAgentId { get; set; }   // 메시지를 받아야 할 Agent의 ID (중계 시 원본 명령의 TargetAgentId)
        public string OriginalCommandId { get; set; } // 서버에서 내려온 원본 명령의 CommandId (추적용)
        public string Payload { get; set; }         // JSON 직렬화된 추가 데이터

        public string ToJson()
        {
            return JsonConvert.SerializeObject(this);
        }

        public static InternalTcpMessage FromJson(string json)
        {
            try
            {
                return JsonConvert.DeserializeObject<InternalTcpMessage>(json);
            }
            catch
            {
                return null; // 파싱 실패 시 null 반환
            }
        }
    }

    // InternalTcpMessage의 Payload 예시들
    public class ProxiedAgentHelloPayload
    {
        // SourceAgentId가 Proxied Agent의 ID 이므로 별도 페이로드 불필요할 수 있음.
        // 필요시 버전 정보 등 추가 가능.
    }

    public class CommandResultPayload
    {
        public bool Success { get; set; }
        public string Message { get; set; }
        public string CurrentMonitorStatusAfterCommand { get; set; } // 명령 수행 후 모니터 상태
    }

    public class ExecuteRelayedCommandPayload // ServerCommand와 유사하게 구성
    {
        public CommandAction ActionToExecute { get; set; } // 실제 수행할 액션 (예: TurnMonitorOn)
        public string ActionPayload { get; set; } // 해당 액션에 필요한 추가 데이터 (예: ServerCommand의 Payload)
    }