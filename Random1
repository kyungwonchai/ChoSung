, 오류 화면 이미지와 설명 감사합니다. "NameError: name 'ValidationError' is not defined" 오류는 app/routes_admin.py 파일 내의 validate_and_clean_ip_list_string 함수에서 IP 주소 형식이 잘못되었을 때 사용자 정의 오류를 발생시키려고 raise ValidationError(...)를 호출하지만, 해당 ValidationError 클래스가 파일 내에 임포트(import)되지 않았기 때문에 발생합니다.

사용자님 말씀대로, 주소 형식이 틀렸을 경우 전체 서버 오류 페이지가 아닌, 폼에 "유효하지 않은 IP 주소 형식입니다"와 같은 오류 메시지가 표시되고 사용자가 다시 입력할 수 있도록 해야 합니다.

이를 해결하려면 app/routes_admin.py 파일 상단에 ValidationError를 임포트하는 구문을 추가해야 합니다. add_target_pc 및 edit_target_pc 함수 내에는 이미 이 ValidationError를 잡아서 처리하고 flash 메시지를 보여주거나 폼 필드에 오류를 추가하는 로직이 포함되어 있으므로, 임포트 문제만 해결되면 의도대로 동작할 것입니다.

수정: app/routes_admin.py (전체 최종 코드)
wtforms.validators로부터 ValidationError를 임포트하는 라인을 추가합니다.

Python

# scontrol_flask_web/app/routes_admin.py
from flask import Blueprint, render_template, redirect, url_for, flash, request, current_app, g
from app.db_utils import get_db_connection
from app.forms import TargetPCForm, AllowedUserIPForm, AdminIPForm, WorkCalendarExceptionForm
from app.auth import ip_auth_required, get_current_user_role
import math
import pymssql
from datetime import datetime as dt_datetime, date, timedelta 
import calendar 
import holidays 
import ipaddress 
from wtforms.validators import ValidationError # <<--- ValidationError 임포트 추가!

admin_bp = Blueprint('admin', __name__)

# === 유틸리티 함수: IP 주소 유효성 검사 및 정제 ===
def validate_and_clean_ip_list_string(ip_string):
    if not ip_string or not ip_string.strip():
        return None 
    ips = [ip.strip() for ip in ip_string.split(';') if ip.strip()]
    if not ips: return None
    valid_ips = []
    for ip_candidate in ips:
        try:
            ip_obj = ipaddress.ip_address(ip_candidate) # IPv4 또는 IPv6 주소 유효성 검사
            # 특정 IP 버전만 허용하려면 여기서 추가 검사 가능
            # 예: if not isinstance(ip_obj, ipaddress.IPv4Address):
            #         raise ValidationError(f"'{ip_candidate}'는 유효한 IPv4 주소가 아닙니다.")
            valid_ips.append(ip_candidate)
        except ValueError: # ipaddress.ip_address()가 실패하면 ValueError 발생
            raise ValidationError(f"주소2 목록의 '{ip_candidate}'는 유효한 IP 주소 형식이 아닙니다.") # 여기서 ValidationError 사용
    return ";".join(valid_ips) if valid_ips else None

# === _get_pagination_data 함수는 이전과 동일 ===
def _get_pagination_data(query_count, query_data, page, per_page, params_count=None, params_data=None):
    # ... (이전 답변 #49의 전체 코드와 동일) ...
    total_items = 0; items_on_page = []
    conn = None
    try:
        conn = get_db_connection()
        with conn.cursor() as cursor:
            cursor.execute(query_count, params_count or ())
            count_result = cursor.fetchone()
            if count_result: total_items = count_result.get('total', 0)
            if total_items > 0:
                offset = (page - 1) * per_page
                final_params_data = (params_data or ()) + (offset, per_page)
                cursor.execute(query_data, final_params_data)
                items_on_page = cursor.fetchall()
            else: items_on_page = []
    except Exception as e:
        current_app.logger.error(f"페이지네이션 데이터 조회 오류: {e}", exc_info=True)
        flash("데이터 로드 중 오류.", "error")
        return {'page': 1, 'per_page': per_page, 'total_items': 0, 'total_pages': 1, 'items': [], 'has_prev': False, 'has_next': False, 'prev_num': 1, 'next_num': 1}
    total_pages = math.ceil(total_items / per_page) if total_items > 0 else 1
    return {'page': page, 'per_page': per_page, 'total_items': total_items, 'total_pages': total_pages, 'items': items_on_page, 'has_prev': page > 1, 'has_next': page < total_pages, 'prev_num': page - 1, 'next_num': page + 1}

# === 1. 대상 PC 관리 ===
@admin_bp.route('/pcs')
@ip_auth_required('admin')
def manage_target_pcs():
    # ... (이전 답변 #49의 코드와 동일) ...
    page = request.args.get('page', 1, type=int); per_page = 10
    q_count = "SELECT COUNT(*) AS total FROM dbo.target_pcs"; q_data = "SELECT id, pc_name, address1, address2, description, created_at, last_modified FROM dbo.target_pcs ORDER BY pc_name OFFSET %s ROWS FETCH NEXT %s ROWS ONLY"
    pagination = _get_pagination_data(q_count, q_data, page, per_page)
    return render_template('admin/manage_target_pcs.html', pcs=pagination['items'], pagination=pagination, title="대상 PC 관리")

@admin_bp.route('/pcs/add', methods=['GET', 'POST'])
@ip_auth_required('admin')
def add_target_pc():
    form = TargetPCForm()
    if form.validate_on_submit(): # WTForms의 기본 유효성 검사 우선 통과 후
        cleaned_address2 = None
        try:
            # address2에 대한 추가적인 유효성 검사 (세미콜론으로 구분된 IP 목록)
            cleaned_address2 = validate_and_clean_ip_list_string(form.address2.data)
        except ValidationError as ve: # validate_and_clean_ip_list_string 에서 발생한 오류
            form.address2.errors.append(str(ve)) # 해당 폼 필드에 오류 메시지 추가
            # flash(str(ve), 'error') # flash 메시지로도 알릴 수 있음
            # 오류 발생 시, 현재 폼 데이터와 함께 템플릿을 다시 렌더링
            return render_template('admin/edit_target_pc.html', form=form, title="새 PC 추가")

        conn = None
        try:
            conn = get_db_connection();
            with conn.cursor() as cursor: sql = "INSERT INTO dbo.target_pcs (pc_name, address1, address2, description) VALUES (%s, %s, %s, %s)"; cursor.execute(sql, (form.pc_name.data, form.address1.data, cleaned_address2, form.description.data))
            conn.commit(); flash(f"PC '{form.pc_name.data}' 추가 성공.", 'success'); return redirect(url_for('admin.manage_target_pcs'))
        except pymssql.IntegrityError as ie:
            if conn: conn.rollback(); msg = f"PC 이름 '{form.pc_name.data}' 중복." if "UNIQUE KEY" in str(ie).upper() or "duplicate key" in str(ie) else f"DB 제약 위반: {str(ie)[:100]}"; flash(msg, 'error'); current_app.logger.error(f"Add TargetPC IntErr: {ie}", exc_info=False)
        except Exception as e:
            if conn: conn.rollback(); flash(f"PC 추가 오류: {str(e)[:100]}", 'error'); current_app.logger.error(f"Add TargetPC Err: {e}", exc_info=True)
            
    return render_template('admin/edit_target_pc.html', form=form, title="새 PC 추가")

@admin_bp.route('/pcs/edit/<int:pc_id>', methods=['GET', 'POST'])
@ip_auth_required('admin')
def edit_target_pc(pc_id):
    conn = None; pc_data = None
    try:
        conn = get_db_connection();
        with conn.cursor() as cursor: cursor.execute("SELECT id, pc_name, address1, address2, description FROM dbo.target_pcs WHERE id = %d", (pc_id,)); pc_data = cursor.fetchone()
    except Exception as e: flash("PC 정보 로드 오류.", "error"); current_app.logger.error(f"Edit PC (GET) ID {pc_id} Err: {e}", exc_info=True); return redirect(url_for('admin.manage_target_pcs'))
    if not pc_data: flash(f"PC ID {pc_id} 없음.", "error"); return redirect(url_for('admin.manage_target_pcs'))
    
    # GET 요청 시에는 DB 데이터로 폼을 채우고, POST 요청 시에는 제출된 데이터로 폼 객체 생성
    form = TargetPCForm(request.form if request.method == 'POST' else None, data=pc_data if request.method == 'GET' else None)
    # 또는 form = TargetPCForm(obj=pc_data_object) 형태로 객체를 전달할 수도 있으나, pymssql 결과는 딕셔너리이므로 data 인자가 적합
    # POST 시에는 form = TargetPCForm() 으로 새 폼을 만들고 validate_on_submit()이 데이터를 채움.
    # GET 시에는 form = TargetPCForm(data=pc_data)로 기존 값을 채움.

    if request.method == 'POST' and form.validate(): # validate() 또는 validate_on_submit()
        cleaned_address2 = None
        try:
            cleaned_address2 = validate_and_clean_ip_list_string(form.address2.data)
        except ValidationError as ve:
            form.address2.errors.append(str(ve))
            # 오류가 있는 폼을 다시 렌더링해야 하므로, pc_data를 다시 전달 (또는 form.pc_name.data 등 사용)
            return render_template('admin/edit_target_pc.html', form=form, title=f"PC 정보 수정: {pc_data['pc_name']}", pc=pc_data)

        try:
            if conn is None or getattr(conn, '_closed', True): conn = get_db_connection()
            with conn.cursor() as cursor:
                sql = "UPDATE dbo.target_pcs SET pc_name = %s, address1 = %s, address2 = %s, description = %s WHERE id = %d"
                cursor.execute(sql, (form.pc_name.data, form.address1.data, cleaned_address2, form.description.data, pc_id))
            conn.commit(); flash(f"PC '{form.pc_name.data}' 수정 성공.", 'success'); return redirect(url_for('admin.manage_target_pcs'))
        except pymssql.IntegrityError as ie:
            if conn: conn.rollback(); msg = f"PC 이름 '{form.pc_name.data}' 중복." if "UNIQUE KEY" in str(ie).upper() or "duplicate key" in str(ie) else f"DB 제약 위반: {str(ie)[:100]}"; flash(msg, 'error'); current_app.logger.error(f"Edit PC ID {pc_id} IntErr: {ie}", exc_info=False)
        except Exception as e:
            if conn: conn.rollback(); flash(f"PC 수정 오류: {str(e)[:100]}", 'error'); current_app.logger.error(f"Edit PC ID {pc_id} Err: {e}", exc_info=True)
            
    # GET 요청이거나 POST 요청에서 유효성 검사 실패 시
    return render_template('admin/edit_target_pc.html', form=form, title=f"PC 정보 수정: {pc_data['pc_name']}", pc=pc_data)

# ... (delete_target_pc 및 나머지 AllowedUserIP, AdminIP, CalendarException 관리 라우트들은 이전 답변 #49과 동일하게 유지) ...
# (이 부분은 매우 길기 때문에 생략합니다. 이전 답변 #49의 전체 코드를 참조하여 이 파일의 나머지 부분을 구성해주세요.)
# 아래는 달력 예외 관리의 마지막 부분만 예시로 남깁니다. (이 부분도 #49 코드와 동일)
@admin_bp.route('/calendar_exceptions/delete/<string:date_str>', methods=['POST'])
@ip_auth_required('admin')
def delete_calendar_exception(date_str):
    conn = None; year_to_redirect = dt_datetime.now().year; month_to_redirect = dt_datetime.now().month
    try:
        date_obj = dt_datetime.strptime(date_str, '%Y-%m-%d').date()
        year_to_redirect = date_obj.year; month_to_redirect = date_obj.month
        conn = get_db_connection()
        with conn.cursor() as cursor:
            sql = "DELETE FROM dbo.work_calendar_exceptions WHERE exception_date = %s"; cursor.execute(sql, (date_obj.strftime('%Y-%m-%d'),)); rows_deleted = cursor.rowcount
        conn.commit()
        if rows_deleted > 0: flash(f"날짜 {date_str} 예외 삭제 성공.", 'success')
        else: flash(f"날짜 {date_str} 예외 없음.", 'warning')
    except ValueError: flash(f"잘못된 날짜 형식: {date_str}", 'error'); current_app.logger.warning(f"Invalid date for delete: {date_str}")
    except Exception as e:
        if conn: conn.rollback(); flash(f"예외 날짜 삭제 오류: {e}", 'error'); current_app.logger.error(f"Delete CalendarEx for {date_str} Error: {e}", exc_info=True)
    return redirect(url_for('admin.manage_calendar_exceptions', year=year_to_redirect, month=month_to_redirect))

app/routes_admin.py 주요 변경 사항:

from wtforms.validators import ValidationError 추가: 파일 상단에 ValidationError 클래스를 임포트했습니다.
validate_and_clean_ip_list_string 함수 내 raise ValidationError(...): 이 부분은 이제 정상적으로 ValidationError 예외를 발생시킬 수 있습니다.
add_target_pc 및 edit_target_pc 함수 내 try-except ValidationError 블록:
validate_and_clean_ip_list_string 함수 호출 부분을 try-except ValidationError as ve: 블록으로 감쌌습니다.
ValidationError가 발생하면 (즉, address2에 입력된 IP 목록 중 유효하지 않은 IP가 있으면), form.address2.errors.append(str(ve))를 통해 해당 폼 필드(address2)에 오류 메시지를 추가합니다.
그 후, 오류가 포함된 form 객체와 함께 edit_target_pc.html (또는 add_target_pc의 경우에도 동일 템플릿 사용) 템플릿을 다시 렌더링하여 사용자에게 오류를 보여주고 수정을 유도합니다. flash(str(ve), 'error')를 사용하여 상단에 알림 메시지를 표시할 수도 있습니다.
폼 객체 생성 방식 (Edit 시): edit_target_pc 함수에서 GET 요청 시 DB에서 가져온 데이터(pc_data, 딕셔너리 형태)를 폼에 채울 때 TargetPCForm(data=pc_data)를 사용하도록 명시했습니다. POST 요청 시에는 TargetPCForm() (또는 TargetPCForm(request.form))을 사용하여 제출된 데이터로 폼을 초기화합니다. 위 코드에서는 form = TargetPCForm(request.form if request.method == 'POST' else None, data=pc_data if request.method == 'GET' else None)와 같이 좀 더 명확하게 분리하거나, form = TargetPCForm(obj=MyPCObject(pc_data)) 와 같이 객체를 사용하는 방법도 있지만, data= 인자로 딕셔너리를 전달하는 것이 WTForms에서 일반적입니다. 더 간단하게는 form = TargetPCForm(data=pc_data) if request.method == 'GET' else TargetPCForm() 로 하고, POST 시에는 form.validate_on_submit()이 request.form 데이터를 자동으로 로드하게 합니다.
생략된 코드에 대한 참고:
위 코드에서 delete_target_pc 이하의 다른 관리 기능 라우트(허용 사용자 IP, 관리자 IP, 달력 예외 목록 표시 등)는 이전 답변(#49)에서 제공된 pymssql 버전 코드를 그대로 사용하시면 됩니다. 지면 관계상 반복되는 부분을 생략했습니다. 만약 routes_admin.py의 모든 라우트가 포함된 완전한 전체 파일이 다시 필요하시면 요청해주세요. 지금은 address2 다중 IP 유효성 검사 오류 처리와 관련된 add_target_pc, edit_target_pc 함수 위주로 수정 사항을 반영했습니다.

이 수정된 app/routes_admin.py 파일을 적용하시면, address2 필드에 잘못된 IP 주소 형식을 입력했을 때 더 이상 서버 오류(NameError)가 발생하지 않고, 해당 입력 필드 옆이나 flash 메시지를 통해 사용자에게 "유효한 IP 주소 형식이 아닙니다"와 같은 오류가 안내될 것입니다.

다시 한번 테스트해보시고 결과를 알려주세요!