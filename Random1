unexpected utf-8 bom line 1 column 1 char 0" 오류 메시지를 정확히 알려주셔서 감사합니다! 이 메시지는 Flask 웹 앱의 Python 코드가 SAgentM.App 에이전트로부터 받은 응답 JSON 문자열을 파싱하려고 할 때, 문자열 가장 첫 부분(line 1, column 1, char 0)에서 예기치 않은 UTF-8 BOM(Byte Order Mark) 문자를 만났다는 매우 구체적인 오류입니다.

UTF-8 BOM이란?
BOM (\ufeff 유니코드 문자, 16진수로는 EF BB BF)은 텍스트 데이터가 UTF-8로 인코딩되었음을 나타내기 위해 파일이나 스트림의 가장 앞에 추가될 수 있는 특수한 문자 시퀀스입니다.

문제 원인:

Python의 표준 json.loads() 함수는 JSON 문자열 시작 부분에 BOM이 오는 것을 허용하지 않습니다. JSON 표준 사양에는 BOM이 포함되어 있지 않기 때문입니다.
SAgentM.App (C# 에이전트)에서 응답을 보낼 때 StreamWriter(stream, Encoding.UTF8, ...)를 사용하고 있는데, Encoding.UTF8의 기본 동작은 BOM을 쓰지 않는 것입니다. 그럼에도 불구하고 어떤 이유로든 (예: 특정 .NET Framework 버전/환경의 미묘한 차이 또는 다른 요인) 응답 데이터 맨 앞에 BOM이 포함되어 Flask로 전송된 것으로 보입니다.
해결 방안:
Flask 웹 앱의 app/socket_client.py 파일에서, 에이전트로부터 응답을 받은 후 JSON으로 파싱하기 직전에 이 BOM 문자를 명시적으로 제거하도록 코드를 수정합니다.

수정: app/socket_client.py (UTF-8 BOM 제거 로직 추가)
send_command_to_agent 함수 내에서 sock.recv()로 데이터를 받고 decode('utf-8') 한 직후에 BOM을 확인하고 제거하는 코드를 추가합니다.

Python

# scontrol_flask_web/app/socket_client.py
import socket
import json
import uuid
from datetime import datetime, timezone
from flask import current_app

AGENT_PORT = 4026
SOCKET_TIMEOUT = 7.0 # 초 단위

def send_command_to_agent(target_ip, command_packet_dict):
    response_data = {
        'success': False, 'message': 'An unexpected error occurred.',
        'raw_response': None, 'packet_id': command_packet_dict.get('PacketId')
    }

    if 'PacketId' not in command_packet_dict or not command_packet_dict['PacketId']:
        command_packet_dict['PacketId'] = str(uuid.uuid4())
    response_data['packet_id'] = command_packet_dict['PacketId']

    if 'TimestampUtc' not in command_packet_dict or not command_packet_dict['TimestampUtc']:
        command_packet_dict['TimestampUtc'] = datetime.now(timezone.utc).isoformat(timespec='milliseconds').replace('+00:00', 'Z')
    
    json_request_str = ""; json_response_raw_str = "" # 초기화
    log_prefix = f"[SocketClient][PktID: {response_data['packet_id']}] Target: {target_ip}:{AGENT_PORT}"

    try:
        json_request_str = json.dumps(command_packet_dict)
        current_app.logger.debug(f"{log_prefix} - 전송 시도: {json_request_str}")

        with socket.socket(socket.AF_INET, socket.SOCK_STREAM) as sock:
            sock.settimeout(SOCKET_TIMEOUT)
            sock.connect((target_ip, AGENT_PORT))
            current_app.logger.info(f"{log_prefix} - 에이전트 연결 성공.")
            sock.sendall((json_request_str + '\n').encode('utf-8'))
            current_app.logger.info(f"{log_prefix} - 명령 전송 완료. 응답 대기 중...")

            buffer = b''
            try:
                while True:
                    chunk = sock.recv(1024)
                    if not chunk:
                        current_app.logger.warning(f"{log_prefix} - 에이전트 연결 닫힘 또는 데이터 없음.")
                        if not buffer: response_data['message'] = "에이전트로부터 빈 응답 (연결 종료됨)."
                        break 
                    buffer += chunk
                    if b'\n' in buffer:
                        json_response_raw_str_bytes, _, _ = buffer.partition(b'\n')
                        json_response_raw_str = json_response_raw_str_bytes.decode('utf-8').strip() # strip()으로 앞뒤 공백 제거
                        break
            except socket.timeout:
                response_data['message'] = f"에이전트({target_ip}:{AGENT_PORT}) 응답 대기 시간 초과."
                current_app.logger.error(response_data['message'])
                return response_data # 타임아웃 시 여기서 반환
            
            # --- UTF-8 BOM 제거 로직 추가 ---
            BOM_UTF8 = '\ufeff' # 유니코드 BOM 문자
            if json_response_raw_str and json_response_raw_str.startswith(BOM_UTF8):
                current_app.logger.warning(f"{log_prefix} - 수신된 응답에서 UTF-8 BOM을 감지하여 제거합니다.")
                json_response_raw_str = json_response_raw_str.lstrip(BOM_UTF8)
            # --- UTF-8 BOM 제거 로직 끝 ---

            current_app.logger.debug(f"{log_prefix} - 수신 원본 응답 (BOM 처리 후): >>>{json_response_raw_str}<<<")

            if not json_response_raw_str:
                response_data['message'] = f"에이전트({target_ip}:{AGENT_PORT})로부터 빈 응답을 받았습니다 (BOM 처리 후)."
                current_app.logger.error(response_data['message'])
                return response_data

            # 첫 번째 JSON 파싱 (전체 CommandPacket)
            try:
                response_packet_from_agent = json.loads(json_response_raw_str)
            except json.JSONDecodeError as je_outer:
                response_data['message'] = f"에이전트 전체 응답 JSON 형식 오류: {je_outer.msg} (at pos {je_outer.pos}). 원본: {json_response_raw_str}"
                current_app.logger.error(response_data['message'], exc_info=True)
                return response_data # 여기서 반환
            
            response_data['success'] = True 
            response_data['message'] = "에이전트로부터 응답을 성공적으로 수신했습니다."
            response_data['raw_response'] = response_packet_from_agent 
            current_app.logger.info(f"{log_prefix} - 응답 수신 및 전체 패킷 파싱 성공: {response_packet_from_agent.get('CommandName')}")

    except socket.timeout:
        response_data['message'] = f"에이전트({target_ip}:{AGENT_PORT}) 연결 시간 초과."
        current_app.logger.error(response_data['message'])
    except socket.error as se:
        response_data['message'] = f"에이전트({target_ip}:{AGENT_PORT}) 통신 소켓 오류: {se}"
        current_app.logger.error(response_data['message'])
    # JSONDecodeError는 위에서 이미 처리했으므로 여기서는 일반 Exception으로
    except Exception as e:
        response_data['message'] = f"에이전트({target_ip}:{AGENT_PORT})와 통신 중 예기치 않은 오류: {e}"
        current_app.logger.error(response_data['message'], exc_info=True)
        
    return response_data
app/socket_client.py의 주요 변경 사항:

BOM 문자 정의: BOM_UTF8 = '\ufeff' 상수를 정의했습니다.
BOM 제거 로직: sock.recv()로 데이터를 받고 decode('utf-8')한 json_response_raw_str 문자열의 시작 부분에 이 BOM_UTF8 문자가 있는지 확인합니다 (startswith()). 만약 있다면, lstrip(BOM_UTF8)을 사용하여 문자열 앞에서 BOM을 제거합니다.
로깅 강화: BOM 제거 시 로그를 남기고, BOM 제거 후의 문자열을 다시 로그로 남겨 확인을 용이하게 했습니다.
첫 번째 json.loads()에 대한 예외 처리 추가: 전체 CommandPacket을 파싱하는 json.loads(json_response_raw_str) 호출도 try-except json.JSONDecodeError 블록으로 감싸서, 만약 여기서도 BOM이나 다른 이유로 오류가 발생하면 좀 더 상세한 오류 메시지를 반환하도록 했습니다.
이 수정된 app/socket_client.py 파일을 Flask 애플리케이션에 적용해 보십시오. 이 변경으로 인해 SAgentM.App 에이전트가 응답 시작 부분에 BOM을 포함하여 보내더라도 Flask 측에서 이를 제거하고 정상적으로 JSON을 파싱할 수 있게 되어 "unexpected utf-8 bom" 오류가 해결될 것으로 기대합니다.