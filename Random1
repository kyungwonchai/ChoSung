아래는 로그를 ListBox에 표시하며, 최대 100개의 로그만 유지되도록 수정된 WPF 애플리케이션의 전체 코드입니다.

MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Diagnostics;
using System.IO;
using System.Windows;
using System.Windows.Threading;

namespace WpfProcessMonitor
{
    public partial class MainWindow : Window
    {
        private DispatcherTimer checkTimer;
        private DispatcherTimer forceRestartTimer;
        private string processListPath = @"c:\processfiles.txt";
        private const int MaxLogCount = 100;
        private List<string> logMessages = new List<string>();

        public MainWindow()
        {
            InitializeComponent();

            // 1분마다 프로세스 상태를 확인하기 위한 타이머 설정
            checkTimer = new DispatcherTimer();
            checkTimer.Interval = TimeSpan.FromMinutes(1);
            checkTimer.Tick += CheckProcesses;
            checkTimer.Start();

            // 1시간마다 프로세스를 강제 종료하고 재시작하기 위한 타이머 설정
            forceRestartTimer = new DispatcherTimer();
            forceRestartTimer.Interval = TimeSpan.FromHours(1);
            forceRestartTimer.Tick += ForceRestartProcesses;
            forceRestartTimer.Start();

            // 시작시 상태 확인
            CheckProcesses(null, null);
        }

        private void CheckProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processNames = File.ReadAllLines(processListPath);

                    foreach (string processName in processNames)
                    {
                        string trimmedProcessName = processName.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessName))
                            continue;

                        Process[] processes = Process.GetProcessesByName(trimmedProcessName);

                        if (processes.Length == 0)
                        {
                            // 프로세스가 실행 중이지 않으면 실행
                            Process.Start(@"c:\abc\proc1.exe");
                            LogMessage($"{trimmedProcessName}가 실행되지 않아 proc1.exe를 실행했습니다.");
                        }
                        else
                        {
                            LogMessage($"{trimmedProcessName}가 이미 실행 중입니다.");
                        }
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void ForceRestartProcesses(object sender, EventArgs e)
        {
            try
            {
                if (File.Exists(processListPath))
                {
                    string[] processNames = File.ReadAllLines(processListPath);

                    foreach (string processName in processNames)
                    {
                        string trimmedProcessName = processName.Trim();
                        if (string.IsNullOrEmpty(trimmedProcessName))
                            continue;

                        Process[] processes = Process.GetProcessesByName(trimmedProcessName);

                        if (processes.Length > 0)
                        {
                            // 프로세스 강제 종료
                            foreach (Process proc in processes)
                            {
                                proc.Kill();
                                proc.WaitForExit();
                            }
                            LogMessage($"{trimmedProcessName}를 강제 종료했습니다.");
                        }

                        // 프로세스가 종료된 것을 확인한 후 다시 실행
                        Process.Start(@"c:\abc\proc1.exe");
                        LogMessage($"{trimmedProcessName}를 재실행했습니다.");
                    }
                }
                else
                {
                    LogMessage($"파일이 존재하지 않습니다: {processListPath}");
                }
            }
            catch (Exception ex)
            {
                LogMessage("오류 발생: " + ex.Message);
                // 예외 처리 코드 추가 (로그 기록 등)
            }
        }

        private void LogMessage(string message)
        {
            Dispatcher.Invoke(() =>
            {
                // 로그 메시지를 추가하고, 최대 100개까지만 유지
                logMessages.Add($"{DateTime.Now}: {message}");

                if (logMessages.Count > MaxLogCount)
                {
                    logMessages.RemoveAt(0); // 가장 오래된 로그 삭제
                }

                // ListBox에 로그를 표시
                LogListBox.ItemsSource = null;
                LogListBox.ItemsSource = logMessages;
                LogListBox.ScrollIntoView(logMessages[logMessages.Count - 1]);
            });
        }
    }
}
MainWindow.xaml
xml
코드 복사
<Window x:Class="WpfProcessMonitor.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Process Monitor" Height="350" Width="525">
    <Grid>
        <ListBox Name="LogListBox"
                 VerticalScrollBarVisibility="Auto" 
                 HorizontalScrollBarVisibility="Auto"
                 Margin="10"/>
    </Grid>
</Window>
코드 설명:
로그 관리: logMessages라는 List<string> 컬렉션을 사용하여 로그 메시지를 관리합니다. 로그가 추가될 때마다 LogListBox에 표시되며, 로그가 100개를 초과하면 가장 오래된 로그가 삭제됩니다.

Dispatcher.Invoke 사용: LogMessage 메서드에서 UI 스레드에서 안전하게 ListBox를 업데이트하기 위해 Dispatcher.Invoke를 사용합니다.

로그 최대 개수 제한: 로그의 최대 개수는 MaxLogCount 상수로 정의되며, 현재 100개로 설정되어 있습니다. 이 수를 넘어가면 가장 오래된 로그가 자동으로 제거됩니다.

UI 업데이트: ListBox의 ItemsSource를 갱신하여 로그 메시지를 업데이트하고, 최신 로그가 항상 보이도록 ScrollIntoView 메서드를 사용하여 스크롤을 관리합니다.

이 코드는 c:\processfiles.txt 파일에 명시된 프로세스 목록을 주기적으로 모니터링하고, 각 프로세스의 상태 변화와 관련된 로그를 ListBox에 표시합니다. 최대 100개의 로그만 유지되며, 새로운 로그가 추가되면 자동으로 스크롤됩