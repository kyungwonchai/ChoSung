Compose의 LazyColumn에서 items를 사용할 때 발생하는 문제와 데이터 클래스의 필드 접근 문제를 해결하기 위해 다음과 같이 코드를 수정하겠습니다.

Compose의 LazyColumn에서 items 함수를 사용하려면 import가 필요합니다. 또한, 데이터 클래스의 필드 접근을 올바르게 처리하도록 코드를 확인하겠습니다.

MainActivity.kt
kotlin
코드 복사
package com.example.mssqlimageapp

import android.graphics.Bitmap
import android.graphics.BitmapFactory
import android.os.Bundle
import android.util.Log
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.Image
import androidx.compose.foundation.gestures.detectTransformGestures
import androidx.compose.foundation.layout.*
import androidx.compose.foundation.lazy.LazyColumn
import androidx.compose.foundation.lazy.items
import androidx.compose.material.*
import androidx.compose.runtime.*
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.asImageBitmap
import androidx.compose.ui.input.pointer.pointerInput
import androidx.compose.ui.unit.IntOffset
import androidx.compose.ui.unit.dp
import com.example.mssqlimageapp.ui.theme.MSSQLImageAppTheme
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.sql.Connection
import java.sql.DriverManager
import java.sql.ResultSet
import kotlin.math.roundToInt

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MSSQLImageAppTheme {
                Surface(color = MaterialTheme.colors.background) {
                    ImageListScreen()
                }
            }
        }
    }
}

@Composable
fun ImageListScreen() {
    var imageList by remember { mutableStateOf(listOf<ImageData>()) }
    var selectedImage by remember { mutableStateOf<Bitmap?>(null) }

    val scope = rememberCoroutineScope()

    Column {
        Button(
            onClick = {
                scope.launch {
                    imageList = fetchDataFromDatabase()
                }
            },
            modifier = Modifier.padding(16.dp)
        ) {
            Text("Fetch Data")
        }
        LazyColumn(modifier = Modifier.weight(1f)) {
            items(imageList) { imageData ->
                Row(
                    modifier = Modifier
                        .fillMaxWidth()
                        .padding(8.dp)
                ) {
                    Text(imageData.imageTitle, modifier = Modifier.weight(1f))
                    Text(imageData.datetime, modifier = Modifier.weight(1f))
                    Button(onClick = {
                        scope.launch {
                            selectedImage = fetchImageFromDatabase(imageData.imageTitle, imageData.datetime)
                        }
                    }) {
                        Text("Load Image")
                    }
                }
            }
        }
        selectedImage?.let { bitmap ->
            ImageDisplayScreen(bitmap = bitmap)
        }
    }
}

data class ImageData(val imageTitle: String, val datetime: String)

suspend fun fetchDataFromDatabase(): List<ImageData> {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.211.211.211:2111;databaseName=yourDatabase",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.createStatement()
            val resultSet: ResultSet = statement.executeQuery("EXEC yourProcedure")

            val imageList = mutableListOf<ImageData>()
            while (resultSet.next()) {
                val imageTitle = resultSet.getString("imagetitle")
                val datetime = resultSet.getString("datetime1")
                imageList.add(ImageData(imageTitle, datetime))
            }
            connection.close()
            imageList
        } catch (e: Exception) {
            Log.e("Database", "Error fetching data", e)
            emptyList()
        }
    }
}

suspend fun fetchImageFromDatabase(imageTitle: String, datetime: String): Bitmap? {
    return withContext(Dispatchers.IO) {
        try {
            val connection: Connection = DriverManager.getConnection(
                "jdbc:jtds:sqlserver://10.211.211.211:2111;databaseName=yourDatabase",
                "yourUsername",
                "yourPassword"
            )
            val statement = connection.prepareCall("{call yourImageProcedure(?, ?)}")
            statement.setString(1, imageTitle)
            statement.setString(2, datetime)
            val resultSet: ResultSet = statement.executeQuery()
            
            var bitmap: Bitmap? = null
            if (resultSet.next()) {
                val blob = resultSet.getBlob("imageColumn")
                val byteArray = blob.binaryStream.readBytes()
                bitmap = BitmapFactory.decodeByteArray(byteArray, 0, byteArray.size)
            }
            connection.close()
            bitmap
        } catch (e: Exception) {
            Log.e("Database", "Error fetching image", e)
            null
        }
    }
}

@Composable
fun ImageDisplayScreen(bitmap: Bitmap) {
    var scale by remember { mutableStateOf(1f) }
    var offset by remember { mutableStateOf(Offset.Zero) }
    
    Box(modifier = Modifier
        .fillMaxSize()
        .pointerInput(Unit) {
            detectTransformGestures { _, pan, zoom, _ ->
                scale *= zoom
                offset = Offset(offset.x + pan.x, offset.y + pan.y)
            }
        }
    ) {
        Image(
            bitmap = bitmap.asImageBitmap(),
            contentDescription = null,
            modifier = Modifier
                .offset { IntOffset(offset.x.roundToInt(), offset.y.roundToInt()) }
                .graphicsLayer(
                    scaleX = scale,
                    scaleY = scale,
                    translationX = offset.x,
                    translationY = offset.y
                )
        )
    }
}
Theme.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.foundation.isSystemInDarkTheme
import androidx.compose.material.*
import androidx.compose.runtime.Composable
import androidx.compose.ui.graphics.Color

private val DarkColorPalette = darkColors(
    primary = Color.Red,
    primaryVariant = Color(0xFF8B0000), // DarkRed에 대한 RGB 코드 사용
    secondary = Color.Red
)

private val LightColorPalette = lightColors(
    primary = Color.Red,
    primaryVariant = Color(0xFF8B0000), // DarkRed에 대한 RGB 코드 사용
    secondary = Color.Red
)

@Composable
fun MSSQLImageAppTheme(
    darkTheme: Boolean = isSystemInDarkTheme(),
    content: @Composable () -> Unit
) {
    val colors = if (darkTheme) {
        DarkColorPalette
    } else {
        LightColorPalette
    }

    MaterialTheme(
        colors = colors, // colors 부분이 빨간색으로 표시됨
        typography = Typography,
        shapes = Shapes, // shapes 부분이 빨간색으로 표시됨
        content = content
    )
}
Shapes.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.foundation.shape.RoundedCornerShape
import androidx.compose.material.Shapes
import androidx.compose.ui.unit.dp

val Shapes = Shapes(
    small = RoundedCornerShape(4.dp),
    medium = RoundedCornerShape(4.dp),
    large = RoundedCornerShape(0.dp)
)
Typography.kt
kotlin
코드 복사
package com.example.mssqlimageapp.ui.theme

import androidx.compose.material.Typography
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.text.font.FontFamily
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.sp

val Typography = Typography(
    body1 = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 16.sp
    )
    /* Other default text styles to override
    button = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.W500,
        fontSize = 14.sp
    ),
    caption = TextStyle(
        fontFamily = FontFamily.Default,
        fontWeight = FontWeight.Normal,
        fontSize = 12.sp
    )
    */
)
proguard-rules.pro
pro
코드 복사
# ProGuard rules for JDBC driver
-keep class net.sourceforge.jtds.** { *; }
-keep class net.sourceforge.jtds.jdbc.** { *; }
이제 앱을 빌드하고 실행하여 문제가 해결되었는지 확인해보세요. LazyColumn에서 items를 사용하는 부분과 데이터 클래스 필드 접근 문제를 해결했습니다.