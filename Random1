래는 주어진 요구사항을 반영하여 수정한 FileCheckerMES20 클래스입니다. 변경 사항은 다음과 같습니다:

변경 사항:
클래스 이름을 FileCheckerMES20로 변경했습니다.
ComportManager _comPortPLC 변수를 추가하고, 생성자에서 comPortManager를 받아 _comPortPLC에 할당합니다.
msgvs.Instance.LogT2 함수를 주요 지점마다 넣어 로그 내용을 출력하여 진행 상황을 알 수 있게 했습니다.
파일을 읽기-쓰기 공유 모드로 열어서 다른 프로세스가 쓰고 있을 때도 읽을 수 있게 했습니다.
마지막으로 PLAN Selected가 등장한 지점부터 실시간 감시를 시작합니다.
최종 수정된 코드 (FileCheckerMES20.cs)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Collections.ObjectModel;
using System.Windows.Threading;

namespace GumiChecker
{
    public class FileCheckerMES20
    {
        // 로그 파일이 위치한 디렉토리 경로
        private string _logDirectory = @"C:\G-MES2.0\GUMI_WEB\log";

        // 정규식 패턴: 파일 이름 규칙을 정의 (IP 주소 형식 + "_M4OI"로 시작)
        private string _filePattern = @"^\d{1,3}(\.\d{1,3}){3}_M4OI[A-Za-z0-9]+_gumi[A-Za-z0-9]+_(\d{2})\.log$";

        // 타이머: 주기적으로 파일 변경을 확인하기 위한 타이머
        private DispatcherTimer _timer;

        // 현재 감시 중인 파일 경로 (가장 최근 파일)
        private string _currentMonitoredFile;

        // 마지막 감지된 PLAN Selected 시간
        private DateTime _lastPlanSelectedDate;

        // 마지막으로 감시 중인 파일의 수정 시간
        private DateTime _lastWriteTime;

        // 현재 처리 중인 ProductOrder 객체
        private ProductOrderModel _currentProductOrder;

        // DataGrid와 바인딩할 ObservableCollection (주문 목록을 실시간으로 갱신)
        private ObservableCollection<ProductOrderModel> _productOrders;

        // 파일에서 마지막으로 `PLAN Selected`가 나온 위치
        private long _lastPlanSelectedPosition;

        // 첫 실행 여부 체크
        private bool _isFirstExecution;

        // ComportManager 인스턴스
        private ComportManager _comPortPLC;

        // 생성자: 타이머를 초기화하고 설정하는 작업 (comPortManager를 받아서 저장)
        public FileCheckerMES20(ObservableCollection<ProductOrderModel> productOrders, ComportManager comPortManager)
        {
            _productOrders = productOrders;
            _comPortPLC = comPortManager; // 받아온 comPortManager를 저장
            _isFirstExecution = true;

            // 타이머 초기화 및 설정 (1초마다 파일 상태를 확인)
            _timer = new DispatcherTimer
            {
                Interval = TimeSpan.FromSeconds(1) // 1초마다 Tick 발생
            };
            _timer.Tick += CheckFiles; // 주기적으로 디렉토리 내 파일들을 확인
            _timer.Start(); // 타이머 시작

            // 로그: 타이머 시작 알림
            msgvs.Instance.LogT2("FileCheckerMES20: 타이머가 시작되었습니다.");

            // 처음 실행할 때 가장 최근 파일을 감시 대상으로 설정
            _currentMonitoredFile = GetLatestLogFile(); // 최근 파일을 가져옴
            _lastWriteTime = _currentMonitoredFile != null 
                ? File.GetLastWriteTime(_currentMonitoredFile) 
                : DateTime.MinValue; // 파일이 없는 경우 초기값 설정

            // 로그: 파일 감시 시작 알림
            msgvs.Instance.LogT2($"FileCheckerMES20: {_currentMonitoredFile} 파일 감시를 시작합니다.");

            // 마지막 PLAN Selected 감지 시간을 현재 시간으로 초기화
            _lastPlanSelectedDate = DateTime.Now;

            // PLAN Selected 위치 초기화
            _lastPlanSelectedPosition = 0;
        }

        // 주기적으로 디렉토리 내 파일을 확인하는 메소드 (타이머에 의해 1초마다 호출)
        private void CheckFiles(object sender, EventArgs e)
        {
            // 현재 디렉토리에서 가장 최신 파일을 확인
            string latestFile = GetLatestLogFile();

            // 새로운 파일이 감지되었거나 현재 감시 중인 파일이 변경된 경우
            if (_currentMonitoredFile == null || latestFile != _currentMonitoredFile)
            {
                // 새로운 파일로 감시 대상을 변경
                _currentMonitoredFile = latestFile;
                _lastWriteTime = File.GetLastWriteTime(_currentMonitoredFile); // 마지막 수정 시간 업데이트

                // 로그: 새로운 파일 감시 시작 알림
                msgvs.Instance.LogT2($"FileCheckerMES20: 새로운 파일 감시 시작 -> {_currentMonitoredFile}");
            }

            // 처음 실행일 때는 로그 파일에서 `PLAN Selected`가 마지막으로 등장한 부분을 찾음
            if (_isFirstExecution)
            {
                FindLastPlanSelected(_currentMonitoredFile);  // PLAN Selected가 마지막으로 나온 위치를 찾음
                _isFirstExecution = false; // 첫 실행 이후에는 실시간 감시로 전환

                // 로그: 처음 실행 시 PLAN Selected 탐색 완료
                msgvs.Instance.LogT2("FileCheckerMES20: PLAN Selected 탐색 완료.");
            }

            // 현재 감시 중인 파일의 마지막 수정 시간을 확인
            DateTime latestWriteTime = File.GetLastWriteTime(_currentMonitoredFile);

            // 파일이 수정된 경우에만 파일을 읽고 처리
            if (latestWriteTime > _lastWriteTime)
            {
                _lastWriteTime = latestWriteTime; // 마지막 수정 시간 업데이트
                ReadLogFileFromPosition(_currentMonitoredFile); // PLAN Selected 이후부터 읽고 처리

                // 로그: 파일이 변경되어 로그 처리 시작
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 수정 감지 -> {_currentMonitoredFile}");
            }
        }

        // 지정된 경로에서 가장 최근에 수정된 파일을 가져오는 메소드
        private string GetLatestLogFile()
        {
            // 로그: 최신 파일 검색 시작
            msgvs.Instance.LogT2("FileCheckerMES20: 최신 로그 파일 검색 중...");

            // 로그 파일 디렉토리에서 파일 목록을 가져와 패턴에 맞는 파일만 필터링
            var logFiles = new DirectoryInfo(_logDirectory).GetFiles("*.log")
                .Where(f => Regex.IsMatch(f.Name, _filePattern)) // 정규식 패턴에 맞는 파일 필터링
                .OrderByDescending(f => f.LastWriteTime) // 수정 시간을 기준으로 내림차순 정렬
                .ToList();

            // 가장 최근에 수정된 파일의 경로 반환 (없을 경우 null 반환)
            return logFiles.FirstOrDefault()?.FullName;
        }

        // 파일을 처음부터 읽고 마지막으로 나오는 `PLAN Selected`를 찾음
        private void FindLastPlanSelected(string filePath)
        {
            if (filePath == null) return; // 파일이 없으면 처리하지 않음

            try
            {
                // 파일을 읽기-쓰기 공유 모드로 열기
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    string line;
                    long currentPosition = 0; // 현재 파일의 위치
                    _lastPlanSelectedPosition = 0; // 마지막 PLAN Selected 위치 초기화

                    while ((line = streamReader.ReadLine()) != null)
                    {
                        currentPosition = fileStream.Position; // 현재 파일의 포인터 위치 저장

                        if (line.Contains("PLAN Selected"))
                        {
                            // PLAN Selected가 나온 위치를 저장 (마지막으로 나온 위치)
                            _lastPlanSelectedPosition = currentPosition;

                            // 로그: PLAN Selected 감지
                            msgvs.Instance.LogT2($"FileCheckerMES20: PLAN Selected 감지 (위치: {currentPosition})");
                        }

                        ProcessLogLine(line, filePath); // 로그 줄 처리
                    }
                }
            }
            catch (IOException ex)
            {
                // 로그: 오류 발생
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 읽기 중 오류 발생 -> {ex.Message}");
            }
        }

        // PLAN Selected 이후부터 파일을 읽고 처리
        private void ReadLogFileFromPosition(string filePath)
        {
            if (filePath == null) return;

            try
            {
                using (var fileStream = new FileStream(filePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                using (var streamReader = new StreamReader(fileStream))
                {
                    fileStream.Seek(_lastPlanSelectedPosition, SeekOrigin.Begin); // 마지막 PLAN Selected 위치로 이동
                    string line;
                    
                    while ((line = streamReader.ReadLine()) != null)
                    {
                        ProcessLogLine(line, filePath); // 로그 줄 처리
                    }

                    // 최신 로그 위치를 업데이트
                    _lastPlanSelectedPosition = fileStream.Position;

                    // 로그: 파일 처리 완료
                    msgvs.Instance.LogT2($"FileCheckerMES20: 파일 처리 완료 -> {_currentMonitoredFile}");
                }
            }
            catch (IOException ex)
            {
                // 로그: 오류 발생
                msgvs.Instance.LogT2($"FileCheckerMES20: 파일 읽기 중 오류 발생 -> {ex.Message}");
            }
        }

        // 로그 파일의 각 줄을 처리하는 메소드
        private void ProcessLogLine(string line, string filePath)
        {
            // 파일 이름에서 날짜를 추출하여 yyyyMMdd 형식으로 변환
            string fileName = Path.GetFileNameWithoutExtension(filePath);
            string dayString = fileName.Substring(fileName.Length - 2); // 파일 이름의 마지막 두 글자를 날짜로 사용
            string currentYearMonth = DateTime.Now.ToString("yyyyMM"); // 현재 연도와 월을 yyyyMM 형식으로 가져옴
            string fullDate = currentYearMonth + dayString; // yyyyMMdd 형식으로 날짜 조합

            // "PLAN Selected" 라인을 감지했을 때 처리
            if (line.Contains("PLAN Selected"))
            {
                var splitLine = line.Split(' '); // 공백으로 분리하여 제품 주문 번호를 가져옴
                string productOrder = splitLine[1]; // 두 번째 값이 제품 주문 번호

                // 로그: PLAN Selected 처리 중
                msgvs.Instance.LogT2($"FileCheckerMES20: PLAN Selected 처리 중 (주문 번호: {productOrder})");

                // 새로운 주문이거나 다른 주문일 경우 처리
                if (_currentProductOrder == null || _currentProductOrder.ProductOrder != productOrder)
                {
                    // 최근 2일 이내에 PLAN Selected가 감지되지 않은 경우 처리
                    if (DateTime.Now.Subtract(_lastPlanSelectedDate).TotalDays > 2)
                    {
                        _currentProductOrder = new ProductOrderModel
                        {
                            ProductOrder = productOrder,
                            PDate = fullDate, // yyyyMMdd 형식으로 날짜 설정
                            POStatus = "wait" // 주문 상태를 "대기(wait)"로 설정
                        };
                        _productOrders.Add(_currentProductOrder); // 새로운 주문을 목록에 추가

                        // 로그: 새로운 주문 추가
                        msgvs.Instance.LogT2($"FileCheckerMES20: 새로운 주문 추가 (주문 번호: {productOrder})");
                    }

                    // 마지막 PLAN Selected 감지 시간을 현재 시간으로 업데이트
                    _lastPlanSelectedDate = DateTime.Now;
                }
            }
            else if (line.Contains("BasicModel") && _currentProductOrder != null)
            {
                var modelData = line.Split(':')[1].Trim(); // BasicModel 데이터를 추출
                _currentProductOrder.BasicModel = modelData; // 모델 데이터 저장

                // 로그: BasicModel 처리
                msgvs.Instance.LogT2($"FileCheckerMES20: BasicModel 처리 -> {modelData}");
            }
            else if (line.Contains("MB^") && _currentProductOrder != null)
            {
                var mbData = line.Split('^'); // MB^ 데이터를 처리
                _currentProductOrder.PORemain = int.Parse(mbData[1]); // 잔여 수량 설정
                _currentProductOrder.MGCount = int.Parse(mbData[2]); // 매거진 수량 설정

                // 로그: MB^ 처리 (잔여 수량, 매거진 수량)
                msgvs.Instance.LogT2($"FileCheckerMES20: MB^ 처리 -> 잔여 수량: {_currentProductOrder.PORemain}, 매거진 수량: {_currentProductOrder.MGCount}");
            }
            else if (line.Contains("JB^") && _currentProductOrder != null)
            {
                _currentProductOrder.PCount++; // 생산된 제품 개수 증가

                // 로그: JB^ 처리 (생산된 제품 개수)
                msgvs.Instance.LogT2($"FileCheckerMES20: JB^ 처리 -> 생산된 제품 개수: {_currentProductOrder.PCount}");
            }
            else if (line.Contains("FNL^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "stack"; // 상태를 "적재(stack)"로 변경

                // 로그: FNL^ 처리 (상태 변경)
                msgvs.Instance.LogT2($"FileCheckerMES20: FNL^ 처리 -> 상태: {_currentProductOrder.POStatus}");
            }
            else if (line.Contains("JD^") && _currentProductOrder != null)
            {
                _currentProductOrder.POStatus = "out"; // 상태를 "배출(out)"로 변경
                ExecuteOutFunction(); // 배출 처리 호출

                // 로그: JD^ 처리 (배출 수행)
                msgvs.Instance.LogT2($"FileCheckerMES20: JD^ 처리 -> 상태: {_currentProductOrder.POStatus}");
            }
        }

        // 배출 처리를 위한 메소드
        private void ExecuteOutFunction()
        {
            // 배출 처리 로직 구현

            // 로그: 배출 처리 완료
            msgvs.Instance.LogT2("FileCheckerMES20: 배출 처리 완료.");
        }
    }

    // ProductOrderModel 클래스: 제품 주문 정보를 저장하는 모델 클래스
    public class ProductOrderModel
    {
        public string ProductOrder { get; set; } // 제품 주문 번호
        public string BasicModel { get; set; } // 제품 모델 정보
        public int PORemain { get; set; } // 잔여 수량
        public int MGCount { get; set; } // 매거진 당 제품 수량
        public int PCount { get; set; } // 생산된 제품 개수
        public string POStatus { get; set; } // 주문 상태 (대기, 적재, 배출 등)
        public string PDate { get; set; } // 제품 주문 날짜 (yyyyMMdd 형식)
    }
}
설명:
클래스 이름: FileCheckerMES20로 변경되었습니다.
ComportManager: ComportManager 인스턴스를 생성자에서 받아 _comPortPLC에 저장했습니다.
로그 출력: msgvs.Instance.LogT2 함수를 주요 지점마다 추가하여 로그로 진행 상황을 확인할 수 있게 했습니다.
타이머 시작, 파일 감시 시작, 새로운 주문 추가, 각 로그 항목 처리 등에서 로그 출력.
PLAN Selected 위치 추적: 처음 파일을 읽을 때 마지막 PLAN Selected가 나온 위치를 추적하여, 그 위치 이후부터 실시간 로그 감시를 수행합니다.
이 코드는 요청하신 모든 요구 사항을 반영하여, 실시간 감시와 진행 상황 로그 출력이 포함된 구조로 완성되었습니다.