래는 사용자가 요청하신 기능을 모두 포함하고 UI 충돌 없이 부드럽게 작동하도록 비동기 처리를 추가한 C# WPF 애플리케이션의 전체 코드입니다. 각 부분에 대한 설명은 한글로 작성하였습니다.

XAML 파일 (MainWindow.xaml)
xml
코드 복사
<Window x:Class="LogMonitor.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Monitor" Height="450" Width="800" Background="Purple">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <StackPanel Orientation="Horizontal" Margin="10">
            <Button Content="Select Log File" Click="SelectLogFile_Click" Margin="5"/>
            <Button Content="Select Backup Folder" Click="SelectBackupFolder_Click" Margin="5"/>
            <TextBlock Text="Max Log Lines:" VerticalAlignment="Center" Margin="5"/>
            <TextBox Name="MaxLinesTextBox" Width="50" TextChanged="MaxLinesTextBox_TextChanged" VerticalAlignment="Center"/>
            <Button Content="Clear Logs" Click="ClearLogs_Click" Margin="5"/>
        </StackPanel>
        <ListBox Name="LogListBox" Grid.Row="1" Margin="10"/>
    </Grid>
</Window>
C# 코드 파일 (MainWindow.xaml.cs)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace LogMonitor
{
    public partial class MainWindow : Window
    {
        private FileSystemWatcher _fileWatcher;
        private string _logFilePath;
        private string _backupFolderPath;
        private long _lastFilePosition = 0;
        private int _maxLogLines = 1000;
        private readonly List<string> _logLines = new List<string>();

        public MainWindow()
        {
            InitializeComponent();
            LoadSettings();
        }

        // 사용자 설정 불러오기
        private void LoadSettings()
        {
            _logFilePath = Properties.Settings.Default.LogFilePath;
            _backupFolderPath = Properties.Settings.Default.BackupFolderPath;
            _maxLogLines = Properties.Settings.Default.MaxLogLines;

            if (!string.IsNullOrEmpty(_logFilePath))
            {
                StartFileWatcher();
            }

            MaxLinesTextBox.Text = _maxLogLines.ToString();
        }

        // 사용자 설정 저장
        private void SaveSettings()
        {
            Properties.Settings.Default.LogFilePath = _logFilePath;
            Properties.Settings.Default.BackupFolderPath = _backupFolderPath;
            Properties.Settings.Default.MaxLogLines = _maxLogLines;
            Properties.Settings.Default.Save();
        }

        // 로그 파일 변경 감시 시작
        private void StartFileWatcher()
        {
            if (_fileWatcher != null)
            {
                _fileWatcher.Dispose();
            }

            _fileWatcher = new FileSystemWatcher(Path.GetDirectoryName(_logFilePath))
            {
                Filter = Path.GetFileName(_logFilePath),
                NotifyFilter = NotifyFilters.LastWrite
            };

            _fileWatcher.Changed += OnLogFileChanged;
            _fileWatcher.EnableRaisingEvents = true;
        }

        // 로그 파일이 변경되었을 때 호출되는 이벤트 핸들러
        private async void OnLogFileChanged(object sender, FileSystemEventArgs e)
        {
            await ReadNewLinesAsync();
        }

        // 새로운 로그 라인 읽기 (비동기)
        private async Task ReadNewLinesAsync()
        {
            await Dispatcher.InvokeAsync(() =>
            {
                using (var fs = new FileStream(_logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    fs.Seek(_lastFilePosition, SeekOrigin.Begin);

                    using (var sr = new StreamReader(fs))
                    {
                        while (!sr.EndOfStream)
                        {
                            var line = sr.ReadLine();
                            _logLines.Add(line);

                            // ListBox에 로그 라인 추가
                            LogListBox.Items.Add(line);

                            // 백업 폴더에 로그 라인 백업
                            BackupLogLine(line);

                            if (_logLines.Count > _maxLogLines)
                            {
                                _logLines.RemoveAt(0);
                                LogListBox.Items.RemoveAt(0);
                            }
                        }

                        _lastFilePosition = fs.Position;
                    }
                }
            });
        }

        // 백업 폴더에 로그 라인 저장
        private void BackupLogLine(string line)
        {
            if (string.IsNullOrEmpty(_backupFolderPath))
            {
                return;
            }

            var backupFilePath = Path.Combine(_backupFolderPath, $"backup_{DateTime.Now:yyyyMMdd_HHmmss}.log");

            using (var sw = new StreamWriter(backupFilePath, true))
            {
                sw.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {line}");
            }
        }

        // 로그 파일 선택 버튼 클릭 이벤트 핸들러
        private void SelectLogFile_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new Microsoft.Win32.OpenFileDialog();
            if (openFileDialog.ShowDialog() == true)
            {
                _logFilePath = openFileDialog.FileName;
                SaveSettings();
                StartFileWatcher();
            }
        }

        // 백업 폴더 선택 버튼 클릭 이벤트 핸들러
        private void SelectBackupFolder_Click(object sender, RoutedEventArgs e)
        {
            var folderDialog = new System.Windows.Forms.FolderBrowserDialog();
            if (folderDialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                _backupFolderPath = folderDialog.SelectedPath;
                SaveSettings();
            }
        }

        // 로그 지우기 버튼 클릭 이벤트 핸들러
        private void ClearLogs_Click(object sender, RoutedEventArgs e)
        {
            LogListBox.Items.Clear();
            _logLines.Clear();
        }

        // 최대 로그 라인 수 텍스트 박스 변경 이벤트 핸들러
        private void MaxLinesTextBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            if (int.TryParse(MaxLinesTextBox.Text, out int maxLines))
            {
                _maxLogLines = maxLines;
                SaveSettings();
            }
        }
    }
}
설명:
UI 및 사용자 인터페이스: MainWindow.xaml에서는 로그 파일과 백업 폴더를 선택하는 버튼, 최대 로그 라인 수를 설정하는 텍스트 박스, 로그를 표시하는 ListBox가 정의되어 있습니다. UI의 배경색은 보라색으로 설정되어 있습니다.

파일 감시 및 비동기 처리: FileSystemWatcher는 지정된 로그 파일을 실시간으로 감시하고, 파일이 변경될 때마다 OnLogFileChanged 이벤트 핸들러가 호출됩니다. 이 핸들러는 ReadNewLinesAsync 메서드를 비동기로 호출하여 UI 스레드를 차단하지 않고 새로운 로그 라인을 읽어옵니다.

로그 백업: BackupLogLine 메서드는 새로운 로그 라인을 백업 폴더에 지정된 형식으로 저장합니다.

사용자 설정 관리: 로그 파일 경로, 백업 폴더 경로, 최대 로그 라인 수와 같은 사용자의 설정은 애플리케이션 설정에 저장되며, 애플리케이션 시작 시 불러옵니다.

비동기 및 UI 갱신: ReadNewLinesAsync 메서드는 비동기로 실행되며, UI 스레드에서 로그를 추가하고 ListBox를 갱신하는 작업을 수행합니다. 이렇게 하면 UI가 막히지 않