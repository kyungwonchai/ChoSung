eparedStatement와 withContext(Dispatchers.IO)를 사용하여 네트워크 작업을 비동기적으로 수행하는 코드를 제공하겠습니다. 이 코드는 Coroutine을 사용하여 비동기적으로 데이터베이스에 접근하고, 결과를 처리하는 방식으로 수정되었습니다.

수정된 Kotlin 코드
kotlin
코드 복사
package com.dxmxsmd.mobilechecker

import android.Manifest
import android.content.Context
import android.content.pm.PackageManager
import android.net.wifi.WifiManager
import android.os.Bundle
import android.os.Handler
import android.os.Looper
import android.provider.Settings
import android.util.Log
import android.widget.RelativeLayout
import android.widget.TextView
import androidx.activity.ComponentActivity
import androidx.camera.core.*
import androidx.camera.lifecycle.ProcessCameraProvider
import androidx.camera.view.PreviewView
import androidx.core.app.ActivityCompat
import androidx.core.content.ContextCompat
import androidx.camera.camera2.interop.Camera2Interop
import androidx.camera.camera2.interop.ExperimentalCamera2Interop
import com.google.mlkit.vision.barcode.BarcodeScanner
import com.google.mlkit.vision.barcode.BarcodeScanning
import com.google.mlkit.vision.common.InputImage
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import java.net.InetAddress
import java.sql.Connection
import java.sql.DriverManager
import java.sql.PreparedStatement
import java.sql.ResultSet
import java.util.concurrent.ExecutorService
import java.util.concurrent.Executors
import java.util.concurrent.TimeUnit

class MainActivity : ComponentActivity() {

    private lateinit var viewFinder: PreviewView
    private lateinit var cameraContainer: RelativeLayout
    private lateinit var deviceInfo: TextView
    private lateinit var cameraExecutor: ExecutorService
    private lateinit var handler: Handler

    private lateinit var deviceIp: String
    private lateinit var deviceId: String

    // MSSQL 연결 정보
    private val dbUrl = "jdbc:sqlserver://<SERVER>:<PORT>;databaseName=<DATABASE>"
    private val dbUser = "<USERNAME>"
    private val dbPassword = "<PASSWORD>"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        viewFinder = findViewById(R.id.viewFinder)
        cameraContainer = findViewById(R.id.camera_container)
        deviceInfo = findViewById(R.id.device_info)

        // 기기 IP 주소와 ID 가져오기
        deviceIp = getDeviceIpAddress()
        deviceId = Settings.Secure.getString(contentResolver, Settings.Secure.ANDROID_ID)

        // IP 주소와 기기 ID 표시
        deviceInfo.text = "IP: $deviceIp\nID: $deviceId"

        if (allPermissionsGranted()) {
            startCamera()
        } else {
            ActivityCompat.requestPermissions(
                this, REQUIRED_PERMISSIONS, REQUEST_CODE_PERMISSIONS
            )
        }

        cameraExecutor = Executors.newSingleThreadExecutor()
        handler = Handler(Looper.getMainLooper())
    }

    @OptIn(ExperimentalCamera2Interop::class)
    private fun startCamera() {
        val cameraProviderFuture = ProcessCameraProvider.getInstance(this)

        cameraProviderFuture.addListener({
            val cameraProvider: ProcessCameraProvider = cameraProviderFuture.get()

            val previewBuilder = Preview.Builder()

            // Camera2Interop을 사용하여 연속 자동 초점 모드 설정
            val camera2Interop = Camera2Interop.Extender(previewBuilder)
            camera2Interop.setCaptureRequestOption(
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE,
                android.hardware.camera2.CaptureRequest.CONTROL_AF_MODE_CONTINUOUS_PICTURE
            )

            val preview = previewBuilder.build().also {
                it.setSurfaceProvider(viewFinder.surfaceProvider)
            }

            val barcodeScanner = BarcodeScanning.getClient()

            val imageAnalysis = ImageAnalysis.Builder()
                .setTargetAspectRatio(AspectRatio.RATIO_16_9) // 장치의 최대 해상도 사용
                .setBackpressureStrategy(ImageAnalysis.STRATEGY_KEEP_ONLY_LATEST)
                .setTargetRotation(viewFinder.display.rotation) // 디스플레이 회전에 맞춤
                .build()
                .also {
                    it.setAnalyzer(cameraExecutor, { imageProxy ->
                        processImageProxy(barcodeScanner, imageProxy)
                    })
                }

            val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

            try {
                cameraProvider.unbindAll()
                cameraProvider.bindToLifecycle(
                    this, cameraSelector, preview, imageAnalysis
                )

            } catch (exc: Exception) {
                Log.e(TAG, "Use case binding failed", exc)
            }

        }, ContextCompat.getMainExecutor(this))
    }

    private fun processImageProxy(barcodeScanner: BarcodeScanner, imageProxy: ImageProxy) {
        val mediaImage = imageProxy.image
        if (mediaImage != null) {
            val image = InputImage.fromMediaImage(mediaImage, imageProxy.imageInfo.rotationDegrees)
            barcodeScanner.process(image)
                .addOnSuccessListener { barcodes ->
                    for (barcode in barcodes) {
                        val rawValue = barcode.rawValue
                        findViewById<TextView>(R.id.text_view_result).text = rawValue

                        // Coroutine을 사용하여 데이터베이스 쿼리를 비동기로 실행
                        CoroutineScope(Dispatchers.Main).launch {
                            val isInDatabase = isQrCodeInDatabase(rawValue)
                            if (isInDatabase) {
                                // QR 코드가 DB에 존재할 경우 테두리를 녹색으로 변경
                                cameraContainer.setBackgroundColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_green_light))
                                // 5분 후에 다시 주황색으로 변경
                                handler.postDelayed({
                                    cameraContainer.setBackgroundColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_orange_light))
                                }, TimeUnit.MINUTES.toMillis(5))
                            } else {
                                // QR 코드가 DB에 존재하지 않을 경우 주황색 테두리 유지
                                cameraContainer.setBackgroundColor(ContextCompat.getColor(this@MainActivity, android.R.color.holo_orange_light))
                            }
                        }
                    }
                }
                .addOnFailureListener {
                    // Handle failure
                }
                .addOnCompleteListener {
                    imageProxy.close()
                }
        }
    }

    private suspend fun isQrCodeInDatabase(qrCode: String): Boolean {
        return withContext(Dispatchers.IO) {
            var connection: Connection? = null
            var preparedStatement: PreparedStatement? = null
            var resultSet: ResultSet? = null
            var result = false
            try {
                // JDBC 드라이버 로드
                Class.forName("com.microsoft.sqlserver.jdbc.SQLServerDriver")

                // 데이터베이스 연결
                connection = DriverManager.getConnection(dbUrl, dbUser, dbPassword)

                // 쿼리 실행
                val query = "SELECT COUNT(*) FROM QRCodeData WHERE QRCode = ?"
                preparedStatement = connection.prepareStatement(query)
                preparedStatement.setString(1, qrCode)
                
                resultSet = preparedStatement.executeQuery()

                // 결과 처리
                if (resultSet.next()) {
                    result = resultSet.getInt(1) > 0
                }
            } catch (e: Exception) {
                e.printStackTrace()
            } finally {
                try {
                    resultSet?.close()
                    preparedStatement?.close()
                    connection?.close()
                } catch (e: Exception) {
                    e.printStackTrace()
                }
            }
            result
        }
    }

    private fun getDeviceIpAddress(): String {
        try {
            val wifiManager = applicationContext.getSystemService(Context.WIFI_SERVICE) as WifiManager
            val ipAddress = wifiManager.connectionInfo.ipAddress
            return InetAddress.getByAddress(
                byteArrayOf(
                    (ipAddress and 0xff).toByte(),
                    (ipAddress shr 8 and 0xff).toByte(),
                    (ipAddress shr 16 and 0xff).toByte(),
                    (ipAddress shr 24 and 0xff).toByte()
                )
            ).hostAddress ?: "IP not found"
        } catch (ex: Exception) {
            return "IP not found"
        }
    }

    private fun allPermissionsGranted() = REQUIRED_PERMISSIONS.all {
        ContextCompat.checkSelfPermission(
            baseContext, it
        ) == PackageManager.PERMISSION_GRANTED
    }

    override fun onDestroy() {
        super.onDestroy()
        cameraExecutor.shutdown()
        handler.removeCallbacksAndMessages(null) // 모든 핸들러 작업 중지
    }

    companion object {
        private const val TAG = "CameraXApp"
        private const val REQUEST_CODE_PERMISSIONS = 10
        private val REQUIRED_PERMISSIONS = arrayOf(Manifest.permission.CAMERA)
    }
}
주요 수정 사항:
withContext(Dispatchers.IO) 사용:

isQrCodeInDatabase 함수는 이제 suspend 함수로, 네트워크 작업을 Dispatchers.IO에서 수행하도록 설정되었습니다. 이를 통해 네트워크 작업이 메인 스레드에서 실행되지 않도록 했습니다.
CoroutineScope를 통한 비동기 처리:

processImageProxy 메서드에서 CoroutineScope(Dispatchers.Main).launch를 사용하여 코루틴을 시작하고, 데이터베이스 작업을 비동기적으로 수행한 후 결과를 처리합니다.
PreparedStatement 사용:

SQL 쿼리 실행 시 PreparedStatement를 사용하여 SQL 인젝션 공격을 방지하고, 보다 안전한 데이터베이스 작업을 수행하도록 했습니다.
이제 데이터베이스 작업은 안전하게 비동기로 처리되며, NetworkOnMainThreadException 문제를 해결할 수 있습니다. 이 코드는 데이터베이스 작업이 완료된 후에 UI 업