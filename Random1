결론부터 말씀드리면, Graphics.FromImage()는 WPF의 BitmapImage에 직접 사용할 수 없습니다. 두 객체는 서로 다른 그래픽 기술을 사용하기 때문입니다.

System.Windows.Media.Imaging.BitmapImage: WPF 전용 이미지 객체입니다.

System.Drawing.Graphics: GDI+ (Windows Forms) 에서 사용하는 그래픽 객체입니다.

BitmapImage에 무언가를 그리려면 WPF에서 권장하는 방식을 사용하거나, 두 형식 간에 변환하는 과정이 필요합니다.

✅ 방법 1: WPF 네이티브 방식 RenderTargetBitmap 사용 (권장)
WPF에서는 UI 요소들을 조합하고, 이 조합된 결과물을 비트맵으로 "렌더링"하는 방식을 사용합니다. 이것이 가장 효율적이고 권장되는 방법입니다.

원리:

Grid나 Canvas 같은 컨테이너 위에 원본 Image를 배치합니다.

그 위에 그리고자 하는 도형(Line, Rectangle)이나 텍스트(TextBlock)를 추가로 배치합니다.

컨테이너 전체를 RenderTargetBitmap을 사용해 하나의 이미지로 만듭니다.

코드 예시:

C#

/// <summary>
/// WPF의 RenderTargetBitmap을 사용해 BitmapSource에 도형을 그립니다.
/// </summary>
/// <param name="originalSource">그림을 그릴 원본 BitmapSource</param>
/// <returns>그리기 작업이 완료된 새로운 BitmapSource</p
private BitmapSource DrawOnBitmap(BitmapSource originalSource)
{
    // 1. 그리기 작업을 할 컨테이너(Canvas) 생성
    var drawingCanvas = new Canvas
    {
        Width = originalSource.PixelWidth,
        Height = originalSource.PixelHeight
    };

    // 2. 컨테이너에 원본 이미지 배치
    var originalImage = new Image { Source = originalSource };
    drawingCanvas.Children.Add(originalImage);
    Canvas.SetLeft(originalImage, 0);
    Canvas.SetTop(originalImage, 0);
    
    // 3. 그리고자 하는 도형이나 텍스트 추가 (예: 대각선)
    var lineToDraw = new System.Windows.Shapes.Line
    {
        X1 = 0,
        Y1 = 0,
        X2 = originalSource.PixelWidth,
        Y2 = originalSource.PixelHeight,
        Stroke = Brushes.Red,
        StrokeThickness = 5
    };
    drawingCanvas.Children.Add(lineToDraw);

    // 4. 컨테이너의 크기를 강제로 측정하고 배치
    drawingCanvas.Measure(new Size(originalSource.PixelWidth, originalSource.PixelHeight));
    drawingCanvas.Arrange(new Rect(new Size(originalSource.PixelWidth, originalSource.PixelHeight)));

    // 5. 컨테이너의 시각적 결과물을 새로운 비트맵으로 렌더링
    var renderTargetBitmap = new RenderTargetBitmap(
        originalSource.PixelWidth,
        originalSource.PixelHeight,
        originalSource.DpiX,
        originalSource.DpiY,
        PixelFormats.Pbgra32);
        
    renderTargetBitmap.Render(drawingCanvas);
    renderTargetBitmap.Freeze(); // 성능 향상을 위해 Freeze

    return renderTargetBitmap;
}

// 사용 예시
private void YourButton_Click(object sender, RoutedEventArgs e)
{
    // 기존에 로드해 둔 originalBitmapImage 사용
    BitmapSource newImageSource = DrawOnBitmap(this.originalBitmapImage);
    yourImageControl.Source = newImageSource;
}
⚠️ 방법 2: BitmapImage ↔ System.Drawing.Bitmap 변환 (기존 코드 활용 시)
기존에 System.Drawing.Graphics를 사용하는 코드가 반드시 필요하다면, WPF BitmapImage를 GDI+ Bitmap으로 변환한 후, 작업이 끝나면 다시 WPF BitmapSource로 변환해야 합니다. 이 방법은 변환 오버헤드가 있어 성능이 저하될 수 있습니다.

원리:

[WPF → GDI+]: BitmapImage를 메모리 스트림에 PngBitmapEncoder 등으로 인코딩합니다.

이 스트림을 이용해 System.Drawing.Bitmap 객체를 생성합니다.

[GDI+ 작업]: Graphics.FromImage()로 Graphics 객체를 얻어와 그림을 그립니다.

[GDI+ → WPF]: 작업이 완료된 System.Drawing.Bitmap을 다시 메모리 스트림에 저장합니다.

이 스트림으로 새로운 BitmapImage를 만들어 UI에 표시합니다.

코드 예시:

C#

/// <summary>
/// BitmapSource를 System.Drawing.Bitmap으로 변환 후 GDI+로 그리고, 다시 BitmapSource로 변환합니다.
/// </summary>
/// <param name="source">그림을 그릴 원본 BitmapSource</param>
/// <returns>그리기 작업이 완료된 새로운 BitmapSource</returns>
private BitmapSource DrawWithGdi(BitmapSource source)
{
    // 1. [WPF -> GDI+] 변환
    System.Drawing.Bitmap gdiBitmap;
    using (var outStream = new System.IO.MemoryStream())
    {
        // BitmapSource를 PNG 형식으로 메모리 스트림에 인코딩
        BitmapEncoder enc = new PngBitmapEncoder();
        enc.Frames.Add(BitmapFrame.Create(source));
        enc.Save(outStream);
        
        // 스트림으로부터 GDI+ Bitmap 생성
        gdiBitmap = new System.Drawing.Bitmap(outStream);
    }

    // 2. [GDI+ 작업] Graphics 객체를 사용해 그림 그리기
    using (var g = System.Drawing.Graphics.FromImage(gdiBitmap))
    {
        var pen = new System.Drawing.Pen(System.Drawing.Color.Blue, 5);
        g.DrawLine(pen, 0, 0, gdiBitmap.Width, gdiBitmap.Height);
        pen.Dispose();
    }

    // 3. [GDI+ -> WPF] 변환
    using (var memory = new System.IO.MemoryStream())
    {
        // 수정된 GDI+ Bitmap을 메모리 스트림에 저장
        gdiBitmap.Save(memory, System.Drawing.Imaging.ImageFormat.Png);
        memory.Position = 0;

        // 스트림으로부터 WPF BitmapImage 생성
        var bitmapImage = new BitmapImage();
        bitmapImage.BeginInit();
        bitmapImage.StreamSource = memory;
        bitmapImage.CacheOption = BitmapCacheOption.OnLoad;
        bitmapImage.EndInit();
        bitmapImage.Freeze();
        
        return bitmapImage;
    }
}

// 사용 예시
private void YourButton_Click(object sender, RoutedEventArgs e)
{
    BitmapSource newImageSource = DrawWithGdi(this.originalBitmapImage);
    yourImageControl.Source = newImageSource;
}
💡 결론
새로운 WPF 프로젝트라면 성능과 아키텍처를 위해 방법 1 (RenderTargetBitmap) 을 사용하세요.