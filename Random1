습니다. 사용자의 요구에 맞게 첫 실행 시 최근 10개 파일을 완료 처리할 때, 파일의 모든 항목을 "완료"로 처리하고, 완료된 작업의 time 값은 0으로 처리하도록 코드를 수정하겠습니다.

이 기능은 프로그램이 예기치 않게 종료된 후에도 최근 파일들의 PO 정보를 확인하고, 파일들을 완료 처리하면서 진행 시간을 0으로 기록하는 목적으로 작동합니다.

다음은 이 요구 사항을 반영한 전체 FileProcessor 코드입니다.

수정된 FileProcessor.cs (최근 10개 파일 완료 처리 및 시간 값 0으로 설정)
csharp
코드 복사
using System;
using System.IO;
using System.Linq;
using System.Threading.Tasks;
using System.Timers;

public class FileProcessor
{
    private string _inputDirectory;  // 파일을 감지할 디렉토리
    private string _backupDirectory;  // 백업 디렉토리
    private Timer _cleanupTimer;  // 파일 삭제 타이머

    // 파일이 감지되었을 때 발생하는 이벤트
    public event Action<LogEntry> OnLogEntryDetected;

    private bool _isInitialRun = true;  // 첫 실행 여부 체크

    public FileProcessor(string inputDirectory)
    {
        _inputDirectory = inputDirectory;
        _backupDirectory = @"C:\MESPRODFILE_Backup";

        // 24시간마다 한 번씩 파일 정리 작업 실행
        _cleanupTimer = new Timer(TimeSpan.FromDays(1).TotalMilliseconds);
        _cleanupTimer.Elapsed += (sender, args) => CleanupOldFiles();
        _cleanupTimer.Start();
    }

    /// <summary>
    /// 파일 감지 작업 시작
    /// </summary>
    public void StartProcessing()
    {
        Task.Run(() => MonitorDirectory());
    }

    /// <summary>
    /// 디렉토리를 감시하여 새로운 파일을 감지
    /// </summary>
    private void MonitorDirectory()
    {
        if (_isInitialRun)
        {
            // 첫 실행 시 최근 10개 파일을 미리 완료 처리
            ProcessRecentFiles();
            _isInitialRun = false;  // 초기 실행 체크 해제
        }

        while (true)
        {
            var files = Directory.GetFiles(_inputDirectory, "*.txt");
            foreach (var file in files)
            {
                // 새 파일은 백업 폴더로 이동 후 처리
                var backupFile = MoveFileToBackup(file);
                if (backupFile != null)
                {
                    ProcessFile(backupFile);
                }
            }
            Task.Delay(5000).Wait();  // 5초마다 디렉토리 확인
        }
    }

    /// <summary>
    /// 첫 실행 시 최근 10개의 파일을 미리 완료 처리
    /// </summary>
    private void ProcessRecentFiles()
    {
        try
        {
            // 파일 목록을 날짜 순으로 정렬하여 최근 10개 파일 가져오기
            var recentFiles = Directory.GetFiles(_inputDirectory, "*.txt")
                                       .OrderByDescending(f => File.GetLastWriteTime(f))
                                       .Take(10);

            foreach (var file in recentFiles)
            {
                // 파일을 백업 폴더로 이동한 후 완료 처리
                var backupFile = MoveFileToBackup(file);
                if (backupFile != null)
                {
                    Console.WriteLine($"Processing recent file (completed): {backupFile}");
                    // 완료 처리를 위한 함수 호출
                    CompleteFile(backupFile);
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing recent files: {ex.Message}");
        }
    }

    /// <summary>
    /// 파일을 백업 폴더로 이동
    /// </summary>
    private string MoveFileToBackup(string filePath)
    {
        try
        {
            // 백업 폴더 경로 생성 (yyyyMMdd 형식)
            string backupSubDirectory = Path.Combine(_backupDirectory, DateTime.Now.ToString("yyyyMMdd"));
            if (!Directory.Exists(backupSubDirectory))
            {
                Directory.CreateDirectory(backupSubDirectory);
            }

            // 백업 파일 경로 설정
            string destinationPath = Path.Combine(backupSubDirectory, Path.GetFileName(filePath));

            // 파일 이동
            File.Move(filePath, destinationPath);

            return destinationPath;  // 이동된 파일 경로 반환
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error moving file to backup: {ex.Message}");
            return null;
        }
    }

    /// <summary>
    /// 이동한 파일을 처리
    /// </summary>
    private void ProcessFile(string filePath)
    {
        try
        {
            // 파일 내용 읽기
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 처리 완료 후 이벤트 발생
            OnLogEntryDetected?.Invoke(logEntry);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error processing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 파일을 완료 처리 (시간 값은 모두 0으로 처리)
    /// </summary>
    private void CompleteFile(string filePath)
    {
        try
        {
            // 파일 내용 읽기
            var lines = File.ReadAllLines(filePath);
            var logEntry = ParseLogEntry(lines);

            // 완료 처리를 위한 로그 엔트리 파싱
            Console.WriteLine($"Completing file {filePath} as completed.");

            // 파일 완료 처리 (타임 값 모두 0으로 설정)
            logEntry.Time = 0;  // 시간 값은 0으로 설정

            // 로그 엔트리 표시 (PO 확인용)
            Console.WriteLine($"PO_NO: {logEntry.PO_NO}, MAG_NO: {logEntry.MAG_NO}, Completed with Time: 0");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error completing file: {ex.Message}");
        }
    }

    /// <summary>
    /// 로그 파일의 내용을 파싱하여 LogEntry 객체로 변환
    /// </summary>
    private LogEntry ParseLogEntry(string[] lines)
    {
        // 로그 엔트리 파싱 로직 구현 (필요에 따라 수정)
        var logEntry = new LogEntry
        {
            MAG_NO = ExtractField(lines, "MAG_NO"),
            MAG_QTY = int.Parse(ExtractField(lines, "MAG_QTY")),
            BASIC_MODEL = ExtractField(lines, "BASIC_MODEL"),
            MODEL_CODE = ExtractField(lines, "MODEL_CODE"),
            PO_NO = ExtractField(lines, "PO_NO"),
            PO_PLAN_QTY = int.Parse(ExtractField(lines, "PO_PLAN_QTY")),
            PO_PROD_QTY = int.Parse(ExtractField(lines, "PO_PROD_QTY")),
            SequenceFlag = DetermineSequenceFlag(ExtractField(lines, "PO_PLAN_QTY"), ExtractField(lines, "PO_PROD_QTY")),
            Time = 0  // 파일이 완료 처리된 경우 Time을 0으로 설정
        };
        return logEntry;
    }

    /// <summary>
    /// 로그 파일에서 각 필드를 추출하는 도우미 함수
    /// </summary>
    private string ExtractField(string[] lines, string fieldName)
    {
        var line = lines.FirstOrDefault(l => l.StartsWith(fieldName + "="));
        if (line != null)
        {
            return line.Split('=')[1].Trim();
        }
        return string.Empty;
    }

    /// <summary>
    /// 시퀀스 플래그 결정 (첫 파일: 1, 중간 파일: 2, 마지막 파일: 3)
    /// </summary>
    private int DetermineSequenceFlag(string planQty, string prodQty)
    {
        int plan = int.Parse(planQty);
        int prod = int.Parse(prodQty);
        if (prod == 0) return 1;  // 첫 번째 파일
        if (prod < plan) return 2;  // 중간 파일
        if (prod >= plan) return 3;  // 마지막 파일
        return 0;  // 기본값
    }

    /// <summary>
    /// 3개월 이상 지난 백업 파일을 삭제
    /// </summary>
    private void CleanupOldFiles()
    {
        try
        {
            // 3개월 전 날짜 계산
            DateTime thresholdDate = DateTime.Now.AddMonths(-3);

            var directories = Directory.GetDirectories(_backupDirectory);
            foreach (var directory in directories)
            {
                DateTime directoryDate;
                if (DateTime.TryParseExact(Path.GetFileName(directory), "yyyyMMdd", null, System.Globalization.DateTimeStyles.None, out directoryDate))
                {
                    // 3개월 이상 된 디렉토리 삭제
                    if (directoryDate < thresholdDate)
                    {
                        Directory.Delete(directory, true);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error cleaning up old files: {ex.Message}");
        }
    }
}
주요 수정 사항:
CompleteFile 메서드:

시간 값은 모두 0으로 처리되도록 수정했습니다.
해당 파일이 완료 처리되었음을 확인하는 콘솔 출력이 추가되었습니다.
완료된 파일의 PO_NO, MAG_NO를 확인할 수 있으며, 파일은 실제로 처리가 완료된 것으로 간주됩니다.
파일 처리 흐름:

첫 실행 시 최근 10개 파일을 완료 처리하며, 이때