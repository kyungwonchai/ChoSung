네, 좋습니다. 요청하신 대로 SocketControl.Core의 핵심 코드(명령 패킷 구조, 모니터 제어 P/Invoke) 및 ManagedPCs 데이터베이스 테이블 DDL을 아래에 제공합니다.

1. SocketControl.Core (C#)
이 프로젝트는 다른 프로젝트들 (SocketControl.Agent, SocketControl.UserClient, SocketControl.ConfigurationManager)에서 공통으로 참조하게 될 라이브러리입니다.

1.1. CommandPacket.cs 및 관련 열거형/페이로드 클래스
명령 패킷의 구조와 통신에 사용될 데이터 형식을 정의합니다. System.Text.Json을 사용하여 페이로드 직렬화를 가정합니다.

C#

// SocketControl.Core/Enums.cs
namespace SocketControl.Core
{
    /// <summary>
    /// 명령 패킷의 처리 방식을 정의합니다.
    /// </summary>
    public enum CommandInstruction
    {
        /// <summary>
        /// 명령을 직접 실행합니다.
        /// </summary>
        DirectExecute,

        /// <summary>
        /// 명령을 지정된 다음 대상으로 중계합니다.
        /// </summary>
        RelayToTarget
    }

    /// <summary>
    /// 실행 또는 중계될 명령의 종류를 정의합니다.
    /// </summary>
    public static class CommandNames
    {
        public const string MonitorControl = "MONITOR_CONTROL";
        // public const string SystemShutdown = "SYSTEM_SHUTDOWN"; // 예시: 추후 확장 가능
        // 다른 명령 이름들...
    }

    /// <summary>
    /// 모니터 제어 동작의 종류를 정의합니다.
    /// </summary>
    public enum MonitorAction
    {
        Off,      // 모니터 끄기 (SC_MONITORPOWER = 2)
        On,       // 모니터 켜기 (SC_MONITORPOWER = -1)
        Standby   // 모니터 절전 모드 (SC_MONITORPOWER = 1)
    }
}

// SocketControl.Core/Payloads.cs
namespace SocketControl.Core
{
    /// <summary>
    /// 모니터 제어 명령의 페이로드입니다.
    /// </summary>
    public class MonitorControlPayload
    {
        public MonitorAction Action { get; set; }
    }

    // 다른 명령에 대한 페이로드 클래스들...
    // public class SystemShutdownPayload { public int DelaySeconds { get; set; } }
}

// SocketControl.Core/CommandPacket.cs
using System;

namespace SocketControl.Core
{
    /// <summary>
    /// 에이전트 간 통신 및 UserClient-Agent 간 통신에 사용될 기본 명령 패킷입니다.
    /// </summary>
    public class CommandPacket
    {
        /// <summary>
        /// 패킷의 고유 식별자입니다.
        /// </summary>
        public Guid PacketId { get; set; }

        /// <summary>
        /// 이 패킷을 수신한 에이전트가 취해야 할 행동입니다.
        /// DirectExecute: CommandName과 PayloadJson을 사용하여 직접 명령을 실행합니다.
        /// RelayToTarget: FinalTargetIpForRelayedCommand로 CommandName과 PayloadJson을 포함하는 새로운 DirectExecute 패킷을 만들어 전송합니다.
        /// </summary>
        public CommandInstruction Instruction { get; set; }

        /// <summary>
        /// 실행되거나 중계될 실제 명령의 이름입니다 (예: CommandNames.MonitorControl).
        /// </summary>
        public string CommandName { get; set; }

        /// <summary>
        /// CommandName에 해당하는 명령의 실제 인자들을 JSON 문자열로 직렬화한 값입니다.
        /// 예: MonitorControlPayload 객체를 JSON으로 변환한 문자열.
        /// </summary>
        public string PayloadJson { get; set; }

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용]
        /// 이 명령 패킷(CommandName, PayloadJson)을 최종적으로 전달받아 실행할 대상의 IP 주소입니다.
        /// 중계 에이전트는 이 주소로 새로운 DirectExecute 패킷을 생성하여 전송합니다.
        /// </summary>
        public string? FinalTargetIpForRelayedCommand { get; set; }

        /// <summary>
        /// [Instruction이 RelayToTarget일 때 사용]
        /// FinalTargetIpForRelayedCommand의 포트 번호입니다.
        /// </summary>
        public int? FinalTargetPortForRelayedCommand { get; set; }

        public CommandPacket()
        {
            PacketId = Guid.NewGuid();
        }
    }
}
사용 예시 (JSON 직렬화/역직렬화):
System.Text.Json.JsonSerializer를 사용합니다.

C#

// 직렬화 예시
// var monitorPayload = new MonitorControlPayload { Action = MonitorAction.Off };
// var payloadJson = System.Text.Json.JsonSerializer.Serialize(monitorPayload);
// var packet = new CommandPacket
// {
//     Instruction = CommandInstruction.DirectExecute,
//     CommandName = CommandNames.MonitorControl,
//     PayloadJson = payloadJson
// };
// var packetJson = System.Text.Json.JsonSerializer.Serialize(packet);

// 역직렬화 예시
// var receivedPacket = System.Text.Json.JsonSerializer.Deserialize<CommandPacket>(jsonStringFromSocket);
// if (receivedPacket.CommandName == CommandNames.MonitorControl)
// {
//     var mcPayload = System.Text.Json.JsonSerializer.Deserialize<MonitorControlPayload>(receivedPacket.PayloadJson);
//     // mcPayload.Action 사용
// }
1.2. MonitorControl.cs (P/Invoke 사용)
로컬 PC의 모니터 전원을 제어하는 P/Invoke 함수 선언입니다.

C#

// SocketControl.Core/MonitorControl.cs
using System;
using System.Runtime.InteropServices;

namespace SocketControl.Core
{
    public static class LocalMonitorControl
    {
        private const int HWND_BROADCAST = 0xFFFF;
        private const uint WM_SYSCOMMAND = 0x0112;
        private const uint SC_MONITORPOWER = 0xF170;

        // dwData 값에 따른 모니터 상태:
        // -1: 모니터 켜기 (The display is powering on)
        //  1: 모니터 절전 (The display is going to low power)
        //  2: 모니터 끄기 (The display is being shut off)

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessageTimeout(
            IntPtr hWnd,
            uint Msg,
            UIntPtr wParam,
            UIntPtr lParam,
            SendMessageTimeoutFlags fuFlags,
            uint uTimeout,
            out UIntPtr lpdwResult);

        [Flags]
        private enum SendMessageTimeoutFlags : uint
        {
            SMTO_NORMAL = 0x0,
            SMTO_BLOCK = 0x1,
            SMTO_ABORTIFHUNG = 0x2,
            SMTO_NOTIMEOUTIFNOTHUNG = 0x8,
            SMTO_ERRORONEXIT = 0x20
        }

        /// <summary>
        /// 로컬 PC의 모니터 전원 상태를 변경합니다.
        /// </summary>
        /// <param name="action">원하는 모니터 동작 (On, Off, Standby)</param>
        /// <returns>성공 시 true, 실패 시 false</returns>
        public static bool SetMonitorState(MonitorAction action)
        {
            UIntPtr monitorStateCode;
            switch (action)
            {
                case MonitorAction.On:
                    monitorStateCode = (UIntPtr)unchecked((int)-1); // 모니터 켜기
                    break;
                case MonitorAction.Standby:
                    monitorStateCode = (UIntPtr)1; // 모니터 절전
                    break;
                case MonitorAction.Off:
                    monitorStateCode = (UIntPtr)2; // 모니터 끄기
                    break;
                default:
                    throw new ArgumentOutOfRangeException(nameof(action), "알 수 없는 모니터 동작입니다.");
            }

            UIntPtr result;
            // 모든 최상위 창에 메시지를 보냅니다.
            SendMessageTimeout(
                (IntPtr)HWND_BROADCAST,
                WM_SYSCOMMAND,
                (UIntPtr)SC_MONITORPOWER,
                monitorStateCode,
                SendMessageTimeoutFlags.SMTO_NORMAL | SendMessageTimeoutFlags.SMTO_ABORTIFHUNG,
                1000, // 1초 타임아웃
                out result);
            
            // SendMessageTimeout의 반환 값으로 성공 여부를 정확히 판단하기는 어려울 수 있습니다.
            // 일반적으로 에러가 발생하지 않으면 성공으로 간주하지만, 실제 환경에서는 추가적인 확인이 필요할 수 있습니다.
            // Marshal.GetLastWin32Error()를 통해 오류 코드를 확인할 수 있습니다.
            int errorCode = Marshal.GetLastWin32Error();
            if (errorCode != 0)
            {
                 // Console.WriteLine($"SetMonitorState Error: {errorCode}"); // 로깅 필요
                 return false;
            }
            return true;
        }
    }
}
2. ManagedPCs 데이터베이스 테이블 DDL (SQL Server 기준)
사용자님께서 제안해주신 스키마를 바탕으로 SQL Server용 DDL을 작성했습니다. 필요에 따라 다른 DBMS에 맞게 수정할 수 있습니다.

SQL

CREATE TABLE ManagedPCs (
    PCID INT IDENTITY(1,1) PRIMARY KEY,               -- 고유 식별자 (자동 증가)
    DisplayName NVARCHAR(100) NOT NULL,               -- UI에 표시될 PC 이름
    PrimaryIP VARCHAR(50) NOT NULL,                   -- 직접 제어 IP 또는 릴레이(경유) IP
    PrimaryPort INT NOT NULL,                         -- PrimaryIP의 에이전트 포트
    SecondaryIP VARCHAR(50) NULL,                     -- (선택) 릴레이 시 최종 목적지 IP
    SecondaryPort INT NULL,                           -- (선택) SecondaryIP의 에이전트 포트
    Description NVARCHAR(255) NULL,                   -- 설명
    IsEnabled BIT NOT NULL DEFAULT 1,                 -- 사용 여부 (기본값: 사용)
    DateCreated DATETIME2 NOT NULL DEFAULT GETUTCDATE(), -- 생성일 (UTC 기준)
    LastModified DATETIME2 NOT NULL DEFAULT GETUTCDATE() -- 최종 수정일 (UTC 기준)
);

-- 선택 사항: 특정 조합에 대한 UNIQUE 제약 조건 (예: 이름 또는 IP 조합)
-- 예: ALTER TABLE ManagedPCs ADD CONSTRAINT UQ_DisplayName UNIQUE (DisplayName);
-- 예: ALTER TABLE ManagedPCs ADD CONSTRAINT UQ_PrimaryIPPort UNIQUE (PrimaryIP, PrimaryPort);
--     (릴레이 구조에서는 IP/Port가 중복될 수 있으므로 신중히 고려)

-- 인덱스 추가 (조회 성능 향상 목적)
CREATE INDEX IX_ManagedPCs_DisplayName ON ManagedPCs (DisplayName);
CREATE INDEX IX_ManagedPCs_PrimaryIP ON ManagedPCs (PrimaryIP);
CREATE INDEX IX_ManagedPCs_SecondaryIP ON ManagedPCs (SecondaryIP);
참고:

GETUTCDATE()는 UTC 기준 현재 시간을 반환합니다. 로컬 시간대를 사용하려면 GETDATE()를 사용할 수 있으나, 여러 지역에 걸쳐 사용될 가능성이 있다면 UTC가 더 표준적입니다.
IsEnabled, DateCreated, LastModified 컬럼을 추가하여 데이터 관리에 유용하게 활용할 수 있도록 했습니다.
여기까지 SocketControl.Core의 핵심 부분과 데이터베이스 테이블 DDL입니다. 이 코드들을 바탕으로 SocketControl.Agent와 SocketControl.UserClient의 기본 로직을 구상하고, 안정적인 소켓 통신을 위한 상세 구현을 추가해 나갈 수 있습니다.

다음 단계로 어떤 부분의 코드 구조를 더 보고 싶으신가요? 예를 들어, SocketControl.Agent의 명령 수신 및 처리 루프의 기본 구조나, SocketControl.UserClient에서 이 CommandPacket을 생성하여 보내는 부분 등을 살펴볼 수 있습니다.

