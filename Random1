안녕하세요! 현재 구성하신 Flask API 서버를 웹 페이지와 연동하여, 외부 웹소켓 서버와의 통신 과정을 실시간으로 브라우저에 표시하는 방법을 알려드리겠습니다.

핵심은 Flask-SocketIO 라이브러리를 사용해 Flask 서버와 사용자 브라우저 간의 실시간 양방향 통신 채널을 만드는 것입니다.

전체적인 데이터 흐름은 다음과 같습니다.
사용자 브라우저 ↔ (Socket.IO) ↔ Flask 서버 (apiapp.py) ↔ (WebSocket) ↔ 외부 웹소켓 서버

해결 방법: Flask-SocketIO를 이용한 실시간 통신 구현
기존의 apiapp.py를 확장하여 웹 페이지를 렌더링하고, 브라우저와 실시간 통신을 통해 외부 웹소켓 서버의 응답을 그대로 전달하는 방식으로 구현합니다.

1. 필요 라이브러리 설치
먼저 필요한 Python 라이브러리들을 설치합니다. websocket-client는 외부 웹소켓 서버에 접속하기 위해 필요합니다.

Bash

pip install Flask Flask-SocketIO eventlet websocket-client
Tip: eventlet은 비동기 처리를 위한 고성능 서버로, Flask-SocketIO와 함께 사용하는 것이 좋습니다.

2. 프로젝트 구조
아래와 같이 templates 폴더를 만들고 그 안에 index.html 파일을 생성합니다.

my_project/
├── apiapp.py         # Flask + SocketIO 서버 로직
└── templates/
    └── index.html    # 사용자에게 보여줄 웹 페이지
3. 백엔드 코드 수정 (apiapp.py)
기존 API 로직에 웹 페이지 렌더링과 Socket.IO 이벤트 핸들러를 추가합니다.

Python

import eventlet
eventlet.monkey_patch()

from flask import Flask, render_template
from flask_socketio import SocketIO
import websocket # websocket-client 라이브러리

# --- Flask 및 SocketIO 앱 초기화 ---
app = Flask(__name__)
app.config['SECRET_KEY'] = 'your-secret-key!' # 실제 운영시에는 복잡한 키로 변경하세요.
socketio = SocketIO(app, async_mode='eventlet')

# --- 외부 웹소켓 서버 정보 ---
# 테스트용 공개 웹소켓 서버 주소입니다. 실제 사용하시는 서버 주소로 변경하세요.
EXTERNAL_WEBSOCKET_URL = "wss://ws.postman-echo.com/raw" 

# --- HTTP 라우트: 웹 페이지 렌더링 ---
@app.route('/')
def index():
    """사용자가 접속할 기본 웹 페이지를 렌더링합니다."""
    return render_template('index.html')

# --- Socket.IO 이벤트 핸들러 ---
@socketio.on('send_message_to_external_ws')
def handle_external_ws_communication(json_data):
    """브라우저로부터 메시지를 받아 외부 웹소켓 서버와 통신하고 결과를 다시 브라우저로 전송합니다."""
    
    message_to_send = json_data.get('data', 'Default Message')
    
    try:
        # 브라우저에 진행 상황 로그 전송
        socketio.emit('log_update', {'data': f"Connecting to {EXTERNAL_WEBSOCKET_URL}..."})
        
        # 외부 웹소켓 서버에 연결
        ws = websocket.create_connection(EXTERNAL_WEBSOCKET_URL)
        
        try:
            socketio.emit('log_update', {'data': f"Sending message: '{message_to_send}'"})
            
            # 데이터 전송
            ws.send(message_to_send)
            
            # 회신(응답) 수신
            socketio.emit('log_update', {'data': "Waiting for response..."})
            response = ws.recv()
            socketio.emit('log_update', {'data': f"Received response: '{response}'"})
            
            # 최종 결과를 브라우저로 전송
            socketio.emit('final_response', {'data': response})
            
        finally:
            # 웹소켓 연결 종료
            ws.close()
            socketio.emit('log_update', {'data': "Connection closed."})

    except Exception as e:
        error_message = f"An error occurred: {str(e)}"
        print(error_message) # 서버 로그에 에러 출력
        socketio.emit('log_update', {'data': error_message})
        socketio.emit('final_response', {'data': f"Error: Failed to communicate with WebSocket server."})


# --- 서버 실행 ---
if __name__ == '__main__':
    # app.run() 대신 socketio.run()을 사용해야 합니다.
    socketio.run(app, host='0.0.0.0', port=5000, debug=True)

4. 프론트엔드 코드 (templates/index.html)
사용자가 외부 웹소켓 서버로 데이터를 보내고 실시간으로 응답을 확인할 수 있는 간단한 UI를 만듭니다.

HTML

<!DOCTYPE html>
<html lang="ko">
<head>
    <meta charset="UTF-8">
    <title>WebSocket Real-time Viewer</title>
    <script src="https://cdn.socket.io/4.7.5/socket.io.min.js"></script>
    <style>
        body { font-family: sans-serif; margin: 2em; }
        #log { border: 1px solid #ccc; padding: 10px; height: 300px; overflow-y: scroll; background-color: #f9f9f9; white-space: pre-wrap; }
        #response { margin-top: 1em; padding: 10px; background-color: #e0ffe0; border: 1px solid #008000; }
        button { padding: 10px 15px; font-size: 16px; }
    </style>
</head>
<body>
    <h1>외부 웹소켓 서버와 통신</h1>
    <p>버튼을 누르면 Flask 서버를 통해 외부 웹소켓 서버로 "Hello WebSocket!" 메시지를 보내고 응답을 받습니다.</p>
    
    <button id="sendButton">데이터 전송 및 회신 받기</button>

    <h3>실시간 통신 로그:</h3>
    <div id="log"></div>

    <h3>최종 응답:</h3>
    <div id="response">Waiting for response...</div>

    <script>
        // Flask 서버의 Socket.IO와 연결
        const socket = io();

        const logDiv = document.getElementById('log');
        const responseDiv = document.getElementById('response');
        const sendButton = document.getElementById('sendButton');

        // 서버 연결 성공 시
        socket.on('connect', () => {
            log('? Connected to Flask-SocketIO server.');
        });

        // 'log_update' 이벤트를 수신하면 로그 영역에 내용 추가
        socket.on('log_update', (msg) => {
            log(`[LOG] ${msg.data}`);
        });

        // 'final_response' 이벤트를 수신하면 최종 응답 영역에 내용 표시
        socket.on('final_response', (msg) => {
            responseDiv.textContent = msg.data;
        });

        // 전송 버튼 클릭 이벤트
        sendButton.addEventListener('click', () => {
            logDiv.innerHTML = ''; // 로그 초기화
            responseDiv.textContent = 'Waiting for response...'; // 응답 초기화
            const message = "Hello WebSocket!"; // 보낼 메시지
            // 서버로 'send_message_to_external_ws' 이벤트를 발생시킴
            socket.emit('send_message_to_external_ws', {data: message});
        });

        // 로그를 화면에 출력하는 헬퍼 함수
        function log(message) {
            logDiv.innerHTML += message + '\n';
            logDiv.scrollTop = logDiv.scrollHeight; // 항상 마지막 로그가 보이도록 스크롤
        }
    </script>
</body>
</html>
5. 실행 방법
터미널에서 apiapp.py가 있는 my_project 디렉토리로 이동합니다.

아래 명령어로 Flask 서버를 실행합니다.

Bash

python apiapp.py
웹 브라우저를 열고 http://127.0.0.1:5000 주소로 접속합니다.

'데이터 전송 및 회신 받기' 버튼을 클릭하면 실시간 통신 로그와 최종 응답이 웹 페이지에 표시되는 것을 확인할 수 있습니다.