래는 요구사항을 충족하기 위해 수정된 MainViewModel과 ComPortManager 코드입니다.

변경 사항은 다음과 같습니다:

DT2330 값 확인: 3초 후 DT2330에 내가 보낸 값이 그대로 쓰여졌는지 확인합니다. 다른 값이 쓰여지면 오류 로그를 기록합니다.
Mewtocol 응답 확인: PLC로 데이터를 전송한 후, Mewtocol 기본 응답을 항상 체크합니다. 올바른 응답을 받지 못하면 에러를 로그에 기록합니다.
1. 수정된 MainViewModel.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.Collections.ObjectModel;
using System.ComponentModel;
using System.Threading.Tasks;
using System.Windows.Input;
using RouterMiddleACRService;

namespace RouterMiddleACR.ViewModels
{
    public class MainViewModel : INotifyPropertyChanged
    {
        private readonly ComPortManager _comPortManager;
        private string _r520Status;
        private string _r521Status;

        public string R520Status
        {
            get => _r520Status;
            set
            {
                _r520Status = value;
                OnPropertyChanged(nameof(R520Status));
            }
        }

        public string R521Status
        {
            get => _r521Status;
            set
            {
                _r521Status = value;
                OnPropertyChanged(nameof(R521Status));
            }
        }

        // Zero부터 4까지 버튼 명령들
        public ObservableCollection<KeyValuePair<string, ICommand>> ButtonCommands { get; set; }

        // 명령 생성
        public ICommand SendTextBoxValueCommand { get; }
        public ICommand ProcessDT2330Command { get; }

        public MainViewModel()
        {
            _comPortManager = new ComPortManager();
            _comPortManager.ConfigurePort("COM1");

            ButtonCommands = new ObservableCollection<KeyValuePair<string, ICommand>>();
            InitializeCommands();

            // 명령 초기화
            SendTextBoxValueCommand = new RelayCommand<string>(async (value) => await SendTextBoxValueToPLC(value));
            ProcessDT2330Command = new RelayCommand(async () => await ReadAndClearDT2330Data());

            // 주기적으로 PLC 상태를 확인하는 작업 시작
            Task.Run(UpdatePLCStatusAsync);
        }

        private void InitializeCommands()
        {
            for (int i = 1; i <= 4; i++)
            {
                int value = i;
                ButtonCommands.Add(new KeyValuePair<string, ICommand>(
                    $"Send {i} to PLC",
                    new RelayCommand(async () => await WriteToPLCAndCheckResponse(value))));
            }
        }

        public async Task WriteToPLCAndCheckResponse(int number)
        {
            // Step 1: Write value to DT2300
            string writeCommand = $"%01#WDD0230000230{number:D2}00**\r";
            string response = await _comPortManager.SendDataToPLCAsync(writeCommand);

            // Check Mewtocol response
            if (!CheckMewtocolResponse(response))
            {
                LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                return;
            }

            LogMessage($"Sent {number} to DT2300, waiting for response...");

            // Step 2: Wait for 3 seconds
            await Task.Delay(3000);

            // Step 3: Check if DT2330 has the correct value within 30 seconds
            bool success = false;
            DateTime startTime = DateTime.Now;

            while ((DateTime.Now - startTime).TotalSeconds < 30)
            {
                string dt2330Response = await _comPortManager.ReadFromPLCAsync("023300");

                if (dt2330Response.Contains(number.ToString()))
                {
                    LogMessage($"Operation completed successfully. Value {number} correctly received from DT2330.");
                    success = true;
                    await _comPortManager.ClearPLCValueAsync("023300");
                    break;
                }
                else if (dt2330Response != "0000") // 다른 값이 쓰여진 경우
                {
                    LogMessage($"ERROR: Unexpected value {dt2330Response} found in DT2330. Expected {number}.");
                    break;
                }

                await Task.Delay(1000); // 1초마다 체크
            }

            if (!success)
            {
                LogMessage($"ERROR: Operation failed. Expected value {number} not received from DT2330 within 30 seconds.");
            }
        }

        public async Task SendTextBoxValueToPLC(string value)
        {
            if (int.TryParse(value, out int intValue))
            {
                string command = $"%01#WDD0230000230{intValue:D2}00**\r";
                string response = await _comPortManager.SendDataToPLCAsync(command);

                if (!CheckMewtocolResponse(response))
                {
                    LogMessage($"ERROR: Failed to write to PLC. Mewtocol response: {response}");
                    return;
                }

                LogMessage($"Sent {value} from TextBox to PLC");
            }
            else
            {
                LogMessage("Invalid value.");
            }
        }

        public async Task ReadAndClearDT2330Data()
        {
            string value = await _comPortManager.ReadFromPLCAsync("023300");
            ProcessPLCValue(value);
            await _comPortManager.ClearPLCValueAsync("023300");
        }

        private void ProcessPLCValue(string value)
        {
            LogMessage($"Processed value from DT2330: {value}");
        }

        private async Task UpdatePLCStatusAsync()
        {
            while (true)
            {
                string r520 = await _comPortManager.ReadFromPLCAsync("005200");
                string r521 = await _comPortManager.ReadFromPLCAsync("005201");

                R520Status = r520.Contains("1") ? "R520: 정상" : "R520: 오류";
                R521Status = r521.Contains("1") ? "R521: 정상" : "R521: 오류";

                await Task.Delay(1000);
            }
        }

        private void LogMessage(string message)
        {
            Console.WriteLine($"{DateTime.Now:yyyy-MM-dd HH:mm:ss} - {message}");
        }

        private bool CheckMewtocolResponse(string response)
        {
            // Mewtocol의 기본 응답을 확인하여 올바른지 확인
            return response.Contains("%01");
        }

        public event PropertyChangedEventHandler PropertyChanged;

        protected virtual void OnPropertyChanged(string propertyName)
        {
            PropertyChanged?.Invoke(this, new PropertyChangedEventArgs(propertyName));
        }
    }
}
2. 수정된 ComPortManager.cs
ComPortManager 클래스에서 PLC로 데이터를 전송하고 응답을 확인하는 메서드를 추가합니다.

csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

namespace RouterMiddleACRService
{
    public class ComPortManager
    {
        private SerialPort _port;

        public void ConfigurePort(string portName, int baudRate = 9600, Parity parity = Parity.None, int dataBits = 8, StopBits stopBits = StopBits.One)
        {
            _port = new SerialPort(portName, baudRate, parity, dataBits, stopBits);
        }

        public async Task<string> SendDataToPLCAsync(string command)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);

                // PLC의 응답을 비동기적으로 읽음
                string response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error sending data to PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task<string> ReadFromPLCAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#RDD{address}**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                _port.Write(commandBytes, 0, commandBytes.Length);
                
                var response = await Task.Run(() => _port.ReadLine());
                return response;
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error reading from PLC: {ex.Message}");
                return string.Empty;
            }
        }

        public async Task ClearPLCValueAsync(string address)
        {
            if (_port == null || !_port.IsOpen)
            {
                throw new InvalidOperationException("The serial port is not open.");
            }

            try
            {
                string command = $"%01#WDD{address}0000**\r";
                byte[] commandBytes = Encoding.ASCII.GetBytes(command);
                await Task.Run(() => _port.Write(commandBytes, 0, commandBytes.Length));
            }
            catch (Exception ex)
            {
                Console.WriteLine($"Error clearing PLC value: {ex.Message}");
            }
        }

        public void OpenPort()
        {
            if (_port != null && !_port.IsOpen)
            {
                _port.Open();
            }
        }

        public void ClosePort()
        {
            if (_port != null && _port.IsOpen)
            {
                _port.Close();
            }
        }
    }
}
설명
PLC로 데이터 전송 및 응답 확인:

SendDataToPLCAsync 메서드는 PLC로 데이터를 전송하고 응답을 읽어오는 메서드입니다.
Mewtocol 프로토콜을 사용하여 PLC로 명령을 전송하고 응답을 기다립니다.
응답을 받아서 제대로 전송이 되었는지 확인합니다. Mewtocol의 기본 응답은 %01로 시작하므로, 이를 확인하여 성공 여부를 판단합니다.
DT2330 값 확인 및 초기화:

WriteToPLCAndCheckResponse 메서드는 PLC에 값을 쓴 후 3초 후부터 최대 30초간 DT2330의 값을 확인합니다.
기대한 값이 맞는지 확인하고, 그렇지 않으면 오류 로그를 기록합니다. 제대로 확인된 경우에는 값을 초기화합니다.
로깅:

각 단계마다 로그를 남겨 작업의 흐름과 오류 발생 시점을 명확히 파악할 수 있습니다.
위의 수정된 코드를 사용하면, PLC로 데이터를 전송한 후 응답을 확인하고, DT2330에 기대한 값이 쓰여졌는지 확인하는 로직을 구현할 수 있습니다. 또한, 예상치 못한 값이 쓰여졌을 때도 오류를 기록하여 디버깅을 돕습니다