DELIMITER $$

CREATE PROCEDURE GetWeeklyInOutSummary()
BEGIN
    SET @sql = NULL;

    -- Example of dynamically constructing SQL with dynamic column names for last 5 weeks
    SELECT GROUP_CONCAT(DISTINCT
        CONCAT(
            'SUM(CASE WHEN YEARWEEK(pm.inputdate) = ',
            YEARWEEK(CURDATE()) - INTERVAL_WEEK.week_num,
            ' THEN CASE WHEN pm.inout_value = ''in'' THEN pm.inout_count WHEN pm.inout_value = ''incancel'' THEN -pm.inout_count ELSE 0 END ELSE 0 END) AS `total_in_w',
            YEARWEEK(CURDATE()) - INTERVAL_WEEK.week_num, '`',
            ', SUM(CASE WHEN YEARWEEK(pm.inputdate) = ',
            YEARWEEK(CURDATE()) - INTERVAL_WEEK.week_num,
            ' THEN CASE WHEN pm.inout_value = ''out'' THEN -pm.inout_count WHEN pm.inout_value = ''outcancel'' THEN pm.inout_count ELSE 0 END ELSE 0 END) AS `total_out_w',
            YEARWEEK(CURDATE()) - INTERVAL_WEEK.week_num, '`'
        )
    ORDER BY INTERVAL_WEEK.week_num INTO @sql
    FROM (
        SELECT 0 AS week_num UNION ALL SELECT 1 UNION ALL SELECT 2 UNION ALL SELECT 3 UNION ALL SELECT 4
    ) AS INTERVAL_WEEK;

    SET @sql = CONCAT('SELECT rp.partcode, rp.partcount, rp.lastupdate, ', @sql, ' 
                      FROM smd.tbl_repare_part_remain rp 
                      JOIN smd.tbl_repare_partmanage pm ON rp.partcode = pm.partcode 
                      GROUP BY rp.partcode, rp.partcount, rp.lastupdate');

    PREPARE stmt FROM @sql;
    EXECUTE stmt;
    DEALLOCATE PREPARE stmt;
END$$

DELIMITER ;
