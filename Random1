 평가를 포함한 각 주요 단계에서 세부적인 진행 상황이 출력되도록 수정된 코드를 작성했습니다. 이제 각 모델 학습, 평가, 실시간 모니터링에 대한 진행 상황과 소요 시간이 출력됩니다.

수정된 전체 코드
python
코드 복사
import numpy as np
import pandas as pd
import pymssql
from sklearn.model_selection import train_test_split
from sklearn.ensemble import RandomForestRegressor
from sklearn.linear_model import LinearRegression
from sklearn.svm import SVR
from sklearn.metrics import mean_squared_error
import matplotlib.pyplot as plt
from tqdm import tqdm  # 진행률 표시를 위한 라이브러리
import time  # 시간 측정을 위한 라이브러리


# 데이터베이스에서 데이터 읽기 함수
def fetch_data_from_procedure(proc_name, connection_details):
    """
    MSSQL 저장 프로시저에서 데이터를 가져오는 함수.
    :param proc_name: 저장 프로시저 이름 (str).
    :param connection_details: 데이터베이스 연결 정보 (dict).
    :return: Pandas DataFrame.
    """
    print(f"Fetching data from procedure: {proc_name}")
    try:
        conn = pymssql.connect(
            server=connection_details['server'],
            user=connection_details['user'],
            password=connection_details['password'],
            database=connection_details['database']
        )
        query = f"EXEC {proc_name}"  # 저장 프로시저 호출
        df = pd.read_sql(query, conn)  # 데이터를 Pandas DataFrame으로 변환
        conn.close()
        print(f"Data fetched successfully from {proc_name}!")
        return df
    except Exception as e:
        print(f"Database connection failed: {e}")
        return pd.DataFrame()


# DB 연결 정보
connection_details = {
    "server": "localhost",
    "user": "your_username",
    "password": "your_password",
    "database": "your_database"
}

# 데이터 읽기
print("Starting data fetching...")
start_time = time.time()

df_test_a = fetch_data_from_procedure("PTestA", connection_details)
df_test_b = fetch_data_from_procedure("PTestB", connection_details)
df_real_a = fetch_data_from_procedure("PRealA", connection_details)
df_real_b = fetch_data_from_procedure("PRealB", connection_details)

print(f"Data fetching completed in {time.time() - start_time:.2f} seconds.\n")

# 데이터 준비
if df_test_a.empty or df_test_b.empty or df_real_a.empty or df_real_b.empty:
    print("No data available. Check your procedures or database connection.")
    exit()

data_a = df_test_a.iloc[:, 1:].values[:4]
data_b = df_test_b.iloc[:, 1:].values[:4]
data = np.concatenate([data_a, data_b])

real_a = df_real_a.iloc[:, 1:].values[:4]
real_b = df_real_b.iloc[:, 1:].values[:4]
real_data = np.concatenate([real_a, real_b])

# 모델 리스트
models = {
    "RandomForest": RandomForestRegressor(),
    "LinearRegression": LinearRegression(),
    "SVR": SVR(kernel="linear")
}

# 최적 모델 찾기
print("Starting model training and evaluation...")
total_start_time = time.time()

best_models = []
errors = []

for i in tqdm(range(8), desc="Training models for each data point"):
    start_time = time.time()
    print(f"\nTraining models for data point {i + 1}/8...")
    
    # i번째 값을 제외한 나머지 7개 값으로 학습 데이터 구성
    X = np.delete(data, i).reshape(-1, 1)
    y = np.delete(data, np.arange(len(data)) != i)

    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

    # 각 모델로 학습 및 평가
    best_model = None
    best_error = float("inf")
    for model_name, model in models.items():
        print(f"Training model: {model_name}...")
        model.fit(X_train, y_train)
        predictions = model.predict(X_test)
        error = mean_squared_error(y_test, predictions)
        print(f"Model: {model_name}, MSE: {error:.5f}")

        if error < best_error:
            best_error = error
            best_model = model_name

    print(f"Best model for data point {i + 1}: {best_model} with MSE: {best_error:.5f}")
    best_models.append(best_model)
    errors.append(best_error)

    print(f"Training and evaluation for data point {i + 1} completed in {time.time() - start_time:.2f} seconds.\n")

print(f"Model training and evaluation completed in {time.time() - total_start_time:.2f} seconds.\n")
print("Best model for each data point:", best_models)
print("Errors for each model:", errors)

# 실시간 모니터링
print("Starting real-time monitoring...")
start_time = time.time()

avg_errors = []
for sample_idx, sample in enumerate(tqdm(real_data.reshape(-1, 8), desc="Monitoring real-time data")):
    print(f"\nProcessing real-time sample {sample_idx + 1}...")
    sample_start_time = time.time()

    sample_errors = []
    for i, model_name in enumerate(best_models):
        model = models[model_name]
        X_sample = np.delete(sample, i).reshape(-1, 1)
        y_sample = sample[i]

        prediction = model.predict(X_sample)
        error = abs(prediction - y_sample)
        print(f"Data point {i + 1}: Predicted={prediction[0]:.5f}, Actual={y_sample:.5f}, Error={error[0]:.5f}")
        sample_errors.append(error)

    avg_error = np.mean(sample_errors)
    avg_errors.append(avg_error)
    print(f"Average error for sample {sample_idx + 1}: {avg_error:.5f}")
    print(f"Real-time processing for sample {sample_idx + 1} completed in {time.time() - sample_start_time:.2f} seconds.\n")

print(f"Real-time monitoring completed in {time.time() - start_time:.2f} seconds.\n")

# 평균 오차의 변화 시각화
plt.plot(avg_errors, label="Average Prediction Error")
plt.xlabel("New Sample Index")
plt.ylabel("Average Error")
plt.legend()
plt.title("Real-time Monitoring of Prediction Errors")
plt.show()
수정된 출력 기능
데이터 읽기

각 프로시저에서 데이터를 읽을 때마다 진행 상황 출력.