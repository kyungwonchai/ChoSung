네, 알겠습니다. 이제 Agent 프로그램 (MonitorAgent)의 전체 코드를 제공해 드리겠습니다.

이 Agent 프로그램은 다음 주요 기능을 수행합니다:

지정된 중계 프로그램(MGSPBrokerService)으로 TCP 소켓 연결을 시도하고 유지합니다.
연결 성공 시 자신의 고유 ID와 시스템 정보를 중계 프로그램에 알립니다 (AgentHello).
자신의 현재 모니터 상태를 주기적으로 또는 변경 시 중계 프로그램에 보고합니다.
중계 프로그램으로부터 모니터 제어 명령 등을 수신하여 로컬에서 실행하고, 그 결과를 보고합니다.
게이트웨이 역할 수행: 중계 프로그램으로부터 "다른 최종 Agent에게 명령을 전달하라"는 요청을 받으면, 해당 최종 Agent와 직접 TCP 소켓 통신을 하여 명령을 전달하고 결과를 다시 중계 프로그램에 보고합니다.
프로젝트 생성:

Visual Studio에서 새 프로젝트를 만듭니다.
템플릿: "WPF 앱(.NET Framework)" (트레이 아이콘 등을 위해 WPF 기반 유지)
프로젝트 이름: MonitorAgent
프레임워크: ".NET Framework 4.5"
필요한 NuGet 패키지 설치:

Newtonsoft.Json: 메시지 직렬화/역직렬화.
패키지 관리자 콘솔: Install-Package Newtonsoft.Json
필요한 외부 파일 (Agent 실행 파일과 같은 폴더에 위치):

MonitorAgent.exe (빌드된 실행 파일)
(필수 배포) broker_address.txt: 중계 프로그램의 주소와 Agent 연결용 포트. 한 줄에 IP주소:포트 형식.
예시 broker_address.txt 내용:
127.0.0.1:9002
(자동 생성) agent_id.txt: Agent의 고유 ID가 저장됩니다.
(자동 생성) agent_log.txt: 로그 파일.
Agent 프로그램 (MonitorAgent) 코드 구성:

1. Config/AppConstants.cs

C#

// MonitorAgent/Config/AppConstants.cs
namespace MonitorAgent.Config
{
    public static class AppConstants
    {
        public const string AgentIdFileName = "agent_id.txt";
        public const string BrokerAddressFileName = "broker_address.txt"; // 중계 서버 주소:포트
        public const string LogFileName = "agent_log.txt";
        public const string AppName = "MonitorAgent"; // 시작프로그램 등록 등에 사용
    }
}
2. Config/AgentIdentifier.cs (이전과 유사, Broker 프로젝트의 것과 거의 동일하게 사용 가능)

C#

// MonitorAgent/Config/AgentIdentifier.cs
using System;
using System.IO;
using System.Linq;
using System.Net.NetworkInformation;
using MonitorAgent.Services; // ILoggingService

namespace MonitorAgent.Config
{
    public class AgentIdentifier
    {
        private readonly ILoggingService _logger;
        private readonly string _filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppConstants.AgentIdFileName);
        public string Id { get; private set; }

        public AgentIdentifier(ILoggingService logger)
        {
            _logger = logger;
            LoadOrGenerateId();
        }

        private void LoadOrGenerateId()
        {
            if (File.Exists(_filePath))
            {
                try
                {
                    Id = File.ReadAllText(_filePath).Trim();
                    if (!string.IsNullOrWhiteSpace(Id))
                    {
                        _logger.LogInfo($"Agent ID loaded from file: {Id}");
                        return;
                    }
                    _logger.LogWarning("Agent ID file was empty. A new ID will be generated.");
                }
                catch (Exception ex)
                {
                    _logger.LogError($"Failed to read Agent ID file. A new ID will be generated. Error: {ex.Message}");
                }
            }
            
            try
            {
                string macAddress = NetworkInterface.GetAllNetworkInterfaces()
                    .Where(nic => nic.OperationalStatus == OperationalStatus.Up && 
                                  nic.NetworkInterfaceType != NetworkInterfaceType.Loopback && 
                                  nic.NetworkInterfaceType != NetworkInterfaceType.Tunnel)
                    .Select(nic => nic.GetPhysicalAddress().ToString())
                    .FirstOrDefault(mac => !string.IsNullOrEmpty(mac) && mac.Length >= 12); // 유효한 MAC 주소

                if (string.IsNullOrEmpty(macAddress))
                {
                    macAddress = Guid.NewGuid().ToString("N").Substring(0, 12).ToUpper();
                    _logger.LogWarning("Could not retrieve a valid MAC address. Using GUID fragment for Agent ID.");
                }
                Id = $"{Environment.MachineName.Replace(" ", "_")}-{macAddress}"; // 공백 제거 및 조합

                File.WriteAllText(_filePath, Id);
                _logger.LogInfo($"New Agent ID generated and saved: {Id}");
            }
            catch (Exception ex)
            {
                Id = Guid.NewGuid().ToString(); // 최종 폴백
                _logger.LogError($"Failed to generate MAC/MachineName based Agent ID. Using GUID: {Id}. Error: {ex.Message}", ex);
            }
        }
    }
}
3. Config/BrokerAddressProvider.cs

C#

// MonitorAgent/Config/BrokerAddressProvider.cs
using System;
using System.IO;
using System.Net;
using MonitorAgent.Services;

namespace MonitorAgent.Config
{
    public class BrokerAddressProvider
    {
        private readonly ILoggingService _logger;
        private readonly string _filePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppConstants.BrokerAddressFileName);
        
        public IPAddress BrokerIpAddress { get; private set; }
        public int BrokerPort { get; private set; }
        public bool IsValid { get; private set; } = false;

        public BrokerAddressProvider(ILoggingService logger)
        {
            _logger = logger;
            LoadAddress();
        }

        private void LoadAddress()
        {
            if (!File.Exists(_filePath))
            {
                _logger.LogError($"Broker address file not found: {_filePath}. Agent cannot connect. Please create this file with 'IP_ADDRESS:PORT'.");
                CreateSampleBrokerAddressFile();
                return;
            }

            try
            {
                string addressString = File.ReadAllText(_filePath).Trim();
                if (string.IsNullOrWhiteSpace(addressString))
                {
                    _logger.LogError($"Broker address in {_filePath} is empty.");
                    return;
                }

                string[] parts = addressString.Split(':');
                if (parts.Length != 2)
                {
                    _logger.LogError($"Invalid broker address format in {_filePath}. Expected 'IP_ADDRESS:PORT'. Found: '{addressString}'.");
                    return;
                }

                if (!IPAddress.TryParse(parts[0], out IPAddress ip))
                {
                    _logger.LogError($"Invalid IP address part in broker address: '{parts[0]}'.");
                    return;
                }
                BrokerIpAddress = ip;

                if (!int.TryParse(parts[1], out int port) || port <= 0 || port > 65535)
                {
                    _logger.LogError($"Invalid port number part in broker address: '{parts[1]}'. Port must be 1-65535.");
                    return;
                }
                BrokerPort = port;
                IsValid = true;
                _logger.LogInfo($"Broker address loaded: {BrokerIpAddress}:{BrokerPort}");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Failed to read or parse Broker address file. Error: {ex.Message}", ex);
            }
        }

        private void CreateSampleBrokerAddressFile()
        {
            try
            {
                File.WriteAllText(_filePath, "127.0.0.1:9002" + Environment.NewLine + "# Replace with your actual MGSPBrokerService IP address and Agent port.");
                _logger.LogInfo($"Sample broker_address.txt created. Please configure it.");
            }
            catch(Exception ex)
            {
                _logger.LogError("Failed to create sample broker_address.txt.", ex);
            }
        }
    }
}
4. Services/LoggingService.cs (이전 Broker의 것과 유사하게 사용 가능, AppConstants 참조 수정)

C#

// MonitorAgent/Services/LoggingService.cs
using System;
using System.IO;
using System.Text;
using MonitorAgent.Config; // AppConstants

namespace MonitorAgent.Services
{
    public enum LogLevel { Debug, Info, Warning, Error, Fatal } // Broker와 동일하게

    public interface ILoggingService
    {
        void LogDebug(string message);
        void LogInfo(string message);
        void LogWarning(string message);
        void LogError(string message, Exception ex = null);
        void LogFatal(string message, Exception ex = null);
        // UI 전송용 로그는 Agent에선 필요 없을 수 있음
    }

    public class AgentLoggingService : ILoggingService
    {
        private readonly string _logFilePath;
        private static readonly object _fileLock = new object();
        private LogLevel _currentLogLevel = LogLevel.Info; // 기본, 설정 파일에서 읽어올 수 있음

        public AgentLoggingService(string logLevelFromConfig = "Info") // 설정 로드 후 주입 가능
        {
            _logFilePath = Path.Combine(AppDomain.CurrentDomain.BaseDirectory, AppConstants.LogFileName);
            SetLogLevel(logLevelFromConfig); // 생성 시 로그 레벨 설정
            LogInfo($"Agent Logging Service initialized. Log file: {_logFilePath}");
        }
        
        public void SetLogLevel(string logLevelString)
        {
            if (Enum.TryParse(logLevelString, true, out LogLevel level))
            {
                _currentLogLevel = level;
                // LogInfo($"Log level set to: {_currentLogLevel}"); // 로그 레벨 변경 시 너무 많은 로그 방지
            }
            else
            {
                LogWarning($"Invalid log level string: {logLevelString}. Using default: {_currentLogLevel}");
            }
        }

        private void WriteLog(LogLevel level, string message, Exception ex = null)
        {
            if (level < _currentLogLevel) return;

            string logEntry = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss.fff}] [{level.ToString().ToUpper()}] {message}";
            if (ex != null)
            {
                logEntry += $"{Environment.NewLine}   Exception: {ex.ToString()}";
            }

            Console.WriteLine(logEntry); // Agent도 콘솔 출력 (디버깅용)

            lock (_fileLock)
            {
                try
                {
                    File.AppendAllText(_logFilePath, logEntry + Environment.NewLine);
                }
                catch { /* 파일 쓰기 실패는 일단 무시 */ }
            }
        }

        public void LogDebug(string message) => WriteLog(LogLevel.Debug, message);
        public void LogInfo(string message) => WriteLog(LogLevel.Info, message);
        public void LogWarning(string message) => WriteLog(LogLevel.Warning, message);
        public void LogError(string message, Exception ex = null) => WriteLog(LogLevel.Error, message, ex);
        public void LogFatal(string message, Exception ex = null) => WriteLog(LogLevel.Fatal, message, ex);
    }
}
5. Services/MonitorControlService.cs (이전과 동일)

C#

// MonitorAgent/Services/MonitorControlService.cs
using System;
using System.Runtime.InteropServices;

namespace MonitorAgent.Services
{
    public interface IMonitorControlService
    {
        bool TurnMonitorOn();
        bool TurnMonitorOff();
        string GetCurrentMonitorStateApproximation(); // 현재 상태 추정 (마지막 명령 기반)
    }

    public class MonitorControlService : IMonitorControlService
    {
        private readonly ILoggingService _logger;
        private const int WM_SYSCOMMAND = 0x0112;
        private const int SC_MONITORPOWER = 0xF170;
        private const int MONITOR_ON = -1;
        private const int MONITOR_OFF = 2;
        private static readonly IntPtr HWND_BROADCAST = new IntPtr(0xFFFF);

        [DllImport("user32.dll", CharSet = CharSet.Auto, SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, uint Msg, IntPtr wParam, IntPtr lParam);

        private string _lastKnownMonitorState = "Unknown"; // 마지막으로 실행한 명령 기반 상태

        public MonitorControlService(ILoggingService logger)
        {
            _logger = logger;
        }

        public bool TurnMonitorOn()
        {
            _logger.LogInfo("Attempting to turn monitor ON.");
            try
            {
                SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
                _logger.LogInfo("Monitor ON command sent successfully.");
                _lastKnownMonitorState = "On";
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to send Monitor ON command.", ex);
                return false;
            }
        }

        public bool TurnMonitorOff()
        {
            _logger.LogInfo("Attempting to turn monitor OFF.");
            try
            {
                SendMessage(HWND_BROADCAST, WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
                _logger.LogInfo("Monitor OFF command sent successfully.");
                _lastKnownMonitorState = "Off";
                return true;
            }
            catch (Exception ex)
            {
                _logger.LogError("Failed to send Monitor OFF command.", ex);
                return false;
            }
        }
        
        public string GetCurrentMonitorStateApproximation()
        {
            // 실제 API로 상태를 읽는 것은 매우 복잡. 마지막 명령으로 추정.
            return _lastKnownMonitorState;
        }
    }
}
6. Models/MessageContract.cs (Broker와 동일한 파일 사용 또는 복사)

이 파일은 MGSPBrokerService 프로젝트의 Models/MessageContract.cs 와 완전히 동일한 내용이어야 합니다. 메시지 규약이 일치해야 통신이 가능합니다. 이전 답변에서 제공된 MGSPBrokerService의 MessageContract.cs 코드를 그대로 가져와서 이 프로젝트에 추가합니다.

7. Network/BrokerTcpClient.cs (중계 프로그램 연결 클라이언트)

C#

// MonitorAgent/Network/BrokerTcpClient.cs
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Config; // BrokerAddressProvider
using MonitorAgent.Models; // BrokerMessage
using MonitorAgent.Services; // ILoggingService
using Newtonsoft.Json;

namespace MonitorAgent.Network
{
    public class BrokerTcpClient : IDisposable
    {
        private readonly BrokerAddressProvider _addressProvider;
        private readonly string _agentId;
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private CancellationTokenSource _cts;
        private Task _receiveLoopTask;
        private readonly TimeSpan _retryConnectDelay = TimeSpan.FromSeconds(10);
        private readonly TimeSpan _statusReportInterval = TimeSpan.FromSeconds(30); // 상태 보고 주기
        private Timer _statusReportTimer;
        private readonly Func<string> _getCurrentMonitorStatusFunc; // 현재 모니터 상태를 가져오는 함수 참조
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected && _networkStream != null;

        public event Action<BrokerMessage> OnBrokerMessageReceived; // Broker로부터 받은 메시지 처리용
        public event Action OnDisconnectedFromBroker;

        public BrokerTcpClient(BrokerAddressProvider addressProvider, string agentId, ILoggingService logger, Func<string> getCurrentMonitorStatusFunc)
        {
            _addressProvider = addressProvider;
            _agentId = agentId;
            _logger = logger;
            _getCurrentMonitorStatusFunc = getCurrentMonitorStatusFunc;
        }

        public async Task StartAsync(CancellationTokenSource parentCts)
        {
            if (!_addressProvider.IsValid)
            {
                _logger.LogError("Broker address is invalid. Cannot start BrokerTcpClient.");
                return;
            }
            _cts = CancellationTokenSource.CreateLinkedTokenSource(parentCts.Token);
            
            // 연결 및 메시지 수신 루프를 백그라운드에서 실행
            // ConnectAndReceiveLoopAsync는 내부적으로 연결이 끊기면 재연결을 시도함
            _ = Task.Run(ConnectAndReceiveLoopAsync, _cts.Token);
        }
        
        private async Task ConnectAndReceiveLoopAsync()
        {
            while (!_cts.IsCancellationRequested)
            {
                if (!IsConnected) // 연결되어 있지 않다면 연결 시도
                {
                    try
                    {
                        _logger.LogInfo($"Attempting to connect to Broker: {_addressProvider.BrokerIpAddress}:{_addressProvider.BrokerPort}");
                        _tcpClient = new TcpClient();
                        var connectTask = _tcpClient.ConnectAsync(_addressProvider.BrokerIpAddress, _addressProvider.BrokerPort);
                        var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5), _cts.Token);

                        if (await Task.WhenAny(connectTask, timeoutTask).ConfigureAwait(false) == connectTask && connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                        {
                            _networkStream = _tcpClient.GetStream();
                            _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                            _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                            _logger.LogInfo("Successfully connected to Broker.");

                            // 연결 성공 시 AgentHello 전송
                            await SendAgentHelloAsync();

                            // 상태 보고 타이머 시작
                            _statusReportTimer?.Dispose();
                            _statusReportTimer = new Timer(ReportStatusTimerCallback, null, TimeSpan.Zero, _statusReportInterval);

                            // 메시지 수신 시작
                            await ReceiveMessagesAsync(); // 이 메서드는 연결이 끊기면 종료됨
                        }
                        else
                        {
                            _tcpClient.Close(); // 연결 실패 또는 타임아웃 시 정리
                            if (_cts.IsCancellationRequested) break;
                            _logger.LogWarning($"Failed to connect to Broker. Retrying in {_retryConnectDelay.TotalSeconds}s...");
                        }
                    }
                    catch (OperationCanceledException) when (_cts.IsCancellationRequested) {
                        _logger.LogInfo("Connection/Receive loop cancelled.");
                        break;
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError($"Error during connection attempt to Broker: {ex.Message}. Retrying in {_retryConnectDelay.TotalSeconds}s...");
                         _tcpClient?.Close(); // 연결 실패 시 정리
                    }
                }
                
                // 재연결 시도 전 대기 (연결이 끊겼거나, 위에서 연결 실패한 경우)
                if (!_cts.IsCancellationRequested)
                {
                    try
                    {
                        await Task.Delay(_retryConnectDelay, _cts.Token);
                    }
                    catch (OperationCanceledException) { break; } // Delay 중 취소
                }
            }
            _logger.LogInfo("BrokerTcpClient ConnectAndReceiveLoopAsync ended.");
            CleanupConnectionResources(); // 루프 종료 시 항상 정리
            OnDisconnectedFromBroker?.Invoke();
        }


        private async Task SendAgentHelloAsync()
        {
            var helloPayload = new AgentHelloPayload
            {
                AgentIdProvidedByApp = _agentId,
                MachineName = Environment.MachineName,
                IpAddresses = GetLocalIpAddresses(),
                AgentVersion = Assembly.GetExecutingAssembly().GetName().Version.ToString()
            };
            var helloMessage = new BrokerMessage
            {
                Type = MessageType.AgentHello,
                SourceId = _agentId,
                Payload = JsonConvert.SerializeObject(helloPayload)
            };
            await SendMessageAsync(helloMessage);
            _logger.LogInfo("AgentHello message sent to Broker.");
        }

        private async void ReportStatusTimerCallback(object state)
        {
            await ReportCurrentStatusAsync();
        }

        public async Task ReportCurrentStatusAsync()
        {
            if (!IsConnected) return;
            string monitorStatus = _getCurrentMonitorStatusFunc?.Invoke() ?? "Unknown";
            var statusPayload = new AgentStatusUpdatePayload { CurrentMonitorStatus = monitorStatus };
            var statusMessage = new BrokerMessage
            {
                Type = MessageType.AgentToBroker_StatusUpdate,
                SourceId = _agentId,
                Payload = JsonConvert.SerializeObject(statusPayload)
            };
            await SendMessageAsync(statusMessage);
            // _logger.LogDebug($"Sent status update to Broker: Monitor={monitorStatus}"); // 너무 잦을 수 있음
        }

        public async Task ReportCommandResultAsync(string correlationId, bool success, string message, string currentMonitorStatus)
        {
             if (!IsConnected) {
                _logger.LogWarning("Cannot report command result, not connected to Broker.");
                return;
             }
            var resultPayload = new AgentCommandResultPayload { Success = success, Message = message, CurrentMonitorStatus = currentMonitorStatus };
            var resultMessage = new BrokerMessage
            {
                Type = MessageType.AgentToBroker_CommandResult,
                SourceId = _agentId,
                CorrelationId = correlationId,
                Payload = JsonConvert.SerializeObject(resultPayload)
            };
            await SendMessageAsync(resultMessage);
            _logger.LogInfo($"Command result (CorrId: {correlationId}, Success: {success}) sent to Broker.");
        }


        private async Task ReceiveMessagesAsync()
        {
            _logger.LogInfo($"Starting to receive messages from Broker for {_agentId}");
            try
            {
                while (!_cts.Token.IsCancellationRequested && IsConnected)
                {
                    string messageJson = await _streamReader.ReadLineAsync();
                    if (messageJson == null) {
                        _logger.LogInfo($"Broker disconnected or stream closed for {_agentId}.");
                        break; 
                    }
                    if (string.IsNullOrWhiteSpace(messageJson)) continue;

                    try
                    {
                        var message = JsonConvert.DeserializeObject<BrokerMessage>(messageJson);
                        if (message != null)
                        {
                            OnBrokerMessageReceived?.Invoke(message);
                        }
                        else
                        {
                            _logger.LogWarning($"Failed to deserialize message from Broker: {messageJson}");
                        }
                    }
                    catch (JsonException jsonEx)
                    {
                        _logger.LogError($"JSON deserialization error from Broker: {jsonEx.Message}. Received: {messageJson}", jsonEx);
                    }
                }
            }
            catch (IOException ioEx)
            {
                _logger.LogInfo($"IOException in receive loop from Broker for {_agentId} (likely connection forcibly closed): {ioEx.Message}");
            }
            catch (ObjectDisposedException)
            {
                _logger.LogInfo($"Receive loop for {_agentId} from Broker terminated due to object disposal.");
            }
            catch (OperationCanceledException)
            {
                 _logger.LogInfo($"Receive loop for {_agentId} from Broker cancelled.");
            }
            catch (Exception ex)
            {
                _logger.LogError($"Unexpected error in receive loop from Broker for {_agentId}: {ex.Message}", ex);
            }
            finally
            {
                _logger.LogInfo($"Receive loop from Broker for {_agentId} ended.");
                // 연결이 여기서 끊겼음을 인지하고, ConnectAndReceiveLoopAsync가 재연결 시도하도록 함
                // CleanupConnectionResources(); // 여기서 호출하면 ConnectAndReceiveLoopAsync의 재연결 로직과 충돌 가능
                // OnDisconnectedFromBroker?.Invoke(); // ConnectAndReceiveLoopAsync에서 처리
            }
        }
        
        public Task SendMessageAsync(BrokerMessage message)
        {
            if (!IsConnected || _streamWriter == null)
            {
                _logger.LogWarning($"Cannot send message to Broker. Not connected or writer is null. MessageType: {message.Type}");
                return Task.FromResult(false); // 또는 Task.CompletedTask in .NET 4.6+
            }
            if (_isDisposed) return Task.FromResult(false);

            // lock을 사용하여 _streamWriter에 대한 동시 접근을 막음
            // WriteLineAsync는 스레드 안전하지 않을 수 있음
            Task task = Task.FromResult(true);
            lock(_sendLock)
            {
                if (IsConnected && _streamWriter != null && !_isDisposed)
                {
                    try
                    {
                        string messageJson = JsonConvert.SerializeObject(message);
                        // WriteLineAsync를 호출하고 반환된 Task를 즉시 await하지 않고 반환하여 호출자가 await하도록 함
                        // 하지만 이 메서드 시그니처가 Task이므로, 실제 비동기 작업을 수행해야 함.
                        // 일반적인 패턴은 StreamWriter.WriteLineAsync()를 사용하거나,
                        // Write를 별도 스레드/태스크에서 처리하는 것임.
                        // 여기서는 단순화를 위해 동기적으로 쓰고 Task.FromResult로 감쌈 (고성능에는 부적합)
                        // 또는 진짜 비동기로 만들려면:
                        // task = _streamWriter.WriteLineAsync(messageJson);
                        
                        _streamWriter.WriteLine(messageJson); // 동기적 쓰기
                        // _logger.LogDebug($"Message sent to Broker: {message.Type}"); // 너무 잦은 로그

                    }
                    catch (ObjectDisposedException)
                    {
                        _logger.LogWarning($"Attempted to send message to Broker on a disposed stream/writer (Type: {message.Type}).");
                        CleanupConnectionResources();
                        OnDisconnectedFromBroker?.Invoke();
                        return Task.FromResult(false);
                    }
                    catch (IOException ioEx)
                    {
                        _logger.LogError($"IOException sending message to Broker (Type: {message.Type}, connection may be lost): {ioEx.Message}", ioEx);
                        CleanupConnectionResources();
                        OnDisconnectedFromBroker?.Invoke();
                        return Task.FromResult(false);
                    }
                    catch (Exception ex)
                    {
                        _logger.LogError($"Error sending message to Broker (Type: {message.Type}): {ex.Message}", ex);
                        // 이 경우에도 연결이 끊어졌을 가능성 높음
                        CleanupConnectionResources();
                        OnDisconnectedFromBroker?.Invoke();
                        return Task.FromResult(false);
                    }
                }
                else
                {
                    return Task.FromResult(false);
                }
            }
            return task; // 이 Task는 실제로는 거의 즉시 완료될 것임 (동기 쓰기 후)
                         // 진정한 비동기 쓰기를 원하면 _streamWriter.WriteLineAsync 사용
        }

        private void CleanupConnectionResources()
        {
            _logger.LogInfo($"Cleaning up connection resources for BrokerTcpClient (AgentId: {_agentId}).");
            _statusReportTimer?.Dispose();
            _statusReportTimer = null;

            try { _streamWriter?.Dispose(); } catch { /* ignore */ }
            _streamWriter = null;
            try { _streamReader?.Dispose(); } catch { /* ignore */ }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { /* ignore */ }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { /* ignore */ } // Close는 Dispose 호출
            _tcpClient = null;
        }
        
        public static List<string> GetLocalIpAddresses() // AgentCoreService에서 사용할 수 있도록 public static
        {
            var ipAddresses = new List<string>();
            try
            {
                foreach (NetworkInterface item in NetworkInterface.GetAllNetworkInterfaces())
                {
                    if (item.OperationalStatus == OperationalStatus.Up && 
                        (item.NetworkInterfaceType == NetworkInterfaceType.Ethernet || item.NetworkInterfaceType == NetworkInterfaceType.Wireless80211))
                    {
                        foreach (UnicastIPAddressInformation ip in item.GetIPProperties().UnicastAddresses)
                        {
                            if (ip.Address.AddressFamily == AddressFamily.InterNetwork) // IPv4
                            {
                                ipAddresses.Add(ip.Address.ToString());
                            }
                        }
                    }
                }
            }
            catch (Exception) { /* 로거가 없을 수 있음 */ }
            return ipAddresses.Distinct().ToList();
        }


        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;

            _logger.LogInfo($"Disposing BrokerTcpClient for AgentId: {_agentId}.");
            _cts?.Cancel(); // 모든 비동기 작업 취소
            _cts?.Dispose();
            _cts = null;

            CleanupConnectionResources(); // 연결 관련 리소스 정리
            _logger.LogInfo($"BrokerTcpClient for AgentId: {_agentId} disposed.");
        }
    }
}
8. Network/DownstreamAgentClient.cs (게이트웨이 역할 시 최종 Agent 연결 클라이언트)

이 클래스는 게이트웨이 Agent가 최종 대상 Agent에게 명령을 전달할 때 사용합니다. BrokerTcpClient와 유사하지만, 대상이 Broker가 아닌 다른 Agent입니다.

C#

// MonitorAgent/Network/DownstreamAgentClient.cs
using System;
using System.IO;
using System.Net;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using MonitorAgent.Models;
using MonitorAgent.Services;
using Newtonsoft.Json;

namespace MonitorAgent.Network
{
    // 이 클래스는 게이트웨이 Agent가 최종 대상 Agent에게 명령을 전달하고 응답을 받을 때 사용.
    // 단발성 연결 및 요청/응답 처리에 더 적합하게 만들 수 있음.
    public class DownstreamAgentClient : IDisposable
    {
        private readonly ILoggingService _logger;
        private TcpClient _tcpClient;
        private NetworkStream _networkStream;
        private StreamReader _streamReader;
        private StreamWriter _streamWriter;
        private readonly object _sendLock = new object();
        private bool _isDisposed = false;

        public bool IsConnected => _tcpClient != null && _tcpClient.Connected;

        public DownstreamAgentClient(ILoggingService logger)
        {
            _logger = logger;
        }

        public async Task<bool> ConnectAsync(string targetIp, int targetPort, CancellationToken token = default(CancellationToken))
        {
            if (IsConnected) Disconnect(); // 기존 연결이 있다면 정리
            if (_isDisposed) throw new ObjectDisposedException(nameof(DownstreamAgentClient));

            _logger.LogInfo($"Downstream: Attempting to connect to final target Agent: {targetIp}:{targetPort}");
            _tcpClient = new TcpClient();
            try
            {
                var connectTask = _tcpClient.ConnectAsync(targetIp, targetPort);
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(5), token); // 연결 타임아웃 5초

                if (await Task.WhenAny(connectTask, timeoutTask).ConfigureAwait(false) == connectTask && connectTask.Status == TaskStatus.RanToCompletion && _tcpClient.Connected)
                {
                    _networkStream = _tcpClient.GetStream();
                    _streamReader = new StreamReader(_networkStream, Encoding.UTF8);
                    _streamWriter = new StreamWriter(_networkStream, Encoding.UTF8) { AutoFlush = true };
                    _logger.LogInfo($"Downstream: Successfully connected to final target Agent {targetIp}:{targetPort}.");
                    return true;
                }
                else
                {
                    _tcpClient.Close();
                    if (token.IsCancellationRequested)
                        _logger.LogInfo("Downstream: Connection attempt to final target Agent cancelled.");
                    else
                        _logger.LogWarning($"Downstream: Timeout or error connecting to final target Agent {targetIp}:{targetPort}.");
                    return false;
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error connecting to final target Agent {targetIp}:{targetPort}: {ex.Message}", ex);
                _tcpClient?.Close();
                return false;
            }
        }

        public async Task<AgentCommandResultPayload> SendCommandAndGetResponseAsync(BrokerExecuteControlPayload commandToRelay, string originalCorrelationId, CancellationToken token = default(CancellationToken))
        {
            if (!IsConnected)
            {
                _logger.LogError("Downstream: Not connected. Cannot send command.");
                return new AgentCommandResultPayload { Success = false, Message = "Gateway not connected to final agent." };
            }
             if (_isDisposed) throw new ObjectDisposedException(nameof(DownstreamAgentClient));

            try
            {
                // 최종 Agent에게 보낼 메시지는 BrokerToAgent_ExecuteControl과 동일한 구조로.
                // 다만, SourceId, TargetId는 이 통신에서는 덜 중요할 수 있음. CorrelationId는 유지.
                var messageToFinalAgent = new BrokerMessage
                {
                    Type = MessageType.BrokerToAgent_ExecuteControl, // 이 타입을 최종 Agent도 이해해야 함.
                    CorrelationId = originalCorrelationId,
                    // SourceId는 이 GatewayAgent의 ID가 될 수 있음 (선택적)
                    // TargetId는 최종 Agent의 ID (여기서는 IP로 식별)
                    Payload = JsonConvert.SerializeObject(new BrokerExecuteControlPayload // commandToRelay를 그대로 보내면 IsGatewayRelay 등이 혼동될 수 있으므로, 필요한 부분만 다시 구성
                    {
                        ActionToPerform = commandToRelay.ActionToPerform,
                        Parameters = commandToRelay.Parameters,
                        IsGatewayRelay = false // 최종 Agent에게는 이것이 직접 명령임
                    })
                };

                string requestJson = JsonConvert.SerializeObject(messageToFinalAgent);
                _logger.LogDebug($"Downstream: Sending to final agent: {requestJson}");
                
                lock (_sendLock) // StreamWriter 동시 접근 방지
                {
                    if (IsConnected) _writer.WriteLine(requestJson); else throw new IOException("Connection lost before send.");
                }

                // 응답 수신 (타임아웃 필요)
                // 최종 Agent도 명령 처리 후 AgentToBroker_CommandResult 형식으로 응답한다고 가정
                var readTask = _streamReader.ReadLineAsync();
                var timeoutTask = Task.Delay(TimeSpan.FromSeconds(30), token); // 응답 대기 타임아웃 30초

                if (await Task.WhenAny(readTask, timeoutTask).ConfigureAwait(false) == readTask && readTask.Result != null)
                {
                    string responseJson = readTask.Result;
                    _logger.LogDebug($"Downstream: Received from final agent: {responseJson}");
                    var responseMessage = JsonConvert.DeserializeObject<BrokerMessage>(responseJson);
                    if (responseMessage != null && responseMessage.Type == MessageType.AgentToBroker_CommandResult)
                    {
                        return JsonConvert.DeserializeObject<AgentCommandResultPayload>(responseMessage.Payload);
                    }
                    else
                    {
                        _logger.LogWarning($"Downstream: Unexpected or invalid response from final agent: {responseJson}");
                        return new AgentCommandResultPayload { Success = false, Message = "Invalid response from final agent." };
                    }
                }
                else
                {
                    if (token.IsCancellationRequested)
                        _logger.LogWarning("Downstream: Response wait cancelled for final agent.");
                    else
                        _logger.LogWarning("Downstream: Timeout waiting for response from final agent.");
                    return new AgentCommandResultPayload { Success = false, Message = "Timeout or cancelled waiting for final agent response." };
                }
            }
            catch (Exception ex)
            {
                _logger.LogError($"Downstream: Error during command relay to final agent: {ex.Message}", ex);
                return new AgentCommandResultPayload { Success = false, Message = $"Error relaying to final agent: {ex.Message}" };
            }
            finally
            {
                Disconnect(); // 각 명령 후 연결 종료 (단발성으로 사용 시) 또는 유지할 수도 있음
            }
        }

        public void Disconnect()
        {
            if (_isDisposed) return;
            _logger.LogInfo("Downstream: Disconnecting from final target Agent.");
            try { _streamWriter?.Dispose(); } catch { }
            _streamWriter = null;
            try { _streamReader?.Dispose(); } catch { }
            _streamReader = null;
            try { _networkStream?.Dispose(); } catch { }
            _networkStream = null;
            try { _tcpClient?.Close(); } catch { }
            _tcpClient = null;
        }

        public void Dispose()
        {
            if (_isDisposed) return;
            _isDisposed = true;
            Disconnect();
            GC.SuppressFinalize(this);
        }
    }
}
9. Core/AgentCore.cs (Agent 핵심 로직)

C#

// MonitorAgent/Core/AgentCore.cs
using System;
using System.Threading;
using System.Threading.Tasks;
using MonitorAgent.Config;
using MonitorAgent.Models;
using MonitorAgent.Network;
using MonitorAgent.Services;
using Newtonsoft.Json;
using System.Net.Sockets; // TcpClient 사용을 위해
using System.Reflection; // Assembly Version

namespace MonitorAgent.Core
{
    public enum AgentOperationalStatus // Agent의 로컬 상태
    {
        Initializing,
        ConnectingToBroker,
        ConnectedToBroker, // Broker와 연결됨 (아직 Hello 전일 수 있음)
        IdentifiedToBroker, // Broker에게 Hello 보내고 인식됨
        Running,            // 정상 작동 중
        RelayingCommand,    // 게이트웨이로서 명령 중계 중
        Disconnected,
        Error,
        Stopping
    }

    public class AgentCore : IDisposable
    {
        private readonly ILoggingService _logger;
        private readonly AgentIdentifier _agentIdentifier;
        private readonly BrokerAddressProvider _brokerAddressProvider;
        private readonly IMonitorControlService _monitorControl;
        
        private BrokerTcpClient _brokerClient;
        private CancellationTokenSource _mainCts;
        private AgentOperationalStatus _currentStatus;

        public event Action<AgentOperationalStatus, string> OnStatusChanged;

        public AgentCore(ILoggingService logger, AgentIdentifier agentIdentifier, BrokerAddressProvider brokerAddressProvider, IMonitorControlService monitorControl)
        {
            _logger = logger;
            _agentIdentifier = agentIdentifier;
            _brokerAddressProvider = brokerAddressProvider;
            _monitorControl = monitorControl;
            UpdateStatus(AgentOperationalStatus.Initializing, "Agent core created.");
        }

        public async Task StartAsync()
        {
            if (_mainCts != null && !_mainCts.IsCancellationRequested)
            {
                _logger.LogWarning("AgentCore is already running or starting.");
                return;
            }
            _mainCts = new CancellationTokenSource();
            UpdateStatus(AgentOperationalStatus.Initializing, "Agent core starting...");

            if (!_brokerAddressProvider.IsValid)
            {
                UpdateStatus(AgentOperationalStatus.Error, "Broker address configuration is invalid. Cannot connect.");
                return;
            }

            _brokerClient = new BrokerTcpClient(_brokerAddressProvider, _agentIdentifier.Id, _logger, _monitorControl.GetCurrentMonitorStateApproximation);
            _brokerClient.OnBrokerMessageReceived += HandleBrokerMessage;
            _brokerClient.OnDisconnectedFromBroker += HandleBrokerDisconnection;

            // BrokerTcpClient의 StartAsync는 내부적으로 연결 및 재연결 루프를 돌림
            _ = _brokerClient.StartAsync(_mainCts); // 백그라운드에서 실행, 반환된 Task를 기다리지 않음

            UpdateStatus(AgentOperationalStatus.ConnectingToBroker, $"Attempting to connect to Broker at {_brokerAddressProvider.BrokerIpAddress}:{_brokerAddressProvider.BrokerPort}");
            // 실제 연결 상태는 BrokerTcpClient 내부 이벤트나 IsConnected 속성으로 확인
        }

        private void HandleBrokerMessage(BrokerMessage message)
        {
            _logger.LogInfo($"Message received from Broker: {message.Type}, CorrId: {message.CorrelationId}");
            switch (message.Type)
            {
                case MessageType.BrokerToAgent_ExecuteControl:
                    HandleExecuteControlCommand(message);
                    break;
                case MessageType.BrokerAck_AgentHello:
                    UpdateStatus(AgentOperationalStatus.IdentifiedToBroker, "Successfully identified to Broker.");
                    // Broker가 Hello Ack를 보내면 여기서 Running 상태로 변경해도 됨
                    UpdateStatus(AgentOperationalStatus.Running, "Agent is running and connected to Broker.");
                    break;
                case MessageType.Ping:
                    HandlePingFromBroker(message);
                    break;
                // 다른 메시지 타입 처리 ...
                default:
                    _logger.LogWarning($"Unhandled message type '{message.Type}' from Broker.");
                    break;
            }
        }

        private async void HandleExecuteControlCommand(BrokerMessage commandMessage)
        {
            BrokerExecuteControlPayload controlPayload = null;
            try
            {
                controlPayload = JsonConvert.DeserializeObject<BrokerExecuteControlPayload>(commandMessage.Payload);
            }
            catch (JsonException jsonEx)
            {
                _logger.LogError($"Failed to parse BrokerExecuteControlPayload: {jsonEx.Message}. Payload: {commandMessage.Payload}", jsonEx);
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, false, "Invalid command payload.", _monitorControl.GetCurrentMonitorStateApproximation());
                return;
            }

            if (controlPayload == null)
            {
                _logger.LogError("BrokerExecuteControlPayload is null after deserialization.");
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, false, "Null command payload.", _monitorControl.GetCurrentMonitorStateApproximation());
                return;
            }

            bool result = false;
            string resultMessage = "Execution failed.";
            string monitorStatusAfterCommand = _monitorControl.GetCurrentMonitorStateApproximation();

            if (!controlPayload.IsGatewayRelay) // 이 Agent가 최종 실행 대상
            {
                _logger.LogInfo($"Executing direct command: {controlPayload.ActionToPerform}");
                switch (controlPayload.ActionToPerform)
                {
                    case "TurnMonitorOn":
                        result = _monitorControl.TurnMonitorOn();
                        resultMessage = result ? "Monitor turned ON." : "Failed to turn monitor ON.";
                        break;
                    case "TurnMonitorOff":
                        result = _monitorControl.TurnMonitorOff();
                        resultMessage = result ? "Monitor turned OFF." : "Failed to turn monitor OFF.";
                        break;
                    default:
                        resultMessage = $"Unknown direct action: {controlPayload.ActionToPerform}";
                        _logger.LogWarning(resultMessage);
                        break;
                }
                monitorStatusAfterCommand = _monitorControl.GetCurrentMonitorStateApproximation();
                // 결과를 Broker로 보고
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, result, resultMessage, monitorStatusAfterCommand);
            }
            else // 이 Agent가 Gateway로서 다른 최종 Agent에게 전달해야 함
            {
                UpdateStatus(AgentOperationalStatus.RelayingCommand, $"Relaying command '{controlPayload.ActionToPerform}' to {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");
                _logger.LogInfo($"Acting as Gateway: Relaying command '{controlPayload.ActionToPerform}' to final target {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}");

                AgentCommandResultPayload finalAgentResult = null;
                using (var downstreamClient = new DownstreamAgentClient(_logger))
                {
                    if (await downstreamClient.ConnectAsync(controlPayload.FinalTargetAgentIp, controlPayload.FinalTargetAgentPort.Value, _mainCts.Token))
                    {
                        // downstreamClient는 BrokerExecuteControlPayload를 받아 최종 Agent에게 전달할 적절한 메시지로 변환해야 함
                        // BrokerExecuteControlPayload 내의 IsGatewayRelay는 이제 false여야 함.
                        var payloadForFinalAgent = new BrokerExecuteControlPayload
                        {
                            ActionToPerform = controlPayload.ActionToPerform,
                            Parameters = controlPayload.Parameters, // 원본 파라미터 그대로 전달
                            IsGatewayRelay = false // 최종 대상에게는 이것이 직접 명령임
                        };
                        finalAgentResult = await downstreamClient.SendCommandAndGetResponseAsync(payloadForFinalAgent, commandMessage.CorrelationId, _mainCts.Token);
                    }
                    else
                    {
                        finalAgentResult = new AgentCommandResultPayload { Success = false, Message = $"Gateway failed to connect to final agent {controlPayload.FinalTargetAgentIp}:{controlPayload.FinalTargetAgentPort}." };
                    }
                } // using 블록 종료 시 downstreamClient.Dispose() 자동 호출

                result = finalAgentResult.Success;
                resultMessage = $"Gateway: {finalAgentResult.Message}"; // 게이트웨이를 통해 전달되었음을 명시
                monitorStatusAfterCommand = finalAgentResult.CurrentMonitorStatus; // 최종 에이전트의 상태

                // 최종 결과를 Broker로 보고 (원본 CorrelationId 사용)
                await _brokerClient.ReportCommandResultAsync(commandMessage.CorrelationId, result, resultMessage, monitorStatusAfterCommand);
                UpdateStatus(AgentOperationalStatus.Running, "Command relay finished."); // 중계 후 원래 상태로
            }
        }
        
        private void HandlePingFromBroker(BrokerMessage pingMessage)
        {
            _logger.LogDebug("Ping received from Broker. Sending Pong.");
            var pongMessage = new BrokerMessage { Type = MessageType.Pong, SourceId = _agentIdentifier.Id, CorrelationId = pingMessage.CorrelationId };
            _brokerClient.SendMessageAsync(pongMessage).ConfigureAwait(false); // 응답은 기다리지 않음
        }


        private void HandleBrokerDisconnection()
        {
            UpdateStatus(AgentOperationalStatus.Disconnected, "Disconnected from Broker. Will attempt to reconnect.");
            // BrokerTcpClient 내부에서 재연결 로직이 이미 동작 중임
        }

        private void UpdateStatus(AgentOperationalStatus newStatus, string message)
        {
            if (_currentStatus == newStatus && newStatus != AgentOperationalStatus.RelayingCommand) return; // 중복 상태 변경 방지 (릴레이는 예외)

            _currentStatus = newStatus;
            string logMessage = $"Agent Status: {_currentStatus} - {message}";
             if (newStatus == AgentOperationalStatus.Error) _logger.LogError(logMessage);
             else _logger.LogInfo(logMessage);
            OnStatusChanged?.Invoke(_currentStatus, message);
        }

        public void Stop()
        {
            UpdateStatus(AgentOperationalStatus.Stopping, "Agent core stopping...");
            _mainCts?.Cancel(); // 모든 내부 작업 취소 요청
            
            _brokerClient?.Dispose(); // BrokerTcpClient 정리
            _brokerClient = null;
            
            _mainCts?.Dispose();
            _mainCts = null;
            _logger.LogInfo("Agent core stopped.");
        }

        public void Dispose()
        {
            Stop();
        }
    }
}
10. UI/TrayIconManager.cs

C#

// MonitorAgent/UI/TrayIconManager.cs
using System;
using System.Windows.Forms; // System.Windows.Forms.dll 참조
using System.Drawing;       // System.Drawing.dll 참조
using MonitorAgent.Core;    // AgentOperationalStatus

namespace MonitorAgent.UI
{
    public class TrayIconManager : IDisposable
    {
        private NotifyIcon _notifyIcon;
        private readonly string _agentId;
        private readonly Action _onExitRequested; // 종료 요청 시 호출될 콜백
        // private readonly Action _onShowStatusClicked; // 상태창 표시 요청 시 호출될 콜백 (필요시)

        public TrayIconManager(string agentId, Action onExitRequested)
        {
            _agentId = agentId;
            _onExitRequested = onExitRequested;
            // _onShowStatusClicked = onShowStatusClicked;

            SetupTrayIcon();
        }

        private void SetupTrayIcon()
        {
            _notifyIcon = new NotifyIcon
            {
                Icon = SystemIcons.Application, // 적절한 아이콘으로 변경 필요
                Visible = true,
                Text = $"MonitorAgent ({_agentId}) - Initializing..."
            };

            var contextMenu = new ContextMenuStrip();
            // contextMenu.Items.Add("Show Status", null, (s, e) => _onShowStatusClicked?.Invoke());
            contextMenu.Items.Add("Exit Agent", null, (s, e) => _onExitRequested?.Invoke());
            
            _notifyIcon.ContextMenuStrip = contextMenu;
            // _notifyIcon.DoubleClick += (s, e) => _onShowStatusClicked?.Invoke();
        }

        public void UpdateStatus(AgentOperationalStatus status, string message)
        {
            if (_notifyIcon != null)
            {
                string trayText = $"Agent ({_agentId.Substring(0, Math.Min(_agentId.Length,10))}...) - {status}";
                if (!string.IsNullOrWhiteSpace(message))
                {
                    trayText += $": {message.Substring(0, Math.Min(message.Length, 20))}{(message.Length > 20 ? "..." : "")}";
                }
                _notifyIcon.Text = trayText.Length > 63 ? trayText.Substring(0, 60) + "..." : trayText;
            }
        }

        public void Dispose()
        {
            _notifyIcon?.Dispose();
            _notifyIcon = null;
        }
    }
}
11. App.xaml.cs (WPF 애플리케이션 진입점)

C#

// MonitorAgent/App.xaml.cs
using System;
using System.Windows;
using MonitorAgent.Config;
using MonitorAgent.Core;
using MonitorAgent.Services;
using MonitorAgent.UI; // TrayIconManager
using Microsoft.Win32; // StartupRegistryService에서 사용 (여기서는 직접 사용 안함)
using System.Diagnostics; // Process

namespace MonitorAgent
{
    public partial class App : Application
    {
        private AgentCore _agentCore;
        private AgentLoggingService _loggingService;
        private TrayIconManager _trayIconManager;
        private AgentIdentifier _agentIdentifier;
        private BrokerAddressProvider _brokerAddressProvider;
        private MonitorControlService _monitorControlService;
        private StartupRegistryService _startupRegistryService;


        protected override async void OnStartup(StartupEventArgs e)
        {
            base.OnStartup(e);
            // MainWindow 자동 생성 방지 (App.xaml에서 StartupUri 제거)

            _loggingService = new AgentLoggingService(); // 로그 레벨은 나중에 설정 파일에서 읽어와서 세팅 가능

            // 중복 실행 방지 (선택적)
            // Mutex mutex = new Mutex(true, "Global\\MonitorAgentInstance", out bool createdNew);
            // if (!createdNew)
            // {
            //    _loggingService.LogWarning("MonitorAgent is already running. Shutting down new instance.");
            //    Shutdown();
            //    return;
            // }

            _agentIdentifier = new AgentIdentifier(_loggingService);
            _brokerAddressProvider = new BrokerAddressProvider(_loggingService);
            _monitorControlService = new MonitorControlService(_loggingService);
            _startupRegistryService = new StartupRegistryService(Config.AppConstants.AppName, _loggingService);


            _agentCore = new AgentCore(_loggingService, _agentIdentifier, _brokerAddressProvider, _monitorControlService);
            _agentCore.OnStatusChanged += AgentCore_OnStatusChanged;

            _trayIconManager = new TrayIconManager(_agentIdentifier.Id, HandleExitRequest);
            _trayIconManager.UpdateStatus(AgentOperationalStatus.Initializing, "Starting up..."); // 초기 상태

            // 시작 프로그램 등록 시도 (설정에 따라)
            // 간단하게, 항상 등록 시도. 설정 파일에서 읽어오는 로직은 AgentConfig에 추가 필요.
            // bool autoStartEnabled = true; // 예시, 실제로는 설정에서 읽어옴
            // if (autoStartEnabled) _startupRegistryService.RegisterInStartup(true);
             _startupRegistryService.EnsureRegistered(); // 현재 실행 파일 경로로 시작 프로그램 등록/업데이트


            await _agentCore.StartAsync();
        }

        private void AgentCore_OnStatusChanged(AgentOperationalStatus status, string message)
        {
            // UI 스레드에서 트레이 아이콘 업데이트
            Dispatcher.Invoke(() =>
            {
                _trayIconManager?.UpdateStatus(status, message);
            });
        }

        private void HandleExitRequest()
        {
            _loggingService.LogInfo("Exit requested from tray icon.");
            ShutdownAgentCoreAndExit();
        }

        private async void ShutdownAgentCoreAndExit()
        {
            if (_agentCore != null)
            {
                _agentCore.Stop(); // 비동기 Stop이 아니므로, 여기서 await 할 필요 없음. Stop 내부에서 정리.
                _agentCore.Dispose(); // 명시적 Dispose
                _agentCore = null;
            }
            _trayIconManager?.Dispose(); // 트레이 아이콘 정리
            _loggingService.LogInfo("Agent shutdown complete. Exiting application.");
            Shutdown(); // WPF 애플리케이션 종료
        }

        protected override void OnExit(ExitEventArgs e)
        {
            // 애플리케이션 종료 시 최종 정리 (이미 HandleExitRequest에서 처리되었을 수 있음)
            ShutdownAgentCoreAndExit(); // 중복 호출되어도 내부에서 처리되도록 AgentCore.Stop/Dispose 설계
            base.OnExit(e);
        }
    }
    
    // 시작 프로그램 등록 유틸리티 (간단 버전)
    public class StartupRegistryService
    {
        private readonly string _appName;
        private readonly ILoggingService _logger;
        private readonly string _appPath;

        public StartupRegistryService(string appName, ILoggingService logger)
        {
            _appName = appName;
            _logger = logger;
            _appPath = Process.GetCurrentProcess().MainModule.FileName;
        }

        public void EnsureRegistered()
        {
            try
            {
                RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
                if (rkApp.GetValue(_appName) == null || rkApp.GetValue(_appName).ToString() != _appPath)
                {
                    rkApp.SetValue(_appName, _appPath);
                    _logger.LogInfo($"Application registered to run at startup: {_appPath}");
                }
                // else { _logger.LogDebug("Application already registered for startup."); }
                rkApp.Close();
            }
            catch (Exception ex)
            {
                _logger.LogError("Error accessing registry for startup registration.", ex);
            }
        }
        public void Unregister()
        {
             try
            {
                RegistryKey rkApp = Registry.CurrentUser.OpenSubKey("SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run", true);
                if (rkApp.GetValue(_appName) != null)
                {
                    rkApp.DeleteValue(_appName, false);
                     _logger.LogInfo("Application unregistered from startup.");
                }
                rkApp.Close();
            }
            catch (Exception ex)
            {
                _logger.LogError("Error unregistering application from startup.", ex);
            }
        }
    }
}
12. App.xaml (수정 - StartupUri 제거)

XML

<Application x:Class="MonitorAgent.App"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
             xmlns:local="clr-namespace:MonitorAgent">
    <Application.Resources>
         
    </Application.Resources>
</Application>
참고: 만약 MainWindow.xaml 과 MainWindow.xaml.cs 파일이 프로젝트에 남아있다면, 이 Agent 프로그램에서는 사용하지 않으므로 삭제해도 됩니다.

Agent 프로그램 실행 방법:

위 코드들을 사용하여 MonitorAgent 프로젝트를 빌드합니다.
Newtonsoft.Json NuGet 패키지가 설치되었는지 확인합니다.
빌드된 MonitorAgent.exe 파일과 함께, 실행 파일과 같은 폴더에 broker_address.txt 파일을 생성하고 중계 프로그램의 IP 주소와 Agent 연결용 포트를 적어줍니다 (예: 127.0.0.1:9002).
MonitorAgent.exe를 실행합니다.
트레이 아이콘이 나타나고, 중계 프로그램으로 연결을 시도합니다.
로그는 agent_log.txt 파일에 기록됩니다.
agent_id.txt 파일이 자동으로 생성되어 이 Agent의 고유 ID를 저장합니다.
이제 이 Agent 프로그램은 이전에 제공한 중계 프로그램(MGSPBrokerService)과 통신할 준비가 되었습니다.