전 용량 위치 선을 사용자 설정 값으로 설정하려면, 사용자로부터 안전 용량 값을 입력받고 이를 커스텀 프로그래스바에 반영하도록 코드를 수정하겠습니다. 이를 위해 MainWindow에 안전 용량 값을 입력하는 TextBox를 추가하고, 해당 값을 커스텀 프로그래스바로 전달하는 로직을 구현합니다.

1. CustomProgressBar.xaml
xml
코드 복사
<UserControl x:Class="SMDFileCleaner.CustomProgressBar"
             xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
             Height="50" Width="400">
    <Grid>
        <ProgressBar x:Name="ProgressBar" Height="30" VerticalAlignment="Center" HorizontalAlignment="Stretch"/>
        <TextBlock x:Name="TextBlock" VerticalAlignment="Center" HorizontalAlignment="Center" Foreground="White" FontWeight="Bold"/>
        <Rectangle x:Name="SafeLine" Stroke="Red" StrokeThickness="2" VerticalAlignment="Stretch" Width="2"/>
    </Grid>
</UserControl>
2. CustomProgressBar.xaml.cs
csharp
코드 복사
using System.Windows;
using System.Windows.Controls;

namespace SMDFileCleaner
{
    public partial class CustomProgressBar : UserControl
    {
        public CustomProgressBar()
        {
            InitializeComponent();
        }

        public void UpdateProgress(double usedPercentage, double safePercentage)
        {
            Dispatcher.Invoke(() =>
            {
                ProgressBar.Value = usedPercentage;
                TextBlock.Text = $"{usedPercentage:0.##}%";

                double safePosition = safePercentage * ProgressBar.ActualWidth / 100;
                SafeLine.Margin = new Thickness(safePosition, 0, 0, 0);
            });
        }
    }
}
3. MainWindow.xaml
xml
코드 복사
<Window x:Class="SMDFileCleaner.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        xmlns:local="clr-namespace:SMDFileCleaner"
        Title="SMD File Cleaner" Height="550" Width="525">
    <Grid>
        <ComboBox x:Name="cbFolderPaths" HorizontalAlignment="Left" Margin="10,10,0,0" VerticalAlignment="Top" Width="400" Height="100" IsEditable="True" TextWrapping="Wrap" AcceptsReturn="True"/>
        <Button x:Name="btnApplyFolders" Content="Apply Folders" HorizontalAlignment="Left" Margin="420,10,0,0" VerticalAlignment="Top" Width="75" Click="btnApplyFolders_Click"/>
        
        <TextBox x:Name="txtRegexPatterns" HorizontalAlignment="Left" Height="50" Margin="10,120,0,0" VerticalAlignment="Top" Width="400" TextWrapping="Wrap" AcceptsReturn="True"/>
        <Button x:Name="btnApplyRegexPatterns" Content="Apply Regex" HorizontalAlignment="Left" Margin="420,120,0,0" VerticalAlignment="Top" Width="75" Click="btnApplyRegexPatterns_Click"/>

        <TextBox x:Name="txtSafeSpace" HorizontalAlignment="Left" Height="23" Margin="10,180,0,0" VerticalAlignment="Top" Width="400" PlaceholderText="Enter safe space in GB"/>
        <Button x:Name="btnApplySafeSpace" Content="Apply Safe Space" HorizontalAlignment="Left" Margin="420,180,0,0" VerticalAlignment="Top" Width="75" Click="btnApplySafeSpace_Click"/>
        
        <Button x:Name="btnStart" Content="Start" HorizontalAlignment="Left" Margin="10,220,0,0" VerticalAlignment="Top" Width="75" Click="btnStart_Click"/>

        <local:CustomProgressBar x:Name="ProgressBar" HorizontalAlignment="Left" Margin="10,260,0,0" VerticalAlignment="Top"/>
    </Grid>
</Window>
4. MainWindow.xaml.cs
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Windows;

namespace SMDFileCleaner
{
    public partial class MainWindow : Window
    {
        private FileCleaner _fileCleaner;
        private List<string> _folderPaths = new List<string>();
        private List<Regex> _regexPatterns = new List<Regex>();
        private const string ConfigFilePath = "config.txt";
        private long _safeFreeSpace = 25L * 1024 * 1024 * 1024; // 25 GB 기본 값
        private long _totalDiskSpace;
        private long _freeDiskSpace;

        public MainWindow()
        {
            InitializeComponent();
            _fileCleaner = new FileCleaner(UpdateProgressBar);
            LoadConfig();
            CheckFolderPaths();
            InitializeDiskSpace();
        }

        private void InitializeDiskSpace()
        {
            _totalDiskSpace = GetTotalDiskSpace("D:\\"); // 예시로 D 드라이브 사용
            _freeDiskSpace = GetFreeDiskSpace("D:\\");
            UpdateProgressBar();
        }

        private long GetTotalDiskSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.TotalSize;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Failed to get total disk space: " + ex.Message);
                return 0;
            }
        }

        private long GetFreeDiskSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                MessageBox.Show("Failed to get free disk space: " + ex.Message);
                return 0;
            }
        }

        private void btnApplyFolders_Click(object sender, RoutedEventArgs e)
        {
            _folderPaths = cbFolderPaths.Text.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries).Take(5).ToList();
            CheckFolderPaths();
            SaveConfig();
            MessageBox.Show("폴더 경로가 저장되었습니다.", "정보", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void btnApplyRegexPatterns_Click(object sender, RoutedEventArgs e)
        {
            var patterns = txtRegexPatterns.Text.Split(new[] { "\r\n", "\r", "\n" }, StringSplitOptions.RemoveEmptyEntries).Take(2).ToList();
            _regexPatterns = patterns.Select(p => new Regex(p)).ToList();
            SaveConfig();
            MessageBox.Show("정규식 패턴이 저장되었습니다.", "정보", MessageBoxButton.OK, MessageBoxImage.Information);
        }

        private void btnApplySafeSpace_Click(object sender, RoutedEventArgs e)
        {
            if (long.TryParse(txtSafeSpace.Text, out long safeSpaceGB))
            {
                _safeFreeSpace = safeSpaceGB * 1024 * 1024 * 1024; // GB를 바이트로 변환
                UpdateProgressBar();
                MessageBox.Show("안전 용량 값이 저장되었습니다.", "정보", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            else
            {
                MessageBox.Show("유효한 숫자를 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void btnStart_Click(object sender, RoutedEventArgs e)
        {
            if (_folderPaths.Count == 0 || _regexPatterns.Count == 0)
            {
                MessageBox.Show("폴더와 정규식을 입력하세요.", "오류", MessageBoxButton.OK, MessageBoxImage.Error);
                return;
            }

            StartFileDeletion();
        }

        private void StartFileDeletion()
        {
            try
            {
                foreach (var folderPath in _folderPaths)
                {
                    foreach (var regex in _regexPatterns)
                    {
                        var filesToDelete = _fileCleaner.GetFilesToDelete(folderPath, regex);
                        if (filesToDelete.Count >= 10)
                        {
                            _fileCleaner.DeleteFilesAsync(filesToDelete, folderPath).Wait();
                            _freeDiskSpace = GetFreeDiskSpace("D:\\");
                            UpdateProgressBar();
                        }
                    }
                }
                MessageBox.Show("파일 삭제 완료.", "완료", MessageBoxButton.OK, MessageBoxImage.Information);
            }
            catch (Exception ex)
            {
                MessageBox.Show("파일 삭제 중 오류 발생: " + ex.Message, "오류", MessageBoxButton.OK, MessageBoxImage.Error);
            }
        }

        private void CheckFolderPaths()
        {
            var validPaths = _folderPaths.Where(Directory.Exists).ToList();
            _folderPaths = validPaths;
            cbFolderPaths.ItemsSource = validPaths;
        }

        private void SaveConfig()
        {
            var lines = _folderPaths.Concat(_regexPatterns.Select(r => r.ToString())).ToList();
            lines.Add((_safeFreeSpace / (1024 * 1024 * 1024)).ToString()); // GB 단위로 저장
            File.WriteAllLines(ConfigFilePath, lines);
        }

        private void LoadConfig()
        {
            if (File.Exists(ConfigFilePath))
            {
                var lines = File.ReadAllLines(ConfigFilePath).ToList();
                if (lines.Count > 0)
                {
                    _folderPaths = lines.Take(5).ToList();
                    _regexPatterns = lines.Skip(5).Take(2).Select(p => new Regex(p)).ToList();
                    if (long.TryParse(lines.Last(), out long safeSpaceGB))
                    {
                        _safeFreeSpace = safeSpaceGB * 1024 * 1024 * 1024;
                    }

                    cbFolderPaths.ItemsSource = _folderPaths;
                    txtRegexPatterns.Text = string.Join(Environment.NewLine, _regexPatterns.Select(r => r.ToString()));
                    txtSafeSpace.Text = safeSpaceGB.ToString();
                }
            }
        }

        private void UpdateProgressBar()
        {
            double usedPercentage = (double)(_totalDiskSpace - _freeDiskSpace) / _totalDiskSpace * 100;
            double safePercentage = (double)(_totalDiskSpace - _safeFreeSpace) / _totalDiskSpace * 100;
            ProgressBar.UpdateProgress(usedPercentage, safePercentage);
        }
    }
}
5. FileCleaner.cs
파일 삭제 시 프로그래스바 갱신 로직 추가
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using System.Windows.Threading;

namespace SMDFileCleaner
{
    public class FileCleaner
    {
        private const long MaxFolderSize = 8L * 1024 * 1024 * 1024; // 8 GB
        private readonly string logDirectory;
        private readonly MLModelBuilder mlModelBuilder;
        private readonly Dispatcher dispatcher;
        private readonly Logger logger;
        private readonly Action<long, string> updateFolderStatistics;
        private readonly Action updateProgressBar;

        public FileCleaner(Action updateProgressBar)
        {
            this.updateProgressBar = updateProgressBar;
        }

        public long GetDriveFreeSpace(string driveName)
        {
            try
            {
                DriveInfo drive = new DriveInfo(driveName);
                return drive.AvailableFreeSpace;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get drive free space: " + ex.Message);
                return 0;
            }
        }

        public List<FileInfo> GetFilesToDelete(string folderPath, Regex regex, bool forceDelete = false)
        {
            try
            {
                var files = GetFiles(folderPath, regex);
                var filesToDelete = files.Where(file => forceDelete || file.CreationTime < DateTime.Now.AddDays(-35)).OrderBy(file => file.CreationTime).ToList();

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(files.Sum(f => f.Length), folderPath);
                });

                return filesToDelete;
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to get files to delete: " + ex.Message);
                return new List<FileInfo>();
            }
        }

        private IEnumerable<FileInfo> GetFiles(string folderPath, Regex regex)
        {
            var files = new List<FileInfo>();
            try
            {
                var directory = new DirectoryInfo(folderPath);
                files.AddRange(directory.GetFiles("*", SearchOption.AllDirectories)
                    .Where(f => f.Length > 500 * 1024 && regex.IsMatch(f.FullName))); // 500KB 이상의 파일 중 정규식과 일치하는 파일

            }
            catch (UnauthorizedAccessException ex)
            {
                logger.LogError("Access denied to folder: " + folderPath + " - " + ex.Message);
            }
            return files;
        }

        public async Task DeleteFilesAsync(List<FileInfo> files, string folderPath, bool forceDelete = false)
        {
            long currentFolderSize = files.Sum(f => f.Length);
            long freeSpace = GetDriveFreeSpace(folderPath.Split('\\')[0] + "\\");

            foreach (var file in files)
            {
                if (currentFolderSize <= MaxFolderSize && !forceDelete)
                {
                    logger.LogRecentActivity("현재 폴더 크기가 8GB 이하입니다.");
                    break;
                }

                if (freeSpace > MainWindow.SafeFreeSpace && !forceDelete)
                {
                    logger.LogRecentActivity($"용량이 {freeSpace / (1024 * 1024 * 1024)} GB 남아서 삭제를 하지 않습니다.");
                    break;
                }

                try
                {
                    file.Delete();
                    currentFolderSize -= file.Length;
                    logger.LogDeletionActivity($"파일 삭제됨: {file.FullName}");
                    await Task.Delay(100); // 파일 삭제 시 딜레이 추가
                    dispatcher.Invoke(() => updateProgressBar());
                }
                catch (Exception ex)
                {
                    logger.LogError("Failed to delete file: " + ex.Message);
                }
            }

            updateFolderStatistics(currentFolderSize, folderPath);
        }

        public void UpdateFolderStatistics(string folderPath, string fileExtension)
        {
            try
            {
                var files = GetFiles(folderPath, new Regex($".*\\.{fileExtension}$"));
                long totalSize = files.Sum(f => f.Length);

                dispatcher.Invoke(() =>
                {
                    updateFolderStatistics(totalSize, folderPath);
                });
            }
            catch (Exception ex)
            {
                logger.LogError("Failed to update folder statistics: " + ex.Message);
            }
        }
    }
}
설명
CustomProgressBar.xaml: 커스텀 프로그래스바를 정의합니다. 프로그래스바와 텍스트블록, 그리고 안전 용량 선을 포함합니다.
CustomProgressBar.xaml.cs: 프로그래스바를 갱신하는 메서드를 정의합니다. Dispatcher.Invoke를 사용하여 UI 쓰레드에서 프로그래스바와 선을 업데이트합니다.
MainWindow.xaml: MainWindow에 커스텀 프로그래스바와 사용자로부터 안전 용량 값을 입력받는 TextBox를 추가합니다.
MainWindow.xaml.cs: MainWindow에 프로그래스바 갱신 로직과 사용자로부터 입력받은 안전 용량 값을 처리하는 로직을 추가합니다. 파일 삭제 시 프로그래스바를 갱신합니다.
FileCleaner.cs: 파일 삭제 시 프로그래스바를 갱신하는 로직을 추가합니다. Dispatcher.Invoke를 사용하여 UI 업데이트를 보장합니다.
이제 프로그램은 사용자가 입력한 안전 용량 값을 기준으로 프로그래스바를 업데이트하며, 파일 삭제 시 프로그래스바가 갱신됩니다