네, 알겠습니다! SControlM 프로젝트의 Services 폴더에 들어갈 CommandSendService.cs 코드를 드리겠습니다. 이 서비스는 SAgentM.App으로 TCP/IP를 통해 명령을 전송하고 응답을 수신하는 역할을 담당합니다.

그 전에, SControlM의 UI에도 로그를 표시하기 위해 SAgentM.App에서 사용했던 것과 유사한 LoggingService.cs를 SControlM/Services/ 폴더에 먼저 만들겠습니다. 이는 CommandSendService나 MainControlViewModel에서 로그를 기록하는 데 사용됩니다.

Services/LoggingService.cs (SControlM 용)

이전에 SControlM/Models/LogEntry.cs (및 LogLevel)를 수정했으므로, 해당 모델을 사용합니다.
<!-- end list -->

C#

// SControlM/Services/LoggingService.cs
using SControlM.Models; // SControlM의 LogEntry, LogLevel 사용
using System;
using System.Collections.ObjectModel;
using System.Configuration;
using System.Windows.Data; // BindingOperations 사용
using System.Windows;     // Application.Current.Dispatcher (필요시)

namespace SControlM.Services
{
    public interface ILoggingService
    {
        ObservableCollection<LogEntry> LogEntries { get; }
        void Log(LogLevel level, string message);
        void Info(string message);
        void Warn(string message);
        void Error(string message, Exception ex = null);
        void Debug(string message);
        void Sent(string message);    // 명령 전송 로그
        void Received(string message); // 응답 수신 로그
    }

    public class LoggingService : ILoggingService
    {
        public ObservableCollection<LogEntry> LogEntries { get; }
        private readonly int _maxEntries;
        private readonly object _logLock = new object();

        public LoggingService()
        {
            LogEntries = new ObservableCollection<LogEntry>();
            BindingOperations.EnableCollectionSynchronization(LogEntries, _logLock);

            // SControlM의 App.config에 MaxUiLogEntries 설정이 있다면 사용
            if (!int.TryParse(ConfigurationManager.AppSettings["MaxUiLogEntriesSControlM"], out _maxEntries))
            {
                _maxEntries = 100; // 기본값
            }
        }

        public void Log(LogLevel level, string message)
        {
            lock (_logLock)
            {
                if (LogEntries.Count >= _maxEntries && _maxEntries > 0)
                {
                    LogEntries.RemoveAt(0);
                }
                LogEntries.Add(new LogEntry(level, message));
            }
        }

        public void Info(string message) => Log(LogLevel.Info, message);
        public void Warn(string message) => Log(LogLevel.Warning, message);
        public void Error(string message, Exception ex = null)
        {
            string fullMessage = message;
            if (ex != null)
            {
                fullMessage += Environment.NewLine + "Exception: " + ex.ToString(); // 더 자세한 예외 정보
            }
            Log(LogLevel.Error, fullMessage);
        }
        public void Debug(string message) => Log(LogLevel.Debug, message);
        public void Sent(string message) => Log(LogLevel.Sent, message);
        public void Received(string message) => Log(LogLevel.Received, message);
    }
}
LoggingService.cs (SControlM용) 주요 변경점:

SControlM.Models.LogEntry 및 SControlM.Models.LogLevel을 사용하도록 네임스페이스와 타입을 맞췄습니다.
Sent와 Received 로그 레벨을 위한 편의 메서드를 추가했습니다.
App.config에서 로그 최대 개수를 읽는 키 이름을 MaxUiLogEntriesSControlM (예시)로 변경하여 SAgentM.App의 설정과 구분할 수 있게 했습니다.
이제 CommandSendService.cs 코드를 제공합니다.

Services/CommandSendService.cs

C#

// SControlM/Services/CommandSendService.cs
using Newtonsoft.Json;
using SControl.Common; // CommandPacket
using SControlM.Models; // AgentTarget
using System;
using System.IO;
using System.Net.Sockets;
using System.Text;
using System.Threading.Tasks;
using System.Threading; // CancellationToken

namespace SControlM.Services
{
    public interface ICommandSendService
    {
        /// <summary>
        /// 지정된 SAgentM 대상으로 명령 패킷을 비동기적으로 전송하고 응답을 받습니다.
        /// </summary>
        /// <param name="target">명령을 전송할 대상 SAgentM 정보입니다.</param>
        /// <param name="commandPacket">전송할 명령 패킷입니다.</param>
        /// <param name="timeout">연결, 전송, 수신 각 단계에 대한 타임아웃입니다.</param>
        /// <param name="cancellationToken">작업 취소 토큰입니다.</param>
        /// <returns>SAgentM으로부터 받은 응답 패킷 또는 오류 발생 시 null.</returns>
        Task<CommandPacket> SendCommandAsync(AgentTarget target, CommandPacket commandPacket, TimeSpan timeout, CancellationToken cancellationToken = default);
    }

    public class CommandSendService : ICommandSendService
    {
        // 이 서비스 자체의 로그를 위해 ILoggingService를 주입받을 수도 있으나,
        // 여기서는 호출하는 ViewModel에서 로그를 처리한다고 가정하고,
        // 서비스는 주로 예외를 통해 상태를 알립니다.
        // private readonly ILoggingService _loggingService;
        // public CommandSendService(ILoggingService loggingService)
        // {
        //    _loggingService = loggingService;
        // }


        public async Task<CommandPacket> SendCommandAsync(AgentTarget target, CommandPacket commandPacket, TimeSpan timeout, CancellationToken cancellationToken = default)
        {
            if (target == null) throw new ArgumentNullException(nameof(target));
            if (commandPacket == null) throw new ArgumentNullException(nameof(commandPacket));

            TcpClient client = null;
            try
            {
                client = new TcpClient();

                // 연결 타임아웃 적용
                var connectTask = client.ConnectAsync(target.IpAddress, target.Port);
                if (await Task.WhenAny(connectTask, Task.Delay(timeout, cancellationToken)) != connectTask || cancellationToken.IsCancellationRequested)
                {
                    cancellationToken.ThrowIfCancellationRequested(); // 취소 요청 시 예외 발생
                    client.Close(); // 연결 시도 중단
                    throw new TimeoutException($"SAgentM ({target.IpAddress}:{target.Port}) 연결 시간 초과 ({timeout.TotalSeconds}초).");
                }
                await connectTask; // 발생 가능한 예외 전파 (예: 호스트 찾을 수 없음)

                if (!client.Connected)
                {
                     throw new SocketException((int)SocketError.NotConnected); // 명시적 예외
                }

                using (NetworkStream stream = client.GetStream())
                // 스트림 읽기/쓰기 타임아웃 설정 (필수)
                {
                    stream.ReadTimeout = (int)timeout.TotalMilliseconds;
                    stream.WriteTimeout = (int)timeout.TotalMilliseconds;
                    
                    using (StreamWriter writer = new StreamWriter(stream, Encoding.UTF8, 1024, true) { AutoFlush = true })
                    using (StreamReader reader = new StreamReader(stream, Encoding.UTF8, true, 1024, true))
                    {
                        string jsonRequest = JsonConvert.SerializeObject(commandPacket);
                        
                        // 전송 (WriteAsync는 CancellationToken을 직접 받지 않음, WriteTimeout에 의존)
                        await writer.WriteLineAsync(jsonRequest).ConfigureAwait(false);
                        // _loggingService?.Sent($"To {target.IpAddress}:{target.Port} - {jsonRequest}"); // 필요시 ViewModel에서 로깅

                        // 수신 (ReadLineAsync도 CancellationToken을 직접 받지 않음, ReadTimeout에 의존)
                        // CancellationToken을 사용하려면 Task.Run으로 감싸거나, 주기적으로 token.IsCancellationRequested 확인 필요
                        string jsonResponse = null;
                        var readTask = reader.ReadLineAsync();
                        if (await Task.WhenAny(readTask, Task.Delay(Timeout.Infinite, cancellationToken)) == readTask) // token으로 취소 가능
                        {
                            jsonResponse = await readTask.ConfigureAwait(false);
                        }
                        else // Task.Delay가 먼저 완료 (취소됨)
                        {
                            cancellationToken.ThrowIfCancellationRequested();
                        }

                        if (string.IsNullOrEmpty(jsonResponse))
                        {
                            throw new IOException("SAgentM으로부터 응답을 받지 못했습니다 (빈 응답).");
                        }
                        // _loggingService?.Received($"From {target.IpAddress}:{target.Port} - {jsonResponse}"); // 필요시 ViewModel에서 로깅

                        return JsonConvert.DeserializeObject<CommandPacket>(jsonResponse);
                    }
                }
            }
            catch (OperationCanceledException) // Task.Delay(timeout, cancellationToken) 또는 명시적 ThrowIfCancellationRequested
            {
                // _loggingService?.Warn($"명령 전송 취소됨: {target.IpAddress}:{target.Port}");
                throw; // ViewModel에서 처리하도록 다시 던짐
            }
            catch (JsonException jsonEx)
            {
                // _loggingService?.Error($"JSON 처리 오류: {jsonEx.Message}", jsonEx);
                throw new ApplicationException($"JSON 처리 오류: {jsonEx.Message}", jsonEx);
            }
            catch (SocketException sockEx)
            {
                // _loggingService?.Error($"소켓 오류: {sockEx.Message} (Code: {sockEx.SocketErrorCode})", sockEx);
                throw new ApplicationException($"SAgentM 통신 소켓 오류: {sockEx.Message} (Code: {sockEx.SocketErrorCode})", sockEx);
            }
            catch (IOException ioEx)
            {
                // _loggingService?.Error($"네트워크 IO 오류: {ioEx.Message}", ioEx);
                throw new ApplicationException($"SAgentM 통신 네트워크 IO 오류: {ioEx.Message}", ioEx);
            }
            catch (TimeoutException) // 연결 또는 읽기/쓰기 타임아웃 명시적 throw
            {
                 // _loggingService?.Error($"타임아웃 오류: {tex.Message}", tex);
                throw; // 이미 TimeoutException이므로 그대로 던짐
            }
            catch (Exception ex)
            {
                // _loggingService?.Error($"명령 전송 중 예기치 않은 오류: {ex.Message}", ex);
                throw new ApplicationException($"명령 전송 중 예기치 않은 오류: {ex.Message}", ex);
            }
            finally
            {
                client?.Close(); // 모든 경우에 클라이언트 연결 확실히 닫기
            }
        }
    }
}
CommandSendService.cs 주요 특징:

비동기 처리: async 및 await를 사용하여 네트워크 작업을 비동기적으로 수행합니다. UI 스레드를 차단하지 않습니다.
타임아웃 처리:
client.ConnectAsync에 대해 Task.WhenAny와 Task.Delay를 사용하여 연결 타임아웃을 구현합니다.
NetworkStream의 ReadTimeout 및 WriteTimeout 속성을 설정하여 읽기/쓰기 작업에 대한 타임아웃을 적용합니다.
ReadLineAsync에 대해서도 Task.WhenAny와 Task.Delay(Timeout.Infinite, cancellationToken)를 사용하여 CancellationToken에 의한 취소를 지원하도록 했습니다.
취소 지원 (CancellationToken): 메서드 인자로 CancellationToken을 받아 작업 중간에 취소 요청이 오면 OperationCanceledException을 발생시켜 작업을 중단할 수 있습니다.
오류 처리: SocketException, IOException, JsonException, TimeoutException 등 다양한 예외를 catch하여 적절한 ApplicationException으로 래핑하거나 그대로 다시 throw하여 호출자(ViewModel)가 처리할 수 있도록 합니다.
리소스 정리: try-finally 블록과 using 문을 사용하여 TcpClient 및 NetworkStream 등의 리소스를 안정적으로 해제합니다.
로깅: 이 서비스 자체에서는 직접적인 UI 로깅을 최소화하고, 주로 예외를 통해 상태를 전달합니다. 로깅은 이 서비스를 사용하는 MainControlViewModel에서 수행하는 것이 더 적절할 수 있습니다 (명령 전송 시도, 성공, 실패, 응답 내용 등). 필요하다면 ILoggingService를 주입받아 내부 오류 로깅을 추가할 수 있습니다.
이제 SControlM에서 SAgentM.App으로 명령을 보내고 응답을 받을 수 있는 핵심 서비스가 준비되었습니다.
다음으로는 이 CommandSendService와 LoggingService를 사용하는 MainControlViewModel.cs를 구현하여 실제 UI와 연결하는 작업을 진행하겠습니다.

계속해서 MainControlViewModel.cs 코드를 드릴까요?

