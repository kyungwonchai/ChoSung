폼(Form) 포함
프로그램 실행 시 폼이 존재하지만, 기본적으로 트레이로 최소화됨.
폼에는 단순히 "모니터 자동 OFF 프로그램입니다" 라는 텍스트가 표시됨.
트레이 아이콘 기능
우클릭 → "종료" 선택 시 프로그램 종료
더블클릭 → 폼 다시 표시
모니터 자동 OFF/ON 기능
GetLastInputInfo()를 사용하여 마우스/키보드 입력 감지
1분(60초) 동안 입력이 없으면 모니터 OFF
입력이 감지되면 모니터 ON
SendMessage로 WM_SYSCOMMAND 메시지를 보내서 제어
🚀 완전한 소스 코드
csharp
코드 복사
using System;
using System.Diagnostics;
using System.Runtime.InteropServices;
using System.Threading;
using System.Windows.Forms;

namespace MonitorAutoControl
{
    public partial class MainForm : Form
    {
        private static readonly int WM_SYSCOMMAND = 0x0112;
        private static readonly int SC_MONITORPOWER = 0xF170;
        private static readonly int MONITOR_ON = -1;
        private static readonly int MONITOR_OFF = 2;
        private static readonly int IDLE_TIME_LIMIT = 60 * 1000; // 1분

        private System.Threading.Timer _idleTimer;
        private NotifyIcon _trayIcon;

        public MainForm()
        {
            InitializeComponent();
            InitializeTrayIcon();
            InitializeTimer();
        }

        private void InitializeComponent()
        {
            this.Text = "모니터 자동 OFF 프로그램";
            this.Size = new System.Drawing.Size(400, 200);
            this.FormClosing += MainForm_FormClosing;

            Label label = new Label()
            {
                Text = "모니터 자동 OFF 프로그램입니다",
                Dock = DockStyle.Fill,
                TextAlign = System.Drawing.ContentAlignment.MiddleCenter
            };
            this.Controls.Add(label);
        }

        private void InitializeTrayIcon()
        {
            _trayIcon = new NotifyIcon()
            {
                Icon = SystemIcons.Application,
                Visible = true,
                ContextMenuStrip = new ContextMenuStrip()
                {
                    Items = { new ToolStripMenuItem("종료", null, (s, e) => ExitApplication()) }
                }
            };
            _trayIcon.DoubleClick += (s, e) => ShowMainForm();
        }

        private void InitializeTimer()
        {
            _idleTimer = new System.Threading.Timer(CheckIdleState, null, 1000, 1000);
        }

        private void ShowMainForm()
        {
            this.Invoke(new Action(() =>
            {
                this.Show();
                this.WindowState = FormWindowState.Normal;
                this.Activate();
            }));
        }

        private void CheckIdleState(object state)
        {
            int idleTime = GetIdleTime();
            if (idleTime > IDLE_TIME_LIMIT)
            {
                TurnMonitorOff();
            }
            else
            {
                TurnMonitorOn();
            }
        }

        private int GetIdleTime()
        {
            LASTINPUTINFO lastInputInfo = new LASTINPUTINFO();
            lastInputInfo.cbSize = Marshal.SizeOf(typeof(LASTINPUTINFO));

            if (GetLastInputInfo(ref lastInputInfo))
            {
                return Environment.TickCount - lastInputInfo.dwTime;
            }
            return 0; // 오류 발생 시 기본값 반환
        }

        private void TurnMonitorOn()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_ON);
        }

        private void TurnMonitorOff()
        {
            SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, (IntPtr)SC_MONITORPOWER, (IntPtr)MONITOR_OFF);
        }

        private void MainForm_FormClosing(object sender, FormClosingEventArgs e)
        {
            e.Cancel = true;
            this.Hide(); // 창을 닫지 않고 숨김
        }

        private void ExitApplication()
        {
            _idleTimer.Dispose();
            _trayIcon.Dispose();
            Application.Exit();
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct LASTINPUTINFO
        {
            public int cbSize;
            public int dwTime;
        }

        [DllImport("user32.dll")]
        private static extern bool GetLastInputInfo(ref LASTINPUTINFO plii);

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr GetDesktopWindow();

        [DllImport("user32.dll", SetLastError = true)]
        private static extern IntPtr SendMessage(IntPtr hWnd, int Msg, IntPtr wParam, IntPtr lParam);

        [STAThread]
        static void Main()
        {
            Application.EnableVisualStyles();
            Application.SetCompatibleTextRenderingDefault(false);
            Application.Run(new MainForm());
        }
    }
}
🔍 주요 기능
✅ 1. 폼 (MainForm) 기본 UI
프로그램 실행 시 폼이 나타남 (모니터 자동 OFF 프로그램입니다 문구 표시)
X 버튼 클릭 시 창을 닫지 않고 숨김 (트레이로 최소화)
✅ 2. 트레이 아이콘 기능
더블클릭 시 폼 다시 표시
우클릭 메뉴에서 "종료" 클릭 시 프로그램 종료
✅ 3. 입력 감지 및 모니터 제어
GetLastInputInfo() 를 사용하여 최신 사용자 입력 감지
1분 동안 입력이 없으면 모니터 OFF, 입력이 감지되면 모니터 ON
SendMessage(GetDesktopWindow(), WM_SYSCOMMAND, SC_MONITORPOWER, MONITOR_OFF) 방식으로 빠르게 모니터 제어
✅ 4. 백그라운드 실행
UI가 최소화되면 트레이에서 계속 실행됨
폼이 닫히지 않고 숨겨짐 (X 버튼을 눌러도 프로세스 종료되지 않음)
✅ 최종 테스트 체크리스트
 폼 실행 시 "모니터 자동 OFF 프로그램입니다" 텍스트 정상 표시
 폼 X 버튼 클릭 시 창이 트레이로 최소화
 트레이 아이콘 정상 표시됨
 트레이에서 더블클릭하면 폼 다시 표시
 트레이에서 "종료" 클릭하면 정상 종료됨
 1분 동안 입력이 없으면 모니터 자동 OFF
 입력 감지 시 모니터 자동 ON
 UI가 없을 때도 정상 작동
🎯 장점
✔ 후킹 사용 없이 입력 감지 가능 → 기업 환경에서도 문제 없음
✔ 트레이에서 깔끔하게 동작 → 백그라운드에서 실행 가능
✔ UI 최소화 및 종료 기능 포함 → 사용자 편의성 강화
✔ 빠르고 안정적인 모니터 ON/OFF 제어 → SendMessage(GetDesktopWindow()) 방식 사용
✔ 최소한의 리소스 사용 → 가벼운 타이머 사용