오는 방식으로 변경하겠습니다. 이를 위해, System.IO 네임스페이스를 사용하여 .ini 파일을 읽고 쓰는 기능을 구현할 것입니다.

아래는 .ini 파일을 사용하여 설정을 저장하고 불러오는 WPF 애플리케이션의 전체 코드입니다.

XAML 파일 (MainWindow.xaml)
xml
코드 복사
<Window x:Class="LogMonitor.MainWindow"
        xmlns="http://schemas.microsoft.com/winfx/2006/xaml/presentation"
        xmlns:x="http://schemas.microsoft.com/winfx/2006/xaml"
        Title="Log Monitor" Height="450" Width="800" Background="Purple">
    <Grid>
        <Grid.RowDefinitions>
            <RowDefinition Height="Auto"/>
            <RowDefinition Height="*"/>
        </Grid.RowDefinitions>
        <StackPanel Orientation="Horizontal" Margin="10">
            <Button Content="Select Log File" Click="SelectLogFile_Click" Margin="5"/>
            <Button Content="Select Backup Folder" Click="SelectBackupFolder_Click" Margin="5"/>
            <TextBlock Text="Max Log Lines:" VerticalAlignment="Center" Margin="5"/>
            <TextBox Name="MaxLinesTextBox" Width="50" TextChanged="MaxLinesTextBox_TextChanged" VerticalAlignment="Center"/>
            <Button Content="Clear Logs" Click="ClearLogs_Click" Margin="5"/>
        </StackPanel>
        <ListBox Name="LogListBox" Grid.Row="1" Margin="10"/>
    </Grid>
</Window>
C# 코드 파일 (MainWindow.xaml.cs)
csharp
코드 복사
using System;
using System.Collections.Generic;
using System.IO;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Threading;

namespace LogMonitor
{
    public partial class MainWindow : Window
    {
        private FileSystemWatcher _fileWatcher;
        private string _logFilePath;
        private string _backupFolderPath;
        private long _lastFilePosition = 0;
        private int _maxLogLines = 1000;
        private readonly List<string> _logLines = new List<string>();

        private const string ConfigFileName = "config.ini"; // 설정 파일 이름

        public MainWindow()
        {
            InitializeComponent();
            LoadSettings(); // 설정 파일 로드
        }

        // 설정 파일에서 값 로드
        private void LoadSettings()
        {
            if (File.Exists(ConfigFileName))
            {
                var lines = File.ReadAllLines(ConfigFileName);
                foreach (var line in lines)
                {
                    var parts = line.Split('=');
                    if (parts.Length == 2)
                    {
                        var key = parts[0].Trim();
                        var value = parts[1].Trim();
                        if (key == "LogFilePath")
                        {
                            _logFilePath = value;
                        }
                        else if (key == "BackupFolderPath")
                        {
                            _backupFolderPath = value;
                        }
                        else if (key == "MaxLogLines")
                        {
                            if (int.TryParse(value, out int maxLines))
                            {
                                _maxLogLines = maxLines;
                            }
                        }
                    }
                }
            }

            if (!string.IsNullOrEmpty(_logFilePath))
            {
                StartFileWatcher();
            }

            MaxLinesTextBox.Text = _maxLogLines.ToString();
        }

        // 설정 파일에 값 저장
        private void SaveSettings()
        {
            var lines = new List<string>
            {
                $"LogFilePath={_logFilePath}",
                $"BackupFolderPath={_backupFolderPath}",
                $"MaxLogLines={_maxLogLines}"
            };

            File.WriteAllLines(ConfigFileName, lines);
        }

        // 로그 파일 변경 감시 시작
        private void StartFileWatcher()
        {
            if (_fileWatcher != null)
            {
                _fileWatcher.Dispose();
            }

            _fileWatcher = new FileSystemWatcher(Path.GetDirectoryName(_logFilePath))
            {
                Filter = Path.GetFileName(_logFilePath),
                NotifyFilter = NotifyFilters.LastWrite
            };

            _fileWatcher.Changed += OnLogFileChanged;
            _fileWatcher.EnableRaisingEvents = true;
        }

        // 로그 파일이 변경되었을 때 호출되는 이벤트 핸들러
        private async void OnLogFileChanged(object sender, FileSystemEventArgs e)
        {
            await ReadNewLinesAsync();
        }

        // 새로운 로그 라인 읽기 (비동기)
        private async Task ReadNewLinesAsync()
        {
            await Dispatcher.InvokeAsync(() =>
            {
                using (var fs = new FileStream(_logFilePath, FileMode.Open, FileAccess.Read, FileShare.ReadWrite))
                {
                    fs.Seek(_lastFilePosition, SeekOrigin.Begin);

                    using (var sr = new StreamReader(fs))
                    {
                        while (!sr.EndOfStream)
                        {
                            var line = sr.ReadLine();
                            _logLines.Add(line);

                            // ListBox에 로그 라인 추가
                            LogListBox.Items.Add(line);

                            // 백업 폴더에 로그 라인 백업
                            BackupLogLine(line);

                            if (_logLines.Count > _maxLogLines)
                            {
                                _logLines.RemoveAt(0);
                                LogListBox.Items.RemoveAt(0);
                            }
                        }

                        _lastFilePosition = fs.Position;
                    }
                }
            });
        }

        // 백업 폴더에 로그 라인 저장
        private void BackupLogLine(string line)
        {
            if (string.IsNullOrEmpty(_backupFolderPath))
            {
                return;
            }

            var backupFilePath = Path.Combine(_backupFolderPath, $"backup_{DateTime.Now:yyyyMMdd_HHmmss}.log");

            using (var sw = new StreamWriter(backupFilePath, true))
            {
                sw.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {line}");
            }
        }

        // 로그 파일 선택 버튼 클릭 이벤트 핸들러
        private void SelectLogFile_Click(object sender, RoutedEventArgs e)
        {
            var openFileDialog = new Microsoft.Win32.OpenFileDialog();
            if (openFileDialog.ShowDialog() == true)
            {
                _logFilePath = openFileDialog.FileName;
                SaveSettings(); // 설정 저장
                StartFileWatcher();
            }
        }

        // 백업 폴더 선택 버튼 클릭 이벤트 핸들러
        private void SelectBackupFolder_Click(object sender, RoutedEventArgs e)
        {
            var folderDialog = new System.Windows.Forms.FolderBrowserDialog();
            if (folderDialog.ShowDialog() == System.Windows.Forms.DialogResult.OK)
            {
                _backupFolderPath = folderDialog.SelectedPath;
                SaveSettings(); // 설정 저장
            }
        }

        // 로그 지우기 버튼 클릭 이벤트 핸들러
        private void ClearLogs_Click(object sender, RoutedEventArgs e)
        {
            LogListBox.Items.Clear();
            _logLines.Clear();
        }

        // 최대 로그 라인 수 텍스트 박스 변경 이벤트 핸들러
        private void MaxLinesTextBox_TextChanged(object sender, System.Windows.Controls.TextChangedEventArgs e)
        {
            if (int.TryParse(MaxLinesTextBox.Text, out int maxLines))
            {
                _maxLogLines = maxLines;
                SaveSettings(); // 설정 저장
            }
        }
    }
}
설명:
설정 파일 관리 (config.ini):

애플리케이션이 시작할 때 LoadSettings 메서드를 호출하여 config.ini 파일에서 설정 값을 읽습니다.
설정 값에는 LogFilePath (로그 파일 경로), BackupFolderPath (백업 폴더 경로), MaxLogLines (최대 로그 라인 수)가 포함됩니다.
설정이 변경될 때마다 SaveSettings 메서드를 호출하여 변경된 설정을 config.ini 파일에 저장합니다.
파일 감시 및 비동기 처리:

FileSystemWatcher를 사용하여 로그 파일을 실시간으로 감시하며, 파일이 변경될 때마다 OnLogFileChanged 이벤트 핸들러가 비동기적으로 호출됩니다.
ReadNewLinesAsync 메서드는 비동기로 실행되어 UI 스레드를 차단하지 않고 새로운 로그 라인을 읽어옵니다.
백업 및 UI 업데이트:

새로운 로그 라인이 감지되면 BackupLogLine 메서드를 통해 지정된 백업 폴더에 로그를 백업합니다.
로그는 ListBox에 실시간으로 추가되며, 최대 로그 라인 수를 초과하면 오래된 로그부터 삭제됩니다.
이 코드는 사용자 요구사항에 따라 .ini 파일을 사용하여 설정을 저장하고 불러오