토큰 개념을 제거하고, 명령을 전송한 후 PLC의 응답을 기다리는 코드를 간소화한 형태로 다시 작성해드리겠습니다. 이 코드는 명령 전송 후에 STX(시작 문자)에서 ETX(종료 문자)까지 응답을 비동기적으로 읽습니다.

PLC 통신 명령 전송 및 응답 대기 코드 (토큰 제거)
csharp
코드 복사
using System;
using System.IO.Ports;
using System.Text;
using System.Threading.Tasks;

public class PLCCommunication
{
    private SerialPort _serialPort;
    private const byte STX = 0x02;  // Start of Text
    private const byte ETX = 0x03;  // End of Text

    public PLCCommunication(string portName, int baudRate)
    {
        _serialPort = new SerialPort(portName, baudRate, Parity.None, 8, StopBits.One);
        _serialPort.Encoding = Encoding.ASCII; // ASCII 인코딩 설정
        _serialPort.Open();
    }

    // 명령 전송 후 응답을 읽는 함수
    public async Task<string> SendCommandAndWaitForResponseAsync(string command)
    {
        // 1. 명령을 전송한다.
        await SendCommandAsync(command);

        // 2. 응답을 STX부터 ETX까지 기다리고 읽는다.
        string response = await ReadUntilETXAsync();

        return response;  // 완전한 응답 패킷 반환
    }

    // 명령을 전송하는 함수
    private async Task SendCommandAsync(string command)
    {
        if (_serialPort.IsOpen)
        {
            byte[] commandBytes = Encoding.ASCII.GetBytes(command);
            await _serialPort.BaseStream.WriteAsync(commandBytes, 0, commandBytes.Length);
            await _serialPort.BaseStream.FlushAsync();  // 명령 전송 후 플러시
        }
        else
        {
            throw new InvalidOperationException("Serial port is not open.");
        }
    }

    // STX에서 ETX까지 응답을 읽는 함수
    private async Task<string> ReadUntilETXAsync()
    {
        var buffer = new byte[256];
        var stringBuilder = new StringBuilder();
        bool reading = false;  // STX 이후 데이터를 읽기 위한 플래그
        int bytesRead;

        while (true) // 무한 루프를 돌며 응답을 기다림
        {
            // 1. 데이터를 비동기적으로 읽는다.
            bytesRead = await _serialPort.BaseStream.ReadAsync(buffer, 0, buffer.Length);

            // 2. 바이트 배열을 문자로 변환하고 처리한다.
            for (int i = 0; i < bytesRead; i++)
            {
                if (buffer[i] == STX)
                {
                    // STX 문자를 만나면 읽기를 시작한다.
                    reading = true;
                    stringBuilder.Clear();  // 새로운 패킷 시작, 기존 데이터 초기화
                }
                else if (buffer[i] == ETX && reading)
                {
                    // ETX 문자를 만나면 읽기를 종료하고 데이터 반환
                    reading = false;
                    return stringBuilder.ToString();  // ETX가 오면 패킷을 반환
                }
                else if (reading)
                {
                    // STX 이후 ETX 전까지의 데이터를 수집
                    stringBuilder.Append((char)buffer[i]);
                }
            }
        }
    }

    // 시리얼 포트를 닫는 함수
    public void Close()
    {
        if (_serialPort.IsOpen)
        {
            _serialPort.Close();
        }
    }
}
사용 예시 (명령 전송 후 응답 대기)
csharp
코드 복사
public async Task MainAsync()
{
    // 시리얼 포트 설정
    var plcCommunication = new PLCCommunication("COM1", 9600);

    try
    {
        // PLC에 명령을 전송하고 응답을 기다림
        string command = "YOUR_COMMAND";  // PLC에 전송할 명령
        string response = await plcCommunication.SendCommandAndWaitForResponseAsync(command);

        // 응답 처리
        Console.WriteLine($"응답: {response}");
    }
    catch (Exception ex)
    {
        Console.WriteLine($"오류 발생: {ex.Message}");
    }
    finally
    {
        // 시리얼 포트 닫기
        plcCommunication.Close();
    }
}
설명:
SendCommandAndWaitForResponseAsync 함수: PLC에 명령을 전송하고, 그에 대한 응답을 STX부터 ETX까지 기다립니다.

명령은 SendCommandAsync 함수를 통해 PLC에 전송됩니다.
전송 후, ReadUntilETXAsync 함수에서 응답을 기다리고, STX부터 ETX까지의 데이터를 읽습니다.
SendCommandAsync 함수: 명령을 ASCII로 인코딩하여 시리얼 포트로 전송합니다.

ReadUntilETXAsync 함수: PLC에서 받은 데이터를 계속해서 읽다가 STX부터 시작해 ETX에 도달하면 패킷을 반환합니다. 이 함수는 무한 루프를 돌며 응답을 받을 때까지 대기합니다.

토큰 제거: 토큰 개념을 사용하지 않고, 응답이 올 때까지 간단하게 무한 루프를 통해 데이터를 계속 읽는 방식으로 수정하였습니다.

이 코드를 통해 명령을 전